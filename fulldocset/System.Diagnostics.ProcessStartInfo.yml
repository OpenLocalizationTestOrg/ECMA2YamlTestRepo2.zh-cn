### YamlMime:ManagedReference
items:
- uid: System.Diagnostics.ProcessStartInfo
  id: ProcessStartInfo
  children:
  - System.Diagnostics.ProcessStartInfo.#ctor
  - System.Diagnostics.ProcessStartInfo.#ctor(System.String)
  - System.Diagnostics.ProcessStartInfo.#ctor(System.String,System.String)
  - System.Diagnostics.ProcessStartInfo.Arguments
  - System.Diagnostics.ProcessStartInfo.CreateNoWindow
  - System.Diagnostics.ProcessStartInfo.Domain
  - System.Diagnostics.ProcessStartInfo.Environment
  - System.Diagnostics.ProcessStartInfo.EnvironmentVariables
  - System.Diagnostics.ProcessStartInfo.ErrorDialog
  - System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle
  - System.Diagnostics.ProcessStartInfo.FileName
  - System.Diagnostics.ProcessStartInfo.LoadUserProfile
  - System.Diagnostics.ProcessStartInfo.Password
  - System.Diagnostics.ProcessStartInfo.PasswordInClearText
  - System.Diagnostics.ProcessStartInfo.RedirectStandardError
  - System.Diagnostics.ProcessStartInfo.RedirectStandardInput
  - System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
  - System.Diagnostics.ProcessStartInfo.StandardErrorEncoding
  - System.Diagnostics.ProcessStartInfo.StandardOutputEncoding
  - System.Diagnostics.ProcessStartInfo.UserName
  - System.Diagnostics.ProcessStartInfo.UseShellExecute
  - System.Diagnostics.ProcessStartInfo.Verb
  - System.Diagnostics.ProcessStartInfo.Verbs
  - System.Diagnostics.ProcessStartInfo.WindowStyle
  - System.Diagnostics.ProcessStartInfo.WorkingDirectory
  langs:
  - csharp
  name: ProcessStartInfo
  nameWithType: ProcessStartInfo
  fullName: System.Diagnostics.ProcessStartInfo
  type: Class
  summary: "指定一的组在启动进程时使用的值。"
  remarks: "ProcessStartInfo 使用连同<xref:System.Diagnostics.Process>组件。</xref:System.Diagnostics.Process> 当你启动进程使用<xref:System.Diagnostics.Process>类，您有权处理信息以及可用时将附加到正在运行的进程。</xref:System.Diagnostics.Process>       ProcessStartInfo 类可用于更好地控制启动的进程。 至少必须设置<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性，手动或使用构造函数。</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 文件名为任何应用程序或文档。 此处的文档定义任何具有打开的文件类型或默认与之关联的操作。 你可以查看已注册的文件类型和其关联的应用程序为你的计算机使用**文件夹选项**对话框中，这是通过操作系统可用。 **高级**按钮可显示是否与特定的注册的文件类型关联的打开操作的对话框。       此外，你可以设置其他属性，定义要与该文件执行操作。 你可以指定特定于类型的值<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>属性。</xref:System.Diagnostics.ProcessStartInfo.Verb%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 例如，你可以指定&quot;打印&quot;的文档类型。 此外，你可以指定<xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>属性的值进行命令行自变量传递给文件的打开过程。</xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> 例如，如果你指定的文本编辑器应用程序中<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性，可以使用<xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>属性来指定要由编辑器中打开一个文本文件。</xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A>       标准输入通常是键盘，而标准输出和标准错误通常是监视器屏幕。 但是，你可以使用<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A>， <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A>，和<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A>属性使获取输入或将输出返回到一个文件或其他设备的过程。</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> </xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> </xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A> 如果你使用<xref:System.Diagnostics.Process.StandardInput%2A>， <xref:System.Diagnostics.Process.StandardOutput%2A>，或<xref:System.Diagnostics.Process.StandardError%2A>属性<xref:System.Diagnostics.Process>组件，你必须首先的相应值的属性上设置 ProcessStartInfo。</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process.StandardInput%2A> 否则，系统将在读取或写入到流时引发异常。       设置<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>来指定是否使用操作系统 shell 启动进程。</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>       你可以更改最多进程启动的时间任何 ProcessStartInfo 属性的值。 启动过程后，更改这些值不起作用。      1> [!NOTE]&1;> 此类包含在类级别应用于所有成员的链接要求。 A<xref:System.Security.SecurityException>直接调用方没有完全信任权限时，将引发。</xref:System.Security.SecurityException> 有关安全要求的详细信息，请参阅[链接需求](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example demonstrates how to use the ProcessStartInfo class to start Internet Explorer, providing the destination URLs as ProcessStartInfo arguments.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/t-system.diagnostics.pro_2_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/t-system.diagnostics.pro_2_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/t-system.diagnostics.pro_2_1.cpp)]"
  syntax:
    content: >-
      [System.ComponentModel.TypeConverter(typeof(System.ComponentModel.ExpandableObjectConverter))]

      public sealed class ProcessStartInfo
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.#ctor
  id: '#ctor'
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: ProcessStartInfo()
  nameWithType: ProcessStartInfo.ProcessStartInfo()
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo()
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "初始化的新实例<xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;></xref>不指定启动进程使用的文件名称的类。"
  remarks: "必须设置至少<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性之前在开始执行过程。</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 文件名为任何应用程序或文档。 在这种情况下，将文档定义任何具有打开的文件类型或默认与之关联的操作。 你可以查看已注册的文件类型和其关联的应用程序为你的计算机使用**文件夹选项**对话框中，这是通过操作系统可用。 **高级**按钮可显示是否与特定的注册的文件类型关联的打开操作的对话框。       （可选） 在开始过程之前，还可以设置其他属性。 <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>属性提供要执行，如&quot;打印&quot;中指示的文件与操作<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性。</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.ProcessStartInfo.Verb%2A> <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>属性提供了一种将命令行参数传送到文件时系统会打开它。</xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>"
  syntax:
    content: public ProcessStartInfo ();
    parameters: []
  overload: System.Diagnostics.ProcessStartInfo.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.#ctor(System.String)
  id: '#ctor(System.String)'
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: ProcessStartInfo(String)
  nameWithType: ProcessStartInfo.ProcessStartInfo(String)
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo(String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "初始化的新实例<xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;></xref>类，并指定一个文件名称，例如应用程序或启动进程使用的文档。"
  remarks: "文件名为任何应用程序或文档。 在这种情况下，将文档定义任何具有打开的文件类型或默认与之关联的操作。 你可以查看已注册的文件类型和其关联的应用程序为你的计算机使用**文件夹选项**对话框中，这是通过操作系统可用。 **高级**按钮可显示是否与特定的注册的文件类型关联的打开操作的对话框。       你可以更改<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性后调用此构造函数，进程启动的时间。</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 启动过程后，更改这些值不起作用。"
  syntax:
    content: public ProcessStartInfo (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "应用程序或启动一个进程使用的文档。"
  overload: System.Diagnostics.ProcessStartInfo.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.#ctor(System.String,System.String)
  id: '#ctor(System.String,System.String)'
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: ProcessStartInfo(String,String)
  nameWithType: ProcessStartInfo.ProcessStartInfo(String,String)
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo(String,String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "初始化的新实例<xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;></xref>类，指定启动该过程中，使用的应用程序文件名称，并指定一组命令行自变量传递给应用程序。"
  remarks: "文件名为任何应用程序或文档。 在这种情况下，将文档定义任何具有打开的文件类型或默认与之关联的操作。 你可以查看已注册的文件类型和其关联的应用程序为你的计算机使用**文件夹选项**对话框中，这是通过操作系统可用。 **高级**按钮可显示是否与特定的注册的文件类型关联的打开操作的对话框。       你可以更改<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>或<xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>属性后调用此构造函数，进程启动的时间。</xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 启动过程后，更改这些值不起作用。"
  syntax:
    content: public ProcessStartInfo (string fileName, string arguments);
    parameters:
    - id: fileName
      type: System.String
      description: "若要启动的进程使用的应用程序。"
    - id: arguments
      type: System.String
      description: "进程启动时要传递给应用程序的命令行参数。"
  overload: System.Diagnostics.ProcessStartInfo.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.Arguments
  id: Arguments
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: Arguments
  nameWithType: ProcessStartInfo.Arguments
  fullName: System.Diagnostics.ProcessStartInfo.Arguments
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置命令行参数启动该应用程序时要使用的集。"
  remarks: ''
  example:
  - "The first example below creates a small application (argsecho.exe) that echos its arguments to the console. The second example creates an application that invokes argsecho.exe to demonstrate different variations for the Arguments property.  \n  \n [!code-vb[Process.Start_static#3](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_2_1.vb)]\n [!code-cs[Process.Start_static#3](~/add/codesnippet/csharp/p-system.diagnostics.pro_2_1.cs)]\n [!code-cpp[Process.Start_static#3](~/add/codesnippet/cpp/p-system.diagnostics.pro_2_1.cpp)]  \n  \n [!code-vb[Process.Start_static#2](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_2_2.vb)]\n [!code-cs[Process.Start_static#2](~/add/codesnippet/csharp/p-system.diagnostics.pro_2_2.cs)]\n [!code-cpp[Process.Start_static#2](~/add/codesnippet/cpp/p-system.diagnostics.pro_2_2.cpp)]"
  syntax:
    content: public string Arguments { get; set; }
    return:
      type: System.String
      description: "单个字符串包含要传递到目标应用程序中指定的参数<xref:System.Diagnostics.ProcessStartInfo.FileName*>属性。</xref:System.Diagnostics.ProcessStartInfo.FileName*> 默认值为空字符串 (&quot;&quot;)。 在 Windows Vista 和早期版本的 Windows 操作系统上，添加到过程的完整路径的长度的自变量的长度必须小于 2080年。 在 Windows 7 和更高版本，长度必须小于 32699。       自变量的分析和解释方式由目标应用程序，因此必须与该应用程序的预期保持一致。 对于应用程序作为示例说明了以下，空格被解释为多个自变量之间的分隔符。 包含空格的单个参数必须用引号引起来，但这些引号不会传递到目标应用程序。 在包括引号在内的最终已分析自变量，三重转义每个标记。"
  overload: System.Diagnostics.ProcessStartInfo.Arguments*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.CreateNoWindow
  id: CreateNoWindow
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: CreateNoWindow
  nameWithType: ProcessStartInfo.CreateNoWindow
  fullName: System.Diagnostics.ProcessStartInfo.CreateNoWindow
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置一个值，该值指示是否在新窗口中启动进程。"
  remarks: "如果<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>属性是`true`或<xref:System.Diagnostics.ProcessStartInfo.UserName%2A>和<xref:System.Diagnostics.ProcessStartInfo.Password%2A>属性不`null`，将忽略 CreateNoWindow 属性值，并且创建一个新窗口。</xref:System.Diagnostics.ProcessStartInfo.Password%2A> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>"
  example:
  - >-
    [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_19_1.cpp)]
     [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_19_1.vb)]
     [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_19_1.cs)]
  syntax:
    content: public bool CreateNoWindow { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果应启动进程而无需创建一个新窗口以包含它;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Diagnostics.ProcessStartInfo.CreateNoWindow*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.Domain
  id: Domain
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: Domain
  nameWithType: ProcessStartInfo.Domain
  fullName: System.Diagnostics.ProcessStartInfo.Domain
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置一个值，标识要启动该进程时使用的域。"
  syntax:
    content: public string Domain { get; set; }
    return:
      type: System.String
      description: "要启动该进程时使用的 Active Directory 域。 域属性主要是感兴趣使用 Active Directory 的企业级环境内的用户。"
  overload: System.Diagnostics.ProcessStartInfo.Domain*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.Environment
  id: Environment
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: Environment
  nameWithType: ProcessStartInfo.Environment
  fullName: System.Diagnostics.ProcessStartInfo.Environment
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取应用于此进程及其子进程的环境变量。"
  remarks: "The environment variables contain search paths for files, directories for temporary files, application-specific options, and other similar information. Although you cannot directly set the Environment property, you can modify the generic dictionary returned by the property. For example, the following code adds a TempPath environment variable: `myProcess.StartInfo.Environment.Add(\"TempPath\", \"C:\\\\Temp\")`.  You must set the <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> property to `false` to start the process after changing the Environment property. If <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true`, an <xref:System.InvalidOperationException> is thrown when the <xref:System.Diagnostics.Process.Start%2A> method is called.  \n  \n On .NET Framework applications, using the Environment property is the same as using the <xref:System.Diagnostics.ProcessStartInfo.EnvironmentVariables%2A> property."
  syntax:
    content: public System.Collections.Generic.IDictionary<string,string> Environment { get; }
    return:
      type: System.Collections.Generic.IDictionary{System.String,System.String}
      description: "一个包含应用于此进程及其子进程的环境变量的泛型字典。 默认值是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Diagnostics.ProcessStartInfo.Environment*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.EnvironmentVariables
  id: EnvironmentVariables
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: EnvironmentVariables
  nameWithType: ProcessStartInfo.EnvironmentVariables
  fullName: System.Diagnostics.ProcessStartInfo.EnvironmentVariables
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取搜索文件的路径、 临时文件、 应用程序特定的选项和其他类似信息的目录。"
  remarks: '虽然不能设置 EnvironmentVariables 属性，可修改<xref:System.Collections.Specialized.StringDictionary>属性返回。</xref:System.Collections.Specialized.StringDictionary> 例如，下面的代码添加 TempPath 环境变量︰ `myProcess.StartInfo.EnvironmentVariables.Add(&quot;TempPath&quot;, &quot;C:\\Temp&quot;)`。  必须设置<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>属性`false`更改 EnvironmentVariables 属性后启动该进程。</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 如果<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`true`、<xref:System.InvalidOperationException>时，将引发<xref:System.Diagnostics.Process.Start%2A>调用方法。</xref:System.Diagnostics.Process.Start%2A> </xref:System.InvalidOperationException> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>'
  syntax:
    content: public System.Collections.Specialized.StringDictionary EnvironmentVariables { get; }
    return:
      type: System.Collections.Specialized.StringDictionary
      description: "一个字符串字典，其中提供应用于此进程以及子进程的环境变量。 默认值是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Diagnostics.ProcessStartInfo.EnvironmentVariables*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.ErrorDialog
  id: ErrorDialog
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: ErrorDialog
  nameWithType: ProcessStartInfo.ErrorDialog
  fullName: System.Diagnostics.ProcessStartInfo.ErrorDialog
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置一个值，该值不能启动进程时是否向用户显示错误对话框。"
  remarks: >-
    > [!NOTE]

    >  <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> must be `true` if you want to set ErrorDialog to `true`.
  syntax:
    content: public bool ErrorDialog { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果应在屏幕上显示错误对话框，如果不能启动进程;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Diagnostics.ProcessStartInfo.ErrorDialog*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle
  id: ErrorDialogParentHandle
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: ErrorDialogParentHandle
  nameWithType: ProcessStartInfo.ErrorDialogParentHandle
  fullName: System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置错误对话框显示无法启动的进程时要使用的窗口句柄。"
  remarks: "如果<xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A>是`true`，ErrorDialogParentHandle 属性指定显示的对话框中的父窗口。</xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A> 它可用于指定父保留应用程序的前面的对话框。"
  syntax:
    content: public IntPtr ErrorDialogParentHandle { get; set; }
    return:
      type: System.IntPtr
      description: "指向结果的进程启动失败的错误对话框中的句柄的指针。"
  overload: System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.FileName
  id: FileName
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: FileName
  nameWithType: ProcessStartInfo.FileName
  fullName: System.Diagnostics.ProcessStartInfo.FileName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置要启动的应用程序或文档。"
  remarks: "你必须设置至少 FileName 属性之前在开始执行过程。 文件名为任何应用程序或文档。 将文档定义任何具有打开的文件类型或默认与之关联的操作。 你可以查看已注册的文件类型和其关联的应用程序为你的计算机使用**文件夹选项**对话框中，这是通过操作系统可用。 **高级**按钮可显示是否与特定的注册的文件类型关联的打开操作的对话框。       可供你的文件类型的一套部分取决于值<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>属性。</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 如果<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`true`，可以启动任何文档，还可以对文件执行操作，如打印与<xref:System.Diagnostics.Process>组件。</xref:System.Diagnostics.Process> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 当<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`false`，你可以开始仅可执行文件与<xref:System.Diagnostics.Process>组件。</xref:System.Diagnostics.Process> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>       可以通过将 FileName 属性设置为最初从中安装应用程序的位置 （例如，Web 地址） 来启动 ClickOnce 应用程序。 不通过指定其安装的位置在硬盘上启动 ClickOnce 应用程序。"
  example:
  - >-
    [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_27_1.cpp)]
     [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_27_1.vb)]
     [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_27_1.cs)]
  syntax:
    content: public string FileName { get; set; }
    return:
      type: System.String
      description: "若要开始，应用程序的名称或应用程序与该键相关联，并具有的默认打开操作对其可用的文件类型的文档的名称。 默认值为空字符串 (&quot;&quot;)。"
  overload: System.Diagnostics.ProcessStartInfo.FileName*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.LoadUserProfile
  id: LoadUserProfile
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: LoadUserProfile
  nameWithType: ProcessStartInfo.LoadUserProfile
  fullName: System.Diagnostics.ProcessStartInfo.LoadUserProfile
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置一个值，该值指示是否要从注册表加载 Windows 用户配置文件。"
  remarks: "如果正在使用的用户名、 密码和域启动的过程，将引用此属性。       如果值为`true`中的用户的配置文件`HKEY_USERS`加载注册表项。 加载配置文件可能非常耗时。 因此，最好使用此值仅在必须访问中的信息`HKEY_CURRENT_USER`注册表项。       在 Windows Server 2003 和 Windows 2000 中，配置文件被卸载，新进程终止后，无论是否创建的过程具有子进程。       在 Windows XP 中，配置文件后卸载新的进程并且它已创建的所有子进程已都终止。"
  syntax:
    content: public bool LoadUserProfile { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果应加载 Windows 用户配置文件;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Diagnostics.ProcessStartInfo.LoadUserProfile*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.Password
  id: Password
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: Password
  nameWithType: ProcessStartInfo.Password
  fullName: System.Diagnostics.ProcessStartInfo.Password
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置包含启动进程时要使用的用户密码的安全字符串。"
  remarks: "> [!IMPORTANT]\n>  The <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> property must be set if <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> and Password are provided. If the property is not set, the default working directory is %SYSTEMROOT%\\system32.  \n  \n> [!NOTE]\n>  Setting the <xref:System.Diagnostics.ProcessStartInfo.Domain%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, and the Password properties in a <xref:System.Diagnostics.ProcessStartInfo> object is the recommended practice for starting a process with user credentials.  \n  \n A <xref:System.Security.SecureString> object is like a <xref:System.String> object in that it has a text value. However, the value of a <xref:System.Security.SecureString> object is automatically encrypted, it can be modified until your application marks it as read-only, and it can be deleted from computer memory by either your application or the .NET Framework garbage collector.  \n  \n For more information about secure strings and an example of how to obtain a password to set this property, see the <xref:System.Security.SecureString> class.  \n  \n> [!NOTE]\n>  If you provide a value for the Password property, the <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> property must be `false`, or an <xref:System.InvalidOperationException> will be thrown when the <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=fullName> method is called."
  syntax:
    content: public System.Security.SecureString Password { get; set; }
    return:
      type: System.Security.SecureString
      description: "用于启动进程时使用的用户密码。"
  overload: System.Diagnostics.ProcessStartInfo.Password*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.PasswordInClearText
  id: PasswordInClearText
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: PasswordInClearText
  nameWithType: ProcessStartInfo.PasswordInClearText
  fullName: System.Diagnostics.ProcessStartInfo.PasswordInClearText
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置以明文形式启动进程时要使用的用户密码。"
  syntax:
    content: public string PasswordInClearText { get; set; }
    return:
      type: System.String
      description: "用户密码以明文形式。"
  overload: System.Diagnostics.ProcessStartInfo.PasswordInClearText*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardError
  id: RedirectStandardError
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: RedirectStandardError
  nameWithType: ProcessStartInfo.RedirectStandardError
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardError
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置一个值，该值指示是否将应用程序的错误输出写入到&lt;xref:System.Diagnostics.Process.StandardError%2A?displayProperty=fullName&gt;流。"
  remarks: "当<xref:System.Diagnostics.Process>将文本写入其标准错误流中，通常在控制台上显示文本。</xref:System.Diagnostics.Process> 通过将重定向<xref:System.Diagnostics.Process.StandardError%2A>流，你可以操作或取消进程的错误输出。</xref:System.Diagnostics.Process.StandardError%2A> 例如，你可以筛选文本、 格式设置不同，或将输出写入控制台和一个指定的日志文件。      1> [!NOTE]&1;> 必须设置<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>到`false`如果你想要设置为 RedirectStandardError `true`。</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 否则，读取从<xref:System.Diagnostics.Process.StandardError%2A>流时将引发异常。</xref:System.Diagnostics.Process.StandardError%2A>       重定向<xref:System.Diagnostics.Process.StandardError%2A>可以读取流，同步或异步。</xref:System.Diagnostics.Process.StandardError%2A> 等方法<xref:System.IO.StreamReader.Read%2A>，<xref:System.IO.StreamReader.ReadLine%2A>和<xref:System.IO.StreamReader.ReadToEnd%2A>同步对执行读取的操作的错误输出流的过程。</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> 这些同步读取操作不会完成之前关联<xref:System.Diagnostics.Process>写入其<xref:System.Diagnostics.Process.StandardError%2A>流处理时，或关闭流。</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process>       与此相反，<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>开始异步读取操作上<xref:System.Diagnostics.Process.StandardError%2A>流。</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 此方法将启用流输出指定的事件处理程序并立即返回到调用方，流输出定向到事件处理程序时可以执行其他工作。      1> [!NOTE]&1;> 正在处理的异步输出应用程序应调用<xref:System.Diagnostics.Process.WaitForExit%2A>方法，以确保已刷新输出缓冲区。</xref:System.Diagnostics.Process.WaitForExit%2A>       同步读取操作引入读取从调用方之间的依赖项<xref:System.Diagnostics.Process.StandardError%2A>流和子进程的写入该流。</xref:System.Diagnostics.Process.StandardError%2A> 这些依赖关系可能会导致死锁条件。 当调用方读取子进程的重定向流时，它是依赖于子。 调用方等待读取操作，直到子写入流或关闭流。 子进程在编写时数据不足，无法填充其重定向的流，它是依赖于父。 子进程等待下一步的写入操作，直到的父项从完整的流中读取或关闭流。 当调用方和子进程等待其他来完成操作，并都可以继续，将产生死锁条件。 可以通过评估的调用方和子进程之间的依赖关系来避免死锁。       例如，下面的 C# 代码演示如何从重定向流中读取和等待子进程退出。      ```   // Start the child process.    Process p = new Process();    // Redirect the error stream of the child process.    p.StartInfo.UseShellExecute = false;    p.StartInfo.RedirectStandardError = true;    p.StartInfo.FileName = &quot;Write500Lines.exe&quot;;    p.Start();    // Do not wait for the child process to exit before    // reading to the end of its redirected error stream.    // p.WaitForExit();    // Read the error stream first and then wait.    string error = p.StandardError.ReadToEnd();    p.WaitForExit();   ```下面的代码示例通过调用来避免死锁条件`p.StandardError.ReadToEnd`之前`p.WaitForExit`。 如果父进程调用会导致死锁条件`p.WaitForExit`之前`p.StandardError.ReadToEnd`和子进程将足够多的文本以填充重定向的流。 父进程将无限期地等待子进程退出。 子进程将无限期地等待父从完整读取<xref:System.Diagnostics.Process.StandardError%2A>流。</xref:System.Diagnostics.Process.StandardError%2A>       从标准输出和标准错误流读取所有文本时类似问题。 例如，下面的 C# 代码执行对这两种流的读取的操作。      ```   // Do not perform a synchronous read to the end of both   // redirected streams.   // string output = p.StandardOutput.ReadToEnd();   // string error = p.StandardError.ReadToEnd();   // p.WaitForExit();   // Use asynchronous read operations on at least one of the streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```下面的代码示例通过执行异步上读取操作来避免死锁条件<xref:System.Diagnostics.Process.StandardOutput%2A>流。</xref:System.Diagnostics.Process.StandardOutput%2A> 死锁条件结果如果父进程调用`p.StandardOutput.ReadToEnd`跟`p.StandardError.ReadToEnd`和子进程将足够多的文本以填充其错误流。 父进程将无限期地等待子进程以关闭其<xref:System.Diagnostics.Process.StandardOutput%2A>流。</xref:System.Diagnostics.Process.StandardOutput%2A> 子进程将无限期地等待父从完整读取<xref:System.Diagnostics.Process.StandardError%2A>流。</xref:System.Diagnostics.Process.StandardError%2A>       异步读取的操作可用于避免这些依赖关系和其潜在的死锁。 或者，可以通过创建两个线程并读取在单独线程上的每个流的输出来避免出现死锁条件。"
  example:
  - "The following example uses the `net use` command together with a user-supplied argument to map a network resource. It then reads the standard error stream of the net command and writes it to console.  \n  \n [!code-cs[Process_StandardError#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_31_1.cs)]\n [!code-cpp[Process_StandardError#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_31_1.cpp)]\n [!code-vb[Process_StandardError#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_31_1.vb)]"
  syntax:
    content: public bool RedirectStandardError { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果错误输出应写入&lt;xref:System.Diagnostics.Process.StandardError%2A?displayProperty=fullName&gt;; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Diagnostics.ProcessStartInfo.RedirectStandardError*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardInput
  id: RedirectStandardInput
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: RedirectStandardInput
  nameWithType: ProcessStartInfo.RedirectStandardInput
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardInput
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置一个值，该值指示是否从读取应用程序输入&lt;xref:System.Diagnostics.Process.StandardInput%2A?displayProperty=fullName&gt;流。"
  remarks: "A<xref:System.Diagnostics.Process>可以从其标准的输入流，通常是键盘读取输入的文本。</xref:System.Diagnostics.Process> 通过将重定向<xref:System.Diagnostics.Process.StandardInput%2A>流，你可以以编程方式指定进程的输入。</xref:System.Diagnostics.Process.StandardInput%2A> 例如，而不是使用键盘输入，你可以提供从指定文件的内容的文本或从另一个应用程序的输出。      1> [!NOTE]&1;> 必须设置<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>到`false`如果你想要设置为 RedirectStandardInput `true`。</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 否则，写入<xref:System.Diagnostics.Process.StandardInput%2A>流时将引发异常。</xref:System.Diagnostics.Process.StandardInput%2A>"
  example:
  - "The following example illustrates how to redirect the <xref:System.Diagnostics.Process.StandardInput%2A> stream of a process. The `sort` command is a console application that reads and sorts text input.  \n  \n The example starts the `sort` command with redirected input. It then prompts the user for text, and passes the text to the `sort` process through the redirected <xref:System.Diagnostics.Process.StandardInput%2A> stream. The `sort` results are displayed to the user on the console.  \n  \n [!code-cs[Process_StandardInput#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_43_1.cs)]\n [!code-cpp[Process_StandardInput#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_43_1.cpp)]\n [!code-vb[Process_StandardInput#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_43_1.vb)]"
  syntax:
    content: public bool RedirectStandardInput { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果应从读取输入&lt;xref:System.Diagnostics.Process.StandardInput%2A?displayProperty=fullName&gt;; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Diagnostics.ProcessStartInfo.RedirectStandardInput*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
  id: RedirectStandardOutput
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: RedirectStandardOutput
  nameWithType: ProcessStartInfo.RedirectStandardOutput
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置一个值，该值指示是否将应用程序文本输出写入&lt;xref:System.Diagnostics.Process.StandardOutput%2A?displayProperty=fullName&gt;流。"
  remarks: "当<xref:System.Diagnostics.Process>将文本写入其标准的流，通常在控制台上显示文本。</xref:System.Diagnostics.Process> 通过设置为 RedirectStandardOutput`true`重定向<xref:System.Diagnostics.Process.StandardOutput%2A>流，你可以操作或取消进程的输出。</xref:System.Diagnostics.Process.StandardOutput%2A> 例如，你可以筛选文本、 格式设置不同，或将输出写入控制台和一个指定的日志文件。      1> [!NOTE]&1;> 必须设置<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>到`false`如果你想要设置为 RedirectStandardOutput `true`。</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 否则，读取从<xref:System.Diagnostics.Process.StandardOutput%2A>流时将引发异常。</xref:System.Diagnostics.Process.StandardOutput%2A>       重定向<xref:System.Diagnostics.Process.StandardOutput%2A>可以读取流，同步或异步。</xref:System.Diagnostics.Process.StandardOutput%2A> 等方法<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，和<xref:System.IO.StreamReader.ReadToEnd%2A>同步对执行读取的操作过程的输出流。</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> 这些同步读取操作不会完成之前关联<xref:System.Diagnostics.Process>写入其<xref:System.Diagnostics.Process.StandardOutput%2A>流处理时，或关闭流。</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       与此相反，<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>开始异步读取操作上<xref:System.Diagnostics.Process.StandardOutput%2A>流。</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 此方法使指定的事件处理程序 (请参阅<xref:System.Diagnostics.Process.OutputDataReceived>) 的输出进行流式处理并立即将返回到调用方，这可以时执行其他工作流输出定向到事件处理程序。</xref:System.Diagnostics.Process.OutputDataReceived>      1> [!NOTE]&1;> 正在处理的异步输出应用程序应调用<xref:System.Diagnostics.Process.WaitForExit%2A>方法，以确保已刷新输出缓冲区。</xref:System.Diagnostics.Process.WaitForExit%2A>       同步读取操作引入读取从调用方之间的依赖项<xref:System.Diagnostics.Process.StandardOutput%2A>流和子进程的写入该流。</xref:System.Diagnostics.Process.StandardOutput%2A> 这些依赖关系可能会导致死锁条件。 当调用方读取子进程的重定向流时，它是依赖于子。 调用方等待读取操作，直到子写入流或关闭流。 子进程在编写时数据不足，无法填充其重定向的流，它是依赖于父。 子进程等待下一步的写入操作，直到的父项从完整的流中读取或关闭流。 当调用方和子进程等待其他来完成操作，并都可以继续，将产生死锁条件。 可以通过评估的调用方和子进程之间的依赖关系来避免死锁。       例如，下面的 C# 代码演示如何从重定向流中读取和等待子进程退出。      ```   Process p = new Process();   p.StartInfo.UseShellExecute = false;   p.StartInfo.RedirectStandardOutput = true;   p.StartInfo.FileName = &quot;Write500Lines.exe&quot;;   p.Start();      // To avoid deadlocks, always read the output stream first and then wait.   string output = p.StandardOutput.ReadToEnd();   p.WaitForExit();   ```下面的代码示例通过调用来避免死锁条件`p.StandardOutput.ReadToEnd`之前`p.WaitForExit`。 如果父进程调用会导致死锁条件`p.WaitForExit`之前`p.StandardOutput.ReadToEnd`和子进程将足够多的文本以填充重定向的流。 父进程将无限期地等待子进程退出。 子进程将无限期地等待父从完整读取<xref:System.Diagnostics.Process.StandardOutput%2A>流。</xref:System.Diagnostics.Process.StandardOutput%2A>       从标准输出和标准错误流读取所有文本时类似问题。 例如，下面的 C# 代码执行对这两种流的读取的操作。      ```   // To avoid deadlocks, use asynchronous read operations on at least one of the streams.   // Do not perform a synchronous read to the end of both redirected streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```下面的代码示例通过执行异步上读取操作来避免死锁条件<xref:System.Diagnostics.Process.StandardOutput%2A>流。</xref:System.Diagnostics.Process.StandardOutput%2A> 死锁条件结果如果父进程调用`p.StandardOutput.ReadToEnd`跟`p.StandardError.ReadToEnd`和子进程将足够多的文本以填充其错误流。 父进程将无限期地等待子进程以关闭其<xref:System.Diagnostics.Process.StandardOutput%2A>流。</xref:System.Diagnostics.Process.StandardOutput%2A> 子进程将无限期地等待父从完整读取<xref:System.Diagnostics.Process.StandardError%2A>流。</xref:System.Diagnostics.Process.StandardError%2A>       异步读取的操作可用于避免这些依赖关系和其潜在的死锁。 或者，可以通过创建两个线程并读取在单独线程上的每个流的输出来避免出现死锁条件。"
  example:
  - >-
    [!code-cpp[ProcessOneStream#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_20_1.cpp)]
     [!code-cs[ProcessOneStream#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_20_1.cs)]
     [!code-vb[ProcessOneStream#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_20_1.vb)]
  syntax:
    content: public bool RedirectStandardOutput { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果输出应写入到&lt;xref:System.Diagnostics.Process.StandardOutput%2A?displayProperty=fullName&gt;; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding
  id: StandardErrorEncoding
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: StandardErrorEncoding
  nameWithType: ProcessStartInfo.StandardErrorEncoding
  fullName: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置错误输出的首选编码。"
  remarks: "如果 StandardErrorEncoding 属性的值是`null`，进程使用错误输出的默认标准错误编码。 启动该过程之前，必须设置 StandardErrorEncoding 属性。 设置此属性不能保证该进程将使用指定的编码;该进程将使用这些它支持的编码。 应测试应用程序，以确定受支持的编码。"
  syntax:
    content: public System.Text.Encoding StandardErrorEncoding { get; set; }
    return:
      type: System.Text.Encoding
      description: "一个表示错误输出的首选的编码的对象。 默认值是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding
  id: StandardOutputEncoding
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: StandardOutputEncoding
  nameWithType: ProcessStartInfo.StandardOutputEncoding
  fullName: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置标准输出的首选编码。"
  remarks: "如果 StandardOutputEncoding 属性的值是`null`，进程使用标准输出的默认标准输出编码。 启动该过程之前，必须设置 StandardOutputEncoding 属性。 设置此属性不能保证该进程将使用指定的编码。 应测试应用程序，以确定该过程支持的编码。"
  syntax:
    content: public System.Text.Encoding StandardOutputEncoding { get; set; }
    return:
      type: System.Text.Encoding
      description: "表示标准输出的首选的编码的对象。 默认值是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.UserName
  id: UserName
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: UserName
  nameWithType: ProcessStartInfo.UserName
  fullName: System.Diagnostics.ProcessStartInfo.UserName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置要启动该进程时使用的用户名。"
  remarks: "> [!IMPORTANT]\n>  The <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> property must be set if UserName and <xref:System.Diagnostics.ProcessStartInfo.Password%2A> are provided. If the property is not set, the default working directory is %SYSTEMROOT%\\system32.  \n  \n If the UserName property is not `null` or an empty string, the <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> property must be `false`, or an <xref:System.InvalidOperationException> will be thrown when the <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=fullName> method is called."
  syntax:
    content: public string UserName { get; set; }
    return:
      type: System.String
      description: "启动进程时要使用的用户名。"
  overload: System.Diagnostics.ProcessStartInfo.UserName*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.UseShellExecute
  id: UseShellExecute
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: UseShellExecute
  nameWithType: ProcessStartInfo.UseShellExecute
  fullName: System.Diagnostics.ProcessStartInfo.UseShellExecute
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置一个值，该值指示是否使用操作系统 shell 启动进程。"
  remarks: "此属性设置为`false`使您能够重定向输入、 输出和错误流。      1> [!NOTE]&1;> 必须 UseShellExecute`false`如果<xref:System.Diagnostics.ProcessStartInfo.UserName%2A>属性不是`null`或空字符串，或<xref:System.InvalidOperationException>时将引发<xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=fullName>调用方法。</xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=fullName> </xref:System.InvalidOperationException> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A>       当使用操作系统 shell 启动进程时，你可以启动任何文档 （这是与默认打开操作的可执行文件关联的任何已注册的文件类型），并对文件执行操作，如打印，通过使用<xref:System.Diagnostics.Process>对象。</xref:System.Diagnostics.Process> UseShellExecute 时`false`，您可以通过使用启动仅可执行文件<xref:System.Diagnostics.Process>对象。</xref:System.Diagnostics.Process>      1> [!NOTE]&1;> 必须 UseShellExecute`true`如果你设置<xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A>属性`true`。</xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A>       <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>属性的行为具体取决于 UseShellExecute 属性的值。</xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> UseShellExecute 时`true`、<xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>属性指定的可执行文件的位置。</xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> 如果<xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>为空字符串，则假定当前目录包含可执行文件。</xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>       UseShellExecute 时`false`、<xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>属性不用于查找可执行文件。</xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> 相反，它仅由已启动并且具有仅在新进程的上下文内的含义的进程使用。 UseShellExecute 时`false`、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性可以是可执行文件的完全限定的路径，或是简单的可执行文件名称，系统将尝试查找在 PATH 环境变量所指定的文件夹内。</xref:System.Diagnostics.ProcessStartInfo.FileName%2A>"
  example:
  - >-
    [!code-cpp[ProcessOneStream#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_44_1.cpp)]
     [!code-cs[ProcessOneStream#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_44_1.cs)]
     [!code-vb[ProcessOneStream#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_44_1.vb)]
  syntax:
    content: public bool UseShellExecute { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果在启动进程; 时，应使用命令行界面<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>如果应直接从可执行文件创建的过程。 默认值是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。"
  overload: System.Diagnostics.ProcessStartInfo.UseShellExecute*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.Verb
  id: Verb
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: Verb
  nameWithType: ProcessStartInfo.Verb
  fullName: System.Diagnostics.ProcessStartInfo.Verb
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置要在打开应用程序或由指定的文档时使用的谓词<xref:System.Diagnostics.ProcessStartInfo.FileName*>属性。</xref:System.Diagnostics.ProcessStartInfo.FileName*>"
  remarks: "每个文件扩展名具有其自己的一组谓词，可获取通过使用<xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>属性。</xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> 例如，&quot;`print`&quot;谓词将打印指定通过使用<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>。</xref:System.Diagnostics.ProcessStartInfo.FileName%2A>文档 可以通过使用一个空字符串指定默认的谓词 (&quot;&quot;)。 谓词的示例包括&quot;编辑&quot;、&quot;打开&quot;、&quot;OpenAsReadOnly&quot;、&quot;打印&quot;和&quot;Printto&quot;。 应使用的一组返回的谓词中显示的谓词<xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>属性。</xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>       当你使用的谓词属性时，设置的值时，你必须包括的文件扩展名<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性。</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 文件名称不必具有扩展名，如果你手动输入谓词属性的值。"
  example:
  - "The following code example starts a new process by using the specified verb and file name. This code example is part of a larger example provided for the <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> property.  \n  \n [!code-vb[ProcessVerbs_Diagnostics#4](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_9_1.vb)]\n [!code-cs[ProcessVerbs_Diagnostics#4](~/add/codesnippet/csharp/p-system.diagnostics.pro_9_1.cs)]"
  syntax:
    content: public string Verb { get; set; }
    return:
      type: System.String
      description: "要与对进程打开的文件执行的操作。 默认值为空字符串 (&quot;&quot;)，它表示没有操作。"
  overload: System.Diagnostics.ProcessStartInfo.Verb*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.Verbs
  id: Verbs
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: Verbs
  nameWithType: ProcessStartInfo.Verbs
  fullName: System.Diagnostics.ProcessStartInfo.Verbs
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取的一组与指定的文件类型关联的谓词<xref:System.Diagnostics.ProcessStartInfo.FileName*>属性。</xref:System.Diagnostics.ProcessStartInfo.FileName*>"
  remarks: "Verbs 属性使您能够确定可与指定的文件使用的谓词<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性。</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 你可以设置<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>属性集中的任何谓词的值。</xref:System.Diagnostics.ProcessStartInfo.Verb%2A> 谓词的示例包括&quot;编辑&quot;、&quot;打开&quot;、&quot;OpenAsReadOnly&quot;、&quot;打印&quot;和&quot;Printto&quot;。       当你使用的 Verbs 属性时，设置的值时，你必须包括的文件扩展名<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性。</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 文件扩展名确定一的组可能的谓词。"
  example:
  - "The following code example displays the defined verbs for the chosen file name. If the user selects one of the defined verbs, the example starts a new process using the selected verb and the input file name.  \n  \n [!code-vb[ProcessVerbs_Diagnostics#3](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_7_1.vb)]\n [!code-cs[ProcessVerbs_Diagnostics#3](~/add/codesnippet/csharp/p-system.diagnostics.pro_7_1.cs)]"
  syntax:
    content: public string[] Verbs { get; }
    return:
      type: System.String[]
      description: "系统可以应用于文件的操作由<xref:System.Diagnostics.ProcessStartInfo.FileName*>属性。</xref:System.Diagnostics.ProcessStartInfo.FileName*>"
  overload: System.Diagnostics.ProcessStartInfo.Verbs*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.WindowStyle
  id: WindowStyle
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: WindowStyle
  nameWithType: ProcessStartInfo.WindowStyle
  fullName: System.Diagnostics.ProcessStartInfo.WindowStyle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置要在启动进程时使用的窗口状态。"
  remarks: ''
  example:
  - >-
    [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_42_1.vb)]
     [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_42_1.cs)]
     [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_42_1.cpp)]
  syntax:
    content: public System.Diagnostics.ProcessWindowStyle WindowStyle { get; set; }
    return:
      type: System.Diagnostics.ProcessWindowStyle
      description: "一个枚举值，该值指示是否在最大化，窗口中启动进程最小化，正常 （即非最大化也非最小化），或不可见。 默认值是<xref uid=&quot;langword_csharp_Normal&quot; name=&quot;Normal&quot; href=&quot;&quot;> </xref>。"
  overload: System.Diagnostics.ProcessStartInfo.WindowStyle*
  exceptions:
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "窗口样式不是一个<xref href=&quot;System.Diagnostics.ProcessWindowStyle&quot;></xref>枚举成员。"
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.WorkingDirectory
  id: WorkingDirectory
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: WorkingDirectory
  nameWithType: ProcessStartInfo.WorkingDirectory
  fullName: System.Diagnostics.ProcessStartInfo.WorkingDirectory
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "当<> *1> 属性是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>，则获取或设置要启动进程的工作目录。当<> *1> 是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>，则获取或设置包含要启动的进程的目录。"
  remarks: "> [!IMPORTANT]\n>  The WorkingDirectory property must be set if <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> and <xref:System.Diagnostics.ProcessStartInfo.Password%2A> are provided. If the property is not set, the default working directory is %SYSTEMROOT%\\system32.  \n  \n If the directory is already part of the system path variable, you do not have to repeat the directory's location in this property.  \n  \n The WorkingDirectory property behaves differently when <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` than when <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `false`. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true`, the WorkingDirectory property specifies the location of the executable. If WorkingDirectory is an empty string, the current directory is understood to contain the executable.  \n  \n> [!NOTE]\n>  When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true`, the working directory of the application that starts the executable is also the working directory of the executable.  \n  \n When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `false`, the WorkingDirectory property is not used to find the executable. Instead, its value applies to the process that is started and only has meaning within the context of the new process."
  syntax:
    content: public string WorkingDirectory { get; set; }
    return:
      type: System.String
      description: "当<> *1> 是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>，包含要启动的进程的目录的完全限定的名称。当<> *1> 属性是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>，要启动进程的工作目录。 默认值为空字符串 (&quot;&quot;)。"
  overload: System.Diagnostics.ProcessStartInfo.WorkingDirectory*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.Diagnostics.ProcessStartInfo.#ctor
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ProcessStartInfo()
  nameWithType: ProcessStartInfo.ProcessStartInfo()
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo()
- uid: System.Diagnostics.ProcessStartInfo.#ctor(System.String)
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ProcessStartInfo(String)
  nameWithType: ProcessStartInfo.ProcessStartInfo(String)
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Diagnostics.ProcessStartInfo.#ctor(System.String,System.String)
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ProcessStartInfo(String,String)
  nameWithType: ProcessStartInfo.ProcessStartInfo(String,String)
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo(String,String)
- uid: System.Diagnostics.ProcessStartInfo.Arguments
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Arguments
  nameWithType: ProcessStartInfo.Arguments
  fullName: System.Diagnostics.ProcessStartInfo.Arguments
- uid: System.Diagnostics.ProcessStartInfo.CreateNoWindow
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: CreateNoWindow
  nameWithType: ProcessStartInfo.CreateNoWindow
  fullName: System.Diagnostics.ProcessStartInfo.CreateNoWindow
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Diagnostics.ProcessStartInfo.Domain
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Domain
  nameWithType: ProcessStartInfo.Domain
  fullName: System.Diagnostics.ProcessStartInfo.Domain
- uid: System.Diagnostics.ProcessStartInfo.Environment
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Environment
  nameWithType: ProcessStartInfo.Environment
  fullName: System.Diagnostics.ProcessStartInfo.Environment
- uid: System.Collections.Generic.IDictionary{System.String,System.String}
  parent: System.Collections.Generic
  isExternal: true
  name: IDictionary<String,String>
  nameWithType: IDictionary<String,String>
  fullName: System.Collections.Generic.IDictionary<System.String,System.String>
  spec.csharp:
  - uid: System.Collections.Generic.IDictionary`2
    name: IDictionary
    nameWithType: IDictionary
    fullName: IDictionary<System.String,System.String>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Diagnostics.ProcessStartInfo.EnvironmentVariables
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: EnvironmentVariables
  nameWithType: ProcessStartInfo.EnvironmentVariables
  fullName: System.Diagnostics.ProcessStartInfo.EnvironmentVariables
- uid: System.Collections.Specialized.StringDictionary
  parent: System.Collections.Specialized
  isExternal: false
  name: StringDictionary
  nameWithType: StringDictionary
  fullName: System.Collections.Specialized.StringDictionary
- uid: System.Diagnostics.ProcessStartInfo.ErrorDialog
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ErrorDialog
  nameWithType: ProcessStartInfo.ErrorDialog
  fullName: System.Diagnostics.ProcessStartInfo.ErrorDialog
- uid: System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ErrorDialogParentHandle
  nameWithType: ProcessStartInfo.ErrorDialogParentHandle
  fullName: System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Diagnostics.ProcessStartInfo.FileName
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: FileName
  nameWithType: ProcessStartInfo.FileName
  fullName: System.Diagnostics.ProcessStartInfo.FileName
- uid: System.Diagnostics.ProcessStartInfo.LoadUserProfile
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: LoadUserProfile
  nameWithType: ProcessStartInfo.LoadUserProfile
  fullName: System.Diagnostics.ProcessStartInfo.LoadUserProfile
- uid: System.Diagnostics.ProcessStartInfo.Password
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Password
  nameWithType: ProcessStartInfo.Password
  fullName: System.Diagnostics.ProcessStartInfo.Password
- uid: System.Security.SecureString
  parent: System.Security
  isExternal: false
  name: SecureString
  nameWithType: SecureString
  fullName: System.Security.SecureString
- uid: System.Diagnostics.ProcessStartInfo.PasswordInClearText
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: PasswordInClearText
  nameWithType: ProcessStartInfo.PasswordInClearText
  fullName: System.Diagnostics.ProcessStartInfo.PasswordInClearText
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardError
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: RedirectStandardError
  nameWithType: ProcessStartInfo.RedirectStandardError
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardError
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardInput
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: RedirectStandardInput
  nameWithType: ProcessStartInfo.RedirectStandardInput
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardInput
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: RedirectStandardOutput
  nameWithType: ProcessStartInfo.RedirectStandardOutput
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
- uid: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: StandardErrorEncoding
  nameWithType: ProcessStartInfo.StandardErrorEncoding
  fullName: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding
- uid: System.Text.Encoding
  parent: System.Text
  isExternal: true
  name: Encoding
  nameWithType: Encoding
  fullName: System.Text.Encoding
- uid: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: StandardOutputEncoding
  nameWithType: ProcessStartInfo.StandardOutputEncoding
  fullName: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding
- uid: System.Diagnostics.ProcessStartInfo.UserName
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: UserName
  nameWithType: ProcessStartInfo.UserName
  fullName: System.Diagnostics.ProcessStartInfo.UserName
- uid: System.Diagnostics.ProcessStartInfo.UseShellExecute
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: UseShellExecute
  nameWithType: ProcessStartInfo.UseShellExecute
  fullName: System.Diagnostics.ProcessStartInfo.UseShellExecute
- uid: System.Diagnostics.ProcessStartInfo.Verb
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Verb
  nameWithType: ProcessStartInfo.Verb
  fullName: System.Diagnostics.ProcessStartInfo.Verb
- uid: System.Diagnostics.ProcessStartInfo.Verbs
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Verbs
  nameWithType: ProcessStartInfo.Verbs
  fullName: System.Diagnostics.ProcessStartInfo.Verbs
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.ProcessStartInfo.WindowStyle
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: WindowStyle
  nameWithType: ProcessStartInfo.WindowStyle
  fullName: System.Diagnostics.ProcessStartInfo.WindowStyle
- uid: System.Diagnostics.ProcessWindowStyle
  parent: System.Diagnostics
  isExternal: false
  name: ProcessWindowStyle
  nameWithType: ProcessWindowStyle
  fullName: System.Diagnostics.ProcessWindowStyle
- uid: System.Diagnostics.ProcessStartInfo.WorkingDirectory
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: WorkingDirectory
  nameWithType: ProcessStartInfo.WorkingDirectory
  fullName: System.Diagnostics.ProcessStartInfo.WorkingDirectory
- uid: System.Diagnostics.ProcessStartInfo.#ctor*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ProcessStartInfo
  nameWithType: ProcessStartInfo.ProcessStartInfo
- uid: System.Diagnostics.ProcessStartInfo.Arguments*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Arguments
  nameWithType: ProcessStartInfo.Arguments
- uid: System.Diagnostics.ProcessStartInfo.CreateNoWindow*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: CreateNoWindow
  nameWithType: ProcessStartInfo.CreateNoWindow
- uid: System.Diagnostics.ProcessStartInfo.Domain*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Domain
  nameWithType: ProcessStartInfo.Domain
- uid: System.Diagnostics.ProcessStartInfo.Environment*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Environment
  nameWithType: ProcessStartInfo.Environment
- uid: System.Diagnostics.ProcessStartInfo.EnvironmentVariables*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: EnvironmentVariables
  nameWithType: ProcessStartInfo.EnvironmentVariables
- uid: System.Diagnostics.ProcessStartInfo.ErrorDialog*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ErrorDialog
  nameWithType: ProcessStartInfo.ErrorDialog
- uid: System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ErrorDialogParentHandle
  nameWithType: ProcessStartInfo.ErrorDialogParentHandle
- uid: System.Diagnostics.ProcessStartInfo.FileName*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: FileName
  nameWithType: ProcessStartInfo.FileName
- uid: System.Diagnostics.ProcessStartInfo.LoadUserProfile*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: LoadUserProfile
  nameWithType: ProcessStartInfo.LoadUserProfile
- uid: System.Diagnostics.ProcessStartInfo.Password*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Password
  nameWithType: ProcessStartInfo.Password
- uid: System.Diagnostics.ProcessStartInfo.PasswordInClearText*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: PasswordInClearText
  nameWithType: ProcessStartInfo.PasswordInClearText
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardError*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: RedirectStandardError
  nameWithType: ProcessStartInfo.RedirectStandardError
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardInput*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: RedirectStandardInput
  nameWithType: ProcessStartInfo.RedirectStandardInput
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: RedirectStandardOutput
  nameWithType: ProcessStartInfo.RedirectStandardOutput
- uid: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: StandardErrorEncoding
  nameWithType: ProcessStartInfo.StandardErrorEncoding
- uid: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: StandardOutputEncoding
  nameWithType: ProcessStartInfo.StandardOutputEncoding
- uid: System.Diagnostics.ProcessStartInfo.UserName*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: UserName
  nameWithType: ProcessStartInfo.UserName
- uid: System.Diagnostics.ProcessStartInfo.UseShellExecute*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: UseShellExecute
  nameWithType: ProcessStartInfo.UseShellExecute
- uid: System.Diagnostics.ProcessStartInfo.Verb*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Verb
  nameWithType: ProcessStartInfo.Verb
- uid: System.Diagnostics.ProcessStartInfo.Verbs*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Verbs
  nameWithType: ProcessStartInfo.Verbs
- uid: System.Diagnostics.ProcessStartInfo.WindowStyle*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: WindowStyle
  nameWithType: ProcessStartInfo.WindowStyle
- uid: System.Diagnostics.ProcessStartInfo.WorkingDirectory*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: WorkingDirectory
  nameWithType: ProcessStartInfo.WorkingDirectory
