### YamlMime:ManagedReference
items:
- uid: System.Windows.DependencyObject
  id: DependencyObject
  children:
  - System.Windows.DependencyObject.#ctor
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.DependencyObjectType
  - System.Windows.DependencyObject.Equals(System.Object)
  - System.Windows.DependencyObject.GetHashCode
  - System.Windows.DependencyObject.GetLocalValueEnumerator
  - System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.IsSealed
  - System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)
  - System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)
  langs:
  - csharp
  name: DependencyObject
  nameWithType: DependencyObject
  fullName: System.Windows.DependencyObject
  type: Class
  summary: "表示参与依赖项属性系统的对象。"
  remarks: "将类可实现[!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)]对其许多的派生类的属性系统服务。       属性系统的主要功能是计算属性的值，并提供有关已更改的值的系统通知。 参与属性系统的另一个密钥类是<xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> <xref:System.Windows.DependencyProperty>启用依赖项属性的注册到属性系统，并提供标识和有关每个依赖项属性信息，而将用作基类允许对象使用的依赖项属性。</xref:System.Windows.DependencyProperty>       将服务和特征包括以下:-承载支持的依赖项属性。 通过调用<xref:System.Windows.DependencyProperty.Register%2A>方法，并将为你的类中的公共静态字段的方法的返回值存储</xref:System.Windows.DependencyProperty.Register%2A>注册依赖项属性      的托管支持附加属性。 通过调用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>方法，并将存储为公共静态只读字段中你的类的方法的返回值</xref:System.Windows.DependencyProperty.RegisterAttached%2A>注册附加的属性 (此外还有其他成员要求; 请注意，这表示[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]附加属性的特定实现。 有关详细信息，请参阅[附加属性概述](~/add/includes/ajax-current-ext-md.md)。)然后可以派生自将任何类上设置附加的属性。      -获取、 设置，并清除实用工具方法，用于将存在任何依赖项属性的值。      元数据，强制值支持，属性更改通知，以及依赖项属性的重写回调或附加属性。 此外，将类便于依赖项属性的每个所有者属性元数据。      -类 a 公共基类派生自<xref:System.Windows.ContentElement>， <xref:System.Windows.Freezable>，或<xref:System.Windows.Media.Visual>。</xref:System.Windows.Media.Visual> </xref:System.Windows.Freezable> </xref:System.Windows.ContentElement> (<xref:System.Windows.UIElement>，另一个基元素类，具有包含的类层次结构<xref:System.Windows.Media.Visual>。)</xref:System.Windows.Media.Visual> </xref:System.Windows.UIElement>"
  example:
  - "The following example derives from DependencyObject to create a new abstract class. The class then registers an attached property and includes support members for that attached property.  \n  \n [!code-cs[WPFAquariumSln#DOMain](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#domain)]\n [!code-vb[WPFAquariumSln#DOMain](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#domain)]"
  syntax:
    content: >-
      [System.ComponentModel.TypeDescriptionProvider(typeof(MS.Internal.ComponentModel.DependencyObjectProvider))]

      [System.Windows.Markup.NameScopeProperty("NameScope", typeof(System.Windows.NameScope))]

      public class DependencyObject : System.Windows.Threading.DispatcherObject
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  implements: []
  inheritedMembers:
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  platform:
  - net462
- uid: System.Windows.DependencyObject.#ctor
  id: '#ctor'
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: DependencyObject()
  nameWithType: DependencyObject.DependencyObject()
  fullName: System.Windows.DependencyObject.DependencyObject()
  type: Constructor
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "初始化的新实例<xref href=&quot;System.Windows.DependencyObject&quot;></xref>类。"
  syntax:
    content: public DependencyObject ();
    parameters: []
  overload: System.Windows.DependencyObject.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)
  id: ClearValue(System.Windows.DependencyProperty)
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: ClearValue(DependencyProperty)
  nameWithType: DependencyObject.ClearValue(DependencyProperty)
  fullName: System.Windows.DependencyObject.ClearValue(DependencyProperty)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "清除属性的本地值。 指定要清除的属性<xref href=&quot;System.Windows.DependencyProperty&quot;></xref>标识符。"
  remarks: "通过调用 ClearValue 清除的属性值不一定会赋予依赖项属性的依赖项属性元数据中指定的默认值。 清除属性只特别清除任何本地值可能被应用。 有关详细信息，请参阅[依赖项属性值优先级](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example iterates all properties that have local values set on an object, then calls ClearValue to clear the values of each such property.  \n  \n [!code-cs[DPClearValue#IterateLocalValuesAndClear](~/add/codesnippet/csharp/DPClearValue/default.xaml.cs#iteratelocalvaluesandclear)]\n [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/add/codesnippet/visualbasic/DPClearValue/default.xaml.vb#iteratelocalvaluesandclear)]"
  syntax:
    content: public void ClearValue (System.Windows.DependencyProperty dp);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "依赖项属性被清除，由<xref href=&quot;System.Windows.DependencyProperty&quot;></xref>对象引用。"
  overload: System.Windows.DependencyObject.ClearValue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "尝试对密封调用 ClearValue <xref href=&quot;System.Windows.DependencyObject&quot;> </xref>。"
  platform:
  - net462
- uid: System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)
  id: ClearValue(System.Windows.DependencyPropertyKey)
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: ClearValue(DependencyPropertyKey)
  nameWithType: DependencyObject.ClearValue(DependencyPropertyKey)
  fullName: System.Windows.DependencyObject.ClearValue(DependencyPropertyKey)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "清除只读属性的本地值。 指定要清除的属性<xref href=&quot;System.Windows.DependencyPropertyKey&quot;> </xref>。"
  remarks: "A<xref:System.Windows.DependencyPropertyKey>标识属性系统操作的只读依赖属性。</xref:System.Windows.DependencyPropertyKey> 定义只读依赖属性的类不应公开此密钥的公共访问权限。 公开提供的键将提供求反后的属性的只读字符公共代码路径，如果等方法<xref:System.Windows.DependencyObject.ClearValue%2A>或<xref:System.Windows.DependencyObject.SetValue%2A>无法调用外部类或程序集，引用键。</xref:System.Windows.DependencyObject.SetValue%2A> </xref:System.Windows.DependencyObject.ClearValue%2A>       通过调用 ClearValue 清除的属性值不一定会赋予依赖项属性的依赖项属性元数据中指定的默认值。 清除值只特别清除任何本地值可能被应用。 有关详细信息，请参阅[依赖项属性值优先级](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public void ClearValue (System.Windows.DependencyPropertyKey key);
    parameters:
    - id: key
      type: System.Windows.DependencyPropertyKey
      description: "要清除依赖项属性的密钥。"
  overload: System.Windows.DependencyObject.ClearValue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "尝试调用<xref:System.Windows.DependencyObject.ClearValue*>对密封<xref href=&quot;System.Windows.DependencyObject&quot;> </xref>。</xref:System.Windows.DependencyObject.ClearValue*>"
  platform:
  - net462
- uid: System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)
  id: CoerceValue(System.Windows.DependencyProperty)
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: CoerceValue(DependencyProperty)
  nameWithType: DependencyObject.CoerceValue(DependencyProperty)
  fullName: System.Windows.DependencyObject.CoerceValue(DependencyProperty)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "将指定的依赖项属性的值强制转换。 这通过调用任何实现<xref href=&quot;System.Windows.CoerceValueCallback&quot;></xref>函数指定依赖项属性的属性元数据中，因为它存在于调用<xref href=&quot;System.Windows.DependencyObject&quot;> </xref>。"
  remarks: "除了通过调用强制值，在显式调用<xref:System.Windows.CoerceValueCallback>依赖项属性也会调用内部的依赖项属性值是正在重新计算出的[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]属性系统。</xref:System.Windows.CoerceValueCallback>       在调用时强制值方法，你正在最终调用强制值回调你指定的属性。 通常，只有当您知道，强制值回调存在，并且您知道强制的回调的条件，你将调用强制值。       调用强制值的最常见方案是在类处理或影响对方的值的依赖方式的相关属性的属性更改回调。 有关详细信息，请参阅[依赖项属性的回调和验证](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example calls CoerceValue within a <xref:System.Windows.PropertyChangedCallback> implementation that is used as the <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> for a different dependency properties on the same class. This is a common pattern for introducing true value dependencies between dependency properties.  \n  \n [!code-cs[DPCallbackOverride#OnPCCurrent](~/add/codesnippet/csharp/DPCallbackOverride/SDKSampleLibrary/class1.cs#onpccurrent)]\n [!code-vb[DPCallbackOverride#OnPCCurrent](~/add/codesnippet/visualbasic/DPCallbackOverride.sdksamplelibrary/class1.vb#onpccurrent)]"
  syntax:
    content: public void CoerceValue (System.Windows.DependencyProperty dp);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "要强制转换的依赖项属性标识符。"
  overload: System.Windows.DependencyObject.CoerceValue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "指定<code> dp </code>或其值无效或不存在。"
  platform:
  - net462
- uid: System.Windows.DependencyObject.DependencyObjectType
  id: DependencyObjectType
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: DependencyObjectType
  nameWithType: DependencyObject.DependencyObjectType
  fullName: System.Windows.DependencyObject.DependencyObjectType
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "获取<xref href=&quot;System.Windows.DependencyObjectType&quot;></xref>包装[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]的此实例的类型。"
  remarks: "此属性很有用，如果从方法返回的对象具有的返回值类型<xref:System.Windows.DependencyObject>并且你想要属性系统特定对其执行操作具体取决于其类型。</xref:System.Windows.DependencyObject> 例如，它会更加高效调用<xref:System.Windows.DependencyProperty.GetMetadata%28System.Windows.DependencyObjectType%29>使用<xref:System.Windows.DependencyObjectType>而不是[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]类型。</xref:System.Windows.DependencyObjectType> </xref:System.Windows.DependencyProperty.GetMetadata%28System.Windows.DependencyObjectType%29> <xref:System.Windows.DependencyObjectType>便于更快的查找。</xref:System.Windows.DependencyObjectType>"
  example:
  - "In the following pseudocode example, `MySubClass` anticipates that additional derived classes might change the default value of the `MyCustom` dependency property. The class implements a default constructor that can determine the actual derived class by taking advantage of polymorphism on the <xref:System.Windows.DependencyObjectType> value whenever that constructor is used as a derived class instantiator.  \n  \n `public DOClass() : base()`  \n  \n `{`  \n  \n `__customPropertyCache = (CustomDP)`  \n  \n `CustomDPProperty.GetMetadata(DependencyObjectType).DefaultValue;`  \n  \n `}`"
  syntax:
    content: public System.Windows.DependencyObjectType DependencyObjectType { get; }
    return:
      type: System.Windows.DependencyObjectType
      description: "A <xref href=&quot;System.Windows.DependencyObjectType&quot;> </xref>包装[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]的此实例的类型。"
  overload: System.Windows.DependencyObject.DependencyObjectType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyObject.Equals(System.Object)
  id: Equals(System.Object)
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: Equals(Object)
  nameWithType: DependencyObject.Equals(Object)
  fullName: System.Windows.DependencyObject.Equals(Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "确定是否提供<xref href=&quot;System.Windows.DependencyObject&quot;></xref>等效于当前<xref href=&quot;System.Windows.DependencyObject&quot;> </xref>。"
  remarks: "此实现不引用相等性，因此不会尝试评估的包含属性的值相等。"
  syntax:
    content: public override sealed bool Equals (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "<xref href=&quot;System.Windows.DependencyObject&quot;> </xref>要与当前实例进行比较。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果两个实例相同;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.DependencyObject.Equals*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyObject.GetHashCode
  id: GetHashCode
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: GetHashCode()
  nameWithType: DependencyObject.GetHashCode()
  fullName: System.Windows.DependencyObject.GetHashCode()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "获取此哈希代码<xref href=&quot;System.Windows.DependencyObject&quot;> </xref>。"
  syntax:
    content: public override sealed int GetHashCode ();
    parameters: []
    return:
      type: System.Int32
      description: "32 位有符号的整数哈希代码。"
  overload: System.Windows.DependencyObject.GetHashCode*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyObject.GetLocalValueEnumerator
  id: GetLocalValueEnumerator
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: GetLocalValueEnumerator()
  nameWithType: DependencyObject.GetLocalValueEnumerator()
  fullName: System.Windows.DependencyObject.GetLocalValueEnumerator()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "创建专用的枚举器，用于确定哪些依赖项属性具有本地设置值，对此<xref href=&quot;System.Windows.DependencyObject&quot;> </xref>。"
  remarks: "A*本地值*是任何依赖项属性值所设置<xref:System.Windows.DependencyObject.SetValue%2A>，而不是属性系统的其他方面。</xref:System.Windows.DependencyObject.SetValue%2A>       <xref:System.Windows.LocalValueEnumerator>通过调用 GetLocalValueEnumerator 可用于枚举具有本地设置的属性获取值上<xref:System.Windows.DependencyObject>实例。</xref:System.Windows.DependencyObject> </xref:System.Windows.LocalValueEnumerator> 每个此类属性表示的枚举器中<xref:System.Windows.LocalValueEntry>具有引用特定的属性的对象<xref:System.Windows.DependencyProperty>及其值。</xref:System.Windows.DependencyProperty> </xref:System.Windows.LocalValueEntry> 此方法的枚举的本地设置值可以用于优化或其他处理的本地值，如确定的哪些属性值<xref:System.Windows.DependencyObject>将更改如果它们已清除。</xref:System.Windows.DependencyObject>      1> [!IMPORTANT]&1;> 返回<xref:System.Windows.LocalValueEnumerator>可能包含<xref:System.Windows.LocalValueEntry>依赖项属性是只读的或通过属性系统计算中值的依赖项属性的记录。</xref:System.Windows.LocalValueEntry> </xref:System.Windows.LocalValueEnumerator> 例如，通过布局使用确定宽度 visual framework 元素将报告<xref:System.Windows.FrameworkElement.ActualWidth%2A>.</xref:System.Windows.FrameworkElement.ActualWidth%2A>的本地值 如果您处于本地值以便重置它们，请检查<xref:System.Windows.DependencyProperty.ReadOnly%2A>上每个属性标识符值<xref:System.Windows.LocalValueEntry>以便确认<xref:System.Windows.DependencyProperty>问题不是只读的。</xref:System.Windows.DependencyProperty> </xref:System.Windows.LocalValueEntry> </xref:System.Windows.DependencyProperty.ReadOnly%2A>"
  example:
  - "The following example iterates all properties that have local values set on an object, then calls <xref:System.Windows.DependencyObject.ClearValue%2A> to clear the values of each such property.  \n  \n [!code-cs[DPClearValue#IterateLocalValuesAndClear](~/add/codesnippet/csharp/DPClearValue/default.xaml.cs#iteratelocalvaluesandclear)]\n [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/add/codesnippet/visualbasic/DPClearValue/default.xaml.vb#iteratelocalvaluesandclear)]"
  syntax:
    content: public System.Windows.LocalValueEnumerator GetLocalValueEnumerator ();
    parameters: []
    return:
      type: System.Windows.LocalValueEnumerator
      description: "一个专用的本地值的枚举。"
  overload: System.Windows.DependencyObject.GetLocalValueEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)
  id: GetValue(System.Windows.DependencyProperty)
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: GetValue(DependencyProperty)
  nameWithType: DependencyObject.GetValue(DependencyProperty)
  fullName: System.Windows.DependencyObject.GetValue(DependencyProperty)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "返回此实例上的依赖项属性的当前有效值<xref href=&quot;System.Windows.DependencyObject&quot;> </xref>。"
  remarks: "*有效值*是通过属性系统返回到正在请求值的任何调用方的属性的值。 有效值是具有计算参与属性系统值优先级的所有可能的输入属性系统的结果。 这包括强制和动画。 有关详细信息，请参阅[依赖项属性值优先级](~/add/includes/ajax-current-ext-md.md)。       此方法将永远不会返回<xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> <xref:System.Windows.DependencyProperty>是 sentinel 值用在内部，有时也通过强制回调公开的各种功能的属性系统。</xref:System.Windows.DependencyProperty>       如果你不确定该属性的类型应该是什么，您可以查询要确定是否有更为具体的请求的依赖关系属性的标识符<xref:System.Windows.DependencyProperty.PropertyType%2A>返回值可以转换为。</xref:System.Windows.DependencyProperty.PropertyType%2A>"
  syntax:
    content: public object GetValue (System.Windows.DependencyProperty dp);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "<xref href=&quot;System.Windows.DependencyProperty&quot;> </xref>要检索其值的属性的标识符。"
    return:
      type: System.Object
      description: "返回当前有效值。"
  overload: System.Windows.DependencyObject.GetValue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "指定<code> dp </code>或其值无效，或者指定<code> dp </code>不存在。"
  platform:
  - net462
- uid: System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)
  id: InvalidateProperty(System.Windows.DependencyProperty)
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: InvalidateProperty(DependencyProperty)
  nameWithType: DependencyObject.InvalidateProperty(DependencyProperty)
  fullName: System.Windows.DependencyObject.InvalidateProperty(DependencyProperty)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "重新评估指定的依赖项属性的有效值"
  remarks: "当调用 InvalidateProperty，任何关联和适用<xref:System.Windows.CoerceValueCallback>或<xref:System.Windows.PropertyChangedCallback>函数注册为可能调用该依赖项属性。</xref:System.Windows.PropertyChangedCallback> </xref:System.Windows.CoerceValueCallback>       设置其本地值的属性上调用 InvalidateProperty 不会产生不起作用，因为本地值优先于其他属性系统输入，动画除外。 但是，您可以调用<xref:System.Windows.DependencyObject.ClearValue%2A>，然后调用 InvalidateProperty。</xref:System.Windows.DependencyObject.ClearValue%2A> 有关详细信息，请参阅[依赖项属性值优先级](~/add/includes/ajax-current-ext-md.md)。       调用 InvalidateProperty 不一定适用于许多依赖项属性方案。 如果由于任何组成部分值更改，因此失效依赖项属性，属性系统使无效，并自动重新计算依赖项属性。 但是，仍有一些 InvalidateProperty 是有用的相应方案。 具体而言，你可以使用内部强制 InvalidateProperty 值或属性更改为不同的依赖属性的回调。 你还可以使用 InvalidateProperty 强制重新计算对不能实现推荐的数据源绑定<xref:System.ComponentModel.INotifyPropertyChanged>通知机制 (可能是如果消耗数据类，不能从，派生或知道数据的静态成员)。</xref:System.ComponentModel.INotifyPropertyChanged>"
  example:
  - "The following example calls InvalidateProperty on a custom property, whenever properties that are involved in the invalidated property's calculations change. This is an alternative technique to calling the <xref:System.Windows.DependencyObject.CoerceValue%2A> method, because invalidating the property will also call any registered <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>.  \n  \n [!code-cs[PropertySystemEsoterics#InvalidateProperty](~/add/codesnippet/csharp/PropertySystemEsoterics/SDKSampleLibrary/class1.cs#invalidateproperty)]\n [!code-vb[PropertySystemEsoterics#InvalidateProperty](~/add/codesnippet/visualbasic/PropertySystemEsoterics.sdksamplelibrary/class1.vb#invalidateproperty)]"
  syntax:
    content: public void InvalidateProperty (System.Windows.DependencyProperty dp);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "<xref href=&quot;System.Windows.DependencyProperty&quot;> </xref>要使之无效的属性的标识符。"
  overload: System.Windows.DependencyObject.InvalidateProperty*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyObject.IsSealed
  id: IsSealed
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: IsSealed
  nameWithType: DependencyObject.IsSealed
  fullName: System.Windows.DependencyObject.IsSealed
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "获取一个值，该值指示是否 （只读），此实例当前密封。"
  remarks: "内部设置此值。"
  syntax:
    content: public bool IsSealed { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果此实例都密封的;，否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.DependencyObject.IsSealed*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  id: OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: OnPropertyChanged(DependencyPropertyChangedEventArgs)
  nameWithType: DependencyObject.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.DependencyObject.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "每当调用这任何依赖属性的有效值<xref href=&quot;System.Windows.DependencyObject&quot;></xref>已更新。 在事件数据报告更改的特定依赖属性。"
  remarks: "此方法不应通常检测个别属性更改或基于每个用例执行挂起的属性。 OnPropertyChanged 改为适用于修改常规失效模式中，如果查阅宽分类的属性已知的某些信息。 例如，在更改<xref:System.Windows.Freezable>可能的值类型中的更改<xref:System.Windows.Freezable>，或可能与子属性，其中所做的更改是在其他<xref:System.Windows.Freezable>引用。</xref:System.Windows.Freezable> </xref:System.Windows.Freezable> </xref:System.Windows.Freezable> <xref:System.Windows.Freezable>OnPropertyChanged 重写实现使用内部信息来确定属性是否为子属性，并提供适当的基类逻辑以两种情况。</xref:System.Windows.Freezable>       OnPropertyChanged 是可能会多次调用对象的生命周期内。 因此，如果你可以实现更好的总体属性系统性能重写特定属性的元数据，然后将附加<xref:System.Windows.CoerceValueCallback>或<xref:System.Windows.PropertyChangedCallback>为各个属性的函数。</xref:System.Windows.PropertyChangedCallback> </xref:System.Windows.CoerceValueCallback> 但是，如果你将使用此方法<xref:System.Windows.DependencyObject>包括大量的值相关的依赖项属性，或如果它包括逻辑，如呈现行为，必须重新运行多个相关属性失效的情况。</xref:System.Windows.DependencyObject>"
  syntax:
    content: protected virtual void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DependencyPropertyChangedEventArgs
      description: "将包含感兴趣，该类型的属性元数据和旧值和新值的依赖项属性标识符的事件数据。"
  overload: System.Windows.DependencyObject.OnPropertyChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)
  id: ReadLocalValue(System.Windows.DependencyProperty)
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: ReadLocalValue(DependencyProperty)
  nameWithType: DependencyObject.ReadLocalValue(DependencyProperty)
  fullName: System.Windows.DependencyObject.ReadLocalValue(DependencyProperty)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "如果它存在，则返回依赖属性的本地值。"
  remarks: "应使用<xref:System.Windows.DependencyObject.GetValue%2A>依赖项属性的大多数典型&quot;get&quot;操作。</xref:System.Windows.DependencyObject.GetValue%2A> ReadLocalValue 不返回使用其中未本地设置值的各种情况下的生效值。       值由样式、 主题、 模板设置，从元数据或属性值继承的默认值是不被视为本地值。 但是，被视为绑定和其他表达式将本地值之后已对它们进行评估。       当未不设置任何本地值时，此方法会返回<xref:System.Windows.DependencyProperty.UnsetValue>.</xref:System.Windows.DependencyProperty.UnsetValue>       如果返回的值而不是<xref:System.Windows.DependencyProperty.UnsetValue>，您可以查询请求的依赖关系属性，以确定是否存在返回值可以转换为更具体类型的元数据。</xref:System.Windows.DependencyProperty.UnsetValue>"
  syntax:
    content: public object ReadLocalValue (System.Windows.DependencyProperty dp);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "<xref href=&quot;System.Windows.DependencyProperty&quot;> </xref>要检索其值的属性的标识符。"
    return:
      type: System.Object
      description: "返回本地值，则返回 sentinel 值<xref href=&quot;System.Windows.DependencyProperty&quot;></xref>如果未不设置任何本地值。"
  overload: System.Windows.DependencyObject.ReadLocalValue*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)
  id: SetCurrentValue(System.Windows.DependencyProperty,System.Object)
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: SetCurrentValue(DependencyProperty,Object)
  nameWithType: DependencyObject.SetCurrentValue(DependencyProperty,Object)
  fullName: System.Windows.DependencyObject.SetCurrentValue(DependencyProperty,Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "设置依赖项属性的值而不更改其值源。"
  remarks: "以编程方式设置其自己的属性之一的值，但不能禁用应用程序的声明的属性使用的组件使用此方法。 SetCurrentValue 方法更改的生效值的属性，但现有的触发器、 数据绑定和样式将继续工作。"
  syntax:
    content: public void SetCurrentValue (System.Windows.DependencyProperty dp, object value);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "要设置的依赖项属性的标识符。"
    - id: value
      type: System.Object
      description: "新的本地值。"
  overload: System.Windows.DependencyObject.SetCurrentValue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "尝试修改只读依赖属性或对密封属性<xref href=&quot;System.Windows.DependencyObject&quot;> </xref>。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>value</code>并不是正确的类型，如为注册<code>dp</code>属性。"
  platform:
  - net462
- uid: System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)
  id: SetValue(System.Windows.DependencyProperty,System.Object)
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: SetValue(DependencyProperty,Object)
  nameWithType: DependencyObject.SetValue(DependencyProperty,Object)
  fullName: System.Windows.DependencyObject.SetValue(DependencyProperty,Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "设置由其依赖项属性标识符指定的依赖项属性的本地值。"
  remarks: "如果所提供的类型与按最初注册依赖属性声明的类型不匹配，则引发异常。 `value`应该始终提供参数，以适合的类型。       异常条件可能受<xref:System.Windows.DependencyProperty.ValidateValueCallback%2A>位于要设置的依赖项属性的依赖项属性标识符的回调。</xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> 否则，提供的值可能无法满足常规类型检查的条件 （例如，将字符串传递时的本机类型为 Double）。"
  syntax:
    content: public void SetValue (System.Windows.DependencyProperty dp, object value);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "要设置的依赖项属性的标识符。"
    - id: value
      type: System.Object
      description: "新的本地值。"
  overload: System.Windows.DependencyObject.SetValue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "尝试修改只读依赖属性或对密封属性<xref href=&quot;System.Windows.DependencyObject&quot;> </xref>。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>value</code>并不是正确的类型，如为注册<code>dp</code>属性。"
  platform:
  - net462
- uid: System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)
  id: SetValue(System.Windows.DependencyPropertyKey,System.Object)
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: SetValue(DependencyPropertyKey,Object)
  nameWithType: DependencyObject.SetValue(DependencyPropertyKey,Object)
  fullName: System.Windows.DependencyObject.SetValue(DependencyPropertyKey,Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "设置指定的只读依赖属性的本地值<xref href=&quot;System.Windows.DependencyPropertyKey&quot;></xref>的依赖项属性的标识符。"
  remarks: "当你设置由您的自定义类定义的只读依赖属性的值时，通常使用该签名。 通常情况下，SetValue 称为只能从注册实现提供确定的值的依赖项属性的内部逻辑该依赖属性的类型。 有关详细信息，请参阅[只读依赖项属性](~/add/includes/ajax-current-ext-md.md)。       如果所提供的类型与按最初注册依赖属性声明的类型不匹配，则引发异常。 `value`应该始终提供参数，以适合的类型。 异常条件可能受<xref:System.Windows.DependencyProperty.ValidateValueCallback%2A>位于要设置的依赖项属性的依赖项属性标识符的回调。</xref:System.Windows.DependencyProperty.ValidateValueCallback%2A>"
  example:
  - "The following example defines a read-only dependency property, along with a `public static readonly` <xref:System.Windows.DependencyProperty> that provides necessary read-only exposure to property consumers, and the get accessor for the [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] wrapper.  \n  \n [!code-cs[WPFAquariumSln#RODP](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#rodp)]\n [!code-vb[WPFAquariumSln#RODP](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#rodp)]"
  syntax:
    content: public void SetValue (System.Windows.DependencyPropertyKey key, object value);
    parameters:
    - id: key
      type: System.Windows.DependencyPropertyKey
      description: "<xref href=&quot;System.Windows.DependencyPropertyKey&quot;> </xref>要设置的属性的标识符。"
    - id: value
      type: System.Object
      description: "新的本地值。"
  overload: System.Windows.DependencyObject.SetValue*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)
  id: ShouldSerializeProperty(System.Windows.DependencyProperty)
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: ShouldSerializeProperty(DependencyProperty)
  nameWithType: DependencyObject.ShouldSerializeProperty(DependencyProperty)
  fullName: System.Windows.DependencyObject.ShouldSerializeProperty(DependencyProperty)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "返回一个值，该值指示序列化进程是否应序列化提供的依赖属性的值。"
  remarks: "默认实现返回`true`在其中一个依赖项属性具有本地值<xref:System.Windows.DependencyObject>.</xref:System.Windows.DependencyObject>上建立的所有用例"
  syntax:
    content: protected virtual bool ShouldSerializeProperty (System.Windows.DependencyProperty dp);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "应序列化依赖项属性的标识符。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果提供的依赖项属性应进行值序列化;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.DependencyObject.ShouldSerializeProperty*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.Threading.DispatcherObject
  isExternal: false
  name: System.Windows.Threading.DispatcherObject
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Windows.DependencyObject.#ctor
  parent: System.Windows.DependencyObject
  isExternal: false
  name: DependencyObject()
  nameWithType: DependencyObject.DependencyObject()
  fullName: System.Windows.DependencyObject.DependencyObject()
- uid: System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)
  parent: System.Windows.DependencyObject
  isExternal: false
  name: ClearValue(DependencyProperty)
  nameWithType: DependencyObject.ClearValue(DependencyProperty)
  fullName: System.Windows.DependencyObject.ClearValue(DependencyProperty)
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)
  parent: System.Windows.DependencyObject
  isExternal: false
  name: ClearValue(DependencyPropertyKey)
  nameWithType: DependencyObject.ClearValue(DependencyPropertyKey)
  fullName: System.Windows.DependencyObject.ClearValue(DependencyPropertyKey)
- uid: System.Windows.DependencyPropertyKey
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyKey
  nameWithType: DependencyPropertyKey
  fullName: System.Windows.DependencyPropertyKey
- uid: System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)
  parent: System.Windows.DependencyObject
  isExternal: false
  name: CoerceValue(DependencyProperty)
  nameWithType: DependencyObject.CoerceValue(DependencyProperty)
  fullName: System.Windows.DependencyObject.CoerceValue(DependencyProperty)
- uid: System.Windows.DependencyObject.DependencyObjectType
  parent: System.Windows.DependencyObject
  isExternal: false
  name: DependencyObjectType
  nameWithType: DependencyObject.DependencyObjectType
  fullName: System.Windows.DependencyObject.DependencyObjectType
- uid: System.Windows.DependencyObjectType
  parent: System.Windows
  isExternal: false
  name: DependencyObjectType
  nameWithType: DependencyObjectType
  fullName: System.Windows.DependencyObjectType
- uid: System.Windows.DependencyObject.Equals(System.Object)
  parent: System.Windows.DependencyObject
  isExternal: false
  name: Equals(Object)
  nameWithType: DependencyObject.Equals(Object)
  fullName: System.Windows.DependencyObject.Equals(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.DependencyObject.GetHashCode
  parent: System.Windows.DependencyObject
  isExternal: false
  name: GetHashCode()
  nameWithType: DependencyObject.GetHashCode()
  fullName: System.Windows.DependencyObject.GetHashCode()
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.DependencyObject.GetLocalValueEnumerator
  parent: System.Windows.DependencyObject
  isExternal: false
  name: GetLocalValueEnumerator()
  nameWithType: DependencyObject.GetLocalValueEnumerator()
  fullName: System.Windows.DependencyObject.GetLocalValueEnumerator()
- uid: System.Windows.LocalValueEnumerator
  parent: System.Windows
  isExternal: false
  name: LocalValueEnumerator
  nameWithType: LocalValueEnumerator
  fullName: System.Windows.LocalValueEnumerator
- uid: System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)
  parent: System.Windows.DependencyObject
  isExternal: false
  name: GetValue(DependencyProperty)
  nameWithType: DependencyObject.GetValue(DependencyProperty)
  fullName: System.Windows.DependencyObject.GetValue(DependencyProperty)
- uid: System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)
  parent: System.Windows.DependencyObject
  isExternal: false
  name: InvalidateProperty(DependencyProperty)
  nameWithType: DependencyObject.InvalidateProperty(DependencyProperty)
  fullName: System.Windows.DependencyObject.InvalidateProperty(DependencyProperty)
- uid: System.Windows.DependencyObject.IsSealed
  parent: System.Windows.DependencyObject
  isExternal: false
  name: IsSealed
  nameWithType: DependencyObject.IsSealed
  fullName: System.Windows.DependencyObject.IsSealed
- uid: System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.DependencyObject
  isExternal: false
  name: OnPropertyChanged(DependencyPropertyChangedEventArgs)
  nameWithType: DependencyObject.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.DependencyObject.OnPropertyChanged(DependencyPropertyChangedEventArgs)
- uid: System.Windows.DependencyPropertyChangedEventArgs
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyChangedEventArgs
  nameWithType: DependencyPropertyChangedEventArgs
  fullName: System.Windows.DependencyPropertyChangedEventArgs
- uid: System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)
  parent: System.Windows.DependencyObject
  isExternal: false
  name: ReadLocalValue(DependencyProperty)
  nameWithType: DependencyObject.ReadLocalValue(DependencyProperty)
  fullName: System.Windows.DependencyObject.ReadLocalValue(DependencyProperty)
- uid: System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)
  parent: System.Windows.DependencyObject
  isExternal: false
  name: SetCurrentValue(DependencyProperty,Object)
  nameWithType: DependencyObject.SetCurrentValue(DependencyProperty,Object)
  fullName: System.Windows.DependencyObject.SetCurrentValue(DependencyProperty,Object)
- uid: System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)
  parent: System.Windows.DependencyObject
  isExternal: false
  name: SetValue(DependencyProperty,Object)
  nameWithType: DependencyObject.SetValue(DependencyProperty,Object)
  fullName: System.Windows.DependencyObject.SetValue(DependencyProperty,Object)
- uid: System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)
  parent: System.Windows.DependencyObject
  isExternal: false
  name: SetValue(DependencyPropertyKey,Object)
  nameWithType: DependencyObject.SetValue(DependencyPropertyKey,Object)
  fullName: System.Windows.DependencyObject.SetValue(DependencyPropertyKey,Object)
- uid: System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)
  parent: System.Windows.DependencyObject
  isExternal: false
  name: ShouldSerializeProperty(DependencyProperty)
  nameWithType: DependencyObject.ShouldSerializeProperty(DependencyProperty)
  fullName: System.Windows.DependencyObject.ShouldSerializeProperty(DependencyProperty)
- uid: System.Windows.DependencyObject.#ctor*
  parent: System.Windows.DependencyObject
  isExternal: false
  name: DependencyObject
  nameWithType: DependencyObject.DependencyObject
- uid: System.Windows.DependencyObject.ClearValue*
  parent: System.Windows.DependencyObject
  isExternal: false
  name: ClearValue
  nameWithType: DependencyObject.ClearValue
- uid: System.Windows.DependencyObject.CoerceValue*
  parent: System.Windows.DependencyObject
  isExternal: false
  name: CoerceValue
  nameWithType: DependencyObject.CoerceValue
- uid: System.Windows.DependencyObject.DependencyObjectType*
  parent: System.Windows.DependencyObject
  isExternal: false
  name: DependencyObjectType
  nameWithType: DependencyObject.DependencyObjectType
- uid: System.Windows.DependencyObject.Equals*
  parent: System.Windows.DependencyObject
  isExternal: false
  name: Equals
  nameWithType: DependencyObject.Equals
- uid: System.Windows.DependencyObject.GetHashCode*
  parent: System.Windows.DependencyObject
  isExternal: false
  name: GetHashCode
  nameWithType: DependencyObject.GetHashCode
- uid: System.Windows.DependencyObject.GetLocalValueEnumerator*
  parent: System.Windows.DependencyObject
  isExternal: false
  name: GetLocalValueEnumerator
  nameWithType: DependencyObject.GetLocalValueEnumerator
- uid: System.Windows.DependencyObject.GetValue*
  parent: System.Windows.DependencyObject
  isExternal: false
  name: GetValue
  nameWithType: DependencyObject.GetValue
- uid: System.Windows.DependencyObject.InvalidateProperty*
  parent: System.Windows.DependencyObject
  isExternal: false
  name: InvalidateProperty
  nameWithType: DependencyObject.InvalidateProperty
- uid: System.Windows.DependencyObject.IsSealed*
  parent: System.Windows.DependencyObject
  isExternal: false
  name: IsSealed
  nameWithType: DependencyObject.IsSealed
- uid: System.Windows.DependencyObject.OnPropertyChanged*
  parent: System.Windows.DependencyObject
  isExternal: false
  name: OnPropertyChanged
  nameWithType: DependencyObject.OnPropertyChanged
- uid: System.Windows.DependencyObject.ReadLocalValue*
  parent: System.Windows.DependencyObject
  isExternal: false
  name: ReadLocalValue
  nameWithType: DependencyObject.ReadLocalValue
- uid: System.Windows.DependencyObject.SetCurrentValue*
  parent: System.Windows.DependencyObject
  isExternal: false
  name: SetCurrentValue
  nameWithType: DependencyObject.SetCurrentValue
- uid: System.Windows.DependencyObject.SetValue*
  parent: System.Windows.DependencyObject
  isExternal: false
  name: SetValue
  nameWithType: DependencyObject.SetValue
- uid: System.Windows.DependencyObject.ShouldSerializeProperty*
  parent: System.Windows.DependencyObject
  isExternal: false
  name: ShouldSerializeProperty
  nameWithType: DependencyObject.ShouldSerializeProperty
