### YamlMime:ManagedReference
items:
- uid: System.Windows.Threading.Dispatcher
  id: Dispatcher
  children:
  - System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Object[])
  - System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  - System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  - System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  - System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  - System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)
  - System.Windows.Threading.Dispatcher.CheckAccess
  - System.Windows.Threading.Dispatcher.CurrentDispatcher
  - System.Windows.Threading.Dispatcher.DisableProcessing
  - System.Windows.Threading.Dispatcher.ExitAllFrames
  - System.Windows.Threading.Dispatcher.FromThread(System.Threading.Thread)
  - System.Windows.Threading.Dispatcher.HasShutdownFinished
  - System.Windows.Threading.Dispatcher.HasShutdownStarted
  - System.Windows.Threading.Dispatcher.Hooks
  - System.Windows.Threading.Dispatcher.Invoke(System.Action)
  - System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority)
  - System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  - System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  - System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)
  - System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  - System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0})
  - System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  - System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  - System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  - System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)
  - System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)
  - System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  - System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})
  - System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  - System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  - System.Windows.Threading.Dispatcher.InvokeShutdown
  - System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)
  - System.Windows.Threading.Dispatcher.Run
  - System.Windows.Threading.Dispatcher.ShutdownFinished
  - System.Windows.Threading.Dispatcher.ShutdownStarted
  - System.Windows.Threading.Dispatcher.Thread
  - System.Windows.Threading.Dispatcher.UnhandledException
  - System.Windows.Threading.Dispatcher.UnhandledExceptionFilter
  - System.Windows.Threading.Dispatcher.ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)
  - System.Windows.Threading.Dispatcher.VerifyAccess
  - System.Windows.Threading.Dispatcher.Yield
  - System.Windows.Threading.Dispatcher.Yield(System.Windows.Threading.DispatcherPriority)
  langs:
  - csharp
  name: Dispatcher
  nameWithType: Dispatcher
  fullName: System.Windows.Threading.Dispatcher
  type: Class
  summary: "提供用于管理工作项的线程的队列服务。"
  remarks: "调度程序维护特定线程的工作项按优先级排列的队列。       当调度程序线程上创建时，它将成为唯一调度程序可能与线程，即使调度程序已关闭。       如果你尝试获取<xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>当前线程和调度程序是不与线程关联，请将创建调度程序。</xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> 创建一种<xref:System.Windows.Threading.DispatcherObject>。</xref:System.Windows.Threading.DispatcherObject>时，还创建调度程序 如果在后台线程上创建调度程序，请确保在退出线程之前关闭调度程序。       如果调度程序关闭的情况下，它不能重新启动。       在[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]、<xref:System.Windows.Threading.DispatcherObject>仅可以由调度程序与之关联。</xref:System.Windows.Threading.DispatcherObject>  例如，后台线程不能更新的内容<xref:System.Windows.Controls.Button>与调度程序关联上[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]线程。</xref:System.Windows.Controls.Button>  为了使后台线程访问<xref:System.Windows.Controls.ContentControl.Content%2A>属性<xref:System.Windows.Controls.Button>，后台线程必须委托到调度程序与关联的工作[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]线程。</xref:System.Windows.Controls.Button> </xref:System.Windows.Controls.ContentControl.Content%2A>  这是通过使用其中一种<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>实现 <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  该操作添加到的位置指定<xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority>的调度程序队列       如果<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>在调度程序的已关闭，返回<xref:System.Windows.Threading.DispatcherOperation>设置为<xref:System.Windows.Threading.DispatcherOperationStatus>。</xref:System.Windows.Threading.DispatcherOperationStatus></xref:System.Windows.Threading.DispatcherOperation>的 status 属性上调用</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       调度程序上的例外情况的方法的所有<xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>，为自由线程对象。</xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>       从派生的对象<xref:System.Windows.Threading.DispatcherObject>具有线程关联。</xref:System.Windows.Threading.DispatcherObject>       从派生的对象<xref:System.Windows.Freezable>是自由线程时它们已冻结。</xref:System.Windows.Freezable>  有关详细信息，请参阅[可冻结对象概述](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example shows how to place an operation onto a Dispatcher.  For the full source code of this example, see [Single-Threaded Application with Long-Running Calculation Sample](http://go.microsoft.com/fwlink/?LinkID=160038).  \n  \n First, a delegate is created that accepts no arguments.  \n  \n [!code-vb[ThreadingPrimeNumber#ThreadingPrimeNumberInit](~/add/codesnippet/visualbasic/t-system.windows.threadi_2_1.vb)]\n [!code-cs[ThreadingPrimeNumber#ThreadingPrimeNumberInit](~/add/codesnippet/csharp/t-system.windows.threadi_2_1.cs)]  \n  \n Next, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> is called.  This call to <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> takes two parameters: the priority, which is set to <xref:System.Windows.Threading.DispatcherPriority?displayProperty=fullName>, and the callback, which is passed in through an instance of the delegate `NextPrimeDelegate`.  \n  \n [!code-vb[ThreadingPrimeNumber#ThreadingPrimeNumberBeingInvoke](~/add/codesnippet/visualbasic/t-system.windows.threadi_2_2.vb)]\n [!code-cs[ThreadingPrimeNumber#ThreadingPrimeNumberBeingInvoke](~/add/codesnippet/csharp/t-system.windows.threadi_2_2.cs)]"
  syntax:
    content: public sealed class Dispatcher
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Object[])
  id: BeginInvoke(System.Delegate,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvoke(Delegate,Object[])
  nameWithType: Dispatcher.BeginInvoke(Delegate,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(Delegate,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "在线程上执行异步使用指定的参数指定的委托， <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>上创建。"
  remarks: "<xref:System.Windows.Threading.DispatcherOperation>返回对象<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>可通过多种方式与指定的委托，如交互:-更改<xref:System.Windows.Threading.DispatcherPriority>的委托因为它正在等待执行的事件队列。</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.DispatcherOperation>      -从事件队列中删除委托。      -等待要返回的委托。      -执行获取在委托返回其后的值。       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的;因此，控制权会立即返回到调用的对象后调用。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       在[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。</xref:System.Windows.Threading.DispatcherObject> 例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。</xref:System.Windows.Controls.Button> 为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> 这是通过使用其中一种<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>实现 <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> 该操作将添加到事件队列。<xref:System.Windows.Threading.Dispatcher>在指定<xref:System.Windows.Threading.DispatcherPriority>。</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       如果<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>调用上<xref:System.Windows.Threading.Dispatcher>，已关闭，返回<xref:System.Windows.Threading.DispatcherOperation>设置为<xref:System.Windows.Threading.DispatcherOperationStatus>。</xref:System.Windows.Threading.DispatcherOperationStatus></xref:System.Windows.Threading.DispatcherOperation>的 status 属性</xref:System.Windows.Threading.Dispatcher></xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "采用参数中指定的方法的委托`args`，这将被推送到<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件队列。"
    - id: args
      type: System.Object[]
      description: "要将作为自变量传递给给定方法的对象数组。 Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "一个对象，它之后立即返回<xref:System.Windows.Threading.Dispatcher.BeginInvoke*>调用时，可用来与该委托，因为它是挂起的执行在事件队列。</xref:System.Windows.Threading.Dispatcher.BeginInvoke*>"
  overload: System.Windows.Threading.Dispatcher.BeginInvoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  id: BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvoke(DispatcherPriority,Delegate)
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate)
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "在线程上执行指定的委托以异步方式在指定的优先级<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>与相关联。"
  remarks: "如果在同一个可执行多个 BeginInvoke 调用<xref:System.Windows.Threading.DispatcherPriority>，它们将在调用所做的顺序执行。</xref:System.Windows.Threading.DispatcherPriority>       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>返回<xref:System.Windows.Threading.DispatcherOperation>可以用于委托时在事件队列的委托交互的对象。</xref:System.Windows.Threading.DispatcherOperation></xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       <xref:System.Windows.Threading.DispatcherOperation>返回对象<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>可通过多种方式与指定的委托，如交互:-更改<xref:System.Windows.Threading.DispatcherPriority>的委托因为它正在等待执行的事件队列。</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.DispatcherOperation>      -从事件队列中删除委托。      -等待要返回的委托。      -执行获取在委托返回其后的值。       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的;因此，控制权会立即返回到调用的对象后调用。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       在[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。</xref:System.Windows.Threading.DispatcherObject>  例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。</xref:System.Windows.Controls.Button>  为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  这是通过使用其中一种<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>实现  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  该操作将添加到事件队列。<xref:System.Windows.Threading.Dispatcher>在指定<xref:System.Windows.Threading.DispatcherPriority>。</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       如果<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>调用上<xref:System.Windows.Threading.Dispatcher>，已关闭，返回<xref:System.Windows.Threading.DispatcherOperation>设置为<xref:System.Windows.Threading.DispatcherOperationStatus>。</xref:System.Windows.Threading.DispatcherOperationStatus></xref:System.Windows.Threading.DispatcherOperation>的 status 属性</xref:System.Windows.Threading.Dispatcher></xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>"
  example:
  - "The following example shows how to place an operation onto a <xref:System.Windows.Threading.Dispatcher>.  For the full source code of this example, see [Single-Threaded Application with Long-Running Calculation Sample](http://go.microsoft.com/fwlink/?LinkID=160038).  \n  \n First, a delegate is created that accepts no arguments.  \n  \n [!code-vb[ThreadingPrimeNumber#ThreadingPrimeNumberInit](~/add/codesnippet/visualbasic/8c08cb62-5b5f-4560-a7bd-_1.vb)]\n [!code-cs[ThreadingPrimeNumber#ThreadingPrimeNumberInit](~/add/codesnippet/csharp/8c08cb62-5b5f-4560-a7bd-_1.cs)]  \n  \n Next, BeginInvoke is called.  Because every <xref:System.Windows.Threading.DispatcherObject> has a property that returns the <xref:System.Windows.Threading.Dispatcher> it is associated with, the desired <xref:System.Windows.Threading.Dispatcher> is obtained by querying the <xref:System.Windows.Threading.DispatcherObject>, in this case a <xref:System.Windows.Controls.Button> named `startStopButton`.   The call to BeginInvoke takes two parameters: the priority, which is set to <xref:System.Windows.Threading.DispatcherPriority?displayProperty=fullName>, and the callback, which is passed in through an instance of the delegate `NextPrimeDelegate`.  \n  \n [!code-vb[ThreadingPrimeNumber#ThreadingPrimeNumberBeingInvoke](~/add/codesnippet/visualbasic/8c08cb62-5b5f-4560-a7bd-_2.vb)]\n [!code-cs[ThreadingPrimeNumber#ThreadingPrimeNumberBeingInvoke](~/add/codesnippet/csharp/8c08cb62-5b5f-4560-a7bd-_2.cs)]"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "优先级，相对于其他挂起的操作以<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>调用事件队列，指定方法。"
    - id: method
      type: System.Delegate
      description: "对方法的委托不采用任何参数，其将被推送到<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件队列。"
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "一个对象，它之后立即返回<xref:System.Windows.Threading.Dispatcher.BeginInvoke*>调用时，可用来与该委托，因为它是挂起的执行在事件队列。</xref:System.Windows.Threading.Dispatcher.BeginInvoke*>"
  overload: System.Windows.Threading.Dispatcher.BeginInvoke*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>不是有效<xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>。"
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  id: BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvoke(Delegate,DispatcherPriority,Object[])
  nameWithType: Dispatcher.BeginInvoke(Delegate,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(Delegate,DispatcherPriority,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "在线程上执行指定的委托使用指定的参数，以指定的优先级，以异步方式， <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>上创建。"
  remarks: "<xref:System.Windows.Threading.DispatcherOperation>返回对象<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>可通过多种方式与指定的委托，如交互:-更改<xref:System.Windows.Threading.DispatcherPriority>的委托因为它正在等待执行的事件队列。</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.DispatcherOperation>      -从事件队列中删除委托。      -等待要返回的委托。      -执行获取在委托返回其后的值。       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的;因此，控制权会立即返回到调用的对象后调用。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       在[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。</xref:System.Windows.Threading.DispatcherObject> 例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。</xref:System.Windows.Controls.Button> 为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> 这是通过使用其中一种<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>实现 <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> 该操作将添加到事件队列。<xref:System.Windows.Threading.Dispatcher>在指定<xref:System.Windows.Threading.DispatcherPriority>。</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       如果<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>调用上<xref:System.Windows.Threading.Dispatcher>，已关闭，返回<xref:System.Windows.Threading.DispatcherOperation>设置为<xref:System.Windows.Threading.DispatcherOperationStatus>。</xref:System.Windows.Threading.DispatcherOperationStatus></xref:System.Windows.Threading.DispatcherOperation>的 status 属性</xref:System.Windows.Threading.Dispatcher></xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "采用参数中指定的方法的委托`args`，这将被推送到<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件队列。"
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "优先级，相对于其他挂起的操作以<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>调用事件队列，指定方法。"
    - id: args
      type: System.Object[]
      description: "要将作为自变量传递给给定方法的对象数组。 Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "一个对象，它之后立即返回<xref:System.Windows.Threading.Dispatcher.BeginInvoke*>调用时，可用来与该委托，因为它是挂起的执行在事件队列。</xref:System.Windows.Threading.Dispatcher.BeginInvoke*>"
  overload: System.Windows.Threading.Dispatcher.BeginInvoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  id: BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvoke(DispatcherPriority,Delegate,Object)
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "在线程上执行指定的委托以异步方式在指定的优先级并且指定的自变量<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>与相关联。"
  remarks: "`Arg`可以是`null`如果不需要参数。       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>返回<xref:System.Windows.Threading.DispatcherOperation>可以用于委托时在事件队列的委托交互的对象。</xref:System.Windows.Threading.DispatcherOperation></xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       <xref:System.Windows.Threading.DispatcherOperation>返回对象<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>可通过多种方式与指定的委托，如交互:-更改<xref:System.Windows.Threading.DispatcherPriority>的委托因为它正在等待执行的事件队列。</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.DispatcherOperation>      -从事件队列中删除委托。      -等待要返回的委托。      -执行获取在委托返回其后的值。       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的;因此，控制权会立即返回到调用的对象后调用。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       在[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。</xref:System.Windows.Threading.DispatcherObject>  例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。</xref:System.Windows.Controls.Button>  为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  这是通过使用其中一种<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>实现  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  该操作将添加到事件队列。<xref:System.Windows.Threading.Dispatcher>在指定<xref:System.Windows.Threading.DispatcherPriority>。</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       如果选择多个<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>调用在同一个<xref:System.Windows.Threading.DispatcherPriority>，它们将在调用所做的顺序执行。</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       如果<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>调用上<xref:System.Windows.Threading.Dispatcher>，已关闭，返回<xref:System.Windows.Threading.DispatcherOperation>设置为<xref:System.Windows.Threading.DispatcherOperationStatus>。</xref:System.Windows.Threading.DispatcherOperationStatus></xref:System.Windows.Threading.DispatcherOperation>的 status 属性</xref:System.Windows.Threading.Dispatcher></xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>"
  example:
  - "The following example shows how to place an operation onto a <xref:System.Windows.Threading.Dispatcher>.  \n  \n First, a delegate is created that accepts one argument, in this case a string.  \n  \n [!code-vb[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/add/codesnippet/visualbasic/threadingweatherforecastsample/window1.xaml.vb#threadingweatherdelegates)]\n [!code-cs[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/add/codesnippet/csharp/ThreadingWeatherForecastSample/Window1.xaml.cs#threadingweatherdelegates)]  \n  \n Next, BeginInvoke is called.  Because every <xref:System.Windows.Threading.DispatcherObject> has a property that returns the <xref:System.Windows.Threading.Dispatcher> it is associated with, the desired <xref:System.Windows.Threading.Dispatcher> is obtained by querying the <xref:System.Windows.Threading.DispatcherObject>, in this case a <xref:System.Windows.Controls.Grid> named `tomorrowsWeather`. The call to BeginInvoke takes three parameters: the priority, which is set to <xref:System.Windows.Threading.DispatcherPriority?displayProperty=fullName>; the callback, which is passed in through an instance of the delegate `OneArgDelegate`; and a string named `weather`, which is the argument for the callback.  \n  \n [!code-vb[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/add/codesnippet/visualbasic/threadingweatherforecastsample/window1.xaml.vb#threadingweatherdispatcheronearge)]\n [!code-cs[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/add/codesnippet/csharp/ThreadingWeatherForecastSample/Window1.xaml.cs#threadingweatherdispatcheronearge)]"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "优先级，相对于其他挂起的操作以<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>调用事件队列，指定方法。"
    - id: method
      type: System.Delegate
      description: "采用一个参数，将被推送到方法的委托<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件队列。"
    - id: arg
      type: System.Object
      description: "要将作为自变量传递给指定的方法的对象。"
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "一个对象，它之后立即返回<xref:System.Windows.Threading.Dispatcher.BeginInvoke*>调用时，可用来与该委托，因为它是挂起的执行在事件队列。</xref:System.Windows.Threading.Dispatcher.BeginInvoke*>"
  overload: System.Windows.Threading.Dispatcher.BeginInvoke*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>不是有效<xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>。"
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  id: BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "在线程上执行指定的委托以异步方式在指定的优先级并且指定的自变量数组<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>与相关联。"
  remarks: "`arg`参数可以为`null`如果不需要参数。       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>返回<xref:System.Windows.Threading.DispatcherOperation>可以用于委托时在事件队列的委托交互的对象。</xref:System.Windows.Threading.DispatcherOperation></xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       <xref:System.Windows.Threading.DispatcherOperation>返回对象<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>可通过多种方式与指定的委托，如交互:-更改<xref:System.Windows.Threading.DispatcherPriority>的委托因为它正在等待执行的事件队列。</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.DispatcherOperation>      -从事件队列中删除委托。      -等待要返回的委托。      -执行获取在委托返回其后的值。       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的;因此，控制权会立即返回到调用的对象后调用。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       在[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。</xref:System.Windows.Threading.DispatcherObject>  例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。</xref:System.Windows.Controls.Button>  为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  这是通过使用其中一种<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>实现  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  该操作将添加到事件队列。<xref:System.Windows.Threading.Dispatcher>在指定<xref:System.Windows.Threading.DispatcherPriority>。</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       如果选择多个<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>调用在同一个<xref:System.Windows.Threading.DispatcherPriority>，它们将在调用所做的顺序执行。</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       如果<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>调用上<xref:System.Windows.Threading.Dispatcher>，已关闭，返回<xref:System.Windows.Threading.DispatcherOperation>设置为<xref:System.Windows.Threading.DispatcherOperationStatus>。</xref:System.Windows.Threading.DispatcherOperationStatus></xref:System.Windows.Threading.DispatcherOperation>的 status 属性</xref:System.Windows.Threading.Dispatcher></xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, object[] args);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "优先级，相对于其他挂起的操作以<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>调用事件队列，指定方法。"
    - id: method
      type: System.Delegate
      description: "方法的委托采用多个自变量，这将被推送到<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件队列。"
    - id: arg
      type: System.Object
      description: "要将作为自变量传递给指定的方法的对象。"
    - id: args
      type: System.Object[]
      description: "要作为参数传递的指定方法的对象数组。"
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "一个对象，它之后立即返回<xref:System.Windows.Threading.Dispatcher.BeginInvoke*>调用时，可用来按原样中挂起执行的委托交互<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>队列。</xref:System.Windows.Threading.Dispatcher.BeginInvoke*>"
  overload: System.Windows.Threading.Dispatcher.BeginInvoke*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;></xref>不是有效的优先级。"
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)
  id: BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvokeShutdown(DispatcherPriority)
  nameWithType: Dispatcher.BeginInvokeShutdown(DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.BeginInvokeShutdown(DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "启动关闭<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>以异步方式。"
  remarks: "BeginInvokeShutdown 要求不受限制的 UI 权限。       当<xref:System.Windows.Threading.Dispatcher>开始关闭的情况下，<xref:System.Windows.Threading.Dispatcher.ShutdownStarted>引发事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>设置为`true`。</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownStarted> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher>不会关闭完全展开事件队列之前。</xref:System.Windows.Threading.Dispatcher>       调度程序完成的情况下，关闭时<xref:System.Windows.Threading.Dispatcher.ShutdownFinished>引发事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>属性设置为`true`。</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownFinished>       关闭流程开始之后，所有挂起的工作将中止队列中的项。"
  syntax:
    content: public void BeginInvokeShutdown (System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "从此处开始关闭调度程序优先级。"
  overload: System.Windows.Threading.Dispatcher.BeginInvokeShutdown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.CheckAccess
  id: CheckAccess
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: CheckAccess()
  nameWithType: Dispatcher.CheckAccess()
  fullName: System.Windows.Threading.Dispatcher.CheckAccess()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "确定调用线程是否与此相关的线程<xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>。"
  remarks: "仅<xref:System.Windows.Threading.Dispatcher>，<xref:System.Windows.Threading.DispatcherObject>创建在可能访问的对象。</xref:System.Windows.Threading.DispatcherObject> </xref:System.Windows.Threading.Dispatcher>  使用<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>用于从另一个线程访问的对象。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>       可以从任何线程调用 checkaccess 方法。       Checkaccess 方法之间的差异和<xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A>为 checkaccess 方法将返回一个布尔值，该值指示调用线程是否有权访问<xref:System.Windows.Threading.Dispatcher>和<xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A>引发异常。</xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A>"
  example:
  - "The following example uses CheckAccess to determine whether a thread has access to a <xref:System.Windows.Controls.Button>.  The CheckAccess method on the <xref:System.Windows.Threading.Dispatcher> associated with the <xref:System.Windows.Controls.Button> is called to verify access to the thread.  If the calling thread has access to the <xref:System.Windows.Threading.Dispatcher>, the <xref:System.Windows.Controls.Button> is updated by accessing the members of the <xref:System.Windows.Controls.Button>; otherwise, a delegate, which accepts a <xref:System.Windows.Controls.Button> as an argument, is placed onto the <xref:System.Windows.Threading.Dispatcher>.  The <xref:System.Windows.Threading.Dispatcher> will delegate the work of updating the <xref:System.Windows.Controls.Button>.  \n  \n [!code-cs[DispatcherAccessSample#DispatcherAccessCheckAccess](~/add/codesnippet/csharp/DispatcherAccessSample/Window1.xaml.cs#dispatcheraccesscheckaccess)]\n [!code-vb[DispatcherAccessSample#DispatcherAccessCheckAccess](~/add/codesnippet/visualbasic/dispatcheraccesssample/window1.xaml.vb#dispatcheraccesscheckaccess)]"
  syntax:
    content: public bool CheckAccess ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>调用线程是否与此相关的线程<xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.Threading.Dispatcher.CheckAccess*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.CurrentDispatcher
  id: CurrentDispatcher
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: CurrentDispatcher
  nameWithType: Dispatcher.CurrentDispatcher
  fullName: System.Windows.Threading.Dispatcher.CurrentDispatcher
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "获取<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>与线程当前正在执行，并创建新<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>如果未与线程相关联。"
  remarks: "如果<xref:System.Windows.Threading.Dispatcher>不是与当前线程关联的新<xref:System.Windows.Threading.Dispatcher>将创建。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher>  这不是这种情况<xref:System.Windows.Threading.Dispatcher.FromThread%2A>方法。</xref:System.Windows.Threading.Dispatcher.FromThread%2A>  <xref:System.Windows.Threading.Dispatcher.FromThread%2A>将返回`null`是否不存在与指定的线程调度程序。</xref:System.Windows.Threading.Dispatcher.FromThread%2A>"
  syntax:
    content: public static System.Windows.Threading.Dispatcher CurrentDispatcher { get; }
    return:
      type: System.Windows.Threading.Dispatcher
      description: "调度程序与当前线程关联。"
  overload: System.Windows.Threading.Dispatcher.CurrentDispatcher*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.DisableProcessing
  id: DisableProcessing
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: DisableProcessing()
  nameWithType: Dispatcher.DisableProcessing()
  fullName: System.Windows.Threading.Dispatcher.DisableProcessing()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "禁用处理<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>队列。"
  remarks: "禁用调度程序处理属于高级的方法，旨在消除不相关的重新进入的可能性。       禁用处理的影响是，如下所示:-[!INCLUDE[TLA2#tla_clr#initcap](~/add/includes/tla2sharptla-clrsharpinitcap-md.md)]锁都将不内部发送消息。      -<xref:System.Windows.Threading.DispatcherFrame>对象不允许推送。</xref:System.Windows.Threading.DispatcherFrame>      的不允许消息处理。       <xref:System.Windows.Threading.DispatcherProcessingDisabled>DisableProcessing 返回被调用时的结构可用来重新启用调度程序处理。</xref:System.Windows.Threading.DispatcherProcessingDisabled>  调用<xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A>上<xref:System.Windows.Threading.DispatcherProcessingDisabled>结构将重新启用处理。</xref:System.Windows.Threading.DispatcherProcessingDisabled> </xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A>       只能在线程上调用 DisableProcessing<xref:System.Windows.Threading.Dispatcher>与相关联。</xref:System.Windows.Threading.Dispatcher>"
  example:
  - "The following example shows how to disable dispatcher processing and re-enable dispatcher processing.  DisableProcessing is called in a **using** statement.  DisableProcessing returns a <xref:System.Windows.Threading.DispatcherProcessingDisabled> structure that is used as the object to be disposed when the **using** block finishes.  When <xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A> is called on the <xref:System.Windows.Threading.DispatcherProcessingDisabled> structure, dispatcher processing is re-enabled.  \n  \n [!code-vb[DispatcherSnippets#DispatcherDisableProcessing](~/add/codesnippet/visualbasic/dispatchersnippets/window1.xaml.vb#dispatcherdisableprocessing)]\n [!code-cs[DispatcherSnippets#DispatcherDisableProcessing](~/add/codesnippet/csharp/DispatcherSnippets/Window1.xaml.cs#dispatcherdisableprocessing)]"
  syntax:
    content: public System.Windows.Threading.DispatcherProcessingDisabled DisableProcessing ();
    parameters: []
    return:
      type: System.Windows.Threading.DispatcherProcessingDisabled
      description: "用于重新启用处理的调度程序的结构。"
  overload: System.Windows.Threading.Dispatcher.DisableProcessing*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.ExitAllFrames
  id: ExitAllFrames
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: ExitAllFrames()
  nameWithType: Dispatcher.ExitAllFrames()
  fullName: System.Windows.Threading.Dispatcher.ExitAllFrames()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "退出所有帧，包括嵌套的帧的请求。"
  syntax:
    content: public static void ExitAllFrames ();
    parameters: []
  overload: System.Windows.Threading.Dispatcher.ExitAllFrames*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.FromThread(System.Threading.Thread)
  id: FromThread(System.Threading.Thread)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: FromThread(Thread)
  nameWithType: Dispatcher.FromThread(Thread)
  fullName: System.Windows.Threading.Dispatcher.FromThread(Thread)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "获取<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>指定的线程。"
  remarks: "如果没有可用于指定线程的调度程序`null`将返回。       FromThread 不创建<xref:System.Windows.Threading.Dispatcher>在线程不具有一种<xref:System.Windows.Threading.Dispatcher>。</xref:System.Windows.Threading.Dispatcher>上</xref:System.Windows.Threading.Dispatcher>   一个新<xref:System.Windows.Threading.Dispatcher>尚不包含的线程上创建<xref:System.Windows.Threading.Dispatcher>时尝试获取<xref:System.Windows.Threading.Dispatcher>使用<xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>属性。</xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher>"
  syntax:
    content: public static System.Windows.Threading.Dispatcher FromThread (System.Threading.Thread thread);
    parameters:
    - id: thread
      type: System.Threading.Thread
      description: "要获取的线程<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>从。"
    return:
      type: System.Windows.Threading.Dispatcher
      description: "调度程序<code> thread </code>。"
  overload: System.Windows.Threading.Dispatcher.FromThread*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.HasShutdownFinished
  id: HasShutdownFinished
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: HasShutdownFinished
  nameWithType: Dispatcher.HasShutdownFinished
  fullName: System.Windows.Threading.Dispatcher.HasShutdownFinished
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "确定是否<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>已完成的情况下关闭。"
  remarks: "当<xref:System.Windows.Threading.Dispatcher>开始关闭的情况下，<xref:System.Windows.Threading.Dispatcher.ShutdownStarted>引发事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>设置为`true`。</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownStarted> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher>事件队列展开之前完全没有关闭。</xref:System.Windows.Threading.Dispatcher>       调度程序完成的情况下，关闭时<xref:System.Windows.Threading.Dispatcher.ShutdownFinished>引发事件和 HasShutdownFinished 属性设置为`true`。</xref:System.Windows.Threading.Dispatcher.ShutdownFinished>       关闭流程开始之后，所有挂起的工作将中止队列中的项。"
  syntax:
    content: public bool HasShutdownFinished { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果调度程序已完成关闭;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.Threading.Dispatcher.HasShutdownFinished*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.HasShutdownStarted
  id: HasShutdownStarted
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: HasShutdownStarted
  nameWithType: Dispatcher.HasShutdownStarted
  fullName: System.Windows.Threading.Dispatcher.HasShutdownStarted
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "确定是否<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>正在关闭。"
  remarks: "当<xref:System.Windows.Threading.Dispatcher>开始关闭的情况下，<xref:System.Windows.Threading.Dispatcher.ShutdownStarted>引发事件和 HasShutdownStarted 设置为`true`。</xref:System.Windows.Threading.Dispatcher.ShutdownStarted> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher>不会关闭完全展开事件队列之前。</xref:System.Windows.Threading.Dispatcher>       调度程序完成的情况下，关闭时<xref:System.Windows.Threading.Dispatcher.ShutdownFinished>引发事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>属性设置为`true`。</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownFinished>       关闭流程开始之后，所有挂起的工作将中止队列中的项。"
  syntax:
    content: public bool HasShutdownStarted { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>已开始关闭; 否则为为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.Threading.Dispatcher.HasShutdownStarted*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Hooks
  id: Hooks
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Hooks
  nameWithType: Dispatcher.Hooks
  fullName: System.Windows.Threading.Dispatcher.Hooks
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "获取的集合提供了一些其他事件信息的挂钩<xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>。"
  remarks: "<xref:System.Windows.Threading.DispatcherHooks>类提供了有关的其他事件信息<xref:System.Windows.Threading.Dispatcher>，例如，当<xref:System.Windows.Threading.Dispatcher>处于非活动状态或完成操作时。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.DispatcherHooks>"
  syntax:
    content: public System.Windows.Threading.DispatcherHooks Hooks { get; }
    return:
      type: System.Windows.Threading.DispatcherHooks
      description: "与此关联的挂钩<xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>。"
  overload: System.Windows.Threading.Dispatcher.Hooks*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action)
  id: Invoke(System.Action)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Action)
  nameWithType: Dispatcher.Invoke(Action)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "执行指定<xref:System.Action>线程上同步<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>与相关联。</xref:System.Action>"
  syntax:
    content: public void Invoke (Action callback);
    parameters:
    - id: callback
      type: System.Action
      description: "要通过调度程序调用的委托。"
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority)
  id: Invoke(System.Action,System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Action,DispatcherPriority)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "执行指定<xref:System.Action>同步在线程上指定的优先级<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>与相关联。</xref:System.Action>"
  syntax:
    content: public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: callback
      type: System.Action
      description: "要通过调度程序调用的委托。"
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "确定以何种顺序指定的回调调用相对于其他挂起的操作中的优先级<xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>。"
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Object[])
  id: Invoke(System.Delegate,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Delegate,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "在线程上异步执行指定的参数与指定的委托<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>与相关联。"
  remarks: "在[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。</xref:System.Windows.Threading.DispatcherObject> 例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。</xref:System.Windows.Controls.Button> 为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> 这是通过使用其中一种<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>实现 <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> 该操作将添加到事件队列。<xref:System.Windows.Threading.Dispatcher>在指定<xref:System.Windows.Threading.DispatcherPriority>。</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步操作;因此，控件将不返回到之前调用的对象后在回调返回。</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (Delegate method, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "采用参数中指定的方法的委托`args`，这将被推送到<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件队列。"
    - id: args
      type: System.Object[]
      description: "要将作为自变量传递给给定方法的对象数组。 Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Object
      description: "正在调用的委托的返回值或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果委托没有返回值。"
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,Delegate)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "在其上的线程上执行指定的委托以同步方式按指定的优先级<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>与相关联。"
  remarks: "在[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。</xref:System.Windows.Threading.DispatcherObject>  例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。</xref:System.Windows.Controls.Button>  为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  这是通过使用其中一种<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>实现  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  该操作将添加到事件队列。<xref:System.Windows.Threading.Dispatcher>在指定<xref:System.Windows.Threading.DispatcherPriority>。</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步操作;因此，控件将不返回到之前调用的对象后在回调返回。</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  example:
  - "The following example places a delegate onto a <xref:System.Windows.Threading.Dispatcher> at <xref:System.Windows.Threading.DispatcherPriority> using Invoke.  \n  \n [!code-vb[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/add/codesnippet/visualbasic/invalidaterequerywithsystemtimer/window1.xaml.vb#systemtimerdispatcherinvoke)]\n [!code-cs[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/add/codesnippet/csharp/InvalidateRequeryWithSystemTimer/Window1.xaml.cs#systemtimerdispatcherinvoke)]"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "优先级，相对于其他挂起的操作以<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>调用事件队列，指定方法。"
    - id: method
      type: System.Delegate
      description: "方法的委托不采用任何参数，其将被推送到<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件队列。"
    return:
      type: System.Object
      description: "正在调用的委托的返回值或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果委托没有返回值。"
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>priority</code>等同于<xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>。"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>不是有效的优先级。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  id: Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Action,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "执行指定<xref:System.Action>同步在线程上指定的优先级<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>与相关联。</xref:System.Action>"
  syntax:
    content: public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: callback
      type: System.Action
      description: "要通过调度程序调用的委托。"
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "确定以何种顺序指定的回调调用相对于其他挂起的操作中的优先级<xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>。"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "一个对象，该值指示是否要取消的操作。"
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Object[])
  id: Invoke(System.Delegate,System.TimeSpan,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Delegate,TimeSpan,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,TimeSpan,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,TimeSpan,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "在线程上异步执行指定的参数与指定的优先级在指定的时间范围内指定的委托<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>与相关联。"
  remarks: "在[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。</xref:System.Windows.Threading.DispatcherObject> 例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。</xref:System.Windows.Controls.Button> 为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> 这是通过使用其中一种<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>实现 <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> 该操作将添加到事件队列。<xref:System.Windows.Threading.Dispatcher>在指定<xref:System.Windows.Threading.DispatcherPriority>。</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步操作;因此，控件将不返回到之前调用的对象后在回调返回。</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (Delegate method, TimeSpan timeout, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "采用参数中指定的方法的委托`args`，这将被推送到<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件队列。"
    - id: timeout
      type: System.TimeSpan
      description: "最长时间等待操作完成。"
    - id: args
      type: System.Object[]
      description: "要将作为自变量传递给给定方法的对象数组。 Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Object
      description: "正在调用的委托的返回值或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果委托没有返回值。"
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  id: Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Delegate,DispatcherPriority,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,DispatcherPriority,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "在线程上异步执行指定的参数与指定的优先级在指定的委托<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>与相关联。"
  remarks: "在[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。</xref:System.Windows.Threading.DispatcherObject> 例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。</xref:System.Windows.Controls.Button> 为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> 这是通过使用其中一种<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>实现 <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> 该操作将添加到事件队列。<xref:System.Windows.Threading.Dispatcher>在指定<xref:System.Windows.Threading.DispatcherPriority>。</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步操作;因此，控件将不返回到之前调用的对象后在回调返回。</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "采用参数中指定的方法的委托`args`，这将被推送到<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件队列。"
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "优先级，相对于其他挂起的操作以<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>调用事件队列，指定方法。"
    - id: args
      type: System.Object[]
      description: "要将作为自变量传递给给定方法的对象数组。 Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Object
      description: "正在调用的委托的返回值或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果委托没有返回值。"
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,Delegate,Object)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate,Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "在线程上异步执行指定的委托，以使用指定的参数指定的优先级<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>与相关联。"
  remarks: "`Arg`可以是`null`如果参数不需要在[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。</xref:System.Windows.Threading.DispatcherObject>  例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。</xref:System.Windows.Controls.Button>  为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  这是通过使用其中一种<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>实现  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  该操作将添加到事件队列。<xref:System.Windows.Threading.Dispatcher>在指定<xref:System.Windows.Threading.DispatcherPriority>。</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步操作;因此，控件将不返回到之前调用的对象后在回调返回。</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "优先级，相对于其他挂起的操作以<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>调用事件队列，指定方法。"
    - id: method
      type: System.Delegate
      description: "采用一个参数，将被推送到方法的委托<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件队列。"
    - id: arg
      type: System.Object
      description: "要将其作为自变量传递给给定方法的对象。"
    return:
      type: System.Object
      description: "正在调用的委托的返回值或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果委托没有返回值。"
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>priority</code>等同于<xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>。"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>不是有效的优先级。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,TimeSpan,Delegate)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "在线程上执行指定的委托以同步方式在指定的优先级并且指定的超时值<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>已创建。"
  remarks: "在[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。</xref:System.Windows.Threading.DispatcherObject>  例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。</xref:System.Windows.Controls.Button>  为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  这是通过使用其中一种<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>实现  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  该操作将添加到事件队列。<xref:System.Windows.Threading.Dispatcher>在指定<xref:System.Windows.Threading.DispatcherPriority>。</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步操作;因此，控件将不返回到之前调用的对象后在回调返回。</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "优先级，相对于其他挂起的操作以<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>调用事件队列，指定方法。"
    - id: timeout
      type: System.TimeSpan
      description: "等待要完成的操作的最大时间。"
    - id: method
      type: System.Delegate
      description: "对方法的委托不采用任何参数，其将被推送到<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件队列。"
    return:
      type: System.Object
      description: "正在调用的委托的返回值或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果委托没有返回值。"
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  id: Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "执行指定<xref:System.Action>同步在线程上指定的优先级<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>与相关联。</xref:System.Action>"
  syntax:
    content: public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);
    parameters:
    - id: callback
      type: System.Action
      description: "要通过调度程序调用的委托。"
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "确定以何种顺序指定的回调调用相对于其他挂起的操作中的优先级<xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>。"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "一个对象，该值指示是否要取消的操作。"
    - id: timeout
      type: System.TimeSpan
      description: "要启动的操作等待的时间最小数量。"
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])
  id: Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "在线程上异步执行指定的参数与指定的优先级在指定的时间范围内指定的委托<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>与相关联。"
  remarks: "在[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。</xref:System.Windows.Threading.DispatcherObject> 例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。</xref:System.Windows.Controls.Button> 为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> 这是通过使用其中一种<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>实现 <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> 该操作将添加到事件队列。<xref:System.Windows.Threading.Dispatcher>在指定<xref:System.Windows.Threading.DispatcherPriority>。</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步操作;因此，控件将不返回到之前调用的对象后在回调返回。</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (Delegate method, TimeSpan timeout, System.Windows.Threading.DispatcherPriority priority, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "采用参数中指定的方法的委托`args`，这将被推送到<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件队列。"
    - id: timeout
      type: System.TimeSpan
      description: "最长时间等待操作完成。"
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "优先级，相对于其他挂起的操作以<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>调用事件队列，指定方法。"
    - id: args
      type: System.Object[]
      description: "要将作为自变量传递给给定方法的对象数组。 Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Object
      description: "正在调用的委托的返回值或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果委托没有返回值。"
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,Delegate,Object,Object[])
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate,Object,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "在线程上异步执行指定的参数与指定的优先级在指定的委托<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>与相关联。"
  remarks: "`Arg`可以是`null`如果参数不需要在[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。</xref:System.Windows.Threading.DispatcherObject>  例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。</xref:System.Windows.Controls.Button>  为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  这是通过使用其中一种<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>实现  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  该操作将添加到事件队列。<xref:System.Windows.Threading.Dispatcher>在指定<xref:System.Windows.Threading.DispatcherPriority>。</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步操作;因此，控件将不返回到之前调用的对象后在回调返回。</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, object[] args);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "优先级，相对于其他挂起的操作以<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>调用事件队列，指定方法。"
    - id: method
      type: System.Delegate
      description: "方法的委托采用多个自变量，这将被推送到<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件队列。"
    - id: arg
      type: System.Object
      description: "要将其作为自变量传递给给定方法的对象。"
    - id: args
      type: System.Object[]
      description: "要将作为自变量传递给给定方法的对象数组。"
    return:
      type: System.Object
      description: "正在调用的委托的返回值或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果委托没有返回值。"
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>priority</code>等同于<xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>。"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>不是有效的优先级。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "在线程上异步执行指定的委托，以使用指定的参数指定的优先级<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>与相关联。"
  remarks: "`Arg`可以是`null`如果参数不需要在[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。</xref:System.Windows.Threading.DispatcherObject>  例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。</xref:System.Windows.Controls.Button>  为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  这是通过使用其中一种<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>实现  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  该操作将添加到事件队列。<xref:System.Windows.Threading.Dispatcher>在指定<xref:System.Windows.Threading.DispatcherPriority>。</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步操作;因此，控件将不返回到之前调用的对象后在回调返回。</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "优先级，相对于其他挂起的操作以<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>调用事件队列，指定方法。"
    - id: timeout
      type: System.TimeSpan
      description: "等待要完成的操作的最大时间。"
    - id: method
      type: System.Delegate
      description: "方法的委托采用多个自变量，这将被推送到<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件队列。"
    - id: arg
      type: System.Object
      description: "要将其作为自变量传递给给定方法的对象。 这可以是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果不需要参数。"
    return:
      type: System.Object
      description: "正在调用的委托的返回值或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果委托没有返回值。"
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>priority</code>等同于<xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>。"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>不是有效的优先级。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "在线程上异步执行指定的参数与指定的优先级在指定的委托<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>与相关联。"
  remarks: "`Arg`可以是`null`如果不需要自变量。       在[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。</xref:System.Windows.Threading.DispatcherObject>  例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。</xref:System.Windows.Controls.Button>  为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  这是通过使用其中一种<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>实现  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  该操作将添加到事件队列。<xref:System.Windows.Threading.Dispatcher>在指定<xref:System.Windows.Threading.DispatcherPriority>。</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步操作;因此，控件将不返回到之前调用的对象后在回调返回。</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg, object[] args);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "优先级，相对于其他挂起的操作以<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>调用事件队列，指定方法。"
    - id: timeout
      type: System.TimeSpan
      description: "等待要完成的操作的最大时间。"
    - id: method
      type: System.Delegate
      description: "方法的委托采用多个自变量，这将被推送到<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件队列。"
    - id: arg
      type: System.Object
      description: "要将作为自变量传递给指定的方法的对象。"
    - id: args
      type: System.Object[]
      description: "要作为参数传递的指定方法的对象数组。"
    return:
      type: System.Object
      description: "正在调用的委托的返回值或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果委托没有返回值。"
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>priority</code>等同于<xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>。"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>不是有效<xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0})
  id: Invoke``1(System.Func{``0})
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Func<TResult>)
  nameWithType: Dispatcher.Invoke(Func<TResult>)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public TResult Invoke<TResult> (Func<TResult> callback);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "要添加。"
    return:
      type: TResult
      description: "要添加。"
  overload: System.Windows.Threading.Dispatcher.Invoke<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  id: Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Func<TResult>,DispatcherPriority)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public TResult Invoke<TResult> (Func<TResult> callback, System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "要添加。"
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "要添加。"
    return:
      type: TResult
      description: "要添加。"
  overload: System.Windows.Threading.Dispatcher.Invoke<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  id: Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public TResult Invoke<TResult> (Func<TResult> callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "要添加。"
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "要添加。"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "要添加。"
    return:
      type: TResult
      description: "要添加。"
  overload: System.Windows.Threading.Dispatcher.Invoke<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  id: Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public TResult Invoke<TResult> (Func<TResult> callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "要添加。"
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "要添加。"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "要添加。"
    - id: timeout
      type: System.TimeSpan
      description: "要添加。"
    return:
      type: TResult
      description: "要添加。"
  overload: System.Windows.Threading.Dispatcher.Invoke<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)
  id: InvokeAsync(System.Action)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Action)
  nameWithType: Dispatcher.InvokeAsync(Action)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "执行指定<xref:System.Action>线程上异步<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>与相关联。</xref:System.Action>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback);
    parameters:
    - id: callback
      type: System.Action
      description: "要通过调度程序调用的委托。"
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "一个对象，调用 InvokeAsync 后立即返回，可用来与该委托，因为它是挂起的执行在事件队列。"
  overload: System.Windows.Threading.Dispatcher.InvokeAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)
  id: InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Action,DispatcherPriority)
  nameWithType: Dispatcher.InvokeAsync(Action,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action,DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "执行指定<xref:System.Action>以异步方式在线程上指定的优先级<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>与相关联。</xref:System.Action>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: callback
      type: System.Action
      description: "要通过调度程序调用的委托。"
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "确定以何种顺序指定的回调调用相对于其他挂起的操作中的优先级<xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>。"
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "一个对象，调用 InvokeAsync 后立即返回，可用来与该委托，因为它是挂起的执行在事件队列。"
  overload: System.Windows.Threading.Dispatcher.InvokeAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  id: InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Action,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.InvokeAsync(Action,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action,DispatcherPriority,CancellationToken)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "执行指定<xref:System.Action>以异步方式在线程上指定的优先级<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>与相关联。</xref:System.Action>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: callback
      type: System.Action
      description: "要通过调度程序调用的委托。"
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "确定以何种顺序指定的回调调用相对于其他挂起的操作中的优先级<xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>。"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "一个对象，该值指示是否要取消的操作。"
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "一个对象，调用 InvokeAsync 后立即返回，可用来与该委托，因为它是挂起的执行在事件队列。"
  overload: System.Windows.Threading.Dispatcher.InvokeAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})
  id: InvokeAsync``1(System.Func{``0})
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Func<TResult>)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public System.Windows.Threading.DispatcherOperation<TResult> InvokeAsync<TResult> (Func<TResult> callback);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "要添加。"
    return:
      type: System.Windows.Threading.DispatcherOperation`1
      description: "要添加。"
  overload: System.Windows.Threading.Dispatcher.InvokeAsync<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  id: InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Func<TResult>,DispatcherPriority)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public System.Windows.Threading.DispatcherOperation<TResult> InvokeAsync<TResult> (Func<TResult> callback, System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "要添加。"
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "要添加。"
    return:
      type: System.Windows.Threading.DispatcherOperation`1
      description: "要添加。"
  overload: System.Windows.Threading.Dispatcher.InvokeAsync<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  id: InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public System.Windows.Threading.DispatcherOperation<TResult> InvokeAsync<TResult> (Func<TResult> callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "要添加。"
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "要添加。"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "要添加。"
    return:
      type: System.Windows.Threading.DispatcherOperation`1
      description: "要添加。"
  overload: System.Windows.Threading.Dispatcher.InvokeAsync<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeShutdown
  id: InvokeShutdown
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeShutdown()
  nameWithType: Dispatcher.InvokeShutdown()
  fullName: System.Windows.Threading.Dispatcher.InvokeShutdown()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "启动的关闭过程<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>同步。"
  remarks: "InvokeShutdown 要求不受限制的 UI 权限。       当<xref:System.Windows.Threading.Dispatcher>开始关闭的情况下，<xref:System.Windows.Threading.Dispatcher.ShutdownStarted>引发事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>设置为`true`。</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownStarted> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher>不会关闭完全展开事件队列之前。</xref:System.Windows.Threading.Dispatcher>       调度程序完成的情况下，关闭时<xref:System.Windows.Threading.Dispatcher.ShutdownFinished>引发事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>属性设置为`true`。</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownFinished>       关闭流程开始之后，所有挂起的工作将中止队列中的项。"
  syntax:
    content: public void InvokeShutdown ();
    parameters: []
  overload: System.Windows.Threading.Dispatcher.InvokeShutdown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)
  id: PushFrame(System.Windows.Threading.DispatcherFrame)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: PushFrame(DispatcherFrame)
  nameWithType: Dispatcher.PushFrame(DispatcherFrame)
  fullName: System.Windows.Threading.Dispatcher.PushFrame(DispatcherFrame)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "进入执行循环。"
  remarks: "A<xref:System.Windows.Threading.DispatcherFrame>表示处理挂起的工作项的循环。</xref:System.Windows.Threading.DispatcherFrame>       调度程序处理在循环中的工作项队列。  循环称为框架。  初始循环通常通过调用<xref:System.Windows.Threading.Dispatcher.Run%2A>.</xref:System.Windows.Threading.Dispatcher.Run%2A>来启动应用程序       PushFrame 进入该参数表示循环`frame`。  每次迭代循环，<xref:System.Windows.Threading.Dispatcher>将检查<xref:System.Windows.Threading.DispatcherFrame.Continue%2A>属性<xref:System.Windows.Threading.DispatcherFrame>类以确定是否应继续循环或如果它应停止。</xref:System.Windows.Threading.DispatcherFrame> </xref:System.Windows.Threading.DispatcherFrame.Continue%2A> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.DispatcherFrame>允许的<xref:System.Windows.Threading.DispatcherFrame.Continue%2A>属性来显式设置，并且它遵循<xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A><xref:System.Windows.Threading.Dispatcher>.</xref:System.Windows.Threading.Dispatcher>属性</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A></xref:System.Windows.Threading.DispatcherFrame.Continue%2A></xref:System.Windows.Threading.DispatcherFrame>  这意味着当<xref:System.Windows.Threading.Dispatcher>开始关闭的情况下，使用默认的帧<xref:System.Windows.Threading.DispatcherFrame>实现将退出，从而使所有嵌套的帧退出。</xref:System.Windows.Threading.DispatcherFrame> </xref:System.Windows.Threading.Dispatcher>"
  example:
  - "The following example shows how to use a <xref:System.Windows.Threading.DispatcherFrame> to achieve similar results as the [!INCLUDE[TLA#tla_winforms](~/add/includes/ajax-current-ext-md.md)] <xref:System.Windows.Forms.Application.DoEvents%2A> method.  \n  \n [!code-vb[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/add/codesnippet/visualbasic/dispatchersnippets/window1.xaml.vb#dispatcherdispatcherframedoevents)]\n [!code-cs[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/add/codesnippet/csharp/DispatcherSnippets/Window1.xaml.cs#dispatcherdispatcherframedoevents)]"
  syntax:
    content: public static void PushFrame (System.Windows.Threading.DispatcherFrame frame);
    parameters:
    - id: frame
      type: System.Windows.Threading.DispatcherFrame
      description: "为处理调度程序帧。"
  overload: System.Windows.Threading.Dispatcher.PushFrame*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>frame</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref:System.Windows.Threading.Dispatcher.HasShutdownFinished*>is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>       -or-       <code>frame</code> is running on a different <xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>.</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished*>       -或者-调度程序处理已被禁用。"
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Run
  id: Run
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Run()
  nameWithType: Dispatcher.Run()
  fullName: System.Windows.Threading.Dispatcher.Run()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "将主执行帧推送的事件队列<xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>。"
  remarks: "<xref:System.Windows.Threading.Dispatcher>处理在循环中的事件队列。</xref:System.Windows.Threading.Dispatcher>  循环称为框架。  初始循环通常通过调用运行启动应用程序。       主执行帧将继续进行，直到<xref:System.Windows.Threading.Dispatcher>关闭。</xref:System.Windows.Threading.Dispatcher>"
  syntax:
    content: public static void Run ();
    parameters: []
  overload: System.Windows.Threading.Dispatcher.Run*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.ShutdownFinished
  id: ShutdownFinished
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: ShutdownFinished
  nameWithType: Dispatcher.ShutdownFinished
  fullName: System.Windows.Threading.Dispatcher.ShutdownFinished
  type: Event
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "发生时<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>完成的情况下关闭。"
  remarks: "当关闭进程的<xref:System.Windows.Threading.Dispatcher>启动时，<xref:System.Windows.Threading.Dispatcher.ShutdownStarted>引发事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>设置为`true`。</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownStarted> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher>事件队列展开之前完全没有关闭。</xref:System.Windows.Threading.Dispatcher>       当调度程序完成后关闭时，将引发 ShutdownFinished 事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>属性设置为`true`。</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>       关闭流程开始之后，所有挂起的工作将中止队列中的项。"
  syntax:
    content: public event EventHandler ShutdownFinished;
    return:
      type: System.EventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.ShutdownStarted
  id: ShutdownStarted
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: ShutdownStarted
  nameWithType: Dispatcher.ShutdownStarted
  fullName: System.Windows.Threading.Dispatcher.ShutdownStarted
  type: Event
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "发生时<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>开始关闭。"
  remarks: "当关闭进程的<xref:System.Windows.Threading.Dispatcher>是开始，将引发 ShutdownStarted 事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>设置为`true`。</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher>事件队列展开之前完全没有关闭。</xref:System.Windows.Threading.Dispatcher>       调度程序完成的情况下，关闭时<xref:System.Windows.Threading.Dispatcher.ShutdownFinished>引发事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>属性设置为`true`。</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownFinished>       关闭流程开始之后，所有挂起的工作将中止队列中的项。"
  syntax:
    content: public event EventHandler ShutdownStarted;
    return:
      type: System.EventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Thread
  id: Thread
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Thread
  nameWithType: Dispatcher.Thread
  fullName: System.Windows.Threading.Dispatcher.Thread
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "获取线程此<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>与相关联。"
  syntax:
    content: public System.Threading.Thread Thread { get; }
    return:
      type: System.Threading.Thread
      description: "中的线程。"
  overload: System.Windows.Threading.Dispatcher.Thread*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.UnhandledException
  id: UnhandledException
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: UnhandledException
  nameWithType: Dispatcher.UnhandledException
  fullName: System.Windows.Threading.Dispatcher.UnhandledException
  type: Event
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "当引发并通过委托执行期间未捕获线程异常时发生<> *1> 或<> *1>。"
  remarks: "通过委托执行期间引发的异常时，将引发此事件<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>未捕获。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>       处理程序可以将该异常标记为已处理，这会阻止内部的异常处理程序调用。       必须小心来避免创建辅助异常并发现出现任何的写入此事件的事件处理程序。 建议避免分配内存或执行处理程序中的密集型操作的任何资源。       <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter>事件提供了一种不会引发 UnhandledException 事件的方法。</xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter>  <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter>事件引发第一次，并且如果<xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A>上<xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs>设置为`false`，不会引发 UnhandledException 事件。</xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs> </xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A> </xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter>"
  syntax:
    content: public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler UnhandledException;
    return:
      type: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.UnhandledExceptionFilter
  id: UnhandledExceptionFilter
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: UnhandledExceptionFilter
  nameWithType: Dispatcher.UnhandledExceptionFilter
  fullName: System.Windows.Threading.Dispatcher.UnhandledExceptionFilter
  type: Event
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "当引发并通过委托执行期间未捕获线程异常时发生<> *1> 或<> *1> 在筛选器阶段时。"
  remarks: "将通过委托执行期间引发的异常的筛选器阶段引发此事件<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>且未能捕获。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>       调用堆栈不展开这一时刻 （首次异常）。       必须小心来避免创建辅助异常并发现出现任何的写入此事件的事件处理程序。  建议避免分配内存或执行处理程序中的密集型操作的任何资源。       UnhandledExceptionFilter 事件提供了一种方法不会引发<xref:System.Windows.Threading.Dispatcher.UnhandledException>事件。</xref:System.Windows.Threading.Dispatcher.UnhandledException>  UnhandledExceptionFilter 事件引发第一次，并且如果<xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A>上<xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs>设置为`false`、<xref:System.Windows.Threading.Dispatcher.UnhandledException>不会引发事件。</xref:System.Windows.Threading.Dispatcher.UnhandledException> </xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs> </xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A>"
  syntax:
    content: public event System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler UnhandledExceptionFilter;
    return:
      type: System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)
  id: ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: ValidatePriority(DispatcherPriority,String)
  nameWithType: Dispatcher.ValidatePriority(DispatcherPriority,String)
  fullName: System.Windows.Threading.Dispatcher.ValidatePriority(DispatcherPriority,String)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "确定是否指定<xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;></xref>是有效的优先级。"
  syntax:
    content: public static void ValidatePriority (System.Windows.Threading.DispatcherPriority priority, string parameterName);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "要检查的优先级。"
    - id: parameterName
      type: System.String
      description: "一个字符串，将返回发生如果的优先级为无效的异常。"
  overload: System.Windows.Threading.Dispatcher.ValidatePriority*
  exceptions:
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>不是有效<xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>。"
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.VerifyAccess
  id: VerifyAccess
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: VerifyAccess()
  nameWithType: Dispatcher.VerifyAccess()
  fullName: System.Windows.Threading.Dispatcher.VerifyAccess()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "确定调用线程是否有权访问此<xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>。"
  remarks: "只有线程<xref:System.Windows.Threading.Dispatcher>创建在可以访问<xref:System.Windows.Threading.Dispatcher>.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher>       此方法是公共的;因此，可以检查任何线程以查看它是否有权访问<xref:System.Windows.Threading.Dispatcher>.</xref:System.Windows.Threading.Dispatcher>       之间的差异<xref:System.Windows.Threading.Dispatcher.CheckAccess%2A>和 VerifyAccess 是<xref:System.Windows.Threading.Dispatcher.CheckAccess%2A>返回一个布尔值，如果调用线程不具有访问<xref:System.Windows.Threading.Dispatcher>并 VerifyAccess 引发异常。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> </xref:System.Windows.Threading.Dispatcher.CheckAccess%2A>"
  example:
  - "The following example uses VerifyAccess to determine whether a thread has access to the thread that a <xref:System.Windows.Controls.Button> was created on.  The method takes an object as an argument, which is cast to a <xref:System.Windows.Controls.Button>.  The VerifyAccess method on the <xref:System.Windows.Threading.Dispatcher> of the <xref:System.Windows.Controls.Button> is called to verify access to the thread.  \n  \n If the calling thread has access to the <xref:System.Windows.Threading.Dispatcher>, the <xref:System.Windows.Controls.Button> is updated by just accessing the members of the <xref:System.Windows.Controls.Button>.  \n  \n If the calling thread does not have access, an <xref:System.InvalidOperationException> is thrown.  This example catches the exception and pushes a delegate, which accepts a <xref:System.Windows.Controls.Button> as an argument, onto the <xref:System.Windows.Threading.Dispatcher> of the <xref:System.Windows.Controls.Button>.  This <xref:System.Windows.Threading.Dispatcher> will do the work of updating the <xref:System.Windows.Controls.Button>.  \n  \n [!code-cs[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/add/codesnippet/csharp/DispatcherAccessSample/Window1.xaml.cs#dispatcheraccessverifyaccess)]\n [!code-vb[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/add/codesnippet/visualbasic/dispatcheraccesssample/window1.xaml.vb#dispatcheraccessverifyaccess)]"
  syntax:
    content: public void VerifyAccess ();
    parameters: []
  overload: System.Windows.Threading.Dispatcher.VerifyAccess*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "调用线程没有访问此<xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>。"
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Yield
  id: Yield
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Yield()
  nameWithType: Dispatcher.Yield()
  fullName: System.Windows.Threading.Dispatcher.Yield()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "创建以异步方式会将控制权出让回当前的调度程序，并提供要处理的其他事件的调度程序有机会的等待对象。"
  remarks: "此方法使你能够暂时释放到当前的调度程序的执行控件，以便它可以执行其他工作，就像处理其他事件的方法。 使用`await`，或`Await`在 Visual Basic 中，运算符的返回值来将控制返回到当前的调度程序。 使用此方法，如果想要让你的应用程序有机会处理事件，而你应用程序执行大量的 UI 线程上的工作。 例如，你可以在更新控件的运行时间较长循环中使用此方法。       此方法等效于调用的<xref:System.Windows.Threading.Dispatcher.Yield%28System.Windows.Threading.DispatcherPriority%29>方法并传入<xref:System.Windows.Threading.DispatcherPriority?displayProperty=fullName>.</xref:System.Windows.Threading.DispatcherPriority?displayProperty=fullName> </xref:System.Windows.Threading.Dispatcher.Yield%28System.Windows.Threading.DispatcherPriority%29>"
  syntax:
    content: public static System.Windows.Threading.DispatcherPriorityAwaitable Yield ();
    parameters: []
    return:
      type: System.Windows.Threading.DispatcherPriorityAwaitable
      description: "以异步方式会将控制权出让回当前的调度程序，并提供要处理的其他事件的调度程序有机会的等待对象。"
  overload: System.Windows.Threading.Dispatcher.Yield*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Yield(System.Windows.Threading.DispatcherPriority)
  id: Yield(System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Yield(DispatcherPriority)
  nameWithType: Dispatcher.Yield(DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Yield(DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "创建以异步方式会将控制权出让回当前的调度程序，并提供要处理的其他事件的调度程序有机会的等待对象。  用指定的优先级计划时发生控制返回到等待此方法的结果代码的工作。"
  remarks: "此方法使你能够暂时释放到当前的调度程序的执行控件，以便它可以执行其他工作，就像处理其他事件的方法。 使用`await`，或`Await`在 Visual Basic 中，运算符的返回值来将控制返回到当前的调度程序。 使用此方法，如果想要让你的应用程序有机会处理事件，而你应用程序执行大量的 UI 线程上的工作。 例如，你可以在更新控件的运行时间较长循环中使用此方法。"
  syntax:
    content: public static System.Windows.Threading.DispatcherPriorityAwaitable Yield (System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "计划延续优先级。"
    return:
      type: System.Windows.Threading.DispatcherPriorityAwaitable
      description: "以异步方式会将控制权出让回当前的调度程序，并提供要处理的其他事件的调度程序有机会的等待对象。"
  overload: System.Windows.Threading.Dispatcher.Yield*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke(Delegate,Object[])
  nameWithType: Dispatcher.BeginInvoke(Delegate,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(Delegate,Object[])
- uid: System.Windows.Threading.DispatcherOperation
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherOperation
  nameWithType: DispatcherOperation
  fullName: System.Windows.Threading.DispatcherOperation
- uid: System.Delegate
  parent: System
  isExternal: true
  name: Delegate
  nameWithType: Delegate
  fullName: System.Delegate
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke(DispatcherPriority,Delegate)
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate)
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate)
- uid: System.Windows.Threading.DispatcherPriority
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherPriority
  nameWithType: DispatcherPriority
  fullName: System.Windows.Threading.DispatcherPriority
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke(Delegate,DispatcherPriority,Object[])
  nameWithType: Dispatcher.BeginInvoke(Delegate,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(Delegate,DispatcherPriority,Object[])
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke(DispatcherPriority,Delegate,Object)
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object)
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
- uid: System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvokeShutdown(DispatcherPriority)
  nameWithType: Dispatcher.BeginInvokeShutdown(DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.BeginInvokeShutdown(DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.CheckAccess
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: CheckAccess()
  nameWithType: Dispatcher.CheckAccess()
  fullName: System.Windows.Threading.Dispatcher.CheckAccess()
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Threading.Dispatcher.CurrentDispatcher
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: CurrentDispatcher
  nameWithType: Dispatcher.CurrentDispatcher
  fullName: System.Windows.Threading.Dispatcher.CurrentDispatcher
- uid: System.Windows.Threading.Dispatcher
  parent: System.Windows.Threading
  isExternal: false
  name: Dispatcher
  nameWithType: Dispatcher
  fullName: System.Windows.Threading.Dispatcher
- uid: System.Windows.Threading.Dispatcher.DisableProcessing
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: DisableProcessing()
  nameWithType: Dispatcher.DisableProcessing()
  fullName: System.Windows.Threading.Dispatcher.DisableProcessing()
- uid: System.Windows.Threading.DispatcherProcessingDisabled
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherProcessingDisabled
  nameWithType: DispatcherProcessingDisabled
  fullName: System.Windows.Threading.DispatcherProcessingDisabled
- uid: System.Windows.Threading.Dispatcher.ExitAllFrames
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ExitAllFrames()
  nameWithType: Dispatcher.ExitAllFrames()
  fullName: System.Windows.Threading.Dispatcher.ExitAllFrames()
- uid: System.Windows.Threading.Dispatcher.FromThread(System.Threading.Thread)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: FromThread(Thread)
  nameWithType: Dispatcher.FromThread(Thread)
  fullName: System.Windows.Threading.Dispatcher.FromThread(Thread)
- uid: System.Threading.Thread
  parent: System.Threading
  isExternal: false
  name: Thread
  nameWithType: Thread
  fullName: System.Threading.Thread
- uid: System.Windows.Threading.Dispatcher.HasShutdownFinished
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: HasShutdownFinished
  nameWithType: Dispatcher.HasShutdownFinished
  fullName: System.Windows.Threading.Dispatcher.HasShutdownFinished
- uid: System.Windows.Threading.Dispatcher.HasShutdownStarted
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: HasShutdownStarted
  nameWithType: Dispatcher.HasShutdownStarted
  fullName: System.Windows.Threading.Dispatcher.HasShutdownStarted
- uid: System.Windows.Threading.Dispatcher.Hooks
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Hooks
  nameWithType: Dispatcher.Hooks
  fullName: System.Windows.Threading.Dispatcher.Hooks
- uid: System.Windows.Threading.DispatcherHooks
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherHooks
  nameWithType: DispatcherHooks
  fullName: System.Windows.Threading.DispatcherHooks
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Action)
  nameWithType: Dispatcher.Invoke(Action)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action)
- uid: System.Action
  parent: System
  isExternal: true
  name: Action
  nameWithType: Action
  fullName: System.Action
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Action,DispatcherPriority)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Delegate,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,Object[])
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,Delegate)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Action,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken)
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Delegate,TimeSpan,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,TimeSpan,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,TimeSpan,Object[])
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Delegate,DispatcherPriority,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,DispatcherPriority,Object[])
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,Delegate,Object)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate,Object)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,TimeSpan,Delegate)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,Delegate,Object,Object[])
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate,Object,Object[])
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0})
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Func<TResult>)
  nameWithType: Dispatcher.Invoke(Func<TResult>)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>)
- uid: TResult
  isExternal: true
  name: TResult
  nameWithType: TResult
  fullName: TResult
- uid: System.Func{TResult}
  parent: System
  isExternal: true
  name: Func<TResult>
  nameWithType: Func<TResult>
  fullName: System.Func<TResult>
  spec.csharp:
  - uid: System.Func`1
    name: Func
    nameWithType: Func
    fullName: Func<TResult>
  - name: <
    nameWithType: <
    fullName: <
  - uid: TResult
    name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Func<TResult>,DispatcherPriority)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Action)
  nameWithType: Dispatcher.InvokeAsync(Action)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action)
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Action,DispatcherPriority)
  nameWithType: Dispatcher.InvokeAsync(Action,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action,DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Action,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.InvokeAsync(Action,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action,DispatcherPriority,CancellationToken)
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Func<TResult>)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>)
- uid: System.Windows.Threading.DispatcherOperation`1
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherOperation<TResult>
  nameWithType: DispatcherOperation<TResult>
  fullName: System.Windows.Threading.DispatcherOperation<TResult>
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Func<TResult>,DispatcherPriority)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
- uid: System.Windows.Threading.Dispatcher.InvokeShutdown
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeShutdown()
  nameWithType: Dispatcher.InvokeShutdown()
  fullName: System.Windows.Threading.Dispatcher.InvokeShutdown()
- uid: System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: PushFrame(DispatcherFrame)
  nameWithType: Dispatcher.PushFrame(DispatcherFrame)
  fullName: System.Windows.Threading.Dispatcher.PushFrame(DispatcherFrame)
- uid: System.Windows.Threading.DispatcherFrame
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherFrame
  nameWithType: DispatcherFrame
  fullName: System.Windows.Threading.DispatcherFrame
- uid: System.Windows.Threading.Dispatcher.Run
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Run()
  nameWithType: Dispatcher.Run()
  fullName: System.Windows.Threading.Dispatcher.Run()
- uid: System.Windows.Threading.Dispatcher.ShutdownFinished
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ShutdownFinished
  nameWithType: Dispatcher.ShutdownFinished
  fullName: System.Windows.Threading.Dispatcher.ShutdownFinished
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Windows.Threading.Dispatcher.ShutdownStarted
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ShutdownStarted
  nameWithType: Dispatcher.ShutdownStarted
  fullName: System.Windows.Threading.Dispatcher.ShutdownStarted
- uid: System.Windows.Threading.Dispatcher.Thread
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Thread
  nameWithType: Dispatcher.Thread
  fullName: System.Windows.Threading.Dispatcher.Thread
- uid: System.Windows.Threading.Dispatcher.UnhandledException
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: UnhandledException
  nameWithType: Dispatcher.UnhandledException
  fullName: System.Windows.Threading.Dispatcher.UnhandledException
- uid: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherUnhandledExceptionEventHandler
  nameWithType: DispatcherUnhandledExceptionEventHandler
  fullName: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
- uid: System.Windows.Threading.Dispatcher.UnhandledExceptionFilter
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: UnhandledExceptionFilter
  nameWithType: Dispatcher.UnhandledExceptionFilter
  fullName: System.Windows.Threading.Dispatcher.UnhandledExceptionFilter
- uid: System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherUnhandledExceptionFilterEventHandler
  nameWithType: DispatcherUnhandledExceptionFilterEventHandler
  fullName: System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler
- uid: System.Windows.Threading.Dispatcher.ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ValidatePriority(DispatcherPriority,String)
  nameWithType: Dispatcher.ValidatePriority(DispatcherPriority,String)
  fullName: System.Windows.Threading.Dispatcher.ValidatePriority(DispatcherPriority,String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.Threading.Dispatcher.VerifyAccess
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: VerifyAccess()
  nameWithType: Dispatcher.VerifyAccess()
  fullName: System.Windows.Threading.Dispatcher.VerifyAccess()
- uid: System.Windows.Threading.Dispatcher.Yield
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Yield()
  nameWithType: Dispatcher.Yield()
  fullName: System.Windows.Threading.Dispatcher.Yield()
- uid: System.Windows.Threading.DispatcherPriorityAwaitable
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherPriorityAwaitable
  nameWithType: DispatcherPriorityAwaitable
  fullName: System.Windows.Threading.DispatcherPriorityAwaitable
- uid: System.Windows.Threading.Dispatcher.Yield(System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Yield(DispatcherPriority)
  nameWithType: Dispatcher.Yield(DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Yield(DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.BeginInvoke*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke
  nameWithType: Dispatcher.BeginInvoke
- uid: System.Windows.Threading.Dispatcher.BeginInvokeShutdown*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvokeShutdown
  nameWithType: Dispatcher.BeginInvokeShutdown
- uid: System.Windows.Threading.Dispatcher.CheckAccess*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: CheckAccess
  nameWithType: Dispatcher.CheckAccess
- uid: System.Windows.Threading.Dispatcher.CurrentDispatcher*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: CurrentDispatcher
  nameWithType: Dispatcher.CurrentDispatcher
- uid: System.Windows.Threading.Dispatcher.DisableProcessing*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: DisableProcessing
  nameWithType: Dispatcher.DisableProcessing
- uid: System.Windows.Threading.Dispatcher.ExitAllFrames*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ExitAllFrames
  nameWithType: Dispatcher.ExitAllFrames
- uid: System.Windows.Threading.Dispatcher.FromThread*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: FromThread
  nameWithType: Dispatcher.FromThread
- uid: System.Windows.Threading.Dispatcher.HasShutdownFinished*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: HasShutdownFinished
  nameWithType: Dispatcher.HasShutdownFinished
- uid: System.Windows.Threading.Dispatcher.HasShutdownStarted*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: HasShutdownStarted
  nameWithType: Dispatcher.HasShutdownStarted
- uid: System.Windows.Threading.Dispatcher.Hooks*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Hooks
  nameWithType: Dispatcher.Hooks
- uid: System.Windows.Threading.Dispatcher.Invoke*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke
  nameWithType: Dispatcher.Invoke
- uid: System.Windows.Threading.Dispatcher.Invoke<TResult>*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke<TResult>
  nameWithType: Dispatcher.Invoke<TResult>
- uid: System.Windows.Threading.Dispatcher.InvokeAsync*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync
  nameWithType: Dispatcher.InvokeAsync
- uid: System.Windows.Threading.Dispatcher.InvokeAsync<TResult>*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync<TResult>
  nameWithType: Dispatcher.InvokeAsync<TResult>
- uid: System.Windows.Threading.Dispatcher.InvokeShutdown*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeShutdown
  nameWithType: Dispatcher.InvokeShutdown
- uid: System.Windows.Threading.Dispatcher.PushFrame*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: PushFrame
  nameWithType: Dispatcher.PushFrame
- uid: System.Windows.Threading.Dispatcher.Run*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Run
  nameWithType: Dispatcher.Run
- uid: System.Windows.Threading.Dispatcher.Thread*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Thread
  nameWithType: Dispatcher.Thread
- uid: System.Windows.Threading.Dispatcher.ValidatePriority*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ValidatePriority
  nameWithType: Dispatcher.ValidatePriority
- uid: System.Windows.Threading.Dispatcher.VerifyAccess*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: VerifyAccess
  nameWithType: Dispatcher.VerifyAccess
- uid: System.Windows.Threading.Dispatcher.Yield*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Yield
  nameWithType: Dispatcher.Yield
