### YamlMime:ManagedReference
items:
- uid: System.Windows.DataTemplate
  id: DataTemplate
  children:
  - System.Windows.DataTemplate.#ctor
  - System.Windows.DataTemplate.#ctor(System.Object)
  - System.Windows.DataTemplate.DataTemplateKey
  - System.Windows.DataTemplate.DataType
  - System.Windows.DataTemplate.Triggers
  - System.Windows.DataTemplate.ValidateTemplatedParent(System.Windows.FrameworkElement)
  langs:
  - csharp
  name: DataTemplate
  nameWithType: DataTemplate
  fullName: System.Windows.DataTemplate
  type: Class
  summary: "介绍数据对象的可视结构。"
  remarks: "DataTemplate 用于指定将数据对象的可视化效果。 你正在绑定时，数据模板对象都特别有用<xref:System.Windows.Controls.ItemsControl>如<xref:System.Windows.Controls.ListBox>整个集合。</xref:System.Windows.Controls.ListBox> </xref:System.Windows.Controls.ItemsControl> 如果没有特殊说明<xref:System.Windows.Controls.ListBox>显示集合中的字符串表示形式的对象。</xref:System.Windows.Controls.ListBox> 在这种情况下，可以使用数据模板来定义数据对象的外观。 你的数据模板的内容将成为数据对象的可视结构。       有关深入讨论，请参阅[数据模板化概述](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example shows how to create a DataTemplate inline. The DataTemplate specifies that each data item appears as three <xref:System.Windows.Controls.TextBlock> elements within a <xref:System.Windows.Controls.StackPanel>. In this example, the data object is a class called `Task`. Note that each <xref:System.Windows.Controls.TextBlock> element in this template is bound to a property of the `Task` class.  \n  \n [!code-xml[DataTemplatingIntro_snip#Inline](~/add/codesnippet/xaml/DataTemplatingSample/Window1.xaml#inline)]  \n  \n It is more common to define a DataTemplate in the resources section so it can be a reusable object, as in the following example:  \n  \n [!code-xml[DataTemplatingIntro_snip#R1](~/add/codesnippet/xaml/DataTemplatingSample/Window1.xaml#r1)]  \n[!code-xml[DataTemplatingIntro_snip#AsResource](~/add/codesnippet/xaml/DataTemplatingSample/Window1.xaml#asresource)]  \n[!code-xml[DataTemplatingIntro_snip#R2](~/add/codesnippet/xaml/DataTemplatingSample/Window1.xaml#r2)]  \n  \n Now you can use `myTaskTemplate` as a resource, as in the following example:  \n  \n [!code-xml[DataTemplatingIntro_snip#MyTaskTemplate](~/add/codesnippet/xaml/DataTemplatingSample/Window1.xaml#mytasktemplate)]  \n  \n For the complete sample, see [Introduction to Data Templating Sample](http://go.microsoft.com/fwlink/?LinkID=160009)."
  syntax:
    content: >-
      [System.Windows.Markup.DictionaryKeyProperty("DataTemplateKey")]

      public class DataTemplate : System.Windows.FrameworkTemplate
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  - System.Windows.FrameworkTemplate
  implements: []
  inheritedMembers:
  - System.Windows.FrameworkTemplate.FindName(System.String,System.Windows.FrameworkElement)
  - System.Windows.FrameworkTemplate.HasContent
  - System.Windows.FrameworkTemplate.IsSealed
  - System.Windows.FrameworkTemplate.LoadContent
  - System.Windows.FrameworkTemplate.RegisterName(System.String,System.Object)
  - System.Windows.FrameworkTemplate.Resources
  - System.Windows.FrameworkTemplate.Seal
  - System.Windows.FrameworkTemplate.ShouldSerializeResources(System.Windows.Markup.XamlDesignerSerializationManager)
  - System.Windows.FrameworkTemplate.ShouldSerializeVisualTree
  - System.Windows.FrameworkTemplate.System#Windows#Markup#INameScope#FindName(System.String)
  - System.Windows.FrameworkTemplate.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  - System.Windows.FrameworkTemplate.Template
  - System.Windows.FrameworkTemplate.UnregisterName(System.String)
  - System.Windows.FrameworkTemplate.VisualTree
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  platform:
  - net462
- uid: System.Windows.DataTemplate.#ctor
  id: '#ctor'
  parent: System.Windows.DataTemplate
  langs:
  - csharp
  name: DataTemplate()
  nameWithType: DataTemplate.DataTemplate()
  fullName: System.Windows.DataTemplate.DataTemplate()
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "初始化的新实例<xref href=&quot;System.Windows.DataTemplate&quot;></xref>类。"
  syntax:
    content: public DataTemplate ();
    parameters: []
  overload: System.Windows.DataTemplate.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DataTemplate.#ctor(System.Object)
  id: '#ctor(System.Object)'
  parent: System.Windows.DataTemplate
  langs:
  - csharp
  name: DataTemplate(Object)
  nameWithType: DataTemplate.DataTemplate(Object)
  fullName: System.Windows.DataTemplate.DataTemplate(Object)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "初始化的新实例<xref href=&quot;System.Windows.DataTemplate&quot;></xref>使用指定的类<xref:System.Windows.DataTemplate.DataType*>属性。</xref:System.Windows.DataTemplate.DataType*>"
  remarks: "若要引用类的类型名称，使用[X:type 标记扩展](~/add/includes/ajax-current-ext-md.md)。 如果模板旨在用于[!INCLUDE[TLA#tla_xml](~/add/includes/tlasharptla-xml-md.md)]数据，这是表示数据的标记名称的字符串。"
  syntax:
    content: public DataTemplate (object dataType);
    parameters:
    - id: dataType
      type: System.Object
      description: "如果模板旨在用于对象数据，这是数据对象的类型名称。"
  overload: System.Windows.DataTemplate.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DataTemplate.DataTemplateKey
  id: DataTemplateKey
  parent: System.Windows.DataTemplate
  langs:
  - csharp
  name: DataTemplateKey
  nameWithType: DataTemplate.DataTemplateKey
  fullName: System.Windows.DataTemplate.DataTemplateKey
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "获取默认的密钥， <xref href=&quot;System.Windows.DataTemplate&quot;> </xref>。"
  remarks: "如果你未设置[X:key 指令](~/add/includes/ajax-current-ext-md.md)上<xref:System.Windows.DataTemplate>，位于<xref:System.Windows.ResourceDictionary>，DataTemplateKey 用作的键。</xref:System.Windows.ResourceDictionary> </xref:System.Windows.DataTemplate>"
  syntax:
    content: public object DataTemplateKey { get; }
    return:
      type: System.Object
      description: "默认键<xref href=&quot;System.Windows.DataTemplate&quot;> </xref>。"
  overload: System.Windows.DataTemplate.DataTemplateKey*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DataTemplate.DataType
  id: DataType
  parent: System.Windows.DataTemplate
  langs:
  - csharp
  name: DataType
  nameWithType: DataTemplate.DataType
  fullName: System.Windows.DataTemplate.DataType
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "获取或设置此类型<xref href=&quot;System.Windows.DataTemplate&quot;></xref>旨在。"
  remarks: "此属性是类的非常类似于<xref:System.Windows.Style.TargetType%2A>属性<xref:System.Windows.Style>类。</xref:System.Windows.Style> </xref:System.Windows.Style.TargetType%2A> 当你设置此属性为数据类型而无需指定`x:Key`、<xref:System.Windows.DataTemplate>获取自动应用到该类型的数据对象。</xref:System.Windows.DataTemplate> 请注意，当你执行此操作`x:Key`隐式设置。 因此，如果将此分配<xref:System.Windows.DataTemplate>`x:Key`值，您要重写的隐式`x:Key`和<xref:System.Windows.DataTemplate>不会自动应用。</xref:System.Windows.DataTemplate> </xref:System.Windows.DataTemplate>       另请注意，如果你正在绑定<xref:System.Windows.Controls.ContentControl>到的集合`Task`对象，<xref:System.Windows.Controls.ContentControl>不使用<xref:System.Windows.DataTemplate>自动。</xref:System.Windows.DataTemplate> </xref:System.Windows.Controls.ContentControl> </xref:System.Windows.Controls.ContentControl> 这是因为上的绑定<xref:System.Windows.Controls.ContentControl>需要区分你是否想要将绑定到整个集合或单个对象的详细信息。</xref:System.Windows.Controls.ContentControl> 如果你<xref:System.Windows.Controls.ContentControl>跟踪的选定内容<xref:System.Windows.Controls.ItemsControl>类型，你可以设置<xref:System.Windows.Data.Binding.Path%2A>属性<xref:System.Windows.Controls.ContentControl>绑定到&quot;`/`&quot;以指示你感兴趣的当前项。</xref:System.Windows.Controls.ContentControl> </xref:System.Windows.Data.Binding.Path%2A> </xref:System.Windows.Controls.ItemsControl> </xref:System.Windows.Controls.ContentControl> 有关示例，请参阅[如何︰ 将绑定到集合和显示基于所选内容的信息](~/add/includes/ajax-current-ext-md.md)。 否则，你需要指定<xref:System.Windows.DataTemplate>显式通过设置<xref:System.Windows.Controls.ContentControl.ContentTemplate%2A>属性。</xref:System.Windows.Controls.ContentControl.ContentTemplate%2A> </xref:System.Windows.DataTemplate>       DataType 属性必须时特别有用<xref:System.Windows.Data.CompositeCollection>的不同类型的数据对象。</xref:System.Windows.Data.CompositeCollection>       如果此属性提供程序针对不位于默认命名空间的 XML 元素，则必须在前面带有命名空间或命名空间指示符的元素名称。 For XML 通过公开 LINQ 对于 XML，命名空间显示在括号内，前面由大括号转义序列︰ ```xaml   <DataTemplate DataType=&quot;{}{http://myNamespace}Details&quot;>   ``` For XML 通过 XPath 公开、 元素名称的前面由的实例建立的命名空间指示符<xref:System.Windows.Data.XmlNamespaceMapping>: ```xaml   <DataTemplate DataType=&quot;mn:Details&quot;>   ``` <a name=&quot;xamlAttributeUsage_DataType&quot;> </a> # # XAML 属性用法```   <object DataType=&quot;typeName&quot;/>   ``` <a name=&quot;xamlValues_DataType&quot;> </a> # # XAML 值*typeName*模板供对象数据，如果此属性包含此数据对象 （作为字符串） 的类型名称。            </xref:System.Windows.Data.XmlNamespaceMapping> 若要引用类的类型名称，使用[X:type 标记扩展](~/add/includes/ajax-current-ext-md.md)。 如果模板旨在用于[!INCLUDE[TLA#tla_xml](~/add/includes/tlasharptla-xml-md.md)]数据，此属性包含的 XML 元素名称。 请参阅有关指定的 XML 元素的非默认命名空间文档备注以了解详情。"
  syntax:
    content: public object DataType { get; set; }
    return:
      type: System.Object
      description: "默认值是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.DataTemplate.DataType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DataTemplate.Triggers
  id: Triggers
  parent: System.Windows.DataTemplate
  langs:
  - csharp
  name: Triggers
  nameWithType: DataTemplate.Triggers
  fullName: System.Windows.DataTemplate.Triggers
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "获取应用属性值或根据一个或多个条件执行操作的触发器的集合。"
  remarks: "如果要创建数据模板中的触发器，则触发器的 setter 应设置数据模板的作用域内的属性。 否则，它可能更适合于创建触发器使用的包含的数据类型为目标的样式。 例如，如果你正在绑定<xref:System.Windows.Controls.ListBox>控件，则容器为<xref:System.Windows.Controls.ListBoxItem>对象。</xref:System.Windows.Controls.ListBoxItem> </xref:System.Windows.Controls.ListBox> 如果你使用触发器来设置不在范围内的属性<xref:System.Windows.DataTemplate>，则它可能更适合于创建<xref:System.Windows.Controls.ListBoxItem>样式，创建该样式中的触发器。</xref:System.Windows.Controls.ListBoxItem> </xref:System.Windows.DataTemplate> 有关详细信息，请参阅什么所属 DataTemplate 中？在[数据模板化概述](~/add/includes/ajax-current-ext-md.md)。      1> [!NOTE]&1;> 此属性仅在中设置[!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]通过集合语法所示，或通过访问的集合对象，并使用它的各种方法，例如 Add。 要访问集合对象本身的属性是只读的该集合本身是读写。      <a name=&quot;xamlPropertyElementUsage_Triggers&quot;></a># # XAML 属性元素用法```   <object>     <object.Triggers>       OneOrMoreTriggers     </object.Triggers>   </object>   ``` <a name=&quot;xamlValues_Triggers&quot;> </a> # # XAML 值*OneOrMoreTriggers*零个或多<xref:System.Windows.TriggerBase>对象。</xref:System.Windows.TriggerBase>      "
  example:
  - "The following <xref:System.Windows.DataTemplate> demonstrates the use of the Triggers property.  \n  \n [!code-xml[DataBindingLab#AuctionItemDataTemplate](~/add/codesnippet/xaml/DataBindingLab/DataBindingLabApp.xaml#auctionitemdatatemplate)]  \n  \n For the complete sample, see [Data Binding Demo](http://go.microsoft.com/fwlink/?LinkID=163703)."
  syntax:
    content: public System.Windows.TriggerCollection Triggers { get; }
    return:
      type: System.Windows.TriggerCollection
      description: "触发器对象的集合。 默认值是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.DataTemplate.Triggers*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DataTemplate.ValidateTemplatedParent(System.Windows.FrameworkElement)
  id: ValidateTemplatedParent(System.Windows.FrameworkElement)
  parent: System.Windows.DataTemplate
  langs:
  - csharp
  name: ValidateTemplatedParent(FrameworkElement)
  nameWithType: DataTemplate.ValidateTemplatedParent(FrameworkElement)
  fullName: System.Windows.DataTemplate.ValidateTemplatedParent(FrameworkElement)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "检查针对一组规则模板化父级。"
  remarks: "该方法使用以下规则:-`templatedParent`必须为非 null <xref:System.Windows.FrameworkElement>.</xref:System.Windows.FrameworkElement>      <xref:System.Windows.DataTemplate>必须将应用于一种<xref:System.Windows.Controls.ContentPresenter>。</xref:System.Windows.Controls.ContentPresenter> </xref:System.Windows.DataTemplate> -"
  syntax:
    content: protected override void ValidateTemplatedParent (System.Windows.FrameworkElement templatedParent);
    parameters:
    - id: templatedParent
      type: System.Windows.FrameworkElement
      description: "此模板应用到的元素。"
  overload: System.Windows.DataTemplate.ValidateTemplatedParent*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.FrameworkTemplate
  isExternal: false
  name: System.Windows.FrameworkTemplate
- uid: System.Windows.DataTemplate.#ctor
  parent: System.Windows.DataTemplate
  isExternal: false
  name: DataTemplate()
  nameWithType: DataTemplate.DataTemplate()
  fullName: System.Windows.DataTemplate.DataTemplate()
- uid: System.Windows.DataTemplate.#ctor(System.Object)
  parent: System.Windows.DataTemplate
  isExternal: false
  name: DataTemplate(Object)
  nameWithType: DataTemplate.DataTemplate(Object)
  fullName: System.Windows.DataTemplate.DataTemplate(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.DataTemplate.DataTemplateKey
  parent: System.Windows.DataTemplate
  isExternal: false
  name: DataTemplateKey
  nameWithType: DataTemplate.DataTemplateKey
  fullName: System.Windows.DataTemplate.DataTemplateKey
- uid: System.Windows.DataTemplate.DataType
  parent: System.Windows.DataTemplate
  isExternal: false
  name: DataType
  nameWithType: DataTemplate.DataType
  fullName: System.Windows.DataTemplate.DataType
- uid: System.Windows.DataTemplate.Triggers
  parent: System.Windows.DataTemplate
  isExternal: false
  name: Triggers
  nameWithType: DataTemplate.Triggers
  fullName: System.Windows.DataTemplate.Triggers
- uid: System.Windows.TriggerCollection
  parent: System.Windows
  isExternal: false
  name: TriggerCollection
  nameWithType: TriggerCollection
  fullName: System.Windows.TriggerCollection
- uid: System.Windows.DataTemplate.ValidateTemplatedParent(System.Windows.FrameworkElement)
  parent: System.Windows.DataTemplate
  isExternal: false
  name: ValidateTemplatedParent(FrameworkElement)
  nameWithType: DataTemplate.ValidateTemplatedParent(FrameworkElement)
  fullName: System.Windows.DataTemplate.ValidateTemplatedParent(FrameworkElement)
- uid: System.Windows.FrameworkElement
  parent: System.Windows
  isExternal: false
  name: FrameworkElement
  nameWithType: FrameworkElement
  fullName: System.Windows.FrameworkElement
- uid: System.Windows.DataTemplate.#ctor*
  parent: System.Windows.DataTemplate
  isExternal: false
  name: DataTemplate
  nameWithType: DataTemplate.DataTemplate
- uid: System.Windows.DataTemplate.DataTemplateKey*
  parent: System.Windows.DataTemplate
  isExternal: false
  name: DataTemplateKey
  nameWithType: DataTemplate.DataTemplateKey
- uid: System.Windows.DataTemplate.DataType*
  parent: System.Windows.DataTemplate
  isExternal: false
  name: DataType
  nameWithType: DataTemplate.DataType
- uid: System.Windows.DataTemplate.Triggers*
  parent: System.Windows.DataTemplate
  isExternal: false
  name: Triggers
  nameWithType: DataTemplate.Triggers
- uid: System.Windows.DataTemplate.ValidateTemplatedParent*
  parent: System.Windows.DataTemplate
  isExternal: false
  name: ValidateTemplatedParent
  nameWithType: DataTemplate.ValidateTemplatedParent
