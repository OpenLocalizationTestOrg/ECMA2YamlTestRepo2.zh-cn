### YamlMime:ManagedReference
items:
- uid: Microsoft.VisualBasic.FileSystem
  id: FileSystem
  children:
  - Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  - Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  - Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  - Microsoft.VisualBasic.FileSystem.CurDir
  - Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  - Microsoft.VisualBasic.FileSystem.Dir
  - Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  - Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  - Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  - Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  - Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  - Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  - Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  - Microsoft.VisualBasic.FileSystem.FreeFile
  - Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  - Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  - Microsoft.VisualBasic.FileSystem.Kill(System.String)
  - Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  - Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  - Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  - Microsoft.VisualBasic.FileSystem.Reset
  - Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  - Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  - Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  - Microsoft.VisualBasic.FileSystem.TAB
  - Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  langs:
  - csharp
  name: FileSystem
  nameWithType: FileSystem
  fullName: Microsoft.VisualBasic.FileSystem
  type: Class
  summary: "<xref uid=&quot;langword_csharp_FileSystem&quot; name=&quot;FileSystem&quot; href=&quot;&quot;> </xref>模块包含用于执行文件、 目录或文件夹和系统操作的过程。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比使用<xref uid=&quot;langword_csharp_FileSystem&quot; name=&quot;FileSystem&quot; href=&quot;&quot;></xref>模块。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "此模块支持的 Visual Basic 语言关键字和访问文件和文件夹的运行时库成员。"
  example:
  - "This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#25](~/add/codesnippet/visualbasic/t-microsoft.visualbasic._17_1.vb)]"
  syntax:
    content: >-
      [Microsoft.VisualBasic.CompilerServices.StandardModule]

      [System.Security.SecurityCritical]

      public sealed class FileSystem
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  id: ChDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDir(String)
  nameWithType: FileSystem.ChDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "更改当前目录或文件夹。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_ChDir &quot; name=&quot;ChDir &quot; href=&quot;&quot;></xref>函数。 有关详细信息，请参阅<xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>。</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>"
  remarks: "`ChDir`函数更改默认的目录，但不是在默认驱动器。 例如，如果默认驱动器 C，以下语句会更改驱动器 D 上的默认目录但 C 保留默认驱动器︰ [!code-vb [VbVbalrCatRef&#39;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_1.vb) ]可以相对目录更改为通过键入两个句点，如下所示︰ [!code-vb [VbVbalrCatRef&#40;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_2.vb) ]       >  [!IMPORTANT]&1;>`ChDir`函数需要非托管的代码的权限，这可能会影响在部分信任情况下其执行。 有关详细信息，请参阅<xref:System.Security.Permissions.SecurityPermission>和。</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the `ChDir` function to change the current directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#41](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_3.vb)]"
  syntax:
    content: public static void ChDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "必需。 A <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref>标识的目录或文件夹的表达式将成为新的默认目录或文件夹。 `Path`可能包括驱动器。 如果未指定驱动器， <xref uid=&quot;langword_csharp_ChDir&quot; name=&quot;ChDir&quot; href=&quot;&quot;> </xref>更改的默认目录或当前的驱动器上的文件夹。"
  overload: Microsoft.VisualBasic.FileSystem.ChDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>为空。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "指定了无效的驱动器，或者驱动器不可用。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  id: ChDrive(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDrive(Char)
  nameWithType: FileSystem.ChDrive(Char)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "更改当前驱动器。"
  remarks: "`ChDrive`函数需要非托管代码的权限，这可能会影响在部分信任情况下其执行。 有关详细信息，请参阅<xref:System.Security.Permissions.SecurityPermission>和[代码访问权限](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)。</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the `ChDrive` function to change the current drive. The function throws an exception if the drive does not exist.  \n  \n [!code-vb[VbVbalrCatRef#32](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._181_1.vb)]"
  syntax:
    content: public static void ChDrive (char Drive);
    parameters:
    - id: Drive
      type: System.Char
      description: "必需。 指定现有的驱动器的字符串表达式。 如果您提供一个零长度字符串 (&quot;&quot;)，当前的驱动器不会更改。 如果`Drive`自变量是包含多个字符的字符串， <xref uid=&quot;langword_csharp_ChDrive&quot; name=&quot;ChDrive&quot; href=&quot;&quot;> </xref>使用仅的第一个字母。"
  overload: Microsoft.VisualBasic.FileSystem.ChDrive*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "指定了无效的驱动器，或者驱动器不可用。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  id: ChDrive(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDrive(String)
  nameWithType: FileSystem.ChDrive(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "更改当前驱动器。"
  remarks: "`ChDrive`函数需要非托管代码的权限，这可能会影响在部分信任情况下其执行。 有关详细信息，请参阅<xref:System.Security.Permissions.SecurityPermission>和[代码访问权限](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)。</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the `ChDrive` function to change the current drive. The function throws an exception if the drive does not exist.  \n  \n [!code-vb[VbVbalrCatRef#32](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._225_1.vb)]"
  syntax:
    content: public static void ChDrive (string Drive);
    parameters:
    - id: Drive
      type: System.String
      description: "必需。 指定现有的驱动器的字符串表达式。 如果您提供一个零长度字符串 (&quot;&quot;)，当前的驱动器不会更改。 如果`Drive`自变量是包含多个字符的字符串， <xref uid=&quot;langword_csharp_ChDrive&quot; name=&quot;ChDrive&quot; href=&quot;&quot;> </xref>使用仅的第一个字母。"
  overload: Microsoft.VisualBasic.FileSystem.ChDrive*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "指定了无效的驱动器，或者驱动器不可用。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.CurDir
  id: CurDir
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: CurDir()
  nameWithType: FileSystem.CurDir()
  fullName: Microsoft.VisualBasic.FileSystem.CurDir()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "返回表示当前路径的字符串。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>可以获得更好的效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>。</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>"
  remarks: ''
  example:
  - "This example uses the `CurDir` function to return the current path.  \n  \n [!code-vb[VbVbalrCatRef#65](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._123_1.vb)]"
  syntax:
    content: public static string CurDir ();
    parameters: []
    return:
      type: System.String
      description: "表示当前路径的字符串。"
  overload: Microsoft.VisualBasic.FileSystem.CurDir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  id: CurDir(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: CurDir(Char)
  nameWithType: FileSystem.CurDir(Char)
  fullName: Microsoft.VisualBasic.FileSystem.CurDir(Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "返回表示当前路径的字符串。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>可以获得更好的效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>。</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>"
  remarks: ''
  example:
  - "This example uses the `CurDir` function to return the current path.  \n  \n [!code-vb[VbVbalrCatRef#65](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._203_1.vb)]"
  syntax:
    content: public static string CurDir (char Drive);
    parameters:
    - id: Drive
      type: System.Char
      description: "可选。 <xref uid=&quot;langword_csharp_Char&quot; name=&quot;Char&quot; href=&quot;&quot;></xref>指定现有的驱动器的表达式。 如果未指定驱动器，或如果`Drive`是零长度字符串 (&quot;&quot;)， <xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;> </xref>返回当前驱动器的路径。"
    return:
      type: System.String
      description: "表示当前路径的字符串。"
  overload: Microsoft.VisualBasic.FileSystem.CurDir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Dir
  id: Dir
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Dir()
  nameWithType: FileSystem.Dir()
  fullName: Microsoft.VisualBasic.FileSystem.Dir()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "返回表示文件、 目录或与指定的模式或文件属性匹配的文件夹的名称或驱动器的卷标签的字符串。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>为你提供更好的工作效率和性能中比文件 I/O 操作<xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;></xref>函数。 请参阅<xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>有关详细信息。</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>"
  remarks: "`Dir`函数支持多个字符的使用 (`*`) 和单字符 (`?`) 通配符来指定多个文件。       `VbVolume`返回而不是特定文件名的驱动器的卷标签。       必须提供`PathName`第一次调用`Dir`函数。 若要检索的下一项，你可以后续调用`Dir`不带参数的函数。      1> [!IMPORTANT]&1;> 正确，运行`Dir`函数需要<xref:System.Security.Permissions.FileIOPermissionAccess>和<xref:System.Security.Permissions.FileIOPermissionAccess>标志<xref:System.Security.Permissions.FileIOPermission>才能被授予对执行代码。</xref:System.Security.Permissions.FileIOPermission> </xref:System.Security.Permissions.FileIOPermissionAccess> </xref:System.Security.Permissions.FileIOPermissionAccess> 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermission>， <xref:System.Security.SecurityException>，和[代码访问权限](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)。</xref:System.Security.SecurityException> </xref:System.Security.Permissions.FileIOPermission>       `Attributes`参数枚举值如下: | | |  |-|-|-|  |值 |常量 |说明 |  |`Normal`|`vbnormal`|默认值。 指定无特性文件。 |  |`ReadOnly`|`vbReadOnly`|指定只读文件，以及带属性的文件。 |  |`Hidden`|`vbHidden`|指定隐藏的文件，以及带属性的文件。 |  |`System`|`vbSystem`|指定系统文件，以及带属性的文件。 |  |`Volume`|`vbVolume`|指定卷标签;如果指定其他任何属性，则`vbVolume`将被忽略。 |  |`Directory`|`vbDirectory`|指定目录或文件夹，并指定无特性还文件。 |  |`Archive`|`vbArchive`|文件自上次备份以来已更改。 |  |`Alias`|`vbAlias`|文件具有不同的名称。 |    &1;> [!NOTE]&1;> 这些枚举由 Visual Basic 语言指定，并可以使用而非实际值在代码中的任意位置。"
  example:
  - "This example uses the `Dir` function to check if certain files and directories exist.  \n  \n [!code-vb[VbVbalrCatRef#3](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._44_1.vb)]"
  syntax:
    content: public static string Dir ();
    parameters: []
    return:
      type: System.String
      description: "表示文件、 目录或与指定的模式或文件属性匹配的文件夹的名称或驱动器的卷标签的字符串。"
  overload: Microsoft.VisualBasic.FileSystem.Dir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  id: Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Dir(String,FileAttribute)
  nameWithType: FileSystem.Dir(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.Dir(String,FileAttribute)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "返回表示文件、 目录或与指定的模式或文件属性匹配的文件夹的名称或驱动器的卷标签的字符串。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>为你提供更好的工作效率和性能中比文件 I/O 操作<xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;></xref>函数。 请参阅<xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>有关详细信息。</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>"
  remarks: "`Dir`函数支持多个字符的使用 (`*`) 和单字符 (`?`) 通配符来指定多个文件。       `VbVolume`返回而不是特定文件名的驱动器的卷标签。       必须提供`PathName`第一次调用`Dir`函数。 若要检索的下一项，你可以后续调用`Dir`不带任何参数的函数。      1> [!IMPORTANT]&1;> 正确，运行`Dir`函数需要<xref:System.Security.Permissions.FileIOPermissionAccess>和<xref:System.Security.Permissions.FileIOPermissionAccess>标志<xref:System.Security.Permissions.FileIOPermission>才能被授予对执行代码。</xref:System.Security.Permissions.FileIOPermission> </xref:System.Security.Permissions.FileIOPermissionAccess> </xref:System.Security.Permissions.FileIOPermissionAccess> 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermission>， <xref:System.Security.SecurityException>，和[代码访问权限](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)。</xref:System.Security.SecurityException> </xref:System.Security.Permissions.FileIOPermission>       `Attributes`参数枚举值如下: | | |  |-|-|-|  |值 |常量 |说明 |  |`Normal`|`vbnormal`|默认值。 指定无特性的文件。 |  |`ReadOnly`|`vbReadOnly`|指定只读文件，除了不具任何属性的文件。 |  |`Hidden`|`vbHidden`|指定隐藏的文件，除了不具任何属性的文件。 |  |`System`|`vbSystem`|指定系统文件，除了不具任何属性的文件。 |  |`Volume`|`vbVolume`|指定卷标签;如果指定其他任何属性，则`vbVolume`将被忽略。 |  |`Directory`|`vbDirectory`|指定此外到没有属性的文件的目录或文件夹，。 |  |`Archive`|`vbArchive`|文件自上次备份以来已更改。 |  |`Alias`|`vbAlias`|文件具有不同的名称。 |    &1;> [!NOTE]&1;> 这些枚举由 Visual Basic 语言指定，并可以使用的实际值替换代码中的任意位置。"
  example:
  - "This example uses the `Dir` function to check if certain files and directories exist.  \n  \n [!code-vb[VbVbalrCatRef#3](~/add/codesnippet/visualbasic/0bb37160-d621-482a-af3b-_1.vb)]"
  syntax:
    content: public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);
    parameters:
    - id: PathName
      type: System.String
      description: "可选。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>指定文件名称、 目录或文件夹名称或驱动器卷标签的表达式。 零长度字符串 (<xref uid=&quot;langword_csharp_&quot;&quot;&quot; name=&quot;&quot;&quot;&quot; href=&quot;&quot;></xref>) 如果，则返回`PathName`找不到。"
    - id: Attributes
      type: Microsoft.VisualBasic.FileAttribute
      description: "可选。 枚举或数值表达式，其值指定文件属性。 如果省略， <xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;> </xref>返回匹配的文件`PathName`但不具任何属性。"
    return:
      type: System.String
      description: "表示文件、 目录或与指定的模式或文件属性匹配的文件夹的名称或驱动器的卷标签的字符串。"
  overload: Microsoft.VisualBasic.FileSystem.Dir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  id: EOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: EOF(Int32)
  nameWithType: FileSystem.EOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.EOF(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "返回一个布尔值<xref uid=&quot;langword_csharp_True&quot; name=&quot;True&quot; href=&quot;&quot;></xref>时文件末尾打开以进行<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;></xref>或连续<xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;></xref>已达到。"
  remarks: "使用`EOF`以避免通过尝试获取输入文件的末尾而产生的错误。       `EOF`函数返回`False`之前已到达文件末尾。 打开以进行文件与`Random`或`Binary`访问，`EOF`返回`False`直到最后一个执行`FileGet`函数不能读取完整记录。       打开以进行文件与`Binary`访问，请尝试通过文件使用读取`Input`函数直到`EOF`返回`True`生成错误。 使用`LOF`和`Loc`函数而不是`EOF`与二进制文件中读取时`Input`，或使用`Get`时使用`EOF`函数。 打开以进行文件与`Output`，`EOF`始终返回`True`。"
  example:
  - "This example uses the `EOF` function to detect the end of a file. This example assumes that `Testfile` is a text file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#62](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._184_1.vb)]"
  syntax:
    content: public static bool EOF (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref>包含任何有效的文件数。"
    return:
      type: System.Boolean
      description: "返回一个布尔值<xref uid=&quot;langword_csharp_True&quot; name=&quot;True&quot; href=&quot;&quot;></xref>时文件末尾打开以进行<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;></xref>或连续<xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;></xref>已达到。"
  overload: Microsoft.VisualBasic.FileSystem.EOF*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  id: FileAttr(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileAttr(Int32)
  nameWithType: FileSystem.FileAttr(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileAttr(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "返回一个枚举，表示使用打开的文件的文件模式<xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;></xref>函数。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>为你提供更好的工作效率和性能中比文件 I/O 操作<xref uid=&quot;langword_csharp_FileAttr &quot; name=&quot;FileAttr &quot; href=&quot;&quot;></xref>函数。 请参阅<xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>有关详细信息。</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>"
  remarks: "此函数将返回一个枚举，表示使用打开的文件的文件模式`FileOpen`函数。"
  example:
  - "This example uses the `FileAttr` function to return the file mode of an open file.  \n  \n [!code-vb[VbVbalrCatRef#46](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._147_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;></xref>. 任何有效的文件数。"
    return:
      type: Microsoft.VisualBasic.OpenMode
      description: "下面的枚举值表示文件访问模式︰       <table><tbody><tr><td> 值       </td><td> 模式       </td></tr><tr><td> 1       </td><td><xref uid=&quot;langword_csharp_OpenMode.Input&quot; name=&quot;OpenMode.Input&quot; href=&quot;&quot;></xref></td></tr><tr><td> 2       </td><td><xref uid=&quot;langword_csharp_OpenMode.Output&quot; name=&quot;OpenMode.Output&quot; href=&quot;&quot;></xref></td></tr><tr><td> 4       </td><td><xref uid=&quot;langword_csharp_OpenMode.Random&quot; name=&quot;OpenMode.Random&quot; href=&quot;&quot;></xref></td></tr><tr><td> 8       </td><td><xref uid=&quot;langword_csharp_OpenMode.Append&quot; name=&quot;OpenMode.Append&quot; href=&quot;&quot;></xref></td></tr><tr><td> 32       </td><td><xref uid=&quot;langword_csharp_OpenMode.Binary&quot; name=&quot;OpenMode.Binary&quot; href=&quot;&quot;></xref></td></tr></tbody></table>"
  overload: Microsoft.VisualBasic.FileSystem.FileAttr*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  id: FileClose(System.Int32[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileClose(Int32[])
  nameWithType: FileSystem.FileClose(Int32[])
  fullName: Microsoft.VisualBasic.FileSystem.FileClose(Int32[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "到输入/输出 (I/O) 结束使用打开的文件到<xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;></xref>函数。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;></xref>可更好的工作效率和性能在文件 I/O 操作。 请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>有关详细信息。"
  remarks: "`FileClose`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[如何︰ 使用 StreamReader 文件中读取文本](~/add/includes/ajax-current-ext-md.md)，[如何︰ 使用 StreamWriter 向文件写入文本](~/add/includes/ajax-current-ext-md.md)，和[演练︰ Visual Basic 中操作文件和目录](~/add/includes/ajax-current-ext-md.md)。       如果省略`FileNumbers`，所有活动文件打开`FileOpen`函数将关闭。       关闭已打开以进行文件`Output`或`Append`，最终输出缓冲区写入到该文件的操作系统缓冲区。 所有关联的缓冲区空间使用的已关闭发布文件。       当`FileClose`执行函数，而其文件的文件的关联是数字结束。"
  example:
  - "This example uses the `FileClose`function to close a file opened for `Input`.  \n  \n [!code-vb[VbVbalrCatRef#69](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._41_1.vb)]"
  syntax:
    content: public static void FileClose (int[] FileNumbers);
    parameters:
    - id: FileNumbers
      type: System.Int32[]
      description: "可选。 0 或更多通道即将关闭的参数数组。"
  overload: Microsoft.VisualBasic.FileSystem.FileClose*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>不存在。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  id: FileCopy(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileCopy(String,String)
  nameWithType: FileSystem.FileCopy(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.FileCopy(String,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "复制文件。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>可以获得更好的效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FileCopy&quot; name=&quot;FileCopy&quot; href=&quot;&quot;> </xref>。 请参阅<xref:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile*>有关详细信息。</xref:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile*>"
  remarks: "如果你尝试使用`FileCopy`函数上当前打开的文件，将会出错。       `FileCopy`需要完全信任才能在本地驱动器上工作。"
  example:
  - "This example uses the `FileCopy` function to copy one file to another. For purposes of this example, assume that `SrcFile` is a file that contains data.  \n  \n [!code-vb[VbVbalrCatRef#2](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._96_1.vb)]"
  syntax:
    content: public static void FileCopy (string Source, string Destination);
    parameters:
    - id: Source
      type: System.String
      description: "必需。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>指定要复制的文件的名称的表达式。 `Source`可能包含驱动器的源文件或目录和文件夹。"
    - id: Destination
      type: System.String
      description: "必需。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>指定目标文件名称的表达式。 `Destination`可能包括的目录或文件夹和目标文件的驱动器。"
  overload: Microsoft.VisualBasic.FileSystem.FileCopy*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Source</code>或<code>Destination</code>无效或不指定。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件已打开。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "文件不存在。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  id: FileDateTime(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileDateTime(String)
  nameWithType: FileSystem.FileDateTime(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileDateTime(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "返回<xref uid=&quot;langword_csharp_Date&quot; name=&quot;Date&quot; href=&quot;&quot;></xref>值，该值指示的日期和时间向其写入一个文件。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FileDateTime&quot; name=&quot;FileDateTime&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*></xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>"
  remarks: ''
  example:
  - "This example uses the `FileDateTime` function to determine the date and time a file was created or last modified. The format of the date and time displayed is based on the locale settings of the system.  \n  \n [!code-vb[VbVbalrCatRef#34](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._22_1.vb)]"
  syntax:
    content: public static DateTime FileDateTime (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "必需。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>指定的文件名称的表达式。 `PathName`可能包含目录或驱动器和文件夹。"
    return:
      type: System.DateTime
      description: "<xref uid=&quot;langword_csharp_Date&quot; name=&quot;Date&quot; href=&quot;&quot;></xref>创建或上次修改值，指示的日期和时间的文件。"
  overload: Microsoft.VisualBasic.FileSystem.FileDateTime*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>PathName</code>无效或包含通配符。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "目标文件不存在。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  id: FileGet(System.Int32,System.Boolean@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Boolean,Int64)
  nameWithType: FileSystem.FileGet(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Boolean,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "到一个变量中，从打开的磁盘文件读取数据。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/ad6628f8-6ae5-47af-a394-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Boolean
      description: "必需。 数据读入到其中的有效变量名称。"
    - id: RecordNumber
      type: System.Int64
      description: "可选。 记录数 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式文件) 或字节数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式文件) 在开始读取。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 且不等于-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  id: FileGet(System.Int32,System.Byte@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Byte,Int64)
  nameWithType: FileSystem.FileGet(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Byte,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "到一个变量中，从打开的磁盘文件读取数据。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used. Then the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/9daa1fad-0f67-40af-bac0-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Byte
      description: "必需。 数据读入到其中的有效变量名称。"
    - id: RecordNumber
      type: System.Int64
      description: "可选。 记录数 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式文件) 或字节数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式文件) 在开始读取。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 且不等于-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  id: FileGet(System.Int32,System.Char@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Char,Int64)
  nameWithType: FileSystem.FileGet(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Char,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "到一个变量中，从打开的磁盘文件读取数据。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/31a532e9-297f-48c8-a186-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Char
      description: "必需。 数据读入到其中的有效变量名称。"
    - id: RecordNumber
      type: System.Int64
      description: "可选。 记录数 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式文件) 或字节数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式文件) 在开始读取。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 且不等于-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  id: FileGet(System.Int32,System.DateTime@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,DateTime,Int64)
  nameWithType: FileSystem.FileGet(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,DateTime,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "到一个变量中，从打开的磁盘文件读取数据。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function,`FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/d9877ddb-692f-47fe-8c26-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.DateTime
      description: "必需。 数据读入到其中的有效变量名称。"
    - id: RecordNumber
      type: System.Int64
      description: "可选。 记录数 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式文件) 或字节数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式文件) 在开始读取。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 且不等于-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  id: FileGet(System.Int32,System.Decimal@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Decimal,Int64)
  nameWithType: FileSystem.FileGet(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Decimal,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "到一个变量中，从打开的磁盘文件读取数据。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/3d9f416d-1287-4566-b3fa-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Decimal
      description: "必需。 数据读入到其中的有效变量名称。"
    - id: RecordNumber
      type: System.Int64
      description: "可选。 记录数 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式文件) 或字节数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式文件) 在开始读取。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 且不等于-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  id: FileGet(System.Int32,System.Double@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Double,Int64)
  nameWithType: FileSystem.FileGet(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Double,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "到一个变量中，从打开的磁盘文件读取数据。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/184fee0e-b744-4669-8fdf-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Double
      description: "必需。 数据读入到其中的有效变量名称。"
    - id: RecordNumber
      type: System.Int64
      description: "可选。 记录数 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式文件) 或字节数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式文件) 在开始读取。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 且不等于-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  id: FileGet(System.Int32,System.Int16@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int16,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int16,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "到一个变量中，从打开的磁盘文件读取数据。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/45e0fdff-455b-4fd4-a7c2-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Int16
      description: "必需。 数据读入到其中的有效变量名称。"
    - id: RecordNumber
      type: System.Int64
      description: "可选。 记录数 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式文件) 或字节数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式文件) 在开始读取。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 且不等于-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  id: FileGet(System.Int32,System.Int32@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int32,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "到一个变量中，从打开的磁盘文件读取数据。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/7db3ee1c-ee17-457b-bd2d-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Int32
      description: "必需。 数据读入到其中的有效变量名称。"
    - id: RecordNumber
      type: System.Int64
      description: "可选。 记录数 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式文件) 或字节数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式文件) 在开始读取。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 且不等于-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  id: FileGet(System.Int32,System.Int64@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int64,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "到一个变量中，从打开的磁盘文件读取数据。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/bd48d1ef-82ea-4239-8c9b-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Int64
      description: "必需。 数据读入到其中的有效变量名称。"
    - id: RecordNumber
      type: System.Int64
      description: "可选。 记录数 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式文件) 或字节数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式文件) 在开始读取。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 且不等于-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  id: FileGet(System.Int32,System.Single@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Single,Int64)
  nameWithType: FileSystem.FileGet(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Single,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "到一个变量中，从打开的磁盘文件读取数据。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/79f9948f-e0d0-41fe-a7b5-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Single
      description: "必需。 数据读入到其中的有效变量名称。"
    - id: RecordNumber
      type: System.Int64
      description: "可选。 记录数 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式文件) 或字节数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式文件) 在开始读取。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 且不等于-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  id: FileGet(System.Int32,System.ValueType@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,ValueType,Int64)
  nameWithType: FileSystem.FileGet(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,ValueType,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "到一个变量中，从打开的磁盘文件读取数据。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/f351f02c-d919-4d73-938f-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.ValueType
      description: "必需。 数据读入到其中的有效变量名称。"
    - id: RecordNumber
      type: System.Int64
      description: "可选。 记录数 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式文件) 或字节数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式文件) 在开始读取。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 且不等于-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  id: FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FileGet(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,String,Int64,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "到一个变量中，从打开的磁盘文件读取数据。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/cefffea4-17eb-455d-be3e-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.String
      description: "必需。 数据读入到其中的有效变量名称。"
    - id: RecordNumber
      type: System.Int64
      description: "可选。 记录数 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式文件) 或字节数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式文件) 在开始读取。"
    - id: StringIsFixedLength
      type: System.Boolean
      description: "可选。 仅当编写一个字符串时，才适用。 指定是否写入两个字节描述符描述长度的字符串。 默认值是<xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 且不等于-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  id: FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "到一个变量中，从打开的磁盘文件读取数据。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the starting of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/c053ec00-d593-49bf-a3cb-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Array
      description: "必需。 数据读入到其中的有效变量名称。"
    - id: RecordNumber
      type: System.Int64
      description: "可选。 记录数 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式文件) 或字节数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式文件) 在开始读取。"
    - id: ArrayIsDynamic
      type: System.Boolean
      description: "可选。 仅编写数组时适用。 指定是否数组视为动态以及是否需要描述的大小和数组边界的数组说明符。"
    - id: StringIsFixedLength
      type: System.Boolean
      description: "可选。 仅当编写一个字符串时，才适用。 指定是否写入两个字节描述符描述长度的字符串。 默认值是<xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 且不等于-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  id: FileGetObject(System.Int32,System.Object@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGetObject(Int32,Object,Int64)
  nameWithType: FileSystem.FileGetObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGetObject(Int32,Object,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "到一个变量中，从打开的磁盘文件读取数据。  <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FileGetObject&quot; name=&quot;FileGetObject&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "The `FileGetObject` function is used instead of `FileGet` to avoid ambiguities at compile time if type `Object` is returned instead of another type, such as `Integer`, `Long`, `Short`, and so forth.  \n  \n If you intend to write out the `Variant` type, `FileGetObject` is required. When in doubt, if you are using an object for the second parameter, it is always suggested that you use `FilePutObject` and `FileGetObject`.  \n  \n `FileGetObject` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGetObject` is usually written with `FilePutObject`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, `FileGetObject` reads the record or byte after the last `FileGetObject` or `FilePutObject` function (or pointed to by the last `Seek` function).  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGetObject` reads subsequent records on record-length boundaries. The space between the end of one record and the beginning of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be precisely determined, it is a good idea to have the record length match the length of the data being read.  \n  \n-   If the variable being read into is a string, by default `FileGetObject` reads a two-byte descriptor containing the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings and when read to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, then the record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions.  \n  \n     For example, the following array declaration requires 218 bytes when the array is written to disk:  \n  \n     [!code-vb[VbVbalrCatRef#27](~/add/codesnippet/visualbasic/16450c3e-87c4-4606-9e31-_1.vb)]  \n  \n     The 218 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2), and 100 bytes for the data (5 \\* 10 \\* 4).  \n  \n-   `FileGetObject` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePutObject`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements, including any arrays and their descriptors. The <xref:Microsoft.VisualBasic.VBFixedStringAttribute> class can be applied to string fields in the structures to indicate the size of string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, all of the `Random` rules apply, with these exceptions:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGetObject`reads all variables from disk contiguously, that is, with no padding between records.  \n  \n-   For any array other than an array in a structure, `FileGetObject` reads only the data. No descriptor is read.  \n  \n `FileGetObject` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file named Form1.vb may not be a Visual Basic source file."
  example:
  - "The following example reads a record into a test file and then retrieves it.  \n  \n [!code-vb[VbVbalrCatRef#26](~/add/codesnippet/visualbasic/16450c3e-87c4-4606-9e31-_2.vb)]"
  syntax:
    content: public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Object
      description: "必需。 数据读入到其中的有效变量名称。"
    - id: RecordNumber
      type: System.Int64
      description: "可选。 记录数 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式文件) 或字节数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式文件) 在开始读取。"
  overload: Microsoft.VisualBasic.FileSystem.FileGetObject*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  id: FileLen(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileLen(String)
  nameWithType: FileSystem.FileLen(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileLen(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "返回<xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;></xref>值，该值指定文件的长度以字节为单位。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FileLen&quot; name=&quot;FileLen&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>。</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>"
  remarks: "如果指定的文件打开时`FileLen`被调用函数时，它已打开时，返回的值表示文件的大小。      1> [!NOTE]&1;> 若要获取的当前打开的文件的长度，请使用`LOF`函数。"
  example:
  - "This example uses the `FileLen` function to return the length of a file in bytes. For purposes of this example, assume that `TestFile` is a file that contains some data.  \n  \n [!code-vb[VbVbalrCatRef#1](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._122_1.vb)]"
  syntax:
    content: public static long FileLen (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "必需。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>指定的文件的表达式。 `PathName`可能包含目录或驱动器和文件夹。"
    return:
      type: System.Int64
      description: "<xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;></xref>值，该值指定文件的长度以字节为单位。"
  overload: Microsoft.VisualBasic.FileSystem.FileLen*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "文件不存在。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  id: FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  nameWithType: FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "打开用于输入或输出文件。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FileOpen`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/add/includes/ajax-current-ext-md.md)。       可以对其执行任何 I/O 操作之前，必须打开文件。 `FileOpen`针对 I/O 分配缓冲区，文件并确定要用于缓冲区的访问模式。      1> [!IMPORTANT]&1;> 写入到文件时，应用程序可能需要创建一个文件，如果尝试写入的文件不存在。 为此，它将用用于创建文件的目录中需要的权限。 但是，如果指定的文件`FileName`确实存在，应用程序需求`Write`仅指向文件本身的权限。 可能有助于提高安全性，部署和授予期间创建文件的任何位置`Write`对该文件的权限仅，而不是整个目录。 为了提高安全性，请将数据写入到的根目录或 Program Files 目录的用户目录而不是。       若要打开的通道可通过使用找到`FreeFile()`函数。      1> [!IMPORTANT]&1;>`FileOpen`函数需要`Read`从访问`FileIOPermissionAccess`枚举，从而可能影响在部分信任情况下其执行。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example illustrates various uses of the `FileOpen` function to enable input and output to a file.  \n  \n The following code opens the file `TestFile` in `Input` mode.  \n  \n [!code-vb[VbVbalrCatRef#5](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_1.vb)]  \n  \n This example opens the file in `Binary` mode for writing operations only.  \n  \n [!code-vb[VbVbalrCatRef#6](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_2.vb)]  \n  \n The following example opens the file in `Random` mode. The file contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#7](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_3.vb)]  \n  \n This code example opens the file in `Output` mode; any process can read or write to file.  \n  \n [!code-vb[VbVbalrCatRef#8](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_4.vb)]  \n  \n This code example opens the file in `Binary` mode for reading; other processes cannot read file.  \n  \n [!code-vb[VbVbalrCatRef#9](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_5.vb)]"
  syntax:
    content: public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。 使用<xref uid=&quot;langword_csharp_FreeFile&quot; name=&quot;FreeFile&quot; href=&quot;&quot;></xref>函数来获取下一个可用的文件数。"
    - id: FileName
      type: System.String
      description: "必需。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>指定的文件名称的表达式-可能包含目录或文件夹和驱动器。"
    - id: Mode
      type: Microsoft.VisualBasic.OpenMode
      description: '必需。 Enumeration specifying the file mode: <xref uid=&quot;langword_csharp_Append&quot; name=&quot;Append&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Output&quot; name=&quot;Output&quot; href=&quot;&quot;></xref>, or <xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;></xref>. 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.OpenMode&quot;> </xref> 。'
    - id: Access
      type: Microsoft.VisualBasic.OpenAccess
      description: '可选。 允许在打开的文件上的指定操作的枚举︰ <xref uid=&quot;langword_csharp_Read&quot; name=&quot;Read&quot; href=&quot;&quot;> </xref>， <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref>，或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref>。 默认为<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.OpenAccess&quot;> </xref> 。'
    - id: Share
      type: Microsoft.VisualBasic.OpenShare
      description: '可选。 枚举指定允许的操作不在打开的文件上其他进程︰ <xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref>， <xref uid=&quot;langword_csharp_Lock Read&quot; name=&quot;Lock Read&quot; href=&quot;&quot;> </xref>， <xref uid=&quot;langword_csharp_Lock Write&quot; name=&quot;Lock Write&quot; href=&quot;&quot;> </xref>，和<xref uid=&quot;langword_csharp_Lock Read Write&quot; name=&quot;Lock Read Write&quot; href=&quot;&quot;> </xref>。 默认为<xref uid=&quot;langword_csharp_Lock Read Write&quot; name=&quot;Lock Read Write&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.OpenShare&quot;> </xref> 。'
    - id: RecordLength
      type: System.Int32
      description: "可选。 小于或等于 32767 （字节） 数。 对于以随机访问方式打开的文件，此值是记录长度。 对于顺序文件，此值是缓冲的字符数。"
  overload: Microsoft.VisualBasic.FileSystem.FileOpen*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "记录长度为负 （和不等于-1）。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileName</code>已打开，或<code>FileName</code>无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  id: FilePut(System.Int32,System.Boolean,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Boolean,Int64)
  nameWithType: FileSystem.FilePut(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Boolean,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "变量的数据写入到磁盘文件中。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FilePut`仅在中有效`Random`和`Binary`模式。       数据使用编写`FilePut`从文件通常通过使用读取`FileGet`。       第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。       `StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。 `FilePut`如果参数为本身不会写入长度描述符`True`。 如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。      ## 随机模式的文件在中打开`Random`模式下，以下规则适用:-如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。 如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。      -如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。 因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。      -如果写入的变量是包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。 例如，当编写一个对象时，包含一个整数，`FilePut`写入&6; 个字节︰ 标识作为对象的两个字节`VarType(`3`)` (`Integer`) 包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。      -如果要写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(`8`)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。      -如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。 Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不能写描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。 描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_1.vb) ] -如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。      -`FilePut`写入的结构元素就像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。          1> [!NOTE]&1;> 字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，# # 有关二进制模式文件在中打开`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式:-`RecordLength`中的子句`FileOpen`函数不起任何作用。 `FilePut`将所有变量磁盘连续，即包含无记录之间的填充。      -对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。      -`FilePut`写入不是元素的结构没有两个字节长度说明符的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入到文件号 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_2.vb) ] -写入某个文件的使用`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Boolean
      description: "必需。 有效的变量名称包含数据写入到磁盘。"
    - id: RecordNumber
      type: System.Int64
      description: "可选。 记录数 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式文件) 或字节数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式文件) 在开始写入。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 且不等于-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  id: FilePut(System.Int32,System.Byte,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Byte,Int64)
  nameWithType: FileSystem.FilePut(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Byte,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "变量的数据写入到磁盘文件中。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FilePut`仅在中有效`Random`和`Binary`模式。       数据使用编写`FilePut`从文件通常通过使用读取`FileGet`。       第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。       `StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。 `FilePut`如果参数为本身不会写入长度描述符`True`。 如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。      ## 随机模式的文件在中打开`Random`模式下，以下规则适用:-如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。 如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。      -如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。 因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。      -如果写入的变量是包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。 例如，当编写一个对象时，包含一个整数，`FilePut`写入&6; 个字节︰ 标识作为对象的两个字节`VarType(`3`)` (`Integer`) 包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。      -如果要写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(`8`)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。      -如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。 Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不能写描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。 描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_1.vb) ] -如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。      -`FilePut`写入的结构元素就像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。          1> [!NOTE]&1;> 字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，# # 有关二进制模式文件在中打开`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式:-`RecordLength`中的子句`FileOpen`函数不起任何作用。 `FilePut`将所有变量磁盘连续，即包含无记录之间的填充。      -对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。      -`FilePut`写入不是元素的结构没有两个字节长度说明符的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入到文件号 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_2.vb) ] -写入某个文件的使用`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Byte
      description: "必需。 有效的变量名称包含数据写入到磁盘。"
    - id: RecordNumber
      type: System.Int64
      description: "可选。 记录数 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式文件) 或字节数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式文件) 在开始写入。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 且不等于-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  id: FilePut(System.Int32,System.Char,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Char,Int64)
  nameWithType: FileSystem.FilePut(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Char,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "变量的数据写入到磁盘文件中。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FilePut`仅在中有效`Random`和`Binary`模式。       数据使用编写`FilePut`从文件通常通过使用读取`FileGet`。       第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。       `StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。 `FilePut`如果参数为本身不会写入长度描述符`True`。 如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。      ## 随机模式的文件在中打开`Random`模式下，以下规则适用:-如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。 如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。      -如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。 因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。      -如果写入的变量是包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。 例如，当编写一个对象时，包含一个整数，`FilePut`写入&6; 个字节︰ 标识作为对象的两个字节`VarType(`3`)` (`Integer`) 包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。      -如果要写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(`8`)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。      -如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。 Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不能写描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。 描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_1.vb) ] -如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。      -`FilePut`写入的结构元素就像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。          1> [!NOTE]&1;> 字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，# # 有关二进制模式文件在中打开`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式:-`RecordLength`中的子句`FileOpen`函数不起任何作用。 `FilePut`将所有变量磁盘连续，即包含无记录之间的填充。      -对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。      -`FilePut`写入不是元素的结构没有两个字节长度说明符的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入到文件号 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_2.vb) ] -写入某个文件的使用`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Char
      description: "必需。 有效的变量名称包含数据写入到磁盘。"
    - id: RecordNumber
      type: System.Int64
      description: "可选。 记录数 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式文件) 或字节数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式文件) 在开始写入。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 且不等于-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  id: FilePut(System.Int32,System.DateTime,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,DateTime,Int64)
  nameWithType: FileSystem.FilePut(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,DateTime,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "变量的数据写入到磁盘文件中。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FilePut`仅在中有效`Random`和`Binary`模式。       数据使用编写`FilePut`从文件通常通过使用读取`FileGet`。       第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。       `StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。 `FilePut`如果参数为本身不会写入长度描述符`True`。 如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。      ## 随机模式的文件在中打开`Random`模式下，以下规则适用:-如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。 如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。      -如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。 因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。      -如果写入的变量是包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。 例如，当编写一个对象时，包含一个整数，`FilePut`写入&6; 个字节︰ 标识作为对象的两个字节`VarType(`3`)` (`Integer`) 包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。      -如果要写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(`8`)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。      -如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。 Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不能写描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。 描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_1.vb) ] -如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。      -`FilePut`写入的结构元素就像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。          1> [!NOTE]&1;> 字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，# # 有关二进制模式文件在中打开`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式:-`RecordLength`中的子句`FileOpen`函数不起任何作用。 `FilePut`将所有变量磁盘连续，即包含无记录之间的填充。      -对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。      -`FilePut`写入不是元素的结构没有两个字节长度说明符的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入到文件号 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_2.vb) ] -写入某个文件的使用`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.DateTime
      description: "必需。 有效的变量名称包含数据写入到磁盘。"
    - id: RecordNumber
      type: System.Int64
      description: "可选。 记录数 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式文件) 或字节数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式文件) 在开始写入。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 且不等于-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  id: FilePut(System.Int32,System.Decimal,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Decimal,Int64)
  nameWithType: FileSystem.FilePut(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Decimal,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "变量的数据写入到磁盘文件中。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FilePut`仅在中有效`Random`和`Binary`模式。       数据使用编写`FilePut`从文件通常通过使用读取`FileGet`。       第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。       `StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。 `FilePut`如果参数为本身不会写入长度描述符`True`。 如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。      ## 随机模式的文件在中打开`Random`模式下，以下规则适用:-如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。 如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。      -如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。 因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。      -如果写入的变量是包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。 例如，当编写一个对象时，包含一个整数，`FilePut`写入&6; 个字节︰ 标识作为对象的两个字节`VarType(`3`)` (`Integer`) 包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。      -如果要写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(`8`)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。      -如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。 Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不能写描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。 描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_1.vb) ] -如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。      -`FilePut`写入的结构元素就像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。          1> [!NOTE]&1;> 字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，# # 有关二进制模式文件在中打开`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式:-`RecordLength`中的子句`FileOpen`函数不起任何作用。 `FilePut`将所有变量磁盘连续，即包含无记录之间的填充。      -对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。      -`FilePut`写入不是元素的结构没有两个字节长度说明符的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入到文件号 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_2.vb) ] -写入某个文件的使用`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Decimal
      description: "必需。 有效的变量名称包含数据写入到磁盘。"
    - id: RecordNumber
      type: System.Int64
      description: "可选。 记录数 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式文件) 或字节数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式文件) 在开始写入。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 且不等于-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  id: FilePut(System.Int32,System.Double,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Double,Int64)
  nameWithType: FileSystem.FilePut(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Double,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "变量的数据写入到磁盘文件中。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FilePut`仅在中有效`Random`和`Binary`模式。       数据使用编写`FilePut`从文件通常通过使用读取`FileGet`。       第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。       `StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。 `FilePut`如果参数为本身不会写入长度描述符`True`。 如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。      ## 随机模式的文件在中打开`Random`模式下，以下规则适用:-如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。 如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。      -如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。 因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。      -如果写入的变量是包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。 例如，当编写一个对象时，包含一个整数，`FilePut`写入&6; 个字节︰ 标识作为对象的两个字节`VarType(`3`)` (`Integer`) 包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。      -如果要写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(`8`)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。      -如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。 Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不能写描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。 描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_1.vb) ] -如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。      -`FilePut`写入的结构元素就像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。          1> [!NOTE]&1;> 字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，# # 有关二进制模式文件在中打开`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式:-`RecordLength`中的子句`FileOpen`函数不起任何作用。 `FilePut`将所有变量磁盘连续，即包含无记录之间的填充。      -对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。      -`FilePut`写入不是元素的结构没有两个字节长度说明符的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入到文件号 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_2.vb) ] -写入某个文件的使用`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Double
      description: "必需。 有效的变量名称包含数据写入到磁盘。"
    - id: RecordNumber
      type: System.Int64
      description: "可选。 记录数 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式文件) 或字节数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式文件) 在开始写入。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 且不等于-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  id: FilePut(System.Int32,System.Int16,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int16,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int16,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "变量的数据写入到磁盘文件中。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FilePut`仅在中有效`Random`和`Binary`模式。       数据使用编写`FilePut`从文件通常通过使用读取`FileGet`。       第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。       `StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。 `FilePut`如果参数为本身不会写入长度描述符`True`。 如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。      ## 随机模式的文件在中打开`Random`模式下，以下规则适用:-如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。 如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。      -如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。 因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。      -如果写入的变量是包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。 例如，当编写一个对象时，包含一个整数，`FilePut`写入&6; 个字节︰ 标识作为对象的两个字节`VarType(`3`)` (`Integer`) 包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。      -如果要写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(`8`)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。      -如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。 Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不能写描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。 描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_1.vb) ] -如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。      -`FilePut`写入的结构元素就像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。          1> [!NOTE]&1;> 字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，# # 有关二进制模式文件在中打开`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式:-`RecordLength`中的子句`FileOpen`函数不起任何作用。 `FilePut`将所有变量磁盘连续，即包含无记录之间的填充。      -对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。      -`FilePut`写入不是元素的结构没有两个字节长度说明符的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入到文件号 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_2.vb) ] -写入某个文件的使用`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Int16
      description: "必需。 有效的变量名称包含数据写入到磁盘。"
    - id: RecordNumber
      type: System.Int64
      description: "可选。 记录数 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式文件) 或字节数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式文件) 在开始写入。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 且不等于-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  id: FilePut(System.Int32,System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int32,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "变量的数据写入到磁盘文件中。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FilePut`仅在中有效`Random`和`Binary`模式。       数据使用编写`FilePut`从文件通常通过使用读取`FileGet`。       第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。       `StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。 `FilePut`如果参数为本身不会写入长度描述符`True`。 如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。      ## 随机模式的文件在中打开`Random`模式下，以下规则适用:-如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。 如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。      -如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。 因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。      -如果写入的变量是包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。 例如，当编写一个对象时，包含一个整数，`FilePut`写入&6; 个字节︰ 标识作为对象的两个字节`VarType(`3`)` (`Integer`) 包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。      -如果要写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(`8`)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。      -如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。 Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不能写描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。 描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_1.vb) ] -如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。      -`FilePut`写入的结构元素就像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。          1> [!NOTE]&1;> 字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，# # 有关二进制模式文件在中打开`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式:-`RecordLength`中的子句`FileOpen`函数不起任何作用。 `FilePut`将所有变量磁盘连续，即包含无记录之间的填充。      -对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。      -`FilePut`写入不是元素的结构没有两个字节长度说明符的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入到文件号 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_2.vb) ] -写入某个文件的使用`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Int32
      description: "必需。 有效的变量名称包含数据写入到磁盘。"
    - id: RecordNumber
      type: System.Int64
      description: "可选。 记录数 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式文件) 或字节数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式文件) 在开始写入。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 且不等于-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  id: FilePut(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int64,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "变量的数据写入到磁盘文件中。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FilePut`仅在中有效`Random`和`Binary`模式。       数据使用编写`FilePut`从文件通常通过使用读取`FileGet`。       第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。       `StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。 `FilePut`如果参数为本身不会写入长度描述符`True`。 如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。      ## 随机模式的文件在中打开`Random`模式下，以下规则适用:-如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。 如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。      -如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。 因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。      -如果写入的变量是包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。 例如，当编写一个对象时，包含一个整数，`FilePut`写入&6; 个字节︰ 标识作为对象的两个字节`VarType(`3`)` (`Integer`) 包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。      -如果要写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(`8`)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。      -如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。 Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不能写描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。 描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_1.vb) ] -如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。      -`FilePut`写入的结构元素就像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。          1> [!NOTE]&1;> 字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，# # 有关二进制模式文件在中打开`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式:-`RecordLength`中的子句`FileOpen`函数不起任何作用。 `FilePut`将所有变量磁盘连续，即包含无记录之间的填充。      -对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。      -`FilePut`写入不是元素的结构没有两个字节长度说明符的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入到文件号 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_2.vb) ] -写入某个文件的使用`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Int64
      description: "必需。 有效的变量名称包含数据写入到磁盘。"
    - id: RecordNumber
      type: System.Int64
      description: "可选。 记录数 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式文件) 或字节数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式文件) 在开始写入。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 且不等于-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  id: FilePut(System.Int32,System.Single,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Single,Int64)
  nameWithType: FileSystem.FilePut(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Single,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "变量的数据写入到磁盘文件中。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FilePut`仅在中有效`Random`和`Binary`模式。       数据使用编写`FilePut`从文件通常通过使用读取`FileGet`。       第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。       `StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。 `FilePut`如果参数为本身不会写入长度描述符`True`。 如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。      ## 随机模式的文件在中打开`Random`模式下，以下规则适用:-如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。 如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。      -如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。 因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。      -如果写入的变量是包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。 例如，当编写一个对象时，包含一个整数，`FilePut`写入&6; 个字节︰ 标识作为对象的两个字节`VarType(`3`)` (`Integer`) 包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。      -如果要写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(`8`)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。      -如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。 Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不能写描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。 描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_1.vb) ] -如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。      -`FilePut`写入的结构元素就像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。          1> [!NOTE]&1;> 字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，# # 有关二进制模式文件在中打开`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式:-`RecordLength`中的子句`FileOpen`函数不起任何作用。 `FilePut`将所有变量磁盘连续，即包含无记录之间的填充。      -对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。      -`FilePut`写入不是元素的结构没有两个字节长度说明符的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入到文件号 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_2.vb) ] -写入某个文件的使用`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Single
      description: "必需。 有效的变量名称包含数据写入到磁盘。"
    - id: RecordNumber
      type: System.Int64
      description: "可选。 记录数 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式文件) 或字节数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式文件) 在开始写入。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 且不等于-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  id: FilePut(System.Int32,System.ValueType,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,ValueType,Int64)
  nameWithType: FileSystem.FilePut(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,ValueType,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "变量的数据写入到磁盘文件中。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FilePut`仅在中有效`Random`和`Binary`模式。       数据使用编写`FilePut`从文件通常通过使用读取`FileGet`。       第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。       `StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。 `FilePut`如果参数为本身不会写入长度描述符`True`。 如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。      ## 随机模式的文件在中打开`Random`模式下，以下规则适用:-如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。 如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。      -如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。 因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。      -如果写入的变量是包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。 例如，当编写一个对象时，包含一个整数，`FilePut`写入&6; 个字节︰ 标识作为对象的两个字节`VarType(`3`)` (`Integer`) 包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。      -如果要写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(`8`)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。      -如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。 Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不能写描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。 描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_1.vb) ] -如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。      -`FilePut`写入的结构元素就像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。          1> [!NOTE]&1;> 字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，# # 有关二进制模式文件在中打开`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式:-`RecordLength`中的子句`FileOpen`函数不起任何作用。 `FilePut`将所有变量磁盘连续，即包含无记录之间的填充。      -对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。      -`FilePut`写入不是元素的结构没有两个字节长度说明符的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入到文件号 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_2.vb) ] -写入某个文件的使用`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.ValueType
      description: "必需。 有效的变量名称包含数据写入到磁盘。"
    - id: RecordNumber
      type: System.Int64
      description: "可选。 记录数 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式文件) 或字节数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式文件) 在开始写入。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 且不等于-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  id: FilePut(System.Object,System.Object,System.Object)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Object,Object,Object)
  nameWithType: FileSystem.FilePut(Object,Object,Object)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Object,Object,Object)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "变量的数据写入到磁盘文件中。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FilePut`仅在中有效`Random`和`Binary`模式。       数据使用编写`FilePut`从文件通常通过使用读取`FileGet`。       第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。       `StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。 `FilePut`如果参数为本身不会写入长度描述符`True`。 如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。      ## 随机模式的文件在中打开`Random`模式下，以下规则适用:-如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。 如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。      -如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。 因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。      -如果写入的变量是包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。 例如，当编写一个对象时，包含一个整数，`FilePut`写入&6; 个字节︰ 标识作为对象的两个字节`VarType(`3`)` (`Integer`) 包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。      -如果要写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(`8`)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。      -如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。 Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不能写描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。 描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_1.vb) ] -如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。      -`FilePut`写入的结构元素就像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。          1> [!NOTE]&1;> 字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，# # 有关二进制模式文件在中打开`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式:-`RecordLength`中的子句`FileOpen`函数不起任何作用。 `FilePut`将所有变量磁盘连续，即包含无记录之间的填充。      -对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。      -`FilePut`写入不是元素的结构没有两个字节长度说明符的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入到文件号 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_2.vb) ] -写入某个文件的使用`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_3.vb)]"
  syntax:
    content: public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Object
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Object
      description: "必需。 有效的变量名称包含数据写入到磁盘。"
    - id: RecordNumber
      type: System.Object
      description: "可选。 记录数 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式文件) 或字节数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式文件) 在开始写入。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 且不等于-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  id: FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FilePut(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,String,Int64,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "变量的数据写入到磁盘文件中。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>..."
  remarks: "`FilePut`仅在中有效`Random`和`Binary`模式。       数据使用编写`FilePut`从文件通常通过使用读取`FileGet`。       第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。       `StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。 `FilePut`如果参数为本身不会写入长度描述符`True`。 如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。      ## 随机模式的文件在中打开`Random`模式下，以下规则适用:-如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。 如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。      -如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。 因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。      -如果写入的变量是包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。 例如，当编写一个对象时，包含一个整数，`FilePut`写入&6; 个字节︰ 标识作为对象的两个字节`VarType(`3`)` (`Integer`) 包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。      -如果要写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(`8`)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。      -如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。 Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不能写描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。 描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_1.vb) ] -如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。      -`FilePut`写入的结构元素就像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。          1> [!NOTE]&1;> 字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，# # 有关二进制模式文件在中打开`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式:-`RecordLength`中的子句`FileOpen`函数不起任何作用。 `FilePut`将所有变量磁盘连续，即包含无记录之间的填充。      -对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。      -`FilePut`写入不是元素的结构没有两个字节长度说明符的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入到文件号 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_2.vb) ] -写入某个文件的使用`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.String
      description: "必需。 有效的变量名称包含数据写入到磁盘。"
    - id: RecordNumber
      type: System.Int64
      description: "可选。 记录数 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式文件) 或字节数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式文件) 在开始写入。"
    - id: StringIsFixedLength
      type: System.Boolean
      description: "可选。 仅当编写一个字符串时，才适用。 指定是否向文件写入字符串的两个字节的字符串长度描述符。 默认值是<xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 且不等于-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  id: FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "变量的数据写入到磁盘文件中。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FilePut`仅在中有效`Random`和`Binary`模式。       数据使用编写`FilePut`从文件通常通过使用读取`FileGet`。       第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。       `StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。 `FilePut`如果参数为本身不会写入长度描述符`True`。 如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。      ## 随机模式的文件在中打开`Random`模式下，以下规则适用:-如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。 如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。      -如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。 因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。      -如果写入的变量是包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。 例如，当编写一个对象时，包含一个整数，`FilePut`写入&6; 个字节︰ 标识作为对象的两个字节`VarType(`3`)` (`Integer`) 包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。      -如果要写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(`8`)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。      -如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。 Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不能写描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。 描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_1.vb) ] -如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。      -`FilePut`写入的结构元素就像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。          1> [!NOTE]&1;> 字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，# # 有关二进制模式文件在中打开`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式:-`RecordLength`中的子句`FileOpen`函数不起任何作用。 `FilePut`将所有变量磁盘连续，即包含无记录之间的填充。      -对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。      -`FilePut`写入不是元素的结构没有两个字节长度说明符的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入到文件号 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_2.vb) ] -写入某个文件的使用`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Array
      description: "必需。 有效的变量名称包含数据写入到磁盘。"
    - id: RecordNumber
      type: System.Int64
      description: "可选。 记录数 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式文件) 或字节数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式文件) 在开始写入。"
    - id: ArrayIsDynamic
      type: System.Boolean
      description: "可选。 仅编写数组时适用。 指定是否将数组视为动态的以及是否写入描述长度的字符串数组描述符。"
    - id: StringIsFixedLength
      type: System.Boolean
      description: "可选。 仅当编写一个字符串时，才适用。 指定是否向文件写入字符串的两个字节的字符串长度描述符。 默认值是<xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 且不等于-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  id: FilePutObject(System.Int32,System.Object,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePutObject(Int32,Object,Int64)
  nameWithType: FileSystem.FilePutObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePutObject(Int32,Object,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "变量的数据写入到磁盘文件中。  <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FilePutObject&quot; name=&quot;FilePutObject&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FilePutObject`而不是使用函数`FilePut`以避免多义性在编译时，如果类型`Object`而不是另一个类型，如传递`Integer`， `Long`， `Short`，依次类推。       `FilePutObject`写入和读取描述对象的描述符。 如果你想要写出`Variant`类型，`FilePutObject`是必需的。 当有疑问时，如果第二个参数使用一个对象，我们建议您始终使用`FilePutObject`和`FileGetObject`。       `FilePutObject`仅在中有效`Random`和`Binary`模式。       数据使用编写`FilePutObject`从文件通常通过使用读取`FileGetObject`。       第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`，`FilePutObject`上次写入的下一步的记录或字节`FileGetObject`或`FilePutObject`函数 (或记录或字节指向由最后一个`Seek`函数)。       `StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。 `FilePutObject`如果参数为本身不会写入长度描述符`True`。 如果你使用`StringIsFixedLength`  =  `True`与`FilePutObject`，您需要做相同，但有`FileGetObject`，和你还必须确保此字符串初始化为所需的长度。      ## 随机模式的文件在中打开`Random`模式下，以下规则适用:-如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePutObject`将后续记录写入记录长度边界上。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法精确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。 如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。      -如果写入的变量是包含数值类型的对象`FilePutObject`写入两个字节以标识`VarType`的对象，然后将该变量。 例如，当编写一个对象时，包含一个整数，`FilePutObject`写入&6; 个字节︰ 标识作为对象的两个字节`VarType(`3`)` (`Integer`) 包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。      -如果要写入的变量是一个对象，包含一个字符串，`FilePutObject`写入一个双字节说明符标识`VarType(`8`)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。      -如果写入的变量为数组，则指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。      ## 在二进制模式的文件打开`Binary`模式下，所有`Random`模式的规则将应用，除:-`RecordLength`子句中的`FileOpen`函数不起任何作用。 `FilePutObject`将所有变量磁盘连续，即包含无记录之间的填充。"
  example:
  - "This example uses the `FilePutObject` function to write a string to a file.  \n  \n [!code-vb[VbVbalrCatRef#54](~/add/codesnippet/visualbasic/69f8d8bb-169c-4dec-b805-_1.vb)]"
  syntax:
    content: public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Object
      description: "必需。 有效的变量名称包含数据写入到磁盘。"
    - id: RecordNumber
      type: System.Int64
      description: "可选。 记录数 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式文件) 或字节数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式文件) 在开始写入。"
  overload: Microsoft.VisualBasic.FileSystem.FilePutObject*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  id: FileWidth(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileWidth(Int32,Int32)
  nameWithType: FileSystem.FileWidth(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileWidth(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "将输出线条宽度分配给使用打开的文件<xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;></xref>函数。"
  remarks: ''
  example:
  - "This example uses the `FileWidth` function to set the output line width for a file.  \n  \n [!code-vb[VbVbalrCatRef#10](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._187_1.vb)]"
  syntax:
    content: public static void FileWidth (int FileNumber, int RecordWidth);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: RecordWidth
      type: System.Int32
      description: "必需。 数值表达式在范围 0 – 255 （含)，它表示在多少个字符显示在行上，启动一个新行之前。 如果`RecordWidth`等于 0，则一条线的长度没有限制。 默认值为`RecordWidth`为 0。"
  overload: Microsoft.VisualBasic.FileSystem.FileWidth*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FreeFile
  id: FreeFile
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FreeFile()
  nameWithType: FileSystem.FreeFile()
  fullName: Microsoft.VisualBasic.FileSystem.FreeFile()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "返回<xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;></xref>值，该值表示可供使用的下一个文件编号<xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;></xref>函数。"
  remarks: "使用`FreeFile`提供尚未使用文件数。"
  example:
  - "This example uses the `FreeFile` function to return the next available file number. Five files are opened for output within the loop, and some sample data is written to each.  \n  \n [!code-vb[VbVbalrCatRef#55](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._104_1.vb)]"
  syntax:
    content: public static int FreeFile ();
    parameters: []
    return:
      type: System.Int32
      description: "返回<xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;></xref>值，该值表示可供使用的下一个文件编号<xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;></xref>函数。"
  overload: Microsoft.VisualBasic.FileSystem.FreeFile*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "超过 255 个文件正在使用中。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  id: GetAttr(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: GetAttr(String)
  nameWithType: FileSystem.GetAttr(String)
  fullName: Microsoft.VisualBasic.FileSystem.GetAttr(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "返回<xref uid=&quot;langword_csharp_FileAttribute&quot; name=&quot;FileAttribute&quot; href=&quot;&quot;></xref>表示的文件、 目录或文件夹的特性的值。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_FileAttribute&quot; name=&quot;FileAttribute&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "若要确定设置了哪些属性，请使用`And`运算符执行返回的值的按位比较`GetAttr`函数和所需的各个文件属性的值。 如果结果不为零，则该属性设置为指定的文件。 例如，以下的返回值`And`表达式是零 if`Archive`未设置属性︰```vb#   Result = GetAttr(FName) And vbArchive   ```如果，则返回一个非零值`Archive`属性设置。"
  example:
  - "This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#25](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._13_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "必需。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>指定的文件、 目录或文件夹名称的表达式。 `PathName`可以包含目录或驱动器和文件夹。"
    return:
      type: Microsoft.VisualBasic.FileAttribute
      description: "返回的值<xref uid=&quot;langword_csharp_GetAttr&quot; name=&quot;GetAttr&quot; href=&quot;&quot;></xref>是下列枚举值的总和︰       <table><tbody><tr><td> 值       </td><td> 常量的说明       </td></tr><tr><td><xref uid=&quot;langword_csharp_Normal&quot; name=&quot;Normal&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbNormal&quot; name=&quot;vbNormal&quot; href=&quot;&quot;></xref>法线。       </td></tr><tr><td><xref uid=&quot;langword_csharp_ReadOnly&quot; name=&quot;ReadOnly&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbReadOnly&quot; name=&quot;vbReadOnly&quot; href=&quot;&quot;></xref>只读的。       </td></tr><tr><td><xref uid=&quot;langword_csharp_Hidden&quot; name=&quot;Hidden&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbHidden&quot; name=&quot;vbHidden&quot; href=&quot;&quot;></xref>隐藏。       </td></tr><tr><td><xref uid=&quot;langword_csharp_System&quot; name=&quot;System&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbSystem&quot; name=&quot;vbSystem&quot; href=&quot;&quot;></xref>系统文件。       </td></tr><tr><td><xref uid=&quot;langword_csharp_Directory&quot; name=&quot;Directory&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbDirectory&quot; name=&quot;vbDirectory&quot; href=&quot;&quot;></xref>目录或文件夹。       </td></tr><tr><td><xref uid=&quot;langword_csharp_Archive&quot; name=&quot;Archive&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbArchive&quot; name=&quot;vbArchive&quot; href=&quot;&quot;></xref>自上次备份以来已更改文件。       </td></tr><tr><td><xref uid=&quot;langword_csharp_Alias&quot; name=&quot;Alias&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbAlias&quot; name=&quot;vbAlias&quot; href=&quot;&quot;></xref>文件具有不同的名称。       </td></tr></tbody></table><div class=&quot;alert NOTE&quot;>    Visual Basic 语言指定这些枚举。 名称可以代替实际值在代码中的任意位置使用。      </div>"
  overload: Microsoft.VisualBasic.FileSystem.GetAttr*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>Pathname</code>无效或包含通配符。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "目标文件不存在。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  id: Input(System.Int32,System.Boolean@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Boolean)
  nameWithType: FileSystem.Input(Int32,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "从打开的顺序文件中读取数据并将数据赋给变量。"
  remarks: "`Input`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/add/includes/ajax-current-ext-md.md)。       数据读取`Input`通过使用通常写入到文件`Write`。 此函数只能用于的文件在打开`Input`或`Binary`模式。      1> [!IMPORTANT]&1;> 时从文件读取，不要做出有关内容的基于文件扩展名的文件的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。       读取时，标准字符串或数值数据就赋给变量而不进行修改。 下表说明了如何处理其他输入的数据。      |||  |-|-|  |数据 |分配给变量的值 |  |分隔逗号或空白的行 |空 |  | #NULL #|`DBNull`|  | #TRUE # 或 #FALSE #|`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式所表示的时间 |  |#ERROR `errornumber` #| `errornumber` （变量是一个对象标记为错误） |      如果在输入数据项时达到文件末尾，输入已停止，则会出错。      1> [!NOTE]&1;>`Input`函数未进行本地化。 例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。      1> [!IMPORTANT]&1;> 者使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._237_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref bool Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Boolean
      description: "必需。 从文件中读取变量分配值-不能为数组或对象变量。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  id: Input(System.Int32,System.Byte@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Byte)
  nameWithType: FileSystem.Input(Int32,Byte)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Byte)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "从打开的顺序文件中读取数据并将数据赋给变量。"
  remarks: "`Input`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/add/includes/ajax-current-ext-md.md)。       数据读取`Input`通过使用通常写入到文件`Write`。 此函数只能用于的文件在打开`Input`或`Binary`模式。      1> [!IMPORTANT]&1;> 时从文件读取，不要做出有关内容的基于文件扩展名的文件的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。       读取时，标准字符串或数值数据就赋给变量而不进行修改。 下表说明了如何处理其他输入的数据。      |||  |-|-|  |数据 |分配给变量的值 |  |分隔逗号或空白的行 |空 |  | #NULL #|`DBNull`|  | #TRUE # 或 #FALSE #|`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式所表示的时间 |  |#ERROR `errornumber` #| `errornumber` （变量是一个对象标记为错误） |      如果在输入数据项时达到文件末尾，输入已停止，则会出错。      1> [!NOTE]&1;>`Input`函数未进行本地化。 例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。      1> [!IMPORTANT]&1;> 者使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._73_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref byte Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Byte
      description: "必需。 从文件中读取变量分配值-不能为数组或对象变量。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  id: Input(System.Int32,System.Char@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Char)
  nameWithType: FileSystem.Input(Int32,Char)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "从打开的顺序文件中读取数据并将数据赋给变量。"
  remarks: "`Input`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/add/includes/ajax-current-ext-md.md)。       数据读取`Input`通过使用通常写入到文件`Write`。 此函数只能用于的文件在打开`Input`或`Binary`模式。      1> [!IMPORTANT]&1;> 时从文件读取，不要做出有关内容的基于文件扩展名的文件的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。       读取时，标准字符串或数值数据就赋给变量而不进行修改。 下表说明了如何处理其他输入的数据。      |||  |-|-|  |数据 |分配给变量的值 |  |分隔逗号或空白的行 |空 |  | #NULL #|`DBNull`|  | #TRUE # 或 #FALSE #|`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式所表示的时间 |  |#ERROR `errornumber` #| `errornumber` （变量是一个对象标记为错误） |      如果在输入数据项时达到文件末尾，输入已停止，则会出错。      1> [!NOTE]&1;>`Input`函数未进行本地化。 例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。      1> [!IMPORTANT]&1;> 者使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._91_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref char Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Char
      description: "必需。 从文件中读取变量分配值-不能为数组或对象变量。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  id: Input(System.Int32,System.DateTime@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,DateTime)
  nameWithType: FileSystem.Input(Int32,DateTime)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,DateTime)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "从打开的顺序文件中读取数据并将数据赋给变量。"
  remarks: "`Input`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/add/includes/ajax-current-ext-md.md)。       数据读取`Input`通过使用通常写入到文件`Write`。 此函数只能用于的文件在打开`Input`或`Binary`模式。      1> [!IMPORTANT]&1;> 时从文件读取，不要做出有关内容的基于文件扩展名的文件的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。       读取时，标准字符串或数值数据就赋给变量而不进行修改。 下表说明了如何处理其他输入的数据。      |||  |-|-|  |数据 |分配给变量的值 |  |分隔逗号或空白的行 |空 |  | #NULL #|`DBNull`|  | #TRUE # 或 #FALSE #|`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式所表示的时间 |  |#ERROR `errornumber` #| `errornumber` （变量是一个对象标记为错误） |      如果在输入数据项时达到文件末尾，输入已停止，则会出错。      1> [!NOTE]&1;>`Input`函数未进行本地化。 例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。      1> [!IMPORTANT]&1;> 者使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._169_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref DateTime Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.DateTime
      description: "必需。 从文件中读取变量分配值-不能为数组或对象变量。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  id: Input(System.Int32,System.Decimal@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Decimal)
  nameWithType: FileSystem.Input(Int32,Decimal)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Decimal)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "从打开的顺序文件中读取数据并将数据赋给变量。"
  remarks: "`Input`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/add/includes/ajax-current-ext-md.md)。       数据读取`Input`通过使用通常写入到文件`Write`。 此函数只能用于的文件在打开`Input`或`Binary`模式。      1> [!IMPORTANT]&1;> 时从文件读取，不要做出有关内容的基于文件扩展名的文件的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。       读取时，标准字符串或数值数据就赋给变量而不进行修改。 下表说明了如何处理其他输入的数据。      |||  |-|-|  |数据 |分配给变量的值 |  |分隔逗号或空白的行 |空 |  | #NULL #|`DBNull`|  | #TRUE # 或 #FALSE #|`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式所表示的时间 |  |#ERROR `errornumber` #| `errornumber` （变量是一个对象标记为错误） |      如果在输入数据项时达到文件末尾，输入已停止，则会出错。      1> [!NOTE]&1;>`Input`函数未进行本地化。 例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。      1> [!IMPORTANT]&1;> 者使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._46_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref decimal Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Decimal
      description: "必需。 从文件中读取变量分配值-不能为数组或对象变量。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  id: Input(System.Int32,System.Double@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Double)
  nameWithType: FileSystem.Input(Int32,Double)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Double)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "从打开的顺序文件中读取数据并将数据赋给变量。"
  remarks: "`Input`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/add/includes/ajax-current-ext-md.md)。       数据读取`Input`通过使用通常写入到文件`Write`。 此函数只能用于的文件在打开`Input`或`Binary`模式。      1> [!IMPORTANT]&1;> 时从文件读取，不要做出有关内容的基于文件扩展名的文件的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。       读取时，标准字符串或数值数据就赋给变量而不进行修改。 下表说明了如何处理其他输入的数据。      |||  |-|-|  |数据 |分配给变量的值 |  |分隔逗号或空白的行 |空 |  | #NULL #|`DBNull`|  | #TRUE # 或 #FALSE #|`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式所表示的时间 |  |#ERROR `errornumber` #| `errornumber` （变量是一个对象标记为错误） |      如果在输入数据项时达到文件末尾，输入已停止，则会出错。      1> [!NOTE]&1;>`Input`函数未进行本地化。 例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。      1> [!IMPORTANT]&1;> 者使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._204_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref double Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Double
      description: "必需。 从文件中读取变量分配值-不能为数组或对象变量。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  id: Input(System.Int32,System.Int16@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int16)
  nameWithType: FileSystem.Input(Int32,Int16)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "从打开的顺序文件中读取数据并将数据赋给变量。"
  remarks: "`Input`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/add/includes/ajax-current-ext-md.md)。       数据读取`Input`通过使用通常写入到文件`Write`。 此函数只能用于的文件在打开`Input`或`Binary`模式。      1> [!IMPORTANT]&1;> 时从文件读取，不要做出有关内容的基于文件扩展名的文件的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。       读取时，标准字符串或数值数据就赋给变量而不进行修改。 下表说明了如何处理其他输入的数据。      |||  |-|-|  |数据 |分配给变量的值 |  |分隔逗号或空白的行 |空 |  | #NULL #|`DBNull`|  | #TRUE # 或 #FALSE #|`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式所表示的时间 |  |#ERROR `errornumber` #| `errornumber` （变量是一个对象标记为错误） |      如果在输入数据项时达到文件末尾，输入已停止，则会出错。      1> [!NOTE]&1;>`Input`函数未进行本地化。 例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。      1> [!IMPORTANT]&1;> 者使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._81_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref short Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Int16
      description: "必需。 从文件中读取变量分配值-不能为数组或对象变量。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  id: Input(System.Int32,System.Int32@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int32)
  nameWithType: FileSystem.Input(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "从打开的顺序文件中读取数据并将数据赋给变量。"
  remarks: "`Input`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/add/includes/ajax-current-ext-md.md)。       数据读取`Input`通过使用通常写入到文件`Write`。 此函数只能用于的文件在打开`Input`或`Binary`模式。      1> [!IMPORTANT]&1;> 时从文件读取，不要做出有关内容的基于文件扩展名的文件的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。       读取时，标准字符串或数值数据就赋给变量而不进行修改。 下表说明了如何处理其他输入的数据。      |||  |-|-|  |数据 |分配给变量的值 |  |分隔逗号或空白的行 |空 |  | #NULL #|`DBNull`|  | #TRUE # 或 #FALSE #|`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式所表示的时间 |  |#ERROR `errornumber` #| `errornumber` （变量是一个对象标记为错误） |      如果在输入数据项时达到文件末尾，输入已停止，则会出错。      1> [!NOTE]&1;>`Input`函数未进行本地化。 例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号被视为变量分隔符而不是作为小数点。      1> [!IMPORTANT]&1;> 者使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._207_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref int Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Int32
      description: "必需。 从文件中读取变量分配值-不能为数组或对象变量。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  id: Input(System.Int32,System.Int64@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int64)
  nameWithType: FileSystem.Input(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "从打开的顺序文件中读取数据并将数据赋给变量。"
  remarks: "`Input`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/add/includes/ajax-current-ext-md.md)。       数据读取`Input`通过使用通常写入到文件`Write`。 此函数只能用于的文件在打开`Input`或`Binary`模式。      1> [!IMPORTANT]&1;> 时从文件读取，不要做出有关内容的基于文件扩展名的文件的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。       读取时，标准字符串或数值数据就赋给变量而不进行修改。 下表说明了如何处理其他输入的数据。      |||  |-|-|  |数据 |分配给变量的值 |  |分隔逗号或空白的行 |空 |  | #NULL #|`DBNull`|  | #TRUE # 或 #FALSE #|`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式所表示的时间 |  |#ERROR `errornumber` #| `errornumber` （变量是一个对象标记为错误） |      如果在输入数据项时达到文件末尾，输入已停止，则会出错。      1> [!NOTE]&1;>`Input`函数未进行本地化。 例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。      1> [!IMPORTANT]&1;> 者使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._31_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref long Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Int64
      description: "必需。 从文件中读取变量分配值-不能为数组或对象变量。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  id: Input(System.Int32,System.Object@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Object)
  nameWithType: FileSystem.Input(Int32,Object)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Object)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "从打开的顺序文件中读取数据并将数据赋给变量。"
  remarks: "`Input`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/add/includes/ajax-current-ext-md.md)。       数据读取`Input`通过使用通常写入到文件`Write`。 此函数只能用于的文件在打开`Input`或`Binary`模式。      1> [!IMPORTANT]&1;> 时从文件读取，不要做出有关内容的基于文件扩展名的文件的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。       读取时，标准字符串或数值数据就赋给变量而不进行修改。 下表说明了如何处理其他输入的数据。      |||  |-|-|  |数据 |分配给变量的值 |  |分隔逗号或空白的行 |空 |  | #NULL #|`DBNull`|  | #TRUE # 或 #FALSE #|`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式所表示的时间 |  |#ERROR `errornumber` #| `errornumber` （变量是一个对象标记为错误） |      如果在输入数据项时达到文件末尾，输入已停止，则会出错。      1> [!NOTE]&1;>`Input`函数未进行本地化。 例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。      1> [!IMPORTANT]&1;> 者使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._244_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref object Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Object
      description: "必需。 从文件中读取变量分配值-不能为数组或对象变量。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  id: Input(System.Int32,System.Single@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Single)
  nameWithType: FileSystem.Input(Int32,Single)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Single)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "从打开的顺序文件中读取数据并将数据赋给变量。"
  remarks: "`Input`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/add/includes/ajax-current-ext-md.md)。       数据读取`Input`通过使用通常写入到文件`Write`。 此函数只能用于的文件在打开`Input`或`Binary`模式。      1> [!IMPORTANT]&1;> 时从文件读取，不要做出有关内容的基于文件扩展名的文件的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。       读取时，标准字符串或数值数据就赋给变量而不进行修改。 下表说明了如何处理其他输入的数据。      |||  |-|-|  |数据 |分配给变量的值 |  |分隔逗号或空白的行 |空 |  | #NULL #|`DBNull`|  | #TRUE # 或 #FALSE #|`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式所表示的时间 |  |#ERROR `errornumber` #| `errornumber` （变量是一个对象标记为错误） |      如果在输入数据项时达到文件末尾，输入已停止，则会出错。      1> [!NOTE]&1;>`Input`函数未进行本地化。 例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。      1> [!IMPORTANT]&1;> 者使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._115_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref float Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.Single
      description: "必需。 从文件中读取变量分配值-不能为数组或对象变量。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  id: Input(System.Int32,System.String@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,String)
  nameWithType: FileSystem.Input(Int32,String)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "从打开的顺序文件中读取数据并将数据赋给变量。"
  remarks: "`Input`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/add/includes/ajax-current-ext-md.md)。       数据读取`Input`通过使用通常写入到文件`Write`。 此函数只能用于的文件在打开`Input`或`Binary`模式。      1> [!IMPORTANT]&1;> 时从文件读取，不要做出有关内容的基于文件扩展名的文件的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。       读取时，标准字符串或数值数据就赋给变量而不进行修改。 下表说明了如何处理其他输入的数据。      |||  |-|-|  |数据 |分配给变量的值 |  |分隔逗号或空白的行 |空 |  | #NULL #|`DBNull`|  | #TRUE # 或 #FALSE #|`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式所表示的时间 |  |#ERROR `errornumber` #| `errornumber` （变量是一个对象标记为错误） |      如果在输入数据项时达到文件末尾，输入已停止，则会出错。      1> [!NOTE]&1;>`Input`函数未进行本地化。 例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。      1> [!IMPORTANT]&1;> 者使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._140_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref string Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Value
      type: System.String
      description: "必需。 从文件中读取变量分配值-不能为数组或对象变量。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  id: InputString(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: InputString(Int32,Int32)
  nameWithType: FileSystem.InputString(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.InputString(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "返回<xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>包含文件中的字符的值在中打开<xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;></xref>模式。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_InputString&quot; name=&quot;InputString&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`InputString`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/add/includes/ajax-current-ext-md.md)。       数据读取`InputString`函数通常通过使用写入到文件`Print`或`FilePut`。 此函数只能用于的文件在打开`Input`或`Binary`模式。       与不同`Input`函数，`InputString`函数返回它所读取的所有字符。 这包括逗号、 回车、 换行符、 引号引起来和前导空格。       打开以进行文件与`Binary`访问，请尝试使用读取通过文件`InputString`函数直到`EOF`返回`True`生成错误。 使用`LOF`和`Loc`函数而不是`EOF`时通过使用读取二进制文件`InputString`，或使用`FileGet`当你使用`EOF`函数。      1> [!NOTE]&1;> 时从文件读取，不要做出有关内容的基于文件扩展名的文件的安全决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。"
  example:
  - "This example uses the `InputString` function to read one character at a time from a file and print it to the `Output` window. This example assumes that `MyFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#33](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._220_1.vb)]"
  syntax:
    content: public static string InputString (int FileNumber, int CharCount);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: CharCount
      type: System.Int32
      description: "必需。 任何有效的数值表达式，用于指定要读取的字符数。"
    return:
      type: System.String
      description: "返回<xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>包含文件中的字符的值在中打开<xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;></xref>模式。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_InputString&quot; name=&quot;InputString&quot; href=&quot;&quot;> </xref>。"
  overload: Microsoft.VisualBasic.FileSystem.InputString*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>不存在。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>CharCount</code>&lt; 0 or &gt; 214."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Kill(System.String)
  id: Kill(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Kill(String)
  nameWithType: FileSystem.Kill(String)
  fullName: Microsoft.VisualBasic.FileSystem.Kill(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "从磁盘中删除文件。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_Kill&quot; name=&quot;Kill&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> 。"
  remarks: "`Kill`支持使用多个字符 (`*`) 和单字符 (`?`) 通配符来指定多个文件。       **安全说明**才能执行，`Kill`函数需要`Read`和`PathDiscovery`标志<xref:System.Security.Permissions.FileIOPermission>才能被授予对执行代码。</xref:System.Security.Permissions.FileIOPermission> 有关详细信息，请参阅<xref:System.Security.SecurityException>[代码访问权限](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)</xref:System.Security.SecurityException>"
  example:
  - "This example uses the `Kill` function to delete a file from a disk.  \n  \n [!code-vb[VbVbalrCatRef#60](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._250_1.vb)]"
  syntax:
    content: public static void Kill (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "必需。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>指定要删除的一个或多个文件名称的表达式。 `PathName`可以包含目录或驱动器和文件夹。"
  overload: Microsoft.VisualBasic.FileSystem.Kill*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "目标文件打开。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到的目标文件。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "权限被拒绝。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  id: LineInput(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: LineInput(Int32)
  nameWithType: FileSystem.LineInput(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LineInput(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "从打开的顺序文件中读取单个行，并将它分配给<xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>变量。"
  remarks: "`LineInput`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/add/includes/ajax-current-ext-md.md)。       数据读取`LineInput`通过使用通常写入到文件`Print`。      1> [!IMPORTANT]&1;> 时从文件读取，不要做出有关内容的基于文件扩展名的文件的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。       `LineInput`函数一次直到它遇到一个回车读取从文件的一个字符 (`Chr(`13`)`) 或回车/换行 (`Chr(`13`)` + `Chr(`10`)`) 序列。 回车符/换行符源的序列将跳过而不是追加到字符字符串。      1> [!IMPORTANT]&1;> 者使用从文件读取`LineInput`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `LineInput` function to read a line from a sequential file and assign it to a variable. This example assumes that `TestFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#19](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._158_1.vb)]"
  syntax:
    content: public static string LineInput (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    return:
      type: System.String
      description: "从打开的顺序文件中读取单个行，并将它分配给<xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>变量。"
  overload: Microsoft.VisualBasic.FileSystem.LineInput*
  exceptions:
  - type: System.IO.EndOfStreamException
    commentId: T:System.IO.EndOfStreamException
    description: "已到达文件尾。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>不存在。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  id: Loc(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Loc(Int32)
  nameWithType: FileSystem.Loc(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Loc(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "返回<xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;></xref>值，该值指定打开的文件中的当前读/写位置。"
  remarks: "`Loc`函数是从零开始; 使用它来检索文件中的第一个字节将返回 0。       `Loc`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/add/includes/ajax-current-ext-md.md)。       下面介绍每种文件访问模式的返回值: | | |  |-|-|  |模式 |返回值 |  |`Random`|读取或写入到文件的最后一个记录编号。 |  |`Sequential`|除以 128 文件中的当前字节位置。 但是，通过返回信息`Loc`为顺序文件不是使用也不需要。 |  |`Binary`|读取或写入的最后一个字节的位置。 |"
  example:
  - "This example uses the `Loc` function to return the current read/write position in an open file. This example assumes that `MyFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#17](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._178_1.vb)]"
  syntax:
    content: public static long Loc (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效<xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;></xref>文件数。"
    return:
      type: System.Int64
      description: "返回<xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;></xref>值，该值指定打开的文件中的当前读/写位置。"
  overload: Microsoft.VisualBasic.FileSystem.Loc*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  id: Lock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32)
  nameWithType: FileSystem.Lock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "通过使用打开的文件的全部或部分其他进程来控制访问<xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;></xref>函数。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;></xref>和<xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`Lock`和`Unlock`函数是在环境中使用其中多个进程可能需要访问同一文件。       `Lock`和`Unlock`函数始终成对使用。 自变量`Lock`和`Unlock`必须相同。       如果`Record`，或`FromRecord`和`ToRecord`是未提供，将被锁定整个文件。 如果`Record`单独指定单个记录将锁定/解锁。       如果已打开文件进行连续的输入或输出，`Lock`和`Unlock`影响整个文件，而不考虑指定的范围`FromRecord`和`ToRecord`。"
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._243_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  id: Lock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "通过使用打开的文件的全部或部分其他进程来控制访问<xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;></xref>函数。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;></xref>和<xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`Lock`和`Unlock`函数是在环境中使用其中多个进程可能需要访问同一文件。       `Lock`和`Unlock`函数始终成对使用。 自变量`Lock`和`Unlock`必须相同。       如果`Record`，或`FromRecord`和`ToRecord`是未提供，将被锁定整个文件。 如果`Record`单独指定单个记录将锁定/解锁。       如果已打开文件进行连续的输入或输出，`Lock`和`Unlock`影响整个文件，而不考虑指定的范围`FromRecord`和`ToRecord`。"
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._38_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber, long Record);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Record
      type: System.Int64
      description: "可选。 数的唯一记录或锁定或解锁的字节"
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  id: Lock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32,Int64,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "通过使用打开的文件的全部或部分其他进程来控制访问<xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;></xref>函数。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;></xref>和<xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`Lock`和`Unlock`函数是在环境中使用其中多个进程可能需要访问同一文件。       `Lock`和`Unlock`函数始终成对使用。 自变量`Lock`和`Unlock`必须相同。       如果`Record`，或`FromRecord`和`ToRecord`是未提供，将被锁定整个文件。 如果`Record`单独指定单个记录将锁定/解锁。       如果已打开文件进行连续的输入或输出，`Lock`和`Unlock`影响整个文件，而不考虑指定的范围`FromRecord`和`ToRecord`。"
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._116_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber, long FromRecord, long ToRecord);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: FromRecord
      type: System.Int64
      description: "可选。 第一个记录或锁定或解锁的字节数。"
    - id: ToRecord
      type: System.Int64
      description: "可选。 最后一个记录或锁定或解锁的字节数。"
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  id: LOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: LOF(Int32)
  nameWithType: FileSystem.LOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LOF(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "返回<xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;></xref>表示的大小，以字节为单位，文件的打开使用<xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;></xref>函数。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_LOF&quot; name=&quot;LOF&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "使用`FileLen`函数来获取未打开的文件的长度。"
  example:
  - "This example uses the `LOF` function to determine the size of an open file. This example assumes that `TestFile` is a text file that contains sample data.  \n  \n [!code-vb[VbVbalrCatRef#23](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._83_1.vb)]"
  syntax:
    content: public static long LOF (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref>包含有效的文件数。"
    return:
      type: System.Int64
      description: "返回<xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;></xref>表示的大小，以字节为单位，文件的打开使用<xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;></xref>函数。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_LOF&quot; name=&quot;LOF&quot; href=&quot;&quot;> </xref>。"
  overload: Microsoft.VisualBasic.FileSystem.LOF*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  id: MkDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: MkDir(String)
  nameWithType: FileSystem.MkDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.MkDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "创建一个新目录。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_MkDir&quot; name=&quot;MkDir&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory*>。</xref:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory*>"
  remarks: "此函数将创建一个新目录。"
  example:
  - "This example uses the `MkDir` function to create a directory. If the drive is not specified, the new directory is created on the current drive.  \n  \n [!code-vb[VbVbalrCatRef#38](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._246_1.vb)]"
  syntax:
    content: public static void MkDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "必需。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>标识要创建的目录的表达式。 `Path`可能包括驱动器。 如果未指定驱动器， <xref uid=&quot;langword_csharp_MkDir&quot; name=&quot;MkDir&quot; href=&quot;&quot;> </xref>当前的驱动器上创建新目录。"
  overload: Microsoft.VisualBasic.FileSystem.MkDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>未指定或为空。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "权限被拒绝。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "目录已存在。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  id: Print(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Print(Int32,Object[])
  nameWithType: FileSystem.Print(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Print(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "将显示格式的数据写入顺序文件。"
  remarks: "`Print`和`PrintLine`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/add/includes/ajax-current-ext-md.md)。       `Print`不包括换行符末尾的换行符。但是，`PrintLine`包括换行符。       数据使用编写`Print`从文件通常通过使用读取`LineInput`或`Input`。       如果省略`Output`为`PrintLine`，该文件; 有关打印一个空行`Print`，没有输出。 将在选项卡上边界，但混合使用逗号上对齐多个以逗号分隔的表达式和`TAB`可能会导致不一致的结果。       有关`Boolean`数据，`True`或`False`打印。 `True`和`False`无论区域设置如何，都不翻译关键字。       日期数据写入文件，通过使用你的系统所识别的标准短日期格式。 时的日期或时间组件缺失或为零时，仅提供部分是写入文件。       执行任何操作写入文件，如果`Output`数据为空。 但是，如果`Output`列表数据是`DBNull`，`Null`写入到文件。       有关`Error`数据，输出将显示为`Error errorcode`。 `Error`关键字不会进行转换而不考虑区域设置。       通过使用写入到文件的所有数据`Print`是国际通用的; 即，数据的格式正确使用适当的小数分隔符。 如果用户想要输出以供多个区域设置中，数据`Write`应使用。       通过使用对文件进行写入`Print`或`PrintLine`函数需要`Write`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Print` and `PrintLine` functions to write data to a file.  \n  \n [!code-vb[VbVbalrCatRef#53](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._146_1.vb)]"
  syntax:
    content: public static void Print (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Output
      type: System.Object[]
      description: "可选。 零个或多个以逗号分隔表达式以写入到的文件。       `Output`自变量设置不︰ <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;> </xref>︰ 文件模式无效。       <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;></xref>:`FileNumber`不存在。"
  overload: Microsoft.VisualBasic.FileSystem.Print*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  id: PrintLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: PrintLine(Int32,Object[])
  nameWithType: FileSystem.PrintLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.PrintLine(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "将显示格式的数据写入顺序文件。"
  remarks: "`Print`和`PrintLine`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/add/includes/ajax-current-ext-md.md)。       `Print`不包括换行符末尾的换行符。但是，`PrintLine`包括换行符。       数据使用编写`Print`从文件通常通过使用读取`LineInput`或`Input`。       如果省略`Output`为`PrintLine`，该文件; 有关打印一个空行`Print`，没有输出。 将在选项卡上边界，但混合使用逗号上对齐多个以逗号分隔的表达式和`TAB`可能会导致不一致的结果。       有关`Boolean`数据，`True`或`False`打印。 `True`和`False`无论区域设置如何，都不翻译关键字。       日期数据写入文件，通过使用系统所识别的标准短日期格式。 时的日期或时间组件缺失或为零时，仅提供部分是写入文件。       执行任何操作写入文件，如果`Output`数据为空。 但是，如果`Output`列表数据是`DBNull`，`Null`写入到文件。       有关`Error`数据，输出将显示为`Error errorcode`。 `Error`关键字不会进行转换而不考虑区域设置。       通过使用写入到文件的所有数据`Print`是国际通用的; 即，数据的格式正确使用适当的小数分隔符。 如果用户想要输出以供多个区域设置中，数据`Write`应使用。       通过使用对文件进行写入`Print`或`PrintLine`函数需要`Write`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Print` and `PrintLine` functions to write data to a file.  \n  \n [!code-vb[VbVbalrCatRef#53](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._245_1.vb)]"
  syntax:
    content: public static void PrintLine (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Output
      type: System.Object[]
      description: "可选。 零个或多个以逗号分隔表达式以写入到的文件。       `Output`自变量设置不︰ <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;> </xref>︰ 文件模式无效。       <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;></xref>:`FileNumber`不存在。"
  overload: Microsoft.VisualBasic.FileSystem.PrintLine*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  id: Rename(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Rename(String,String)
  nameWithType: FileSystem.Rename(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.Rename(String,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "重命名的磁盘文件或目录。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_Rename&quot; name=&quot;Rename&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`Rename`函数重命名文件，并将其移动到不同的目录，如有必要。 `Rename`函数可以将文件移个驱动器，但它仅可以重命名现有目录时同时`NewPath`和`OldPath`位于相同的驱动器上。 `Rename`无法创建新文件或目录。       使用`Rename`函数对打开的文件产生错误。 重命名它前，必须先关闭打开的文件。 `Rename`自变量不能包含多个字符 （*） 和单字符 （？） 通配符。      1> [!IMPORTANT]&1;> 时使用`Rename`以将文件从受保护的位置复制到受保护的位置，该文件，仍保持较低的限制的权限。 请检查以确保没有引入可能的安全风险。"
  example:
  - "This example uses the `Rename` function to rename a file. For purposes of this example, assume that the directories that are specified already exist.  \n  \n [!code-vb[VbVbalrCatRef#30](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._97_1.vb)]"
  syntax:
    content: public static void Rename (string OldPath, string NewPath);
    parameters:
    - id: OldPath
      type: System.String
      description: "必需。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>指定的现有文件名称和位置的表达式。 `OldPath`可能包括的目录和驱动器，该文件。"
    - id: NewPath
      type: System.String
      description: "必需。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>指定新文件名和位置的表达式。 `NewPath`可能包括的目标位置的目录和驱动器。 指定的文件名称`NewPath`不能存在。"
  overload: Microsoft.VisualBasic.FileSystem.Rename*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "路径无效。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>OldPath</code>文件不存在。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "无法重命名为不同的设备。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Reset
  id: Reset
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Reset()
  nameWithType: FileSystem.Reset()
  fullName: Microsoft.VisualBasic.FileSystem.Reset()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "关闭所有打开的磁盘文件使用<xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;></xref>函数。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_Reset&quot; name=&quot;Reset&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`Reset`函数关闭打开的所有活动文件`FileOpen`函数，并且具有相同的功能`FileClose()`不带任何参数。"
  example:
  - "This example uses the `Reset` function to close all open files and write the contents of all file buffers to disk. Note the use of the `Object` variable `FileNumber` as both a string and a number.  \n  \n [!code-vb[VbVbalrCatRef#12](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._117_1.vb)]"
  syntax:
    content: public static void Reset ();
    parameters: []
  overload: Microsoft.VisualBasic.FileSystem.Reset*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  id: RmDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: RmDir(String)
  nameWithType: FileSystem.RmDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.RmDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "删除现有的目录。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_RmDir&quot; name=&quot;RmDir&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory*>。</xref:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory*>"
  remarks: "如果你尝试使用，则会发生错误`RmDir`在包含文件的目录。 使用`Kill`函数以删除所有文件，然后尝试删除一个目录。"
  example:
  - "This example uses the `RmDir` function to remove an existing directory.  \n  \n [!code-vb[VbVbalrCatRef#31](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._20_1.vb)]"
  syntax:
    content: public static void RmDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "必需。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>标识目录或要删除的文件夹的表达式。 `Path`可以包含驱动器。 如果未指定驱动器， <xref uid=&quot;langword_csharp_RmDir&quot; name=&quot;RmDir&quot; href=&quot;&quot;> </xref>中删除当前的驱动器上的目录。"
  overload: Microsoft.VisualBasic.FileSystem.RmDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>未指定或为空。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "目标目录包含文件。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "目录不存在。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  id: Seek(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Seek(Int32)
  nameWithType: FileSystem.Seek(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "返回<xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;></xref>通过指定文件中的当前读/写位置打开<xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;></xref>函数或通过打开下, 一步的读/写操作的文件中的位置设置<xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;></xref>函数。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_Seek&quot; name=&quot;Seek&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`Seek`返回一个值介于 1 和 2,147,483,647 之间 (等效于 2 ^31-1) （含）。       下面介绍每种文件访问模式的返回值: | | |  |-|-|  |模式 |返回值 |  |`Random`|读取或写入的下一步记录号 |  |`Binary`, `Input`, `Output`, `Append`|下一步操作的发生的字节位置。 在文件中的第一个字节在位置 1，第二个字节在位置 2，依此类推。 |"
  example:
  - "This example uses the `Seek` function to return the current file position. The example assumes `TestFile` is a file that contains records of the structure `Record`.  \n  \n [!code-vb[VbVbalrCatRef#47](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_1.vb)]  \n  \n For files opened in `Random` mode, `Seek` returns the number of next record.  \n  \n [!code-vb[VbVbalrCatRef#48](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_2.vb)]  \n  \n For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#49](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_3.vb)]  \n  \n This example uses the `Seek` function to set the position for the next read or write in a file.  \n  \n For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#52](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_4.vb)]"
  syntax:
    content: public static long Seek (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref>包含有效的文件数。"
    return:
      type: System.Int64
      description: "返回<xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;></xref>通过指定文件中的当前读/写位置打开<xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;></xref>函数或通过打开下, 一步的读/写操作的文件中的位置设置<xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;></xref>函数。"
  overload: Microsoft.VisualBasic.FileSystem.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  id: Seek(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Seek(Int32,Int64)
  nameWithType: FileSystem.Seek(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "返回<xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;></xref>通过指定文件中的当前读/写位置打开<xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;></xref>函数或通过打开下, 一步的读/写操作的文件中的位置设置<xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;></xref>函数。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_Seek&quot; name=&quot;Seek&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`Seek`返回一个值介于 1 和 2,147,483,647 之间 (等效于 2 ^31-1) （含）。       下面介绍每种文件访问模式的返回值: | | |  |-|-|  |模式 |返回值 |  |`Random`|读取或写入的下一步记录号 |  |`Binary`, `Input`, `Output`, `Append`|下一步操作的发生的字节位置。 在文件中的第一个字节在位置 1，第二个字节在位置 2，依此类推。 |"
  example:
  - "This example uses the `Seek` function to return the current file position. The example assumes `TestFile` is a file that contains records of the structure `Record`.  \n  \n [!code-vb[VbVbalrCatRef#47](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_1.vb)]  \n  \n For files opened in `Random` mode, `Seek` returns the number of next record.  \n  \n [!code-vb[VbVbalrCatRef#48](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_2.vb)]  \n  \n For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#49](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_3.vb)]  \n  \n This example uses the `Seek` function to set the position for the next read or write in a file.  \n  \n For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#52](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_4.vb)]"
  syntax:
    content: public static void Seek (int FileNumber, long Position);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref>包含有效的文件数。"
    - id: Position
      type: System.Int64
      description: "必需。 1 – 2147483647，（含)，范围内的数字，用于指示下一个读/写操作的其中应发生。"
  overload: Microsoft.VisualBasic.FileSystem.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  id: SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: SetAttr(String,FileAttribute)
  nameWithType: FileSystem.SetAttr(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.SetAttr(String,FileAttribute)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "设置属性的文件信息。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_SetAttr&quot; name=&quot;SetAttr&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "如果您尝试设置打开的文件的属性，则会发生运行时错误。       `Attributes`参数枚举值如下: | | |  |-|-|-|  |值 |常量 |说明 |  |`Normal`|`vbNormal`|正常 （默认值）。 |  |`ReadOnly`|`vbReadOnly`|只读的。 |  |`Hidden`|`vbHidden`|隐藏。 |  |`System`|`vbSystem`|系统文件。 |  |`Volume`|`vbVolume`|卷标 |  |`Directory`|`vbDirectory`|目录或文件夹。 |  |`Archive`|`vbArchive`|文件自上次备份以来已更改。 |  |`Alias`|`vbAlias`|文件具有不同的名称。 |    &1;> [!NOTE]&1;> 这些枚举指定的 Visual Basic 语言。 名称可以使用而非实际值在代码中的任意位置。"
  example:
  - "This example uses the `SetAttr` function to set attributes for a file.  \n  \n [!code-vb[VbVbalrCatRef#14](~/add/codesnippet/visualbasic/7c37826d-7b37-4e2d-b69a-_1.vb)]"
  syntax:
    content: public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);
    parameters:
    - id: PathName
      type: System.String
      description: "必需。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>指定的文件名称的表达式。 `PathName`可以包含目录或文件夹和驱动器。"
    - id: Attributes
      type: Microsoft.VisualBasic.FileAttribute
      description: "必需。 常量或数值表达式，其值用于指定文件属性。"
  overload: Microsoft.VisualBasic.FileSystem.SetAttr*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Attribute</code>类型无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  id: SPC(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: SPC(Int16)
  nameWithType: FileSystem.SPC(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.SPC(Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "与使用<xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;></xref>函数来确定输出位置。"
  remarks: "如果`Count`小于输出线条宽度下, 一步打印位置立即遵循的打印的空格数。 如果`Count`大于输出线条宽度，`SPC`计算使用公式的下一步打印位置︰ `currentprintposition`(+ (`Count``Mod``width`)) 例如，如果打印当前位置为 24，输出行宽度为 80，并且你指定`SPC(`90`)`，则下一步打印将开始从位置 34 （打印当前位置 + 90/80 的余数）。 如果当前打印位置和输出线条宽度之间的区别在于小于`Count`(或`Count` `Mod` *宽度*)，则`SPC`函数将跳到下一步的行的开头，并生成空间等于`Count`– (*宽度*–*小于*)。      1> [!NOTE]&1;> 确保表格列的宽度足以容纳较宽的字母。"
  example:
  - "This example uses the `SPC` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#16](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._222_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.SpcInfo SPC (short Count);
    parameters:
    - id: Count
      type: System.Int16
      description: "必需。 要显示或打印列表中的下一步表达式之前插入的空格数。"
    return:
      type: Microsoft.VisualBasic.SpcInfo
      description: "与使用<xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;></xref>函数来确定输出位置。"
  overload: Microsoft.VisualBasic.FileSystem.SPC*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.TAB
  id: TAB
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: TAB()
  nameWithType: FileSystem.TAB()
  fullName: Microsoft.VisualBasic.FileSystem.TAB()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "与使用<xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;></xref>函数确定输出位置。"
  remarks: "如果在当前行的当前打印位置大于`Column`，`TAB`跳过为列的值等于`Column`下一步的输出行上。 如果`Column`小于 1，`TAB`将打印位置移动到第 1 列。 如果`Column`大于输出线条宽度，`TAB`计算使用公式的下一步打印位置︰ 列 Mod 宽度，例如，如果*宽度*是 80，并指定`TAB(`90`)`，则下一个打印将开始列 10 （90/80 的余数）。 如果`Column`小于当前打印位置，在下一行计算的输出位置的打印启动。 如果计算出的打印位置大于当前打印位置，打印开始计算在同一行上打印位置。       在输出行上的最左边打印位置始终为 1。 当你使用`Print`或`PrintLine`函数来打印到文件，最右边的打印位置是输出文件中，你可以使用设置的当前宽度`FileWidth`函数。       `TAB`函数还可用于`WriteLine`函数。 它不能使用<xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>或<xref:System.Console.WriteLine%2A?displayProperty=fullName>。</xref:System.Console.WriteLine%2A?displayProperty=fullName> </xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>      1> [!NOTE]&1;> 确保表格列的宽度足以包含较宽的字母。"
  example:
  - "This example uses the `TAB` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#37](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._165_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.TabInfo TAB ();
    parameters: []
    return:
      type: Microsoft.VisualBasic.TabInfo
      description: "与使用<xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;></xref>函数确定输出位置。"
  overload: Microsoft.VisualBasic.FileSystem.TAB*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  id: TAB(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: TAB(Int16)
  nameWithType: FileSystem.TAB(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.TAB(Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "与使用<xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;></xref>函数确定输出位置。"
  remarks: "如果在当前行的当前打印位置大于`Column`，`TAB`跳过为列的值等于`Column`下一步的输出行上。 如果`Column`小于 1，`TAB`将打印位置移动到第 1 列。 如果`Column`大于输出线条宽度，`TAB`计算使用公式的下一步打印位置︰ 列 Mod 宽度，例如，如果*宽度*是 80，并指定`TAB(`90`)`，则下一个打印将开始列 10 （90/80 的余数）。 如果`Column`小于当前打印位置，在下一行计算的输出位置的打印启动。 如果计算出的打印位置大于当前打印位置，打印开始计算在同一行上打印位置。       在输出行上的最左边打印位置始终为 1。 当你使用`Print`或`PrintLine`函数来打印到文件，最右边的打印位置是输出文件中，你可以使用设置的当前宽度`FileWidth`函数。       `TAB`函数还可用于`WriteLine`函数。 它不能使用<xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>或<xref:System.Console.WriteLine%2A?displayProperty=fullName>。</xref:System.Console.WriteLine%2A?displayProperty=fullName> </xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>      1> [!NOTE]&1;> 确保表格列的宽度足以包含较宽的字母。"
  example:
  - "This example uses the `TAB` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#37](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._125_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.TabInfo TAB (short Column);
    parameters:
    - id: Column
      type: System.Int16
      description: "可选。 显示或打印列表中的下一步表达式之前移动到的列号。 如果省略， <xref uid=&quot;langword_csharp_TAB&quot; name=&quot;TAB&quot; href=&quot;&quot;> </xref>将插入点移到下一步的打印区域的开始。"
    return:
      type: Microsoft.VisualBasic.TabInfo
      description: "与使用<xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;></xref>函数确定输出位置。"
  overload: Microsoft.VisualBasic.FileSystem.TAB*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  id: Unlock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32)
  nameWithType: FileSystem.Unlock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "通过使用打开的文件的全部或部分其他进程来控制访问<xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;></xref>函数。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;></xref>和<xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`Lock`和`Unlock`函数是在环境中使用其中多个进程可能需要访问同一文件。       `Lock`和`Unlock`函数始终成对使用。 自变量`Lock`和`Unlock`必须相同。       如果`Record`，或`FromRecord`和`ToRecord`是未提供，将被锁定整个文件。 如果`Record`单独指定单个记录将锁定/解锁。       如果已打开文件进行连续的输入或输出，`Lock`和`Unlock`影响整个文件，而不考虑指定的范围`FromRecord`和`ToRecord`。"
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._26_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  id: Unlock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "通过使用打开的文件的全部或部分其他进程来控制访问<xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;></xref>函数。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;></xref>和<xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`Lock`和`Unlock`函数是在环境中使用其中多个进程可能需要访问同一文件。       `Lock`和`Unlock`函数始终成对使用。 自变量`Lock`和`Unlock`必须相同。       如果`Record`，或`FromRecord`和`ToRecord`是未提供，将被锁定整个文件。 如果`Record`单独指定单个记录将锁定/解锁。       如果已打开文件进行连续的输入或输出，`Lock`和`Unlock`影响整个文件，而不考虑指定的范围`FromRecord`和`ToRecord`。"
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._210_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber, long Record);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: Record
      type: System.Int64
      description: "可选。 数的唯一记录或锁定或解锁的字节"
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  id: Unlock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32,Int64,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "通过使用打开的文件的全部或部分其他进程来控制访问<xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;></xref>函数。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能使你更好的工作效率和性能在文件 I/O 操作比<xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;></xref>和<xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`Lock`和`Unlock`函数是在环境中使用其中多个进程可能需要访问同一文件。       `Lock`和`Unlock`函数始终成对使用。 自变量`Lock`和`Unlock`必须相同。       如果`Record`，或`FromRecord`和`ToRecord`是未提供，将被锁定整个文件。 如果`Record`单独指定单个记录将锁定/解锁。       如果已打开文件进行连续的输入或输出，`Lock`和`Unlock`影响整个文件，而不考虑指定的范围`FromRecord`和`ToRecord`。"
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/93b8910d-5e06-4d09-8b8b-_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber, long FromRecord, long ToRecord);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 任何有效的文件数。"
    - id: FromRecord
      type: System.Int64
      description: "可选。 第一个记录或锁定或解锁的字节数。"
    - id: ToRecord
      type: System.Int64
      description: "可选。 最后一个记录或锁定或解锁的字节数。"
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  id: Write(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Write(Int32,Object[])
  nameWithType: FileSystem.Write(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Write(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "将数据写入顺序文件。 数据使用编写<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>从文件通常通过使用读取<xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref>。"
  remarks: "`Write`和`WriteLine`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/add/includes/ajax-current-ext-md.md)。       如果省略`Output`，向文件打印一个空行。 可以用逗号分隔多个表达式。       与不同`Print`函数，`Write`函数插入项与字符串周围的引号之间的逗号，按它们写入到文件的形式。 无需显式分隔符放入列表。 当`Write`用于将数据写入到文件中，仅数字`Boolean`，日期、 null 和`Error`支持数据格式。 下面的通用假设遵循这样的数据始终能够阅读和使用正确的解释`Input`，而不考虑区域设置:-数值写入数据时总是使用句点作为小数分隔符。      -为`Boolean`数据，`#TRUE#`或`#FALSE#`打印。 `True`和`False`无论区域设置如何，都不翻译关键字。      -日期数据写入到文件使用的通用日期格式。 时的日期或时间组件缺失或为零时，仅提供部分是写入文件。      -则不写入到文件，如果`Output`数据为空。 但是，对于 null 数据一样，`#NULL#`写入。      -为`Error`数据，输出将显示为`#ERROR errorcode#`。 `Error`不转换关键字，而不考虑区域设置。       `WriteLine`将插入一个换行符 (即回车符/换行符，或`Chr(13) + Chr(10)`)，在其写入的最后一个字符后`Output`文件。       可以在字符串中嵌入引号引起来通过使用双引号括起来，或&quot;&quot;。 例如， [!code-vb [VbVbalrCatRef&#63;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._145_1.vb) ]返回的值的字符串`Double quotation marks aren&quot;t &quot;difficult&quot; to handle`。       通过使用对文件进行写入`Write`或`WriteLine`函数需要`Append`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Write` function to write raw data to a sequential file.  \n  \n [!code-vb[VbVbalrCatRef#64](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._145_2.vb)]"
  syntax:
    content: public static void Write (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref>包含任何有效的文件数的表达式。"
    - id: Output
      type: System.Object[]
      description: "可选。 一个或多个以逗号分隔表达式以写入到的文件。"
  overload: Microsoft.VisualBasic.FileSystem.Write*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件模式无效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  id: WriteLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: WriteLine(Int32,Object[])
  nameWithType: FileSystem.WriteLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.WriteLine(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "将数据写入顺序文件。 数据使用编写<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>从文件通常通过使用读取<xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref>。"
  remarks: "`Write`和`WriteLine`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/add/includes/ajax-current-ext-md.md)。       如果省略`Output`，向文件打印一个空行。 可以用逗号分隔多个表达式。       与不同`Print`函数，`Write`函数插入项与字符串周围的引号之间的逗号，按它们写入到文件的形式。 无需显式分隔符放入列表。 当`Write`用于将数据写入到文件中，仅数字`Boolean`，日期、 null 和`Error`支持数据格式。 下面的通用假设遵循这样的数据始终能够阅读和使用正确的解释`Input`，而不考虑区域设置:-数值写入数据时总是使用句点作为小数分隔符。      -为`Boolean`数据，`#TRUE#`或`#FALSE#`打印。 `True`和`False`无论区域设置如何，都不翻译关键字。      -日期数据写入到文件使用的通用日期格式。 时的日期或时间组件缺失或为零时，仅提供部分是写入文件。      -则不写入到文件，如果`Output`数据为空。 但是，对于 null 数据一样，`#NULL#`写入。      -为`Error`数据，输出将显示为`#ERROR errorcode#`。 `Error`不转换关键字，而不考虑区域设置。       `WriteLine`将插入一个换行符 (即回车符/换行符，或`Chr(13) + Chr(10)`)，在其写入的最后一个字符后`Output`文件。       可以在字符串中嵌入引号引起来通过使用双引号括起来，或&quot;&quot;。 例如， [!code-vb [VbVbalrCatRef&#63;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._172_1.vb) ]返回的值的字符串`Double quotation marks aren&quot;t &quot;difficult&quot; to handle`。       通过使用对文件进行写入`Write`或`WriteLine`函数需要`Append`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Write` function to write raw data to a sequential file.  \n  \n [!code-vb[VbVbalrCatRef#64](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._172_2.vb)]"
  syntax:
    content: public static void WriteLine (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必需。 <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref>包含任何有效的文件数的表达式。"
    - id: Output
      type: System.Object[]
      description: "可选。 一个或多个以逗号分隔表达式以写入到的文件。"
  overload: Microsoft.VisualBasic.FileSystem.WriteLine*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.IO.EndOfStreamException
  isExternal: true
  name: System.IO.EndOfStreamException
- uid: Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDir(String)
  nameWithType: FileSystem.ChDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDir(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive(Char)
  nameWithType: FileSystem.ChDrive(Char)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(Char)
- uid: System.Char
  parent: System
  isExternal: true
  name: Char
  nameWithType: Char
  fullName: System.Char
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive(String)
  nameWithType: FileSystem.ChDrive(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(String)
- uid: Microsoft.VisualBasic.FileSystem.CurDir
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir()
  nameWithType: FileSystem.CurDir()
  fullName: Microsoft.VisualBasic.FileSystem.CurDir()
- uid: Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir(Char)
  nameWithType: FileSystem.CurDir(Char)
  fullName: Microsoft.VisualBasic.FileSystem.CurDir(Char)
- uid: Microsoft.VisualBasic.FileSystem.Dir
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir()
  nameWithType: FileSystem.Dir()
  fullName: Microsoft.VisualBasic.FileSystem.Dir()
- uid: Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir(String,FileAttribute)
  nameWithType: FileSystem.Dir(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.Dir(String,FileAttribute)
- uid: Microsoft.VisualBasic.FileAttribute
  parent: Microsoft.VisualBasic
  isExternal: false
  name: FileAttribute
  nameWithType: FileAttribute
  fullName: Microsoft.VisualBasic.FileAttribute
- uid: Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: EOF(Int32)
  nameWithType: FileSystem.EOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.EOF(Int32)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileAttr(Int32)
  nameWithType: FileSystem.FileAttr(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileAttr(Int32)
- uid: Microsoft.VisualBasic.OpenMode
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenMode
  nameWithType: OpenMode
  fullName: Microsoft.VisualBasic.OpenMode
- uid: Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileClose(Int32[])
  nameWithType: FileSystem.FileClose(Int32[])
  fullName: Microsoft.VisualBasic.FileSystem.FileClose(Int32[])
- uid: System.Int32[]
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32[]
  spec.csharp:
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileCopy(String,String)
  nameWithType: FileSystem.FileCopy(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.FileCopy(String,String)
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileDateTime(String)
  nameWithType: FileSystem.FileDateTime(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileDateTime(String)
- uid: System.DateTime
  parent: System
  isExternal: true
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Boolean,Int64)
  nameWithType: FileSystem.FileGet(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Boolean,Int64)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Byte,Int64)
  nameWithType: FileSystem.FileGet(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Byte,Int64)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Char,Int64)
  nameWithType: FileSystem.FileGet(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Char,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,DateTime,Int64)
  nameWithType: FileSystem.FileGet(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,DateTime,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Decimal,Int64)
  nameWithType: FileSystem.FileGet(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Decimal,Int64)
- uid: System.Decimal
  parent: System
  isExternal: true
  name: Decimal
  nameWithType: Decimal
  fullName: System.Decimal
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Double,Int64)
  nameWithType: FileSystem.FileGet(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Double,Int64)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int16,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int16,Int64)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int32,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int64,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Single,Int64)
  nameWithType: FileSystem.FileGet(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Single,Int64)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,ValueType,Int64)
  nameWithType: FileSystem.FileGet(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,ValueType,Int64)
- uid: System.ValueType
  parent: System
  isExternal: true
  name: ValueType
  nameWithType: ValueType
  fullName: System.ValueType
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FileGet(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,String,Int64,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGetObject(Int32,Object,Int64)
  nameWithType: FileSystem.FileGetObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGetObject(Int32,Object,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileLen(String)
  nameWithType: FileSystem.FileLen(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileLen(String)
- uid: Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  nameWithType: FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
- uid: Microsoft.VisualBasic.OpenAccess
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenAccess
  nameWithType: OpenAccess
  fullName: Microsoft.VisualBasic.OpenAccess
- uid: Microsoft.VisualBasic.OpenShare
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenShare
  nameWithType: OpenShare
  fullName: Microsoft.VisualBasic.OpenShare
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Boolean,Int64)
  nameWithType: FileSystem.FilePut(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Boolean,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Byte,Int64)
  nameWithType: FileSystem.FilePut(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Byte,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Char,Int64)
  nameWithType: FileSystem.FilePut(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Char,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,DateTime,Int64)
  nameWithType: FileSystem.FilePut(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,DateTime,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Decimal,Int64)
  nameWithType: FileSystem.FilePut(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Decimal,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Double,Int64)
  nameWithType: FileSystem.FilePut(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Double,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int16,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int16,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int32,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int64,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Single,Int64)
  nameWithType: FileSystem.FilePut(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Single,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,ValueType,Int64)
  nameWithType: FileSystem.FilePut(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,ValueType,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Object,Object,Object)
  nameWithType: FileSystem.FilePut(Object,Object,Object)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Object,Object,Object)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FilePut(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,String,Int64,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePutObject(Int32,Object,Int64)
  nameWithType: FileSystem.FilePutObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePutObject(Int32,Object,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileWidth(Int32,Int32)
  nameWithType: FileSystem.FileWidth(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileWidth(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.FreeFile
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FreeFile()
  nameWithType: FileSystem.FreeFile()
  fullName: Microsoft.VisualBasic.FileSystem.FreeFile()
- uid: Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: GetAttr(String)
  nameWithType: FileSystem.GetAttr(String)
  fullName: Microsoft.VisualBasic.FileSystem.GetAttr(String)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Boolean)
  nameWithType: FileSystem.Input(Int32,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Byte)
  nameWithType: FileSystem.Input(Int32,Byte)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Byte)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Char)
  nameWithType: FileSystem.Input(Int32,Char)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Char)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,DateTime)
  nameWithType: FileSystem.Input(Int32,DateTime)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,DateTime)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Decimal)
  nameWithType: FileSystem.Input(Int32,Decimal)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Decimal)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Double)
  nameWithType: FileSystem.Input(Int32,Double)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Double)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int16)
  nameWithType: FileSystem.Input(Int32,Int16)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int16)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int32)
  nameWithType: FileSystem.Input(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int64)
  nameWithType: FileSystem.Input(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Object)
  nameWithType: FileSystem.Input(Int32,Object)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Object)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Single)
  nameWithType: FileSystem.Input(Int32,Single)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Single)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,String)
  nameWithType: FileSystem.Input(Int32,String)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,String)
- uid: Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: InputString(Int32,Int32)
  nameWithType: FileSystem.InputString(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.InputString(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.Kill(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Kill(String)
  nameWithType: FileSystem.Kill(String)
  fullName: Microsoft.VisualBasic.FileSystem.Kill(String)
- uid: Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LineInput(Int32)
  nameWithType: FileSystem.LineInput(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LineInput(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Loc(Int32)
  nameWithType: FileSystem.Loc(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Loc(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32)
  nameWithType: FileSystem.Lock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32,Int64,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LOF(Int32)
  nameWithType: FileSystem.LOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LOF(Int32)
- uid: Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: MkDir(String)
  nameWithType: FileSystem.MkDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.MkDir(String)
- uid: Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Print(Int32,Object[])
  nameWithType: FileSystem.Print(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Print(Int32,Object[])
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: PrintLine(Int32,Object[])
  nameWithType: FileSystem.PrintLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.PrintLine(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Rename(String,String)
  nameWithType: FileSystem.Rename(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.Rename(String,String)
- uid: Microsoft.VisualBasic.FileSystem.Reset
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Reset()
  nameWithType: FileSystem.Reset()
  fullName: Microsoft.VisualBasic.FileSystem.Reset()
- uid: Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: RmDir(String)
  nameWithType: FileSystem.RmDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.RmDir(String)
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek(Int32)
  nameWithType: FileSystem.Seek(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek(Int32,Int64)
  nameWithType: FileSystem.Seek(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SetAttr(String,FileAttribute)
  nameWithType: FileSystem.SetAttr(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.SetAttr(String,FileAttribute)
- uid: Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SPC(Int16)
  nameWithType: FileSystem.SPC(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.SPC(Int16)
- uid: Microsoft.VisualBasic.SpcInfo
  parent: Microsoft.VisualBasic
  isExternal: false
  name: SpcInfo
  nameWithType: SpcInfo
  fullName: Microsoft.VisualBasic.SpcInfo
- uid: Microsoft.VisualBasic.FileSystem.TAB
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB()
  nameWithType: FileSystem.TAB()
  fullName: Microsoft.VisualBasic.FileSystem.TAB()
- uid: Microsoft.VisualBasic.TabInfo
  parent: Microsoft.VisualBasic
  isExternal: false
  name: TabInfo
  nameWithType: TabInfo
  fullName: Microsoft.VisualBasic.TabInfo
- uid: Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB(Int16)
  nameWithType: FileSystem.TAB(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.TAB(Int16)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32)
  nameWithType: FileSystem.Unlock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32,Int64,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Write(Int32,Object[])
  nameWithType: FileSystem.Write(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Write(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: WriteLine(Int32,Object[])
  nameWithType: FileSystem.WriteLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.WriteLine(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.ChDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDir
  nameWithType: FileSystem.ChDir
- uid: Microsoft.VisualBasic.FileSystem.ChDrive*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive
  nameWithType: FileSystem.ChDrive
- uid: Microsoft.VisualBasic.FileSystem.CurDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir
  nameWithType: FileSystem.CurDir
- uid: Microsoft.VisualBasic.FileSystem.Dir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir
  nameWithType: FileSystem.Dir
- uid: Microsoft.VisualBasic.FileSystem.EOF*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: EOF
  nameWithType: FileSystem.EOF
- uid: Microsoft.VisualBasic.FileSystem.FileAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileAttr
  nameWithType: FileSystem.FileAttr
- uid: Microsoft.VisualBasic.FileSystem.FileClose*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileClose
  nameWithType: FileSystem.FileClose
- uid: Microsoft.VisualBasic.FileSystem.FileCopy*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileCopy
  nameWithType: FileSystem.FileCopy
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileDateTime
  nameWithType: FileSystem.FileDateTime
- uid: Microsoft.VisualBasic.FileSystem.FileGet*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet
  nameWithType: FileSystem.FileGet
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGetObject
  nameWithType: FileSystem.FileGetObject
- uid: Microsoft.VisualBasic.FileSystem.FileLen*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileLen
  nameWithType: FileSystem.FileLen
- uid: Microsoft.VisualBasic.FileSystem.FileOpen*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileOpen
  nameWithType: FileSystem.FileOpen
- uid: Microsoft.VisualBasic.FileSystem.FilePut*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut
  nameWithType: FileSystem.FilePut
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePutObject
  nameWithType: FileSystem.FilePutObject
- uid: Microsoft.VisualBasic.FileSystem.FileWidth*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileWidth
  nameWithType: FileSystem.FileWidth
- uid: Microsoft.VisualBasic.FileSystem.FreeFile*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FreeFile
  nameWithType: FileSystem.FreeFile
- uid: Microsoft.VisualBasic.FileSystem.GetAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: GetAttr
  nameWithType: FileSystem.GetAttr
- uid: Microsoft.VisualBasic.FileSystem.Input*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input
  nameWithType: FileSystem.Input
- uid: Microsoft.VisualBasic.FileSystem.InputString*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: InputString
  nameWithType: FileSystem.InputString
- uid: Microsoft.VisualBasic.FileSystem.Kill*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Kill
  nameWithType: FileSystem.Kill
- uid: Microsoft.VisualBasic.FileSystem.LineInput*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LineInput
  nameWithType: FileSystem.LineInput
- uid: Microsoft.VisualBasic.FileSystem.Loc*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Loc
  nameWithType: FileSystem.Loc
- uid: Microsoft.VisualBasic.FileSystem.Lock*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock
  nameWithType: FileSystem.Lock
- uid: Microsoft.VisualBasic.FileSystem.LOF*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LOF
  nameWithType: FileSystem.LOF
- uid: Microsoft.VisualBasic.FileSystem.MkDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: MkDir
  nameWithType: FileSystem.MkDir
- uid: Microsoft.VisualBasic.FileSystem.Print*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Print
  nameWithType: FileSystem.Print
- uid: Microsoft.VisualBasic.FileSystem.PrintLine*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: PrintLine
  nameWithType: FileSystem.PrintLine
- uid: Microsoft.VisualBasic.FileSystem.Rename*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Rename
  nameWithType: FileSystem.Rename
- uid: Microsoft.VisualBasic.FileSystem.Reset*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Reset
  nameWithType: FileSystem.Reset
- uid: Microsoft.VisualBasic.FileSystem.RmDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: RmDir
  nameWithType: FileSystem.RmDir
- uid: Microsoft.VisualBasic.FileSystem.Seek*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek
  nameWithType: FileSystem.Seek
- uid: Microsoft.VisualBasic.FileSystem.SetAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SetAttr
  nameWithType: FileSystem.SetAttr
- uid: Microsoft.VisualBasic.FileSystem.SPC*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SPC
  nameWithType: FileSystem.SPC
- uid: Microsoft.VisualBasic.FileSystem.TAB*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB
  nameWithType: FileSystem.TAB
- uid: Microsoft.VisualBasic.FileSystem.Unlock*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock
  nameWithType: FileSystem.Unlock
- uid: Microsoft.VisualBasic.FileSystem.Write*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Write
  nameWithType: FileSystem.Write
- uid: Microsoft.VisualBasic.FileSystem.WriteLine*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: WriteLine
  nameWithType: FileSystem.WriteLine
