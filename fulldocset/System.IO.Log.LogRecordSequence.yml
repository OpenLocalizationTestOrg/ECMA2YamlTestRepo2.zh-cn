### YamlMime:ManagedReference
items:
- uid: System.IO.Log.LogRecordSequence
  id: LogRecordSequence
  children:
  - System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)
  - System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)
  - System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.LogRecordSequence.BaseSequenceNumber
  - System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.CreateReservationCollection
  - System.IO.Log.LogRecordSequence.Dispose
  - System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.Flush
  - System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.LastSequenceNumber
  - System.IO.Log.LogRecordSequence.LogStore
  - System.IO.Log.LogRecordSequence.MaximumRecordLength
  - System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  - System.IO.Log.LogRecordSequence.ReadRestartAreas
  - System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.LogRecordSequence.ReservedBytes
  - System.IO.Log.LogRecordSequence.RestartSequenceNumber
  - System.IO.Log.LogRecordSequence.RetryAppend
  - System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.TailPinned
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  langs:
  - csharp
  name: LogRecordSequence
  nameWithType: LogRecordSequence
  fullName: System.IO.Log.LogRecordSequence
  type: Class
  summary: "表示存储在一个记录序列<xref href=&quot;System.IO.Log.LogStore&quot;> </xref>。"
  remarks: "LogRecordSequence 类提供记录序列接口在公用日志文件系统 (CLFS) 日志之上的实现。 除了标准的面向记录的功能，它为避免出现日志已满的情况和多路复用的同一个物理文件上的客户端提供了一个策略模型。 适用于<xref:System.IO.Log.LogStore>类，该类提供了一个接口，直接操作和管理 CLFS 日志文件。</xref:System.IO.Log.LogStore> 之间的关系<xref:System.IO.Log.LogStore>类和 LogRecordSequence 类是类似于磁盘文件之间的关系和<xref:System.IO.FileStream>对象。</xref:System.IO.FileStream> </xref:System.IO.Log.LogStore> 磁盘文件提供了具体的存储，并具有诸如长度和上次访问时间; 的属性<xref:System.IO.FileStream>对象提供对可用来读取和写入它。 该文件的视图</xref:System.IO.FileStream>时 同样，<xref:System.IO.Log.LogStore>类具有策略和磁盘范围; 集合等属性和 LogRecordSequence 类提供面向记录的机制，用于读取和写入数据。</xref:System.IO.Log.LogStore>"
  example:
  - "This example shows how to use the LogRecordSequence class:  \n  \n [!code-cs[S_UELogRecordSequence#0](~/add/codesnippet/csharp/t-system.io.log.logrecor_1.cs)]\n [!code-vb[S_UELogRecordSequence#0](~/add/codesnippet/visualbasic/t-system.io.log.logrecor_1.vb)]"
  syntax:
    content: 'public sealed class LogRecordSequence : IDisposable, System.IO.Log.IRecordSequence'
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  - System.IO.Log.IRecordSequence
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)
  id: '#ctor(System.IO.Log.LogStore)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(LogStore)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "初始化的新实例<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>与指定的日志存储区的类。"
  remarks: "缓冲区大小确定了可追加或读取的记录的最大大小。 在此构造函数，设置默认值为 64。 所需的缓冲区数设置为 10。"
  syntax:
    content: public LogRecordSequence (System.IO.Log.LogStore logStore);
    parameters:
    - id: logStore
      type: System.IO.Log.LogStore
      description: "<xref href=&quot;System.IO.Log.LogStore&quot;> </xref>此记录序列应使用。"
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>logStore</code>是无效的。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)
  id: '#ctor(System.String,System.IO.FileMode)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "初始化的新实例<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>使用指定路径的日志存储区和访问模式的类。"
  remarks: "此构造函数初始化新<xref:System.IO.Log.LogRecordSequence>上的新<xref:System.IO.Log.LogStore>它以指定的路径和模式打开的对象。</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogRecordSequence> 它授予对应用商店中，读/写访问权限和共享读访问权限打开的存储。"
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode);
    parameters:
    - id: path
      type: System.String
      description: "要打开的日志存储区的基文件相对或绝对路径。"
    - id: mode
      type: System.IO.FileMode
      description: "之一<xref href=&quot;System.IO.FileMode&quot;></xref>确定如何打开或创建存储的值。"
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>为空字符串 (&quot;&quot;)。       -或-<code>path</code>仅包含空格。       -或-<code>path</code>包含一个或多个无效字符。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>包含无效值。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到该文件。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "打开日志存储区时发生了 I/O 错误。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "不支持此操作。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>无法使用，因为未安装所需的公用日志文件系统 (CLFS) 组件。 如果它不用于你的平台安装 CLFS 组件，或者使用<xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>类。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)
  id: '#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(LogStore,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "初始化的新实例<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>类与指定的日志存储区，每个记录的缓冲区大小以及缓冲区数量。"
  remarks: "使用此构造函数，如果你想要为指定值`bufferSize`和`bufferCount`并且不希望使用默认值为 64 个`bufferSize`10 `bufferCount`。"
  syntax:
    content: public LogRecordSequence (System.IO.Log.LogStore logStore, int bufferSize, int bufferCount);
    parameters:
    - id: logStore
      type: System.IO.Log.LogStore
      description: "<xref href=&quot;System.IO.Log.LogStore&quot;> </xref>此记录序列应使用。"
    - id: bufferSize
      type: System.Int32
      description: "所需的缓冲区大小 （字节）。 缓冲区大小确定了可追加或读取的记录的最大大小。"
    - id: bufferCount
      type: System.Int32
      description: "所需的缓冲区数。"
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>logStore</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize </code>为负数或零。       -或-<code>bufferCount</code>为负数或零。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "初始化的新实例<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>使用指定路径的日志存储区以及访问和共享模式的类。"
  remarks: "此构造函数初始化新<xref:System.IO.Log.LogRecordSequence>上的新<xref:System.IO.Log.LogStore>它以指定的路径、 模式和访问权限打开的对象。</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogRecordSequence> 共享读访问权限打开的存储。"
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access);
    parameters:
    - id: path
      type: System.String
      description: "要打开的日志存储区的基文件相对或绝对路径。"
    - id: mode
      type: System.IO.FileMode
      description: "之一<xref href=&quot;System.IO.FileMode&quot;></xref>确定如何打开或创建存储的值。"
    - id: access
      type: System.IO.FileAccess
      description: "之一<xref href=&quot;System.IO.FileAccess&quot;></xref>确定如何通过访问文件的值<xref href=&quot;System.IO.Log.LogStore&quot;> </xref>。"
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>为空字符串 (&quot;&quot;)。       -或-<code>path</code>仅包含空格。       -或-<code>path</code>包含一个或多个无效字符。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>包含无效值。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到该文件。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "打开日志存储区时发生了 I/O 错误。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "不支持此操作。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>无法使用，因为未安装所需的公用日志文件系统 (CLFS) 组件。 如果它不用于你的平台安装 CLFS 组件，或者使用<xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>类。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "初始化的新实例<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>使用指定路径的日志存储区和访问模式的类。"
  remarks: "此构造函数初始化新<xref:System.IO.Log.LogRecordSequence>上的新<xref:System.IO.Log.LogStore>它以指定的路径、 模式和访问权限打开的对象。</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogRecordSequence> 共享指定的访问权限打开的存储。"
  example:
  - "This example shows how to use this <xref:System.IO.Log.LogRecordSequence> constructor:  \n  \n [!code-cs[S_UELogRecordSequence#1](~/add/codesnippet/csharp/5a33f64b-b9a0-4b07-9df4-_1.cs)]\n [!code-vb[S_UELogRecordSequence#1](~/add/codesnippet/visualbasic/5a33f64b-b9a0-4b07-9df4-_1.vb)]"
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
    parameters:
    - id: path
      type: System.String
      description: "要打开的日志存储区的基文件相对或绝对路径。"
    - id: mode
      type: System.IO.FileMode
      description: "之一<xref href=&quot;System.IO.FileMode&quot;></xref>确定如何打开或创建存储的值。"
    - id: access
      type: System.IO.FileAccess
      description: "之一<xref href=&quot;System.IO.FileAccess&quot;></xref>确定如何通过访问文件的值<xref href=&quot;System.IO.Log.LogStore&quot;> </xref>。"
    - id: share
      type: System.IO.FileShare
      description: "之一<xref href=&quot;System.IO.FileShare&quot;></xref>确定将如何在进程之间共享的日志存储区的值。"
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>为空字符串 (&quot;&quot;)。       -或-<code>path</code>仅包含空格。       -或-<code>path</code>包含一个或多个无效字符。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>包含无效值。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到该文件。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "打开日志存储区时发生了 I/O 错误。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "不支持此操作。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>无法使用，因为未安装所需的公用日志文件系统 (CLFS) 组件。 如果它不用于你的平台安装 CLFS 组件，或者使用<xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>类。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "初始化的新实例<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>类使用的日志存储区、 文件权限、 访问和共享模式和缓冲区大小和计数为记录到指定的路径。"
  remarks: "此构造函数初始化新<xref:System.IO.Log.LogRecordSequence>上的新<xref:System.IO.Log.LogStore>它以指定的路径、 模式和访问权限打开的对象。</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogRecordSequence> 共享指定的访问权限打开的存储。"
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount);
    parameters:
    - id: path
      type: System.String
      description: "要打开的日志存储区的基文件相对或绝对路径。"
    - id: mode
      type: System.IO.FileMode
      description: "之一<xref href=&quot;System.IO.FileMode&quot;></xref>确定如何打开或创建存储的值。"
    - id: access
      type: System.IO.FileAccess
      description: "之一<xref href=&quot;System.IO.FileAccess&quot;></xref>确定如何通过访问文件的值<xref href=&quot;System.IO.Log.LogStore&quot;> </xref>。"
    - id: share
      type: System.IO.FileShare
      description: "之一<xref href=&quot;System.IO.FileShare&quot;></xref>确定将如何在进程之间共享的日志存储区的值。"
    - id: bufferSize
      type: System.Int32
      description: "所需的缓冲区大小 （字节）。 缓冲区大小确定了可追加或读取的记录的最大大小。"
    - id: bufferCount
      type: System.Int32
      description: "所需的缓冲区数。"
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>为空字符串 (&quot;&quot;)。       -或-<code>path</code>仅包含空格。       -或-<code>path</code>包含一个或多个无效字符。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>包含无效值。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到该文件。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "打开日志存储区时发生了 I/O 错误。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "不支持此操作。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>无法使用，因为未安装所需的公用日志文件系统 (CLFS) 组件。 如果它不用于你的平台安装 CLFS 组件，或者使用<xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>类。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "初始化的新实例<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>类。"
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount, System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: path
      type: System.String
      description: "要打开的日志存储区的基文件相对或绝对路径。"
    - id: mode
      type: System.IO.FileMode
      description: "一个有效<xref href=&quot;System.IO.FileMode&quot;></xref>值，该值确定如何打开或创建存储。"
    - id: access
      type: System.IO.FileAccess
      description: "一个有效<xref href=&quot;System.IO.FileAccess&quot;></xref>值，该值确定如何访问日志存储区。"
    - id: share
      type: System.IO.FileShare
      description: "一个有效<xref href=&quot;System.IO.FileShare&quot;></xref>值，该值确定将如何在进程之间共享的日志存储区。"
    - id: bufferSize
      type: System.Int32
      description: "所需的缓冲区大小 （字节）。 缓冲区大小确定了可追加或读取的记录的最大大小。"
    - id: bufferCount
      type: System.Int32
      description: "所需的缓冲区数。"
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "一个有效<xref href=&quot;System.Security.AccessControl.FileSecurity&quot;></xref>值，该值指定要设置新创建的存储区中，如果必须创建存储区的安全性。"
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "指定的文件<code> path </code>无效。       -或者-指定的日志存储区文件名无效。       - <code> mode </code>的值为<xref href=&quot;System.IO.FileMode&quot;> </xref>，并且不能在没有写访问权限。       - <code> mode </code>的值为<xref href=&quot;System.IO.FileMode&quot;> </xref>，并且不能在没有写访问权限。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一个或多个参数<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "超出范围的一个或多个参数。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "指定的文件<code> path </code>找不到。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "由于出现意外的 I/O 异常，无法执行请求。       -指定的文件<code> path </code>无法访问，因为它正在使用另一个进程。       -指定的文件<code> path </code>无法创建，因为该文件或目录已存在。       -或者-日志句柄无法绑定到线程池。       -或者-指定的日志文件格式或版本无效。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "不支持此操作。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>无法使用，因为未安装所需的公用日志文件系统 (CLFS) 组件。 如果它不用于你的平台安装 CLFS 组件，或者使用<xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>类。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列已满。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  id: AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "前移日志的基序列号。 此方法不能被继承。"
  remarks: "此方法通常用于<xref:System.IO.Log.LogRecordSequence.TailPinned>事件来释放记录中的空间。</xref:System.IO.Log.LogRecordSequence.TailPinned> <xref:System.IO.Log.LogRecordSequence.TailPinned>事件表示序列 （即基序列号） 的结尾需要前移以释放空间。</xref:System.IO.Log.LogRecordSequence.TailPinned> 释放空间可以通过任一写入重新开始区域使用<xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>方法，或截断日志并使用 AdvanceBaseSequenceNumber 方法向前移动到指定的日志的基序列号`newBaseSequenceNumber`参数。</xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> 示例部分中的代码示例演示了第二种方法。       请注意，调用此方法是设置新基序列号 using 相同<xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>方法，只不过没有将重新开始记录写入日志。</xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>"
  example:
  - "This example shows how to use the AdvanceBaseSequenceNumber method with the <xref:System.IO.Log.LogRecordSequence.TailPinned> event to free up space in a log sequence.  \n  \n```  \nrecordSequence.RetryAppend = true;  \nrecordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  \n  \nvoid HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  \n{  \n   // tailPinnedEventArgs.TargetSequenceNumber is the target   \n   // sequence number to free up space to.    \n   // However, this sequence number is not necessarily valid.  We have  \n   // to use this sequence number as a starting point for finding a  \n   // valid point within the log to advance toward. You need to  \n   // identify a record with a sequence number equal to, or greater  \n   // than TargetSequenceNumber; let's call this   \n   // realTargetSequenceNumber. Once found, move the base  \n  \n   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  \n  \n}  \n```"
  syntax:
    content: public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "指定新的基<xref href=&quot;System.IO.Log.SequenceNumber&quot;></xref>的日志。 这必须介于当前基序列号和日志的最后一个序列号之间的范围 （含）。"
  overload: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSequenceNumber</code>不适合此序列。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "新的或现有存档尾数据或基活动日志是无效的。       - <code> newBaseSequenceNumber </code>不在此序列的基和最后一个序列号之间。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "由于出现意外的 I/O 异常，无法执行请求。       -或者-由于出现 I/O 设备错误，无法执行请求。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "指定的日志没有任何范围。 必须创建一个或多个范围，然后可能使用记录序列。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列已满。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "将日志记录写入<xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>。 此方法不能被继承。"
  remarks: "中包含的数据`data`参数将连接成单个字节数组，以便以记录形式追加。 但是，数据将重新拆分为数组段中读取记录时不进行任何设置。       通常情况下，此方法完成之前记录已写入。 若要确保记录已写入，请指定<xref:System.IO.Log.RecordAppendOptions>标志使用`recordAppendOptions`参数或调用<xref:System.IO.Log.LogRecordSequence.Flush%2A>方法。</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  example:
  - "The following example demonstrates how to use this method to append a log record to the sequence.  \n  \n [!code-cs[S_UELogRecordSequence#13](~/add/codesnippet/csharp/11cb4ef9-9d52-4994-983c-_1.cs)]\n [!code-vb[S_UELogRecordSequence#13](~/add/codesnippet/visualbasic/11cb4ef9-9d52-4994-983c-_1.vb)]"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "用户指定顺序的下一个记录序列号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "上一步顺序的下一个记录序列号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> ，它指定应如何写入数据。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加的日志记录的序列号。"
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>或<code>previousRecord</code>对此序列无效。       -或-<code>data</code>由于它大于最大记录大小，因此无法追加。       -或-<code>reservations</code>不是由此记录序列。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一个或多个参数<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>或<code>previousRecord</code>不在此序列的基和最后一个序列号之间。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "由于出现意外的 I/O 异常，无法执行请求。       -或者-由于出现 I/O 设备错误，无法执行请求。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "无法执行操作，因为记录序列通过只读访问权限打开。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列已满。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "追加到日志记录<xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>。 此方法不能被继承。"
  remarks: "中包含的数据`data`参数将连接成单个字节数组，以便以记录形式追加。 但是，数据将重新拆分为数组段中读取记录时不进行任何设置。       通常情况下，此方法完成之前记录已写入。 若要确保记录已写入，请指定<xref:System.IO.Log.RecordAppendOptions>标志使用`recordAppendOptions`参数或调用<xref:System.IO.Log.LogRecordSequence.Flush%2A>方法。</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "用户指定顺序的下一个记录序列号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "上一步顺序的下一个记录序列号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> ，它指定应如何写入数据。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加的日志记录的序列号。"
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>或<code>previousRecord</code>对此序列无效。       -或-<code>data</code>由于它大于最大记录大小，因此无法追加。       -或-<code>reservations</code>不是由此记录序列。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一个或多个参数<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>或<code>previousRecord</code>不在此序列的基和最后一个序列号之间。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "由于出现意外的 I/O 异常，无法执行请求。       -或者-由于出现 I/O 设备错误，无法执行请求。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "无法执行操作，因为记录序列通过只读访问权限打开。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列已满。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "追加到日志记录<xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>，使用序列中先前保留的空间。 此方法不能被继承。"
  remarks: "中包含的数据`data`参数将连接成单个字节数组，以便以记录形式追加。 但是，数据将重新拆分为数组段中读取记录时不进行任何设置。       追加的记录将占用先前已保留，使用指定的保留的空间`reservations`参数。 如果追加成功，它将占用能容纳数据，并将从集合中移除保留区域最小保留区域。       通常情况下，此方法完成之前记录已写入。 若要确保记录已写入，请指定<xref:System.IO.Log.RecordAppendOptions>标志使用`recordAppendOptions`参数或调用<xref:System.IO.Log.LogRecordSequence.Flush%2A>方法。</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "用户指定顺序的下一个记录序列号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "上一步顺序的下一个记录序列号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> ，它指定应如何写入数据。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> ，它包含应当用于此记录的保留。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加的日志记录的序列号。"
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>或<code>previousRecord</code>对此序列无效。       -或-<code>data</code>由于它大于最大记录大小，因此无法追加。       -或-<code>reservations</code>不是由此记录序列。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一个或多个参数<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>或<code>previousRecord</code>不在此序列的基和最后一个序列号之间。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "由于出现意外的 I/O 异常，无法执行请求。       -或者-由于出现 I/O 设备错误，无法执行请求。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "无法执行操作，因为记录序列通过只读访问权限打开。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列已满。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "保留不足以容纳<code> data </code>可以位于<code> reservations </code>。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "追加到日志记录<xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>，使用序列中先前保留的空间。 此方法不能被继承。"
  remarks: "中包含的数据`data`参数将连接成单个字节数组，以便以记录形式追加。 但是，数据将重新拆分为数组段中读取记录时不进行任何设置。       追加的记录将占用先前已保留，使用指定的保留的空间`reservations`参数。 如果追加成功，它将占用能容纳数据，并将从集合中移除保留区域最小保留区域。       通常情况下，此方法完成之前记录已写入。 若要确保记录已写入，请指定<xref:System.IO.Log.RecordAppendOptions>标志使用`recordAppendOptions`参数或调用<xref:System.IO.Log.IRecordSequence.Flush%2A>方法。</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "用户指定顺序的下一个记录序列号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "上一步顺序的下一个记录序列号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> ，它指定应如何写入数据。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> ，它包含应当用于此记录的保留。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加的日志记录的序列号。"
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>或<code>previousRecord</code>对此序列无效。       -或-<code>data</code>由于它大于最大记录大小，因此无法追加。       -或-<code>reservations</code>不是由此记录序列。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一个或多个参数<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>或<code>previousRecord</code>不在此序列的基和最后一个序列号之间。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "由于出现意外的 I/O 异常，无法执行请求。       -或者-由于出现 I/O 设备错误，无法执行请求。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "无法执行操作，因为记录序列通过只读访问权限打开。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列已满。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "保留不足以容纳<code> data </code>可以位于<code> reservations </code>。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BaseSequenceNumber
  id: BaseSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BaseSequenceNumber
  nameWithType: LogRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.BaseSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "获取在当前的第一条有效记录的序列号<xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>。"
  remarks: "有效序列号是大于或等于 BaseSequenceNumber，并且小于<xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.</xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>       此属性的值可以更改通过调用<xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>方法或<xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>方法。</xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> </xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>"
  example:
  - "This example shows how to use the BaseSequenceNumber member in a loop.  \n  \n [!code-cs[S_UELogRecordSequence#10](~/add/codesnippet/csharp/p-system.io.log.logrecor_2_1.cs)]\n [!code-vb[S_UELogRecordSequence#10](~/add/codesnippet/visualbasic/p-system.io.log.logrecor_2_1.vb)]"
  syntax:
    content: public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "中有效记录对应的最低序列号<xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>。"
  overload: System.IO.Log.LogRecordSequence.BaseSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "在序列已释放的之后，已访问属性。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "开始异步追加操作。 此方法不能被继承。"
  remarks: "应传递<xref:System.IAsyncResult>到此方法返回<xref:System.IO.Log.LogRecordSequence.EndAppend%2A>方法，以确保追加操作已完成并能够适当释放资源。</xref:System.IO.Log.LogRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> 如果在异步追加过程中发生错误，直到不引发异常<xref:System.IO.Log.LogRecordSequence.EndAppend%2A>方法调用与<xref:System.IAsyncResult>此方法返回。</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndAppend%2A>       中包含的数据`data`参数将连接成单个字节数组，以便以记录形式追加。 但是，数据将重新拆分为数组段中读取记录时不进行任何设置。       通常情况下，此方法完成之前记录已写入。 若要确保记录已写入，请指定<xref:System.IO.Log.RecordAppendOptions>标志使用`recordAppendOptions`参数或调用<xref:System.IO.Log.LogRecordSequence.Flush%2A>方法。</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "用户指定顺序的下一个记录序列号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "上一步顺序的下一个记录序列号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> ，它指定应如何写入数据。"
    - id: callback
      type: System.AsyncCallback
      description: "可选的异步回调，以在追加完成时调用。"
    - id: state
      type: System.Object
      description: "用户提供的对象，用于区分此特定异步追加请求与其他请求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>表示异步追加，可能仍处于挂起状态。</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>nextUndoRecord</code>或<code>previousRecord</code>对此序列无效。       -或-<code>data</code>由于它大于最大记录大小，因此无法追加。       -或-<code>reservations</code>不是由此记录序列。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一个或多个参数<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>nextUndoRecord</code>或<code>previousRecord</code>不在此序列的基和最后一个序列号之间。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "由于出现意外的 I/O 异常，无法执行请求。       -或者-由于出现 I/O 设备错误，无法执行请求。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "无法执行操作，因为记录序列通过只读访问权限打开。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列已满。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "开始异步追加操作。 此方法不能被继承。"
  remarks: "应传递<xref:System.IAsyncResult>到此方法返回<xref:System.IO.Log.LogRecordSequence.EndAppend%2A>方法，以确保追加操作已完成并能够适当释放资源。</xref:System.IO.Log.LogRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> 如果在异步追加过程中发生错误，直到不引发异常<xref:System.IO.Log.LogRecordSequence.EndAppend%2A>方法调用与<xref:System.IAsyncResult>此方法返回。</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndAppend%2A>       中包含的数据`data`参数将连接成单个字节数组，以便以记录形式追加。 但是，数据将重新拆分为数组段中读取记录时不进行任何设置。       通常情况下，此方法完成之前记录已写入。 若要确保记录已写入，请指定<xref:System.IO.Log.RecordAppendOptions>标志使用`recordAppendOptions`参数或调用<xref:System.IO.Log.LogRecordSequence.Flush%2A>方法。</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "用户指定顺序的下一个记录序列号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "上一步顺序的下一个记录序列号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> ，它指定应如何写入数据。"
    - id: callback
      type: System.AsyncCallback
      description: "可选的异步回调，以在追加完成时调用。"
    - id: state
      type: System.Object
      description: "用户提供的对象，用于区分此特定异步追加请求与其他请求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>表示异步追加，可能仍处于挂起状态。</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>或<code>previousRecord</code>对此序列无效。       -或-<code>data</code>由于它大于最大记录大小，因此无法追加。       -或-<code>reservations</code>不是由此记录序列。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一个或多个参数<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>或<code>previousRecord</code>不在此序列的基和最后一个序列号之间。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "由于出现意外的 I/O 异常，无法执行请求。       -或者-由于出现 I/O 设备错误，无法执行请求。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "无法执行操作，因为记录序列通过只读访问权限打开。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列已满。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "开始异步追加操作。 此方法不能被继承。"
  remarks: "应传递<xref:System.IAsyncResult>到此方法返回<xref:System.IO.Log.LogRecordSequence.EndAppend%2A>方法，以确保追加操作已完成并能够适当释放资源。</xref:System.IO.Log.LogRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> 如果在异步追加过程中发生错误，直到不引发异常<xref:System.IO.Log.LogRecordSequence.EndAppend%2A>方法调用与<xref:System.IAsyncResult>此方法返回。</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndAppend%2A>       中包含的数据`data`参数将连接成单个字节数组，以便以记录形式追加。 但是，数据将重新拆分为数组段中读取记录时不进行任何设置。       追加的记录将占用先前已保留，使用指定的保留的空间`reservations`参数。 如果追加成功，它将占用能容纳数据，并将从集合中移除保留区域最小保留区域。       通常情况下，此方法完成之前记录已写入。 若要确保记录已写入，请指定<xref:System.IO.Log.RecordAppendOptions>标志使用`recordAppendOptions`参数或调用<xref:System.IO.Log.LogRecordSequence.Flush%2A>方法。</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "用户指定顺序的下一个记录序列号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "上一步顺序的下一个记录序列号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> ，它指定应如何写入数据。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> ，它包含应当用于此记录的保留。"
    - id: callback
      type: System.AsyncCallback
      description: "可选的异步回调，以在追加完成时调用。"
    - id: state
      type: System.Object
      description: "用户提供的对象，用于区分此特定异步追加请求与其他请求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>表示异步追加，可能仍处于挂起状态。</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>或<code>previousRecord</code>对此序列无效。       -或-<code>data</code>由于它大于最大记录大小，因此无法追加。       -或-<code>reservations</code>不是由此记录序列。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一个或多个参数<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>或<code>previousRecord</code>不在此序列的基和最后一个序列号之间。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "由于出现意外的 I/O 异常，无法执行请求。       -或者-由于出现 I/O 设备错误，无法执行请求。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "无法执行操作，因为记录序列通过只读访问权限打开。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列已满。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "保留不足以容纳<code> data </code>可以位于<code> reservations </code>。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "开始异步追加操作。 此方法不能被继承。"
  remarks: "应传递<xref:System.IAsyncResult>到此方法返回<xref:System.IO.Log.LogRecordSequence.EndAppend%2A>方法，以确保追加操作已完成并能够适当释放资源。</xref:System.IO.Log.LogRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> 如果在异步追加过程中发生错误，直到不引发异常<xref:System.IO.Log.LogRecordSequence.EndAppend%2A>方法调用与<xref:System.IAsyncResult>此方法返回。</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndAppend%2A>       中包含的数据`data`参数将连接成单个字节数组，以便以记录形式追加。 但是，数据将重新拆分为数组段中读取记录时不进行任何设置。       追加的记录将占用先前已保留，使用指定的保留的空间`reservations`参数。 如果追加成功，它将占用能容纳数据，并将从集合中移除保留区域最小保留区域。       通常情况下，此方法完成之前记录已写入。 若要确保记录已写入，请指定<xref:System.IO.Log.RecordAppendOptions>标志使用`recordAppendOptions`参数或调用<xref:System.IO.Log.LogRecordSequence.Flush%2A>方法。</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "用户指定顺序的下一个记录序列号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "上一步顺序的下一个记录序列号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> ，它指定应如何写入数据。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> ，它包含应当用于此记录的保留。"
    - id: callback
      type: System.AsyncCallback
      description: "可选的异步回调，以在追加完成时调用。"
    - id: state
      type: System.Object
      description: "用户提供的对象，用于区分此特定异步追加请求与其他请求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>表示异步追加，可能仍处于挂起状态。</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>或<code>previousRecord</code>对此序列无效。       -或-<code>data</code>由于它大于最大记录大小，因此无法追加。       -或-<code>reservations</code>不是由此记录序列。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一个或多个参数<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>或<code>previousRecord</code>不在此序列的基和最后一个序列号之间。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "由于出现意外的 I/O 异常，无法执行请求。       -或者-由于出现 I/O 设备错误，无法执行请求。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "无法执行操作，因为记录序列通过只读访问权限打开。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列已满。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "保留不足以容纳<code> data </code>可以位于<code> reservations </code>。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  id: BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "开始异步刷新操作，使用序列中先前保留的空间。 此方法不能被继承。"
  remarks: "应传递<xref:System.IAsyncResult>返回在当前方法<xref:System.IO.Log.LogRecordSequence.EndFlush%2A>方法，以确保刷新完成并适当释放资源。</xref:System.IO.Log.LogRecordSequence.EndFlush%2A> </xref:System.IAsyncResult> 如果异步刷新过程中发生错误，直到不引发异常<xref:System.IO.Log.LogRecordSequence.EndFlush%2A>方法调用与<xref:System.IAsyncResult>此方法返回。</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndFlush%2A>       调用此方法可以确保所有记录已追加到<xref:System.IO.Log.LogRecordSequence>持久写入。</xref:System.IO.Log.LogRecordSequence>       如果记录序列已经释放，或者如果传递了无效自变量，将立即引发异常，此操作内。 异步刷新请求，例如，I/O 请求过程中的磁盘故障过程中发生的错误将导致在时引发异常<xref:System.IO.Log.LogRecordSequence.EndFlush%2A>调用方法。</xref:System.IO.Log.LogRecordSequence.EndFlush%2A>"
  syntax:
    content: public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "必须写入的最新记录的序列号。 如果此<xref href=&quot;System.IO.Log.SequenceNumber&quot;></xref>无效，则必须写入所有记录。"
    - id: callback
      type: System.AsyncCallback
      description: "可选的异步回调，在刷新完成时调用。"
    - id: state
      type: System.Object
      description: "一个用户提供的对象，它将此特定异步刷新请求与其他请求区别开来。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，表示异步刷新操作，可能仍处于挂起状态。</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sequenceNumber</code>不适合此序列。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>sequenceNumber</code>不是此序列的基和最后一个序列号号之间。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "由于出现意外的 I/O 异常，无法执行请求。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "指定的日志没有任何范围。 必须创建一个或多个范围，然后才能使用记录序列。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "无法执行操作，因为记录序列通过只读访问权限打开。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列已满。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "开始异步保留和追加操作。 此方法不能被继承。"
  remarks: "应传递<xref:System.IAsyncResult>到此方法返回<xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>方法，以确保追加操作已完成并能够适当释放资源。</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> 如果在异步追加过程中发生错误，直到不引发异常<xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>方法调用与<xref:System.IAsyncResult>此方法返回。</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>       中包含的数据`data`参数将连接成单个字节数组，以便以记录形式追加。 但是，数据将重新拆分为数组段中读取记录时不进行任何设置。       指定的保留添加到所提供的保留集合在原子操作中使用记录追加操作。 如果追加失败，不保留任何空间。       通常情况下，此方法可以完成之前记录已写入。 若要确保记录已写入，请指定<xref:System.IO.Log.RecordAppendOptions>标志使用`recordAppendOptions`参数或调用<xref:System.IO.Log.LogRecordSequence.Flush%2A>方法。</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       如果记录序列已经释放，或者如果传递了无效自变量，将立即引发异常，此操作内。 例如，I/O 请求过程中的磁盘故障异步追加请求过程中发生的错误将导致在时引发异常<xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>调用方法。</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "用户指定顺序的下一个记录序列号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "上一步顺序的下一个记录序列号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> ，它指定应如何写入数据。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "要在其中生成保留的保留集合。"
    - id: reservations
      type: System.Int64[]
      description: "要生成，以字节为单位的保留。"
    - id: callback
      type: System.AsyncCallback
      description: "可选的异步回调，以在追加完成时调用。"
    - id: state
      type: System.Object
      description: "用户提供的对象，用于区分此特定异步追加请求与其他请求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，表示此异步操作，可能仍处于挂起状态。</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>或<code>previousRecord</code>对此序列无效。       -或-<code>data</code>由于它大于最大记录大小，因此无法追加。       -或-<code>reservations</code>不是由此记录序列。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一个或多个参数<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>或<code>previousRecord</code>不在此序列的基和最后一个序列号之间。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "由于出现意外的 I/O 异常，无法执行请求。       -或者-由于出现 I/O 设备错误，无法执行请求。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "无法执行操作，因为记录序列通过只读访问权限打开。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列已满。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "保留不足以容纳<code> data </code>可以位于<code> reservations </code>。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "开始异步保留和追加操作。 此方法不能被继承。"
  remarks: "应传递<xref:System.IAsyncResult>到此方法返回<xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>方法，以确保追加操作已完成并能够适当释放资源。</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> 如果在异步追加过程中发生错误，直到不引发异常<xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>方法调用与<xref:System.IAsyncResult>此方法返回。</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>       中包含的数据`data`参数将连接成单个字节数组，以便以记录形式追加。 但是，数据将重新拆分为数组段中读取记录时不进行任何设置。       指定的保留添加到所提供的保留集合在原子操作中使用记录追加操作。 如果追加失败，不保留任何空间。       通常情况下，此方法可以完成之前记录已写入。 若要确保记录已写入，请指定<xref:System.IO.Log.RecordAppendOptions>标志使用`recordAppendOptions`参数或调用<xref:System.IO.Log.LogRecordSequence.Flush%2A>方法。</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       如果记录序列已经释放，或者如果传递了无效自变量，将立即引发异常，此操作内。 例如，I/O 请求过程中的磁盘故障异步追加请求过程中发生的错误将导致在时引发异常<xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>调用方法。</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "用户指定顺序的下一个记录序列号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "上一步顺序的下一个记录序列号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> ，它指定应如何写入数据。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "要在其中生成保留的保留集合。"
    - id: reservations
      type: System.Int64[]
      description: "要生成，以字节为单位的保留。"
    - id: callback
      type: System.AsyncCallback
      description: "可选的异步回调，以在追加完成时调用。"
    - id: state
      type: System.Object
      description: "用户提供的对象，用于区分此特定异步追加请求与其他请求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，表示此异步操作，可能仍处于挂起状态。</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "追加记录时发生 I/O 错误。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列无法获得足够的可用空间来容纳新记录，或生成保留。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "开始异步重新开始区域写入操作，使用序列中先前保留的空间。 此方法不能被继承。"
  remarks: "应传递<xref:System.IAsyncResult>到此方法返回<xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>方法，以确保重新开始区域写入操作已完成并能够适当释放资源。</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> 如果在异步重新开始区域写入操作期间发生错误，直到不引发异常<xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>方法调用与<xref:System.IAsyncResult>此方法返回。</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>       中包含的数据`data`参数将连接成单个字节数组，以便以记录形式追加。 但是，数据将重新拆分为数组段中读取记录时不进行任何设置。       该操作成功完成时，基序列号已更新。 其所有日志记录序列号小于新的基序列号都不可访问。       如果<xref:System.IO.Log.ReservationCollection>指定，写入的重新开始区域将占用先前已保留，使用集合中包含的保留的空间。</xref:System.IO.Log.ReservationCollection> 如果该方法成功，它将占用的最小的保留，可以容纳的数据，而该保留将从集合中移除。       如果记录序列已经释放，或者如果传递了无效自变量，将立即引发异常，此操作内。 例如，I/O 请求过程中的磁盘故障异步追加请求过程中发生的错误将导致在时引发异常<xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>调用方法。</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "将连接在一起并以记录形式追加的字节数组段。"
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "新的基序列号。 指定的序列号必须大于或等于当前基序列号。"
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> ，它包含应当用于此重新开始区域的保留。"
    - id: callback
      type: System.AsyncCallback
      description: "可选的异步回调，以重新开始区域写入完成时调用。"
    - id: state
      type: System.Object
      description: "一个用户提供的对象，它将此特定异步重新开始区域写入请求与其他请求区别开来。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，表示的异步重新开始区域写入操作，可能仍处于挂起状态。</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>不适合此序列。       -或者-指定的日志枚举开始序列号无效。       -或-<code>data</code>由于它大于最大记录大小，因此无法追加。       -或-<code>reservation</code>不是由此记录序列。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一个或多个参数是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "新的或现有存档尾数据或基活动日志是无效的。       - <code> newBaseSeqNum </code>不在此序列的基和最后一个序列号之间。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "由于出现意外的 I/O 异常，无法执行请求。       -或者-由于出现 I/O 设备错误，无法执行请求。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列已满。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "开始异步重新开始区域写入操作，使用序列中先前保留的空间。 此方法不能被继承。"
  remarks: "应传递<xref:System.IAsyncResult>到此方法返回<xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>方法，以确保重新开始区域写入操作已完成并能够适当释放资源。</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> 如果在异步重新开始区域写入操作期间发生错误，直到不引发异常<xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>方法调用与<xref:System.IAsyncResult>此方法返回。</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>       中包含的数据`data`参数将连接成单个字节数组，以便以记录形式追加。 但是，数据将重新拆分为数组段中读取记录时不进行任何设置。       该操作成功完成时，基序列号已更新。 其所有日志记录序列号小于新的基序列号都不可访问。       如果<xref:System.IO.Log.ReservationCollection>指定，写入的重新开始区域将占用先前已保留，使用集合中包含的保留的空间。</xref:System.IO.Log.ReservationCollection> 如果该方法成功，它将占用的最小的保留，可以容纳的数据，而该保留将从集合中移除。       如果记录序列已经释放，或者如果传递了无效自变量，将立即引发异常，此操作内。 例如，I/O 请求过程中的磁盘故障异步追加请求过程中发生的错误将导致在时引发异常<xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>调用方法。</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "新的基序列号。 指定的序列号必须大于或等于当前基序列号。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> ，它包含应当用于此重新开始区域的保留。"
    - id: callback
      type: System.AsyncCallback
      description: "可选的异步回调，以重新开始区域写入完成时调用。"
    - id: state
      type: System.Object
      description: "一个用户提供的对象，它将此特定异步重新开始区域写入请求与其他请求区别开来。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，表示的异步重新开始区域写入操作，可能仍处于挂起状态。</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>不适合此序列。       -或者-指定的日志枚举开始序列号无效。       -或-<code>data</code>由于它大于最大记录大小，因此无法追加。       -或-<code>reservationCollection</code>不是由此记录序列。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一个或多个参数是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "新的或现有存档尾数据或基活动日志是无效的。       - <code> newBaseSeqNum </code>不在此序列的基和最后一个序列号之间。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "由于出现意外的 I/O 异常，无法执行请求。       -或者-由于出现 I/O 设备错误，无法执行请求。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列已满。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.CreateReservationCollection
  id: CreateReservationCollection
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: CreateReservationCollection()
  nameWithType: LogRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.LogRecordSequence.CreateReservationCollection()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "创建一个新<xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>。 此方法不能被继承。"
  remarks: ''
  example:
  - "Reservations can be performed in two ways as shown in the following examples. You can adopt the practices in the samples for robust processing. Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.  \n  \n```  \n//Using the ReserveAndAppend Method  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nlong[] lengthOfUndoRecords = new long[] { 1000 };  \nrecordSequence.ReserveAndAppend(recordData,  \n                                                     userSqn,  \n                                                     previousSqn,  \n                                                     RecordSequenceAppendOptions.None,  \n                                                     reservations,  \n                                                     lengthOfUndoRecords);  \nrecordSequence.Append(undoRecordData,    // If necessary …  \n                                    userSqn,  \n                                    previousSqn,  \n                                    RecordSequenceAppendOptions.ForceFlush,  \n                                    reservations);  \n  \n// Using the Manual Approach  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nreservations.Add(lengthOfUndoRecord);  \ntry  \n{  \n   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  \n}  \ncatch (Exception)  \n{  \n   reservations.Remove(lengthOfUndoRecord);  \n   throw;  \n}  \n  \nrecordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  \n```"
  syntax:
    content: public System.IO.Log.ReservationCollection CreateReservationCollection ();
    parameters: []
    return:
      type: System.IO.Log.ReservationCollection
      description: "新创建<xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>。"
  overload: System.IO.Log.LogRecordSequence.CreateReservationCollection*
  exceptions:
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Dispose
  id: Dispose
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Dispose()
  nameWithType: LogRecordSequence.Dispose()
  fullName: System.IO.Log.LogRecordSequence.Dispose()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "释放组件使用的资源。"
  remarks: ''
  example:
  - "This example shows how to use Dispose to release resource:  \n  \n [!code-cs[S_UELogRecordSequence#11](~/add/codesnippet/csharp/m-system.io.log.logrecor_1.cs)]\n [!code-vb[S_UELogRecordSequence#11](~/add/codesnippet/visualbasic/m-system.io.log.logrecor_1.vb)]  \n  \n [!code-cs[S_UELogRecordSequence#12](~/add/codesnippet/csharp/m-system.io.log.logrecor_2.cs)]\n [!code-vb[S_UELogRecordSequence#12](~/add/codesnippet/visualbasic/m-system.io.log.logrecor_2.vb)]"
  syntax:
    content: public void Dispose ();
    parameters: []
  overload: System.IO.Log.LogRecordSequence.Dispose*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)
  id: EndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "结束异步追加操作。 此方法不能被继承。"
  remarks: "此方法阻止，直到 I/O 操作已完成。 调用 EndAppend 时，异步写入请求，例如，I/O 请求过程的磁盘故障过程中发生的错误变得可见。       必须在上一次调用此方法每个<xref:System.IAsyncResult>返回<xref:System.IO.Log.LogRecordSequence.BeginAppend%2A>方法。</xref:System.IO.Log.LogRecordSequence.BeginAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "对未完成的异步 I/O 请求的引用。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加的日志记录的序列号。"
  overload: System.IO.Log.LogRecordSequence.EndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>是无效的。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "由于出现意外的 I/O 异常，无法执行请求。       -或者-由于出现 I/O 设备错误，无法执行请求。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End &quot; name=&quot;End &quot; href=&quot;&quot;></xref>为此异步操作已调用。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "无法执行操作，因为记录序列通过只读访问权限打开。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列已满。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)
  id: EndFlush(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndFlush(IAsyncResult)
  nameWithType: LogRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndFlush(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "结束异步刷新操作。 此方法不能被继承。"
  remarks: "此方法阻止，直到 I/O 操作已完成。 调用 EndFlush 时，异步刷新请求，例如，I/O 请求过程的磁盘故障过程中发生的错误变得可见。       必须在上一次调用此方法每个<xref:System.IAsyncResult>返回<xref:System.IO.Log.LogRecordSequence.BeginFlush%2A>方法。</xref:System.IO.Log.LogRecordSequence.BeginFlush%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "对未完成的异步 I/O 请求的引用。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "写入的最后一个记录序列号。"
  overload: System.IO.Log.LogRecordSequence.EndFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>是无效的。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "由于出现意外的 I/O 异常，无法执行请求。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>为此异步操作已调用。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "无法执行操作，因为记录序列通过只读访问权限打开。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列已满。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  id: EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndReserveAndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "结束异步保留和追加操作。 此方法不能被继承。"
  remarks: "此方法阻止，直到 I/O 操作已完成。 调用 EndReserveAndAppend 时，异步写入请求，例如，I/O 请求过程的磁盘故障过程中发生的错误变得可见。       必须在上一次调用此方法每个<xref:System.IAsyncResult>返回<xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A>方法。</xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "对未完成的异步 I/O 请求的引用。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加的日志记录的序列号。"
  overload: System.IO.Log.LogRecordSequence.EndReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>是无效的。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "由于出现意外的 I/O 异常，无法执行请求。       -或者-由于出现 I/O 设备错误，无法执行请求。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>为此异步操作已调用。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "无法执行操作，因为记录序列通过只读访问权限打开。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列已满。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  id: EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: LogRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndWriteRestartArea(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "结束异步重新开始区域写入操作。 此方法不能被继承。"
  remarks: "此方法阻止，直到 I/O 操作已完成。 调用 EndWriteRestartArea 时，异步写入请求，例如，I/O 请求过程的磁盘故障过程中发生的错误变得可见。       必须在上一次调用此方法每个<xref:System.IAsyncResult>返回<xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A>方法。</xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "对未完成的异步 I/O 请求的引用。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "写入的日志记录的序列号。"
  overload: System.IO.Log.LogRecordSequence.EndWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>不是有效的。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "新的或现有存档尾数据或基活动日志是无效的。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "由于出现意外的 I/O 异常，无法执行请求。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>为此异步操作已调用。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列已满。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Flush
  id: Flush
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Flush()
  nameWithType: LogRecordSequence.Flush()
  fullName: System.IO.Log.LogRecordSequence.Flush()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "确保所有追加的记录都已写入。 此方法不能被继承。"
  remarks: "调用此方法可以确保所有记录已追加到<xref:System.IO.Log.LogRecordSequence>都已持久写入。</xref:System.IO.Log.LogRecordSequence>"
  syntax:
    content: public System.IO.Log.SequenceNumber Flush ();
    parameters: []
    return:
      type: System.IO.Log.SequenceNumber
      description: "写入的最后一个记录序列号。"
  overload: System.IO.Log.LogRecordSequence.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "刷新数据时出现 I/O 错误。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "不支持此操作。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列无法获得足够的可用空间以包含新的重新开始区域。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "指定的日志没有任何范围。 必须创建一个或多个范围，然后才能使用记录序列。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)
  id: Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Flush(SequenceNumber)
  nameWithType: LogRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.Flush(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "确保所有追加的记录，直到并包括指定的序列号的记录都已持久写入。 此方法不能被继承。"
  remarks: "调用此方法可以确保与序列的所有记录最多和不高于指定的序列号都已持久写入。"
  syntax:
    content: public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "必须写入的最新记录的序列号。 如果此<xref href=&quot;System.IO.Log.SequenceNumber&quot;></xref>无效，则必须写入所有记录。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "写入的最后一个记录序列号。"
  overload: System.IO.Log.LogRecordSequence.Flush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sequenceNumber</code>不适合此序列。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>sequenceNumber</code>不是此序列的基和最后一个序列号号之间。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "由于出现意外的 I/O 异常，无法执行请求。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "指定的日志没有任何范围。 必须创建一个或多个范围，然后才能使用记录序列。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "无法执行操作，因为记录序列通过只读访问权限打开。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列已满。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.LastSequenceNumber
  id: LastSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LastSequenceNumber
  nameWithType: LogRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.LastSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "获取序列号比追加的最新记录大"
  remarks: "此属性包含一个可以保证较大的序列号的最后一个序列号大于追加记录。 有效序列号是大于或等于<xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A>，并且小于 LastSequenceNumber。</xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> 所有其他序列号均无效。"
  syntax:
    content: public System.IO.Log.SequenceNumber LastSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "序列号比追加的最新记录大。"
  overload: System.IO.Log.LogRecordSequence.LastSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "在序列已释放的之后，已访问属性。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.LogStore
  id: LogStore
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogStore
  nameWithType: LogRecordSequence.LogStore
  fullName: System.IO.Log.LogRecordSequence.LogStore
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "获取<xref href=&quot;System.IO.Log.LogStore&quot;> </xref> ，其中包含此记录序列的数据。 此方法不能被继承。"
  remarks: ''
  example:
  - "This example shows how to use the LogStore member to add extents.  \n  \n [!code-cs[S_UELogRecordSequence#11](~/add/codesnippet/csharp/p-system.io.log.logrecor_1_1.cs)]\n [!code-vb[S_UELogRecordSequence#11](~/add/codesnippet/visualbasic/p-system.io.log.logrecor_1_1.vb)]"
  syntax:
    content: public System.IO.Log.LogStore LogStore { get; }
    return:
      type: System.IO.Log.LogStore
      description: "<xref href=&quot;System.IO.Log.LogStore&quot;> </xref> ，其中包含此记录序列的数据。"
  overload: System.IO.Log.LogRecordSequence.LogStore*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.MaximumRecordLength
  id: MaximumRecordLength
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: MaximumRecordLength
  nameWithType: LogRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.LogRecordSequence.MaximumRecordLength
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "获取可以添加到此记录序列的记录的最大大小。"
  syntax:
    content: public long MaximumRecordLength { get; }
    return:
      type: System.Int64
      description: "可以添加到此记录序列的记录的最大大小。"
  overload: System.IO.Log.LogRecordSequence.MaximumRecordLength*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  id: ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "返回序列中记录的可枚举集合。 此方法不能被继承。"
  remarks: "此方法返回序列中记录的可枚举集合。 所枚举记录的顺序取决于值`logRecordEnum`参数。"
  example:
  - "This example shows how to use ReadLogRecords in a loop.  \n  \n [!code-cs[S_UELogRecordSequence#10](~/add/codesnippet/csharp/65162f37-dafe-4315-8e44-_1.cs)]\n [!code-vb[S_UELogRecordSequence#10](~/add/codesnippet/visualbasic/65162f37-dafe-4315-8e44-_1.vb)]"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);
    parameters:
    - id: start
      type: System.IO.Log.SequenceNumber
      description: "读取操作开始处的第一个记录序列号。"
    - id: logRecordEnum
      type: System.IO.Log.LogRecordEnumeratorType
      description: "一个有效<xref href=&quot;System.IO.Log.LogRecordEnumeratorType&quot;></xref>值，该值指定使用方式 （即，向前或向后） 中的记录应读取从<xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>。"
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "序列中记录的可枚举集合。"
  overload: System.IO.Log.LogRecordSequence.ReadLogRecords*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>start</code>不适合此序列。       -或-<code>logRecordEnum</code>无效。       -或者-集合中找不到指定的元素。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>start</code>不是此序列的基和最后一个序列号号之间。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "由于出现意外的 I/O 异常，无法执行请求。       -或者-由于出现 I/O 设备错误，无法执行请求。       -或用于写入的日志记录是大于用于读取它的缓冲区大小的缓冲区大小。       -或者-记录序列已损坏。       -或者-指定的日志文件格式或版本无效。       -或者-记录已写入的记录序列版本不兼容。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "操作无效，因为尚未启动枚举。 调用<xref:System.Collections.IEnumerator.MoveNext*>必须进行。</xref:System.Collections.IEnumerator.MoveNext*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReadRestartAreas
  id: ReadRestartAreas
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReadRestartAreas()
  nameWithType: LogRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.LogRecordSequence.ReadRestartAreas()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "返回序列中重新开始区域的可枚举集合。 此方法不能被继承。"
  remarks: "重新开始区域将枚举在反向序列号的顺序，即从最高序列号到最低序列号。 仅重新开始区域的最后一个序列号之间的序列号和基序列号枚举。"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadRestartAreas ();
    parameters: []
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "序列中重新开始区域的可枚举集合。"
  overload: System.IO.Log.LogRecordSequence.ReadRestartAreas*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>start</code>不是此序列的基和最后一个序列号号之间。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "由于出现意外的 I/O 异常，无法执行请求。       -或者-由于出现 I/O 设备错误，无法执行请求。       -或用于写入的日志记录是大于用于读取它的缓冲区大小的缓冲区大小。       -或者-记录序列已损坏。       -或者-指定的日志文件格式或版本无效。       -或者-记录已写入的记录序列版本不兼容。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "操作无效，因为尚未启动枚举。 调用<xref:System.Collections.IEnumerator.MoveNext*>必须进行。</xref:System.Collections.IEnumerator.MoveNext*>       -或枚举已经终止。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "自动生成一个保留，并向序列中追加一条记录。 此方法不能被继承。"
  remarks: "中包含的数据`data`参数将连接成单个字节数组，以便以记录形式追加。 但是，数据将重新拆分为数组段中读取记录时不进行任何设置。       指定的保留添加到所提供的保留集合在原子操作中使用记录追加操作。 如果追加失败，不保留任何空间。       通常情况下，此方法可以完成之前记录已写入。 若要确保记录已写入，请指定<xref:System.IO.Log.RecordAppendOptions>标志使用`recordAppendOptions`参数或调用<xref:System.IO.Log.LogRecordSequence.Flush%2A>方法。</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  example:
  - "The following example shows how to use this method to make reservations. Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.  \n  \n```  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nlong[] lengthOfUndoRecords = new long[] { 1000 };  \nrecordSequence.ReserveAndAppend(recordData,  \n                                                     userSqn,  \n                                                     previousSqn,  \n                                                     RecordSequenceAppendOptions.None,  \n                                                     reservations,  \n                                                     lengthOfUndoRecords);  \nrecordSequence.Append(undoRecordData,    // If necessary …  \n                                    userSqn,  \n                                    previousSqn,  \n                                    RecordSequenceAppendOptions.ForceFlush,  \n                                    reservations);  \n```"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "用户指定顺序的下一个记录序列号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "上一步顺序的下一个记录序列号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> ，它指定应如何写入数据。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> ，其中包含要在其中生成保留的集合。"
    - id: reservations
      type: System.Int64[]
      description: "要生成，以字节为单位的保留。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加的日志记录的序列号。"
  overload: System.IO.Log.LogRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>nextUndoRecord</code>或<code>previousRecord</code>对此序列无效。       -或-<code>data</code>由于它大于最大记录大小，因此无法追加。       -或-<code>reservations</code>不是由此记录序列。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一个或多个参数<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>nextUndoRecord</code>或<code>previousRecord</code>不在此序列的基和最后一个序列号之间。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "由于出现意外的 I/O 异常，无法执行请求。       -或者-由于出现 I/O 设备错误，无法执行请求。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "无法执行操作，因为记录序列通过只读访问权限打开。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列已满。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "保留不足以容纳<code> data </code>可以位于<code> reservations </code>。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "自动生成一个保留，并向序列中追加一条记录。 此方法不能被继承。"
  remarks: "中包含的数据`data`参数将连接成单个字节数组，以便以记录形式追加。 但是，数据将重新拆分为数组段中读取记录时不进行任何设置。       指定的保留添加到所提供的保留集合在原子操作中使用记录追加操作。 如果追加失败，不保留任何空间。       通常情况下，此方法可以完成之前记录已写入。 若要确保记录已写入，请指定<xref:System.IO.Log.RecordAppendOptions>标志使用`recordAppendOptions`参数或调用<xref:System.IO.Log.LogRecordSequence.Flush%2A>方法。</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "用户指定顺序的下一个记录序列号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "上一步顺序的下一个记录序列号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> ，它指定应如何写入数据。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "要在其中生成保留的保留集合。"
    - id: reservations
      type: System.Int64[]
      description: "要生成，以字节为单位的保留。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加的日志记录的序列号。"
  overload: System.IO.Log.LogRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "追加记录时发生 I/O 错误。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列无法获得足够的可用空间来容纳新记录，或生成保留。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一个或多个参数<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>或<code>previousRecord</code>不在此序列的基和最后一个序列号之间。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "无法执行操作，因为记录序列通过只读访问权限打开。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "保留不足以容纳<code> data </code>可以位于<code> reservations </code>。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReservedBytes
  id: ReservedBytes
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReservedBytes
  nameWithType: LogRecordSequence.ReservedBytes
  fullName: System.IO.Log.LogRecordSequence.ReservedBytes
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "获取已保留的字节总数。"
  syntax:
    content: public long ReservedBytes { get; }
    return:
      type: System.Int64
      description: "此记录序列中做出的所有保留的总大小。"
  overload: System.IO.Log.LogRecordSequence.ReservedBytes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "在序列已释放的之后，已访问属性。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.RestartSequenceNumber
  id: RestartSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: RestartSequenceNumber
  nameWithType: LogRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.RestartSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "获取重新开始区域的序列的号最接近日志末尾。"
  remarks: "重新开始区域用于临时存储包含客户端的最后一个检查点操作的信息。 公用日志文件系统 (CLFS) 维护两个重新开始区域，以确保至少一个有效区域总是可用。 需要恢复时，CLFS 最后一个检查点操作中读取其重新开始区域和所有数据。 此数据将初始化事务表、 脏页表和打开文件表，以便它们可以用于恢复过程。       使用<xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A>方法，可以移除最近写入的重新开始区域。</xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "最接近日志末尾的重新开始区域的序列号。"
  overload: System.IO.Log.LogRecordSequence.RestartSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "在序列已释放的之后，已访问属性。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.RetryAppend
  id: RetryAppend
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: RetryAppend
  nameWithType: LogRecordSequence.RetryAppend
  fullName: System.IO.Log.LogRecordSequence.RetryAppend
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "获取或设置一个值，该值指示是否将追加如果日志已满时自动重试。"
  remarks: "如果此属性的值是`true`，和<xref:System.IO.Log.LogRecordSequence.Append%2A>调用因为序列中没有足够的空间而失败，则记录序列将尝试释放空间，然后重试追加。</xref:System.IO.Log.LogRecordSequence.Append%2A>"
  example:
  - "This example shows how to use the RetryAppend property.  \n  \n [!code-cs[S_UELogRecordSequence#3](~/add/codesnippet/csharp/p-system.io.log.logrecor_0_1.cs)]\n [!code-vb[S_UELogRecordSequence#3](~/add/codesnippet/visualbasic/p-system.io.log.logrecor_0_1.vb)]"
  syntax:
    content: public bool RetryAppend { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果追加如果日志已满，则为将自动重试否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.Log.LogRecordSequence.RetryAppend*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "在序列已释放的之后，已访问属性。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)
  id: SetLastRecord(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: SetLastRecord(SequenceNumber)
  nameWithType: LogRecordSequence.SetLastRecord(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.SetLastRecord(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "设置中的最后一条记录<xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>。"
  remarks: "指定的序列号必须大于基序列号。       此方法完成时，先前追加序列号大于指定的序列号的所有记录都都不可访问。"
  syntax:
    content: public void SetLastRecord (System.IO.Log.SequenceNumber sequenceNumber);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "在新的最后一个序列号<xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>。       这应代指当前在日志中的当前有效记录。"
  overload: System.IO.Log.LogRecordSequence.SetLastRecord*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sequenceNumber</code>不适合此序列。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "新的或现有存档尾数据或基活动日志是无效的。       - <code> sequenceNumber </code>不在此序列的基和最后一个序列号之间。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "由于出现意外的 I/O 异常，无法执行请求。       -或者-已到达日志的结尾。       -或者-指定的日志文件格式或版本无效。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.TailPinned
  id: TailPinned
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: TailPinned
  nameWithType: LogRecordSequence.TailPinned
  fullName: System.IO.Log.LogRecordSequence.TailPinned
  type: Event
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "用信号通知需要移动序列的结尾。"
  remarks: "你可以时激发此事件记录序列空间不足。 此事件激发时，尾数据的序列 （即基序列号） 将前移以释放空间。       可以随时记录序列决定，它必须释放空间，出于任何原因引发该事件。 例如，当 CLFS 策略引擎可能会决定激发事件确定时，它，两个日志客户端共享相同的日志文件的结尾相距过远。 释放空间可以通过以下任一方法写入重新开始区域，或截断日志，并使用<xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>方法清除空间来。</xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> 示例部分中的代码示例演示了第二种方法。       你还可以调用<xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A>TailPinned 事件以释放空间之外的方法。</xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> 类似于其他日志处理系统内的检查点重新开始区域。 调用此方法指示应用程序将重新开始区域彻底完成之前的所有以前的记录，并可用于将来的记录追加。 与其他任何记录类似，此方法写入的记录需要使用日志函数中的实际可用空间。"
  example:
  - "This example shows how to use the TailPinned event.  \n  \n```  \nrecordSequence.RetryAppend = true;  \nrecordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  \n  \nvoid HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  \n{  \n   // tailPinnedEventArgs.TargetSequenceNumber is the target   \n   // sequence number to free up space to.    \n   // However, this sequence number is not necessarily valid.  We have  \n   // to use this sequence number as a starting point for finding a  \n   // valid point within the log to advance toward. You need to  \n   // identify a record with a sequence number equal to, or greater  \n   // than TargetSequenceNumber; let's call this   \n   // realTargetSequenceNumber. Once found, move the base  \n  \n   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  \n  \n}  \n```"
  syntax:
    content: public event EventHandler<System.IO.Log.TailPinnedEventArgs> TailPinned;
    return:
      type: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  id: WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "写入重新开始区域写入<xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>。 此方法不能被继承。"
  remarks: "重新开始区域用于临时存储包含客户端的最后一个检查点操作的信息。 公用日志文件系统 (CLFS) 维护两个重新开始区域，以确保至少一个有效区域总是可用。 需要恢复时，CLFS 最后一个检查点操作中读取其重新开始区域和所有数据。 此数据将初始化事务表、 脏页表和打开文件表，以便它们可以用于恢复过程。       可以使用读取重新开始区域<xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       字节数组段中的数据将连接成单个字节数组，以便以记录形式追加。 数据将重新拆分为数组段读取重新开始区域时不进行任何设置。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "将连接在一起并以记录形式追加数组段。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "重新开始区域写入的序列号。"
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "写入重新开始区域时出现 I/O 错误。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列无法获得足够的可用空间以包含新的重新开始区域。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一个或多个参数<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "写入重新开始区域写入<xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>。 此方法不能被继承。"
  remarks: "重新开始区域用于临时存储包含客户端的最后一个检查点操作的信息。 公用日志文件系统 (CLFS) 维护两个重新开始区域，以确保至少一个有效区域总是可用。 需要恢复时，CLFS 最后一个检查点操作中读取其重新开始区域和所有数据。 此数据将初始化事务表、 脏页表和打开文件表，以便它们可以用于恢复过程。       可以使用读取重新开始区域<xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       字节数组段中的数据将连接成单个字节数组，以便以记录形式追加。 数据将重新拆分为数组段读取重新开始区域时不进行任何设置。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "重新开始区域写入的序列号。"
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "写入重新开始区域时出现 I/O 错误。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列无法获得足够的可用空间以包含新的重新开始区域。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一个或多个参数<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "写入重新开始区域写入<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>并更新基序列号。 此方法不能被继承。"
  remarks: "重新开始区域用于临时存储包含客户端的最后一个检查点操作的信息。 公用日志文件系统 (CLFS) 维护两个重新开始区域，以确保至少一个有效区域总是可用。 需要恢复时，CLFS 最后一个检查点操作中读取其重新开始区域和所有数据。 此数据将初始化事务表、 脏页表和打开文件表，以便它们可以用于恢复过程。       可以使用读取重新开始区域<xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       重新开始区域写入时，字节数组段中的数据将连接成单个字节数组，以便以记录形式追加。 数据将重新拆分为数组段读取重新开始区域时不进行任何设置。       此方法成功完成时，基序列号已更新。 其所有日志记录序列号小于新的基序列号都不可访问。       如果记录序列已经释放，或者如果传递了无效自变量，将立即引发异常，此操作内。 例如，I/O 请求过程中的磁盘故障异步追加请求过程中发生的错误将导致在时引发异常<xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>调用方法。</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "新的基序列号。 指定的序列号必须大于或等于当前基序列号。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "重新开始区域写入的序列号。"
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "写入重新开始区域时出现 I/O 错误。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列无法获得足够的可用空间以包含新的重新开始区域。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "写入重新开始区域写入<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>并更新基序列号。 此方法不能被继承。"
  remarks: "重新开始区域用于临时存储包含客户端的最后一个检查点操作的信息。 公用日志文件系统 (CLFS) 维护两个重新开始区域，以确保至少一个有效区域总是可用。 需要恢复时，CLFS 最后一个检查点操作中读取其重新开始区域和所有数据。 此数据将初始化事务表、 脏页表和打开文件表，以便它们可以用于恢复过程。       可以使用读取重新开始区域<xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       重新开始区域写入时，字节数组段中的数据将连接成单个字节数组，以便以记录形式追加。 数据将重新拆分为数组段读取重新开始区域时不进行任何设置。       此方法成功完成时，基序列号已更新。 其所有日志记录序列号小于新的基序列号都不可访问。       如果记录序列已经释放，或者如果传递了无效自变量，将立即引发异常，此操作内。 例如，I/O 请求过程中的磁盘故障异步追加请求过程中发生的错误将导致在时引发异常<xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>调用方法。</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "新的基序列号。 指定的序列号必须大于或等于当前基序列号。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "重新开始区域写入的序列号。"
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "写入重新开始区域时出现 I/O 错误。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列无法获得足够的可用空间以包含新的重新开始区域。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "写入重新开始区域写入<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>使用的保留，并更新基序列号。 此方法不能被继承。"
  remarks: "重新开始区域用于临时存储包含客户端的最后一个检查点操作的信息。 公用日志文件系统 (CLFS) 维护两个重新开始区域，以确保至少一个有效区域总是可用。 需要恢复时，CLFS 最后一个检查点操作中读取其重新开始区域和所有数据。 此数据将初始化事务表、 脏页表和打开文件表，以便它们可以用于恢复过程。       可以使用读取重新开始区域<xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       重新开始区域写入时，字节数组段中的数据将连接成单个字节数组，以便以记录形式追加。 数据将重新拆分为数组段读取重新开始区域时不进行任何设置。       如果指定了保留，写入的重新开始区域将占用先前已保留，使用集合中包含的保留的空间。 如果该方法成功，它将占用能容纳数据，并保留将从集合中移除的最小保留。       此方法成功完成时，基序列号已更新。 其所有日志记录序列号小于新的基序列号都不可访问。       如果记录序列已经释放，或者如果传递了无效自变量，将立即引发异常，此操作内。 例如，I/O 请求过程中的磁盘故障异步追加请求过程中发生的错误将导致在时引发异常<xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>调用方法。</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "新的基序列号。 指定的序列号必须大于或等于当前基序列号。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> ，它包含应当用于此重新开始区域的保留。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "重新开始区域写入的序列号。"
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "写入重新开始区域时出现 I/O 错误。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列无法获得足够的可用空间以包含新的重新开始区域。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "写入重新开始区域写入<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>使用的保留，并更新基序列号。 此方法不能被继承。"
  remarks: "重新开始区域用于临时存储包含客户端的最后一个检查点操作的信息。 公用日志文件系统 (CLFS) 维护两个重新开始区域，以确保至少一个有效区域总是可用。 需要恢复时，CLFS 最后一个检查点操作中读取其重新开始区域和所有数据。 此数据将初始化事务表、 脏页表和打开文件表，以便它们可以用于恢复过程。       可以使用读取重新开始区域<xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       重新开始区域写入时，字节数组段中的数据将连接成单个字节数组，以便以记录形式追加。 数据将重新拆分为数组段读取重新开始区域时不进行任何设置。       如果指定了保留，写入的重新开始区域将占用先前已保留，使用集合中包含的保留的空间。 如果该方法成功，它将占用能容纳数据，并保留将从集合中移除的最小保留。       此方法成功完成时，基序列号已更新。 其所有日志记录序列号小于新的基序列号都不可访问。       如果记录序列已经释放，或者如果传递了无效自变量，将立即引发异常，此操作内。 例如，I/O 请求过程中的磁盘故障异步追加请求过程中发生的错误将导致在时引发异常<xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>调用方法。</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "新的基序列号。 指定的序列号必须大于或等于当前基序列号。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> ，它包含应当用于此重新开始区域的保留。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "重新开始区域写入的序列号。"
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>不适合此序列。       -或者-指定的日志枚举开始序列号无效。       -或-<code>data</code>由于它大于最大记录大小，因此无法追加。       -或-<code>reservationCollection</code>不是由此记录序列。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一个或多个参数是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "新的或现有存档尾数据或基活动日志是无效的。       - <code> newBaseSeqNum </code>不在此序列的基和最后一个序列号之间。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "由于出现意外的 I/O 异常，无法执行请求。       -或者-由于出现 I/O 设备错误，无法执行请求。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志序列的访问被拒绝由操作系统。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列已满。"
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IO.Log.SequenceFullException
  parent: System.IO.Log
  isExternal: false
  name: SequenceFullException
  nameWithType: SequenceFullException
  fullName: System.IO.Log.SequenceFullException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.IO.Log.ReservationNotFoundException
  parent: System.IO.Log
  isExternal: false
  name: ReservationNotFoundException
  nameWithType: ReservationNotFoundException
  fullName: System.IO.Log.ReservationNotFoundException
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(LogStore)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore)
- uid: System.IO.Log.LogStore
  parent: System.IO.Log
  isExternal: false
  name: LogStore
  nameWithType: LogStore
  fullName: System.IO.Log.LogStore
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.FileMode
  parent: System.IO
  isExternal: false
  name: FileMode
  nameWithType: FileMode
  fullName: System.IO.FileMode
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(LogStore,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
- uid: System.IO.FileShare
  parent: System.IO
  isExternal: false
  name: FileShare
  nameWithType: FileShare
  fullName: System.IO.FileShare
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
- uid: System.Security.AccessControl.FileSecurity
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSecurity
  nameWithType: FileSecurity
  fullName: System.Security.AccessControl.FileSecurity
- uid: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
- uid: System.IO.Log.SequenceNumber
  parent: System.IO.Log
  isExternal: false
  name: SequenceNumber
  nameWithType: SequenceNumber
  fullName: System.IO.Log.SequenceNumber
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.ArraySegment{System.Byte}
  parent: System
  isExternal: true
  name: ArraySegment<Byte>
  nameWithType: ArraySegment<Byte>
  fullName: System.ArraySegment<System.Byte>
  spec.csharp:
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.RecordAppendOptions
  parent: System.IO.Log
  isExternal: false
  name: RecordAppendOptions
  nameWithType: RecordAppendOptions
  fullName: System.IO.Log.RecordAppendOptions
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
  parent: System.Collections.Generic
  isExternal: true
  name: IList<ArraySegment<Byte>>
  nameWithType: IList<ArraySegment<Byte>>
  fullName: System.Collections.Generic.IList<System.ArraySegment<System.Byte>>
  spec.csharp:
  - uid: System.Collections.Generic.IList`1
    name: IList
    nameWithType: IList
    fullName: IList<System.ArraySegment<System.Byte>>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.ReservationCollection
  parent: System.IO.Log
  isExternal: false
  name: ReservationCollection
  nameWithType: ReservationCollection
  fullName: System.IO.Log.ReservationCollection
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.LogRecordSequence.BaseSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: LogRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.Int64[]
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64[]
  spec.csharp:
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: Int64[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.CreateReservationCollection
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: CreateReservationCollection()
  nameWithType: LogRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.LogRecordSequence.CreateReservationCollection()
- uid: System.IO.Log.LogRecordSequence.Dispose
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Dispose()
  nameWithType: LogRecordSequence.Dispose()
  fullName: System.IO.Log.LogRecordSequence.Dispose()
- uid: System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndAppend(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndFlush(IAsyncResult)
  nameWithType: LogRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndFlush(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndReserveAndAppend(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: LogRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndWriteRestartArea(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.Flush
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Flush()
  nameWithType: LogRecordSequence.Flush()
  fullName: System.IO.Log.LogRecordSequence.Flush()
- uid: System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Flush(SequenceNumber)
  nameWithType: LogRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.Flush(SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.LastSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: LogRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.LastSequenceNumber
- uid: System.IO.Log.LogRecordSequence.LogStore
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogStore
  nameWithType: LogRecordSequence.LogStore
  fullName: System.IO.Log.LogRecordSequence.LogStore
- uid: System.IO.Log.LogRecordSequence.MaximumRecordLength
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: LogRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.LogRecordSequence.MaximumRecordLength
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
- uid: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<LogRecord>
  nameWithType: IEnumerable<LogRecord>
  fullName: System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.IO.Log.LogRecord>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.LogRecord
    name: LogRecord
    nameWithType: LogRecord
    fullName: LogRecord
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordEnumeratorType
  parent: System.IO.Log
  isExternal: false
  name: LogRecordEnumeratorType
  nameWithType: LogRecordEnumeratorType
  fullName: System.IO.Log.LogRecordEnumeratorType
- uid: System.IO.Log.LogRecordSequence.ReadRestartAreas
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadRestartAreas()
  nameWithType: LogRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.LogRecordSequence.ReadRestartAreas()
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.LogRecordSequence.ReservedBytes
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: LogRecordSequence.ReservedBytes
  fullName: System.IO.Log.LogRecordSequence.ReservedBytes
- uid: System.IO.Log.LogRecordSequence.RestartSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: LogRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.LogRecordSequence.RetryAppend
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: LogRecordSequence.RetryAppend
  fullName: System.IO.Log.LogRecordSequence.RetryAppend
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: SetLastRecord(SequenceNumber)
  nameWithType: LogRecordSequence.SetLastRecord(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.SetLastRecord(SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.TailPinned
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: TailPinned
  nameWithType: LogRecordSequence.TailPinned
  fullName: System.IO.Log.LogRecordSequence.TailPinned
- uid: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<TailPinnedEventArgs>
  nameWithType: EventHandler<TailPinnedEventArgs>
  fullName: System.EventHandler<System.IO.Log.TailPinnedEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.IO.Log.TailPinnedEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.TailPinnedEventArgs
    name: TailPinnedEventArgs
    nameWithType: TailPinnedEventArgs
    fullName: TailPinnedEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.LogRecordSequence.#ctor*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence
  nameWithType: LogRecordSequence.LogRecordSequence
- uid: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber
  nameWithType: LogRecordSequence.AdvanceBaseSequenceNumber
- uid: System.IO.Log.LogRecordSequence.Append*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append
  nameWithType: LogRecordSequence.Append
- uid: System.IO.Log.LogRecordSequence.BaseSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: LogRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.LogRecordSequence.BeginAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend
  nameWithType: LogRecordSequence.BeginAppend
- uid: System.IO.Log.LogRecordSequence.BeginFlush*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginFlush
  nameWithType: LogRecordSequence.BeginFlush
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginReserveAndAppend
  nameWithType: LogRecordSequence.BeginReserveAndAppend
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginWriteRestartArea
  nameWithType: LogRecordSequence.BeginWriteRestartArea
- uid: System.IO.Log.LogRecordSequence.CreateReservationCollection*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: CreateReservationCollection
  nameWithType: LogRecordSequence.CreateReservationCollection
- uid: System.IO.Log.LogRecordSequence.Dispose*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Dispose
  nameWithType: LogRecordSequence.Dispose
- uid: System.IO.Log.LogRecordSequence.EndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndAppend
  nameWithType: LogRecordSequence.EndAppend
- uid: System.IO.Log.LogRecordSequence.EndFlush*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndFlush
  nameWithType: LogRecordSequence.EndFlush
- uid: System.IO.Log.LogRecordSequence.EndReserveAndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndReserveAndAppend
  nameWithType: LogRecordSequence.EndReserveAndAppend
- uid: System.IO.Log.LogRecordSequence.EndWriteRestartArea*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndWriteRestartArea
  nameWithType: LogRecordSequence.EndWriteRestartArea
- uid: System.IO.Log.LogRecordSequence.Flush*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Flush
  nameWithType: LogRecordSequence.Flush
- uid: System.IO.Log.LogRecordSequence.LastSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: LogRecordSequence.LastSequenceNumber
- uid: System.IO.Log.LogRecordSequence.LogStore*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogStore
  nameWithType: LogRecordSequence.LogStore
- uid: System.IO.Log.LogRecordSequence.MaximumRecordLength*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: LogRecordSequence.MaximumRecordLength
- uid: System.IO.Log.LogRecordSequence.ReadLogRecords*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadLogRecords
  nameWithType: LogRecordSequence.ReadLogRecords
- uid: System.IO.Log.LogRecordSequence.ReadRestartAreas*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadRestartAreas
  nameWithType: LogRecordSequence.ReadRestartAreas
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReserveAndAppend
  nameWithType: LogRecordSequence.ReserveAndAppend
- uid: System.IO.Log.LogRecordSequence.ReservedBytes*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: LogRecordSequence.ReservedBytes
- uid: System.IO.Log.LogRecordSequence.RestartSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: LogRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.LogRecordSequence.RetryAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: LogRecordSequence.RetryAppend
- uid: System.IO.Log.LogRecordSequence.SetLastRecord*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: SetLastRecord
  nameWithType: LogRecordSequence.SetLastRecord
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea
  nameWithType: LogRecordSequence.WriteRestartArea
