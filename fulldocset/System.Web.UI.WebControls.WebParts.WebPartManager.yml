### YamlMime:ManagedReference
items:
- uid: System.Web.UI.WebControls.WebParts.WebPartManager
  id: WebPartManager
  children:
  - System.Web.UI.WebControls.WebParts.WebPartManager.#ctor
  - System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections
  - System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)
  - System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart
  - System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers
  - System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)
  - System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)
  - System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode
  - System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)
  - System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)
  - System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode
  - System.Web.UI.WebControls.WebParts.WebPartManager.CheckRenderClientScript
  - System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning
  - System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)
  - System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode
  - System.Web.UI.WebControls.WebParts.WebPartManager.Connections
  - System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated
  - System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating
  - System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)
  - System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)
  - System.Web.UI.WebControls.WebParts.WebPartManager.Controls
  - System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart(System.Web.UI.WebControls.WebParts.WebPart)
  - System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers
  - System.Web.UI.WebControls.WebParts.WebPartManager.CreateControlCollection
  - System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes
  - System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID
  - System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)
  - System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)
  - System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization
  - System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)
  - System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning
  - System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)
  - System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode
  - System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)
  - System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)
  - System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode
  - System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged
  - System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging
  - System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes
  - System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections
  - System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode
  - System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript
  - System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming
  - System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting
  - System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing
  - System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning
  - System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)
  - System.Web.UI.WebControls.WebParts.WebPartManager.Focus
  - System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)
  - System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager(System.Web.UI.Page)
  - System.Web.UI.WebControls.WebParts.WebPartManager.GetDisplayTitle(System.Web.UI.WebControls.WebParts.WebPart)
  - System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl(System.Web.UI.WebControls.WebParts.WebPart)
  - System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart(System.Web.UI.Control)
  - System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)
  - System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)
  - System.Web.UI.WebControls.WebParts.WebPartManager.Internals
  - System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Web.UI.WebControls.WebParts.WebPart)
  - System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)
  - System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty
  - System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState(System.Object)
  - System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)
  - System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet
  - System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet
  - System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)
  - System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)
  - System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)
  - System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)
  - System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)
  - System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)
  - System.Web.UI.WebControls.WebParts.WebPartManager.OnInit(System.EventArgs)
  - System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender(System.EventArgs)
  - System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)
  - System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)
  - System.Web.UI.WebControls.WebParts.WebPartManager.OnUnload(System.EventArgs)
  - System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)
  - System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)
  - System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)
  - System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)
  - System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)
  - System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)
  - System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)
  - System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)
  - System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)
  - System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)
  - System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)
  - System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)
  - System.Web.UI.WebControls.WebParts.WebPartManager.Personalization
  - System.Web.UI.WebControls.WebParts.WebPartManager.RegisterClientScript
  - System.Web.UI.WebControls.WebParts.WebPartManager.Render(System.Web.UI.HtmlTextWriter)
  - System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState
  - System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)
  - System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart
  - System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged
  - System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging
  - System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty
  - System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)
  - System.Web.UI.WebControls.WebParts.WebPartManager.SkinID
  - System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections
  - System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes
  - System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty
  - System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)
  - System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)
  - System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState
  - System.Web.UI.WebControls.WebParts.WebPartManager.Visible
  - System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded
  - System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding
  - System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed
  - System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing
  - System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted
  - System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting
  - System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved
  - System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving
  - System.Web.UI.WebControls.WebParts.WebPartManager.WebParts
  - System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected
  - System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting
  - System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected
  - System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting
  - System.Web.UI.WebControls.WebParts.WebPartManager.Zones
  langs:
  - csharp
  name: WebPartManager
  nameWithType: WebPartManager
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager
  type: Class
  summary: "用作 Web 部件控件集，管理所有 Web 部件控件、 功能和网页发生的事件的中心类。"
  remarks: "将控件充当 Web 部件应用程序的中心或控制中心。 必须有一个且只能是一个-人员使用 Web 部件控件的每一页上的控件实例。 与的 Web 部件应用程序的大多数方面，人员控件仅适用于经过身份验证的用户。 此外，其功能几乎完全使用驻留在继承<xref:System.Web.UI.WebControls.WebParts.WebZone>类</xref:System.Web.UI.WebControls.WebParts.WebZone>的 Web 部件区域内的服务器控件的工作原理 驻留在这些区域之外的页的服务器控件可以具有很少 Web 部件功能或具有人员控件交互。       作为页上的 Web 部件功能的中心，人员控件可执行的下表中所述的任务类型。      |任务类别 |控件的作用 |  |-------------------|---------------------------|  |跟踪 Web 部件控件 |将跟踪的页面上提供了 Web 部件功能，包括<xref:System.Web.UI.WebControls.WebParts.WebPart>控件、 连接、 区域和其他的控件的许多不同类型。 |  |添加和删除 Web 部件控件 |提供用于添加、 删除和关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>页面上的控件的方法。 |  |管理连接 |创建控件，之间的连接并监视连接，以及添加和删除它们的进程。 |  |个性化控件和页 |使用户能够将控件移至不同的位置，在页中，并将启动用户可以在其中编辑外观、 属性和控件的行为的视图。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPart> 维护每一页上的特定于用户的个性化设置。 |  |不同的页视图之间切换 |切换不同的页上，专用视图之间的页，以便用户可以执行某些任务，例如更改页面布局或编辑控件。 |  |引发 Web 部件生命周期事件 |定义引发，并使开发人员能够处理的 Web 部件控件，例如当控件在添加、 移动、 已连接，或删除的生命周期事件。 |  |启用导入和导出控件 |导出包含<xref:System.Web.UI.WebControls.WebParts.WebPart>控件的属性的状态的 XML 流，并允许用户方便起见，在对其他页或站点中的复杂控件进行个性化设置的文件中导入。 |      将类具有大量的属性。</xref:System.Web.UI.WebControls.WebParts.WebPart> 与跟踪其他控件的人员角色一致，它具有多个引用的 Web 部件控件或其他特殊的 Web 部件对象集合的属性。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>，和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>属性都是由人员控件用于其跟踪和其他管理任务的所有集合。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A>       另一组属性包含在 Web 部件应用中发生的某些方案中应用的可自定义警告。 其中包括<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>，和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A>属性。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>       将类重写一些由许多 Web 服务器控件使用其基继承属性。 其中包括<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A>，和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A>属性。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A>       最后，没有可用于访问应用程序的当前状态的一组属性。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>属性指示的页是单元的当前显示模式</xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A>属性指示是否允许控件呈现客户端脚本，它是相关的情况下可能具有不同的功能的浏览器或具有脚本没有关闭用户的位置</xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>属性都引用包含对许多重要的扩展性情况下使用的 Web 部件方法调用一个实用工具类很有用。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> 通过隐藏对一个单独的类中的这些方法的调用 (<xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals>类)，将类拥有简化 API。</xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>属性提供访问权限的个性化设置对象，用于存储用户的个性化设置和数据保存到永久存储。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>属性指示其<xref:System.Web.UI.WebControls.WebParts.WebPart>用户或应用程序当前选择页上的控件。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>属性指示是否在自定义个性化数据<xref:System.Web.UI.WebControls.WebParts.WebPart>控制已更改。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>       将控件包含五个内置的显示模式或网页的视图。 开发人员可以扩展此功能，通过扩展类型，例如<xref:System.Web.UI.WebControls.WebParts.WebZone>类或<xref:System.Web.UI.WebControls.WebParts.ToolZone>类</xref:System.Web.UI.WebControls.WebParts.ToolZone></xref:System.Web.UI.WebControls.WebParts.WebZone>创建自定义显示模式 用户可以将页切换到不同的显示模式中，假设的适当类型的对应于给定的显示模式的控件出现在页面上。      1> [!NOTE]&1;> 可以扩展此功能，以便用户可以切换到自定义显示模式，而无页上的相应区域。 但是，默认行为是显示模式对应区域。       标准显示模式表示由人员类中的公共字段。 下表总结了字段和其所指的显示模式。 页的当前显示模式如上所述，始终在中引用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>属性和可以在给定的种类的页，存在的区域的特定页的显示模式集包含在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>属性。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>      |字段 |显示模式的详细信息 |  |-----------|--------------------------|  |<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>|Web 页; 的普通用户视图默认和最常见的显示模式。 |  |<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>|用户可以重新排列或删除控件，若要更改页面布局视图。 |  |<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>|该视图在其中编辑的用户界面 (UI) 变得可见，则用户可以编辑外观、 属性和行为的控件的正常浏览模式中可见。 |  |<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>|该视图中的目录用户界面变得可见，则用户可以从目录的可用控件向页面添加控件。 |  |<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>|在其中连接 UI 变得可见，则该视图用户可以连接、 管理或断开控件之间的连接。 |      将控件还包含在 Web 部件页面和控件的生命周期中非常重要的事件数。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> 这些事件提供对 Web 部件控件的行为的精确进行编程控制。 大多数方法适用于<xref:System.Web.UI.WebControls.WebParts.WebPart>控件 (或位于其他服务器或用户控件<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域，以便它们可以充当<xref:System.Web.UI.WebControls.WebParts.WebPart>控件)。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> </xref:System.Web.UI.WebControls.WebParts.WebPart> 但是，有些事件有关的页面或页上的连接状态。 下表列出了可用的事件，并总结了它们的用途。      1> [!NOTE]&1;> 在下表中的所有情况下，&quot;控件&quot;一词是指<xref:System.Web.UI.WebControls.WebParts.WebPart>控件或任何服务器控件位于某个区域中，使用包装<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>在运行时的对象。</xref:System.Web.UI.WebControls.WebParts.GenericWebPart> </xref:System.Web.UI.WebControls.WebParts.WebPart>      |事件 |说明 |  |-----------|-----------------|  |<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>|恰好在将控件添加到页上，以确认它是否授权之前发生。 |  |<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>|在页面上的所有连接已都激活后发生。 |  |<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>|恰好在激活页上的所有连接的过程之前发生。 |  |<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged>|页的当前显示模式更改后发生。 |  |<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging>|更改页面的显示模式的过程之前发生。 |  |<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>|已取消所选内容的控件后发生。 |  |<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>|取消所选控件的内容的过程之前发生。 |  |<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>|控件添加到区域后发生。 |  |<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding>|恰好在将控件添加到区域的过程之前发生。 |  |<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>|控件已关闭 （从页中移除） 后发生。 |  |<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>|恰好在关闭控件的过程之前发生。 |  |<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>|永久删除动态控件 （一种以编程方式创建或添加从目录） 的实例后发生。 |  |<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>|恰好在删除动态控件的过程之前发生。 |  |<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>|控件具有在其区域内移动或移动到另一个区域后发生。 |  |<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>|恰好在移动控件的过程之前发生。 |  |<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>|两个控件选择来参与连接建立连接后发生。 |  |<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>|连接两个控件的过程之前发生。 |  |<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>|已断开连接的两个控件后发生。 |  |<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>|恰好在断开连接两个控件的过程之前发生。 |      将在控件有许多用于管理 Web 部件页方法。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 此处未列出的方法一大组是其名称采用的形式在方法*EventName*。 这些方法通常引发其关联的事件，并提供与类型<xref:System.Web.UI.WebControls.WebParts.WebPartEventHandler>.</xref:System.Web.UI.WebControls.WebParts.WebPartEventHandler>处理程序的事件 由开发人员从人员类继承，可以重写这些方法中的大多数。 此外，页开发人员可以使用这些方法关联的事件提供自定义处理程序。 例如中的情况下<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>事件，无法添加页开发人员`OnWebPartAdded`属性设为`<asp:webpartmanager>`以及 Web 页上，然后分配自定义的方法名称添加到该属性提供的事件自定义处理标记中的元素。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> 属性对应于<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A>方法和事件处理大多数 Web 部件事件和其关联的方法的工作方式此基本模式。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A>       此外，将控件具有方法特定于的管理任务<xref:System.Web.UI.WebControls.WebParts.WebPart>控件 (和服务器或用户控件用作<xref:System.Web.UI.WebControls.WebParts.WebPart>控件)。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPart> These methods include <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>, and <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>.</xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A></xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A></xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A></xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A></xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A></xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A></xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A></xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A></xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A></xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A></xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A></xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A></xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart></xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>       另一组方法专用于连接。 This includes methods such as <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>, and <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>.</xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A></xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A></xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A></xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A></xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A></xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A></xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A></xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A></xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A></xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>       最后，某些人员方法专注于个性化功能。 These include <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A>, and <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A>.</xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A></xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A></xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A></xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A></xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A></xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A></xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A>       有关详细信息的其他人员方法的访问通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>属性，请参阅的文档<xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals>类。</xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>"
  example:
  - "The following code example demonstrates both declarative and programmatic use of the WebPartManager control.  \n  \n The code example has four parts:  \n  \n-   A user control that enables you to change display modes on a Web Parts page.  \n  \n-   A Web page that contains two custom <xref:System.Web.UI.WebControls.WebParts.WebPart> controls that can be connected, and an `<asp:webpartmanager>` element.  \n  \n-   A source code file that contains two custom <xref:System.Web.UI.WebControls.WebParts.WebPart> controls, and a custom interface.  \n  \n-   An explanation of how the example works in a browser.  \n  \n The user control has a drop-down list control that shows the possible display modes on a page, given the Web Parts controls that are present on the page. In the Web page for this code example, this user control is declared just below the WebPartManager element in the page's markup, and there is a `Register` directive near the top of the Web page to register the control. For details about display modes and a description of the source code in this control, see [Walkthrough: Changing Display Modes on a Web Parts Page](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[WebParts_WebPartManager_SimpleConnection#6](~/add/codesnippet/csharp/t-system.web.ui.webcontr_345_1.ascx)]\n [!code-vb[WebParts_WebPartManager_SimpleConnection#6](~/add/codesnippet/visualbasic/t-system.web.ui.webcontr_345_1.ascx)]  \n  \n The declarative markup for the Web page contains `Register` directives for both the user control and the custom controls. There is an `<asp:webpartmanager>` element, an `<asp:webpartzone>` element to contain the custom controls, and an `<asp:connectionszone>` element. The page also contains some inline code that handles connection-related events for the WebPartManager control; you can see the effect of this code as you connect and disconnect controls.  \n  \n [!code-cs[WebParts_WebPartManager_SimpleConnection#1](~/add/codesnippet/csharp/t-system.web.ui.webcontr_345_2.aspx)]\n [!code-vb[WebParts_WebPartManager_SimpleConnection#1](~/add/codesnippet/visualbasic/t-system.web.ui.webcontr_345_2.aspx)]  \n  \n The third part of the example is the source code for the controls. Note that there is an interface named `IZipCode`, and this interface is implemented in the `ZipCodeWebPart` class. This class has a special callback method named `ProvideIZipCode` that serves as a provider. The other type, named `WeatherWebPart`, is also implemented with a special method named `GetIZipCode`, which enables the control to act as a consumer of the other control.  \n  \n For the code example to run, you must compile this source code. You can compile it explicitly and put the resulting assembly in your Web site's Bin folder or the global assembly cache. Alternatively, you can put the source code in your site's App_Code folder, where it will be dynamically compiled at run time. This code example assumes that you have compiled the source into an assembly, and the `Register` directive in the Web page references the assembly name. For a walkthrough that demonstrates how to compile, see [Walkthrough: Developing and Using a Custom Web Server Control](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[WebParts_WebPartManager_SimpleConnection#2](~/add/codesnippet/csharp/t-system.web.ui.webcontr_345_3.cs)]\n [!code-vb[WebParts_WebPartManager_SimpleConnection#2](~/add/codesnippet/visualbasic/t-system.web.ui.webcontr_345_3.vb)]  \n  \n After you have loaded the Web page in a browser, click the **Display Mode** drop-down list control and select **Connect** to switch the page to connect mode. Connect mode uses the `<asp:connectionszone>` element to enable you to create connections between controls. In connect mode, click the downward arrow in the title bar of the **ZIP Code** control to activate its verbs menu, and then click **Connect**. After the connection UI appears, click the **Create a connection to a Consumer** link. A cell appears that has a drop-down list control. Select **Weather Control** in the drop-down list, and then click **Connect** to complete the connection of the two controls. Click **Close**, and then use the **Display Mode** drop-down list to return the page to normal browse mode. You can enter a ZIP Code, and the consumer control will be updated with the value you enter. Because the `ZipCode` property was marked with the `Personalizable` attribute in the source code, this property value will persist across browser sessions, thus saving the value entered by a user. A more sophisticated consumer control could take the ZIP code information, look up weather information based on the code, and display it to a user."
  syntax:
    content: >-
      [System.ComponentModel.Bindable(false)]

      [System.ComponentModel.Designer("System.Web.UI.Design.WebControls.WebParts.WebPartManagerDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      [System.Web.UI.NonVisualControl]

      [System.Web.UI.ParseChildren(true)]

      [System.Web.UI.PersistChildren(false)]

      [System.Web.UI.ViewStateModeById]

      public class WebPartManager : System.Web.UI.Control, System.Web.UI.INamingContainer, System.Web.UI.WebControls.WebParts.IPersonalizable
  inheritance:
  - System.Object
  - System.Web.UI.Control
  implements:
  - System.Web.UI.INamingContainer
  - System.Web.UI.WebControls.WebParts.IPersonalizable
  inheritedMembers:
  - System.Web.UI.Control.Adapter
  - System.Web.UI.Control.AddedControl(System.Web.UI.Control,System.Int32)
  - System.Web.UI.Control.AddParsedSubObject(System.Object)
  - System.Web.UI.Control.ApplyStyleSheetSkin(System.Web.UI.Page)
  - System.Web.UI.Control.AppRelativeTemplateSourceDirectory
  - System.Web.UI.Control.BeginRenderTracing(System.IO.TextWriter,System.Object)
  - System.Web.UI.Control.BindingContainer
  - System.Web.UI.Control.BuildProfileTree(System.String,System.Boolean)
  - System.Web.UI.Control.ChildControlsCreated
  - System.Web.UI.Control.ClearCachedClientID
  - System.Web.UI.Control.ClearChildControlState
  - System.Web.UI.Control.ClearChildState
  - System.Web.UI.Control.ClearChildViewState
  - System.Web.UI.Control.ClearEffectiveClientIDMode
  - System.Web.UI.Control.ClientID
  - System.Web.UI.Control.ClientIDMode
  - System.Web.UI.Control.ClientIDSeparator
  - System.Web.UI.Control.Context
  - System.Web.UI.Control.CreateChildControls
  - System.Web.UI.Control.DataBind
  - System.Web.UI.Control.DataBind(System.Boolean)
  - System.Web.UI.Control.DataBindChildren
  - System.Web.UI.Control.DataBinding
  - System.Web.UI.Control.DataItemContainer
  - System.Web.UI.Control.DataKeysContainer
  - System.Web.UI.Control.DesignMode
  - System.Web.UI.Control.Dispose
  - System.Web.UI.Control.Disposed
  - System.Web.UI.Control.EnableViewState
  - System.Web.UI.Control.EndRenderTracing(System.IO.TextWriter,System.Object)
  - System.Web.UI.Control.EnsureChildControls
  - System.Web.UI.Control.EnsureID
  - System.Web.UI.Control.Events
  - System.Web.UI.Control.FindControl(System.String)
  - System.Web.UI.Control.FindControl(System.String,System.Int32)
  - System.Web.UI.Control.GetDesignModeState
  - System.Web.UI.Control.GetRouteUrl(System.Object)
  - System.Web.UI.Control.GetRouteUrl(System.String,System.Object)
  - System.Web.UI.Control.GetRouteUrl(System.String,System.Web.Routing.RouteValueDictionary)
  - System.Web.UI.Control.GetRouteUrl(System.Web.Routing.RouteValueDictionary)
  - System.Web.UI.Control.GetUniqueIDRelativeTo(System.Web.UI.Control)
  - System.Web.UI.Control.HasChildViewState
  - System.Web.UI.Control.HasControls
  - System.Web.UI.Control.HasEvents
  - System.Web.UI.Control.ID
  - System.Web.UI.Control.IdSeparator
  - System.Web.UI.Control.Init
  - System.Web.UI.Control.IsChildControlStateCleared
  - System.Web.UI.Control.IsLiteralContent
  - System.Web.UI.Control.IsTrackingViewState
  - System.Web.UI.Control.IsViewStateEnabled
  - System.Web.UI.Control.Load
  - System.Web.UI.Control.LoadViewState(System.Object)
  - System.Web.UI.Control.LoadViewStateByID
  - System.Web.UI.Control.MapPathSecure(System.String)
  - System.Web.UI.Control.NamingContainer
  - System.Web.UI.Control.OnBubbleEvent(System.Object,System.EventArgs)
  - System.Web.UI.Control.OnDataBinding(System.EventArgs)
  - System.Web.UI.Control.OnLoad(System.EventArgs)
  - System.Web.UI.Control.OpenFile(System.String)
  - System.Web.UI.Control.Page
  - System.Web.UI.Control.Parent
  - System.Web.UI.Control.PreRender
  - System.Web.UI.Control.RaiseBubbleEvent(System.Object,System.EventArgs)
  - System.Web.UI.Control.RemovedControl(System.Web.UI.Control)
  - System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)
  - System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter)
  - System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)
  - System.Web.UI.Control.RenderingCompatibility
  - System.Web.UI.Control.ResolveAdapter
  - System.Web.UI.Control.ResolveClientUrl(System.String)
  - System.Web.UI.Control.ResolveUrl(System.String)
  - System.Web.UI.Control.SaveViewState
  - System.Web.UI.Control.SetDesignModeState(System.Collections.IDictionary)
  - System.Web.UI.Control.SetRenderMethodDelegate(System.Web.UI.RenderMethod)
  - System.Web.UI.Control.SetTraceData(System.Object,System.Object)
  - System.Web.UI.Control.SetTraceData(System.Object,System.Object,System.Object)
  - System.Web.UI.Control.Site
  - System.Web.UI.Control.System#Web#UI#IControlBuilderAccessor#ControlBuilder
  - System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#GetDesignModeState
  - System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#SetDesignModeState(System.Collections.IDictionary)
  - System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#SetOwnerControl(System.Web.UI.Control)
  - System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#UserData
  - System.Web.UI.Control.System#Web#UI#IDataBindingsAccessor#DataBindings
  - System.Web.UI.Control.System#Web#UI#IDataBindingsAccessor#HasDataBindings
  - System.Web.UI.Control.System#Web#UI#IExpressionsAccessor#Expressions
  - System.Web.UI.Control.System#Web#UI#IExpressionsAccessor#HasExpressions
  - System.Web.UI.Control.System#Web#UI#IParserAccessor#AddParsedSubObject(System.Object)
  - System.Web.UI.Control.TemplateControl
  - System.Web.UI.Control.TemplateSourceDirectory
  - System.Web.UI.Control.UniqueID
  - System.Web.UI.Control.Unload
  - System.Web.UI.Control.ValidateRequestMode
  - System.Web.UI.Control.ViewState
  - System.Web.UI.Control.ViewStateIgnoresCase
  - System.Web.UI.Control.ViewStateMode
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.#ctor
  id: '#ctor'
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: WebPartManager()
  nameWithType: WebPartManager.WebPartManager()
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartManager()
  type: Constructor
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "初始化的新实例<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>类。"
  remarks: "将构造函数初始化所使用的几个重要变量<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> 直接影响所有 Web 部件页的一个分配是默认页面显示模式设置为浏览模式的事实 (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>)。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>"
  syntax:
    content: public WebPartManager ();
    parameters: []
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections
  id: ActivateConnections
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: ActivateConnections()
  nameWithType: WebPartManager.ActivateConnections()
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections()
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "使处于活动状态在网页上当前处于非活动状态的所有连接。"
  remarks: "ActivateConnections 方法调用到页上的每个请求以激活之间的现有连接<xref:System.Web.UI.WebControls.WebParts.WebPart>和驻留在其他服务器控件<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域。</xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> </xref:System.Web.UI.WebControls.WebParts.WebPart> 在某些情况下，例如，如果存在冲突的连接被激活，则此方法中反过来调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法来结束有问题的连接。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 断开连接的过程<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>引发事件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 通常，开发人员可以取消此事件，但在这种情况，这是不能取消的连接中冲突，因为<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件需要为了完成激活连接的过程中解决该冲突。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> 有关详细信息，请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>"
  syntax:
    content: protected virtual void ActivateConnections ();
    parameters: []
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)
  id: AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: AddWebPart(WebPart,WebPartZoneBase,Int32)
  nameWithType: WebPartManager.AddWebPart(WebPart,WebPartZoneBase,Int32)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(WebPart,WebPartZoneBase,Int32)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "提供标准的编程方法来添加<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>到网页上的控件。"
  remarks: "使用 AddWebPart 方法同时添加新的动态<xref:System.Web.UI.WebControls.WebParts.WebPart>控制到页中，并重新打开以前已关闭在页面上的静态或动态控件。</xref:System.Web.UI.WebControls.WebParts.WebPart> 当调用该方法时若要添加新控件时，它实际创建一份所引用的控件`webPart`参数。 一个新的 ID 生成的控件，复制，因此，开发人员应引用<xref:System.Web.UI.WebControls.WebParts.WebPart>从要获取新的 ID 值的方法返回的控件。</xref:System.Web.UI.WebControls.WebParts.WebPart> 当调用方法以重新打开以前关闭的控件时，它将返回对所引用的控件的直接引用`webPart`参数。      1> [!IMPORTANT]&1;> 应始终使用 AddWebPart 方法，而不是<xref:System.Web.UI.ControlCollection.Add%2A>方法的引用的控件的集合<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A?displayProperty=fullName>属性，以将添加<xref:System.Web.UI.WebControls.WebParts.WebPart>以编程方式控制到页中，因为使用<xref:System.Web.UI.ControlCollection.Add%2A>方法引发异常。</xref:System.Web.UI.ControlCollection.Add%2A> </xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A?displayProperty=fullName> </xref:System.Web.UI.ControlCollection.Add%2A> 若要添加不是控件<xref:System.Web.UI.WebControls.WebParts.WebPart>控件 (换而言之，一个将使用自动换行的服务器控件<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控件在运行时)，首先应调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>方法以创建该控件，然后调用 AddWebPart 方法添加控件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> </xref:System.Web.UI.WebControls.WebParts.GenericWebPart> </xref:System.Web.UI.WebControls.WebParts.WebPart> 此方法的演示，请参阅示例部分。"
  example:
  - "The following code example demonstrates use of the AddWebPart method to add a server control programmatically to a page. The page markup contains an empty `<asp:webpartzone>` element, and an `<asp:webpartmanager>` element. The first time the **Add Calendar** button is clicked, the code in the event handler creates a <xref:System.Web.UI.WebControls.Calendar> control, and adds it to a zone as a <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> object, calling the AddWebPart method.  \n  \n [!code-cs[WebParts_WebPartManager_DeleteWebPart#1](~/add/codesnippet/csharp/6da004d9-95d1-4401-9d7e-_1.aspx)]\n [!code-vb[WebParts_WebPartManager_DeleteWebPart#1](~/add/codesnippet/visualbasic/6da004d9-95d1-4401-9d7e-_1.aspx)]"
  syntax:
    content: public System.Web.UI.WebControls.WebParts.WebPart AddWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);
    parameters:
    - id: webPart
      type: System.Web.UI.WebControls.WebParts.WebPart
      description: "<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;> </xref> （或服务器或用户控件） 要添加到 Web 页或页上打开。"
    - id: zone
      type: System.Web.UI.WebControls.WebParts.WebPartZoneBase
      description: "<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartZoneBase&quot;> </xref> ，`webPart`将被添加到。"
    - id: zoneIndex
      type: System.Int32
      description: "一个整数，表示序号位置`webPart`占据了`zone`，相对于中的其他控件`zone`。"
    return:
      type: System.Web.UI.WebControls.WebParts.WebPart
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;> </xref>已添加到页面的控件。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>webPart</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>zone</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>zone</code> is not registered in the <xref href=\"System.Web.UI.WebControls.WebParts.WebPartManager\"></xref> control's collection of zones.  \n  \n \\- or -  \n  \n <code>webPart</code> is already in <code>zone</code>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "值<code> zoneIndex </code>小于零。"
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart
  id: AuthorizeWebPart
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: AuthorizeWebPart
  nameWithType: WebPartManager.AuthorizeWebPart
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart
  type: Event
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "发生时<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized*>调用方法来确定是否<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>或服务器控件可以添加到页面。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized*>"
  remarks: "每当发生 AuthorizeWebPart 事件<xref:System.Web.UI.WebControls.WebParts.WebPart>控件添加到页。</xref:System.Web.UI.WebControls.WebParts.WebPart> 有大量的常见方案，可以在其中将控件添加到页。 有关这些的完整说明，请参阅备注部分<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 时添加一个控件，它必须检查以查看是否其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性已设置并且，如果是这样，是否控件有权添加到页面。</xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>       开发人员可以创建的 AuthorizeWebPart 事件，提供筛选为控件的事件处理程序。 如果控件的<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性值不符合事件处理程序代码中的条件，控件不会添加到页。</xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>"
  example:
  - "The following code example demonstrates how to set a custom event handler for the AuthorizeWebPart event, which automatically overrides the default <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> method.  \n  \n The code in the `mgr1_AuthorizeWebPart` method checks whether the controls on the page have their respective <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> property values set to `user` and, if so, returns `true`, which means that they will be authorized and added to the page. This assumes the default approach is to allow users to view controls with a page in user personalization scope. Notice, however, that in the example one of the controls has its <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> property value set to `admin`. Developers might place this filter on a specialized control that was designed for only administrative users to see. This control will fail the authorization check during the AuthorizeWebPart event, and will not be displayed. Note that controls that do not have the property set are displayed as well; they are assumed not to be part of a filtering scenario because their <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> properties are not set.  \n  \n [!code-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/add/codesnippet/visualbasic/e-system.web.ui.webcontr_9_1.aspx)]\n [!code-cs[WebParts_WebPartManager_AuthorizeWebPart#1](~/add/codesnippet/csharp/e-system.web.ui.webcontr_9_1.aspx)]"
  syntax:
    content: public event System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart;
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers
  id: AvailableTransformers
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: AvailableTransformers
  nameWithType: WebPartManager.AvailableTransformers
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "获取的集合<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartTransformer&quot;></xref>对象可用于在创建 Web 部件服务器控件之间的连接时使用。"
  remarks: "此属性使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A>方法创建集合。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A> 默认情况下，将从应用程序配置文件读取可用的转换器。"
  syntax:
    content: public System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers { get; }
    return:
      type: System.Web.UI.WebControls.WebParts.TransformerTypeCollection
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.TransformerTypeCollection&quot;> </xref>包含一套<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartTransformer&quot;></xref>对象。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)
  id: BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: BeginWebPartConnecting(WebPart)
  nameWithType: WebPartManager.BeginWebPartConnecting(WebPart)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(WebPart)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "将启动的连接两个过程<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>控件。"
  remarks: "存在 BeginWebPartConnecting 方法，以便可以在不同的阶段，为开发人员提供更好地控制连接过程完成构成控件之间的连接的过程。 该方法执行初始检查以确保组`webPart`处于可以合法方式连接的状态。 如果`webPart`通过所有检查，然后将设置为当前所选控件 (请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>属性)，并可以继续连接过程。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>"
  syntax:
    content: public virtual void BeginWebPartConnecting (System.Web.UI.WebControls.WebParts.WebPart webPart);
    parameters:
    - id: webPart
      type: System.Web.UI.WebControls.WebParts.WebPart
      description: "正为其建立连接控件。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>webPart</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "在页面上的当前显示模式不是<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode&quot;> </xref>。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>webPart</code> is closed.  \n  \n \\- or -  \n  \n <code>webPart</code> is not part of the <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls*> collection.  \n  \n -or -  \n  \n <code>webPart</code> is equal to the <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart*> control."
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)
  id: BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: BeginWebPartEditing(WebPart)
  nameWithType: WebPartManager.BeginWebPartEditing(WebPart)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(WebPart)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "开始编辑的过程<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>控件。"
  remarks: "存在 BeginWebPartEditing 方法，以便可以在不同的阶段，为开发人员提供更好地控制该过程完成编辑控件的过程。 该方法执行初始检查以确保组`webPart`处于可以编辑的状态。 如果`webPart`通过所有检查，然后将设置为当前所选控件 (请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>属性)，并编辑过程可继续进行。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>"
  syntax:
    content: public virtual void BeginWebPartEditing (System.Web.UI.WebControls.WebParts.WebPart webPart);
    parameters:
    - id: webPart
      type: System.Web.UI.WebControls.WebParts.WebPart
      description: "要编辑的控件。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>webPart</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "在页面上的当前显示模式不是<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode&quot;> </xref>。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>webPart</code> is closed.  \n  \n \\- or -  \n  \n <code>webPart</code> is not part of the <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls*> collection.  \n  \n -or -  \n  \n <code>webPart</code> is equal to the <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart*> control."
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode
  id: BrowseDisplayMode
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: BrowseDisplayMode
  nameWithType: WebPartManager.BrowseDisplayMode
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode
  type: Field
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "表示包含 Web 部件控件的页面的默认显示模式。 此字段为只读的。"
  remarks: "BrowseDisplayMode 字段引用自定义<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>对象，创建并包含<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> </xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 由于这是一个静态对象，你可以引用直接通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager>而无需控件的实例的类。</xref:System.Web.UI.WebControls.WebParts.WebPartManager>       包含 Web 部件页在首次加载时 BrowseDisplayMode （浏览模式） 在默认情况下。 当用户只需浏览与它们在正常的网页上时，在浏览模式中会保留页。 如果用户想要对进行个性化设置的页面布局、 控件、 外观或行为，它们必须将页切换到一个专用的显示模式可通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>属性。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>"
  example:
  - "The following code example demonstrates how to work with the BrowseDisplayMode field programmatically. The code populates a drop-down list with the supported display modes, which in this case are browse and design. Notice that, in the `Page_PreRender` method, the code checks whether the current <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> property is set to BrowseDisplayMode. If so, `Label1` will be visible, and if not, `Label1` will be hidden.  \n  \n [!code-cs[WebParts_WebPartManager_BrowseDisplayMode#1](~/add/codesnippet/csharp/f-system.web.ui.webcontr_5_1.aspx)]\n [!code-vb[WebParts_WebPartManager_BrowseDisplayMode#1](~/add/codesnippet/visualbasic/f-system.web.ui.webcontr_5_1.aspx)]  \n  \n After you load the page in a browser, you are in browse mode by default. Notice the label on the page that indicates you are in browse mode. Use the drop-down list control to switch the page to design mode. Notice that, because of the code in the `Page_PreRender` method, the label is now hidden."
  syntax:
    content: public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode;
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartDisplayMode
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)
  id: CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: CanConnectWebParts(WebPart,ProviderConnectionPoint,WebPart,ConsumerConnectionPoint)
  nameWithType: WebPartManager.CanConnectWebParts(WebPart,ProviderConnectionPoint,WebPart,ConsumerConnectionPoint)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(WebPart,ProviderConnectionPoint,WebPart,ConsumerConnectionPoint)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "检查<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>控件将参与连接，以确定它们是否能够连接，如果使用者和提供程序的控件具有兼容的接口和<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartTransformer&quot;></xref>对象，则不需要。"
  remarks: "此方法用于连接`provider`和`consumer`如果这两个控件具有兼容的连接点类型，以便<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>对象，则不需要。</xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> 你可能想要使用此方法验证两个控件，可以连接，然后再调<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>若要创建的编程连接。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>       此重载使用相同的实现<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29>方法重载中，使用唯一的例外是，此重载不需要 transformer。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29>"
  example:
  - "The following code example demonstrates how to use this method.  \n  \n The code example has four parts:  \n  \n-   A user control that enables you to change display modes on a Web Parts page.  \n  \n-   A Web page that contains two custom <xref:System.Web.UI.WebControls.WebParts.WebPart> controls that can be connected, an `<asp:webpartmanager>` element, and some event-handling code that creates a connection using the <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> method.  \n  \n-   A source code file that contains two custom <xref:System.Web.UI.WebControls.WebParts.WebPart> controls, and a custom interface.  \n  \n-   An explanation of how the example works in a browser.  \n  \n The first part of the code example is the user control for changing display modes. You can obtain the source code for the user control from the Example section of the <xref:System.Web.UI.WebControls.WebParts.WebPartManager> class overview. For more information about display modes and how the user control works, see [Walkthrough: Changing Display Modes on a Web Parts Page](~/add/includes/ajax-current-ext-md.md).  \n  \n The declarative markup for the Web page contains `Register` directives for both the user control and the custom controls. There is an `<asp:webpartmanager>` element, an `<asp:webpartzone>` element to contain the custom controls, and an `<asp:connectionszone>` element. Notice that in the `Page_Load` method, the code checks whether the connection can be made and, if so, defines a provider, a consumer, and their respective connection points, and then adds a new connection to the set of static connections referenced by the <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> property.  \n  \n [!code-cs[WebParts_WebPartManager_StaticConnections#1](~/add/codesnippet/csharp/6c629474-a5b1-438b-b1c7-_1.aspx)]\n [!code-vb[WebParts_WebPartManager_StaticConnections#1](~/add/codesnippet/visualbasic/6c629474-a5b1-438b-b1c7-_1.aspx)]  \n  \n The third part of the example is the source code for the controls. It contains an interface and two custom <xref:System.Web.UI.WebControls.WebParts.WebPart> controls, one acting as a provider, and the other as a consumer. Because they have compatible connection points (both of them recognize the `IZipCode` interface), a transformer is not needed to make the connection. For the code example to run, you must compile this source code. You can compile it explicitly and put the resulting assembly in your Web site's Bin folder or the global assembly cache. Alternatively, you can put the source code in your site's App_Code folder, where it will be dynamically compiled at run time. For a walkthrough that demonstrates how to compile, see [Walkthrough: Developing and Using a Custom Web Server Control](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[WebParts_WebPartManager_StaticConnections#2](~/add/codesnippet/csharp/6c629474-a5b1-438b-b1c7-_2.cs)]\n [!code-vb[WebParts_WebPartManager_StaticConnections#2](~/add/codesnippet/visualbasic/6c629474-a5b1-438b-b1c7-_2.vb)]  \n  \n After you have loaded the Web page in a browser, click the **Display Mode** drop-down list control and select **Connect** to switch the page to connect mode. Connect mode uses the `<asp:connectionszone>` element to enable you to create connections between controls. In connect mode, click the downward arrow in the title bar of the **ZIP Code** control to activate its verbs menu, and then click **Connect**. After the connection user interface (UI) appears, notice that a connection has already been created by the code contained in the `Page_Load` method."
  syntax:
    content: public bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);
    parameters:
    - id: provider
      type: System.Web.UI.WebControls.WebParts.WebPart
      description: "为提供数据的控件`consumer`当连接控件。"
    - id: providerConnectionPoint
      type: System.Web.UI.WebControls.WebParts.ProviderConnectionPoint
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.ConnectionPoint&quot;> </xref> ，它使`provider`参与连接。"
    - id: consumer
      type: System.Web.UI.WebControls.WebParts.WebPart
      description: "接收数据的控件`provider`当连接控件。"
    - id: consumerConnectionPoint
      type: System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.ConnectionPoint&quot;> </xref>充当回调方法，因此，`consumer`可以参与连接。"
    return:
      type: System.Boolean
      description: "一个布尔值，该值指示是否<code> provider </code>和<code> consumer </code>可以连接。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)
  id: CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: CanConnectWebParts(WebPart,ProviderConnectionPoint,WebPart,ConsumerConnectionPoint,WebPartTransformer)
  nameWithType: WebPartManager.CanConnectWebParts(WebPart,ProviderConnectionPoint,WebPart,ConsumerConnectionPoint,WebPartTransformer)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(WebPart,ProviderConnectionPoint,WebPart,ConsumerConnectionPoint,WebPartTransformer)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "检查<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>控件将参与连接，以确定它们是否能够连接，并使用<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartTransformer&quot;></xref>对象以创建不兼容的使用者和提供程序之间的连接。"
  remarks: "此方法用于连接`provider`和`consumer`如果这两个控件具有不兼容的连接点类型，以便<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>对象是必需的。</xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> 你可能想要使用此方法验证两个控件，可以连接，然后再调<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>若要创建的编程连接。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>       此重载使用相同的实现<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29>方法重载中，使用唯一的例外是，此重载所需的转换器。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29>"
  syntax:
    content: public virtual bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);
    parameters:
    - id: provider
      type: System.Web.UI.WebControls.WebParts.WebPart
      description: "为提供数据的控件`consumer`当连接控件。"
    - id: providerConnectionPoint
      type: System.Web.UI.WebControls.WebParts.ProviderConnectionPoint
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.ConnectionPoint&quot;> </xref>充当回调方法，因此，`provider`可以参与连接。"
    - id: consumer
      type: System.Web.UI.WebControls.WebParts.WebPart
      description: "接收数据的控件`provider`当连接控件。"
    - id: consumerConnectionPoint
      type: System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.ConnectionPoint&quot;> </xref>充当回调方法，因此，`consumer`可以参与连接。"
    - id: transformer
      type: System.Web.UI.WebControls.WebParts.WebPartTransformer
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartTransformer&quot;> </xref>这样的不兼容的`provider`和`consumer`连接。"
    return:
      type: System.Boolean
      description: "一个布尔值，该值指示是否<code> provider </code>和<code> consumer </code>能够形成连接。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode
  id: CatalogDisplayMode
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: CatalogDisplayMode
  nameWithType: WebPartManager.CatalogDisplayMode
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode
  type: Field
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "表示用于从控件的目录的服务器控件添加到 Web 页的显示模式。 此字段为只读的。"
  remarks: "CatalogDisplayMode 字段引用自定义<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>对象，创建并包含<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> </xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 由于这是一个静态对象，你可以引用直接通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager>而无需控件的实例的类。</xref:System.Web.UI.WebControls.WebParts.WebPartManager>       当用户想要将控件添加到页中，如果可用的服务器控件目录时，则可以将该页切换到 CatalogDisplayMode （目录模式），并显示目录用户界面 (UI)。 用于 Web 部件目录的用户界面提供的<xref:System.Web.UI.WebControls.WebParts.CatalogZoneBase>区域控件。</xref:System.Web.UI.WebControls.WebParts.CatalogZoneBase> 开发人员在设计时，将该区域添加到页，然后将服务器控件添加到该区域，以便用户将能够在运行时将这些控件添加到相应的页面。 开发人员已添加这些控件后，目录模式变得页上受支持的显示模式，因为所需的控件有若要启用目录的模式。       当用户将某页目录模式、 区域和已添加到变得可见，它的所有服务器控件切换和用户可以从要添加到页中，或从页中删除控件的目录中选择控件。 控件已添加到页后，会显示在普通浏览模式中，更新页。"
  example:
  - "The following code example demonstrates how to work with the CatalogDisplayMode field programmatically. The code populates a drop-down list with the supported display modes for the page, which in this case are browse, design, and catalog. The catalog mode is available because of the `<asp:CatalogZone>` element and its child elements in the Web page. Notice that, in the `Page_PreRender` method, the code checks whether the current <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> property is set to CatalogDisplayMode. If so, `Label1` will be visible, and if not, `Label1` will be hidden.  \n  \n [!code-vb[WebParts_WebPartManager_CatalogDisplayMode#1](~/add/codesnippet/visualbasic/f-system.web.ui.webcontr_3_1.aspx)]\n [!code-cs[WebParts_WebPartManager_CatalogDisplayMode#1](~/add/codesnippet/csharp/f-system.web.ui.webcontr_3_1.aspx)]  \n  \n After you load the page in a browser, you are in browse mode by default. Notice that the label on the page is hidden. Use the drop-down list control to switch the page to catalog mode. Notice that, because of the code in the `Page_PreRender` method, the label is now visible. You can select the control in the catalog and add it to either of the two zones on the page."
  syntax:
    content: public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode;
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartDisplayMode
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CheckRenderClientScript
  id: CheckRenderClientScript
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: CheckRenderClientScript()
  nameWithType: WebPartManager.CheckRenderClientScript()
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.CheckRenderClientScript()
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "检查发出请求和的值的浏览器的功能<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript*>属性，以确定是否呈现客户端脚本。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript*>"
  syntax:
    content: protected virtual bool CheckRenderClientScript ();
    parameters: []
    return:
      type: System.Boolean
      description: "一个布尔值，该值指示是否呈现客户端脚本。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.CheckRenderClientScript*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning
  id: CloseProviderWarning
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: CloseProviderWarning
  nameWithType: WebPartManager.CloseProviderWarning
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "获取或设置当用户关闭充当提供程序连接中的其他控件的控件时显示警告。"
  remarks: "当用户关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，通常会显示任何消息。</xref:System.Web.UI.WebControls.WebParts.WebPart> 这意味着若要关闭控件有关的详细信息，请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>方法。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>       但是，当控件连接到另一个控件，并充当提供程序的数据的另一个控件，当用户尝试关闭该控件时，将显示默认警告消息。 消息会通知用户，提供程序控制即将关闭，这意味着控制连接到此提供程序，如使用者不会使用任何数据。 CloseProviderWarning 属性使开发人员自定义向用户显示警告消息。       当用户关闭，如果页开发人员将为空或 null 字符串值分配给此属性，将显示任何警告消息框<xref:System.Web.UI.WebControls.WebParts.WebPart>是一个提供程序的控制。</xref:System.Web.UI.WebControls.WebParts.WebPart>"
  example:
  - "The following code example demonstrates how to use the CloseProviderWarning property to display a custom warning to users.  \n  \n The code example has four parts:  \n  \n-   A user control that enables you to change display modes on a Web Parts page.  \n  \n-   A source code file that contains two custom <xref:System.Web.UI.WebControls.WebParts.WebPart> controls and a custom interface.  \n  \n-   A Web page that contains two custom <xref:System.Web.UI.WebControls.WebParts.WebPart> controls that can be connected and an `<asp:webpartmanager>` element.  \n  \n-   An explanation of how the example works in a browser.  \n  \n The following code contains only the Web page portion of the example. You will also need the custom user control and the source code for the custom controls mentioned above. Obtain these two items from the Example section of the <xref:System.Web.UI.WebControls.WebParts.WebPartManager> class overview.  \n  \n The following Web page code demonstrates how to assign a custom warning message to the CloseProviderWarning property in declarative markup in the `<asp:webpartmanager>` element.  \n  \n [!code-cs[WebParts_WebPartManager_CloseProviderWarning#1](~/add/codesnippet/csharp/p-system.web.ui.webcontr_979_1.aspx)]\n [!code-vb[WebParts_WebPartManager_CloseProviderWarning#1](~/add/codesnippet/visualbasic/p-system.web.ui.webcontr_979_1.aspx)]  \n  \n After you have loaded the Web page in a browser, click the **Display Mode** drop-down list control and select **Connect** to switch the page to connect mode. Connect mode uses the `<asp:connectionszone>` element to enable you to create connections between controls. In connect mode, click the downward arrow in the title bar of the **ZIP Code** control to activate its verbs menu, and then click **Connect**. After the connection user interface (UI) appears, click the **Create a connection to a Consumer** link. A cell appears that has a drop-down list control. Select **Weather Control** in the drop-down list, and click **Connect** to complete the connection of the two controls. Click **Close**, and then use the **Display Mode** drop-down list to return the page to normal browse mode. Finally, click the verbs menu for the **ZIP Code** control (which is the provider control in this case) and select **Close**. The custom message you assigned to the CloseProviderWarning property is displayed."
  syntax:
    content: public virtual string CloseProviderWarning { get; set; }
    return:
      type: System.String
      description: "包含警告消息的字符串。 默认值是由.NET Framework 提供的区域性特定消息。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)
  id: CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: CloseWebPart(WebPart)
  nameWithType: WebPartManager.CloseWebPart(WebPart)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(WebPart)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "关闭<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>控件，它不呈现在网页上，但可以重新打开的方式。"
  remarks: "CloseWebPart 方法中删除<xref:System.Web.UI.WebControls.WebParts.WebPart>或其他服务器控件，以使其不呈现在网页上，最初包含它。</xref:System.Web.UI.WebControls.WebParts.WebPart> 已关闭的控件添加到<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>对象，这将保持对已关闭的控件的引用，并使得要还原到页的控件。</xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> 关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>控件仍显示在所引用的集合<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>属性。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> </xref:System.Web.UI.WebControls.WebParts.WebPart>       关闭控件是不同的删除它。 已关闭的控件仍可用于还原到页中，但已删除的控件实例永久删除，而且将永远无法还原。 而不管是否<xref:System.Web.UI.WebControls.WebParts.WebPart>或服务器控件是 （在页面的标记中声明） 的静态或动态 （添加到页面以编程方式或通过用户从 Web 部件目录），它可以关闭并重新打开页面上。</xref:System.Web.UI.WebControls.WebParts.WebPart>       通常情况下，用户可以关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>通过单击其谓词菜单并选择关闭谓词的控件。</xref:System.Web.UI.WebControls.WebParts.WebPart> 也可以通过直接调用 CloseWebPart 方法并将其传递到的引用关闭控件`webPart`。       在页面上其中<xref:System.Web.UI.WebControls.WebParts.WebPart>控件已关闭，如果开发人员声明`<asp:catalogzone>`元素，并在其中添加`<asp:pagecatalogpart>`元素，它提供了适合用户还原到页在运行时的已关闭的控件的简单的用户界面 (UI)。</xref:System.Web.UI.WebControls.WebParts.WebPart> 用户可以将页切换到目录的显示模式，并且已关闭的控件将出现在该页目录。 用户可以选择已关闭的控件并将其添加回第一页的任何位置，它们需要，以及然后将所选的控件的还原到页和按正常方式呈现。       当调用 CloseWebPart 方法时，它会发出多个事件︰ <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>（如果有多个控件），和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>（如果有连接的控件）。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> 通常，开发人员可以取消这些事件，但在某些情况下它不能取消服务。 有关详细信息，请参阅的文档<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>，和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>"
  example:
  - "The following code example demonstrates how to use the CloseWebPart method.  \n  \n The code example has four parts:  \n  \n-   A user control that enables you to change page display modes.  \n  \n-   A custom <xref:System.Web.UI.WebControls.WebParts.WebPart> control.  \n  \n-   A Web page.  \n  \n-   An explanation of how the example works in a browser.  \n  \n The first part of the code example is the user control for changing display modes. You can obtain the source code for the user control from the Example section of the <xref:System.Web.UI.WebControls.WebParts.WebPartManager> class overview. For more information about display modes and how the user control works, see [Walkthrough: Changing Display Modes on a Web Parts Page](~/add/includes/ajax-current-ext-md.md).  \n  \n The second part of the code example is the custom <xref:System.Web.UI.WebControls.WebParts.WebPart> control. For the code example to run, you must compile this source code. You can compile it explicitly and put the resulting assembly in your Web site's Bin folder or the global assembly cache. Alternatively, you can put the source code in your site's App_Code folder, where it will be dynamically compiled at run time. This example uses the dynamic compilation approach; thus there is no `Assembly` attribute in the `Register` directive for this control at the top of the Web page. For a walkthrough that demonstrates how to compile, see [Walkthrough: Developing and Using a Custom Web Server Control](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[WebParts_WebPartManager_CloseWebPart#3](~/add/codesnippet/visualbasic/b26a8753-d277-40c2-ba47-_1.vb)]\n [!code-cs[WebParts_WebPartManager_CloseWebPart#3](~/add/codesnippet/csharp/b26a8753-d277-40c2-ba47-_1.cs)]  \n  \n The third part of the code example is the Web page. The page contains a <xref:System.Web.UI.WebControls.WebParts.CatalogZone> zone, with an <`asp:pagecatalogpart>` element declared within it. This is what will contain the closed <xref:System.Web.UI.WebControls.WebParts.WebPart> control and enable users to add it back to the page. The `Button1_Click` method directly calls the CloseWebPart method to close the custom <xref:System.Web.UI.WebControls.WebParts.WebPart> control, although a user can also close the control through the verbs menu.  \n  \n [!code-cs[WebParts_WebPartManager_CloseWebPart#1](~/add/codesnippet/csharp/b26a8753-d277-40c2-ba47-_2.aspx)]\n [!code-vb[WebParts_WebPartManager_CloseWebPart#1](~/add/codesnippet/visualbasic/b26a8753-d277-40c2-ba47-_2.aspx)]  \n  \n After you load the page in a browser, close the custom <xref:System.Web.UI.WebControls.WebParts.WebPart> control by clicking the verbs menu (the arrow symbol) in the header of the control, and clicking **Close**. Now change the page to catalog mode by selecting **Catalog** in the **Display Mode** drop-down list control. The page catalog appears with the closed control. Select the check box next to the closed control, click **Add** to add it to the page, and then click **Close** to return the page to browse mode. The control is restored to the page. Now close it again, this time by clicking the **Close WebPart** button."
  syntax:
    content: public void CloseWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);
    parameters:
    - id: webPart
      type: System.Web.UI.WebControls.WebParts.WebPart
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;> </xref>或正在关闭中的服务器控件<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartZoneBase&quot;> </xref>。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>webPart</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>webPart</code> is not in the <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls*> collection.  \n  \n \\- or -  \n  \n <code>webPart</code> is a shared control and has already been closed by another user."
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode
  id: ConnectDisplayMode
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: ConnectDisplayMode
  nameWithType: WebPartManager.ConnectDisplayMode
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode
  type: Field
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "表示用于显示特殊用户界面 (UI) 的显示模式用户管理之间的连接<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>控件。 此字段为只读的。"
  remarks: "ConnectDisplayMode 字段引用自定义<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>对象，创建并包含<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> </xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 由于这是一个静态对象，你可以引用直接通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager>而无需控件的实例的类。</xref:System.Web.UI.WebControls.WebParts.WebPartManager>       当用户想管理之间的连接<xref:System.Web.UI.WebControls.WebParts.WebPart>控件在网页上，如果<xref:System.Web.UI.WebControls.WebParts.ConnectionsZone>区域已声明的页上，则可以将该页切换到 ConnectDisplayMode 模式。</xref:System.Web.UI.WebControls.WebParts.ConnectionsZone> </xref:System.Web.UI.WebControls.WebParts.WebPart> 连接的显示模式显示特殊 UI 管理连接，包括连接或断开连接控件，以及如何编辑现有连接的详细信息的功能。       如果你想要为用户提供的功能使用由 Web 部件控件集提供的用户界面管理连接，您必须声明`<asp:connectionszone>`页面的标记中的元素。 与其他类型的元素不同<xref:System.Web.UI.WebControls.WebParts.WebZone>区域，不需要将此元素中的任何其他标记添加; 你只需声明元素本身。</xref:System.Web.UI.WebControls.WebParts.WebZone>"
  example:
  - "The following code example demonstrates the usage of the ConnectDisplayMode mode.  \n  \n The code example has three parts:  \n  \n-   A source file that contains an interface and custom <xref:System.Web.UI.WebControls.WebParts.WebPart> controls that can form a connection.  \n  \n-   A Web page that provides a connection UI and demonstrates working with the ConnectDisplayMode mode.  \n  \n-   An explanation of how to run the example.  \n  \n The first part of the code example is a source file that contains an interface and two custom <xref:System.Web.UI.WebControls.WebParts.WebPart> controls that are designed so they can be connected. For the code example to run, you must compile this source code. You can compile it explicitly and put the resulting assembly in your Web site's Bin folder or the global assembly cache. Alternatively, you can put the source code in your site's App_Code folder, where it will be dynamically compiled at run time. This code example uses the dynamic compilation approach. For a walkthrough that demonstrates how to compile, see [Walkthrough: Developing and Using a Custom Web Server Control](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[WebParts_WebPartManager_ConnectDisplayMode#2](~/add/codesnippet/csharp/f-system.web.ui.webcontr_1_1.cs)]\n [!code-vb[WebParts_WebPartManager_ConnectDisplayMode#2](~/add/codesnippet/visualbasic/f-system.web.ui.webcontr_1_1.vb)]  \n  \n The second part of the example is a Web page that hosts the custom controls. Within the server `<script>` tags on the page are several methods that populate a drop-down list with the display modes available on the page. A user can select these from the drop-down list to change the page's display mode. One of the available display modes is connect display mode, because an `<asp:connectionszone>` element is declared in the page's markup. Notice that this element does not contain any other child elements; it exists only to enable the connection management UI for users.  \n  \n The ConnectDisplayMode mode appears in this example in two places. First, in the `Page_Init` method, the connect display mode is added to the drop-down list of display modes, as the code loops through the collection referenced in the <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> property. Second, the `Page_PreRender` method checks the current display mode on the page, and if the current mode is ConnectDisplayMode, a message is displayed in a <xref:System.Web.UI.WebControls.Label> control.  \n  \n [!code-cs[WebParts_WebPartManager_ConnectDisplayMode#1](~/add/codesnippet/csharp/f-system.web.ui.webcontr_1_2.aspx)]\n [!code-vb[WebParts_WebPartManager_ConnectDisplayMode#1](~/add/codesnippet/visualbasic/f-system.web.ui.webcontr_1_2.aspx)]  \n  \n After you load the page in a browser, click the drop-down list and select **Connect** to switch the page into connect display mode. Notice that a message appears, telling you that the page is in connect display mode. Now click the verbs menu (an arrow symbol) in the title bar of one of the <xref:System.Web.UI.WebControls.WebParts.WebPart> controls, and then click **Connect** in the verbs menu. After the connection UI is displayed, click the link to create a connection. Use the drop-down list within the connection UI that appears, select the other control that will participate in the connection, and click the **Connect** button. The connection is established. Click the **Close** button, and then use the drop-down list at the top of the page to return the page to browse display mode."
  syntax:
    content: public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode;
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartDisplayMode
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.Connections
  id: Connections
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: Connections
  nameWithType: WebPartManager.Connections
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.Connections
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "获取在网页上的所有当前连接的集合的引用。"
  remarks: "连接属性提供用于访问当前的一组连接在页面上的方法。 集合本身是只读的并想要操作集合中的特定连接开发人员应使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager>方法，如<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> </xref:System.Web.UI.WebControls.WebParts.WebPartManager>"
  example:
  - "The following code example demonstrates declarative and programmatic use of the <xref:System.Web.UI.WebControls.WebParts.WebPartManager> control.  \n  \n The code example has four parts:  \n  \n-   A user control that enables you to change display modes on a Web Parts page.  \n  \n-   A Web page that contains two custom <xref:System.Web.UI.WebControls.WebParts.WebPart> controls that can be connected, and an `<asp:webpartmanager>` element.  \n  \n-   A source code file that contains two custom <xref:System.Web.UI.WebControls.WebParts.WebPart> controls and a custom interface.  \n  \n-   An explanation of how the example works in a browser.  \n  \n The following code contains only the Web page portion of the example. You will also need the custom user control and the source code for the custom controls mentioned above. Obtain these two items from the Example section of the <xref:System.Web.UI.WebControls.WebParts.WebPartManager> class overview.  \n  \n The following Web page code demonstrates how to use the Connections property programmatically to get the count of current connections on a page. Note that in the `<script>` tag section, the code to handle two events for the <xref:System.Web.UI.WebControls.WebParts.WebPartManager> control accesses the Connections property to obtain the count.  \n  \n [!code-cs[WebParts_WebPartManager_SimpleConnection#1](~/add/codesnippet/csharp/p-system.web.ui.webcontr_34_1.aspx)]\n [!code-vb[WebParts_WebPartManager_SimpleConnection#1](~/add/codesnippet/visualbasic/p-system.web.ui.webcontr_34_1.aspx)]  \n  \n After you have loaded the Web page in a browser, click the **Display Mode** drop-down list control and select **Connect** to switch the page to connect mode. Connect mode uses the `<asp:connectionszone>` element to enable you to create connections between controls. In connect mode, click the downward arrow in the title bar of the **ZIP Code** control to activate its verbs menu, and then click **Connect**. After the connection user interface (UI) displays, click the **Create a connection to a Consumer** link. A cell appears that has a drop-down list control. Select **Weather Control** in the drop-down list, and click **Connect** to complete the connection of the two controls. Click **Close**, and then use the **Display Mode** drop-down list to return the page to normal browse mode. Note that a label now displays the number of connections and the number of <xref:System.Web.UI.WebControls.WebParts.WebPart> controls. If you now return to connect mode and disconnect the two controls, when you return to browse mode, the label's content should be updated and there should be no connections."
  syntax:
    content: public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections { get; }
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartConnectionCollection
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartConnectionCollection&quot;> </xref>包含一套<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartConnection&quot;></xref>对象。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.Connections*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated
  id: ConnectionsActivated
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: ConnectionsActivated
  nameWithType: WebPartManager.ConnectionsActivated
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated
  type: Event
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "在页面上的所有当前 Web 部件连接仅未连接，但已经开始主动之间的共享数据所涉及的每个连接的使用者和提供程序控件后发生。"
  remarks: "生命周期的连接，此事件发生后页面完成其加载过程。 它还后发生<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>事件，只是指示<xref:System.Web.UI.WebControls.WebParts.WebPart>或服务器控件所涉及的特定连接已成功连接。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> 在情况下 ConnectionsActivated 方法在有多个连接页上的，指示在页面上的所有有效 Web 部件连接现活动和能够共享数据。 了解所有连接都处于活动状态后，开发人员可以执行任意数量的任务，包括将通知用户的所有连接的状态通知使用者控件处理和显示来自其提供程序，数据等等。       此事件与<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A>方法，它引发事件并允许开发人员创建自定义事件处理程序。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A>       页开发人员可以创建自定义事件处理程序，通过添加`OnConnectionsActivated`属性设为`<asp:webpartmanager>`页上，，然后将自定义的方法名称分配到的属性中的元素。"
  syntax:
    content: public event EventHandler ConnectionsActivated;
    return:
      type: System.EventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating
  id: ConnectionsActivating
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: ConnectionsActivating
  nameWithType: WebPartManager.ConnectionsActivating
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating
  type: Event
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "激活在网页上所有建立的 Web 部件连接过程中发生。"
  remarks: "生命周期的连接，会发生此事件页之前完成其加载进程，如<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>调用方法。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> 不同于<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>事件，这就需要之间的特定连接<xref:System.Web.UI.WebControls.WebParts.WebPart>或其他服务器控件。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> 当在页面上的所有可能的连接已连接，并且要激活，则 ConnectionsActivating 事件发生。       与关联 ConnectionsActivating 事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A>方法，将引发事件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> 控件开发人员想要扩展的可以添加到页面的连接类型可以重写受保护<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A>方法并激活其他类型的连接。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A>       页开发人员可以创建自定义事件处理程序，通过添加`OnConnectionsActivating`属性设为`<asp:webpartmanager>`页上，，然后将自定义的方法名称分配到的属性中的元素。"
  syntax:
    content: public event EventHandler ConnectionsActivating;
    return:
      type: System.EventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)
  id: ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: ConnectWebParts(WebPart,ProviderConnectionPoint,WebPart,ConsumerConnectionPoint)
  nameWithType: WebPartManager.ConnectWebParts(WebPart,ProviderConnectionPoint,WebPart,ConsumerConnectionPoint)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(WebPart,ProviderConnectionPoint,WebPart,ConsumerConnectionPoint)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "创建两个之间的连接<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>或<xref href=&quot;System.Web.UI.WebControls.WebParts.GenericWebPart&quot;></xref>控制使用仅对控件和控件所指定的引用<xref href=&quot;System.Web.UI.WebControls.WebParts.ConnectionPoint&quot;></xref>对象。"
  remarks: "此重载用于在其连接点充分兼容确保它们而无需使用连接时连接控件<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>对象。</xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> 当调用该方法的此重载时，它只需将传递到另一重载版本的方法的调用并将传递`null`需要的参数<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>对象。</xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>       当你尝试以编程方式连接两个控件时，你可以使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>条件检查，以确定是否可以直接连接控件中的方法。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>"
  example:
  - "The following code example demonstrates how to use this method to create a connection programmatically. For the full code required to run the example, see the Example section of the <xref:System.Web.UI.WebControls.WebParts.WebPartManager> class overview. From that example, you will need the source code for the user control that allows you to change display modes on the page, and the source code for the two custom <xref:System.Web.UI.WebControls.WebParts.WebPart> controls.  \n  \n The code for the Web page that hosts the two controls follows. The page uses `Register` directives at the top to declare the user control and the custom controls. The custom controls are then referenced declaratively within an `<asp:webpartzone>` element. The code that handles the `Button1_Click` method creates a connection between the controls by using the <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> method.  \n  \n [!code-cs[WebParts_WebPartManager_ConnectWebParts1#1](~/add/codesnippet/csharp/4892fea4-8419-4966-aca7-_1.aspx)]\n [!code-vb[WebParts_WebPartManager_ConnectWebParts1#1](~/add/codesnippet/visualbasic/4892fea4-8419-4966-aca7-_1.aspx)]  \n  \n After you load the page in a browser, click the **Connect WebPart Controls** button to form the connection. You can then enter some data in the text box, and click the **Enter 5-digit ZIP Code** button to demonstrate that the controls are connected, and that data entered in the first control is updated in the second."
  syntax:
    content: public System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);
    parameters:
    - id: provider
      type: System.Web.UI.WebControls.WebParts.WebPart
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;> </xref>连接到另一个提供数据的角色的控件的控件。"
    - id: providerConnectionPoint
      type: System.Web.UI.WebControls.WebParts.ProviderConnectionPoint
      description: "一种方法用作回调方法，以连接。 在 Web 部件控件集中实现时，这是中的公共方法`provider`且标有<xref uid=&quot;langword_csharp_ConnectionProvider&quot; name=&quot;ConnectionProvider&quot; href=&quot;&quot;></xref>元数据属性。"
    - id: consumer
      type: System.Web.UI.WebControls.WebParts.WebPart
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;> </xref>角色为接收从数据的控件`provider`，然后处理或显示它。"
    - id: consumerConnectionPoint
      type: System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint
      description: "用于与连接的方法`providerConnectionPoint`接收连接的数据。 在 Web 部件控件集中实现时，这是中的公共方法`consumer`且标有<xref uid=&quot;langword_csharp_ConnectionConsumer&quot; name=&quot;ConnectionConsumer&quot; href=&quot;&quot;></xref>元数据属性。"
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartConnection
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartConnection&quot;> </xref>包含有关提供程序和使用者连接所需的各种信息。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;> </xref>的动态集合的控件的集合是只读的。"
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)
  id: ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: ConnectWebParts(WebPart,ProviderConnectionPoint,WebPart,ConsumerConnectionPoint,WebPartTransformer)
  nameWithType: WebPartManager.ConnectWebParts(WebPart,ProviderConnectionPoint,WebPart,ConsumerConnectionPoint,WebPartTransformer)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(WebPart,ProviderConnectionPoint,WebPart,ConsumerConnectionPoint,WebPartTransformer)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "创建两个之间的连接<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>或<xref href=&quot;System.Web.UI.WebControls.WebParts.GenericWebPart&quot;></xref>控制使用的控件，其指定的引用<xref href=&quot;System.Web.UI.WebControls.WebParts.ConnectionPoint&quot;></xref>对象，和一个<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartTransformer&quot;></xref>对象。"
  remarks: "此重载用于在其连接点不兼容时连接控件。 发生不兼容时`consumer`实现其他接口比`provider`作为连接点。 Transformer 将数据转换可以理解的一种`consumer`。"
  syntax:
    content: public virtual System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);
    parameters:
    - id: provider
      type: System.Web.UI.WebControls.WebParts.WebPart
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;> </xref>到另一个连接的控件提供数据的角色。"
    - id: providerConnectionPoint
      type: System.Web.UI.WebControls.WebParts.ProviderConnectionPoint
      description: "中的公共方法`provider`且标有<xref uid=&quot;langword_csharp_ConnectionProvider&quot; name=&quot;ConnectionProvider&quot; href=&quot;&quot;></xref>元数据属性，并作为回调方法，以连接。"
    - id: consumer
      type: System.Web.UI.WebControls.WebParts.WebPart
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;> </xref>接收中的数据的角色`provider`或`transformer`，然后处理或显示它。"
    - id: consumerConnectionPoint
      type: System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint
      description: "中的公共方法`consumer`且标有<xref uid=&quot;langword_csharp_ConnectionConsumer&quot; name=&quot;ConnectionConsumer&quot; href=&quot;&quot;></xref>元数据属性，连接与`providerConnectionPoint`接收连接的数据。"
    - id: transformer
      type: System.Web.UI.WebControls.WebParts.WebPartTransformer
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartTransformer&quot;> </xref>这样的通过将转换中的数据的两个控件之间的连接`provider`为格式，`consumer`可以处理。"
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartConnection
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartConnection&quot;> </xref>包含有关提供程序、 使用者和 transformer 连接所需的信息。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "连接已在中激活<xref href=&quot;System.Web.UI.Control.PreRender&quot;> </xref>。"
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.Controls
  id: Controls
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: Controls
  nameWithType: WebPartManager.Controls
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.Controls
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "获取所有的集合<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;> </xref>，服务器或用户控件中包含<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartZoneBase&quot;></xref>区域在网页上，并且由管理<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>控件。"
  remarks: "控件属性不引用所引用的其他控件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制，如各种区域控件，<xref:System.Web.UI.WebControls.WebParts.EditorPart>或<xref:System.Web.UI.WebControls.WebParts.CatalogPart>控件和其他人。</xref:System.Web.UI.WebControls.WebParts.CatalogPart> </xref:System.Web.UI.WebControls.WebParts.EditorPart> </xref:System.Web.UI.WebControls.WebParts.WebPartManager>       Web 部件控件集，以及在不应在代码中调用的大多数开发情况下使用此属性。 出于此原因，虽然属性是公共的但会将其隐藏的 IntelliSense。 开发人员想要访问的集合<xref:System.Web.UI.WebControls.WebParts.WebPart>或由其他服务器控件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件应使用其<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>属性。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> </xref:System.Web.UI.WebControls.WebParts.WebPartManager> </xref:System.Web.UI.WebControls.WebParts.WebPart>"
  syntax:
    content: public override System.Web.UI.ControlCollection Controls { get; }
    return:
      type: System.Web.UI.ControlCollection
      description: "A <xref href=&quot;System.Web.UI.ControlCollection&quot;> </xref> ，其中包含由管理的所有控件<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>控件。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.Controls*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart(System.Web.UI.WebControls.WebParts.WebPart)
  id: CopyWebPart(System.Web.UI.WebControls.WebParts.WebPart)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: CopyWebPart(WebPart)
  nameWithType: WebPartManager.CopyWebPart(WebPart)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart(WebPart)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "使用 Web 部件控件集用来创建一份<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>或用于将控件添加到网页的服务器控件。"
  remarks: "不能在代码中直接调用 CopyWebPart 方法。 内部调用此方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件添加新的动态的过程的一部分<xref:System.Web.UI.WebControls.WebParts.WebPart>或到页上的服务器控件。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartManager> 动态控件添加到页面以编程方式或通过 Web 部件用户界面 (UI)，例如用户从控件，而不是直接在页面的标记中声明一个静态控件的目录中添加控件。      1> [!NOTE]&1;> 如果开发人员想要使该方法以处理复制方案的更多控制，可以在派生类中重写的方法。 有关详细信息，请参阅对继承者部分的说明。       添加一个新的动态控件时，如果它是<xref:System.Web.UI.WebControls.WebParts.WebPart>控制，CopyWebPart 方法将返回控件的新实例。</xref:System.Web.UI.WebControls.WebParts.WebPart> 如果正在添加的控件 （如用户控件、 一个自定义控件或 ASP.NET 控件） 的服务器控件的某些其他类型，已将具有与包装控件<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>由 Web 部件控件集的对象。</xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 当 CopyWebPart 方法遇到的<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控件，它将返回<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>它。 内自动换行的子控件的新实例使用的控件</xref:System.Web.UI.WebControls.WebParts.GenericWebPart>的新实例</xref:System.Web.UI.WebControls.WebParts.GenericWebPart>       当 CopyWebPart 方法创建要返回的控件的新副本时，它还将重置所有属性的值为其默认值。 请注意，是否你想要保留可个性化属性的值，并将它们复制到新的控件实例，应调用<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.CopyPersonalizationState%2A>方法也。</xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.CopyPersonalizationState%2A> 最后一步执行的方法是调用 CopyWebPart<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID%2A>方法来获取控件的新 ID。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID%2A>      1> [!NOTE]&1;> 由于该方法获取复制的控件的新 ID，你不应依赖于引用原始 id 添加到页面的动态控件 相反，应引用该方法返回的控件的新实例。"
  syntax:
    content: protected virtual System.Web.UI.WebControls.WebParts.WebPart CopyWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);
    parameters:
    - id: webPart
      type: System.Web.UI.WebControls.WebParts.WebPart
      description: "<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;> </xref>或要复制的服务器控件。"
    return:
      type: System.Web.UI.WebControls.WebParts.WebPart
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;> </xref>要添加到页。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers
  id: CreateAvailableTransformers
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: CreateAvailableTransformers()
  nameWithType: WebPartManager.CreateAvailableTransformers()
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers()
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "创建一组的网站的配置文件中指定的转换器并将它们添加到集合的引用的转换器<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers*>属性。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers*>"
  syntax:
    content: protected virtual System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers ();
    parameters: []
    return:
      type: System.Web.UI.WebControls.WebParts.TransformerTypeCollection
      description: "指定在网站的配置文件中的转换器集合。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CreateControlCollection
  id: CreateControlCollection
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: CreateControlCollection()
  nameWithType: WebPartManager.CreateControlCollection()
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.CreateControlCollection()
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "返回由管理的所有控件的集合<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>在网页上的控件。 此类不能被继承。"
  syntax:
    content: protected override sealed System.Web.UI.ControlCollection CreateControlCollection ();
    parameters: []
    return:
      type: System.Web.UI.ControlCollection
      description: "A <xref href=&quot;System.Web.UI.ControlCollection&quot;> </xref>包含管理的所有各种 Web 部件控件<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>控件。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.CreateControlCollection*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes
  id: CreateDisplayModes
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: CreateDisplayModes()
  nameWithType: WebPartManager.CreateDisplayModes()
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes()
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "创建 Web 部件应用程序的所有可能的显示模式的集。"
  remarks: "此方法创建的所有可能的显示模式，而不仅仅是支持特定页面上的显示模式的列表。 有关受支持的显示模式的详细信息，请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>属性。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>       默认情况下，Web 部件控件集创建的以下一组显示在 Web 部件页上使用的模式:- <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>- <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>- <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>- <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>-<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>开发人员可以创建自定义显示模式，可以使用或不相关的自定义派生自的区域<xref:System.Web.UI.WebControls.WebParts.WebZone>或<xref:System.Web.UI.WebControls.WebParts.ToolZone>类。</xref:System.Web.UI.WebControls.WebParts.ToolZone> </xref:System.Web.UI.WebControls.WebParts.WebZone> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> 若要创建的自定义显示模式，你必须从<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>类，也要添加为支持的模式，在页面上的显示模式，你必须从继承<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类，并重写 CreateDisplayModes 方法。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> </xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>       当使用添加显示模式<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection.Add%2A>方法，你应将其添加你希望它们出现在任何用户界面 (UI) 控件中的顺序 (如<xref:System.Web.UI.WebControls.ListBox>控件)，向用户提供可能的显示模式在页面上。</xref:System.Web.UI.WebControls.ListBox> </xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection.Add%2A>"
  example:
  - "The following code example demonstrates how to use the CreateDisplayModes method.  \n  \n The code example has five parts:  \n  \n-   A user control that enables you to change display modes on a Web Parts page.  \n  \n-   A Web page that hosts the other controls.  \n  \n-   A user control that resides in a <xref:System.Web.UI.WebControls.WebParts.WebPartZone> zone on the Web page, and enables you to enter and display text in a label.  \n  \n-   A source code file that contains two controls. One is a custom <xref:System.Web.UI.WebControls.WebParts.WebPartManager> control, and the other is a custom <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> object to add to the page's default display modes.  \n  \n-   A source code file that contains two custom <xref:System.Web.UI.WebControls.WebParts.WebPart> controls, and a custom interface.  \n  \n-   An explanation of how the example works in a browser.  \n  \n The first part of the code example is the user control for changing display modes. You can obtain the source code for the user control from the Example section of the <xref:System.Web.UI.WebControls.WebParts.WebPartManager> class overview. For more information about display modes and how the user control works, see [Walkthrough: Changing Display Modes on a Web Parts Page](~/add/includes/ajax-current-ext-md.md).  \n  \n The second part of the example is the Web page. It contains two <xref:System.Web.UI.WebControls.WebParts.WebPartZone> controls, both user controls, and the custom <xref:System.Web.UI.WebControls.WebParts.WebPartManager> control. Notice the `Register` directives at the top of the page to reference the user controls and namespace for the compiled controls.  \n  \n [!code-cs[Webparts_WebPartManager_CreateDisplayModes#1](~/add/codesnippet/csharp/m-system.web.ui.webcontr_187_1.aspx)]\n [!code-vb[Webparts_WebPartManager_CreateDisplayModes#1](~/add/codesnippet/visualbasic/m-system.web.ui.webcontr_187_1.aspx)]  \n  \n The third part of the example is the user control for entering and displaying text. It uses a <xref:System.Web.UI.WebControls.MultiView> control to create multiple views of the UI. One view appears with the `Button1` button, the other without. Notice that in the overridden `OnPreRender` method, the code checks to see whether the page is currently in the custom display mode and, if so, displays the first view of the user control, which includes the button. If the page is not in the custom display mode, for example if the page is in browse or design mode, the button is hidden.  \n  \n [!code-cs[Webparts_WebPartManager_CreateDisplayModes#2](~/add/codesnippet/csharp/m-system.web.ui.webcontr_187_2.ascx)]\n [!code-vb[Webparts_WebPartManager_CreateDisplayModes#2](~/add/codesnippet/visualbasic/m-system.web.ui.webcontr_187_2.ascx)]  \n  \n The fourth part of the example is the source file for the two custom classes. Notice that the custom <xref:System.Web.UI.WebControls.WebParts.WebPartManager> class overrides the CreateDisplayModes method, and that it first calls the base method to add all the default display modes, and then adds the custom display mode. The custom display mode class, `InLineEditDisplayMode`, simply inherits from <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>, sets the name of the display mode in the constructor, and overrides a number of the base properties to establish the characteristics of the custom display.  \n  \n For the code example to run, you must compile this source code. You can compile it explicitly and put the resulting assembly in your Web site's Bin folder or the global assembly cache. Alternatively, you can put the source code in your site's App_Code folder, where it will be dynamically compiled at run time. For a walkthrough that demonstrates how to compile, see [Walkthrough: Developing and Using a Custom Web Server Control](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[Webparts_WebPartManager_CreateDisplayModes#3](~/add/codesnippet/csharp/m-system.web.ui.webcontr_187_3.cs)]\n [!code-vb[Webparts_WebPartManager_CreateDisplayModes#3](~/add/codesnippet/visualbasic/m-system.web.ui.webcontr_187_3.vb)]  \n  \n To run the code example, load the page in a browser. Notice that the page is currently in browse mode, and no button is visible. Using the **Display Mode** drop-down list control, change the page to **Inline Edit Display** mode, and notice that now the `Button1` button is visible in the lower user control. Add some text, and click the button to update the control. Notice that the page display is returned to browse mode, the text you entered is now displayed, and the button is once again hidden because the page is no longer in the custom display mode."
  syntax:
    content: protected virtual System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes ();
    parameters: []
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection&quot;> </xref> ，其中包含所有支持的显示模式。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID
  id: CreateDynamicConnectionID
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: CreateDynamicConnectionID()
  nameWithType: WebPartManager.CreateDynamicConnectionID()
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID()
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "获取一个唯一的值，以作为动态连接的 ID。"
  remarks: "CreateDynamicConnectionID 方法生成的 GUID 值，并将其转换为字符串，以便作为连接的唯一 ID。 此方法叫做每次创建动态连接。"
  syntax:
    content: protected virtual string CreateDynamicConnectionID ();
    parameters: []
    return:
      type: System.String
      description: "包含连接的唯一 ID 的字符串。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)
  id: CreateDynamicWebPartID(System.Type)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: CreateDynamicWebPartID(Type)
  nameWithType: WebPartManager.CreateDynamicWebPartID(Type)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(Type)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "生成的唯一 ID 的动态<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>控件。"
  remarks: "当<xref:System.Web.UI.WebControls.WebParts.WebPart>控件添加到网页，则它们可以是静态 （这意味着页标记中声明的控件） 或动态 （这意味着它们将以编程方式添加）。</xref:System.Web.UI.WebControls.WebParts.WebPart> 在任何情况下，<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件创建新的动态控件将添加到页上，它会调用此方法以生成唯一 id。</xref:System.Web.UI.WebControls.WebParts.WebPartManager>       方法是虚方法，使开发人员可以重写它如果他们想要提供自定义实现来生成 id。"
  syntax:
    content: protected virtual string CreateDynamicWebPartID (Type webPartType);
    parameters:
    - id: webPartType
      type: System.Type
      description: "<xref:System.Type>为其生成 ID 的控件。</xref:System.Type>"
    return:
      type: System.String
      description: "包含控件的唯一 ID 的字符串。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>webPartType</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)
  id: CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: CreateErrorWebPart(String,String,String,String,String)
  nameWithType: WebPartManager.CreateErrorWebPart(String,String,String,String,String)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(String,String,String,String,String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "创建插入到页并向最终用户，当尝试加载或创建动态显示的特殊控件<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>控件出于某些原因而失败。"
  remarks: "Web 部件控件集尝试加载或创建的动态实例时调用 CreateErrorWebPart 方法<xref:System.Web.UI.WebControls.WebParts.WebPart>或服务器控件和它出于某些原因而失败。</xref:System.Web.UI.WebControls.WebParts.WebPart> 该方法将创建一个<xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>对象，将分配到其中，错误消息，并返回它。</xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>控件插入失败，在控件的位置，并且其错误消息显示在页上。</xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>       不能在代码中直接调用 CreateErrorWebPart 方法。 但是，你可以从继承<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类和扩展方法。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> 有关详细信息，请参阅继承者部分的说明。       最终用户可以使用<xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>控制在页中很多像常规<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> 若要删除错误消息，用户可以控制通过单击关闭关闭谓词，此时该控件将添加到<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>对象，像任何其他已关闭的控件一样。</xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> 如果最终用户删除<xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>控件时，无法加载服务器控件也将删除从页中。</xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>"
  syntax:
    content: protected virtual System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart (string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage);
    parameters:
    - id: originalID
      type: System.String
      description: "失败控件的 ID 字符串。 如果<xref href=&quot;System.Web.UI.WebControls.WebParts.GenericWebPart&quot;></xref>会涉及到在该故障，ID 是子服务器控件的 ID。"
    - id: originalTypeName
      type: System.String
      description: "一个字符串，它的名称<xref:System.Type>失败控件。</xref:System.Type> 如果<xref href=&quot;System.Web.UI.WebControls.WebParts.GenericWebPart&quot;></xref>会涉及到该故障，在类型名称是其子服务器控件的类型。"
    - id: originalPath
      type: System.String
      description: "如果包含一个用户控件的路径的字符串<xref href=&quot;System.Web.UI.WebControls.WebParts.GenericWebPart&quot;></xref>包含的子用户控件参与失败。"
    - id: genericWebPartID
      type: System.String
      description: "返回的 ID 字符串<xref href=&quot;System.Web.UI.WebControls.WebParts.GenericWebPart&quot;> </xref>，如果该类型的控件陷入中未能加载或创建的控件。"
    - id: errorMessage
      type: System.String
      description: "一个字符串，包含要显示在页面上的错误消息。"
    return:
      type: System.Web.UI.WebControls.WebParts.ErrorWebPart
      description: "<xref href=&quot;System.Web.UI.WebControls.WebParts.ErrorWebPart&quot;> </xref>插入页面无法加载或创建控件的位置。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization
  id: CreatePersonalization
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: CreatePersonalization()
  nameWithType: WebPartManager.CreatePersonalization()
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization()
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "返回一个个性化对象以包含当前网页的用户的个性化数据。"
  remarks: "CreatePersonalization 方法返回一个对象来包含和管理针对当前页的用户的个性化设置。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件管理此对象。</xref:System.Web.UI.WebControls.WebParts.WebPartManager>"
  syntax:
    content: protected virtual System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization ();
    parameters: []
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartPersonalization
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartPersonalization&quot;> </xref>包含用户的个性化数据。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)
  id: CreateWebPart(System.Web.UI.Control)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: CreateWebPart(Control)
  nameWithType: WebPartManager.CreateWebPart(Control)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(Control)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "包装不是一个服务器控件<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>控件替换为<xref href=&quot;System.Web.UI.WebControls.WebParts.GenericWebPart&quot;></xref>对象，以便控件可以具有 Web 部件功能。"
  remarks: "CreateWebPart 方法是用于启用不的服务器控件的主要机制<xref:System.Web.UI.WebControls.WebParts.WebPart>控件以与相同的功能对其执行<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，因此完全参与 Web 部件应用程序。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPart> 大大地使用此方法，开发人员展开他们可以使用 Web 部件应用程序中的服务器控件的数，因为几乎任何类型的服务器控件-可以使用标准 ASP.NET 控件、 用户控件和自定义控件。       <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件还使用此方法在两种情况下包装服务器控件与<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>对象。</xref:System.Web.UI.WebControls.WebParts.GenericWebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartManager> 当用户将服务器控件添加到页上通过使用<xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart>控制，如果导入的控件不是<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，调用该 CreateWebPart 方法。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> 此外，当服务器控件中声明中的持久性格式<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域在网页上，方法调用的任何控件不 CreateWebPart<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>       当以编程方式向区域添加服务器控件时，典型的方法是使用 CreateWebPart 方法包装控件<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>对象，，然后调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>方法将控件添加到所有的集合<xref:System.Web.UI.WebControls.WebParts.WebPart>控件在页上，通过引用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>属性。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> </xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> </xref:System.Web.UI.WebControls.WebParts.GenericWebPart>"
  example:
  - "The following code example demonstrates use of the CreateWebPart method. In the `Button2_Click method`, the CreateWebPart method is called to wrap a <xref:System.Web.UI.WebControls.Calendar> control with a <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> object before adding it to the zone.  \n  \n [!code-cs[WebParts_WebPartManager_DeleteWebPart#1](~/add/codesnippet/csharp/6552ec5d-43c0-4c29-a8a1-_1.aspx)]\n [!code-vb[WebParts_WebPartManager_DeleteWebPart#1](~/add/codesnippet/visualbasic/6552ec5d-43c0-4c29-a8a1-_1.aspx)]"
  syntax:
    content: public virtual System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart (System.Web.UI.Control control);
    parameters:
    - id: control
      type: System.Web.UI.Control
      description: "不是一个服务器控件<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>控件。"
    return:
      type: System.Web.UI.WebControls.WebParts.GenericWebPart
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.GenericWebPart&quot;> </xref>包装<code> control </code> ，并使它能够用作真正<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>控件。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning
  id: DeleteWarning
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: DeleteWarning
  nameWithType: WebPartManager.DeleteWarning
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "获取或设置自定义警告消息显示给最终用户，他们删除控件时。"
  remarks: "当用户删除<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，通常显示默认警告消息。</xref:System.Web.UI.WebControls.WebParts.WebPart> 它会警告用户控件的此实例中删除时，删除是永久性。 页开发人员可以向用户提供了如何向页面添加控件的新实例 (如通过的目录<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，或通过某些编程的方式)，但永久移除已删除的控件的当前实例。</xref:System.Web.UI.WebControls.WebParts.WebPart> 如果需要，将显示警告对话框中包含一个按钮，用户取消删除操作。       DeleteWarning 属性使开发人员能够设置向用户显示该警告消息。       如果页开发人员分配一个空字符串 (&quot;&quot;) 将显示此属性，没有警告消息对话框中的值，当用户中删除<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。</xref:System.Web.UI.WebControls.WebParts.WebPart>      1> [!NOTE]&1;> DeleteWarning 属性未显示在静态的情况下<xref:System.Web.UI.WebControls.WebParts.WebPart>控件和服务器控件。</xref:System.Web.UI.WebControls.WebParts.WebPart> 静态控件是在内声明的服务器控件<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域中的网页上的标记。</xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 此类控件是静态的因为它们不能删除，因此将永远不会在这种情况下显示删除警告消息。 静态控件可以关闭的用户，但已关闭的控件添加到页目录中，从中它可以重新添加到页面的用户，而永远无法恢复删除的控件。"
  example:
  - "The following code example demonstrates the use of the DeleteWarning property declaratively and programmatically.  \n  \n There are four parts to the code example:  \n  \n-   A user control that enables you to change page display modes.  \n  \n-   A custom <xref:System.Web.UI.WebControls.WebParts.WebPart> control.  \n  \n-   A Web page.  \n  \n-   An explanation of how the example works in a browser.  \n  \n The first part of the code example is the user control for changing display modes. You can obtain the source code for the user control from the Example section of the <xref:System.Web.UI.WebControls.WebParts.WebPartManager> class overview. For more information about display modes and how the user control works, see [Walkthrough: Changing Display Modes on a Web Parts Page](~/add/includes/ajax-current-ext-md.md).  \n  \n The second part of the code example is the custom <xref:System.Web.UI.WebControls.WebParts.WebPart> control. For the code example to run, you must compile this source code. You can compile it explicitly and put the resulting assembly in your Web site's Bin folder or the global assembly cache. Alternatively, you can put the source code in your site's App_Code folder, where it will be dynamically compiled at run time. This example uses the dynamic compilation approach; thus there is no `Assembly` attribute in the `Register` directive for this control at the top of the Web page. For a walkthrough that demonstrates how to compile, see [Walkthrough: Developing and Using a Custom Web Server Control](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[WebParts_WebPartManager_DeleteWarning#3](~/add/codesnippet/csharp/p-system.web.ui.webcontr_226_1.cs)]\n [!code-vb[WebParts_WebPartManager_DeleteWarning#3](~/add/codesnippet/visualbasic/p-system.web.ui.webcontr_226_1.vb)]  \n  \n The third part of the code example is the Web page. The page contains a <xref:System.Web.UI.WebControls.WebParts.CatalogZone> zone, with the custom <xref:System.Web.UI.WebControls.WebParts.WebPart> control declared in the zone, so that a user can add it to the page at run time. Note that only dynamic controls (controls that are added to a page programmatically or from a catalog like this one) can be deleted from a page. Static controls (controls that are declared within a <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zone in the markup of a page) can be closed, but never deleted. The `<asp:webpartmanager>` element declares a custom value for the DeleteWarning property by using the `DeleteWarning` attribute. The `Button1_Click` method assigns another custom value to the DeleteWarning property.  \n  \n [!code-cs[WebParts_WebPartManager_DeleteWarning#1](~/add/codesnippet/csharp/p-system.web.ui.webcontr_226_2.aspx)]\n [!code-vb[WebParts_WebPartManager_DeleteWarning#1](~/add/codesnippet/visualbasic/p-system.web.ui.webcontr_226_2.aspx)]  \n  \n After you load the page in a browser, you need to add the <xref:System.Web.UI.WebControls.WebParts.WebPart> control to the page. Using the **Display Mode** drop-down list control, select catalog mode. When the catalog appears, select the check box next to the custom control, click **Add** to add it to the page, and then click **Close** to return the page to browse mode. Now that the control is visible, you can delete it. Using the **Display Mode** control again, switch the page into design mode (you cannot delete controls while the page is in browse mode). Click the verbs menu (the arrow symbol) in the header of the <xref:System.Web.UI.WebControls.WebParts.WebPart> control, and select **Delete**. The warning that you set on the `DeleteWarning` attribute appears. Click **Cancel**. Now click the button labeled **Change Delete Warning**, which changes the property value programmatically. From the verbs menu on the control, select **Delete** again, and notice that this time the other warning message appears."
  syntax:
    content: public virtual string DeleteWarning { get; set; }
    return:
      type: System.String
      description: "包含警告消息的文本的字符串。 默认值为本地化的警告消息。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)
  id: DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: DeleteWebPart(WebPart)
  nameWithType: WebPartManager.DeleteWebPart(WebPart)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(WebPart)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "永久删除的动态实例<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>在网页上的控件。"
  remarks: "DeleteWebPart 方法永久移除所表示的控件`webPart`从页中的参数。 与关闭的控件，它将添加到<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>控制，可以在已删除的控件实例可以永远不会添加回页回页上，添加。</xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>      1> [!NOTE]&1;> Web 部件控件的实施方式的设置，用户若要删除动态的能力<xref:System.Web.UI.WebControls.WebParts.WebPart>控件取决于用户和控件添加到页面中的个性化设置范围。</xref:System.Web.UI.WebControls.WebParts.WebPart> 如果控件添加页面时共享作用域中 （由具有权限的用户），然后控件无法删除由各个用户页面时用户作用域中。       可以删除仅动态控件。 以编程方式或通过用户从目录中添加控件动态控件添加到页。 静态控件添加到以声明方式中标记或持久性格式的页。 声明性的标记是永久地存在于标记，因为静态控件永远不会被删除，但它们可以关闭并重新打开。"
  example:
  - "The following code example demonstrates how to use the DeleteWebPart method. The first time the **Add Calendar** button is clicked, the code in the event handler creates a <xref:System.Web.UI.WebControls.Calendar> control, and adds it to a zone as a <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> object. Because the control is added programmatically, it is a dynamic control, and therefore it can be deleted. When a user clicks the **Delete Calendar** button, the code ensures that the control exists, and then deletes it by calling the DeleteWebPart method.  \n  \n [!code-cs[WebParts_WebPartManager_DeleteWebPart#1](~/add/codesnippet/csharp/116fed0f-0c12-4700-9cde-_1.aspx)]\n [!code-vb[WebParts_WebPartManager_DeleteWebPart#1](~/add/codesnippet/visualbasic/116fed0f-0c12-4700-9cde-_1.aspx)]"
  syntax:
    content: public void DeleteWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);
    parameters:
    - id: webPart
      type: System.Web.UI.WebControls.WebParts.WebPart
      description: "要删除的服务器控件。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode
  id: DesignDisplayMode
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: DesignDisplayMode
  nameWithType: WebPartManager.DesignDisplayMode
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode
  type: Field
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "表示用于更改包含 Web 部件控件的网页的布局的显示模式。 此字段为只读的。"
  remarks: "DesignDisplayMode 字段引用自定义<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>对象，创建并包含<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> </xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 由于这是一个静态对象，你可以引用直接通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager>而无需控件的实例的类。</xref:System.Web.UI.WebControls.WebParts.WebPartManager>       包含 Web 部件页在首次加载时，在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>（浏览模式） 默认情况下。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> 如果用户想要通过将控件移到不同的区域或在当前区域内更改页的布局，它们必须先切换到 DesignDisplayMode （设计模式下） 的页。 在设计模式下，将显示各种区域的用户界面 (UI)，而且用户可以拖动控件来更改布局。"
  example:
  - "The following code example demonstrates how to work with the DesignDisplayMode field programmatically. The code populates a drop-down list with the supported display modes for the page, which in this case are browse and design. Notice that, in the `Page_PreRender` method, the code checks whether the current <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> property is set to DesignDisplayMode. If so, `Label1` will be visible, and if not, `Label1` will be hidden.  \n  \n [!code-vb[WebParts_WebPartManager_DesignDisplayMode#1](~/add/codesnippet/visualbasic/f-system.web.ui.webcontr_6_1.aspx)]\n [!code-cs[WebParts_WebPartManager_DesignDisplayMode#1](~/add/codesnippet/csharp/f-system.web.ui.webcontr_6_1.aspx)]  \n  \n After you load the page in a browser, you are in browse mode by default. Notice that the label on the page is hidden. Use the drop-down list control to switch the page to design mode. Notice that, because of the code in the `Page_PreRender` method, the label is now visible."
  syntax:
    content: public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode;
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartDisplayMode
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)
  id: DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: DisconnectWebPart(WebPart)
  nameWithType: WebPartManager.DisconnectWebPart(WebPart)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(WebPart)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "删除<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>或服务器控件，它是正在从它参与任何连接关闭或删除。"
  remarks: "由 Web 部件控件集在页或从页中删除控件时在内部调用 DisconnectWebPart 方法。 在此类方案中，方法被调用来删除该控件从任何连接其中包含作为使用者或提供程序。 如果从任何连接删除控件，则此方法也会调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>方法来结束的任何连接`webPart`正忙于。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>       当调用 DisconnectWebPart 方法时，将引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 通常，此事件可以被取消，但不是能取消两种情况下。 页上，在请求期间发生的一种情况时<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>调用方法。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> 如果没有现有的连接中冲突，将调用 DisconnectWebPart 方法关闭之一相互冲突的连接，并在这种情况<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件不能被取消，因为必须解决冲突。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>       另一种情况时<xref:System.Web.UI.WebControls.WebParts.WebPart>或关闭或删除当前连接的服务器控件。</xref:System.Web.UI.WebControls.WebParts.WebPart> 在这种情况下，因的控件而正在从删除页上，其连接需要被终止，因此不能取消设计使然<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件中断的结束连接过程。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 有关详细信息，请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>"
  example:
  - "The following code example demonstrates how to use the DisconnectWebPart method. Using two custom <xref:System.Web.UI.WebControls.WebParts.WebPart> controls, the Web page enables you to create a connection between the controls by clicking a button, while another button enables you to disconnect the controls. If you close one of the controls while the page is in browse mode and the controls are connected, an override of the DisconnectWebPart method disconnects the closed control, ends the connection, and displays a message.  \n  \n The code example has four parts:  \n  \n-   A user control for changing display modes.  \n  \n-   A source file containing custom <xref:System.Web.UI.WebControls.WebParts.WebPart> controls.  \n  \n-   A Web page to host the controls.  \n  \n-   An explanation of how the example works in a browser.  \n  \n The first part of the code example is the user control for changing display modes. You can obtain the source code for the user control from the Example section of the <xref:System.Web.UI.WebControls.WebParts.WebPartManager> class overview. For more information about display modes and how the user control works, see [Walkthrough: Changing Display Modes on a Web Parts Page](~/add/includes/ajax-current-ext-md.md).  \n  \n The second part is the file containing the source code for the two custom <xref:System.Web.UI.WebControls.WebParts.WebPart> controls that will be connected, and a custom <xref:System.Web.UI.WebControls.WebParts.WebPartManager> control. For the code example to run, you must compile this source code. You can compile it explicitly and put the resulting assembly in your Web site's Bin folder or the global assembly cache. Alternatively, you can put the source code in your site's App_Code folder, where it will be dynamically compiled at run time. This example uses dynamic compilation, so the `Register` directive that references these components in the Web page is declared accordingly at the top of the Web page. For a walkthrough that demonstrates compiling options, see [Walkthrough: Developing and Using a Custom Web Server Control](~/add/includes/ajax-current-ext-md.md).  \n  \n In the source code, notice the inherited control `MyWebPartManager` that overrides the DisconnectWebPart method. This method checks each connection in a page to see whether the control being closed participates in the connection and, if so, calls the <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> method to end the connection. This is identical to the base implementation of the method in the <xref:System.Web.UI.WebControls.WebParts.WebPartManager> control. The overridden method then customizes the base implementation by writing a message to the page.  \n  \n [!code-cs[WebParts_WebPartManager_DisconnectWebParts#2](~/add/codesnippet/csharp/71ce8e23-5620-4b82-8ba7-_1.cs)]\n [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/add/codesnippet/visualbasic/71ce8e23-5620-4b82-8ba7-_1.vb)]  \n  \n The third part of the code example is the Web page. Notice that near the top, it contains `Register` directives to register the user control, and the dynamically compiled assembly with the <xref:System.Web.UI.WebControls.WebParts.WebPart> controls. The page has two primary methods. The `Button1_Click` method creates a connection between the controls, while the `Button2_Click` method disconnects the controls.  \n  \n [!code-cs[WebParts_WebPartManager_DisconnectWebParts#1](~/add/codesnippet/csharp/71ce8e23-5620-4b82-8ba7-_2.aspx)]\n [!code-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/add/codesnippet/visualbasic/71ce8e23-5620-4b82-8ba7-_2.aspx)]  \n  \n After you load the page, click the **Connect** button to connect the controls. Then click the verbs menu in one of the controls (the downward arrow in the header of the control), and select **Close** from the verbs menu. When you try to close the control, the overridden method is called, the connection is ended, and the message is written to the page. If you want to reset the page to restore the closed control and experiment with other options, click the **Reset User State** link to remove personalization data and restore the page's original state."
  syntax:
    content: protected virtual void DisconnectWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);
    parameters:
    - id: webPart
      type: System.Web.UI.WebControls.WebParts.WebPart
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;> </xref>要断开连接的控件。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)
  id: DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: DisconnectWebParts(WebPartConnection)
  nameWithType: WebPartManager.DisconnectWebParts(WebPartConnection)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(WebPartConnection)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "断开连接连接到 Web 页的服务器控件的过程执行。"
  remarks: "DisconnectWebParts 方法执行的结束之间的连接的整个过程<xref:System.Web.UI.WebControls.WebParts.WebPart>或服务器控件，当你将其传递`connection`参数。</xref:System.Web.UI.WebControls.WebParts.WebPart>       此方法用于断开控件，当你将放`<asp:connectionszone>`在网页上，用于提供用户界面 (UI) 管理连接的元素。 在一个页面时连接的显示模式 (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>)，并且当前连接存在，用户可以单击一个按钮来调用 DisconnectWebParts 方法终止的连接。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>       你还可以调用 DisconnectWebParts 方法直接从代码中，如果你想要以编程方式，而不必添加断开控件`<asp:connectionszone>`到页元素。"
  example:
  - "The following code example demonstrates how to use the DisconnectWebParts method. Using two custom <xref:System.Web.UI.WebControls.WebParts.WebPart> controls, the Web page enables you to create a connection between the controls by clicking a button, while another button enables you to disconnect the controls.  \n  \n The code example has four parts:  \n  \n-   A user control for changing display modes.  \n  \n-   A source file containing custom <xref:System.Web.UI.WebControls.WebParts.WebPart> controls.  \n  \n-   A Web page to host the controls.  \n  \n-   An explanation of how the example works in a browser.  \n  \n The first part of the code example is the user control for changing display modes. You can obtain the source code for the user control from the Example section of the <xref:System.Web.UI.WebControls.WebParts.WebPartManager> class overview. For more information about display modes and how the user control works, see [Walkthrough: Changing Display Modes on a Web Parts Page](~/add/includes/ajax-current-ext-md.md).  \n  \n The second part is a file containing the source code for the two custom <xref:System.Web.UI.WebControls.WebParts.WebPart> controls that will be connected. For the code example to run, you must compile this source code. You can compile it explicitly and put the resulting assembly in your Web site's Bin folder or the global assembly cache. Alternatively, you can put the source code in your site's App_Code folder, where it will be dynamically compiled at run time. This example uses dynamic compilation, so the `Register` directive that references these components in the Web page is declared accordingly at the top of the Web page. For a walkthrough that demonstrates compiling options, see [Walkthrough: Developing and Using a Custom Web Server Control](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[WebParts_WebPartManager_DisconnectWebParts#2](~/add/codesnippet/csharp/01708fce-976e-4f0e-bfeb-_1.cs)]\n [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/add/codesnippet/visualbasic/01708fce-976e-4f0e-bfeb-_1.vb)]  \n  \n The third part of the code example is the Web page. Notice that near the top, it contains `Register` directives to register the user control and the dynamically compiled assembly with the <xref:System.Web.UI.WebControls.WebParts.WebPart> controls. The page has two primary methods. The `Button1_Click` method creates a connection between the controls, and the `Button2_Click` method disconnects the controls.  \n  \n [!code-cs[WebParts_WebPartManager_DisconnectWebParts#1](~/add/codesnippet/csharp/01708fce-976e-4f0e-bfeb-_2.aspx)]\n [!code-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/add/codesnippet/visualbasic/01708fce-976e-4f0e-bfeb-_2.aspx)]  \n  \n After you load the page, you can click the **Connect** button to connect the controls. If you enter some text in the text box control, and then click the **Enter** button, the text will be displayed in the connected control (it would not be displayed if the controls were disconnected). If you click the **Disconnect** button, the controls will be disconnected. You can verify the connection status of the controls by using the **Display Mode** drop-down list control to switch the page into **Connect** mode. After doing that, click the verbs menu (represented by an arrow) in the title bar of one of the controls, and select the **Connect** item. The connection UI is displayed; it is available because there is an `<asp:connectionszone>` element declared in the page. You can also connect and disconnect the controls from this UI."
  syntax:
    content: public virtual void DisconnectWebParts (System.Web.UI.WebControls.WebParts.WebPartConnection connection);
    parameters:
    - id: connection
      type: System.Web.UI.WebControls.WebParts.WebPartConnection
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartConnection&quot;> </xref>表示服务器控件之间的连接。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>connection</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>connection</code>未包含在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections*>或<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections*>。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections*> is read-only.  \n  \n \\- or -  \n  \n <code>connection</code> has already been disconnected from <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections*>.  \n  \n \\- or -  \n  \n <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections*> is read-only.  \n  \n \\- or -  \n  \n <code>connection</code> has already been disconnected from <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections*>."
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode
  id: DisplayMode
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: DisplayMode
  nameWithType: WebPartManager.DisplayMode
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "获取或设置包含 Web 部件控件的网页的活动的显示模式。"
  remarks: "页面，其中包含 Web 部件控件始终是几个可能的显示模式之一中。 有关显示模式的详细信息，请参阅[Web 部件页显示模式](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Web.UI.WebControls.WebParts.WebPartManager>类创建网页上的显示模式。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> 使用的基本<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>类，<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件创建可以用在包含 Web 部件控件的页的多个标准显示模式对象。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> </xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 这些标准的显示模式进行了介绍<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>类概述。</xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>       <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件还管理使用 Web 部件控件的页面的显示模式。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> 使用 DisplayMode 属性<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件在页上保留对当前显示模式的引用。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> DisplayMode 属性还可用于将页切换到不同的显示模式。 更改使用 Web 部件控件的页面上的显示模式的示例，请参阅[演练︰ 在 Web 部件页面上更改显示模式](~/add/includes/ajax-current-ext-md.md)。       作为管理显示模式中，一部分<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件还提供事件和事件处理程序与相关显示模式，如<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A>方法和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A>方法。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A> </xref:System.Web.UI.WebControls.WebParts.WebPartManager> 这些方法提供了一种机制自定义页面的行为，以及甚至对于添加的自定义显示模式。"
  example:
  - "The following code example demonstrates programmatic use of the DisplayMode property. After loading the page in a browser, you can use the buttons near the bottom of the page to switch display modes. The page is in browse mode by default when it loads. If you switch to design mode, you can drag the server controls from one zone to another, or arrange two controls within one zone. If you switch to edit mode, you can click the verbs menu in the header of either of the server controls, select **Edit**, and edit the control using the provided editing user interface (UI).  \n  \n> [!NOTE]\n>  Switching among display modes in a Web Parts application is very common, and you might want to provide a consistent, reusable way to do this on all your pages that contain Web Parts controls. For an example of a user control that changes display modes and that can be reused on many pages, see [Walkthrough: Changing Display Modes on a Web Parts Page](../Topic/Walkthrough:%20Changing%20Display%20Modes%20on%20a%20Web%20Parts%20Page.md).  \n  \n [!code-cs[WebParts_WebPartManager_DisplayMode#1](~/add/codesnippet/csharp/p-system.web.ui.webcontr_632_1.aspx)]\n [!code-vb[WebParts_WebPartManager_DisplayMode#1](~/add/codesnippet/visualbasic/p-system.web.ui.webcontr_632_1.aspx)]"
  syntax:
    content: public virtual System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode { get; set; }
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartDisplayMode
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartDisplayMode&quot;> </xref> ，它确定某页的显示模式。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartDisplayMode&quot;> </xref>对象分配给属性为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref href=\"System.Web.UI.WebControls.WebParts.WebPartDisplayMode\"></xref> object being assigned to the property is not one of the supported display modes.  \n  \n \\- or -  \n  \n The <xref href=\"System.Web.UI.WebControls.WebParts.WebPartDisplayMode\"></xref> object being assigned to the property is disabled."
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged
  id: DisplayModeChanged
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: DisplayModeChanged
  nameWithType: WebPartManager.DisplayModeChanged
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged
  type: Event
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "当前页已更改 Web 部件显示模式后发生。"
  remarks: "显示模式是 Web 部件应用程序不可或缺的组成部分。 当用户切换到不同的显示模式在网页上时，页通常会采用非常不同的外观，具体取决于新的显示模式的目的。 显示模式已更改后，你可能想要进行某些更改在用户界面 (UI)，如隐藏或显示某些控件中，更改所选的 UI 元素的外观，依此类推。      1> [!NOTE]&1;> 显示模式的详细信息，请参阅[Web 部件页显示模式](~/add/includes/ajax-current-ext-md.md)。 有关使用事件的详细信息，请参阅[如何︰ 在 Web 窗体应用程序中使用事件](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged;
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging
  id: DisplayModeChanging
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: DisplayModeChanging
  nameWithType: WebPartManager.DisplayModeChanging
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging
  type: Event
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "用户单击开始将更改为不同的显示模式的过程的网页上的谓词之后发生。"
  remarks: "显示模式是 Web 部件应用程序不可或缺的组成部分。 当用户切换到不同的显示模式在网页上时，页通常会采用非常不同的外观，具体取决于新的显示模式的目的。 用户启动的过程将更改为新的显示模式，通过单击谓词后，你可能想要通过使用用户界面 (UI) 中进行某些更改<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode%2A>属性来确定新的显示模式将是什么，，然后将相应地更改各种用户界面元素。</xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode%2A> 有用的方式来执行此操作是重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A>方法以自定义 UI。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A>      1> [!NOTE]&1;> 显示模式的详细信息，请参阅[Web 部件页显示模式](~/add/includes/ajax-current-ext-md.md)。 有关使用事件的详细信息，请参阅[如何︰ 在 Web 窗体应用程序中使用事件](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging;
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes
  id: DisplayModes
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: DisplayModes
  nameWithType: WebPartManager.DisplayModes
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "获取与关联的所有显示模式的只读集合<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>控件。"
  remarks: "DisplayModes 属性引用所有关联显示模式，这与<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>属性，即在引用有 （上受支持） 的当前页的显示模式。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>       两个提供的显示模式、 浏览和设计，始终支持在页面上。 其他三个显示模式、 编辑、 目录和连接，支持仅当页具有相应的特定显示模式工作所需的区域类型时。 例如，如果你的页面不包含<xref:System.Web.UI.WebControls.WebParts.EditorZone>区域，编辑显示模式将出现在由 DisplayModes 属性，引用的集合，但不是会显示所引用的集合中<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>属性。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> </xref:System.Web.UI.WebControls.WebParts.EditorZone>"
  example:
  - "The following code example shows the programmatic use of the DisplayModes property. The code uses this property to populate the list with all the display modes available in the Web Parts control set, even those that are not supported on the current page. In this case, the catalog and connect display modes are not supported, because their corresponding required zones are not on the page.  \n  \n The other three display modes--browse, design, and edit--are supported on the page. Edit mode is supported because the page contains an <xref:System.Web.UI.WebControls.WebParts.EditorZone> zone, while browse and design modes are always supported.  \n  \n After you load the page in a browser, you can use the drop-down list control to switch the page from browse mode to design mode, and then to edit mode. In edit mode, you can click the drop-down verbs menu in the header of one of the server controls, and select **Edit** to edit the control. Note that if you select **Catalog** or **Connect** in the drop-down list, an error page is generated.  \n  \n [!code-cs[WebParts_WebPartManager_DisplayModes#1](~/add/codesnippet/csharp/p-system.web.ui.webcontr_572_1.aspx)]\n [!code-vb[WebParts_WebPartManager_DisplayModes#1](~/add/codesnippet/visualbasic/p-system.web.ui.webcontr_572_1.aspx)]"
  syntax:
    content: public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes { get; }
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection&quot;> </xref>包含的一套<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartDisplayMode&quot;></xref>与关联的对象<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>控件。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections
  id: DynamicConnections
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: DynamicConnections
  nameWithType: WebPartManager.DynamicConnections
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "获取在网页上当前存在的所有动态连接的集合。"
  remarks: "动态连接都是以编程方式，而不是静态创建的连接。 静态连接创建的 Web 窗体页的标记中声明它们。 通过编程方式，或一个用户创建了使用连接用户界面 (UI) 的连接形成动态连接。       DynamicConnections 集合中，但它是只读的无法更改其内容，提供以编程方式访问每个动态连接对象。      1> [!NOTE]&1;> 执行常见的操作，如连接或断开<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，开发人员应使用的公共方法上,<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类，如<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>，而不是尝试直接修改 DynamicConnections 集合中的连接对象。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> </xref:System.Web.UI.WebControls.WebParts.WebPartManager> </xref:System.Web.UI.WebControls.WebParts.WebPart>"
  syntax:
    content: protected System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections { get; }
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartConnectionCollection
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartConnectionCollection&quot;> </xref>包含页上的所有动态连接到的引用。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode
  id: EditDisplayMode
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: EditDisplayMode
  nameWithType: WebPartManager.EditDisplayMode
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode
  type: Field
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "表示最终用户可以编辑和修改服务器控件的显示模式。 此字段为只读的。"
  remarks: "EditDisplayMode 字段引用自定义<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>对象，创建并包含<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> </xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 由于这是一个静态对象，你可以引用直接通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager>而无需控件的实例的类。</xref:System.Web.UI.WebControls.WebParts.WebPartManager>       包含 Web 部件页在首次加载时，在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>（浏览模式） 默认情况下。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> 如果用户想要编辑或修改服务器控件，它们必须先切换到 EditDisplayMode （编辑模式） 的页。 其次，它们必须选择要编辑，请通过单击该控件的标头中的谓词菜单上的编辑谓词的特定服务器控件。 控件处于编辑模式后，编辑的用户界面 (UI) 将显示用于编辑所选的控件。       若要启用页面上的编辑模式，该页必须包含至少一个<xref:System.Web.UI.WebControls.WebParts.EditorZone>区域包含一个或多个所提供的编辑控件，如<xref:System.Web.UI.WebControls.WebParts.LayoutEditorPart>控件或自定义编辑控件。</xref:System.Web.UI.WebControls.WebParts.LayoutEditorPart> </xref:System.Web.UI.WebControls.WebParts.EditorZone>"
  example:
  - "The following code example demonstrates how to work with the EditDisplayMode field programmatically. The code populates a drop-down list with the supported display modes for the page, which in this case are browse, design, and edit. To support editing, an `<asp:EditorZone>` element is in the page. Notice that, in the `Page_PreRender` method, the code checks whether the current <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> property is set to EditDisplayMode. If so, `Label1` will be visible, and if not, `Label1` will be hidden.  \n  \n [!code-cs[WebParts_WebPartManager_EditDisplayMode#1](~/add/codesnippet/csharp/f-system.web.ui.webcontr_7_1.aspx)]\n [!code-vb[WebParts_WebPartManager_EditDisplayMode#1](~/add/codesnippet/visualbasic/f-system.web.ui.webcontr_7_1.aspx)]  \n  \n After you load the page in a browser, you are in browse mode by default. Notice the label on the page is hidden. Use the drop-down list control to switch the page to edit mode. Notice that, because of the code in the `Page_PreRender` method, the label is now visible. Click the **Edit** verb in the verbs menu on one of the controls, to enable editing of that specific control."
  syntax:
    content: public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode;
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartDisplayMode
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript
  id: EnableClientScript
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: EnableClientScript
  nameWithType: WebPartManager.EnableClientScript
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "获取或设置一个值，确定是否在包含的 Web 页上启用客户端脚本<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>控件。"
  remarks: "EnableClientScript 属性提供开发人员禁用客户端脚本方法。 你可能需要禁用客户端脚本出于安全目的，或者以确保页面的所有用户将都具有类似的用户体验，即使它们使用不同的浏览器。       你可以禁用客户端脚本通过添加`EnableClientScript`属性设为<xref:System.Web.UI.WebControls.WebParts.WebPartManager>元素在网页上，如下所示的声明性代码的以下行︰ `<asp:webpartmanager id=&quot;manager&quot; runat=&quot;server&quot;` `EnableClientScript=&quot;false&quot; />`此外，开发人员可以消除此属性，通过继承<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类和设置默认值为`false`。</xref:System.Web.UI.WebControls.WebParts.WebPartManager>        </xref:System.Web.UI.WebControls.WebParts.WebPartManager>       Web 部件控件集使用客户端脚本以提供一些客户端用户界面 (UI) 和个性化功能。 如果禁用客户端脚本，Web 部件控件仍起作用，但某些功能将被禁用。 禁用了将控件拖动到不同区域的功能，以及能够呈现 （谓词改为显示为控件的标题栏中的链接） 的控件的标题栏中的下拉列表谓词菜单中的谓词。"
  syntax:
    content: public virtual bool EnableClientScript { get; set; }
    return:
      type: System.Boolean
      description: "一个布尔值，该值指示是否在页上可以运行客户端脚本。 默认值是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming
  id: EnableTheming
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: EnableTheming
  nameWithType: WebPartManager.EnableTheming
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "获取一个值，该值在网页上启用了的主题的使用。"
  remarks: "<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件重写基<xref:System.Web.UI.Control.EnableTheming%2A>属性以确保它始终返回值为`true`。</xref:System.Web.UI.Control.EnableTheming%2A> </xref:System.Web.UI.WebControls.WebParts.WebPartManager> 这是因为 Web 部件控件集要求使用主题来进行呈现 Web 部件控件的子控件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制的和窗体中的网页上的用户界面 (UI)。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> 例如，主题用于呈现各种区域，并驻留在区域，其中包括各种类型的控件部件控件 (继承的控件<xref:System.Web.UI.WebControls.WebParts.Part>类)，用户控件、 ASP.NET 服务器控件和自定义服务器控件。</xref:System.Web.UI.WebControls.WebParts.Part>       尽管重写的 EnableTheming 属性实现为读/写属性，根据其基属性，但无法设置属性，因为设计使然，它始终必须返回值为`true`。 如果你尝试设置属性，<xref:System.NotSupportedException>引发异常。</xref:System.NotSupportedException>"
  syntax:
    content: public override bool EnableTheming { get; set; }
    return:
      type: System.Boolean
      description: "一个布尔值，该值指示是否启用主题。 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>在所有情况下。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "尝试设置属性值。"
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting
  id: EndWebPartConnecting
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: EndWebPartConnecting()
  nameWithType: WebPartManager.EndWebPartConnecting()
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting()
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "完成连接的过程<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>到另一个控件的控件。"
  remarks: "EndWebPartConnecting 方法完成连接的过程<xref:System.Web.UI.WebControls.WebParts.WebPart>到另一个控件的控件。</xref:System.Web.UI.WebControls.WebParts.WebPart> 它是对应于<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>方法。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>       EndWebPartConnecting 方法可以确保个性化设置对象引用的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>属性是可修改，这是必要的因为建立连接本身是一种类型的个性化设置。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> 然后，该方法确保，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>对象不是`null`，最后调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>方法。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>"
  syntax:
    content: public virtual void EndWebPartConnecting ();
    parameters: []
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "所引用的控件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart*>属性是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart*>"
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing
  id: EndWebPartEditing
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: EndWebPartEditing()
  nameWithType: WebPartManager.EndWebPartEditing()
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing()
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "完成编辑过程<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>控件。"
  remarks: "EndWebPartEditing 方法完成编辑过程<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。</xref:System.Web.UI.WebControls.WebParts.WebPart> 它是对应于<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>方法。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>       EndWebPartEditing 方法可以确保个性化设置对象引用的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>属性是可修改，这是必要的因为编辑控件是一个过程，需要更改个性化设置。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> 然后，该方法确保，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>对象不是`null`，以便当前所选<xref:System.Web.UI.WebControls.WebParts.WebPart>控件可以更改，并最后调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>方法。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> </xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>"
  syntax:
    content: public virtual void EndWebPartEditing ();
    parameters: []
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "所引用的控件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart*>属性是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart*>"
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning
  id: ExportSensitiveDataWarning
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: ExportSensitiveDataWarning
  nameWithType: WebPartManager.ExportSensitiveDataWarning
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "获取或设置当用户尝试将敏感状态数据从导出时显示一条警告消息的文本<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>控件。"
  remarks: "当用户尝试导出敏感状态数据从<xref:System.Web.UI.WebControls.WebParts.WebPart>控制，如果任何正在导出的数据来自已标记为敏感的源代码中的成员时，向用户在消息框中，告知他们正在导出敏感数据并提供一个机会取消导出显示一条警告消息。</xref:System.Web.UI.WebControls.WebParts.WebPart> 开发人员可以通过设置标记为敏感的特定成员的数据`isSensitive`参数`[Personalizable]`属性设为`true`成员上。 有关此属性和参数的详细信息，请参阅<xref:System.Web.UI.WebControls.WebParts.PersonalizableAttribute>类。</xref:System.Web.UI.WebControls.WebParts.PersonalizableAttribute>      1> [!IMPORTANT]&1;> 时使用 Web 部件的导出功能，敏感数据可能无法导出到未经授权的用户。 有关如何防范此威胁的详细信息，请参阅[保护 Web 部件页](~/add/includes/ajax-current-ext-md.md)。       每当用户尝试导出，将显示默认消息。 但是，通过向 ExportSensitiveDataWarning 属性分配一个值，你可以提供自定义的警告消息。"
  example:
  - "The following code example demonstrates the declarative use of the ExportSensitiveDataWarning property.  \n  \n The code for the following Web page uses a standard <xref:System.Web.UI.WebControls.BulletedList> control and places it in a zone. The control will be wrapped with a <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> control at run time, which enables it to act as a true <xref:System.Web.UI.WebControls.WebParts.WebPart> control. To make the control exportable, an `ExportMode` attribute is added to the `<asp:bulletedlist>` element, and the attribute value is set to <xref:System.Web.UI.WebControls.WebParts.WebPartExportMode>, which means that both sensitive and non-sensitive data can be exported. Note also that in the `<asp:webpartmanager>` element, the `ExportSensitiveDataWarning` attribute is assigned a custom value.  \n  \n Note that for the code example to work, there is a setting you must add in the Web.config file to enable exporting Web Parts description files. Ensure that you have a Web.config file in the same directory as the Web page for this code example. Within the `<system.web>` section, make sure there is a `<webParts>` element with an `enableExport` attribute set to `true`, as in the following markup.  \n  \n `<webParts enableExport=\"true\">`  \n  \n `...`  \n  \n `</webParts>`  \n  \n [!code-vb[WebParts_WebPartManager_ExportSensitiveData#1](~/add/codesnippet/visualbasic/p-system.web.ui.webcontr_1033_1.aspx)]\n [!code-cs[WebParts_WebPartManager_ExportSensitiveData#1](~/add/codesnippet/csharp/p-system.web.ui.webcontr_1033_1.aspx)]  \n  \n After you load the page in a browser, click the verbs menu (represented by a downward arrow) in the title bar of the control that contains the links. In the verbs menu, select **Export**, and notice that a message box appears with the custom warning. If you want to continue with the export, click **OK**, which will allow you to save a local copy of an XML description file with all the data about the control."
  syntax:
    content: public virtual string ExportSensitiveDataWarning { get; set; }
    return:
      type: System.String
      description: "包含警告消息的字符串。 默认消息是由.NET Framework 提供的区域性特定值。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)
  id: ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: ExportWebPart(WebPart,XmlWriter)
  nameWithType: WebPartManager.ExportWebPart(WebPart,XmlWriter)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(WebPart,XmlWriter)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "创建包含的服务器控件的状态和属性数据的 XML 说明文件。"
  remarks: "ExportWebPart 方法将从各种状态和属性的数据组合`webPart`到 XML 文件。 数据包括有关控件本身，包括程序集、 状态数据和属性数据的信息。 启动导出的用户可以将 XML 文件保存到磁盘中，本地计算机或网络上。 然后，其他用户可以说明文件导入到另一个页面或网站，并将状态和属性数据应用到的其他实例`webPart`。 这样，用户可以共享并重复使用其服务器控件上的设置快速而方便的机制和它还为开发人员提供一种控制的外观和行为的导出和导入控件的方法。       上的属性`webPart`不导出的默认值。 若要启用导出的属性，必须将其与标记`[Personalizable]`的源代码中的属性。 也可以将标记为包含敏感数据，通过设置可导出属性`isSensitive`参数`[Personalizable]`属性设为`true`。 默认情况下，`isSensitive`是`false`。 开发人员可以将参数设置为`true`以指示数据是敏感。       若要启用`webPart`要导出，开发人员设置其<xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A>属性值为<xref:System.Web.UI.WebControls.WebParts.WebPartExportMode>（包括所有可个性化和敏感属性） 或<xref:System.Web.UI.WebControls.WebParts.WebPartExportMode>，导出敏感属性除。</xref:System.Web.UI.WebControls.WebParts.WebPartExportMode> </xref:System.Web.UI.WebControls.WebParts.WebPartExportMode> </xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A>      1> [!IMPORTANT]&1;> 允许用户将数据导出从控件，并将数据导入其他控件，需要某些安全风险。 开发人员应使用前面讨论方法来保护敏感数据，并且如果他们想要避免完全公开数据的风险，它们不使导出上`webPart`根本。 有关 Web 部件安全问题的详细信息，请参阅[保护 Web 部件页](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public virtual void ExportWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Xml.XmlWriter writer);
    parameters:
    - id: webPart
      type: System.Web.UI.WebControls.WebParts.WebPart
      description: "将从其导出数据控件。"
    - id: writer
      type: System.Xml.XmlWriter
      description: "<xref:System.Xml.XmlWriter>，它将从导出的数据写入`webPart`XML 说明文件。</xref:System.Xml.XmlWriter>"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>webPart</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>writer</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>webPart</code> is not contained in the collection of controls referenced in <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls*>.  \n  \n \\- or -  \n  \n The <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode*> property of <code>webPart</code> is set to a value of <xref href=\"System.Web.UI.WebControls.WebParts.WebPartExportMode\"></xref>, which means that export is disabled for <code>webPart</code>."
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.Focus
  id: Focus
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: Focus()
  nameWithType: WebPartManager.Focus()
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.Focus()
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "重写，以防止将焦点设置在<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>控制，因为它有没有用户界面 (UI)。"
  remarks: "焦点方法重写基<xref:System.Web.UI.Control.Focus%2A?displayProperty=fullName>方法，并在调用方调用的方法时引发异常。</xref:System.Web.UI.Control.Focus%2A?displayProperty=fullName> 因为<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件没有用户界面，并且是永远不会对用户可见，则它从不允许将焦点设置在本身上。</xref:System.Web.UI.WebControls.WebParts.WebPartManager>"
  syntax:
    content: public override void Focus ();
    parameters: []
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.Focus*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "调用方尝试调用不支持没有用户界面的控件中的焦点方法。"
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)
  id: GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: GetConsumerConnectionPoints(WebPart)
  nameWithType: WebPartManager.GetConsumerConnectionPoints(WebPart)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(WebPart)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "检索的集合<xref href=&quot;System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint&quot;></xref>可以充当从服务器的连接点的对象，它是控制作为 Web 部件连接中的使用者。"
  remarks: "Web 部件连接中始终涉及两个控件，一个充当数据，另一个充当数据的使用者的提供程序。 每个控件必须具有一个或多个定义为连接点的方法。 对于使用者控件，其连接点为<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>对象。</xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint> 检索使用者连接点是构成 Web 部件连接中的必需步骤。       使用者必须始终具有至少一个连接点，若要能够建立连接。 GetConsumerConnectionPoints 方法检查使用者控件，并检索其所有连接点的集合。 如果<xref:System.Web.UI.WebControls.WebParts.WebPart>控件具有没有连接点，该方法返回一个空集合。</xref:System.Web.UI.WebControls.WebParts.WebPart>"
  example:
  - "The following code example demonstrates how to use the GetConsumerConnectionPoints method.  \n  \n The code example has four parts:  \n  \n-   A user control that enables you to change display modes on a Web Parts page.  \n  \n-   A Web page that contains two custom <xref:System.Web.UI.WebControls.WebParts.WebPart> controls that can be connected, and an `<asp:webpartmanager>` element.  \n  \n-   A source code file that contains two custom <xref:System.Web.UI.WebControls.WebParts.WebPart> controls and a custom interface.  \n  \n-   An explanation of how the example works in a browser.  \n  \n The first part of the code example is the user control for changing display modes. You can obtain the source code for the user control from the Example section of the <xref:System.Web.UI.WebControls.WebParts.WebPartManager> class overview. For more information about display modes and how the user control works, see the topic [Walkthrough: Changing Display Modes on a Web Parts Page](~/add/includes/ajax-current-ext-md.md).  \n  \n The declarative markup for the Web page contains `Register` directives for both the user control and the custom controls. There is an `<asp:webpartmanager>` element, an `<asp:webpartzone>` element to contain the custom controls, and an `<asp:connectionszone>` element. Notice that in the `Page_Load` method, the code checks to see whether a connection already exists and, if not, defines a provider, a consumer, and their respective connection points, and then adds a new connection to the set of static connections referenced by the <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> property. Note that the <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection> object that is retrieved by using the GetConsumerConnectionPoints method is then passed to the <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> method to determine whether a connection between the two controls can be created.  \n  \n [!code-cs[WebParts_WebPartManager_StaticConnections#1](~/add/codesnippet/csharp/02749d07-cefa-48e1-9ad7-_1.aspx)]\n [!code-vb[WebParts_WebPartManager_StaticConnections#1](~/add/codesnippet/visualbasic/02749d07-cefa-48e1-9ad7-_1.aspx)]  \n  \n The third part of the example is the source code for the controls. You can obtain this code, and instructions for compiling it, from the Example section of the <xref:System.Web.UI.WebControls.WebParts.WebPartManager> class overview.  \n  \n After you have loaded the Web page in a browser, click the **Display Mode** drop-down list control and select **Connect** to switch the page to connect mode. Connect mode uses the `<asp:connectionszone>` element to enable you to create connections between controls. In connect mode, click the downward arrow in the title bar of the **ZIP Code** control to activate its verbs menu, and then click **Connect**. After the connection user interface (UI) appears, notice that a connection has already been created by the code contained in the `Page_Load` method. If you return to this page in a later browser session, this static connection will already be established and will not need to be recreated each time the page loads."
  syntax:
    content: public virtual System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);
    parameters:
    - id: webPart
      type: System.Web.UI.WebControls.WebParts.WebPart
      description: "一个充当使用者连接中的服务器控件。"
    return:
      type: System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection&quot;> </xref> ，其中包含使用者中的所有连接点。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>webPart</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager(System.Web.UI.Page)
  id: GetCurrentWebPartManager(System.Web.UI.Page)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: GetCurrentWebPartManager(Page)
  nameWithType: WebPartManager.GetCurrentWebPartManager(Page)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager(Page)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "检索的当前实例的引用<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>页上的控件。"
  remarks: "GetCurrentWebPartManager 方法是在上下文中有用你想要检索对当前的引用<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> 出现这种常用情况是如果你正在编写的自定义控件在开发过程的 ID 不能知道<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件置于其上将。</xref:System.Web.UI.WebControls.WebParts.WebPartManager>      1> [!NOTE]&1;> GetCurrentWebPartManager 方法是静态的因此您可以直接无的实例调用它<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager>       Web 部件中的某些控件控件集，如<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，具有<xref:System.Web.UI.WebControls.WebParts.WebPart.WebPartManager%2A>可以检索对当前的引用的属性<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> </xref:System.Web.UI.WebControls.WebParts.WebPart.WebPartManager%2A> </xref:System.Web.UI.WebControls.WebParts.WebPart> 因此，在使用此类控件，你应使用此属性来检索的引用。       如果你在编码在其中你知道的<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制，例如编写内联代码在 Web 页中，它是最简单和直接引用的<xref:System.Web.UI.WebControls.WebParts.WebPartManager>id 的控制</xref:System.Web.UI.WebControls.WebParts.WebPartManager>方式效率最高</xref:System.Web.UI.WebControls.WebParts.WebPartManager>ID 的上下文中"
  example:
  - "The following code example demonstrates how to use the GetCurrentWebPartManager method. The example has two parts: a custom server control, and a Web page that hosts the control.  \n  \n The custom <xref:System.Web.UI.WebControls.Label> control uses the GetCurrentWebPartManager method to retrieve the ID of the <xref:System.Web.UI.WebControls.WebParts.WebPartManager> control on the current page, and then displays the ID.  \n  \n [!code-cs[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/add/codesnippet/csharp/42edcc7a-0f38-4926-86e7-_1.cs)]\n [!code-vb[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/add/codesnippet/visualbasic/42edcc7a-0f38-4926-86e7-_1.vb)]  \n  \n The following code example provides the Web page that hosts the control in a <xref:System.Web.UI.WebControls.WebParts.WebPartZone> zone.  \n  \n [!code-cs[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/add/codesnippet/csharp/42edcc7a-0f38-4926-86e7-_2.aspx)]\n [!code-vb[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/add/codesnippet/visualbasic/42edcc7a-0f38-4926-86e7-_2.aspx)]  \n  \n After you load the page in a browser, notice that the ID of the current <xref:System.Web.UI.WebControls.WebParts.WebPartManager> control is displayed within the custom <xref:System.Web.UI.WebControls.Label> control."
  syntax:
    content: public static System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager (System.Web.UI.Page page);
    parameters:
    - id: page
      type: System.Web.UI.Page
      description: "包含的实例的 Web 页<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;> </xref>。"
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartManager
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;> </xref>引用页面上的控件的当前实例。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>page</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.GetDisplayTitle(System.Web.UI.WebControls.WebParts.WebPart)
  id: GetDisplayTitle(System.Web.UI.WebControls.WebParts.WebPart)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: GetDisplayTitle(WebPart)
  nameWithType: WebPartManager.GetDisplayTitle(WebPart)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.GetDisplayTitle(WebPart)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "获取包含的值的字符串<xref:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle*>属性<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>控件。</xref:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle*>"
  remarks: "获取的计算所得的值<xref:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle%2A>属性`webPart`。</xref:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle%2A> 当开发人员不将值赋给<xref:System.Web.UI.WebControls.WebParts.Part.Title%2A>属性<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，此方法产生的值显示为标题。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.Part.Title%2A> 无标题控件的计算的值包含，该值指示在当前区域内的控件的序列号为一个字符串，后面追加一个数字。"
  syntax:
    content: protected virtual string GetDisplayTitle (System.Web.UI.WebControls.WebParts.WebPart webPart);
    parameters:
    - id: webPart
      type: System.Web.UI.WebControls.WebParts.WebPart
      description: "控件，该方法返回的<xref:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle*>.</xref:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle*>值"
    return:
      type: System.String
      description: "一个字符串，包含的计算所得的值<xref:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle*>为<code> webPart </code>。</xref:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle*>"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.GetDisplayTitle*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>webPart</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>webPart</code>不在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls*>集合。"
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl(System.Web.UI.WebControls.WebParts.WebPart)
  id: GetExportUrl(System.Web.UI.WebControls.WebParts.WebPart)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: GetExportUrl(WebPart)
  nameWithType: WebPartManager.GetExportUrl(WebPart)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl(WebPart)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "获取相对虚拟路径和查询字符串的请求的一部分时用户尝试导出<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>控件。"
  remarks: "GetExportUrl 方法返回的值是指向包含该控件的页以及窗体导出请求提交到服务器的追加的查询字符串值的服务器位置的相对虚拟路径。 GetExportUrl 方法再允许提交，以防止恶意脚本攻击的请求编码字符串。      1> [!NOTE]&1;> 有关保护 Web 部件应用程序的详细信息，请参阅[保护 Web 部件页](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public string GetExportUrl (System.Web.UI.WebControls.WebParts.WebPart webPart);
    parameters:
    - id: webPart
      type: System.Web.UI.WebControls.WebParts.WebPart
      description: "<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;> </xref>正在导出。"
    return:
      type: System.String
      description: "一个字符串，包含了相对虚拟路径和查询字符串共同形成导出控件的请求。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart(System.Web.UI.Control)
  id: GetGenericWebPart(System.Web.UI.Control)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: GetGenericWebPart(Control)
  nameWithType: WebPartManager.GetGenericWebPart(Control)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart(Control)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "获取到的实例的引用<xref href=&quot;System.Web.UI.WebControls.WebParts.GenericWebPart&quot;></xref>包含服务器控件的控件。"
  remarks: "一般情况下，有两种类别的控件的开发人员放在<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域，以参与 Web 部件应用程序︰<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，继承自<xref:System.Web.UI.WebControls.WebParts.WebPart>基类和其他服务器控件，它可以是标准 ASP.NET 控件、 自定义控件或用户控件。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 当任何这些控件将置于<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域，它将的功能<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> A<xref:System.Web.UI.WebControls.WebParts.WebPart>控件具有此功能本质上就是，但其他类型的服务器控件不这样做。</xref:System.Web.UI.WebControls.WebParts.WebPart> 若要启用其他服务器控件，使其作为<xref:System.Web.UI.WebControls.WebParts.WebPart>控制当它们都将置于<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域，ASP.NET 包装它们与<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控件。</xref:System.Web.UI.WebControls.WebParts.GenericWebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> </xref:System.Web.UI.WebControls.WebParts.WebPart> 因为<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控件继承直接从<xref:System.Web.UI.WebControls.WebParts.WebPart>类，它为其子控件提供 true Web 部件功能。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.GenericWebPart>       通常在运行时，页开发人员可能想要获取对引用<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>包含一个区域中的服务器控件的控件。</xref:System.Web.UI.WebControls.WebParts.GenericWebPart> GetGenericWebPart 方法使它们能够检索到的引用<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控件。</xref:System.Web.UI.WebControls.WebParts.GenericWebPart>"
  example:
  - "The following code example demonstrates the use of the GetGenericWebPart method. The code example contains a <xref:System.Web.UI.WebControls.Calendar> control declared within a <xref:System.Web.UI.WebControls.WebParts.WebPartZone> zone. The `Button1_Click` method first prints the ID of the <xref:System.Web.UI.WebControls.Calendar> control to a label, and then uses the GetGenericWebPart method to retrieve a reference to the <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> control that wraps the calendar. The ID of the <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> control, and the ID of its child control (which is the <xref:System.Web.UI.WebControls.Calendar> control), are both printed to a second label.  \n  \n [!code-cs[WebParts_WebPartManager_GetGenericWebPart#1](~/add/codesnippet/csharp/d656242f-a1d2-490c-85d4-_1.aspx)]\n [!code-vb[WebParts_WebPartManager_GetGenericWebPart#1](~/add/codesnippet/visualbasic/d656242f-a1d2-490c-85d4-_1.aspx)]"
  syntax:
    content: public System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart (System.Web.UI.Control control);
    parameters:
    - id: control
      type: System.Web.UI.Control
      description: "中存在的服务器控件<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartZoneBase&quot;></xref>和包装为子控件的<xref href=&quot;System.Web.UI.WebControls.WebParts.GenericWebPart&quot;></xref>在运行时。"
    return:
      type: System.Web.UI.WebControls.WebParts.GenericWebPart
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.GenericWebPart&quot;> </xref>包装<code> control </code>为子控件。 该方法返回<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果<code> control </code>未包含在<xref href=&quot;System.Web.UI.WebControls.WebParts.GenericWebPart&quot;> </xref>。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>control</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)
  id: GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: GetProviderConnectionPoints(WebPart)
  nameWithType: WebPartManager.GetProviderConnectionPoints(WebPart)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(WebPart)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "检索的集合<xref href=&quot;System.Web.UI.WebControls.WebParts.ProviderConnectionPoint&quot;></xref>可以充当从服务器的连接点的对象，它是控制作为 Web 部件连接中的提供者。"
  remarks: "Web 部件连接中始终涉及两个控件，一个充当数据，另一个充当数据的使用者的提供程序。 每个控件必须具有一个或多个定义为连接点的方法。 对于提供程序控件，其连接点为<xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint>对象。</xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint>       一个提供程序必须始终具有至少一个连接点，若要能够建立连接。 GetProviderConnectionPoints 方法检查提供程序控制并检索其所有连接点的集合。 检索提供程序连接点是构成 Web 部件连接中的必需步骤。"
  example:
  - "The following code example demonstrates how to use the GetProviderConnectionPoints method.  \n  \n The example has four parts:  \n  \n-   A user control that enables you to change display modes on a Web Parts page.  \n  \n-   A Web page that contains two custom <xref:System.Web.UI.WebControls.WebParts.WebPart> controls that can be connected, and an `<asp:webpartmanager>` element.  \n  \n-   A source code file that contains two custom <xref:System.Web.UI.WebControls.WebParts.WebPart> controls and a custom interface.  \n  \n-   An explanation of how the example works in a browser.  \n  \n The first part of the code example is the user control for changing display modes. You can obtain the source code for the user control from the Example section of the <xref:System.Web.UI.WebControls.WebParts.WebPartManager> class overview. For more information about display modes and how the user control works, see [Walkthrough: Changing Display Modes on a Web Parts Page](~/add/includes/ajax-current-ext-md.md).  \n  \n The declarative markup for the Web page contains `Register` directives for both the user control and the custom controls. There is an `<asp:webpartmanager>` element, an `<asp:webpartzone>` element to contain the custom controls, and an `<asp:connectionszone>` element. Notice that in the `Page_Load` method, the code checks to see whether a connection already exists and, if not, defines a provider, a consumer, and their respective connection points, and then adds a new connection to the set of static connections referenced by the <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> property. Note that the <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection> object that is retrieved by using the GetProviderConnectionPoints method is then passed to the <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> method to determine whether a connection between the two controls can be created.  \n  \n [!code-cs[WebParts_WebPartManager_StaticConnections#1](~/add/codesnippet/csharp/7aa405f8-9f90-4b6f-8d66-_1.aspx)]\n [!code-vb[WebParts_WebPartManager_StaticConnections#1](~/add/codesnippet/visualbasic/7aa405f8-9f90-4b6f-8d66-_1.aspx)]  \n  \n The third part of the example is the source code for the controls. You can obtain this code, and instructions for compiling it, from the Example section of the <xref:System.Web.UI.WebControls.WebParts.WebPartManager> class overview.  \n  \n After you have loaded the Web page in a browser, click the **Display Mode** drop-down list control and select **Connect** to switch the page to connect mode. Connect mode uses the `<asp:connectionszone>` element to enable you to create connections between controls. In connect mode, click the downward arrow in the title bar of the **ZIP Code** control to activate its verbs menu, and then click **Connect**. After the connection user interface (UI) appears, notice that a connection has already been created by the code contained in the `Page_Load` method. If you return to this page in a later browser session, this static connection will already be established and will not need to be recreated each time the page loads."
  syntax:
    content: public virtual System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);
    parameters:
    - id: webPart
      type: System.Web.UI.WebControls.WebParts.WebPart
      description: "一个充当提供程序连接中的服务器控件。"
    return:
      type: System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection&quot;> </xref> ，其中包含提供程序中的所有连接点。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>webPart</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)
  id: ImportWebPart(System.Xml.XmlReader,System.String@)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: ImportWebPart(XmlReader,String)
  nameWithType: WebPartManager.ImportWebPart(XmlReader,String)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(XmlReader,String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "导入包含状态和属性数据的 XML 说明文件<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>控制，并将数据应用到控件。"
  remarks: "ImportWebPart 方法导入由 XML 说明文件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>的服务器控件的方法。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> 它不是导入，则实际的服务器控件，但仅包含有关控件的状态和属性数据的说明文件。 控件和说明文件中引用的程序集必须已经是用户尝试导入说明文件服务器上可用。       若要启用导入一个控件，开发人员需要添加<xref:System.Web.UI.WebControls.WebParts.CatalogZone>将在何处启用导入的页上的控件。</xref:System.Web.UI.WebControls.WebParts.CatalogZone> 在该区域，<xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart>必须添加控件。</xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> 此控件提供一个文件对话框，允许用户浏览并找到要导入的说明文件。       在用户查找的描述文件，并开始导入后，由 ImportWebPart 方法读取说明文件。 如果没有错误，并且如果找到的程序集和控件，将服务器控件添加到目录中<xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart>控制和说明文件中指定的各种属性和状态数据应用于控件。</xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> 然后，用户可以选择的控件，并将其添加到页面。      1> [!IMPORTANT]&1;> 如<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>方法，ImportWebPart 方法有一些潜在的安全风险。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> 因为它涉及到将数据导入网站，恶意用户可能尝试插入到说明文件导入的错误数据或甚至脚本代码。 然后将错误数据无法显示页面，或在数据库中，或插入的脚本无法运行。 与导入描述文件，以及避免这些风险的方法关联的潜在风险的概述，请参阅[保护 Web 部件页](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public virtual System.Web.UI.WebControls.WebParts.WebPart ImportWebPart (System.Xml.XmlReader reader, out string errorMessage);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "<xref:System.Xml.XmlReader>，从要导入的 XML 说明文件中读取的状态和属性数据。</xref:System.Xml.XmlReader>"
    - id: errorMessage
      type: System.String
      description: "A <xref:System.String>，将向用户显示如果导入过程中遇到错误。</xref:System.String>"
    return:
      type: System.Web.UI.WebControls.WebParts.WebPart
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;> </xref> (或由包装的服务器控件<xref href=&quot;System.Web.UI.WebControls.WebParts.GenericWebPart&quot;> </xref> ，因此会视为<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;> </xref>) 导入的 XML 说明文件中引用。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>reader</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.EndOfStreamException
    commentId: T:System.IO.EndOfStreamException
    description: "<code>reader</code> could not read the file.  \n  \n \\- or -  \n  \n <code>reader</code> needed to display an import error message but did not find one in the file.  \n  \n \\- or -  \n  \n <code>reader</code> reached the end of the file without finding the XML element that contains the exported data."
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.Internals
  id: Internals
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: Internals
  nameWithType: WebPartManager.Internals
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.Internals
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "获取对<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManagerInternals&quot;></xref>类，该类用于合并和拆分中实际实现的方法的一组<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>类，但通常用于控件开发人员。"
  remarks: "内部属性公开的 Api 来调入一组<xref:System.Web.UI.WebControls.WebParts.WebPartManager>主要用于扩展性用例的方法。</xref:System.Web.UI.WebControls.WebParts.WebPartManager>       若要使用这些内部的方法的设计的方法是通过内部属性访问它们。 由于受保护属性，你仅可以访问它并调用<xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals>通过从<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类</xref:System.Web.UI.WebControls.WebParts.WebPartManager>继承的类</xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals>的实例内的方法      1> [!NOTE]&1;> 此属性隐藏的中的 IntelliSense [!INCLUDE[vsprvsext](~/add/includes/ajax-current-ext-md.md)]。 但是，在派生<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类，则仍可以访问的属性，其不同的成员。</xref:System.Web.UI.WebControls.WebParts.WebPartManager>"
  syntax:
    content: protected System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals { get; }
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartManagerInternals
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManagerInternals&quot;> </xref>，通过该<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>可以引用被分隔成的各种方法<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManagerInternals&quot;> </xref>。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.Internals*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Web.UI.WebControls.WebParts.WebPart)
  id: IsAuthorized(System.Web.UI.WebControls.WebParts.WebPart)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: IsAuthorized(WebPart)
  nameWithType: WebPartManager.IsAuthorized(WebPart)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(WebPart)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "确定控件是否有权添加到页面中的初始步骤将执行。"
  remarks: "IsAuthorized 方法是调用 Web 部件控件集用来检查授权的初始方法<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。</xref:System.Web.UI.WebControls.WebParts.WebPart> 它接受`webPart`作为参数，并开始最终确定是否将控件添加到页的过程。 此方法在代码中直接调用需要以确定是否授权给定的控件时。       此方法执行初始任务确定控件是否继承自<xref:System.Web.UI.WebControls.WebParts.WebPart>类或者是否<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控制，并且，如果是这样，哪种类型的子控制它包含。</xref:System.Web.UI.WebControls.WebParts.GenericWebPart> </xref:System.Web.UI.WebControls.WebParts.WebPart> 若要完成的任务的授权，它调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>重载方法。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>"
  example:
  - "The following code example demonstrates how to call the IsAuthorized method from your code to determine whether a control is authorized to be added to a page.  \n  \n The code example has three parts:  \n  \n-   A custom <xref:System.Web.UI.WebControls.WebParts.WebPartManager> control that overrides the IsAuthorized method.  \n  \n-   A Web page that creates a filter for a <xref:System.Web.UI.WebControls.WebParts.WebPart> control.  \n  \n-   An explanation of how to run the code example.  \n  \n This code example uses a custom <xref:System.Web.UI.WebControls.WebParts.WebPartManager> control that overrides the <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> overload method to provide custom handling of the <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> property. This control checks for a property value of `admin` and, if the value is present, authorizes the control. If a control has a different value, it is not authorized; controls without the property value are authorized as well, as they are presumed not to be part of the filtering scenario.  \n  \n For this code example to run, you must compile this source code. You can compile it explicitly and put the resulting assembly in your Web site's Bin folder or the global assembly cache. Alternatively, you can put the source code in your site's App_Code folder, where it will be dynamically compiled at run time. This code example uses the dynamic compile method. For a walkthrough that demonstrates how to compile, see [Walkthrough: Developing and Using a Custom Web Server Control](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[WebParts_WebPartManager_IsAuthorized#2](~/add/codesnippet/csharp/9c13e351-e761-4514-8860-_1.cs)]\n [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/add/codesnippet/visualbasic/9c13e351-e761-4514-8860-_1.vb)]  \n  \n The second part of the code example creates a filter that can potentially exclude a control. The following Web page contains three ASP.NET server controls in an `<asp:webpartzone>` element. Notice that the first and second controls have their <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> properties set to different values, and the third does not assign the property. This authorization value can be checked at run time, and the control can be added to the page if the filter matches criteria set by the developer. Notice also that in the `Page_Load` method, the code calls the IsAuthorized method to determine whether each of the controls is authorized, and if so, it sets each control's <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A> property.  \n  \n [!code-cs[WebParts_WebPartManager_IsAuthorized#1](~/add/codesnippet/csharp/9c13e351-e761-4514-8860-_2.aspx)]\n [!code-vb[WebParts_WebPartManager_IsAuthorized#1](~/add/codesnippet/visualbasic/9c13e351-e761-4514-8860-_2.aspx)]  \n  \n Note that for the code example to work, you must add a setting in the Web.config file to enable exporting Web Parts description files. Ensure that you have a Web.config file in the same directory as the Web page for this code example. Within the `<system.web>` section, make sure there is a `<webParts>` element with an `enableExport` attribute set to `true`, as in the following markup.  \n  \n `<webParts enableExport=\"true\">`  \n  \n `...`  \n  \n `</webParts>`  \n  \n After you load the page in a browser, note that the first control is displayed, because it matches the criteria in the overridden method. The second control is not added to the page, because it is excluded by the filter. The third control is also added, because it does not have its <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> property set. Notice that if you click the verbs menu icon in the title bar of either control, they can both be exported because their respective <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A> property values were assigned."
  syntax:
    content: public bool IsAuthorized (System.Web.UI.WebControls.WebParts.WebPart webPart);
    parameters:
    - id: webPart
      type: System.Web.UI.WebControls.WebParts.WebPart
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;> </xref>或正在接受授权检查其他服务器控件。"
    return:
      type: System.Boolean
      description: "一个布尔值，该值指示是否<code> webPart </code>可以添加到页。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>webPart</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)
  id: IsAuthorized(System.Type,System.String,System.String,System.Boolean)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: IsAuthorized(Type,String,String,Boolean)
  nameWithType: WebPartManager.IsAuthorized(Type,String,String,Boolean)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(Type,String,String,Boolean)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "确定控件是否有权添加到页面中的最后步骤执行。"
  remarks: "确定控件是否有权添加到页面中的最后步骤执行 IsAuthorized 重载方法。 该方法确保`type`是有效的类型，而`path`被检查的控件是一个用户控件的情况下，才会包含一个值。 然后，它调用的重要<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法，将引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>"
  example:
  - "The following code example demonstrates how to override the IsAuthorized method to determine whether a control is authorized to be added to a page.  \n  \n The first step is to create a filter that can potentially exclude a control. The following Web page contains three ASP.NET server controls in an `<asp:webpartzone>` element. Notice that the first and second controls have their <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> properties set to different values, and the third does not assign the property. This authorization value can be checked at run time, and the control can be added to the page if the filter matches criteria set by the developer.  \n  \n [!code-cs[WebParts_WebPartManager_IsAuthorized#1](~/add/codesnippet/csharp/c3cfcde3-abf1-45f3-ace8-_1.aspx)]\n [!code-vb[WebParts_WebPartManager_IsAuthorized#1](~/add/codesnippet/visualbasic/c3cfcde3-abf1-45f3-ace8-_1.aspx)]  \n  \n The second step is to override the IsAuthorized method, and create custom handling for authorization filters. Note that the code first checks whether the property has a value, so that any control that does not assign the <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> property will be added automatically. If a control has a filter, the code returns `true` only if the filter value is equal to `admin`. This demonstrates a simple mechanism you can use for displaying certain controls to certain users, depending on their role. While a full example using roles is beyond the scope of this topic, you could use the same logic as the overridden method in this code example, except that you could check whether the current user is in a role that matches the authorization filter value, and then add the control only for that user. This would enable you to create pages where some users would see all the controls, and other users would see only selected controls. This is how the logic that checks the filter might look if you used roles:  \n  \n [Visual Basic]  \n  \n```  \nIf Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter) Then  \n  return True  \nElse  \n  return False  \nEnd If  \n```  \n  \n [C#]  \n  \n```  \nif(Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter))  \n    return true;  \nelse  \n    return false;  \n```  \n  \n For the code example to run, you must compile this source code. You can compile it explicitly and put the resulting assembly in your Web site's Bin folder or the global assembly cache. Alternatively, you can put the source code in your site's App_Code folder, where it will be dynamically compiled at run time. This code example uses the dynamic compile method. For a walkthrough that demonstrates how to compile, see [Walkthrough: Developing and Using a Custom Web Server Control](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[WebParts_WebPartManager_IsAuthorized#2](~/add/codesnippet/csharp/c3cfcde3-abf1-45f3-ace8-_2.cs)]\n [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/add/codesnippet/visualbasic/c3cfcde3-abf1-45f3-ace8-_2.vb)]  \n  \n After you load the page in a browser, note that the first control is displayed, because it matches the criteria in the overridden method. The second control is not added to the page, because its filter value is excluded. The third control is added, because it does not have its <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> property set. If you change the property value on the second control to match that of the first control, and then run the page again, the second control is added as well."
  syntax:
    content: public virtual bool IsAuthorized (Type type, string path, string authorizationFilter, bool isShared);
    parameters:
    - id: type
      type: System.Type
      description: "<xref:System.Type>的控件进行授权检查。</xref:System.Type>"
    - id: path
      type: System.String
      description: "被授权，如果控件是一个用户控件的控件的源文件相对的应用程序路径。"
    - id: authorizationFilter
      type: System.String
      description: "分配给一个任意字符串值<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter*>属性<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>用来授权是否可以将控件添加到页上的控件。</xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter*>"
    - id: isShared
      type: System.Boolean
      description: "指示被检查授权控件是否共享的控制，这意味着它对应用程序的许多或所有用户可见并将其<xref:System.Web.UI.WebControls.WebParts.WebPart.IsShared*>属性值设置为<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。</xref:System.Web.UI.WebControls.WebParts.WebPart.IsShared*>"
    return:
      type: System.Boolean
      description: "一个布尔值，该值指示控件是否有权添加到页。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>type</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>type</code> is a user control, and <code>path</code> is either <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref> or an empty string (\"\").  \n  \n \\- or -  \n  \n <code>type</code> is not a user control, and <code>path</code> has a value assigned to it."
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty
  id: IsCustomPersonalizationStateDirty
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: IsCustomPersonalizationStateDirty
  nameWithType: WebPartManager.IsCustomPersonalizationStateDirty
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "获取一个值，该值指示是否进行了个性化更改会影响由控制页级个性化设置详细信息， <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;> </xref>控件。"
  remarks: "<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件在内部使用 IsCustomPersonalizationStateDirty 属性来跟踪是否有任何它所管理的数据已更改的页级别个性化设置。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> 当用户执行各种级别的页，如添加或删除的个性化设置操作时，将更改个性化数据<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，连接或断开控件，通过移动控件和其他操作更改页面的布局。</xref:System.Web.UI.WebControls.WebParts.WebPart>      1> [!NOTE]&1;> 用户还可以执行级别的控制，这意味着它们对特定的控件进行个性化修改，个性化和所做的更改仅影响该控件。 示例将编辑控件，并可以更改其标题文本或它的背景色。 控件级别个性化设置不会影响所跟踪的页面级别个性化数据<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件，并因此 IsCustomPersonalizationStateDirty 属性值不会更改为`true`控件级别个性化发生时。</xref:System.Web.UI.WebControls.WebParts.WebPartManager>       尽管该方法受保护并不直接由调用方，访问<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>直接由调用方，然后才能访问属性，并返回此属性的值。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>"
  syntax:
    content: protected virtual bool IsCustomPersonalizationStateDirty { get; }
    return:
      type: System.Boolean
      description: "一个布尔值，该值指示是否进行了个性化设置更改。 默认值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState(System.Object)
  id: LoadControlState(System.Object)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: LoadControlState(Object)
  nameWithType: WebPartManager.LoadControlState(Object)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState(Object)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "加载的控件状态数据已保存来自前面的页请求，并需要还原在后续请求。"
  remarks: "方法可用于还原应在回发期间的页上，保留的属性数据 LoadControlState 即使<xref:System.Web.UI.Control.EnableViewState%2A>属性设置为`false`。</xref:System.Web.UI.Control.EnableViewState%2A>"
  syntax:
    content: protected override void LoadControlState (object savedState);
    parameters:
    - id: savedState
      type: System.Object
      description: "包含要加载的保留的状态数据。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>savedState</code>不是有效<xref:System.Web.UI.PageStatePersister.ControlState*>。"
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)
  id: LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: LoadCustomPersonalizationState(PersonalizationDictionary)
  nameWithType: WebPartManager.LoadCustomPersonalizationState(PersonalizationDictionary)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(PersonalizationDictionary)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "存储已传递到自定义个性化数据<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>由个性化对象会在初始化过程中使用的控件。"
  remarks: "LoadCustomPersonalizationState 方法提供的窗体中的已保存的状态数据<xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary>对象。</xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> 此数据最终使用加载到 Web 部件控件的个性化数据以及执行其他初始化任务。      1> [!NOTE]&1;> 开始时的一系列方法调用此方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState%2A>方法最初请求关联<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>对象提供个性化数据到<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> </xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState%2A>       不能在代码中直接调用此方法。 但是，，可以直接调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A>方法，后者自身调用 LoadCustomPersonalizationState 方法，并返回个性化数据。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A>"
  syntax:
    content: protected virtual void LoadCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);
    parameters:
    - id: state
      type: System.Web.UI.WebControls.WebParts.PersonalizationDictionary
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.PersonalizationDictionary&quot;> </xref> ，其中包含要加载的状态数据。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet
  id: MediumPermissionSet
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: MediumPermissionSet
  nameWithType: WebPartManager.MediumPermissionSet
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "获取<xref href=&quot;System.Security.PermissionSet&quot;></xref>对象，它仅允许<xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;></xref>权限和<xref href=&quot;System.Web.AspNetHostingPermissionLevel&quot;></xref>权限。"
  remarks: "<xref:System.Security.PermissionSet>类型反序列化导入过程中使用此属性返回的对象。</xref:System.Security.PermissionSet>"
  syntax:
    content: protected virtual System.Security.PermissionSet MediumPermissionSet { get; }
    return:
      type: System.Security.PermissionSet
      description: "A <xref href=&quot;System.Security.PermissionSet&quot;> </xref>对象，它仅允许<xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;></xref>权限和<xref href=&quot;System.Web.AspNetHostingPermissionLevel&quot;></xref>权限。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet
  id: MinimalPermissionSet
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: MinimalPermissionSet
  nameWithType: WebPartManager.MinimalPermissionSet
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "获取<xref href=&quot;System.Security.PermissionSet&quot;></xref>对象，它仅允许<xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;></xref>权限和<xref href=&quot;System.Web.AspNetHostingPermissionLevel&quot;></xref>权限。"
  remarks: "<xref:System.Security.PermissionSet>导入所有操作都只键入反序列化过程中使用此属性返回的对象。</xref:System.Security.PermissionSet>"
  syntax:
    content: protected virtual System.Security.PermissionSet MinimalPermissionSet { get; }
    return:
      type: System.Security.PermissionSet
      description: "获取<xref href=&quot;System.Security.PermissionSet&quot;></xref>对象，它仅允许<xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;></xref>权限和<xref href=&quot;System.Web.AspNetHostingPermissionLevel&quot;></xref>权限。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)
  id: MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: MoveWebPart(WebPart,WebPartZoneBase,Int32)
  nameWithType: WebPartManager.MoveWebPart(WebPart,WebPartZoneBase,Int32)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(WebPart,WebPartZoneBase,Int32)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "将移动<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>或服务器控件从一个<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartZoneBase&quot;></xref>区域到另一个，或到同一区域内的新位置。"
  remarks: "<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件使用 MoveWebPart 方法来移动`webPart`到在同一区域中，或不同区域中的新位置。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> 你可以直接从代码中，调用此方法，也会调用时用户将控件移到新位置在 Web 部件用户界面 (UI) 中使用各种选项。       之前，必须满足的条件数`webPart`可以移动，和其中的大部分由本主题的异常部分中列出的项。 如果`webPart`中未包含<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域开始时，不能移入某个区域。</xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>       在满足的条件后，操作按以下顺序发生移动`webPart`: 1。  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A>方法引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>事件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A>      2.  `webPart`从其当前区域 （如有必要），删除和添加到其新的区域或在其当前的区域内的新位置。      3.  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A>方法引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>事件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A>      4.  `zoneIndex`的每个<xref:System.Web.UI.WebControls.WebParts.WebPart>起点和目标区域中的控件重置，以反映移动的控件。</xref:System.Web.UI.WebControls.WebParts.WebPart>"
  example:
  - "The following code example demonstrates how to call the MoveWebPart method directly from code to move a <xref:System.Web.UI.WebControls.WebParts.WebPart> control from one zone to another.  \n  \n The code example has three parts:  \n  \n-   A user control for changing display modes.  \n  \n-   A Web page to host the controls.  \n  \n-   An explanation of how to run the code example.  \n  \n The first part of the code example is the user control for changing display modes. You can obtain the source code for the user control from the Example section of the <xref:System.Web.UI.WebControls.WebParts.WebPartManager> class overview. For more information about display modes and how the user control works, see [Walkthrough: Changing Display Modes on a Web Parts Page](~/add/includes/ajax-current-ext-md.md).  \n  \n The second part of the example is a Web page that contains two zones, each of which contains two server controls. When a user clicks the **Move WebPart** button on the page, the code in the `Button1_Click` method moves a control from the first zone to a new position in the second zone. Notice that the code first must call the <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> method to retrieve the <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> object that wraps the `list1` control. This is required because the first parameter of the MoveWebPart method requires a <xref:System.Web.UI.WebControls.WebParts.WebPart> control, whereas `list1` is an ASP.NET server control.  \n  \n [!code-cs[WebParts_WebPartManager_MoveWebPart#1](~/add/codesnippet/csharp/49caf3f6-e63d-4133-bdf2-_1.aspx)]\n [!code-vb[WebParts_WebPartManager_MoveWebPart#1](~/add/codesnippet/visualbasic/49caf3f6-e63d-4133-bdf2-_1.aspx)]  \n  \n After the page loads, click the **Move WebPart** button, and note that the control that contains the links moves into the middle position in the second zone. This movement of the control is accomplished programmatically by calling the MoveWebPart method. You can also use the **Display Mode** drop-down list control to switch the page to design mode, and in design mode, you can drag the controls to different zones or different positions within their zones. The MoveWebPart method is also called by the <xref:System.Web.UI.WebControls.WebParts.WebPartManager> control to handle such user-initiated moves."
  syntax:
    content: public virtual void MoveWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);
    parameters:
    - id: webPart
      type: System.Web.UI.WebControls.WebParts.WebPart
      description: "<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;> </xref>或移动其他服务器控件。"
    - id: zone
      type: System.Web.UI.WebControls.WebParts.WebPartZoneBase
      description: "目标<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartZoneBase&quot;></xref>到`webPart`将被移。"
    - id: zoneIndex
      type: System.Int32
      description: "一个整数，指示的索引`webPart`相对于其他控件内`zone`。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>webPart</code> is not contained in the <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls*> collection of the <xref href=\"System.Web.UI.WebControls.WebParts.WebPartManager\"></xref> control.  \n  \n \\- or -  \n  \n <code>zone</code> is not contained in the <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones*> collection of the <xref href=\"System.Web.UI.WebControls.WebParts.WebPartManager\"></xref> control.  \n  \n \\- or -  \n  \n The zone referenced by the <code>webPart</code> control's <xref:System.Web.UI.WebControls.WebParts.WebPart.Zone*> property is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>, which means that <code>webPart</code> is not currently contained in a zone."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>webPart</code>or <code>zone</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>zoneIndex</code>小于零。"
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)
  id: OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: OnAuthorizeWebPart(WebPartAuthorizationEventArgs)
  nameWithType: WebPartManager.OnAuthorizeWebPart(WebPartAuthorizationEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(WebPartAuthorizationEventArgs)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "引发<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart&quot;></xref>事件并调用事件处理程序，如果存在。"
  remarks: "调用 OnAuthorizeWebPart 方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法，当<xref:System.Web.UI.WebControls.WebParts.WebPart>控件要添加到页面的授权检查。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 当调用 OnAuthorizeWebPart 方法时，将引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件，并且如果没有为事件处理程序方法，它调用处理程序。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>       授权的过程<xref:System.Web.UI.WebControls.WebParts.WebPart>控件是一个重要的 Web 部件功能。</xref:System.Web.UI.WebControls.WebParts.WebPart> 每个<xref:System.Web.UI.WebControls.WebParts.WebPart>或添加到的区域的服务器控件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件将经历授权过程以确定是否可以添加控件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> </xref:System.Web.UI.WebControls.WebParts.WebPart> 默认情况下，Web 部件控件集不提供任何筛选条件，以防止控件添加到区域。 但控件集提供了开发人员创建其自己的筛选条件所需的机制。 通过使用这些机制，可以创建自定义筛选方案。 例如，你可以创建筛选器，以便如果用户是管理员角色中，某些控件将添加到区域中，当呈现页面，并且如果用户是用户角色中，将不会添加这些控件。       在授权过程中筛选控件使用机制<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>和 OnAuthorizeWebPart 方法和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>上的事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> </xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>       若要创建筛选的方案，没有实质上是两个任务。 首先，你还将字符串转换为分配<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>每个属性<xref:System.Web.UI.WebControls.WebParts.WebPart>你想要筛选的控件。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 这些字符串值可以是任意的但它们应包含你想要作为筛选依据的条件。 例如，如果你想给定的控件要添加到区域才管理员用户正在查看页上，则可以分配的字符串值`admin`的属性。 然后可以使用 ASP.NET 角色功能，并将你的站点的所有用户都添加到各种角色，例如管理员、 经理和用户。 当正在加载页面时，筛选代码将检查用户的哪些角色中，将其与要检查的控件上的授权筛选器值比较，如果该用户的管理员角色的是 （例如），并且你已设置的控件<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>值赋给`admin`，无法添加控件。</xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>       创建筛选方案的第二步是编写代码以检查<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性值在<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，并确定每个控件是否已被添加到其区域之前的授权。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 有两个用于此筛选代码的放置位置选项。 第一个选项是页开发人员的首选的选项。 你可以创建一个方法来处理<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>直接在 Web 页的服务器脚本代码，或单独的代码文件中的事件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 将你的方法与事件相关联通过添加`OnAuthorizeWebPart`属性设为的标记<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制在页中，如下面的示例标记代码中所示。</xref:System.Web.UI.WebControls.WebParts.WebPartManager>      ```   <asp:webpartmanager id=&quot;manager1&quot; runat=&quot;server&quot;       OnAuthorizeWebPart=&quot;manager1_AuthorizeWebPart&quot; />   ```所有自定义方法都只需是检查每个<xref:System.Web.UI.WebControls.WebParts.WebPart>控制是否满足筛选条件，然后，根据结果，将分配到一个布尔值<xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs.IsAuthorized%2A>属性<xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs>对象，以指示是否<xref:System.Web.UI.WebControls.WebParts.WebPart>可以添加控件。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs> </xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs.IsAuthorized%2A> </xref:System.Web.UI.WebControls.WebParts.WebPart> 示例部分中的代码演示如何执行此操作。       有关在何处放置筛选代码的第二个选项是继承自<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类，并重写一个方法以检查筛选器条件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> 可以重写以执行此操作的两个方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=fullName>方法或 OnAuthorizeWebPart 方法。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=fullName> 尽管任何一种方法将起作用，但在大多数情况下它是更可取的方法重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法，因为它提供了更多的编程控制对整个授权过程中，而 OnAuthorizeWebPart 方法执行只有一个特定的任务，是引发的事件和处理程序提出的检查。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 有关自定义的代码示例<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类，并重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法，请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=fullName>的方法重载。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=fullName> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> </xref:System.Web.UI.WebControls.WebParts.WebPartManager>"
  example:
  - "The following code example demonstrates how to set a custom event handler for the <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> event, so that the handler can provide custom filtering code for the OnAuthorizeWebPart method. This example would be a typical way for a page developer to provide a filtering scenario and authorization of <xref:System.Web.UI.WebControls.WebParts.WebPart> controls to be added to a page.  \n  \n In the Web page, notice that the `<asp:webpartmanager>` element has the `OnAuthorizeWebPart` attribute with the name of the event handler assigned to it. The method checks whether the controls on the page have their respective <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> property values set to `admin` and, if so, returns `true`, which means that they will be authorized and added to the page.  \n  \n> [!NOTE]\n>  Note that controls that do not have any value assigned to the <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> property are added as well, because they are assumed not to be part of a filtering scenario. This would be a common approach in a filtering scenario: some controls would be filtered, and others would not be, because they are presumed to be available for all users.  \n  \n [!code-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/add/codesnippet/visualbasic/fb74240d-1119-4128-abbc-_1.aspx)]\n [!code-cs[WebParts_WebPartManager_AuthorizeWebPart#1](~/add/codesnippet/csharp/fb74240d-1119-4128-abbc-_1.aspx)]  \n  \n Because setting up users in roles is beyond the scope of this topic, this code example does not check user roles in the filtering. However, the scenario of filtering controls according to user roles is likely to be one of the most common uses of this filtering feature. If you have roles on your site, and you want to check user roles in this method to filter controls, the method would resemble the following code block (versus the simpler approach in the preceding code example, which does not use roles).  \n  \n [Visual Basic]  \n  \n```  \nProtected Sub WebPartManager1_AuthorizeWebPart(ByVal sender _  \n  As Object, ByVal e As WebPartAuthorizationEventArgs)  \n  \n  If String.IsNullOrEmpty(e.AuthorizationFilter) Then  \n    If Roles.IsUserInRole(Page.User.Identity.Name, _  \n      e.AuthorizationFilter) Then  \n  \n      e.IsAuthorized = True  \n    Else  \n      e.IsAuthorized = False  \n    End If  \n  End If  \n  \nEnd Sub  \n```  \n  \n [C#]  \n  \n```  \nprotected void mgr1_AuthorizeWebPart(object sender,   \n  WebPartAuthorizationEventArgs e)  \n{  \n  if (!String.IsNullOrEmpty(e.AuthorizationFilter))  \n  {  \n    if(Roles.IsUserInRole(Page.User.Identity.Name, e.authorizationFilter))  \n      e.IsAuthorized = true;  \n    else  \n      e.IsAuthorized = false;  \n  }  \n}  \n```"
  syntax:
    content: protected virtual void OnAuthorizeWebPart (System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e);
    parameters:
    - id: e
      type: System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs&quot;> </xref>包含事件数据。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)
  id: OnConnectionsActivated(System.EventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: OnConnectionsActivated(EventArgs)
  nameWithType: WebPartManager.OnConnectionsActivated(EventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(EventArgs)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "引发<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated&quot;></xref>事件以指示加载一个页，并且其控件，并且已激活页上的连接以开始共享数据。"
  remarks: "OnConnectionsActivated 方法将引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>页面完成加载过程后的事件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated> 该方法提供了一种添加事件的处理程序方法。       页开发人员可以通过添加添加自定义事件处理程序`OnConnectionsActivated`属性设为`<asp:webpartmanager>`页，然后将自定义的方法名称分配到的属性中的元素。"
  syntax:
    content: protected virtual void OnConnectionsActivated (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "<xref:System.EventArgs>包含事件数据。</xref:System.EventArgs>"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)
  id: OnConnectionsActivating(System.EventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: OnConnectionsActivating(EventArgs)
  nameWithType: WebPartManager.OnConnectionsActivating(EventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(EventArgs)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "引发<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating&quot;></xref>事件以指示已加载一个页，并且其控件，并且可以开始激活连接过程。"
  remarks: "OnConnectionsActivating 方法将引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>事件，开发人员提供一种机制，用于以编程方式自定义激活连接的过程。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>       页开发人员可以通过添加添加自定义事件处理程序`OnConnectionsActivating`属性设为`<asp:webpartmanager>`页，然后将自定义的方法名称分配到的属性中的元素。"
  syntax:
    content: protected virtual void OnConnectionsActivating (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "<xref:System.EventArgs>包含事件数据。</xref:System.EventArgs>"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)
  id: OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: OnDisplayModeChanged(WebPartDisplayModeEventArgs)
  nameWithType: WebPartManager.OnDisplayModeChanged(WebPartDisplayModeEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(WebPartDisplayModeEventArgs)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "引发<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged&quot;></xref>事件，则指示<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>控件已完成从一种显示模式切换到另一个在网页上的过程。"
  remarks: "OnDisplayModeChanged 方法的基形式只引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged>事件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged>"
  syntax:
    content: protected virtual void OnDisplayModeChanged (System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e);
    parameters:
    - id: e
      type: System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs&quot;> </xref>包含与已更改的显示模式相关联的事件数据。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)
  id: OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: OnDisplayModeChanging(WebPartDisplayModeCancelEventArgs)
  nameWithType: WebPartManager.OnDisplayModeChanging(WebPartDisplayModeCancelEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(WebPartDisplayModeCancelEventArgs)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "引发<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging&quot;></xref>事件，则指示<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>控件的过程中从一种显示模式切换到另一个在网页上。"
  remarks: "OnDisplayModeChanging 方法的基形式只引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging>事件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging>"
  syntax:
    content: protected virtual void OnDisplayModeChanging (System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e);
    parameters:
    - id: e
      type: System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs
      description: "<xref:System.EventArgs>包含与不断变化的显示模式相关联的事件数据。</xref:System.EventArgs>"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnInit(System.EventArgs)
  id: OnInit(System.EventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: OnInit(EventArgs)
  nameWithType: WebPartManager.OnInit(EventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnInit(EventArgs)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "引发<xref href=&quot;System.Web.UI.Control.Init&quot;></xref>事件，即第一个事件中<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>控件生命周期。"
  remarks: "OnInit 方法调用基方法，将引发<xref:System.Web.UI.Control.Init>控件，然后执行几个预备步骤，如确保只有一个实例的事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件在页中，并加载个性化数据。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> </xref:System.Web.UI.Control.Init>"
  syntax:
    content: protected override void OnInit (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "<xref:System.EventArgs>包含事件数据。</xref:System.EventArgs>"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.OnInit*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "是另一个<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>页上的控件"
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender(System.EventArgs)
  id: OnPreRender(System.EventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: OnPreRender(EventArgs)
  nameWithType: WebPartManager.OnPreRender(EventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender(EventArgs)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "引发<xref href=&quot;System.Web.UI.Control.PreRender&quot;></xref>事件，发生之前<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>控件是否呈现在网页上。"
  remarks: "OnPreRender 方法调用基方法，将引发<xref:System.Web.UI.Control.PreRender>事件控件，然后注册了多个包含 Web 部件的页所需的客户端脚本控制。</xref:System.Web.UI.Control.PreRender>"
  syntax:
    content: protected override void OnPreRender (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "<xref:System.EventArgs>包含事件数据。</xref:System.EventArgs>"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)
  id: OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: OnSelectedWebPartChanged(WebPartEventArgs)
  nameWithType: WebPartManager.OnSelectedWebPartChanged(WebPartEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(WebPartEventArgs)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "引发<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged&quot;></xref>后发生的事件<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>控件或者新选择或清除其选择。"
  remarks: "OnSelectedWebPartChanged 方法将引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>事件，这通常是在开发人员可能希望更改用户界面 (UI) 的外观的时间点。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged> 例如，当新<xref:System.Web.UI.WebControls.WebParts.WebPart>控件被选定，Web 部件控件集更改新选择的控件的呈现。</xref:System.Web.UI.WebControls.WebParts.WebPart> 清除控件的选择之后，呈现返回到正常。       在用户选择特定<xref:System.Web.UI.WebControls.WebParts.WebPart>编辑控件中的，调用该 OnSelectedWebPartChanged 方法。</xref:System.Web.UI.WebControls.WebParts.WebPart> 当用户完成编辑控件，并将其关闭，与控件的选择处于未选中状态的结果时，再次调用该 OnSelectedWebPartChanged 方法。"
  syntax:
    content: protected virtual void OnSelectedWebPartChanged (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);
    parameters:
    - id: e
      type: System.Web.UI.WebControls.WebParts.WebPartEventArgs
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartEventArgs&quot;> </xref>包含事件数据。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)
  id: OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: OnSelectedWebPartChanging(WebPartCancelEventArgs)
  nameWithType: WebPartManager.OnSelectedWebPartChanging(WebPartCancelEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(WebPartCancelEventArgs)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "引发<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging&quot;></xref>事件，更改其中的过程中发生<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>当前选中控件。"
  remarks: "OnSelectedWebPartChanging 方法将引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>事件，更改其中的过程中发生<xref:System.Web.UI.WebControls.WebParts.WebPart>当前选中控件。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>       <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件使用此方法，而且关联的事件，以提供取消进程在其中更改所选的控件的机会。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> 例如，在调用该方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>方法，并还在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>方法，以提供一种方法来取消该过程。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> 如果用户单击正在编辑的控件上的取消谓词，控件不再处于选中状态，并且不保存任何编辑更改，因为 OnSelectedWebPartChanging 方法使它能够取消编辑的更改。      1> [!NOTE]&1;> 期间的开始和结束连接的过程的方法同样调用方法<xref:System.Web.UI.WebControls.WebParts.WebPart>控件添加到另一个控件，以便取消该进程。</xref:System.Web.UI.WebControls.WebParts.WebPart>       页开发人员可以创建自定义处理程序<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>通过添加事件`OnSelectedWebPartChanging`属性设为`<asp:webpartmanager>`中声明性页面标记，并将自定义方法的名称分配给该属性的元素。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>"
  syntax:
    content: protected virtual void OnSelectedWebPartChanging (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);
    parameters:
    - id: e
      type: System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs&quot;> </xref>包含事件数据。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnUnload(System.EventArgs)
  id: OnUnload(System.EventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: OnUnload(EventArgs)
  nameWithType: WebPartManager.OnUnload(EventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnUnload(EventArgs)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "对基<xref href=&quot;System.Web.UI.Control.Unload&quot;></xref>事件并删除<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>在网页上的实例。"
  syntax:
    content: protected override void OnUnload (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "与控件删除关联的事件数据。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.OnUnload*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)
  id: OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: OnWebPartAdded(WebPartEventArgs)
  nameWithType: WebPartManager.OnWebPartAdded(WebPartEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(WebPartEventArgs)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "引发<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded&quot;></xref>后发生的事件<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>控件已添加到页。"
  remarks: "在添加的过程中调用 OnWebPartAdded 方法<xref:System.Web.UI.WebControls.WebParts.WebPart>控件 (或添加到其他服务器控件<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域) 到页。</xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> </xref:System.Web.UI.WebControls.WebParts.WebPart>       页开发人员可以创建自定义处理程序<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>通过添加事件`OnWebPartAdded`属性设为`asp:webpartmanager>`元素，并将自定义的方法名称分配给该属性。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>"
  syntax:
    content: protected virtual void OnWebPartAdded (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);
    parameters:
    - id: e
      type: System.Web.UI.WebControls.WebParts.WebPartEventArgs
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartEventArgs&quot;> </xref>包含事件数据。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)
  id: OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: OnWebPartAdding(WebPartAddingEventArgs)
  nameWithType: WebPartManager.OnWebPartAdding(WebPartAddingEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(WebPartAddingEventArgs)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "引发<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding&quot;></xref>事件，添加的过程中发生<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>控件 （或的服务器或用户控件），它到<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartZoneBase&quot;></xref>区域。"
  remarks: "通过以下方法将引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding>事件，它指示控件正在添加。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding> 该方法还提供了选项来取消添加过程。 如果成功添加控件，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>事件遵循。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>       页开发人员可以通过添加为关联的事件提供自定义的处理程序`OnWebPartAdding`属性设为`<asp:webpartmanager>`上 Web 页面中，，然后将自定义的方法名称分配给该属性的元素。"
  syntax:
    content: protected virtual void OnWebPartAdding (System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e);
    parameters:
    - id: e
      type: System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs&quot;> </xref>包含事件数据。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)
  id: OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: OnWebPartClosed(WebPartEventArgs)
  nameWithType: WebPartManager.OnWebPartClosed(WebPartEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(WebPartEventArgs)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "引发<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed&quot;></xref>事件以发出信号控件已被移除从页。"
  remarks: "以下方法将引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>事件，则指示<xref:System.Web.UI.WebControls.WebParts.WebPart>控件 （或其他服务器或用户控件） 已成功关闭在页面上。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>       若要关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>控件意味着若要删除从页以便不呈现，并且还将其放在一个特殊持有对象调用页目录。</xref:System.Web.UI.WebControls.WebParts.WebPart> 对应于一个页目录<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>控制，维护对已关闭的引用<xref:System.Web.UI.WebControls.WebParts.WebPart>为每个页的控件。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> 如果<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>控件声明内的网页<xref:System.Web.UI.WebControls.WebParts.CatalogZone>区域，用户可以将页切换到目录的显示模式，并将以前关闭任何控件添加回页面。</xref:System.Web.UI.WebControls.WebParts.CatalogZone> </xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>       以下方法使开发人员创建的自定义处理程序有机会<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>事件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> 页开发人员可以通过添加添加自定义事件处理程序`OnWebPartClosed`属性设为`<asp:webpartmanager>`页，然后将自定义的方法名称分配到的属性中的元素。 开发人员可能在此方法中执行的一个有用的任务是显示在已关闭的控件的位置的占位符，完成与工具提示将告知用户如何将控件添加回页面。"
  syntax:
    content: protected virtual void OnWebPartClosed (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);
    parameters:
    - id: e
      type: System.Web.UI.WebControls.WebParts.WebPartEventArgs
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartEventArgs&quot;> </xref>包含事件数据。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)
  id: OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: OnWebPartClosing(WebPartCancelEventArgs)
  nameWithType: WebPartManager.OnWebPartClosing(WebPartCancelEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(WebPartCancelEventArgs)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "引发<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing&quot;></xref>的过程中发生的事件<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>或正在从页面中删除的服务器控件。"
  remarks: "OnWebPartClosing 方法将引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>事件来指示控制正在被关闭或从页中移除。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> 该方法还提供了选项来取消关闭进程。 如果控件已成功移除从页中，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>事件遵循。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>       页开发人员可以通过添加为关联的事件提供自定义的处理程序`OnWebPartClosinging`属性设为`<asp:webpartmanager>`上 Web 页面中，，然后将自定义的方法名称分配给该属性的元素。"
  syntax:
    content: protected virtual void OnWebPartClosing (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);
    parameters:
    - id: e
      type: System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs&quot;> </xref>包含事件数据。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)
  id: OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: OnWebPartDeleted(WebPartEventArgs)
  nameWithType: WebPartManager.OnWebPartDeleted(WebPartEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(WebPartEventArgs)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "引发<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted&quot;></xref>后发生的事件<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>永久删除一个页的控件。"
  remarks: "在删除过程中调用 OnWebPartDeleted 方法<xref:System.Web.UI.WebControls.WebParts.WebPart>控件 (或添加到其他服务器控件<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域) 从一个页面。</xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> </xref:System.Web.UI.WebControls.WebParts.WebPart>       页开发人员可以创建自定义处理程序<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>通过添加事件`OnWebPartDeleted`属性设为`asp:webpartmanager>`元素，并将自定义的方法名称分配给该属性。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>"
  syntax:
    content: protected virtual void OnWebPartDeleted (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);
    parameters:
    - id: e
      type: System.Web.UI.WebControls.WebParts.WebPartEventArgs
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartEventArgs&quot;> </xref>包含事件数据。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)
  id: OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: OnWebPartDeleting(WebPartCancelEventArgs)
  nameWithType: WebPartManager.OnWebPartDeleting(WebPartCancelEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(WebPartCancelEventArgs)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "引发<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting&quot;></xref>事件，指示动态<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>控件 (或包含在的服务器或用户控件<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartZoneBase&quot;></xref>区域) 正在被删除。"
  remarks: "仅动态<xref:System.Web.UI.WebControls.WebParts.WebPart>控件可以被删除，并且当删除控件时，控件实例从页面中永久删除，无法还原。</xref:System.Web.UI.WebControls.WebParts.WebPart> 动态<xref:System.Web.UI.WebControls.WebParts.WebPart>控件是指那些以编程方式，添加或从 Web 部件目录，而不是静态控件中声明的网页上的标记。</xref:System.Web.UI.WebControls.WebParts.WebPart>       OnWebPartDeleting 方法将引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>事件来指示，从其区域永久删除控件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting> 该方法还提供了机会取消删除过程。 如果控件已成功删除从页中，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>事件遵循。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>       页开发人员可以通过添加为关联的事件提供自定义的处理程序`OnWebPartDeleting`属性设为`<asp:webpartmanager>`上 Web 页面中，，然后将自定义的方法名称分配给该属性的元素。"
  syntax:
    content: protected virtual void OnWebPartDeleting (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);
    parameters:
    - id: e
      type: System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs&quot;> </xref>包含事件数据。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)
  id: OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: OnWebPartMoved(WebPartEventArgs)
  nameWithType: WebPartManager.OnWebPartMoved(WebPartEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(WebPartEventArgs)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "引发<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved&quot;></xref>后发生的事件<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>控件已被移动到其他位置在页面上。"
  remarks: "OnWebPartMoved 方法将引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>事件在最后的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>方法，可确保移动控件的过程完成之前的任何代码在事件处理程序将运行。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>       <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>在其当前的区域内或另一个区域，在移动控件和是否移动是以编程方式或通过用户拖动控件并不重要时引发事件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>       页开发人员可以创建自定义处理程序<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>通过添加事件`OnWebPartMoved`属性设为`asp:webpartmanager>`元素，并将自定义的方法名称分配给该属性。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>"
  syntax:
    content: protected virtual void OnWebPartMoved (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);
    parameters:
    - id: e
      type: System.Web.UI.WebControls.WebParts.WebPartEventArgs
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartEventArgs&quot;> </xref>包含事件数据。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)
  id: OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: OnWebPartMoving(WebPartMovingEventArgs)
  nameWithType: WebPartManager.OnWebPartMoving(WebPartMovingEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(WebPartMovingEventArgs)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "引发<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving&quot;></xref>事件，指示<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>或中的服务器或用户控件<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartZoneBase&quot;></xref>区域是正在移动。"
  remarks: "通过以下方法将引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>事件发生时<xref:System.Web.UI.WebControls.WebParts.WebPart>或其他服务器控件将被移到另一个区域或其区域。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> 该方法还提供了取消移动过程的机会。 如果移动已成功完成，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>事件遵循。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>       页开发人员可以通过添加为关联的事件提供自定义的处理程序`OnWebPartMoving`属性设为`<asp:webpartmanager>`上 Web 页面中，，然后将自定义的方法名称分配给该属性的元素。"
  syntax:
    content: protected virtual void OnWebPartMoving (System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e);
    parameters:
    - id: e
      type: System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs&quot;> </xref>包含事件数据。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)
  id: OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: OnWebPartsConnected(WebPartConnectionsEventArgs)
  nameWithType: WebPartManager.OnWebPartsConnected(WebPartConnectionsEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(WebPartConnectionsEventArgs)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "引发<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected&quot;></xref>事件，发生之间建立连接后<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>控件。"
  remarks: "OnWebPartsConnected 方法将引发其对应的事件在最后的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>方法，这样可以确保事件处理程序中的任何代码运行之前完成连接两个控件所必需的步骤。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>       该方法提供了对创建连接的过程进行编程控制和关联的事件是在该处若要更新的用户界面 (UI) 或通知用户已建立的连接的方便的点。       页开发人员可以创建自定义处理程序<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>通过添加事件`OnWebPartsConnected`属性设为`asp:webpartmanager>`元素，并将自定义的方法名称分配给该属性。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>"
  syntax:
    content: protected virtual void OnWebPartsConnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);
    parameters:
    - id: e
      type: System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs&quot;> </xref>包含事件数据。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)
  id: OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: OnWebPartsConnecting(WebPartConnectionsCancelEventArgs)
  nameWithType: WebPartManager.OnWebPartsConnecting(WebPartConnectionsCancelEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(WebPartConnectionsCancelEventArgs)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "引发<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting&quot;></xref>事件，建立两个之间的连接的过程中发生<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>或中包含的服务器或用户控件<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartZoneBase&quot;></xref>区域。"
  remarks: "通过以下方法将引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>事件，发生在两个控件尝试建立连接。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> 该方法提供了机会取消连接尝试。 如果连接成功，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>事件遵循。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>       页开发人员可以通过添加为关联的事件提供自定义的处理程序`OnWebPartsConnecting`属性设为`<asp:webpartmanager>`上 Web 页面中，，然后将自定义的方法名称分配给该属性的元素。"
  syntax:
    content: protected virtual void OnWebPartsConnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);
    parameters:
    - id: e
      type: System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs&quot;> </xref>包含事件数据。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)
  id: OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: OnWebPartsDisconnected(WebPartConnectionsEventArgs)
  nameWithType: WebPartManager.OnWebPartsDisconnected(WebPartConnectionsEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(WebPartConnectionsEventArgs)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "引发<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected&quot;></xref>事件，发生之间的连接后<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>控件已结束。"
  remarks: "OnWebPartsDisconnected 方法将引发其对应的事件在最后的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>方法，执行终止两个控件之间的连接的过程。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>       该方法提供了对结束连接的过程进行编程控制，以便开发人员可以通知用户，对用户界面 (UI)，进行更改或对应用程序进行其他更改。       页开发人员可以创建自定义处理程序<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>通过添加事件`OnWebPartsDisconnected`属性设为`asp:webpartmanager>`元素，并将自定义的方法名称分配给该属性。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>"
  syntax:
    content: protected virtual void OnWebPartsDisconnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);
    parameters:
    - id: e
      type: System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs&quot;> </xref>包含事件数据。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)
  id: OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: OnWebPartsDisconnecting(WebPartConnectionsCancelEventArgs)
  nameWithType: WebPartManager.OnWebPartsDisconnecting(WebPartConnectionsCancelEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(WebPartConnectionsCancelEventArgs)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "引发<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting&quot;></xref>事件，指示两个<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>或中的服务器或用户控件<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartZoneBase&quot;></xref>结束连接正在区域。"
  remarks: "通过以下方法将引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件，发生在两个控件正在结束连接。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 该方法提供了机会取消断开连接过程。 如果连接成功移除，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>事件遵循。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>       页开发人员可以通过添加为关联的事件提供自定义的处理程序`OnWebPartsDisconnecting`属性设为`<asp:webpartmanager>`上 Web 页面中，，然后将自定义的方法名称分配给该属性的元素。"
  syntax:
    content: protected virtual void OnWebPartsDisconnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);
    parameters:
    - id: e
      type: System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs&quot;> </xref>包含事件数据。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.Personalization
  id: Personalization
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: Personalization
  nameWithType: WebPartManager.Personalization
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.Personalization
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "获取包含用于网页的个性化数据的对象的引用。"
  remarks: "个性化设置属性使您能够访问<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>与通过页关联的对象<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> </xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> 使用此属性，可访问的个性化设置对象的各种成员。 例如，你可以使用<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A>方法切换页面的个性化设置范围从共享到用户作用域，反之亦然。</xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A> 你还可找到出当前的个性化设置范围的页上，是否启用了个性化设置甚至在页上的提供程序用于个性化数据时，和的详细信息。       请注意，所引用的个性化属性数据是通过跟踪的页面级别个性化数据<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> 特定于控件的个性化数据，如可个性化设置的属性的值<xref:System.Web.UI.WebControls.WebParts.WebPart>控制，不是个性化设置属性的一部分。</xref:System.Web.UI.WebControls.WebParts.WebPart>      1> [!NOTE]&1;> Web 部件个性化设置的详细信息，请参阅[Web 部件个性化概述](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example demonstrates how to use the Personalization property programmatically.  \n  \n The following Web page allows a user to enter edit mode to edit certain aspects of the <xref:System.Web.UI.WebControls.Calendar> control. The **Toggle Scope** button switches the page to user or shared personalization scope. The **Edit Mode** and **Browse Mode** buttons each switch the page into the appropriate display mode. Notice that in the `<script>` tag section of the file, two of the methods that handle events use the Personalization property to access useful members of the underlying object. Specifically, these methods use the <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A> method and the <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Scope%2A> property on the object accessed through the Personalization property.  \n  \n [!code-cs[WebParts_WebPartManager_Personalization#1](~/add/codesnippet/csharp/p-system.web.ui.webcontr_970_1.aspx)]\n [!code-vb[WebParts_WebPartManager_Personalization#1](~/add/codesnippet/visualbasic/p-system.web.ui.webcontr_970_1.aspx)]  \n  \n For the code example to run, you also must enable a user or users to personalize pages in shared scope. Add an entry to the Web.config file, within the `<system.web>` section, that looks like the following markup.  \n  \n```  \n<webParts>  \n  <personalization>  \n    <authorization>  \n      <allow  \n        users=\"[Replace the text and brackets with a user name or   \n           group.]\"  \n        roles=\"admin\"   \n        verbs=\"enterSharedScope\"  />  \n    </authorization>  \n  </personalization>  \n</webParts>   \n```  \n  \n After you load the page in a browser, click the **Toggle Scope** button, and notice that the page now says the scope is shared. Click **Edit Mode** to change the display mode, click the verbs menu on the visible control, and select **Edit** from the menu. Notice that the user interface (UI) for both editing controls appears. Now click **Browse Mode** to return to normal browsing. If the page says it is in shared scope, click **Toggle Scope** again to ensure the page is in user scope. Next, follow the same steps to edit the control again, but notice that now in the editing UI, the <xref:System.Web.UI.WebControls.WebParts.BehaviorEditorPart> control does not appear. That is because this control only works when the page is in shared personalization scope."
  syntax:
    content: public System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization { get; }
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartPersonalization
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartPersonalization&quot;> </xref>包含个性化数据。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.Personalization*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.RegisterClientScript
  id: RegisterClientScript
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: RegisterClientScript()
  nameWithType: WebPartManager.RegisterClientScript()
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.RegisterClientScript()
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "使<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>控件能够发出用于各种个性化功能，例如将拖动的客户端脚本<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;> </xref> Web 页中的控件。"
  syntax:
    content: protected virtual void RegisterClientScript ();
    parameters: []
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.RegisterClientScript*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.Render(System.Web.UI.HtmlTextWriter)
  id: Render(System.Web.UI.HtmlTextWriter)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: Render(HtmlTextWriter)
  nameWithType: WebPartManager.Render(HtmlTextWriter)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.Render(HtmlTextWriter)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "重写以防止<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>从呈现任何内容的控件。"
  syntax:
    content: protected override void Render (System.Web.UI.HtmlTextWriter writer);
    parameters:
    - id: writer
      type: System.Web.UI.HtmlTextWriter
      description: "<xref href=&quot;System.Web.UI.HtmlTextWriter&quot;> </xref>接收要写入的页的控件的内容。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.Render*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState
  id: SaveControlState
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: SaveControlState()
  nameWithType: WebPartManager.SaveControlState()
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState()
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "保存状态的数据<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>控制以便可以将数据还原到包含该控件的网页的后续请求上。"
  remarks: "方法将在页回发期间，应保留的属性的状态数据保存 SaveControlState 即使<xref:System.Web.UI.Control.EnableViewState%2A>属性设置为`false`。</xref:System.Web.UI.Control.EnableViewState%2A>"
  syntax:
    content: protected override object SaveControlState ();
    parameters: []
    return:
      type: System.Object
      description: "<xref:System.Object>以包含的控件的保存状态数据。</xref:System.Object>"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)
  id: SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: SaveCustomPersonalizationState(PersonalizationDictionary)
  nameWithType: WebPartManager.SaveCustomPersonalizationState(PersonalizationDictionary)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(PersonalizationDictionary)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "保存自定义的个性化设置状态数据由维护<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>控制，以便可以重新加载此数据，每当重新加载页面。"
  remarks: "SaveCustomPersonalizationState 方法过程个性化中, 至关重要，因为它允许个性化的用户设置，以供将来的浏览器会话存储并访问到页。 该方法保存自定义个性化设置状态数据，其中包括以下各项︰ 动态<xref:System.Web.UI.WebControls.WebParts.WebPart>或已添加到页或从一个页; 已移页; 的控件，并且已创建或删除的动态连接中删除的服务器控件。</xref:System.Web.UI.WebControls.WebParts.WebPart>       不能在代码中直接调用此方法。 但是，可以调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A>方法，其自身调用此方法以保存个性化数据。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A>"
  syntax:
    content: protected virtual void SaveCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);
    parameters:
    - id: state
      type: System.Web.UI.WebControls.WebParts.PersonalizationDictionary
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.PersonalizationDictionary&quot;> </xref> ，其中包含要加载的状态数据。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart
  id: SelectedWebPart
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: SelectedWebPart
  nameWithType: WebPartManager.SelectedWebPart
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "获取对<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>或进行编辑或创建与另一个控件的连接当前所选其他服务器控件。"
  remarks: "SelectedWebPart 属性返回的引用<xref:System.Web.UI.WebControls.WebParts.WebPart>或进行编辑或创建与另一个控件的连接当前所选其他服务器控件。</xref:System.Web.UI.WebControls.WebParts.WebPart>       <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件提供了几个有用的方法和事件处理中选择一个控件的过程。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>刚才所选控件后，但在进行任何更改之前发生的事件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> 若要发动控件上的某些操作，它在选定后，重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>方法。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> 例如，你可能想要更改的控件选择但尚未，未更改以直观地强调所选控件的外观。       <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>事件发生只需在所选的控件已更改之后。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged> 若要更改后对其执行在控件上的某些操作，请重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>方法。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>"
  syntax:
    content: public System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart { get; }
    return:
      type: System.Web.UI.WebControls.WebParts.WebPart
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;> </xref>当前选择编辑或建立连接的控件。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged
  id: SelectedWebPartChanged
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: SelectedWebPartChanged
  nameWithType: WebPartManager.SelectedWebPartChanged
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged
  type: Event
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "在其中一个的所选内容之后<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>已更改控件并将其移到另一个控件在网页上。"
  remarks: "可以结合使用此事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>方法可以更改选定控件的用户界面 (UI)。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> 例如，如果用户将页切换到设计模式下 (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>)，然后选择<xref:System.Web.UI.WebControls.WebParts.WebPart>控件与将其拖到新位置的意图，很常见，例如通过更改其边框的颜色的更改所选控件的呈现或后台处于选定状态时。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>      1> [!NOTE]&1;> 使用事件的详细信息，请参阅[如何︰ 在 Web 窗体应用程序中使用事件](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public event System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged;
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging
  id: SelectedWebPartChanging
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: SelectedWebPartChanging
  nameWithType: WebPartManager.SelectedWebPartChanging
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging
  type: Event
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "更改其中的过程中发生<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>或网页上当前所选服务器控件。"
  remarks: "可以结合使用此事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>方法。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> 页开发人员可以通过添加在代码中创建事件处理程序`OnSelectedWebPartChanging`属性设为`<asp:webpartmanager>`页上，并将该属性的值设置为自定义方法的名称中的元素将处理该事件。       在开始或结束之间控件，并开始和结束时间的编辑控件的连接的过程中，将引发此事件。 有关详细信息，请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>方法。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>       通常情况下，当作为更改所选的控件的用户的操作的直接结果引发 SelectedWebPartChanging 事件时，可以取消该事件。 但是，没有事件不能在其中被取消的方案。 如果<xref:System.Web.UI.WebControls.WebParts.WebPartZone>中删除控件，<xref:System.Web.UI.WebControls.WebParts.WebPart>它包含的控件必须先结束所有，否则它们将被孤立。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartZone> 在这种情况下<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>控件、 不用户，它必须确定当前选定哪个控件，以及何时更改而无需中断，不可能选择，以便它可以完成清理所有控件的过程。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartManager> 因此，设计使然 SelectedWebPartChanging 方法不能取消在此方案中。 可以取消的相关事件，请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>事件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>"
  syntax:
    content: public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging;
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty
  id: SetPersonalizationDirty
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: SetPersonalizationDirty()
  nameWithType: WebPartManager.SetPersonalizationDirty()
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty()
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "设置一个标志，指示该自定义个性化数据以供<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>控制已更改。"
  remarks: "SetPersonalizationDirty 方法设置的个性化组件最终导致的 Web 部件控件集，以保存更新的个性化设置数据的标志。 有关详细信息可能会导致更改跟踪的个性化设置数据的方案<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制，请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>属性。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> </xref:System.Web.UI.WebControls.WebParts.WebPartManager>       SetPersonalizationDirty 方法不能在代码中直接调用，并且不能重写，因为它在内部使用由 Web 部件控件集作为 Web 部件个性化功能的一部分。"
  syntax:
    content: protected void SetPersonalizationDirty ();
    parameters: []
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)
  id: SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: SetSelectedWebPart(WebPart)
  nameWithType: WebPartManager.SetSelectedWebPart(WebPart)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(WebPart)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "集<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart*>属性值等于当前所选<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>或服务器控件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart*>"
  remarks: "在进程的开始或结束编辑指定的控件的过程中调用 SetSelectedWebPart 方法`webPart`参数，并且那些开头或结尾包括连接`webPart`。       在编辑和连接过程中，开头`webPart`是以进行编辑，或输入连接已选择的控件。       在编辑和连接过程中，末尾`null`传递给 SetSelectedWebPart 方法，这会导致当前所选控件不再被选定。"
  syntax:
    content: protected void SetSelectedWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);
    parameters:
    - id: webPart
      type: System.Web.UI.WebControls.WebParts.WebPart
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;> </xref>或已选择的服务器控件。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.SkinID
  id: SkinID
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: SkinID
  nameWithType: WebPartManager.SkinID
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.SkinID
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "获取或设置一个空字符串 (&quot;&quot;)，以便任何外观可以应用于<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>控件。"
  remarks: "SkinID 属性重写继承<xref:System.Web.UI.Control.SkinID%2A?displayProperty=fullName>属性可避免<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件，这是不可见的控件中，从使用外观。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> </xref:System.Web.UI.Control.SkinID%2A?displayProperty=fullName> 属性的实现可以防止外观通过始终返回空字符串从指定`get`访问器，并始终引发异常，尝试在中设置一个值是否`set`访问器。"
  syntax:
    content: public override string SkinID { get; set; }
    return:
      type: System.String
      description: "空字符串，以防止<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>分配给它的外观的控件。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.SkinID*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "尝试设置属性值。"
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections
  id: StaticConnections
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: StaticConnections
  nameWithType: WebPartManager.StaticConnections
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "获取所有的集合的引用<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartConnection&quot;></xref>定义为静态连接到 Web 页上的对象。"
  remarks: "使用 StaticConnections 属性<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件来跟踪和管理页上的所有静态连接。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> 静态连接，与动态连接，相比不必添加到页面中，每次呈现页面。       此属性所引用的集合包含是否以编程方式创建或使用指定的页，存在的所有静态连接`<asp:webpartconnection>`页面的标记中的元素。"
  example:
  - "The following code example demonstrates programmatic use of the StaticConnections property.  \n  \n The code example has four parts:  \n  \n-   A user control that enables you to change display modes on a Web Parts page.  \n  \n-   A source code file that contains two custom <xref:System.Web.UI.WebControls.WebParts.WebPart> controls and a custom interface.  \n  \n-   A Web page that contains two custom <xref:System.Web.UI.WebControls.WebParts.WebPart> controls that can be connected, and an `<asp:webpartmanager>` element.  \n  \n-   An explanation of how the example works in a browser.  \n  \n The following code contains only the Web page portion of the example. You will also need to obtain the first two parts of the example--the custom user control and the source code for the custom controls and interface--from the Example section of the <xref:System.Web.UI.WebControls.WebParts.WebPartManager> class overview. That topic also explains your options for compiling the <xref:System.Web.UI.WebControls.WebParts.WebPart> controls.  \n  \n The third part of the code example is the Web page. The declarative markup for the page contains `Register` directives for both the user control and the custom controls. There is an `<asp:webpartmanager>` element, an `<asp:webpartzone>` element to contain the custom controls, and an `<asp:connectionszone>` element. Notice that in the `Page_Load` method, the code checks to see whether a connection already exists and, if not, defines a provider, a consumer, and their respective connection points, and then adds a new connection to the set of static connections referenced by the StaticConnections property.  \n  \n [!code-cs[WebParts_WebPartManager_StaticConnections#1](~/add/codesnippet/csharp/p-system.web.ui.webcontr_98_1.aspx)]\n [!code-vb[WebParts_WebPartManager_StaticConnections#1](~/add/codesnippet/visualbasic/p-system.web.ui.webcontr_98_1.aspx)]  \n  \n After you have loaded the Web page in a browser, click the **Display Mode** drop-down list control and select **Connect** to switch the page to connect mode. Connect mode uses the `<asp:connectionszone>` element to enable you to create connections between controls. In connect mode, click the downward arrow in the title bar of the **ZIP Code** control to activate its verbs menu, and then click **Connect**. After the connection user interface (UI) appears, notice that a connection has already been created by the code contained in the `Page_Load` method. If you return to this page in a later browser session, this static connection will already be established and will not need to be recreated each time the page loads."
  syntax:
    content: public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections { get; }
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartConnectionCollection
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartConnectionCollection&quot;> </xref>包含页上的所有静态连接。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes
  id: SupportedDisplayModes
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: SupportedDisplayModes
  nameWithType: WebPartManager.SupportedDisplayModes
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "获取显示的所有模式都可在特定的 Web 页面上的只读集合。"
  remarks: "SupportedDisplayModes 属性包含实际可用在页中，给定的类型的页上存在的区域控件的显示模式。      1> [!NOTE]&1;> 显示模式可被禁用，且当禁用的显示模式时，它未添加到 SupportedDisplayModes 集合中，即使该显示模式支持的区域的对应类型是在页上存在。       始终支持浏览模式和设计模式。 而异的显示模式是编辑、 目录和连接模式。 其中每个显示模式是与特定类型的关联<xref:System.Web.UI.WebControls.WebParts.ToolZone>控件。</xref:System.Web.UI.WebControls.WebParts.ToolZone> 它是区域的该特定类型，在网页上导致一个要添加到由 SupportedDisplayModes 属性引用的集合的特定显示模式存在。 例如，如果 Web 页包含<xref:System.Web.UI.WebControls.WebParts.EditorZone>但不是区域<xref:System.Web.UI.WebControls.WebParts.CatalogZone>区域，然后编辑显示模式是一个受支持的模式，在该页上，但不是支持的目录的显示模式。</xref:System.Web.UI.WebControls.WebParts.CatalogZone> </xref:System.Web.UI.WebControls.WebParts.EditorZone>      1> [!NOTE]&1;> SupportedDisplayModes 属性不同于<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>属性，引用的集合包含与当前可用的所有显示模式<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制，甚至那些在特定页上不支持。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>"
  example:
  - "The following code example shows the programmatic use of the SupportedDisplayModes property. The code uses this property to populate the list with only the display modes available in the current Web page.  \n  \n There are three supported display modes on this page: browse, design, and edit. The first two are always available, and the edit mode is available in this code example because the page contains an <xref:System.Web.UI.WebControls.WebParts.EditorZone> control. The catalog and connect display modes are not shown, because their corresponding zones are not on this page.  \n  \n [!code-vb[WebParts_WebPartManager_SupportedDisplayModes#1](~/add/codesnippet/visualbasic/p-system.web.ui.webcontr_388_1.aspx)]\n [!code-cs[WebParts_WebPartManager_SupportedDisplayModes#1](~/add/codesnippet/csharp/p-system.web.ui.webcontr_388_1.aspx)]  \n  \n After you load the page in a browser, you can use the drop-down list control to switch the page from browse mode to design mode, and then to edit mode. In edit mode, you can click the drop-down verbs menu in the header of one of the server controls, and select **Edit** to edit the control."
  syntax:
    content: public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes { get; }
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection&quot;> </xref>包含的一套<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartDisplayMode&quot;></xref>可在特定的网页上的对象。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty
  id: System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty
  isEii: true
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty
  nameWithType: WebPartManager.System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "获取一个值，指示自定义个性化设置状态数据由<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>控件在网页上已更改。"
  remarks: "IPersonalizable.IsDirty 属性为提供的方法调用方确定个性化状态由管理的数据是否<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制已更改。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> 当用户个性化页级别的详细信息，例如通过更改页面布局、 创建或删除连接，并添加或删除控件，个性化数据由<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制更改。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> 这是受保护的值返回到调用方传递方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A>属性，无法由调用方直接访问该属性。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A>      1> [!NOTE]&1;> IPersonalizable.IsDirty 属性不指示是否可个性化属性值或影响外观的个人的单独属性<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，已更改。</xref:System.Web.UI.WebControls.WebParts.WebPart> 控制级别个性化会单独跟踪的每个控件。 IPersonalizable.IsDirty 属性指示仅个性化数据，在页级别上是由<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制已更改。</xref:System.Web.UI.WebControls.WebParts.WebPartManager>       以下列表描述了将导致要返回的值的 IPersonalizable.IsDirty 属性的个性化某些常见实例`true`，以指示，<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件具有某些更改的个性化数据:-关闭静态<xref:System.Web.UI.WebControls.WebParts.WebPart>控件 （或服务器或用户控件） 在页面上。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartManager>      -还原已关闭的静态<xref:System.Web.UI.WebControls.WebParts.WebPart>从页目录回页的控件。</xref:System.Web.UI.WebControls.WebParts.WebPart>      -将任何控件移，在其区域内或另一个区域。      -从目录中添加控件<xref:System.Web.UI.WebControls.WebParts.WebPart>或服务器控件，或以编程方式添加控件。</xref:System.Web.UI.WebControls.WebParts.WebPart>      -之间创建连接两个<xref:System.Web.UI.WebControls.WebParts.WebPart>控制，以编程方式或通过使用连接用户界面 (UI)。</xref:System.Web.UI.WebControls.WebParts.WebPart>      -删除两个连接<xref:System.Web.UI.WebControls.WebParts.WebPart>控制，以编程方式或通过使用连接用户界面。</xref:System.Web.UI.WebControls.WebParts.WebPart>       若要访问此属性的值，必须强制转换<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件实例与<xref:System.Web.UI.WebControls.WebParts.IPersonalizable>接口; 你可以然后读取<xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A>属性值。</xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A> </xref:System.Web.UI.WebControls.WebParts.IPersonalizable> </xref:System.Web.UI.WebControls.WebParts.WebPartManager>"
  example:
  - "The following code example demonstrates a simple usage of the IPersonalizable.IsDirty property, to indicate some common page personalization instances that cause a <xref:System.Web.UI.WebControls.WebParts.WebPartManager> control's personalization data to change.  \n  \n The code example has four parts:  \n  \n-   A user control that allows you to change display modes on a page that contains Web Parts controls.  \n  \n-   A source file that contains the code for two custom <xref:System.Web.UI.WebControls.WebParts.WebPart> controls that can be connected, and an interface.  \n  \n-   A Web page that hosts all the controls.  \n  \n-   An explanation of how the code example works.  \n  \n The first part of the code example is the user control for changing display modes. You can obtain the source code for the user control from the Example section of the <xref:System.Web.UI.WebControls.WebParts.WebPartManager> class overview. For information about display modes and how the user control works, see [Walkthrough: Changing Display Modes on a Web Parts Page](~/add/includes/ajax-current-ext-md.md).  \n  \n The second part of the example is the source file with the custom controls and the interface. Notice that the `IZipCode` interface exposes one method, and that this method as implemented in the custom `ZipCodeWebPart` control serves as a callback method to enable `ZipCodeWebPart` to act as a provider in a connection scenario. The other control, `WeatherWebPart`, acts as the consumer control in a connection; it can consume the particular interface provided by `ZipCodeWebPart`. In a real application, `WeatherWebPart` could consume a personalized ZIP Code value from the provider, and then provide graphical weather information to users.  \n  \n For the code example to run, you must compile this source code. You can compile it explicitly and put the resulting assembly in your Web site's Bin folder or the global assembly cache. Alternatively, you can put the source code in your site's App_Code folder, where it will be dynamically compiled at run time. This code example uses dynamic compilation; therefore, notice that the `Register` directive for this component at the top of the Web page contains only `TagPrefix` and `Namespace` attributes, without an `Assembly` attribute. For a walkthrough that demonstrates how to compile, see [Walkthrough: Developing and Using a Custom Web Server Control](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[WebParts_WebPartManager_IsDirty#2](~/add/codesnippet/csharp/c24ecc1a-95a5-4007-8876-_1.cs)]\n [!code-vb[WebParts_WebPartManager_IsDirty#2](~/add/codesnippet/visualbasic/c24ecc1a-95a5-4007-8876-_1.vb)]  \n  \n The third part of the code example is the Web page. Notice that it contains two <xref:System.Web.UI.WebControls.WebParts.WebPartZone> zones, with the first one containing the two custom <xref:System.Web.UI.WebControls.WebParts.WebPart> controls. There is also a <xref:System.Web.UI.WebControls.WebParts.CatalogZone> zone, which contains a standard <xref:System.Web.UI.WebControls.Calendar> control that users can add to the page. The `<asp:connectionszone>` element provides a connection UI for users to create connections between controls. In the `Page_PreRender` method, notice that it checks to see whether the personalization data has changed and, if so, updates the text of `Label1`.  \n  \n [!code-cs[WebParts_WebPartManager_IsDirty#1](~/add/codesnippet/csharp/c24ecc1a-95a5-4007-8876-_2.aspx)]\n [!code-vb[WebParts_WebPartManager_IsDirty#1](~/add/codesnippet/visualbasic/c24ecc1a-95a5-4007-8876-_2.aspx)]  \n  \n After you load the page in a browser, try to create some of the scenarios listed in the Remarks section of this topic that will change the personalization data. As you make various changes, when a change involves one of the personalization scenarios tracked by the <xref:System.Web.UI.WebControls.WebParts.WebPartManager> control, the text of the `Label1` control is displayed to indicate that personalization data has changed. For example, you can:  \n  \n-   Create a connection between controls by clicking the **Connect WebPart Controls** button.  \n  \n-   Use the **Display Mode** drop-down list control to switch the page to catalog mode, and add the **My Calendar** control to the second <xref:System.Web.UI.WebControls.WebParts.WebPartZone> zone.  \n  \n-   Change the page back to browse mode, click on the verbs menu (shown with an arrow symbol in the title bar) for the **My Calendar** control, and select **Close** to close it and add it to the page catalog.  \n  \n-   Return the page to catalog mode, and add the **My Calendar** control back to the page.  \n  \n-   Use the **Display Mode** control to switch the page to design mode, and rearrange the layout of the controls by dragging one or more of them to another zone, or to a different position in the same zone."
  syntax:
    content: bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty { get; }
    return:
      type: System.Boolean
      description: "一个布尔值，该值指示是否已更改个性化状态数据。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)
  id: System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)
  isEii: true
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: System.Web.UI.WebControls.WebParts.IPersonalizable.Load(PersonalizationDictionary)
  nameWithType: WebPartManager.System.Web.UI.WebControls.WebParts.IPersonalizable.Load(PersonalizationDictionary)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.System.Web.UI.WebControls.WebParts.IPersonalizable.Load(PersonalizationDictionary)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "返回以前保存的自定义个性化设置状态数据，需要进行加载到<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>控件。"
  remarks: "此方法是实现的<xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Load%2A?displayProperty=fullName>方法，为 Web 部件控件集直接访问受保护提供了一种方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A?displayProperty=fullName>方法。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A?displayProperty=fullName> </xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Load%2A?displayProperty=fullName> 当调用此方法时，它将存储由自定义个性化的数据<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件，并且以前保存更高版本在初始化过程中使用的永久性的数据存储中。</xref:System.Web.UI.WebControls.WebParts.WebPartManager>      1> [!NOTE]&1;> 在大多数情况下，页和控件开发人员代码不必调用此方法，因为主要由 Web 部件控件集用作检索个性化设置数据的机制。"
  syntax:
    content: void IPersonalizable.Load (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);
    parameters:
    - id: state
      type: System.Web.UI.WebControls.WebParts.PersonalizationDictionary
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.PersonalizationDictionary&quot;> </xref> ，其中包含要加载的状态数据。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)
  id: System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)
  isEii: true
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: System.Web.UI.WebControls.WebParts.IPersonalizable.Save(PersonalizationDictionary)
  nameWithType: WebPartManager.System.Web.UI.WebControls.WebParts.IPersonalizable.Save(PersonalizationDictionary)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.System.Web.UI.WebControls.WebParts.IPersonalizable.Save(PersonalizationDictionary)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "将由管理的自定义个性化设置状态数据保存<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>控件。"
  remarks: "IPersonalizable.Save 方法是实现的<xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A?displayProperty=fullName>方法，为 Web 部件控件集直接访问受保护提供了一种方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A?displayProperty=fullName>方法。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A?displayProperty=fullName> </xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A?displayProperty=fullName> 当调用此方法时，它将保存由管理的所有个人的数据<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件添加到为 Web 部件应用程序配置的永久性的数据存储。</xref:System.Web.UI.WebControls.WebParts.WebPartManager>      1> [!NOTE]&1;> 在大多数情况下，页和控件开发人员代码不必调用此方法，因为主要由 Web 部件控件集用作保存个性化设置数据的机制。"
  syntax:
    content: void IPersonalizable.Save (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);
    parameters:
    - id: state
      type: System.Web.UI.WebControls.WebParts.PersonalizationDictionary
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.PersonalizationDictionary&quot;> </xref> ，其中包含要保存的状态数据。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState
  id: TrackViewState
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: TrackViewState()
  nameWithType: WebPartManager.TrackViewState()
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState()
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "个性化状态将数据应用到<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>控件，并且为该控件的视图状态数据更改启用跟踪的基方法的调用。"
  remarks: "对视图状态数据的更改存储在<xref:System.Web.UI.StateBag>对象，并可通过该控件的访问<xref:System.Web.UI.Control.ViewState%2A>属性。</xref:System.Web.UI.Control.ViewState%2A> </xref:System.Web.UI.StateBag>"
  syntax:
    content: protected override void TrackViewState ();
    parameters: []
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.Visible
  id: Visible
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: Visible
  nameWithType: WebPartManager.Visible
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.Visible
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "获取一个值，使子控件可见。"
  remarks: "<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件重写基<xref:System.Web.UI.Control.Visible%2A?displayProperty=fullName>属性始终返回的值`true`可见属性。</xref:System.Web.UI.Control.Visible%2A?displayProperty=fullName> </xref:System.Web.UI.WebControls.WebParts.WebPartManager> 即使<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件本身不可见，请将 Visible 属性必须设置为`true`，以便其所有子控件都是否可见。 默认情况下。</xref:System.Web.UI.WebControls.WebParts.WebPartManager>       如果你尝试设置可见属性的值，它始终生成错误，因为<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件已重写基属性行为，并防止将任何值分配给属性。</xref:System.Web.UI.WebControls.WebParts.WebPartManager>       此属性在可视化设计器，可绑定并非是可在运行时绑定。 有关详细信息，请参阅<xref:System.ComponentModel.BindableAttribute>。</xref:System.ComponentModel.BindableAttribute>"
  syntax:
    content: public override bool Visible { get; set; }
    return:
      type: System.Boolean
      description: "一个布尔值，该值指示是否<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>控件及其子控件是否可见。 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>在所有情况下。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.Visible*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "尝试将值分配给属性。"
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded
  id: WebPartAdded
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: WebPartAdded
  nameWithType: WebPartManager.WebPartAdded
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded
  type: Event
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "在动态之后<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>或者其他服务器控件添加到<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartZoneBase&quot;></xref>区域，以指示已成功添加控件。"
  remarks: "WebPartAdded 事件非常有用，该值指示动态控件 （而不是正在中的页标记声明，以编程方式添加控件） 已成功添加到区域。 结合<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A>方法，该事件提供了开发人员提供一种方法来更新用户界面 (UI) 或通知用户已成功添加控件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A>"
  syntax:
    content: public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded;
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding
  id: WebPartAdding
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: WebPartAdding
  nameWithType: WebPartManager.WebPartAdding
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding
  type: Event
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "添加动态的过程中发生<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>或到其他服务器控件<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartZoneBase&quot;></xref>区域。"
  remarks: "WebPartAdding 事件由引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A>方法后将控件添加到区域的过程已开始。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A> 此事件提供了机会在完成之前取消过程。 如果添加过程成功，此事件后跟<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>事件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>       页开发人员可以通过添加为事件提供自定义处理程序`OnWebPartAdding`属性设为`<asp:webpartmanager>`页上，并将自定义的方法名称分配给该属性中的元素。"
  syntax:
    content: public event System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding;
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed
  id: WebPartClosed
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: WebPartClosed
  nameWithType: WebPartManager.WebPartClosed
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed
  type: Event
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "发生时<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>控件 （或服务器或用户控件） 从页中移除。"
  remarks: "WebPartClosed 事件指示，控件已成功关闭，由用户或以编程方式。 若要关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>控件意味着若要删除从页以便不呈现，并且还将其放在一个特殊持有对象调用页目录。</xref:System.Web.UI.WebControls.WebParts.WebPart> 对应于一个页目录<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>控制，维护对已关闭的引用<xref:System.Web.UI.WebControls.WebParts.WebPart>为每个页的控件。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> 如果<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>控件声明内的网页<xref:System.Web.UI.WebControls.WebParts.CatalogZone>区域，用户可以将页切换到目录的显示模式，并将以前关闭任何控件添加回页面。</xref:System.Web.UI.WebControls.WebParts.CatalogZone> </xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>       WebPartClosed 事件是<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A>方法，其中同时引发事件，并提供该处理程序</xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A>关联       页开发人员可以通过添加添加自定义事件处理程序`OnWebPartClosed`属性设为`<asp:webpartmanager>`页，然后将自定义的方法名称分配到的属性中的元素。"
  syntax:
    content: public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed;
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing
  id: WebPartClosing
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: WebPartClosing
  nameWithType: WebPartManager.WebPartClosing
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing
  type: Event
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "删除的过程中发生<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>从页控件 （或服务器或用户控件）。"
  remarks: "WebPartClosing 事件由引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A>方法时<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件正在关闭一个控件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A> 如果该控件的删除操作成功，此事件后跟<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>事件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>       页开发人员可以通过添加为事件提供自定义处理程序`OnWebPartClosed`属性设为`asp:webpartmanager>`页上，并将自定义的方法名称分配给该属性中的元素。       通常情况下，WebPartClosing 事件引发作为用户结束的直接结果<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，可以取消该事件。</xref:System.Web.UI.WebControls.WebParts.WebPart> 但是，没有事件不能在其中被取消的方案。 如果<xref:System.Web.UI.WebControls.WebParts.WebPartZone>中删除控件，<xref:System.Web.UI.WebControls.WebParts.WebPart>它包含的控件必须先结束所有，否则它们将被孤立。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartZone> 在这种情况下<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>控制，不是用户。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartManager> 以及何时<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件正在调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>方法来关闭每个控件，并引发 WebPartClosing 事件，事件不能被取消 （按照设计），因为<xref:System.Web.UI.WebControls.WebParts.WebPartManager>需要完成清理所有区域控件的任务。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> </xref:System.Web.UI.WebControls.WebParts.WebPartManager>"
  syntax:
    content: public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing;
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted
  id: WebPartDeleted
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: WebPartDeleted
  nameWithType: WebPartManager.WebPartDeleted
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted
  type: Event
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "之后，将会<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>或其他服务器控件已被删除从<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartZoneBase&quot;></xref>区域。"
  remarks: "WebPartDeleted 事件非常有用，该值指示动态控件 （而不是正在中的页标记声明，以编程方式添加控件） 已成功删除从区域。 结合<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A>方法，该事件提供了开发人员提供一种方法来更新用户界面 (UI) 或通知用户已成功删除控件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A>"
  syntax:
    content: public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted;
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting
  id: WebPartDeleting
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: WebPartDeleting
  nameWithType: WebPartManager.WebPartDeleting
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting
  type: Event
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "永久删除的动态实例的过程中发生<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>或从其他服务器控件<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartZoneBase&quot;></xref>区域。"
  remarks: "WebPartDeleting 事件由引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A>方法，在删除动态控件 （通过编程方式或通过 Web 部件用户界面的用户已添加的控件） 的过程。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A> 事件提供了机会在它完成之前取消过程。 如果成功完成删除过程，此事件后跟<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>事件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>       页开发人员可以通过添加为事件提供自定义处理程序`OnWebPartDeleting`属性设为`<asp:webpartmanager>`页上，并将自定义的方法名称分配给该属性中的元素。"
  syntax:
    content: public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting;
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved
  id: WebPartMoved
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: WebPartMoved
  nameWithType: WebPartManager.WebPartMoved
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved
  type: Event
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "之后，将会<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>或服务器控件已被移动到其他位置在网页上。"
  remarks: "此事件同时适用于静态 （在网页上的标记中声明） 和动态控件。 与之关联<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A>方法。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> 因为引发事件时完成移动后，开发人员可以包含事件处理程序来提供某些通知提供给用户、 一些验证或某些其他操作。 若要添加事件处理程序，你可以添加`OnWebPartMoved`属性设为`<asp:webpartmanager>`页上，并将赋给特性的自定义方法的名称中的元素。"
  syntax:
    content: public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved;
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving
  id: WebPartMoving
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: WebPartMoving
  nameWithType: WebPartManager.WebPartMoving
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving
  type: Event
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "移动过程中发生<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>或包含在其他服务器控件<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartZoneBase&quot;></xref>区域。"
  remarks: "将引发 WebPartMoving 事件时<xref:System.Web.UI.WebControls.WebParts.WebPart>或其他服务器控件将被移到另一个区域或其自己的区域，。</xref:System.Web.UI.WebControls.WebParts.WebPart> 当用户拖动控件，或以编程方式移动时，则可以发生此情况。       WebPartMoving 事件由引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A>方法，并提供在完成之前取消移动过程的机会。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> 如果移动已完成，控件已放置在新位置，此事件后跟<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>事件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>       页开发人员可以创建自定义事件处理程序，通过添加`OnWebPartMoving`属性设为`<asp:webpartmanager>`元素，并将自定义的方法名称分配给该属性。"
  syntax:
    content: public event System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving;
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.WebParts
  id: WebParts
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: WebParts
  nameWithType: WebPartManager.WebParts
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.WebParts
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "获取所有的引用<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>控件跟踪<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartManager&quot;></xref>在网页上的控件。"
  remarks: "使用 web 部件属性<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件跟踪所有<xref:System.Web.UI.WebControls.WebParts.WebPart>中包含的控件<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>页上的区域。</xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> </xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartManager> 尽管该集合是只读的你可以访问单个<xref:System.Web.UI.WebControls.WebParts.WebPart>以编程方式控制通过对它们的集合并进行更改。</xref:System.Web.UI.WebControls.WebParts.WebPart>      1> [!NOTE]&1;>，可能能够<xref:System.Web.UI.WebControls.WebParts.WebPart>控件将外部的页面上放置<xref:System.Web.UI.WebControls.WebParts.WebPartZone>区域，这会导致控件未跟踪<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制或其 web 部件集合中引用。</xref:System.Web.UI.WebControls.WebParts.WebPartManager> </xref:System.Web.UI.WebControls.WebParts.WebPartZone> </xref:System.Web.UI.WebControls.WebParts.WebPart> 但是，很少使用<xref:System.Web.UI.WebControls.WebParts.WebPart>管理区域，之外，因为它然后丢失其 Web 部件功能并作为正常的服务器控件。</xref:System.Web.UI.WebControls.WebParts.WebPart>       任何类型的控件，无论是自定义可以放置在区域中，<xref:System.Web.UI.WebControls.WebParts.WebPart>控件、 标准 ASP.NET 控件、 一个用户控件或自定义服务器控件，可以被视为<xref:System.Web.UI.WebControls.WebParts.WebPart>控件在运行时。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPart> 不是控件时<xref:System.Web.UI.WebControls.WebParts.WebPart>控件放入<xref:System.Web.UI.WebControls.WebParts.WebPartZone>区域，在 ASP.NET 包装控件的运行时<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>对象，以便控件可以具有的行为与真正<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.GenericWebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartZone> </xref:System.Web.UI.WebControls.WebParts.WebPart> 因此，通过使用 web 部件属性，<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件可以跟踪任何类型的服务器控件，无论是否它派生自<xref:System.Web.UI.WebControls.WebParts.WebPart>类。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartManager>"
  example:
  - "The following code example demonstrates how to use the WebParts property programmatically to access individual <xref:System.Web.UI.WebControls.WebParts.WebPart> controls. Notice that in the declarative markup for the Web page, within the `<asp:webpartzone>` element there are two standard ASP.NET server controls. Although these do not inherit from the <xref:System.Web.UI.WebControls.WebParts.WebPart> class, because they are in a zone they will be wrapped with a <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> object at run time, and thus will be included in the collection referenced by the WebParts property. You could also add custom <xref:System.Web.UI.WebControls.WebParts.WebPart> controls, user controls, or custom server controls in this zone, and they would be handled the same way.  \n  \n [!code-vb[WebParts_WebPartManager_WebParts#1](~/add/codesnippet/visualbasic/p-system.web.ui.webcontr_992_1.aspx)]\n [!code-cs[WebParts_WebPartManager_WebParts#1](~/add/codesnippet/csharp/p-system.web.ui.webcontr_992_1.aspx)]  \n  \n Note that for the code example to work, you must add a setting in the Web.config file to enable exporting Web Parts description files. Ensure that you have a Web.config file in the same directory as the Web page for this code example. Within the `<system.web>` section, make sure there is a `<webParts>` element with an `enableExport` attribute set to `true`, as in the following markup.  \n  \n `<webParts enableExport=\"true\">`  \n  \n `...`  \n  \n `</webParts>`  \n  \n After you load the page into a browser, if you click the **WebPart Count** button, the code uses the WebParts property to return the count of controls in the collection. If you click the **Hide Calendar Title** button, the code changes the calendar so that it renders with only a border and not a title."
  syntax:
    content: public System.Web.UI.WebControls.WebParts.WebPartCollection WebParts { get; }
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartCollection
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartCollection&quot;> </xref> ，其中包含一套引用<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>控件。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.WebParts*
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected
  id: WebPartsConnected
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: WebPartsConnected
  nameWithType: WebPartManager.WebPartsConnected
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected
  type: Event
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "后特定的连接建立之间发生<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>控件 （或服务器或用户控件）。"
  remarks: "与关联 WebPartsConnected 事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A>方法。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A> 此事件非常有用，因为你知道连接已完成后，你可能想要通知的事实，用户或甚至更改页面的用户界面 (UI)。 例如，你可能想要显示某个提供两个控件之间的成功连接的建议的图形图像或显示简要的消息，，然后在各个页面显示模式回浏览模式。       页开发人员可以通过添加与此事件关联的自定义事件处理程序`OnWebPartsConnected`属性设为`<asp:webpartmanager>`页上，并将自定义的方法名称分配给该属性中的元素。"
  syntax:
    content: public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected;
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting
  id: WebPartsConnecting
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: WebPartsConnecting
  nameWithType: WebPartManager.WebPartsConnecting
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting
  type: Event
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "创建之间的连接的过程中发生<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>控件 (或服务器或用户控件置于<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartZoneBase&quot;></xref>区域)。"
  remarks: "WebPartsConnecting 事件由引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A>方法，并且它表明连接过程已开始 （例如，用户已选择了某个控件并单击连接谓词），但尚未完成。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A> 事件提供了机会在完成之前取消连接。 如果连接成功完成，此事件后跟<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>事件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>       页开发人员可以通过添加添加自定义事件处理程序`OnWebPartsConnecting`属性设为`<asp:webpartmanager>`元素，并将自定义的方法名称分配给该属性。"
  syntax:
    content: public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting;
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected
  id: WebPartsDisconnected
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: WebPartsDisconnected
  nameWithType: WebPartManager.WebPartsDisconnected
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected
  type: Event
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "在两个之间的连接之后<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>或已终止服务器控件。"
  remarks: "与关联 WebPartsDisconnected 事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A>方法。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A> 此事件非常有用，因为你知道连接终止后，你可能想要通知用户，在代码中，执行某些清除操作或在用户界面 (UI) 中进行其他更改。       页开发人员可以通过添加与此事件关联的自定义事件处理程序`OnWebPartsDisConnected`属性设为`<asp:webpartmanager>`页上，并将自定义的方法名称分配给该属性中的元素。"
  syntax:
    content: public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected;
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting
  id: WebPartsDisconnecting
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: WebPartsDisconnecting
  nameWithType: WebPartManager.WebPartsDisconnecting
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting
  type: Event
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "结束连接过程中发生之间以前连接<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPart&quot;></xref>或服务器控件。"
  remarks: "WebPartsDisconnecting 事件由引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A>方法，并表明这样的事实用户已单击断开连接的谓词，或<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>否则调用方法。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> </xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A> 事件提供了机会取消完成之前结束连接的过程。 如果连接由于成功结束，此事件后跟<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>事件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>       页开发人员可以通过添加添加自定义事件处理程序`OnWebPartsDisconnecting`属性设为`<asp:webpartmanager>`元素，并将自定义的方法名称分配给该属性。       通常情况下，当作为结束连接的用户的操作的直接结果引发 WebPartsDisconnecting 事件时，可以取消该事件。 但是，有几种应用场景中的事件不能被取消。 第一个方案是，如果<xref:System.Web.UI.WebControls.WebParts.WebPartZone>中删除控件，<xref:System.Web.UI.WebControls.WebParts.WebPart>它包含的控件必须先结束所有，否则它们将被孤立。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartZone> 在这种情况下<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，不用户，和它必须还能够以终止绝不会遭受的中断，任何连接的控件的连接，以便它可以完成清理并关闭所有控件的过程。</xref:System.Web.UI.WebControls.WebParts.WebPart> </xref:System.Web.UI.WebControls.WebParts.WebPartManager> 因此，设计使然 WebPartsDisconnecting 方法不能取消在此方案中。 可以取消的相关事件，请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>事件。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>       无法在其中取消 WebPartsDisconnecting 事件第二个情况的情形是<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>调用方法时 （这在到页中，每个请求过程中例如调用），并且没有某种类型的页上的现有连接中的冲突。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> 例如，用户可能是连接到控件 y 的控件 x 但控件 x 来控制 z，共享的用户连接和尚未控件 x 不允许进行多个连接。 在这种情况下，连接的每个用户的设置优先，和<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件将解决冲突，通过调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法和结束之间的连接 x 和 z 适用于特定用户。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> </xref:System.Web.UI.WebControls.WebParts.WebPartManager> 由于此断开连接是必需的解决冲突，设计使然 WebPartsDisconnecting 事件不能取消在此方案中。       在其中 WebPartsDisconnecting 方法不能取消第三个情况的情形是<xref:System.Web.UI.WebControls.WebParts.WebPart>或删除或关闭当前连接的服务器控件。</xref:System.Web.UI.WebControls.WebParts.WebPart> 由于控件肯定会从此页中删除，它是逻辑必不可少若要删除其连接的。 因此，当<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件时，将调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法，后者又引发 WebPartsDisconnecting 事件时，设计使然是不可能取消该事件不存在。</xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> </xref:System.Web.UI.WebControls.WebParts.WebPartManager>"
  syntax:
    content: public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting;
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.Zones
  id: Zones
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  langs:
  - csharp
  name: Zones
  nameWithType: WebPartManager.Zones
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.Zones
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web.UI.WebControls.WebParts
  summary: "获取所有的集合的引用<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartZoneBase&quot;></xref>在网页上的区域。"
  remarks: "使用区域属性<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件跟踪<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>在网页上的区域。</xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> </xref:System.Web.UI.WebControls.WebParts.WebPartManager> 请注意属性不引用所有类型的区域;它引用派生自的区域<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>类，其中包括<xref:System.Web.UI.WebControls.WebParts.WebPartZone>区域。</xref:System.Web.UI.WebControls.WebParts.WebPartZone> </xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>       尽管该属性引用的集合是只读的但可以使用它可以访问集合中的单个对象，并以编程方式使用它们。"
  example:
  - "The following code example demonstrates how to use the Zones property programmatically to access individual <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zone controls. Notice that in the declarative markup for the Web page, there are two `<asp:webpartzone>` elements, each containing a server control. In the `<script>` section of the page, the code uses the Zones property to access the individual zones, listing all the zone IDs and then changing the background color on the second zone.  \n  \n [!code-cs[WebParts_WebPartManager_Zones#1](~/add/codesnippet/csharp/p-system.web.ui.webcontr_860_1.aspx)]\n [!code-vb[WebParts_WebPartManager_Zones#1](~/add/codesnippet/visualbasic/p-system.web.ui.webcontr_860_1.aspx)]  \n  \n Note that for the code example to work, you must add a setting in the Web.config file to enable exporting Web Parts description files. Ensure that you have a Web.config file in the same directory as the Web page for this code example. Within the `<system.web>` section, make sure there is a `<webParts>` element with an `enableExport` attribute set to `true`, as in the following markup.  \n  \n `<webParts enableExport=\"true\">`  \n  \n `...`  \n  \n `</webParts>`  \n  \n After you load the page into a browser, if you click the **List Zone IDs** button, the code uses the Zones property to list the IDs of all zones in the collection. If you click the **Change Zone BackColor** button, the code changes the background color of the second zone."
  syntax:
    content: public System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones { get; }
    return:
      type: System.Web.UI.WebControls.WebParts.WebPartZoneCollection
      description: "A <xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartZoneCollection&quot;> </xref>引用一组<xref href=&quot;System.Web.UI.WebControls.WebParts.WebPartZoneBase&quot;></xref>区域。"
  overload: System.Web.UI.WebControls.WebParts.WebPartManager.Zones*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Web.UI.Control
  isExternal: false
  name: System.Web.UI.Control
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.IO.EndOfStreamException
  isExternal: true
  name: System.IO.EndOfStreamException
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.#ctor
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: WebPartManager()
  nameWithType: WebPartManager.WebPartManager()
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartManager()
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: ActivateConnections()
  nameWithType: WebPartManager.ActivateConnections()
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections()
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: AddWebPart(WebPart,WebPartZoneBase,Int32)
  nameWithType: WebPartManager.AddWebPart(WebPart,WebPartZoneBase,Int32)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(WebPart,WebPartZoneBase,Int32)
- uid: System.Web.UI.WebControls.WebParts.WebPart
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: WebPart
  nameWithType: WebPart
  fullName: System.Web.UI.WebControls.WebParts.WebPart
- uid: System.Web.UI.WebControls.WebParts.WebPartZoneBase
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: WebPartZoneBase
  nameWithType: WebPartZoneBase
  fullName: System.Web.UI.WebControls.WebParts.WebPartZoneBase
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: AuthorizeWebPart
  nameWithType: WebPartManager.AuthorizeWebPart
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart
- uid: System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: WebPartAuthorizationEventHandler
  nameWithType: WebPartAuthorizationEventHandler
  fullName: System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: AvailableTransformers
  nameWithType: WebPartManager.AvailableTransformers
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers
- uid: System.Web.UI.WebControls.WebParts.TransformerTypeCollection
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: TransformerTypeCollection
  nameWithType: TransformerTypeCollection
  fullName: System.Web.UI.WebControls.WebParts.TransformerTypeCollection
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: BeginWebPartConnecting(WebPart)
  nameWithType: WebPartManager.BeginWebPartConnecting(WebPart)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(WebPart)
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: BeginWebPartEditing(WebPart)
  nameWithType: WebPartManager.BeginWebPartEditing(WebPart)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(WebPart)
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: BrowseDisplayMode
  nameWithType: WebPartManager.BrowseDisplayMode
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode
- uid: System.Web.UI.WebControls.WebParts.WebPartDisplayMode
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: WebPartDisplayMode
  nameWithType: WebPartDisplayMode
  fullName: System.Web.UI.WebControls.WebParts.WebPartDisplayMode
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: CanConnectWebParts(WebPart,ProviderConnectionPoint,WebPart,ConsumerConnectionPoint)
  nameWithType: WebPartManager.CanConnectWebParts(WebPart,ProviderConnectionPoint,WebPart,ConsumerConnectionPoint)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(WebPart,ProviderConnectionPoint,WebPart,ConsumerConnectionPoint)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Web.UI.WebControls.WebParts.ProviderConnectionPoint
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: ProviderConnectionPoint
  nameWithType: ProviderConnectionPoint
  fullName: System.Web.UI.WebControls.WebParts.ProviderConnectionPoint
- uid: System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: ConsumerConnectionPoint
  nameWithType: ConsumerConnectionPoint
  fullName: System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: CanConnectWebParts(WebPart,ProviderConnectionPoint,WebPart,ConsumerConnectionPoint,WebPartTransformer)
  nameWithType: WebPartManager.CanConnectWebParts(WebPart,ProviderConnectionPoint,WebPart,ConsumerConnectionPoint,WebPartTransformer)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(WebPart,ProviderConnectionPoint,WebPart,ConsumerConnectionPoint,WebPartTransformer)
- uid: System.Web.UI.WebControls.WebParts.WebPartTransformer
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: WebPartTransformer
  nameWithType: WebPartTransformer
  fullName: System.Web.UI.WebControls.WebParts.WebPartTransformer
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: CatalogDisplayMode
  nameWithType: WebPartManager.CatalogDisplayMode
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CheckRenderClientScript
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: CheckRenderClientScript()
  nameWithType: WebPartManager.CheckRenderClientScript()
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.CheckRenderClientScript()
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: CloseProviderWarning
  nameWithType: WebPartManager.CloseProviderWarning
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: CloseWebPart(WebPart)
  nameWithType: WebPartManager.CloseWebPart(WebPart)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(WebPart)
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: ConnectDisplayMode
  nameWithType: WebPartManager.ConnectDisplayMode
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.Connections
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: Connections
  nameWithType: WebPartManager.Connections
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.Connections
- uid: System.Web.UI.WebControls.WebParts.WebPartConnectionCollection
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: WebPartConnectionCollection
  nameWithType: WebPartConnectionCollection
  fullName: System.Web.UI.WebControls.WebParts.WebPartConnectionCollection
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: ConnectionsActivated
  nameWithType: WebPartManager.ConnectionsActivated
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: ConnectionsActivating
  nameWithType: WebPartManager.ConnectionsActivating
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: ConnectWebParts(WebPart,ProviderConnectionPoint,WebPart,ConsumerConnectionPoint)
  nameWithType: WebPartManager.ConnectWebParts(WebPart,ProviderConnectionPoint,WebPart,ConsumerConnectionPoint)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(WebPart,ProviderConnectionPoint,WebPart,ConsumerConnectionPoint)
- uid: System.Web.UI.WebControls.WebParts.WebPartConnection
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: WebPartConnection
  nameWithType: WebPartConnection
  fullName: System.Web.UI.WebControls.WebParts.WebPartConnection
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: ConnectWebParts(WebPart,ProviderConnectionPoint,WebPart,ConsumerConnectionPoint,WebPartTransformer)
  nameWithType: WebPartManager.ConnectWebParts(WebPart,ProviderConnectionPoint,WebPart,ConsumerConnectionPoint,WebPartTransformer)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(WebPart,ProviderConnectionPoint,WebPart,ConsumerConnectionPoint,WebPartTransformer)
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.Controls
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: Controls
  nameWithType: WebPartManager.Controls
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.Controls
- uid: System.Web.UI.ControlCollection
  parent: System.Web.UI
  isExternal: false
  name: ControlCollection
  nameWithType: ControlCollection
  fullName: System.Web.UI.ControlCollection
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart(System.Web.UI.WebControls.WebParts.WebPart)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: CopyWebPart(WebPart)
  nameWithType: WebPartManager.CopyWebPart(WebPart)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart(WebPart)
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: CreateAvailableTransformers()
  nameWithType: WebPartManager.CreateAvailableTransformers()
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers()
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CreateControlCollection
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: CreateControlCollection()
  nameWithType: WebPartManager.CreateControlCollection()
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.CreateControlCollection()
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: CreateDisplayModes()
  nameWithType: WebPartManager.CreateDisplayModes()
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes()
- uid: System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: WebPartDisplayModeCollection
  nameWithType: WebPartDisplayModeCollection
  fullName: System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: CreateDynamicConnectionID()
  nameWithType: WebPartManager.CreateDynamicConnectionID()
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID()
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: CreateDynamicWebPartID(Type)
  nameWithType: WebPartManager.CreateDynamicWebPartID(Type)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(Type)
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: CreateErrorWebPart(String,String,String,String,String)
  nameWithType: WebPartManager.CreateErrorWebPart(String,String,String,String,String)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(String,String,String,String,String)
- uid: System.Web.UI.WebControls.WebParts.ErrorWebPart
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: ErrorWebPart
  nameWithType: ErrorWebPart
  fullName: System.Web.UI.WebControls.WebParts.ErrorWebPart
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: CreatePersonalization()
  nameWithType: WebPartManager.CreatePersonalization()
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization()
- uid: System.Web.UI.WebControls.WebParts.WebPartPersonalization
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: WebPartPersonalization
  nameWithType: WebPartPersonalization
  fullName: System.Web.UI.WebControls.WebParts.WebPartPersonalization
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: CreateWebPart(Control)
  nameWithType: WebPartManager.CreateWebPart(Control)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(Control)
- uid: System.Web.UI.WebControls.WebParts.GenericWebPart
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: GenericWebPart
  nameWithType: GenericWebPart
  fullName: System.Web.UI.WebControls.WebParts.GenericWebPart
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: DeleteWarning
  nameWithType: WebPartManager.DeleteWarning
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: DeleteWebPart(WebPart)
  nameWithType: WebPartManager.DeleteWebPart(WebPart)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(WebPart)
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: DesignDisplayMode
  nameWithType: WebPartManager.DesignDisplayMode
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: DisconnectWebPart(WebPart)
  nameWithType: WebPartManager.DisconnectWebPart(WebPart)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(WebPart)
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: DisconnectWebParts(WebPartConnection)
  nameWithType: WebPartManager.DisconnectWebParts(WebPartConnection)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(WebPartConnection)
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: DisplayMode
  nameWithType: WebPartManager.DisplayMode
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: DisplayModeChanged
  nameWithType: WebPartManager.DisplayModeChanged
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged
- uid: System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: WebPartDisplayModeEventHandler
  nameWithType: WebPartDisplayModeEventHandler
  fullName: System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: DisplayModeChanging
  nameWithType: WebPartManager.DisplayModeChanging
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging
- uid: System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: WebPartDisplayModeCancelEventHandler
  nameWithType: WebPartDisplayModeCancelEventHandler
  fullName: System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: DisplayModes
  nameWithType: WebPartManager.DisplayModes
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: DynamicConnections
  nameWithType: WebPartManager.DynamicConnections
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: EditDisplayMode
  nameWithType: WebPartManager.EditDisplayMode
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: EnableClientScript
  nameWithType: WebPartManager.EnableClientScript
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: EnableTheming
  nameWithType: WebPartManager.EnableTheming
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: EndWebPartConnecting()
  nameWithType: WebPartManager.EndWebPartConnecting()
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting()
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: EndWebPartEditing()
  nameWithType: WebPartManager.EndWebPartEditing()
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing()
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: ExportSensitiveDataWarning
  nameWithType: WebPartManager.ExportSensitiveDataWarning
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: ExportWebPart(WebPart,XmlWriter)
  nameWithType: WebPartManager.ExportWebPart(WebPart,XmlWriter)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(WebPart,XmlWriter)
- uid: System.Xml.XmlWriter
  parent: System.Xml
  isExternal: true
  name: XmlWriter
  nameWithType: XmlWriter
  fullName: System.Xml.XmlWriter
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.Focus
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: Focus()
  nameWithType: WebPartManager.Focus()
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.Focus()
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: GetConsumerConnectionPoints(WebPart)
  nameWithType: WebPartManager.GetConsumerConnectionPoints(WebPart)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(WebPart)
- uid: System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: ConsumerConnectionPointCollection
  nameWithType: ConsumerConnectionPointCollection
  fullName: System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager(System.Web.UI.Page)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: GetCurrentWebPartManager(Page)
  nameWithType: WebPartManager.GetCurrentWebPartManager(Page)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager(Page)
- uid: System.Web.UI.WebControls.WebParts.WebPartManager
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: WebPartManager
  nameWithType: WebPartManager
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager
- uid: System.Web.UI.Page
  parent: System.Web.UI
  isExternal: false
  name: Page
  nameWithType: Page
  fullName: System.Web.UI.Page
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.GetDisplayTitle(System.Web.UI.WebControls.WebParts.WebPart)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: GetDisplayTitle(WebPart)
  nameWithType: WebPartManager.GetDisplayTitle(WebPart)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.GetDisplayTitle(WebPart)
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl(System.Web.UI.WebControls.WebParts.WebPart)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: GetExportUrl(WebPart)
  nameWithType: WebPartManager.GetExportUrl(WebPart)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl(WebPart)
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart(System.Web.UI.Control)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: GetGenericWebPart(Control)
  nameWithType: WebPartManager.GetGenericWebPart(Control)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart(Control)
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: GetProviderConnectionPoints(WebPart)
  nameWithType: WebPartManager.GetProviderConnectionPoints(WebPart)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(WebPart)
- uid: System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: ProviderConnectionPointCollection
  nameWithType: ProviderConnectionPointCollection
  fullName: System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: ImportWebPart(XmlReader,String)
  nameWithType: WebPartManager.ImportWebPart(XmlReader,String)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(XmlReader,String)
- uid: System.Xml.XmlReader
  parent: System.Xml
  isExternal: true
  name: XmlReader
  nameWithType: XmlReader
  fullName: System.Xml.XmlReader
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.Internals
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: Internals
  nameWithType: WebPartManager.Internals
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.Internals
- uid: System.Web.UI.WebControls.WebParts.WebPartManagerInternals
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: WebPartManagerInternals
  nameWithType: WebPartManagerInternals
  fullName: System.Web.UI.WebControls.WebParts.WebPartManagerInternals
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Web.UI.WebControls.WebParts.WebPart)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: IsAuthorized(WebPart)
  nameWithType: WebPartManager.IsAuthorized(WebPart)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(WebPart)
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: IsAuthorized(Type,String,String,Boolean)
  nameWithType: WebPartManager.IsAuthorized(Type,String,String,Boolean)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(Type,String,String,Boolean)
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: IsCustomPersonalizationStateDirty
  nameWithType: WebPartManager.IsCustomPersonalizationStateDirty
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState(System.Object)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: LoadControlState(Object)
  nameWithType: WebPartManager.LoadControlState(Object)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: LoadCustomPersonalizationState(PersonalizationDictionary)
  nameWithType: WebPartManager.LoadCustomPersonalizationState(PersonalizationDictionary)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(PersonalizationDictionary)
- uid: System.Web.UI.WebControls.WebParts.PersonalizationDictionary
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: PersonalizationDictionary
  nameWithType: PersonalizationDictionary
  fullName: System.Web.UI.WebControls.WebParts.PersonalizationDictionary
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: MediumPermissionSet
  nameWithType: WebPartManager.MediumPermissionSet
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet
- uid: System.Security.PermissionSet
  parent: System.Security
  isExternal: false
  name: PermissionSet
  nameWithType: PermissionSet
  fullName: System.Security.PermissionSet
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: MinimalPermissionSet
  nameWithType: WebPartManager.MinimalPermissionSet
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: MoveWebPart(WebPart,WebPartZoneBase,Int32)
  nameWithType: WebPartManager.MoveWebPart(WebPart,WebPartZoneBase,Int32)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(WebPart,WebPartZoneBase,Int32)
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnAuthorizeWebPart(WebPartAuthorizationEventArgs)
  nameWithType: WebPartManager.OnAuthorizeWebPart(WebPartAuthorizationEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(WebPartAuthorizationEventArgs)
- uid: System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: WebPartAuthorizationEventArgs
  nameWithType: WebPartAuthorizationEventArgs
  fullName: System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnConnectionsActivated(EventArgs)
  nameWithType: WebPartManager.OnConnectionsActivated(EventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(EventArgs)
- uid: System.EventArgs
  parent: System
  isExternal: true
  name: EventArgs
  nameWithType: EventArgs
  fullName: System.EventArgs
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnConnectionsActivating(EventArgs)
  nameWithType: WebPartManager.OnConnectionsActivating(EventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(EventArgs)
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnDisplayModeChanged(WebPartDisplayModeEventArgs)
  nameWithType: WebPartManager.OnDisplayModeChanged(WebPartDisplayModeEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(WebPartDisplayModeEventArgs)
- uid: System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: WebPartDisplayModeEventArgs
  nameWithType: WebPartDisplayModeEventArgs
  fullName: System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnDisplayModeChanging(WebPartDisplayModeCancelEventArgs)
  nameWithType: WebPartManager.OnDisplayModeChanging(WebPartDisplayModeCancelEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(WebPartDisplayModeCancelEventArgs)
- uid: System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: WebPartDisplayModeCancelEventArgs
  nameWithType: WebPartDisplayModeCancelEventArgs
  fullName: System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnInit(System.EventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnInit(EventArgs)
  nameWithType: WebPartManager.OnInit(EventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnInit(EventArgs)
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender(System.EventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnPreRender(EventArgs)
  nameWithType: WebPartManager.OnPreRender(EventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender(EventArgs)
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnSelectedWebPartChanged(WebPartEventArgs)
  nameWithType: WebPartManager.OnSelectedWebPartChanged(WebPartEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(WebPartEventArgs)
- uid: System.Web.UI.WebControls.WebParts.WebPartEventArgs
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: WebPartEventArgs
  nameWithType: WebPartEventArgs
  fullName: System.Web.UI.WebControls.WebParts.WebPartEventArgs
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnSelectedWebPartChanging(WebPartCancelEventArgs)
  nameWithType: WebPartManager.OnSelectedWebPartChanging(WebPartCancelEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(WebPartCancelEventArgs)
- uid: System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: WebPartCancelEventArgs
  nameWithType: WebPartCancelEventArgs
  fullName: System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnUnload(System.EventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnUnload(EventArgs)
  nameWithType: WebPartManager.OnUnload(EventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnUnload(EventArgs)
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnWebPartAdded(WebPartEventArgs)
  nameWithType: WebPartManager.OnWebPartAdded(WebPartEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(WebPartEventArgs)
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnWebPartAdding(WebPartAddingEventArgs)
  nameWithType: WebPartManager.OnWebPartAdding(WebPartAddingEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(WebPartAddingEventArgs)
- uid: System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: WebPartAddingEventArgs
  nameWithType: WebPartAddingEventArgs
  fullName: System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnWebPartClosed(WebPartEventArgs)
  nameWithType: WebPartManager.OnWebPartClosed(WebPartEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(WebPartEventArgs)
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnWebPartClosing(WebPartCancelEventArgs)
  nameWithType: WebPartManager.OnWebPartClosing(WebPartCancelEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(WebPartCancelEventArgs)
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnWebPartDeleted(WebPartEventArgs)
  nameWithType: WebPartManager.OnWebPartDeleted(WebPartEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(WebPartEventArgs)
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnWebPartDeleting(WebPartCancelEventArgs)
  nameWithType: WebPartManager.OnWebPartDeleting(WebPartCancelEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(WebPartCancelEventArgs)
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnWebPartMoved(WebPartEventArgs)
  nameWithType: WebPartManager.OnWebPartMoved(WebPartEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(WebPartEventArgs)
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnWebPartMoving(WebPartMovingEventArgs)
  nameWithType: WebPartManager.OnWebPartMoving(WebPartMovingEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(WebPartMovingEventArgs)
- uid: System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: WebPartMovingEventArgs
  nameWithType: WebPartMovingEventArgs
  fullName: System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnWebPartsConnected(WebPartConnectionsEventArgs)
  nameWithType: WebPartManager.OnWebPartsConnected(WebPartConnectionsEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(WebPartConnectionsEventArgs)
- uid: System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: WebPartConnectionsEventArgs
  nameWithType: WebPartConnectionsEventArgs
  fullName: System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnWebPartsConnecting(WebPartConnectionsCancelEventArgs)
  nameWithType: WebPartManager.OnWebPartsConnecting(WebPartConnectionsCancelEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(WebPartConnectionsCancelEventArgs)
- uid: System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: WebPartConnectionsCancelEventArgs
  nameWithType: WebPartConnectionsCancelEventArgs
  fullName: System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnWebPartsDisconnected(WebPartConnectionsEventArgs)
  nameWithType: WebPartManager.OnWebPartsDisconnected(WebPartConnectionsEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(WebPartConnectionsEventArgs)
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnWebPartsDisconnecting(WebPartConnectionsCancelEventArgs)
  nameWithType: WebPartManager.OnWebPartsDisconnecting(WebPartConnectionsCancelEventArgs)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(WebPartConnectionsCancelEventArgs)
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.Personalization
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: Personalization
  nameWithType: WebPartManager.Personalization
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.Personalization
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.RegisterClientScript
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: RegisterClientScript()
  nameWithType: WebPartManager.RegisterClientScript()
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.RegisterClientScript()
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.Render(System.Web.UI.HtmlTextWriter)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: Render(HtmlTextWriter)
  nameWithType: WebPartManager.Render(HtmlTextWriter)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.Render(HtmlTextWriter)
- uid: System.Web.UI.HtmlTextWriter
  parent: System.Web.UI
  isExternal: false
  name: HtmlTextWriter
  nameWithType: HtmlTextWriter
  fullName: System.Web.UI.HtmlTextWriter
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: SaveControlState()
  nameWithType: WebPartManager.SaveControlState()
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState()
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: SaveCustomPersonalizationState(PersonalizationDictionary)
  nameWithType: WebPartManager.SaveCustomPersonalizationState(PersonalizationDictionary)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(PersonalizationDictionary)
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: SelectedWebPart
  nameWithType: WebPartManager.SelectedWebPart
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: SelectedWebPartChanged
  nameWithType: WebPartManager.SelectedWebPartChanged
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged
- uid: System.Web.UI.WebControls.WebParts.WebPartEventHandler
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: WebPartEventHandler
  nameWithType: WebPartEventHandler
  fullName: System.Web.UI.WebControls.WebParts.WebPartEventHandler
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: SelectedWebPartChanging
  nameWithType: WebPartManager.SelectedWebPartChanging
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging
- uid: System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: WebPartCancelEventHandler
  nameWithType: WebPartCancelEventHandler
  fullName: System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: SetPersonalizationDirty()
  nameWithType: WebPartManager.SetPersonalizationDirty()
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty()
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: SetSelectedWebPart(WebPart)
  nameWithType: WebPartManager.SetSelectedWebPart(WebPart)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(WebPart)
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.SkinID
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: SkinID
  nameWithType: WebPartManager.SkinID
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.SkinID
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: StaticConnections
  nameWithType: WebPartManager.StaticConnections
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: SupportedDisplayModes
  nameWithType: WebPartManager.SupportedDisplayModes
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty
  nameWithType: WebPartManager.System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: System.Web.UI.WebControls.WebParts.IPersonalizable.Load(PersonalizationDictionary)
  nameWithType: WebPartManager.System.Web.UI.WebControls.WebParts.IPersonalizable.Load(PersonalizationDictionary)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.System.Web.UI.WebControls.WebParts.IPersonalizable.Load(PersonalizationDictionary)
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: System.Web.UI.WebControls.WebParts.IPersonalizable.Save(PersonalizationDictionary)
  nameWithType: WebPartManager.System.Web.UI.WebControls.WebParts.IPersonalizable.Save(PersonalizationDictionary)
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.System.Web.UI.WebControls.WebParts.IPersonalizable.Save(PersonalizationDictionary)
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: TrackViewState()
  nameWithType: WebPartManager.TrackViewState()
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState()
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.Visible
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: Visible
  nameWithType: WebPartManager.Visible
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.Visible
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: WebPartAdded
  nameWithType: WebPartManager.WebPartAdded
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: WebPartAdding
  nameWithType: WebPartManager.WebPartAdding
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding
- uid: System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: WebPartAddingEventHandler
  nameWithType: WebPartAddingEventHandler
  fullName: System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: WebPartClosed
  nameWithType: WebPartManager.WebPartClosed
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: WebPartClosing
  nameWithType: WebPartManager.WebPartClosing
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: WebPartDeleted
  nameWithType: WebPartManager.WebPartDeleted
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: WebPartDeleting
  nameWithType: WebPartManager.WebPartDeleting
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: WebPartMoved
  nameWithType: WebPartManager.WebPartMoved
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: WebPartMoving
  nameWithType: WebPartManager.WebPartMoving
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving
- uid: System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: WebPartMovingEventHandler
  nameWithType: WebPartMovingEventHandler
  fullName: System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.WebParts
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: WebParts
  nameWithType: WebPartManager.WebParts
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.WebParts
- uid: System.Web.UI.WebControls.WebParts.WebPartCollection
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: WebPartCollection
  nameWithType: WebPartCollection
  fullName: System.Web.UI.WebControls.WebParts.WebPartCollection
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: WebPartsConnected
  nameWithType: WebPartManager.WebPartsConnected
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected
- uid: System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: WebPartConnectionsEventHandler
  nameWithType: WebPartConnectionsEventHandler
  fullName: System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: WebPartsConnecting
  nameWithType: WebPartManager.WebPartsConnecting
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting
- uid: System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: WebPartConnectionsCancelEventHandler
  nameWithType: WebPartConnectionsCancelEventHandler
  fullName: System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: WebPartsDisconnected
  nameWithType: WebPartManager.WebPartsDisconnected
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: WebPartsDisconnecting
  nameWithType: WebPartManager.WebPartsDisconnecting
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.Zones
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: Zones
  nameWithType: WebPartManager.Zones
  fullName: System.Web.UI.WebControls.WebParts.WebPartManager.Zones
- uid: System.Web.UI.WebControls.WebParts.WebPartZoneCollection
  parent: System.Web.UI.WebControls.WebParts
  isExternal: false
  name: WebPartZoneCollection
  nameWithType: WebPartZoneCollection
  fullName: System.Web.UI.WebControls.WebParts.WebPartZoneCollection
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.#ctor*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: WebPartManager
  nameWithType: WebPartManager.WebPartManager
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: ActivateConnections
  nameWithType: WebPartManager.ActivateConnections
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: AddWebPart
  nameWithType: WebPartManager.AddWebPart
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: AvailableTransformers
  nameWithType: WebPartManager.AvailableTransformers
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: BeginWebPartConnecting
  nameWithType: WebPartManager.BeginWebPartConnecting
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: BeginWebPartEditing
  nameWithType: WebPartManager.BeginWebPartEditing
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: CanConnectWebParts
  nameWithType: WebPartManager.CanConnectWebParts
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CheckRenderClientScript*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: CheckRenderClientScript
  nameWithType: WebPartManager.CheckRenderClientScript
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: CloseProviderWarning
  nameWithType: WebPartManager.CloseProviderWarning
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: CloseWebPart
  nameWithType: WebPartManager.CloseWebPart
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.Connections*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: Connections
  nameWithType: WebPartManager.Connections
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: ConnectWebParts
  nameWithType: WebPartManager.ConnectWebParts
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.Controls*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: Controls
  nameWithType: WebPartManager.Controls
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: CopyWebPart
  nameWithType: WebPartManager.CopyWebPart
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: CreateAvailableTransformers
  nameWithType: WebPartManager.CreateAvailableTransformers
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CreateControlCollection*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: CreateControlCollection
  nameWithType: WebPartManager.CreateControlCollection
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: CreateDisplayModes
  nameWithType: WebPartManager.CreateDisplayModes
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: CreateDynamicConnectionID
  nameWithType: WebPartManager.CreateDynamicConnectionID
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: CreateDynamicWebPartID
  nameWithType: WebPartManager.CreateDynamicWebPartID
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: CreateErrorWebPart
  nameWithType: WebPartManager.CreateErrorWebPart
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: CreatePersonalization
  nameWithType: WebPartManager.CreatePersonalization
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: CreateWebPart
  nameWithType: WebPartManager.CreateWebPart
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: DeleteWarning
  nameWithType: WebPartManager.DeleteWarning
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: DeleteWebPart
  nameWithType: WebPartManager.DeleteWebPart
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: DisconnectWebPart
  nameWithType: WebPartManager.DisconnectWebPart
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: DisconnectWebParts
  nameWithType: WebPartManager.DisconnectWebParts
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: DisplayMode
  nameWithType: WebPartManager.DisplayMode
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: DisplayModes
  nameWithType: WebPartManager.DisplayModes
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: DynamicConnections
  nameWithType: WebPartManager.DynamicConnections
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: EnableClientScript
  nameWithType: WebPartManager.EnableClientScript
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: EnableTheming
  nameWithType: WebPartManager.EnableTheming
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: EndWebPartConnecting
  nameWithType: WebPartManager.EndWebPartConnecting
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: EndWebPartEditing
  nameWithType: WebPartManager.EndWebPartEditing
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: ExportSensitiveDataWarning
  nameWithType: WebPartManager.ExportSensitiveDataWarning
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: ExportWebPart
  nameWithType: WebPartManager.ExportWebPart
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.Focus*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: Focus
  nameWithType: WebPartManager.Focus
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: GetConsumerConnectionPoints
  nameWithType: WebPartManager.GetConsumerConnectionPoints
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: GetCurrentWebPartManager
  nameWithType: WebPartManager.GetCurrentWebPartManager
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.GetDisplayTitle*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: GetDisplayTitle
  nameWithType: WebPartManager.GetDisplayTitle
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: GetExportUrl
  nameWithType: WebPartManager.GetExportUrl
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: GetGenericWebPart
  nameWithType: WebPartManager.GetGenericWebPart
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: GetProviderConnectionPoints
  nameWithType: WebPartManager.GetProviderConnectionPoints
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: ImportWebPart
  nameWithType: WebPartManager.ImportWebPart
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.Internals*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: Internals
  nameWithType: WebPartManager.Internals
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: IsAuthorized
  nameWithType: WebPartManager.IsAuthorized
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: IsCustomPersonalizationStateDirty
  nameWithType: WebPartManager.IsCustomPersonalizationStateDirty
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: LoadControlState
  nameWithType: WebPartManager.LoadControlState
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: LoadCustomPersonalizationState
  nameWithType: WebPartManager.LoadCustomPersonalizationState
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: MediumPermissionSet
  nameWithType: WebPartManager.MediumPermissionSet
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: MinimalPermissionSet
  nameWithType: WebPartManager.MinimalPermissionSet
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: MoveWebPart
  nameWithType: WebPartManager.MoveWebPart
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnAuthorizeWebPart
  nameWithType: WebPartManager.OnAuthorizeWebPart
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnConnectionsActivated
  nameWithType: WebPartManager.OnConnectionsActivated
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnConnectionsActivating
  nameWithType: WebPartManager.OnConnectionsActivating
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnDisplayModeChanged
  nameWithType: WebPartManager.OnDisplayModeChanged
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnDisplayModeChanging
  nameWithType: WebPartManager.OnDisplayModeChanging
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnInit*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnInit
  nameWithType: WebPartManager.OnInit
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnPreRender
  nameWithType: WebPartManager.OnPreRender
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnSelectedWebPartChanged
  nameWithType: WebPartManager.OnSelectedWebPartChanged
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnSelectedWebPartChanging
  nameWithType: WebPartManager.OnSelectedWebPartChanging
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnUnload*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnUnload
  nameWithType: WebPartManager.OnUnload
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnWebPartAdded
  nameWithType: WebPartManager.OnWebPartAdded
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnWebPartAdding
  nameWithType: WebPartManager.OnWebPartAdding
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnWebPartClosed
  nameWithType: WebPartManager.OnWebPartClosed
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnWebPartClosing
  nameWithType: WebPartManager.OnWebPartClosing
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnWebPartDeleted
  nameWithType: WebPartManager.OnWebPartDeleted
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnWebPartDeleting
  nameWithType: WebPartManager.OnWebPartDeleting
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnWebPartMoved
  nameWithType: WebPartManager.OnWebPartMoved
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnWebPartMoving
  nameWithType: WebPartManager.OnWebPartMoving
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnWebPartsConnected
  nameWithType: WebPartManager.OnWebPartsConnected
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnWebPartsConnecting
  nameWithType: WebPartManager.OnWebPartsConnecting
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnWebPartsDisconnected
  nameWithType: WebPartManager.OnWebPartsDisconnected
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: OnWebPartsDisconnecting
  nameWithType: WebPartManager.OnWebPartsDisconnecting
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.Personalization*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: Personalization
  nameWithType: WebPartManager.Personalization
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.RegisterClientScript*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: RegisterClientScript
  nameWithType: WebPartManager.RegisterClientScript
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.Render*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: Render
  nameWithType: WebPartManager.Render
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: SaveControlState
  nameWithType: WebPartManager.SaveControlState
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: SaveCustomPersonalizationState
  nameWithType: WebPartManager.SaveCustomPersonalizationState
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: SelectedWebPart
  nameWithType: WebPartManager.SelectedWebPart
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: SetPersonalizationDirty
  nameWithType: WebPartManager.SetPersonalizationDirty
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: SetSelectedWebPart
  nameWithType: WebPartManager.SetSelectedWebPart
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.SkinID*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: SkinID
  nameWithType: WebPartManager.SkinID
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: StaticConnections
  nameWithType: WebPartManager.StaticConnections
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: SupportedDisplayModes
  nameWithType: WebPartManager.SupportedDisplayModes
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty
  nameWithType: WebPartManager.System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: System.Web.UI.WebControls.WebParts.IPersonalizable.Load
  nameWithType: WebPartManager.System.Web.UI.WebControls.WebParts.IPersonalizable.Load
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: System.Web.UI.WebControls.WebParts.IPersonalizable.Save
  nameWithType: WebPartManager.System.Web.UI.WebControls.WebParts.IPersonalizable.Save
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: TrackViewState
  nameWithType: WebPartManager.TrackViewState
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.Visible*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: Visible
  nameWithType: WebPartManager.Visible
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.WebParts*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: WebParts
  nameWithType: WebPartManager.WebParts
- uid: System.Web.UI.WebControls.WebParts.WebPartManager.Zones*
  parent: System.Web.UI.WebControls.WebParts.WebPartManager
  isExternal: false
  name: Zones
  nameWithType: WebPartManager.Zones
