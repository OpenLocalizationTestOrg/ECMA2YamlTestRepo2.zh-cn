### YamlMime:ManagedReference
items:
- uid: System.Collections.Hashtable
  id: Hashtable
  children:
  - System.Collections.Hashtable.#ctor
  - System.Collections.Hashtable.#ctor(System.Collections.IDictionary)
  - System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)
  - System.Collections.Hashtable.#ctor(System.Int32)
  - System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)
  - System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)
  - System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)
  - System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)
  - System.Collections.Hashtable.#ctor(System.Int32,System.Single)
  - System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  - System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)
  - System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  - System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)
  - System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  - System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  - System.Collections.Hashtable.Add(System.Object,System.Object)
  - System.Collections.Hashtable.Clear
  - System.Collections.Hashtable.Clone
  - System.Collections.Hashtable.comparer
  - System.Collections.Hashtable.Contains(System.Object)
  - System.Collections.Hashtable.ContainsKey(System.Object)
  - System.Collections.Hashtable.ContainsValue(System.Object)
  - System.Collections.Hashtable.CopyTo(System.Array,System.Int32)
  - System.Collections.Hashtable.Count
  - System.Collections.Hashtable.EqualityComparer
  - System.Collections.Hashtable.GetEnumerator
  - System.Collections.Hashtable.GetHash(System.Object)
  - System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Collections.Hashtable.hcp
  - System.Collections.Hashtable.IsFixedSize
  - System.Collections.Hashtable.IsReadOnly
  - System.Collections.Hashtable.IsSynchronized
  - System.Collections.Hashtable.Item(System.Object)
  - System.Collections.Hashtable.KeyEquals(System.Object,System.Object)
  - System.Collections.Hashtable.Keys
  - System.Collections.Hashtable.OnDeserialization(System.Object)
  - System.Collections.Hashtable.Remove(System.Object)
  - System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)
  - System.Collections.Hashtable.SyncRoot
  - System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator
  - System.Collections.Hashtable.Values
  langs:
  - csharp
  name: Hashtable
  nameWithType: Hashtable
  fullName: System.Collections.Hashtable
  type: Class
  summary: "表示根据键的哈希代码的组织键/值对的集合。       若要浏览此类型的.NET Framework 源代码，请参阅[引用源](http://referencesource.microsoft.com/#mscorlib/system/collections/hashtable.cs#10fefb6e0ae510dd)。"
  remarks: "> [!NOTE]1> 要查看此类型的.NET Framework 源代码，请参阅[引用源](http://referencesource.microsoft.com/#mscorlib/system/collections/hashtable.cs#10fefb6e0ae510dd)。 你可以浏览源代码联机，请下载离线查看的引用并在调试; 过程中逐步执行源 （包括修补程序和更新）请参阅[说明](http://referencesource.microsoft.com/)。       每个元素是存储在一个键/值对<xref:System.Collections.DictionaryEntry>对象。</xref:System.Collections.DictionaryEntry> 密钥不能为`null`，但可以是一个值。       用作键，即可通过哈希表需重写对象<xref:System.Object.GetHashCode%2A?displayProperty=fullName>方法 (或<xref:System.Collections.IHashCodeProvider>接口) 和<xref:System.Object.Equals%2A?displayProperty=fullName>方法 (或<xref:System.Collections.IComparer>接口)。</xref:System.Collections.IComparer> </xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Collections.IHashCodeProvider> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> 方法和接口的实现必须处理区分大小写相同的方式;否则，哈希表可能会出现错误的行为。 例如，在创建哈希表时，你必须使用<xref:System.Collections.CaseInsensitiveHashCodeProvider>类 (或任何不区分大小写<xref:System.Collections.IHashCodeProvider>实现) 使用<xref:System.Collections.CaseInsensitiveComparer>类 (或任何不区分大小写<xref:System.Collections.IComparer>实现)。</xref:System.Collections.IComparer> </xref:System.Collections.CaseInsensitiveComparer> </xref:System.Collections.IHashCodeProvider> </xref:System.Collections.CaseInsensitiveHashCodeProvider>       此外，这些方法必须生成相同的结果调用使用相同的参数，而哈希表中存在的键时。 一种替代方法是使用的哈希表构造函数<xref:System.Collections.IEqualityComparer>参数。</xref:System.Collections.IEqualityComparer> 如果键相等性只需引用相等性的继承的实现<xref:System.Object.GetHashCode%2A?displayProperty=fullName>和<xref:System.Object.Equals%2A?displayProperty=fullName>便已足够。</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName>       密钥对象必须是不可变，只要它们使用的键的哈希表。       如果将元素添加到哈希表，该元素放入存储桶基于键的哈希代码。 密钥的后续查找使用密钥的哈希代码要搜索中只有一个特定的存储桶，这将大大减少查找元素所需的键比较的次数。       哈希表已加载因子确定元素与存储桶的最大比率。 较小负载因素会导致更快地平均查找时间，但代价是增加的内存消耗。 1.0 默认负载因子通常提供速度和大小之间的最佳平衡。 创建哈希表时，也可以指定不同的负载因素。       当元素添加到哈希表时，会增加哈希表的实际加载因子。 当实际负载因子达到指定的加载因子时，哈希表中的存储桶的数量自动增加到大于两次哈希表存储桶的当前数量最小质数。       哈希表中的每个密钥对象必须提供其自己的哈希函数，可通过调用<xref:System.Collections.Hashtable.GetHash%2A>.</xref:System.Collections.Hashtable.GetHash%2A>访问 但是，任何对象实现<xref:System.Collections.IHashCodeProvider>可以传递哈希表构造函数，并且该哈希函数用于表中的所有对象。</xref:System.Collections.IHashCodeProvider>       哈希表容量是哈希表可以容纳的元素数目。 当元素添加到哈希表时，自动增加容量通过重新分配所需的方式。       对于非常大的哈希表对象，你可以通过设置增加到 20 亿元素在 64 位系统上的最大容量`enabled`到的配置元素的属性`true`在运行时环境中。       `foreach` C# 语言的语句 (`For Each`在 Visual Basic 中) 返回集合中的元素的类型的对象。 由于哈希表的每个元素是键/值对，元素类型不是键的类型或值的类型。 相反，元素类型是<xref:System.Collections.DictionaryEntry>.</xref:System.Collections.DictionaryEntry> 例如︰ [!code-cpp [System.Collections.Hashtable_ClassExample#01](~/add/codesnippet/cpp/t-system.collections.has_1.cpp)][!code-cs[System.Collections.Hashtable_ClassExample#01](~/add/codesnippet/csharp/t-system.collections.has_1.cs)][!code-vb[System.Collections.Hashtable_ClassExample#01](~/add/codesnippet/visualbasic/t-system.collections.has_1.vb) ] `foreach`语句是枚举数，仅允许从，不写入集合读取周围的包装器。           由于序列化和反序列化枚举器，哈希表可以会变得重新排序的元素，不能继续而不调用枚举<xref:System.Collections.IEnumerator.Reset%2A>方法。</xref:System.Collections.IEnumerator.Reset%2A>      1> [!NOTE]&1;> 由于可以继承密钥并且不能更改其行为，使用比较可保证其绝对唯一性<xref:System.Type.Equals%2A>方法。</xref:System.Type.Equals%2A>"
  example:
  - "The following example shows how to create, initialize and perform various functions to a Hashtable and how to print out its keys and values.  \n  \n [!code-cpp[System.Collections.Hashtable_ClassExample#00](~/add/codesnippet/cpp/t-system.collections.has_2.cpp)]\n [!code-cs[System.Collections.Hashtable_ClassExample#00](~/add/codesnippet/csharp/t-system.collections.has_2.cs)]\n [!code-vb[System.Collections.Hashtable_ClassExample#00](~/add/codesnippet/visualbasic/t-system.collections.has_2.vb)]"
  syntax:
    content: >-
      [System.Diagnostics.DebuggerDisplay("Count = {Count}")]

      [System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Hashtable/HashtableDebugView))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public class Hashtable : ICloneable, System.Collections.IDictionary, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable
  inheritance:
  - System.Object
  implements:
  - System.Collections.IDictionary
  - System.ICloneable
  - System.Runtime.Serialization.IDeserializationCallback
  - System.Runtime.Serialization.ISerializable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor
  id: '#ctor'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable()
  nameWithType: Hashtable.Hashtable()
  fullName: System.Collections.Hashtable.Hashtable()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化一个新的空实例<xref href=&quot;System.Collections.Hashtable&quot;></xref>类使用默认的初始容量，加载因子、 哈希代码提供程序和比较器。"
  remarks: "哈希表的容量用于计算哈希表存储桶基于负载系数的最佳数量。 自动增加容量所需的方式。       加载因子是元素与存储桶的最大比率。 较小的加载因子意味着更快的查找，但代价是增加的内存消耗。       当实际负载因子达到指定的加载因子时，存储桶的数量自动增加到大于两次存储桶的当前数量最小质数。       哈希代码提供程序分配中的键的哈希代码<xref:System.Collections.Hashtable>对象。</xref:System.Collections.Hashtable> 默认哈希代码提供程序是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>密钥的实现       比较器确定两个键是否相等。 中的所有键<xref:System.Collections.Hashtable>必须是唯一的。</xref:System.Collections.Hashtable> 默认比较器是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>密钥的实现       此构造函数是 o （1） 操作。"
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctor#1](~/add/codesnippet/cpp/m-system.collections.has_4_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctor#1](~/add/codesnippet/csharp/m-system.collections.has_4_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctor#1](~/add/codesnippet/visualbasic/m-system.collections.has_4_1.vb)]"
  syntax:
    content: public Hashtable ();
    parameters: []
  overload: System.Collections.Hashtable.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary)
  id: '#ctor(System.Collections.IDictionary)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IDictionary)
  nameWithType: Hashtable.Hashtable(IDictionary)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化的新实例<xref href=&quot;System.Collections.Hashtable&quot;></xref>通过将指定的字典中的元素复制到新的类<xref href=&quot;System.Collections.Hashtable&quot;></xref>对象。 新<xref href=&quot;System.Collections.Hashtable&quot;></xref>对象具有初始容量与复制的元素数相等，并使用默认负载因子，哈希代码提供程序和比较器。"
  remarks: "初始容量设置为源字典中的元素数。 容量将自动根据需要增加根据负载因子。       加载因子是元素与存储桶的最大比率。 较小的加载因子意味着更快的查找，但代价是增加的内存消耗。       当实际负载因子达到指定的加载因子时，存储桶的数量自动增加到大于两次存储桶的当前数量最小质数。       哈希代码提供程序分配中的键的哈希代码<xref:System.Collections.Hashtable>对象。</xref:System.Collections.Hashtable> 默认哈希代码提供程序是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>密钥的实现       比较器确定两个键是否相等。 中的所有键<xref:System.Collections.Hashtable>必须是唯一的。</xref:System.Collections.Hashtable> 默认比较器是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>密钥的实现       新元素<xref:System.Collections.Hashtable>枚举数循环访问的相同顺序排序<xref:System.Collections.IDictionary>对象。</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable>       此构造函数是 O (`n`) 操作，其中`n`是中的元素数`d`参数。"
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/cpp/m-system.collections.has_1_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/csharp/m-system.collections.has_1_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/visualbasic/m-system.collections.has_1_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IDictionary d);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>要复制到新对象<xref href=&quot;System.Collections.Hashtable&quot;></xref>对象。</xref:System.Collections.IDictionary>"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)
  id: '#ctor(System.Collections.IEqualityComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IEqualityComparer)
  nameWithType: Hashtable.Hashtable(IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(IEqualityComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化一个新的空实例<xref href=&quot;System.Collections.Hashtable&quot;></xref>类使用默认的初始容量并加载因子，以及指定<xref:System.Collections.IEqualityComparer>对象。</xref:System.Collections.IEqualityComparer>"
  remarks: "哈希表的容量用于计算哈希表存储桶基于负载系数的最佳数量。 自动增加容量所需的方式。       加载因子是元素与存储桶的最大比率。 较小的加载因子意味着更快的查找，但代价是增加的内存消耗。       当实际负载因子达到指定的加载因子时，存储桶的数量自动增加到大于两次存储桶的当前数量最小质数。       <xref:System.Collections.IEqualityComparer>对象包括哈希代码提供程序和比较器。</xref:System.Collections.IEqualityComparer> 如果<xref:System.Collections.IEqualityComparer>中使用<xref:System.Collections.Hashtable>构造函数、 中用作键的对象<xref:System.Collections.Hashtable>对象无需重写<xref:System.Object.GetHashCode%2A?displayProperty=fullName>和<xref:System.Object.Equals%2A?displayProperty=fullName>方法。</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> </xref:System.Collections.IEqualityComparer>       哈希代码提供程序分配<xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable>中的键的哈希代码 默认哈希代码提供程序是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>密钥的实现       比较器确定两个键是否相等。 中的所有键<xref:System.Collections.Hashtable>必须是唯一的。</xref:System.Collections.Hashtable> 默认比较器是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>密钥的实现       <xref:System.Collections.IEqualityComparer>可实现进行查找使用不区分大小写的字符串等方案。</xref:System.Collections.IEqualityComparer>       此构造函数是 o （1） 操作。"
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctor#1](~/add/codesnippet/cpp/m-system.collections.has_5_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctor#1](~/add/codesnippet/csharp/m-system.collections.has_5_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctor#1](~/add/codesnippet/visualbasic/m-system.collections.has_5_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IEqualityComparer equalityComparer);
    parameters:
    - id: equalityComparer
      type: System.Collections.IEqualityComparer
      description: "<xref:System.Collections.IEqualityComparer>对象，用于定义的哈希代码提供程序和比较器用于<xref href=&quot;System.Collections.Hashtable&quot;></xref>对象。</xref:System.Collections.IEqualityComparer>       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>若要使用的默认哈希代码提供程序和默认比较器。 默认哈希代码提供程序是每个键实现&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;和默认比较器是每个键实现&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;。"
  overload: System.Collections.Hashtable.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(Int32)
  nameWithType: Hashtable.Hashtable(Int32)
  fullName: System.Collections.Hashtable.Hashtable(Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化一个新的空实例<xref href=&quot;System.Collections.Hashtable&quot;></xref>类使用指定的初始容量，以及默认负载因子，哈希代码提供程序和比较器。"
  remarks: "指定的初始容量，则无需执行大量的大小将元素添加到时调整操作<xref:System.Collections.Hashtable>对象。</xref:System.Collections.Hashtable> 容量将自动根据需要增加根据负载因子。       加载因子是元素与存储桶的最大比率。 较小的加载因子意味着更快的查找，但代价是增加的内存消耗。       当实际负载因子达到指定的加载因子时，存储桶的数量自动增加到大于两次存储桶的当前数量最小质数。       哈希代码提供程序分配<xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable>中的键的哈希代码 默认哈希代码提供程序是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>密钥的实现       比较器确定两个键是否相等。 中的所有键<xref:System.Collections.Hashtable>必须是唯一的。</xref:System.Collections.Hashtable> 默认比较器是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>密钥的实现       此构造函数是 O (`n`) 操作，其中`n`是`capacity`。"
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/cpp/m-system.collections.has_2_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/csharp/m-system.collections.has_2_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/visualbasic/m-system.collections.has_2_1.vb)]"
  syntax:
    content: public Hashtable (int capacity);
    parameters:
    - id: capacity
      type: System.Int32
      description: "元素的近似数目的<xref href=&quot;System.Collections.Hashtable&quot;></xref>最初可以包含对象。"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>小于零。"
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)
  id: '#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IDictionary,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,IEqualityComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化的新实例<xref href=&quot;System.Collections.Hashtable&quot;></xref>通过将指定的字典中的元素复制到新的类<xref href=&quot;System.Collections.Hashtable&quot;></xref>对象。 新<xref href=&quot;System.Collections.Hashtable&quot;></xref>对象复制的元素数量相等的初始容量并使用默认负载因子和指定<xref:System.Collections.IEqualityComparer>对象。</xref:System.Collections.IEqualityComparer>"
  remarks: "初始容量设置为源字典中的元素数。 容量将自动根据需要增加根据负载因子。       加载因子是元素与存储桶的最大比率。 较小的加载因子意味着更快的查找，但代价是增加的内存消耗。       当实际负载因子达到指定的加载因子时，存储桶的数量自动增加到大于两次存储桶的当前数量最小质数。       <xref:System.Collections.IEqualityComparer>对象包括哈希代码提供程序和比较器。</xref:System.Collections.IEqualityComparer> 如果<xref:System.Collections.IEqualityComparer>中使用<xref:System.Collections.Hashtable>构造函数、 中用作键的对象<xref:System.Collections.Hashtable>对象无需重写<xref:System.Object.GetHashCode%2A?displayProperty=fullName>和<xref:System.Object.Equals%2A?displayProperty=fullName>方法。</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> </xref:System.Collections.IEqualityComparer>       哈希代码提供程序分配<xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable>中的键的哈希代码 默认哈希代码提供程序是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>密钥的实现       比较器确定两个键是否相等。 中的所有键<xref:System.Collections.Hashtable>必须是唯一的。</xref:System.Collections.Hashtable> 默认比较器是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>密钥的实现       <xref:System.Collections.IEqualityComparer>可实现进行查找使用不区分大小写的字符串等方案。</xref:System.Collections.IEqualityComparer>       新元素<xref:System.Collections.Hashtable>枚举数循环访问的相同顺序排序<xref:System.Collections.IDictionary>对象。</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable>       此构造函数是 O (`n`) 操作，其中`n`是中的元素数`d`参数。"
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/cpp/81cd87de-02b7-42cc-8fdd-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/csharp/81cd87de-02b7-42cc-8fdd-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/visualbasic/81cd87de-02b7-42cc-8fdd-_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IDictionary d, System.Collections.IEqualityComparer equalityComparer);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>要复制到新对象<xref href=&quot;System.Collections.Hashtable&quot;></xref>对象。</xref:System.Collections.IDictionary>"
    - id: equalityComparer
      type: System.Collections.IEqualityComparer
      description: "<xref:System.Collections.IEqualityComparer>对象，用于定义的哈希代码提供程序和比较器用于<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Collections.IEqualityComparer>       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>若要使用的默认哈希代码提供程序和默认比较器。 默认哈希代码提供程序是每个键实现&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;和默认比较器是每个键实现&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;。"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)
  id: '#ctor(System.Collections.IDictionary,System.Single)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IDictionary,Single)
  nameWithType: Hashtable.Hashtable(IDictionary,Single)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,Single)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化的新实例<xref href=&quot;System.Collections.Hashtable&quot;></xref>通过将指定的字典中的元素复制到新的类<xref href=&quot;System.Collections.Hashtable&quot;></xref>对象。 新<xref href=&quot;System.Collections.Hashtable&quot;></xref>对象具有初始容量与复制的元素数相等，并使用指定的加载因子，以及默认哈希代码提供程序和比较器。"
  remarks: "初始容量设置为源字典中的元素数。 容量将自动根据需要增加根据负载因子。       加载因子是元素与存储桶的最大比率。 较小的加载因子意味着更快的查找，但代价是增加的内存消耗。 加载因子 1.0 是速度和大小之间的最佳平衡。       当实际负载因子达到指定的加载因子时，存储桶的数量自动增加到大于两次存储桶的当前数量最小质数。       哈希代码提供程序分配中的键的哈希代码<xref:System.Collections.Hashtable>对象。</xref:System.Collections.Hashtable> 默认哈希代码提供程序是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>密钥的实现       比较器确定两个键是否相等。 中的所有键<xref:System.Collections.Hashtable>必须是唯一的。</xref:System.Collections.Hashtable> 默认比较器是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>密钥的实现       新元素<xref:System.Collections.Hashtable>枚举数循环访问的相同顺序排序<xref:System.Collections.IDictionary>对象。</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable>       此构造函数是 O (`n`) 操作，其中`n`是中的元素数`d`参数。"
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cs[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/csharp/fb1cfbc8-7454-4619-a6e7-_1.cs)]\n [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/cpp/fb1cfbc8-7454-4619-a6e7-_1.cpp)]\n [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/visualbasic/fb1cfbc8-7454-4619-a6e7-_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IDictionary d, float loadFactor);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>要复制到新对象<xref href=&quot;System.Collections.Hashtable&quot;></xref>对象。</xref:System.Collections.IDictionary>"
    - id: loadFactor
      type: System.Single
      description: "从 0.1 到 1.0，再乘以提供最佳性能的默认值范围内的数字。 结果是元素与存储桶的最大比率。"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>loadFactor</code>小于 0.1。       -或-<code>loadFactor</code>大于 1.0。"
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)
  id: '#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(IHashCodeProvider,IComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化一个新的空实例<xref href=&quot;System.Collections.Hashtable&quot;></xref>类使用默认的初始容量并加载因子，指定的哈希代码提供程序和比较器。"
  remarks: "哈希表的容量用于计算哈希表存储桶基于负载系数的最佳数量。 自动增加容量所需的方式。       加载因子是元素与存储桶的最大比率。 较小的加载因子意味着更快的查找，但代价是增加的内存消耗。       当实际负载因子达到指定的加载因子时，存储桶的数量自动增加到大于两次存储桶的当前数量最小质数。       哈希代码提供程序分配中的键的哈希代码<xref:System.Collections.Hashtable>对象。</xref:System.Collections.Hashtable> 默认哈希代码提供程序是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>密钥的实现       比较器确定两个键是否相等。 中的所有键<xref:System.Collections.Hashtable>必须是唯一的。</xref:System.Collections.Hashtable> 默认比较器是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>密钥的实现       自定义的哈希代码提供程序和自定义比较器启用方案，如执行查找使用不区分大小写的字符串。       此构造函数是 o （1） 操作。"
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctor#1](~/add/codesnippet/cpp/1ff65986-0234-4702-94b7-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctor#1](~/add/codesnippet/csharp/1ff65986-0234-4702-94b7-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctor#1](~/add/codesnippet/visualbasic/1ff65986-0234-4702-94b7-_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);
    parameters:
    - id: hcp
      type: System.Collections.IHashCodeProvider
      description: "<xref href=&quot;System.Collections.IHashCodeProvider&quot;> </xref>的所有键的对象，提供哈希代码<xref href=&quot;System.Collections.Hashtable&quot;></xref>对象。       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>以使用默认哈希代码提供程序，即每个键实现&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;。"
    - id: comparer
      type: System.Collections.IComparer
      description: "<xref:System.Collections.IComparer>对象可用于确定两个键是否相等。</xref:System.Collections.IComparer>       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>表示使用默认比较器，这是每个键实现&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;。"
  overload: System.Collections.Hashtable.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)
  id: '#ctor(System.Int32,System.Collections.IEqualityComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(Int32,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(Int32,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,IEqualityComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化一个新的空实例<xref href=&quot;System.Collections.Hashtable&quot;></xref>类使用指定的初始容量和<xref:System.Collections.IEqualityComparer>，和默认加载因子。</xref:System.Collections.IEqualityComparer>"
  remarks: "指定的初始容量，则无需执行大量的大小将元素添加到时调整操作<xref:System.Collections.Hashtable>对象。</xref:System.Collections.Hashtable> 容量将自动根据需要增加根据负载因子。       加载因子是元素与存储桶的最大比率。 较小的加载因子意味着更快的查找，但代价是增加的内存消耗。       当实际负载因子达到指定的加载因子时，存储桶的数量自动增加到大于两次存储桶的当前数量最小质数。       <xref:System.Collections.IEqualityComparer>对象包括哈希代码提供程序和比较器。</xref:System.Collections.IEqualityComparer> 如果<xref:System.Collections.IEqualityComparer>中使用<xref:System.Collections.Hashtable>构造函数、 中用作键的对象<xref:System.Collections.Hashtable>无需重写<xref:System.Object.GetHashCode%2A?displayProperty=fullName>和<xref:System.Object.Equals%2A?displayProperty=fullName>方法。</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> </xref:System.Collections.IEqualityComparer>       哈希代码提供程序分配<xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable>中的键的哈希代码 默认哈希代码提供程序是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>密钥的实现       比较器确定两个键是否相等。 中的所有键<xref:System.Collections.Hashtable>必须是唯一的。</xref:System.Collections.Hashtable> 默认比较器是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>密钥的实现       <xref:System.Collections.IEqualityComparer>可实现进行查找使用不区分大小写的字符串等方案。</xref:System.Collections.IEqualityComparer>       此构造函数是 O (`n`) 操作，其中`n`是`capacity`参数。"
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/cpp/5067e9ac-cd98-4da8-9418-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/csharp/5067e9ac-cd98-4da8-9418-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/visualbasic/5067e9ac-cd98-4da8-9418-_1.vb)]"
  syntax:
    content: public Hashtable (int capacity, System.Collections.IEqualityComparer equalityComparer);
    parameters:
    - id: capacity
      type: System.Int32
      description: "元素的近似数目的<xref href=&quot;System.Collections.Hashtable&quot;></xref>最初可以包含对象。"
    - id: equalityComparer
      type: System.Collections.IEqualityComparer
      description: "<xref:System.Collections.IEqualityComparer>对象，用于定义的哈希代码提供程序和比较器用于<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Collections.IEqualityComparer>       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>若要使用的默认哈希代码提供程序和默认比较器。 默认哈希代码提供程序是每个键实现&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;和默认比较器是每个键实现&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;。"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>小于零。"
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Single)
  id: '#ctor(System.Int32,System.Single)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(Int32,Single)
  nameWithType: Hashtable.Hashtable(Int32,Single)
  fullName: System.Collections.Hashtable.Hashtable(Int32,Single)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化一个新的空实例<xref href=&quot;System.Collections.Hashtable&quot;></xref>类使用指定的初始容量并加载因子的默认哈希代码提供程序和比较器。"
  remarks: "指定的初始容量，则无需执行大量的大小将元素添加到时调整操作<xref:System.Collections.Hashtable>对象。</xref:System.Collections.Hashtable> 容量将自动根据需要增加根据负载因子。       加载因子是元素与存储桶的最大比率。 较小的加载因子意味着更快的查找，但代价是增加的内存消耗。 加载因子 1.0 是速度和大小之间的最佳平衡。       当实际负载因子达到指定的加载因子时，存储桶的数量自动增加到大于两次存储桶的当前数量最小质数。       哈希代码提供程序分配<xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable>中的键的哈希代码 默认哈希代码提供程序是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>密钥的实现       比较器确定两个键是否相等。 中的所有键<xref:System.Collections.Hashtable>必须是唯一的。</xref:System.Collections.Hashtable> 默认比较器是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>密钥的实现       此构造函数是 O (`n`) 操作，其中`n`是`capacity`参数。"
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/cpp/m-system.collections.has_8_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/csharp/m-system.collections.has_8_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/visualbasic/m-system.collections.has_8_1.vb)]"
  syntax:
    content: public Hashtable (int capacity, float loadFactor);
    parameters:
    - id: capacity
      type: System.Int32
      description: "元素的近似数目的<xref href=&quot;System.Collections.Hashtable&quot;></xref>最初可以包含对象。"
    - id: loadFactor
      type: System.Single
      description: "从 0.1 到 1.0，再乘以提供最佳性能的默认值范围内的数字。 结果是元素与存储桶的最大比率。"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>小于零。       -或-<code>loadFactor</code>小于 0.1。       -或-<code>loadFactor</code>大于 1.0。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>capacity</code>导致溢出。"
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: '#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(SerializationInfo,StreamingContext)
  nameWithType: Hashtable.Hashtable(SerializationInfo,StreamingContext)
  fullName: System.Collections.Hashtable.Hashtable(SerializationInfo,StreamingContext)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化一个新的空实例<xref href=&quot;System.Collections.Hashtable&quot;></xref>是可序列化使用指定的类<xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;></xref>和<xref:System.Runtime.Serialization.StreamingContext>对象。</xref:System.Runtime.Serialization.StreamingContext>"
  remarks: "哈希表的容量用于计算哈希表存储桶基于负载系数的最佳数量。 自动增加容量所需的方式。       加载因子是元素与存储桶的最大比率。 较小的加载因子意味着更快的查找，但代价是增加的内存消耗。       当实际负载因子达到指定的加载因子时，存储桶的数量自动增加到大于两次存储桶的当前数量最小质数。       哈希代码提供程序分配中的键的哈希代码<xref:System.Collections.Hashtable>对象。</xref:System.Collections.Hashtable> 默认哈希代码提供程序是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>密钥的实现       比较器确定两个键是否相等。 中的所有键<xref:System.Collections.Hashtable>必须是唯一的。</xref:System.Collections.Hashtable> 默认比较器是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>密钥的实现       此构造函数是 O (`n`) 操作，其中`n`为<xref:System.Collections.Hashtable.Count%2A>。</xref:System.Collections.Hashtable.Count%2A>       因为序列化和反序列化的枚举数<xref:System.Collections.Hashtable>可能会导致变得重新排序的元素，不能继续而不调用枚举<xref:System.Collections.IEnumerator.Reset%2A>方法。</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.Hashtable>"
  syntax:
    content: protected Hashtable (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "A <xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref>对象，其中包含序列化所需的信息<xref href=&quot;System.Collections.Hashtable&quot;></xref>对象。"
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "A<xref:System.Runtime.Serialization.StreamingContext>对象，其中包含的源和目标与关联的序列化流<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Runtime.Serialization.StreamingContext>"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>info</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  id: '#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IDictionary,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,IHashCodeProvider,IComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化的新实例<xref href=&quot;System.Collections.Hashtable&quot;></xref>通过将指定的字典中的元素复制到新的类<xref href=&quot;System.Collections.Hashtable&quot;></xref>对象。 新<xref href=&quot;System.Collections.Hashtable&quot;></xref>对象具有初始容量与复制的元素数相等，并使用默认的加载因子，以及指定的哈希代码提供程序和比较器。 此 API 已废弃不用。 一种替代方法，请参阅&lt;xref:System.Collections.Hashtable.%23ctor%2A&gt;。"
  remarks: "初始容量设置为源字典中的元素数。 容量将自动根据需要增加根据负载因子。       加载因子是元素与存储桶的最大比率。 较小的加载因子意味着更快的查找，但代价是增加的内存消耗。       当实际负载因子达到指定的加载因子时，存储桶的数量自动增加到大于两次存储桶的当前数量最小质数。       哈希代码提供程序分配中的键的哈希代码<xref:System.Collections.Hashtable>对象。</xref:System.Collections.Hashtable> 默认哈希代码提供程序是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>密钥的实现       比较器确定两个键是否相等。 中的所有键<xref:System.Collections.Hashtable>必须是唯一的。</xref:System.Collections.Hashtable> 默认比较器是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>密钥的实现       自定义的哈希代码提供程序和自定义比较器启用方案，如执行查找使用不区分大小写的字符串。       新元素<xref:System.Collections.Hashtable>枚举数循环访问的相同顺序排序<xref:System.Collections.IDictionary>对象。</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable>       此构造函数是 O (`n`) 操作，其中`n`是中的元素数`d`参数。"
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/cpp/9a30e378-7c34-4854-b12f-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/csharp/9a30e378-7c34-4854-b12f-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/visualbasic/9a30e378-7c34-4854-b12f-_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IDictionary d, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>要复制到新对象<xref href=&quot;System.Collections.Hashtable&quot;></xref>对象。</xref:System.Collections.IDictionary>"
    - id: hcp
      type: System.Collections.IHashCodeProvider
      description: "<xref href=&quot;System.Collections.IHashCodeProvider&quot;> </xref>的所有键的对象，提供哈希代码<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>以使用默认哈希代码提供程序，即每个键实现&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;。"
    - id: comparer
      type: System.Collections.IComparer
      description: "<xref:System.Collections.IComparer>对象可用于确定两个键是否相等。</xref:System.Collections.IComparer>       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>表示使用默认比较器，这是每个键实现&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;。"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)
  id: '#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IDictionary,Single,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,Single,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,Single,IEqualityComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化的新实例<xref href=&quot;System.Collections.Hashtable&quot;></xref>通过将指定的字典中的元素复制到新的类<xref href=&quot;System.Collections.Hashtable&quot;></xref>对象。 新<xref href=&quot;System.Collections.Hashtable&quot;></xref>对象具有初始容量与复制的元素数相等，并使用指定的负载因子和<xref:System.Collections.IEqualityComparer>对象。</xref:System.Collections.IEqualityComparer>"
  remarks: "初始容量设置为源字典中的元素数。 容量将自动根据需要增加根据负载因子。       加载因子是元素与存储桶的最大比率。 较小的加载因子意味着更快的查找，但代价是增加的内存消耗。 加载因子 1.0 是速度和大小之间的最佳平衡。       当实际负载因子达到指定的加载因子时，存储桶的数量自动增加到大于两次存储桶的当前数量最小质数。       <xref:System.Collections.IEqualityComparer>对象包括哈希代码提供程序和比较器。</xref:System.Collections.IEqualityComparer> 如果<xref:System.Collections.IEqualityComparer>中使用<xref:System.Collections.Hashtable>构造函数、 中用作键的对象<xref:System.Collections.Hashtable>对象无需重写<xref:System.Object.GetHashCode%2A?displayProperty=fullName>和<xref:System.Object.Equals%2A?displayProperty=fullName>方法。</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> </xref:System.Collections.IEqualityComparer>       哈希代码提供程序分配<xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable>中的键的哈希代码 默认哈希代码提供程序是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>密钥的实现       比较器确定两个键是否相等。 中的所有键<xref:System.Collections.Hashtable>必须是唯一的。</xref:System.Collections.Hashtable> 默认比较器是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>密钥的实现       <xref:System.Collections.IEqualityComparer>可实现进行查找使用不区分大小写的字符串等方案。</xref:System.Collections.IEqualityComparer>       新元素<xref:System.Collections.Hashtable>枚举数循环访问的相同顺序排序<xref:System.Collections.IDictionary>对象。</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable>       此构造函数是 O (`n`) 操作，其中`n`是中的元素数`d`参数。"
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cs[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/csharp/a92f83be-9de4-470a-8cbb-_1.cs)]\n [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/cpp/a92f83be-9de4-470a-8cbb-_1.cpp)]\n [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/visualbasic/a92f83be-9de4-470a-8cbb-_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IDictionary d, float loadFactor, System.Collections.IEqualityComparer equalityComparer);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>要复制到新对象<xref href=&quot;System.Collections.Hashtable&quot;></xref>对象。</xref:System.Collections.IDictionary>"
    - id: loadFactor
      type: System.Single
      description: "从 0.1 到 1.0，再乘以提供最佳性能的默认值范围内的数字。 结果是元素与存储桶的最大比率。"
    - id: equalityComparer
      type: System.Collections.IEqualityComparer
      description: "<xref:System.Collections.IEqualityComparer>对象，用于定义的哈希代码提供程序和比较器用于<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Collections.IEqualityComparer>       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>若要使用的默认哈希代码提供程序和默认比较器。 默认哈希代码提供程序是每个键实现&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;和默认比较器是每个键实现&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;。"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>loadFactor</code>小于 0.1。       -或-<code>loadFactor</code>大于 1.0。"
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  id: '#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(Int32,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(Int32,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,IHashCodeProvider,IComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化一个新的空实例<xref href=&quot;System.Collections.Hashtable&quot;></xref>类使用指定的初始容量、 哈希代码提供程序、 比较器，和默认加载因子。"
  remarks: "指定的初始容量，则无需执行大量的大小将元素添加到时调整操作<xref:System.Collections.Hashtable>对象。</xref:System.Collections.Hashtable> 容量将自动根据需要增加根据负载因子。       加载因子是元素与存储桶的最大比率。 较小的加载因子意味着更快的查找，但代价是增加的内存消耗。       当实际负载因子达到指定的加载因子时，存储桶的数量自动增加到大于两次存储桶的当前数量最小质数。       哈希代码提供程序分配<xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable>中的键的哈希代码 默认哈希代码提供程序是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>密钥的实现       比较器确定两个键是否相等。 中的所有键<xref:System.Collections.Hashtable>必须是唯一的。</xref:System.Collections.Hashtable> 默认比较器是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>密钥的实现       自定义的哈希代码提供程序和自定义比较器启用方案，如执行查找使用不区分大小写的字符串。       此构造函数是 O (`n`) 操作，其中`n`是`capacity`参数。"
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/cpp/2154dba0-3cc6-41f7-aa9b-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/csharp/2154dba0-3cc6-41f7-aa9b-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/visualbasic/2154dba0-3cc6-41f7-aa9b-_1.vb)]"
  syntax:
    content: public Hashtable (int capacity, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);
    parameters:
    - id: capacity
      type: System.Int32
      description: "元素的近似数目的<xref href=&quot;System.Collections.Hashtable&quot;></xref>最初可以包含对象。"
    - id: hcp
      type: System.Collections.IHashCodeProvider
      description: "<xref href=&quot;System.Collections.IHashCodeProvider&quot;> </xref>的所有键的对象，提供哈希代码<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>以使用默认哈希代码提供程序，即每个键实现&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;。"
    - id: comparer
      type: System.Collections.IComparer
      description: "<xref:System.Collections.IComparer>对象可用于确定两个键是否相等。</xref:System.Collections.IComparer>       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>表示使用默认比较器，这是每个键实现&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;。"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>小于零。"
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)
  id: '#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(Int32,Single,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(Int32,Single,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,Single,IEqualityComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化一个新的空实例<xref href=&quot;System.Collections.Hashtable&quot;></xref>类使用指定的初始容量，加载因子和<xref:System.Collections.IEqualityComparer>对象。</xref:System.Collections.IEqualityComparer>"
  remarks: "指定的初始容量，则无需执行大量的大小将元素添加到时调整操作<xref:System.Collections.Hashtable>对象。</xref:System.Collections.Hashtable> 容量将自动根据需要增加根据负载因子。       加载因子是元素与存储桶的最大比率。 较小的加载因子意味着更快的查找，但代价是增加的内存消耗。 加载因子 1.0 是速度和大小之间的最佳平衡。       当实际负载因子达到指定的加载因子时，存储桶的数量自动增加到大于两次存储桶的当前数量最小质数。       <xref:System.Collections.IEqualityComparer>对象包括哈希代码提供程序和比较器。</xref:System.Collections.IEqualityComparer> 如果<xref:System.Collections.IEqualityComparer>中使用<xref:System.Collections.Hashtable>构造函数、 中用作键的对象<xref:System.Collections.Hashtable>无需重写<xref:System.Object.GetHashCode%2A?displayProperty=fullName>和<xref:System.Object.Equals%2A?displayProperty=fullName>方法。</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> </xref:System.Collections.IEqualityComparer>       哈希代码提供程序分配<xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable>中的键的哈希代码 默认哈希代码提供程序是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>密钥的实现       比较器确定两个键是否相等。 中的所有键<xref:System.Collections.Hashtable>必须是唯一的。</xref:System.Collections.Hashtable> 默认比较器是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>密钥的实现       <xref:System.Collections.IEqualityComparer>可实现进行查找使用不区分大小写的字符串等方案。</xref:System.Collections.IEqualityComparer>       此构造函数是 O (`n`) 操作，其中`n`是`capacity`参数。"
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/cpp/30b60c47-7bce-44a2-8d17-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/csharp/30b60c47-7bce-44a2-8d17-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/visualbasic/30b60c47-7bce-44a2-8d17-_1.vb)]"
  syntax:
    content: public Hashtable (int capacity, float loadFactor, System.Collections.IEqualityComparer equalityComparer);
    parameters:
    - id: capacity
      type: System.Int32
      description: "元素的近似数目的<xref href=&quot;System.Collections.Hashtable&quot;></xref>最初可以包含对象。"
    - id: loadFactor
      type: System.Single
      description: "从 0.1 到 1.0，再乘以提供最佳性能的默认值范围内的数字。 结果是元素与存储桶的最大比率。"
    - id: equalityComparer
      type: System.Collections.IEqualityComparer
      description: "<xref:System.Collections.IEqualityComparer>对象，用于定义的哈希代码提供程序和比较器用于<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Collections.IEqualityComparer>       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>若要使用的默认哈希代码提供程序和默认比较器。 默认哈希代码提供程序是每个键实现&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;和默认比较器是每个键实现&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;。"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>小于零。       -或-<code>loadFactor</code>小于 0.1。       -或-<code>loadFactor</code>大于 1.0。"
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  id: '#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IDictionary,Single,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,Single,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,Single,IHashCodeProvider,IComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化的新实例<xref href=&quot;System.Collections.Hashtable&quot;></xref>通过将指定的字典中的元素复制到新的类<xref href=&quot;System.Collections.Hashtable&quot;></xref>对象。 新<xref href=&quot;System.Collections.Hashtable&quot;></xref>对象具有初始容量与复制的元素数相等，并使用指定的加载因子，哈希代码提供程序和比较器。"
  remarks: "初始容量设置为源字典中的元素数。 容量将自动根据需要增加根据负载因子。       加载因子是元素与存储桶的最大比率。 较小的加载因子意味着更快的查找，但代价是增加的内存消耗。 加载因子 1.0 是速度和大小之间的最佳平衡。       当实际负载因子达到指定的加载因子时，存储桶的数量自动增加到大于两次存储桶的当前数量最小质数。       哈希代码提供程序分配中的键的哈希代码<xref:System.Collections.Hashtable>对象。</xref:System.Collections.Hashtable> 默认哈希代码提供程序是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>密钥的实现       比较器确定两个键是否相等。 中的所有键<xref:System.Collections.Hashtable>必须是唯一的。</xref:System.Collections.Hashtable> 默认比较器是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>密钥的实现       自定义的哈希代码提供程序和自定义比较器启用方案，如执行查找使用不区分大小写的字符串。       新元素<xref:System.Collections.Hashtable>枚举数循环访问的相同顺序排序<xref:System.Collections.IDictionary>对象。</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable>       此构造函数是 O (`n`) 操作，其中`n`是中的元素数`d`参数。"
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cs[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/csharp/c67b166f-bc6a-49e5-9bd7-_1.cs)]\n [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/cpp/c67b166f-bc6a-49e5-9bd7-_1.cpp)]\n [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/visualbasic/c67b166f-bc6a-49e5-9bd7-_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IDictionary d, float loadFactor, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>要复制到新对象<xref href=&quot;System.Collections.Hashtable&quot;></xref>对象。</xref:System.Collections.IDictionary>"
    - id: loadFactor
      type: System.Single
      description: "从 0.1 到 1.0，再乘以提供最佳性能的默认值范围内的数字。 结果是元素与存储桶的最大比率。"
    - id: hcp
      type: System.Collections.IHashCodeProvider
      description: "<xref href=&quot;System.Collections.IHashCodeProvider&quot;> </xref>的所有键的对象，提供哈希代码<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>以使用默认哈希代码提供程序，即每个键实现&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;。"
    - id: comparer
      type: System.Collections.IComparer
      description: "<xref:System.Collections.IComparer>对象可用于确定两个键是否相等。</xref:System.Collections.IComparer>       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>表示使用默认比较器，这是每个键实现&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;。"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>loadFactor</code>小于 0.1。       -或-<code>loadFactor</code>大于 1.0。"
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  id: '#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(Int32,Single,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(Int32,Single,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,Single,IHashCodeProvider,IComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化一个新的空实例<xref href=&quot;System.Collections.Hashtable&quot;></xref>类使用指定的初始容量，加载因子、 哈希代码提供程序和比较器。"
  remarks: "指定的初始容量，则无需执行大量的大小将元素添加到时调整操作<xref:System.Collections.Hashtable>对象。</xref:System.Collections.Hashtable> 容量将自动根据需要增加根据负载因子。       加载因子是元素与存储桶的最大比率。 较小的加载因子意味着更快的查找，但代价是增加的内存消耗。 加载因子 1.0 是速度和大小之间的最佳平衡。       当实际负载因子达到指定的加载因子时，存储桶的数量自动增加到大于两次存储桶的当前数量最小质数。       哈希代码提供程序分配<xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable>中的键的哈希代码 默认哈希代码提供程序是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>密钥的实现       比较器确定两个键是否相等。 中的所有键<xref:System.Collections.Hashtable>必须是唯一的。</xref:System.Collections.Hashtable> 默认比较器是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>密钥的实现       自定义的哈希代码提供程序和自定义比较器启用方案，如执行查找使用不区分大小写的字符串。       此构造函数是 O (`n`) 操作，其中`n`是`capacity`参数。"
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/cpp/86ed2545-c9ee-4654-a1a4-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/csharp/86ed2545-c9ee-4654-a1a4-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/visualbasic/86ed2545-c9ee-4654-a1a4-_1.vb)]"
  syntax:
    content: public Hashtable (int capacity, float loadFactor, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);
    parameters:
    - id: capacity
      type: System.Int32
      description: "元素的近似数目的<xref href=&quot;System.Collections.Hashtable&quot;></xref>最初可以包含对象。"
    - id: loadFactor
      type: System.Single
      description: "从 0.1 到 1.0，再乘以提供最佳性能的默认值范围内的数字。 结果是元素与存储桶的最大比率。"
    - id: hcp
      type: System.Collections.IHashCodeProvider
      description: "<xref href=&quot;System.Collections.IHashCodeProvider&quot;> </xref>的所有键的对象，提供哈希代码<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>以使用默认哈希代码提供程序，即每个键实现&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;。"
    - id: comparer
      type: System.Collections.IComparer
      description: "<xref:System.Collections.IComparer>对象可用于确定两个键是否相等。</xref:System.Collections.IComparer>       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>表示使用默认比较器，这是每个键实现&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;。"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>小于零。       -或-<code>loadFactor</code>小于 0.1。       -或-<code>loadFactor</code>大于 1.0。"
  platform:
  - net462
- uid: System.Collections.Hashtable.Add(System.Object,System.Object)
  id: Add(System.Object,System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Add(Object,Object)
  nameWithType: Hashtable.Add(Object,Object)
  fullName: System.Collections.Hashtable.Add(Object,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "添加一个带有指定的键和值转换为元素<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
  remarks: "密钥不能为`null`，但可以是一个值。       具有其状态和其哈希代码值之间没有关联的对象通常不应作为键。 例如，字符串对象作为键要优于使用 StringBuilder 对象。       你还可以使用<xref:System.Collections.Hashtable.Item%2A>中不存在要添加新元素的键的值设置属性<xref:System.Collections.Hashtable>; 例如， `myCollection[&quot;myNonexistentKey&quot;] = myValue`。</xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable.Item%2A> 但是，如果指定的键已存在于<xref:System.Collections.Hashtable>，则设置<xref:System.Collections.Hashtable.Item%2A>属性将会覆盖旧值。</xref:System.Collections.Hashtable.Item%2A> </xref:System.Collections.Hashtable> 与此相反，Add 方法不会修改现有元素。       如果<xref:System.Collections.Hashtable.Count%2A>小于的容量<xref:System.Collections.Hashtable>，此方法为 o （1） 运算。</xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable.Count%2A> 如果容量需要增加以容纳新元素，此方法会成为 O (`n`) 操作，其中`n`为<xref:System.Collections.Hashtable.Count%2A>。</xref:System.Collections.Hashtable.Count%2A>"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Hashtable>.  \n  \n [!code-cpp[Classic Hashtable.Add Example#1](~/add/codesnippet/cpp/m-system.collections.has_6_1.cpp)]\n [!code-cs[Classic Hashtable.Add Example#1](~/add/codesnippet/csharp/m-system.collections.has_6_1.cs)]\n [!code-vb[Classic Hashtable.Add Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_6_1.vb)]"
  syntax:
    content: public virtual void Add (object key, object value);
    parameters:
    - id: key
      type: System.Object
      description: "要添加的元素的键。"
    - id: value
      type: System.Object
      description: "要添加的元素的值。 该值可以为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Collections.Hashtable.Add*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "中已存在具有相同键的元素<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.Hashtable&quot;> </xref>是只读的。       -或- <xref href=&quot;System.Collections.Hashtable&quot;> </xref>具有固定的大小。"
  platform:
  - net462
- uid: System.Collections.Hashtable.Clear
  id: Clear
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Clear()
  nameWithType: Hashtable.Clear()
  fullName: System.Collections.Hashtable.Clear()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "移除所有元素从<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
  remarks: "<xref:System.Collections.Hashtable.Count%2A>是设置为零，并且集合的元素对其他对象的引用也被释放。</xref:System.Collections.Hashtable.Count%2A> 容量保持不变。       此方法为 O (`n`) 操作，其中`n`为<xref:System.Collections.Hashtable.Count%2A>。</xref:System.Collections.Hashtable.Count%2A>"
  example:
  - "The following example shows how to clear the values of the <xref:System.Collections.Hashtable>.  \n  \n [!code-cpp[Classic Hashtable.Clear Example#1](~/add/codesnippet/cpp/m-system.collections.has_10_1.cpp)]\n [!code-vb[Classic Hashtable.Clear Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_10_1.vb)]\n [!code-cs[Classic Hashtable.Clear Example#1](~/add/codesnippet/csharp/m-system.collections.has_10_1.cs)]"
  syntax:
    content: public virtual void Clear ();
    parameters: []
  overload: System.Collections.Hashtable.Clear*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.Hashtable&quot;> </xref>是只读的。"
  platform:
  - net462
- uid: System.Collections.Hashtable.Clone
  id: Clone
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Clone()
  nameWithType: Hashtable.Clone()
  fullName: System.Collections.Hashtable.Clone()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "创建的浅表复制<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
  remarks: "集合的浅表副本复制仅的元素集合，不论它们是引用类型还是值类型，但它不会复制引用所引用的对象。 新集合中的引用都指向原始集合中的引用指向同一对象。       与此相反，集合的深层副本复制这些元素，以及由这些元素直接或间接引用的所有内容。       <xref:System.Collections.Hashtable>克隆具有相同数量的、 相同的容量、 相同的<xref:System.Collections.IHashCodeProvider>实现，并将相同的<xref:System.Collections.IComparer>实现作为原始<xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> </xref:System.Collections.IComparer> </xref:System.Collections.IHashCodeProvider> </xref:System.Collections.Hashtable>       此方法为 O (`n`) 操作，其中`n`为<xref:System.Collections.Hashtable.Count%2A>。</xref:System.Collections.Hashtable.Count%2A>"
  syntax:
    content: public virtual object Clone ();
    parameters: []
    return:
      type: System.Object
      description: "浅表复制<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
  overload: System.Collections.Hashtable.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.comparer
  id: comparer
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: comparer
  nameWithType: Hashtable.comparer
  fullName: System.Collections.Hashtable.comparer
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "获取或设置<xref:System.Collections.IComparer>用于<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Collections.IComparer>"
  remarks: "检索此属性的值是一个 o （1） 操作。"
  syntax:
    content: protected System.Collections.IComparer comparer { get; set; }
    return:
      type: System.Collections.IComparer
      description: "<xref:System.Collections.IComparer>用于<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Collections.IComparer>"
  overload: System.Collections.Hashtable.comparer*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "属性设置为一个值，但哈希表使用<xref:System.Collections.IEqualityComparer>.</xref:System.Collections.IEqualityComparer>创建"
  platform:
  - net462
- uid: System.Collections.Hashtable.Contains(System.Object)
  id: Contains(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Contains(Object)
  nameWithType: Hashtable.Contains(Object)
  fullName: System.Collections.Hashtable.Contains(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "确定是否<xref href=&quot;System.Collections.Hashtable&quot;></xref>包含特定键。"
  remarks: "包含实现<xref:System.Collections.IDictionary.Contains%2A?displayProperty=fullName>.</xref:System.Collections.IDictionary.Contains%2A?displayProperty=fullName> 它的行为完全相同<xref:System.Collections.Hashtable.ContainsKey%2A>.</xref:System.Collections.Hashtable.ContainsKey%2A>       此方法为 o （1） 运算。       从.NET Framework 2.0 开始，此方法使用集合的对象<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`以确定是否存在项。</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> 在.NET Framework 的早期版本，通过进行此决定<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`参数的集合中的对象。</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  example:
  - "The following example shows how to determine whether the <xref:System.Collections.Hashtable> contains a specific element.  \n  \n [!code-cpp[Classic Hashtable.Contains Example#1](~/add/codesnippet/cpp/m-system.collections.has_12_1.cpp)]\n [!code-cs[Classic Hashtable.Contains Example#1](~/add/codesnippet/csharp/m-system.collections.has_12_1.cs)]\n [!code-vb[Classic Hashtable.Contains Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_12_1.vb)]"
  syntax:
    content: public virtual bool Contains (object key);
    parameters:
    - id: key
      type: System.Object
      description: "要查找中的键<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Collections.Hashtable&quot;></xref>包含具有指定的元素键; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Collections.Hashtable.Contains*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.ContainsKey(System.Object)
  id: ContainsKey(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: ContainsKey(Object)
  nameWithType: Hashtable.ContainsKey(Object)
  fullName: System.Collections.Hashtable.ContainsKey(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "确定是否<xref href=&quot;System.Collections.Hashtable&quot;></xref>包含特定键。"
  remarks: "此方法的行为完全相同<xref:System.Collections.Hashtable.Contains%2A>.</xref:System.Collections.Hashtable.Contains%2A>       此方法为 o （1） 运算。       从.NET Framework 2.0 开始，此方法使用集合的对象<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`以确定是否存在项。</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> 在.NET Framework 的早期版本，通过进行此决定<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`参数的集合中的对象。</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  example:
  - "The following example shows how to determine whether the <xref:System.Collections.Hashtable> contains a specific element.  \n  \n [!code-cpp[Classic Hashtable.Contains Example#1](~/add/codesnippet/cpp/m-system.collections.has_7_1.cpp)]\n [!code-cs[Classic Hashtable.Contains Example#1](~/add/codesnippet/csharp/m-system.collections.has_7_1.cs)]\n [!code-vb[Classic Hashtable.Contains Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_7_1.vb)]"
  syntax:
    content: public virtual bool ContainsKey (object key);
    parameters:
    - id: key
      type: System.Object
      description: "要查找中的键<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Collections.Hashtable&quot;></xref>包含具有指定的元素键; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Collections.Hashtable.ContainsKey*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.ContainsValue(System.Object)
  id: ContainsValue(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: ContainsValue(Object)
  nameWithType: Hashtable.ContainsValue(Object)
  fullName: System.Collections.Hashtable.ContainsValue(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "确定是否<xref href=&quot;System.Collections.Hashtable&quot;></xref>包含特定值。"
  remarks: "元素的值<xref:System.Collections.Hashtable>相比于指定的值使用<xref:System.Object.Equals%2A?displayProperty=fullName>方法。</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Collections.Hashtable>       此方法执行的线性搜索;因此，此方法为 O (`n`) 操作，其中`n`为<xref:System.Collections.Hashtable.Count%2A>。</xref:System.Collections.Hashtable.Count%2A>       从.NET Framework 2.0 开始，此方法使用集合的对象<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`以确定是否存在项。</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> 在.NET Framework 的早期版本，通过进行此决定<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`参数的集合中的对象。</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  example:
  - "The following example shows how to determine whether the <xref:System.Collections.Hashtable> contains a specific element.  \n  \n [!code-cpp[Classic Hashtable.Contains Example#1](~/add/codesnippet/cpp/m-system.collections.has_9_1.cpp)]\n [!code-cs[Classic Hashtable.Contains Example#1](~/add/codesnippet/csharp/m-system.collections.has_9_1.cs)]\n [!code-vb[Classic Hashtable.Contains Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_9_1.vb)]"
  syntax:
    content: public virtual bool ContainsValue (object value);
    parameters:
    - id: value
      type: System.Object
      description: "要查找中的值<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。 该值可以为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Collections.Hashtable&quot;></xref>包含具有指定的元素<code> value </code>; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Collections.Hashtable.ContainsValue*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.CopyTo(System.Array,System.Int32)
  id: CopyTo(System.Array,System.Int32)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: CopyTo(Array,Int32)
  nameWithType: Hashtable.CopyTo(Array,Int32)
  fullName: System.Collections.Hashtable.CopyTo(Array,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "副本<xref href=&quot;System.Collections.Hashtable&quot;></xref>元素的一维<xref:System.Array>实例的指定索引处。</xref:System.Array>"
  remarks: "元素被复制到<xref:System.Array>与在其中的枚举数循环访问<xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable>相同的顺序</xref:System.Array>       若要复制仅在密钥<xref:System.Collections.Hashtable>，使用`Hashtable.Keys.CopyTo`。</xref:System.Collections.Hashtable>       若要仅中的值复制<xref:System.Collections.Hashtable>，使用`Hashtable.Values.CopyTo`。</xref:System.Collections.Hashtable>       此方法为 O (`n`) 操作，其中`n`为<xref:System.Collections.Hashtable.Count%2A>。</xref:System.Collections.Hashtable.Count%2A>"
  example:
  - "The following example shows how to copy the list of keys or the list of values in a <xref:System.Collections.Hashtable> into a one-dimensional <xref:System.Array>.  \n  \n [!code-cs[Classic Hashtable.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.has_0_1.cs)]\n [!code-vb[Classic Hashtable.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_0_1.vb)]\n [!code-cpp[Classic Hashtable.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.has_0_1.cpp)]"
  syntax:
    content: public virtual void CopyTo (Array array, int arrayIndex);
    parameters:
    - id: array
      type: System.Array
      description: "一维<xref:System.Array>的目标<xref:System.Collections.DictionaryEntry>从复制的对象<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Collections.DictionaryEntry> </xref:System.Array> <xref:System.Array>必须具有从零开始的索引。</xref:System.Array>"
    - id: arrayIndex
      type: System.Int32
      description: "中的从零开始索引`array`复制开始处。"
  overload: System.Collections.Hashtable.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>arrayIndex</code>小于零。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>是多维的。       -源中的元素的数目<xref href=&quot;System.Collections.Hashtable&quot;></xref>大于从的可用空间<code>arrayIndex</code>到目标的末尾<code>array</code>。"
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "源类型<xref href=&quot;System.Collections.Hashtable&quot;></xref>无法自动转换为目标的类型<code> array </code>。"
  platform:
  - net462
- uid: System.Collections.Hashtable.Count
  id: Count
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Count
  nameWithType: Hashtable.Count
  fullName: System.Collections.Hashtable.Count
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "获取中包含的键/值对的数目<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
  remarks: "检索此属性的值是一个 o （1） 操作。"
  syntax:
    content: public virtual int Count { get; }
    return:
      type: System.Int32
      description: "中包含的键/值对的数目<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
  overload: System.Collections.Hashtable.Count*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.EqualityComparer
  id: EqualityComparer
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: EqualityComparer
  nameWithType: Hashtable.EqualityComparer
  fullName: System.Collections.Hashtable.EqualityComparer
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "获取<xref:System.Collections.IEqualityComparer>用于<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Collections.IEqualityComparer>"
  remarks: "<xref:System.Collections.IEqualityComparer>包括比较器和哈希代码提供程序。</xref:System.Collections.IEqualityComparer> 如果<xref:System.Collections.IEqualityComparer>中使用<xref:System.Collections.Hashtable>构造函数、 中用作键的对象<xref:System.Collections.Hashtable>无需重写<xref:System.Object.GetHashCode%2A?displayProperty=fullName>和<xref:System.Object.Equals%2A?displayProperty=fullName>方法。</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> </xref:System.Collections.IEqualityComparer>       检索此属性的值是一个 o （1） 操作。"
  syntax:
    content: protected System.Collections.IEqualityComparer EqualityComparer { get; }
    return:
      type: System.Collections.IEqualityComparer
      description: "<xref:System.Collections.IEqualityComparer>用于<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Collections.IEqualityComparer>"
  overload: System.Collections.Hashtable.EqualityComparer*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "属性设置为一个值，但哈希表使用创建<xref href=&quot;System.Collections.IHashCodeProvider&quot;></xref>和<xref:System.Collections.IComparer>。</xref:System.Collections.IComparer>"
  platform:
  - net462
- uid: System.Collections.Hashtable.GetEnumerator
  id: GetEnumerator
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: GetEnumerator()
  nameWithType: Hashtable.GetEnumerator()
  fullName: System.Collections.Hashtable.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "返回<xref:System.Collections.IDictionaryEnumerator>，它循环访问<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Collections.IDictionaryEnumerator>"
  remarks: "[Visual Basic、 C#]      `foreach` C# 语言的语句 (`for each`在 Visual Basic 中) 隐藏了枚举数的复杂性。  因此，使用`foreach`建议，而不是直接操作枚举数。       枚举器可用于读取集合中中的数据，但它们不能用于修改基础集合。       最初，枚举数定位在集合中的第一个元素之前。 <xref:System.Collections.IEnumerator.Reset%2A>此外会回此位置的枚举数。</xref:System.Collections.IEnumerator.Reset%2A>  在此位置上，<xref:System.Collections.IEnumerator.Current%2A>是不确定的。</xref:System.Collections.IEnumerator.Current%2A> 因此，你必须调用<xref:System.Collections.IEnumerator.MoveNext%2A>的第一个元素的集合，然后再读取<xref:System.Collections.IEnumerator.Current%2A>.</xref:System.Collections.IEnumerator.Current%2A>的值枚举器向前移动</xref:System.Collections.IEnumerator.MoveNext%2A>       <xref:System.Collections.IEnumerator.Current%2A>返回相同的对象之前<xref:System.Collections.IEnumerator.MoveNext%2A>或<xref:System.Collections.IEnumerator.Reset%2A>称为。</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>设置<xref:System.Collections.IEnumerator.Current%2A>到下一个元素。</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>       如果<xref:System.Collections.IEnumerator.MoveNext%2A>越过的末尾的集合，枚举数定位在集合中的最后一个元素的后面和<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`。</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> 当枚举器位于此位置上，后续调用<xref:System.Collections.IEnumerator.MoveNext%2A>还返回`false`。</xref:System.Collections.IEnumerator.MoveNext%2A> 如果最后一次调用到<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`，<xref:System.Collections.IEnumerator.Current%2A>是不确定的。</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> 若要设置<xref:System.Collections.IEnumerator.Current%2A>可以再次，集合的第一个元素调用<xref:System.Collections.IEnumerator.Reset%2A>后, 跟<xref:System.Collections.IEnumerator.MoveNext%2A>.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.Current%2A>       只要集合保持不变，枚举数就保持有效。 如果对集合进行更改，如添加、 修改或删除元素，则枚举数将失效且不可恢复，而且其行为是不确定。       枚举数没有对集合; 独占访问权因此，枚举整个集合本质上不是线程安全的过程。  若要确保枚举过程中的线程安全性，可以锁定在整个枚举期间的集合。  若要允许访问集合以进行读取和写入的多个线程，则必须实现自己的同步。       此方法为 o （1） 运算。       因为序列化和反序列化的枚举数<xref:System.Collections.Hashtable>可能会导致变得重新排序的元素，不能继续而不调用枚举<xref:System.Collections.IEnumerator.Reset%2A>方法。</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.Hashtable>"
  example:
  - "The following example compares the use of GetEnumerator and `foreach` to enumerate the contents of a <xref:System.Collections.Hashtable>.  \n  \n [!code-cpp[Classic Hashtable Example#2](~/add/codesnippet/cpp/m-system.collections.has_3_1.cpp)]\n [!code-cs[Classic Hashtable Example#2](~/add/codesnippet/csharp/m-system.collections.has_3_1.cs)]\n [!code-vb[Classic Hashtable Example#2](~/add/codesnippet/visualbasic/m-system.collections.has_3_1.vb)]"
  syntax:
    content: public virtual System.Collections.IDictionaryEnumerator GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IDictionaryEnumerator
      description: "An <xref:System.Collections.IDictionaryEnumerator> for the <xref href=&quot;System.Collections.Hashtable&quot;></xref>.</xref:System.Collections.IDictionaryEnumerator>"
  overload: System.Collections.Hashtable.GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.GetHash(System.Object)
  id: GetHash(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: GetHash(Object)
  nameWithType: Hashtable.GetHash(Object)
  fullName: System.Collections.Hashtable.GetHash(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "返回指定键的哈希代码。"
  remarks: "如果哈希表已创建具有特定<xref:System.Collections.IHashCodeProvider>实现，此方法使用该哈希代码提供程序; 否则，它使用<xref:System.Object.GetHashCode%2A?displayProperty=fullName>实现`key`。</xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.IHashCodeProvider>       此方法为 o （1） 运算。"
  syntax:
    content: protected virtual int GetHash (object key);
    parameters:
    - id: key
      type: System.Object
      description: "<xref:System.Object>要返回的哈希代码为。</xref:System.Object>"
    return:
      type: System.Int32
      description: "哈希代码<code> key </code>。"
  overload: System.Collections.Hashtable.GetHash*
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: GetObjectData(SerializationInfo,StreamingContext)
  nameWithType: Hashtable.GetObjectData(SerializationInfo,StreamingContext)
  fullName: System.Collections.Hashtable.GetObjectData(SerializationInfo,StreamingContext)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "实现<xref href=&quot;System.Runtime.Serialization.ISerializable&quot;></xref>接口，并返回序列化所需的数据<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
  remarks: "此方法为 O (`n`) 操作，其中`n`为<xref:System.Collections.Hashtable.Count%2A>。</xref:System.Collections.Hashtable.Count%2A>"
  syntax:
    content: public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "A <xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref>对象，其中包含序列化所需的信息<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "A<xref:System.Runtime.Serialization.StreamingContext>对象，其中包含的源和目标与关联的序列化流<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Runtime.Serialization.StreamingContext>"
  overload: System.Collections.Hashtable.GetObjectData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>info</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "集合已修改。"
  platform:
  - net462
- uid: System.Collections.Hashtable.hcp
  id: hcp
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: hcp
  nameWithType: Hashtable.hcp
  fullName: System.Collections.Hashtable.hcp
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "获取或设置可分配哈希代码的对象。"
  remarks: "检索此属性的值是一个 o （1） 操作。"
  syntax:
    content: protected System.Collections.IHashCodeProvider hcp { get; set; }
    return:
      type: System.Collections.IHashCodeProvider
      description: "可分配哈希代码的对象。"
  overload: System.Collections.Hashtable.hcp*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "属性设置为一个值，但哈希表使用<xref:System.Collections.IEqualityComparer>.</xref:System.Collections.IEqualityComparer>创建"
  platform:
  - net462
- uid: System.Collections.Hashtable.IsFixedSize
  id: IsFixedSize
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: IsFixedSize
  nameWithType: Hashtable.IsFixedSize
  fullName: System.Collections.Hashtable.IsFixedSize
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "获取一个值，该值指示是否<xref href=&quot;System.Collections.Hashtable&quot;></xref>具有固定的大小。"
  remarks: "具有固定大小的集合不允许添加或移除元素后的集合在创建，但是允许修改现有元素。       具有固定大小的集合是只是一个集合的包装器防止添加和移除元素;因此，如果对基础集合，包括添加或移除元素，进行更改的固定大小的集合将反映这些更改。       检索此属性的值是一个 o （1） 操作。"
  syntax:
    content: public virtual bool IsFixedSize { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Collections.Hashtable&quot;></xref>具有固定大小; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Collections.Hashtable.IsFixedSize*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.IsReadOnly
  id: IsReadOnly
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: IsReadOnly
  nameWithType: Hashtable.IsReadOnly
  fullName: System.Collections.Hashtable.IsReadOnly
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "获取一个值，该值指示是否<xref href=&quot;System.Collections.Hashtable&quot;></xref>是只读的。"
  remarks: "集合是只读的不允许添加、 移除或修改元素的集合在创建后。       集合是只读的是只是一个集合与防止集合; 进行修改的包装因此，如果对基础集合进行更改，只读集合将反映这些更改。       检索此属性的值是一个 o （1） 操作。"
  syntax:
    content: public virtual bool IsReadOnly { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Collections.Hashtable&quot;></xref>只读的; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Collections.Hashtable.IsReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.IsSynchronized
  id: IsSynchronized
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: IsSynchronized
  nameWithType: Hashtable.IsSynchronized
  fullName: System.Collections.Hashtable.IsSynchronized
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "获取一个值，该值指示是否访问<xref href=&quot;System.Collections.Hashtable&quot;></xref>是同步的 （线程安全）。"
  remarks: "A<xref:System.Collections.Hashtable>可以同时支持一个编写器和多个读取器。</xref:System.Collections.Hashtable> 若要支持多个编写器，必须通过返回的包装器来完成所有操作<xref:System.Collections.Hashtable.Synchronized%2A>方法。</xref:System.Collections.Hashtable.Synchronized%2A>       枚举整个集合本质上不是线程安全的过程。 即使某个集合已同步，其他线程仍可以修改集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改导致的异常。       下面的代码示例演示如何锁定集合使用<xref:System.Collections.Hashtable.SyncRoot%2A>在整个枚举期间︰ [!code-cpp[经典 Hashtable.IsSynchronized 第二个示例](~/add/codesnippet/cpp/p-system.collections.has_1_1.cpp)][!code-vb[经典 Hashtable.IsSynchronized 第二个示例](~/add/codesnippet/visualbasic/p-system.collections.has_1_1.vb)][!code-cs[经典 Hashtable.IsSynchronized 第二个示例](~/add/codesnippet/csharp/p-system.collections.has_1_1.cs)]     </xref:System.Collections.Hashtable.SyncRoot%2A>"
  example:
  - "The following example shows how to synchronize a <xref:System.Collections.Hashtable>, determine if a <xref:System.Collections.Hashtable> is synchronized, and use a synchronized <xref:System.Collections.Hashtable>.  \n  \n [!code-cs[Classic Hashtable.IsSynchronized Example#1](~/add/codesnippet/csharp/p-system.collections.has_1_2.cs)]\n [!code-cpp[Classic Hashtable.IsSynchronized Example#1](~/add/codesnippet/cpp/p-system.collections.has_1_2.cpp)]\n [!code-vb[Classic Hashtable.IsSynchronized Example#1](~/add/codesnippet/visualbasic/p-system.collections.has_1_2.vb)]"
  syntax:
    content: public virtual bool IsSynchronized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果访问<xref href=&quot;System.Collections.Hashtable&quot;></xref>是同步的 （线程安全）; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Collections.Hashtable.IsSynchronized*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.Item(System.Object)
  id: Item(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Item(Object)
  nameWithType: Hashtable.Item(Object)
  fullName: System.Collections.Hashtable.Item(Object)
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "获取或设置与指定键关联的值。"
  remarks: "此属性提供能够通过使用以下语法访问集合中的特定元素︰ `myCollection[key]`。       你还可以使用项目属性来添加新元素中不存在的键的值设置<xref:System.Collections.Hashtable>; 例如， `myCollection[&quot;myNonexistentKey&quot;] = myValue`。</xref:System.Collections.Hashtable> 但是，如果指定的键已存在于<xref:System.Collections.Hashtable>，设置项目属性将覆盖旧值。</xref:System.Collections.Hashtable> 与此相反，<xref:System.Collections.Hashtable.Add%2A>方法不会修改现有元素。</xref:System.Collections.Hashtable.Add%2A>       密钥不能为`null`，但可以是一个值。 来区分`null`返回因为找不到指定的键和`null`返回指定键的值是因为`null`，使用<xref:System.Collections.Hashtable.Contains%2A>方法或<xref:System.Collections.Hashtable.ContainsKey%2A>方法来确定在列表中是否存在的项。</xref:System.Collections.Hashtable.ContainsKey%2A> </xref:System.Collections.Hashtable.Contains%2A>       检索此属性的值的运算 o （1）;设置属性也是 o （1） 运算。       C# 语言使用关键字进行定义而不是实现索引器<xref:System.Collections.IList.Item%2A>属性。</xref:System.Collections.IList.Item%2A> Visual Basic 实现为默认属性，它提供相同的索引功能的项。"
  syntax:
    content: public virtual object this[object key] { get; set; }
    parameters:
    - id: key
      type: System.Object
      description: "密钥要获取或设置其值。"
    return:
      type: System.Object
      description: "与指定键关联的值。 如果未找到指定的键，尝试获取它将返回<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，并尝试将其设置创建一个使用指定的键的新元素。"
  overload: System.Collections.Hashtable.Item*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "将属性设置和<xref href=&quot;System.Collections.Hashtable&quot;></xref>是只读的。       -或-设置该属性， <code> key </code>不存在于集合中，与<xref href=&quot;System.Collections.Hashtable&quot;></xref>具有固定的大小。"
  platform:
  - net462
- uid: System.Collections.Hashtable.KeyEquals(System.Object,System.Object)
  id: KeyEquals(System.Object,System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: KeyEquals(Object,Object)
  nameWithType: Hashtable.KeyEquals(Object,Object)
  fullName: System.Collections.Hashtable.KeyEquals(Object,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "比较特定<xref:System.Object>与中的特定键<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Object>"
  remarks: "如果哈希表已创建具有特定<xref:System.Collections.IComparer>实现中，此方法使用该比较器; 即， <xref:System.Collections.IComparer.Compare%2A>(`item`， `key`)。</xref:System.Collections.IComparer.Compare%2A> </xref:System.Collections.IComparer> 否则，它使用`item.Equals(key)`。       此方法为 o （1） 运算。"
  syntax:
    content: protected virtual bool KeyEquals (object item, object key);
    parameters:
    - id: item
      type: System.Object
      description: "<xref:System.Object>进行比较的`key`。</xref:System.Object>"
    - id: key
      type: System.Object
      description: "中的密钥<xref href=&quot;System.Collections.Hashtable&quot;></xref>进行比较的`item`。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>if <code>item</code> and <code>key</code> are equal; otherwise, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>."
  overload: System.Collections.Hashtable.KeyEquals*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>item</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>key</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.Keys
  id: Keys
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Keys
  nameWithType: Hashtable.Keys
  fullName: System.Collections.Hashtable.Keys
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "获取<xref:System.Collections.ICollection>包含中的键<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Collections.ICollection>"
  remarks: "中的键的顺序<xref:System.Collections.ICollection>未指定，但它是中的关联值顺序相同<xref:System.Collections.ICollection>返回<xref:System.Collections.Hashtable.Values%2A>方法。</xref:System.Collections.Hashtable.Values%2A> </xref:System.Collections.ICollection> </xref:System.Collections.ICollection>       返回<xref:System.Collections.ICollection>不是静态的副本; 相反，<xref:System.Collections.ICollection>引用回原始<xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable>中的键</xref:System.Collections.ICollection></xref:System.Collections.ICollection> 因此，更改为<xref:System.Collections.Hashtable>继续才会反映在<xref:System.Collections.ICollection>.</xref:System.Collections.ICollection> </xref:System.Collections.Hashtable>       检索此属性的值是一个 o （1） 操作。"
  syntax:
    content: public virtual System.Collections.ICollection Keys { get; }
    return:
      type: System.Collections.ICollection
      description: "<xref:System.Collections.ICollection>包含中的键<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Collections.ICollection>"
  overload: System.Collections.Hashtable.Keys*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.OnDeserialization(System.Object)
  id: OnDeserialization(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: OnDeserialization(Object)
  nameWithType: Hashtable.OnDeserialization(Object)
  fullName: System.Collections.Hashtable.OnDeserialization(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "实现<xref href=&quot;System.Runtime.Serialization.ISerializable&quot;></xref>接口，并引发反序列化完成时，反序列化事件。"
  remarks: "此方法为 O (`n`) 操作，其中`n`为<xref:System.Collections.Hashtable.Count%2A>。</xref:System.Collections.Hashtable.Count%2A>       因为序列化和反序列化的枚举数<xref:System.Collections.Hashtable>可能会导致变得重新排序的元素，不能继续而不调用枚举<xref:System.Collections.IEnumerator.Reset%2A>方法。</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.Hashtable>"
  syntax:
    content: public virtual void OnDeserialization (object sender);
    parameters:
    - id: sender
      type: System.Object
      description: "反序列化事件源。"
  overload: System.Collections.Hashtable.OnDeserialization*
  exceptions:
  - type: System.Runtime.Serialization.SerializationException
    commentId: T:System.Runtime.Serialization.SerializationException
    description: "<xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref>关联与当前对象<xref href=&quot;System.Collections.Hashtable&quot;></xref>无效。"
  platform:
  - net462
- uid: System.Collections.Hashtable.Remove(System.Object)
  id: Remove(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Remove(Object)
  nameWithType: Hashtable.Remove(Object)
  fullName: System.Collections.Hashtable.Remove(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "移除带有指定键的元素<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
  remarks: "如果<xref:System.Collections.Hashtable>不具有指定键，包含的元素<xref:System.Collections.Hashtable>保持不变。</xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> 不引发异常。       此方法为 o （1） 运算。"
  example:
  - "The following example shows how to remove elements from the <xref:System.Collections.Hashtable>.  \n  \n [!code-cpp[Classic Hashtable.Remove Example#1](~/add/codesnippet/cpp/m-system.collections.has_13_1.cpp)]\n [!code-cs[Classic Hashtable.Remove Example#1](~/add/codesnippet/csharp/m-system.collections.has_13_1.cs)]\n [!code-vb[Classic Hashtable.Remove Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_13_1.vb)]"
  syntax:
    content: public virtual void Remove (object key);
    parameters:
    - id: key
      type: System.Object
      description: "要移除的元素的键。"
  overload: System.Collections.Hashtable.Remove*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.Hashtable&quot;> </xref>是只读的。       -或- <xref href=&quot;System.Collections.Hashtable&quot;> </xref>具有固定的大小。"
  platform:
  - net462
- uid: System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)
  id: Synchronized(System.Collections.Hashtable)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Synchronized(Hashtable)
  nameWithType: Hashtable.Synchronized(Hashtable)
  fullName: System.Collections.Hashtable.Synchronized(Hashtable)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "返回同步的 （线程安全） 包装器<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
  remarks: "已同步方法是线程安全的多个读取器和编写器。 此外，同步的包装器可确保只有一个编写器编写一次。       枚举整个集合本质上不是一个线程安全的过程。 即使某个集合已同步，其他线程仍可以修改集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改导致的异常。       下面的代码示例演示如何锁定集合使用<xref:System.Collections.Hashtable.SyncRoot%2A>在整个枚举期间︰ [!code-cpp[经典 Hashtable.IsSynchronized 第二个示例](~/add/codesnippet/cpp/m-system.collections.has_11_1.cpp)][!code-vb[经典 Hashtable.IsSynchronized 第二个示例](~/add/codesnippet/visualbasic/m-system.collections.has_11_1.vb)][!code-cs[经典 Hashtable.IsSynchronized 第二个示例](~/add/codesnippet/csharp/m-system.collections.has_11_1.cs)]此方法为 o （1） 运算。    </xref:System.Collections.Hashtable.SyncRoot%2A>"
  example:
  - "The following example shows how to synchronize a <xref:System.Collections.Hashtable>, determine if a <xref:System.Collections.Hashtable> is synchronized, and use a synchronized <xref:System.Collections.Hashtable>.  \n  \n [!code-cs[Classic Hashtable.IsSynchronized Example#1](~/add/codesnippet/csharp/m-system.collections.has_11_2.cs)]\n [!code-cpp[Classic Hashtable.IsSynchronized Example#1](~/add/codesnippet/cpp/m-system.collections.has_11_2.cpp)]\n [!code-vb[Classic Hashtable.IsSynchronized Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_11_2.vb)]"
  syntax:
    content: public static System.Collections.Hashtable Synchronized (System.Collections.Hashtable table);
    parameters:
    - id: table
      type: System.Collections.Hashtable
      description: "<xref href=&quot;System.Collections.Hashtable&quot;> </xref>进行同步。"
    return:
      type: System.Collections.Hashtable
      description: "一个同步 （线程安全） 包装器<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
  overload: System.Collections.Hashtable.Synchronized*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>table</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.SyncRoot
  id: SyncRoot
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: SyncRoot
  nameWithType: Hashtable.SyncRoot
  fullName: System.Collections.Hashtable.SyncRoot
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "获取可以用于对访问进行同步的对象<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
  remarks: "若要创建的同步的版本<xref:System.Collections.Hashtable>，使用<xref:System.Collections.Hashtable.Synchronized%2A>方法。</xref:System.Collections.Hashtable.Synchronized%2A> </xref:System.Collections.Hashtable> 但是，派生的类可以提供自己的同步的版本<xref:System.Collections.Hashtable>使用 SyncRoot 属性。</xref:System.Collections.Hashtable> 同步代码必须对执行操作的 SyncRoot <xref:System.Collections.Hashtable>，不是直接对<xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> 这可确保正确地执行操作的从其他对象派生的集合。 具体地说，这样可保持正确的同步，与可能同时对修改其他线程<xref:System.Collections.Hashtable>对象。</xref:System.Collections.Hashtable>       枚举整个集合本质上不是线程安全的过程。 即使某个集合已同步，其他线程仍可以修改集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改导致的异常。       下面的代码示例演示如何在整个枚举过程中使用 SyncRoot 的集合︰ [!code-cpp[经典 Hashtable.IsSynchronized 第二个示例](~/add/codesnippet/cpp/p-system.collections.has_0_1.cpp)][!code-vb[经典 Hashtable.IsSynchronized 第二个示例](~/add/codesnippet/visualbasic/p-system.collections.has_0_1.vb)][!code-cs[经典 Hashtable.IsSynchronized 示例&#2;    ](~/add/codesnippet/csharp/p-system.collections.has_0_1.cs)]"
  syntax:
    content: public virtual object SyncRoot { get; }
    return:
      type: System.Object
      description: "可以用于对访问进行同步的对象<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
  overload: System.Collections.Hashtable.SyncRoot*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator
  id: System#Collections#IEnumerable#GetEnumerator
  isEii: true
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: System.Collections.IEnumerable.GetEnumerator()
  nameWithType: Hashtable.System.Collections.IEnumerable.GetEnumerator()
  fullName: System.Collections.Hashtable.System.Collections.IEnumerable.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "返回循环访问集合的枚举。"
  remarks: "[Visual Basic、 C#]      `foreach` C# 语言的语句 (`for each`在 Visual Basic 中) 隐藏了枚举数的复杂性。  因此，使用`foreach`建议，而不是直接操作枚举数。       枚举器可用于读取集合中中的数据，但它们不能用于修改基础集合。       最初，枚举数定位在集合中的第一个元素之前。 <xref:System.Collections.IEnumerator.Reset%2A>此外会回此位置的枚举数。</xref:System.Collections.IEnumerator.Reset%2A> 在此位置，调用<xref:System.Collections.IEnumerator.Current%2A>引发异常。</xref:System.Collections.IEnumerator.Current%2A> 因此，你必须调用<xref:System.Collections.IEnumerator.MoveNext%2A>的第一个元素的集合，然后再读取<xref:System.Collections.IEnumerator.Current%2A>.</xref:System.Collections.IEnumerator.Current%2A>的值枚举器向前移动</xref:System.Collections.IEnumerator.MoveNext%2A>       <xref:System.Collections.IEnumerator.Current%2A>返回相同的对象之前<xref:System.Collections.IEnumerator.MoveNext%2A>或<xref:System.Collections.IEnumerator.Reset%2A>称为。</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>设置<xref:System.Collections.IEnumerator.Current%2A>到下一个元素。</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>       如果<xref:System.Collections.IEnumerator.MoveNext%2A>越过的末尾的集合，枚举数定位在集合中的最后一个元素的后面和<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`。</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> 当枚举器位于此位置上，后续调用<xref:System.Collections.IEnumerator.MoveNext%2A>还返回`false`。</xref:System.Collections.IEnumerator.MoveNext%2A> 如果最后一次调用到<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`，则调用<xref:System.Collections.IEnumerator.Current%2A>引发异常。</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> 若要设置<xref:System.Collections.IEnumerator.Current%2A>可以再次，集合的第一个元素调用<xref:System.Collections.IEnumerator.Reset%2A>后, 跟<xref:System.Collections.IEnumerator.MoveNext%2A>.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.Current%2A>       只要集合保持不变，枚举数就保持有效。 如果对集合进行更改，可以如添加、 修改或删除元素，枚举数将失效，并且下一个调用<xref:System.Collections.IEnumerator.MoveNext%2A>或<xref:System.Collections.IEnumerator.Reset%2A>引发<xref:System.InvalidOperationException>.</xref:System.InvalidOperationException> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> 如果之间修改集合<xref:System.Collections.IEnumerator.MoveNext%2A>和<xref:System.Collections.IEnumerator.Current%2A>，<xref:System.Collections.IEnumerator.Current%2A>返回到，设置的元素，即使枚举数已经无效。</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A>       枚举数没有对集合; 独占访问权因此，枚举整个集合本质上不是线程安全的过程。 即使某个集合已同步，其他线程仍可以修改集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改导致的异常。       此方法为 o （1） 运算。"
  syntax:
    content: System.Collections.IEnumerator IEnumerable.GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: "<xref:System.Collections.IEnumerator>可用于循环访问集合。</xref:System.Collections.IEnumerator>"
  overload: System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.Values
  id: Values
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Values
  nameWithType: Hashtable.Values
  fullName: System.Collections.Hashtable.Values
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "获取<xref:System.Collections.ICollection>包含中的值<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Collections.ICollection>"
  remarks: "中的值的顺序<xref:System.Collections.ICollection>未指定，但它是中的关联键顺序相同<xref:System.Collections.ICollection>返回<xref:System.Collections.Hashtable.Keys%2A>方法。</xref:System.Collections.Hashtable.Keys%2A> </xref:System.Collections.ICollection> </xref:System.Collections.ICollection>       返回<xref:System.Collections.ICollection>不是静态的副本; 相反，<xref:System.Collections.ICollection>引用回原始<xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable>中的值</xref:System.Collections.ICollection></xref:System.Collections.ICollection> 因此，更改为<xref:System.Collections.Hashtable>继续才会反映在<xref:System.Collections.ICollection>.</xref:System.Collections.ICollection> </xref:System.Collections.Hashtable>       检索此属性的值是一个 o （1） 操作。"
  syntax:
    content: public virtual System.Collections.ICollection Values { get; }
    return:
      type: System.Collections.ICollection
      description: "<xref:System.Collections.ICollection>包含中的值<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Collections.ICollection>"
  overload: System.Collections.Hashtable.Values*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.InvalidCastException
  isExternal: true
  name: System.InvalidCastException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Runtime.Serialization.SerializationException
  isExternal: true
  name: System.Runtime.Serialization.SerializationException
- uid: System.Collections.Hashtable.#ctor
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable()
  nameWithType: Hashtable.Hashtable()
  fullName: System.Collections.Hashtable.Hashtable()
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IDictionary)
  nameWithType: Hashtable.Hashtable(IDictionary)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary)
- uid: System.Collections.IDictionary
  parent: System.Collections
  isExternal: true
  name: IDictionary
  nameWithType: IDictionary
  fullName: System.Collections.IDictionary
- uid: System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IEqualityComparer)
  nameWithType: Hashtable.Hashtable(IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(IEqualityComparer)
- uid: System.Collections.IEqualityComparer
  parent: System.Collections
  isExternal: true
  name: IEqualityComparer
  nameWithType: IEqualityComparer
  fullName: System.Collections.IEqualityComparer
- uid: System.Collections.Hashtable.#ctor(System.Int32)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(Int32)
  nameWithType: Hashtable.Hashtable(Int32)
  fullName: System.Collections.Hashtable.Hashtable(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IDictionary,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,IEqualityComparer)
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IDictionary,Single)
  nameWithType: Hashtable.Hashtable(IDictionary,Single)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,Single)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(IHashCodeProvider,IComparer)
- uid: System.Collections.IHashCodeProvider
  parent: System.Collections
  isExternal: false
  name: IHashCodeProvider
  nameWithType: IHashCodeProvider
  fullName: System.Collections.IHashCodeProvider
- uid: System.Collections.IComparer
  parent: System.Collections
  isExternal: true
  name: IComparer
  nameWithType: IComparer
  fullName: System.Collections.IComparer
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(Int32,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(Int32,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,IEqualityComparer)
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Single)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(Int32,Single)
  nameWithType: Hashtable.Hashtable(Int32,Single)
  fullName: System.Collections.Hashtable.Hashtable(Int32,Single)
- uid: System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(SerializationInfo,StreamingContext)
  nameWithType: Hashtable.Hashtable(SerializationInfo,StreamingContext)
  fullName: System.Collections.Hashtable.Hashtable(SerializationInfo,StreamingContext)
- uid: System.Runtime.Serialization.SerializationInfo
  parent: System.Runtime.Serialization
  isExternal: false
  name: SerializationInfo
  nameWithType: SerializationInfo
  fullName: System.Runtime.Serialization.SerializationInfo
- uid: System.Runtime.Serialization.StreamingContext
  parent: System.Runtime.Serialization
  isExternal: true
  name: StreamingContext
  nameWithType: StreamingContext
  fullName: System.Runtime.Serialization.StreamingContext
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IDictionary,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,IHashCodeProvider,IComparer)
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IDictionary,Single,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,Single,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,Single,IEqualityComparer)
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(Int32,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(Int32,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,IHashCodeProvider,IComparer)
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(Int32,Single,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(Int32,Single,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,Single,IEqualityComparer)
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IDictionary,Single,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,Single,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,Single,IHashCodeProvider,IComparer)
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(Int32,Single,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(Int32,Single,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,Single,IHashCodeProvider,IComparer)
- uid: System.Collections.Hashtable.Add(System.Object,System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Add(Object,Object)
  nameWithType: Hashtable.Add(Object,Object)
  fullName: System.Collections.Hashtable.Add(Object,Object)
- uid: System.Collections.Hashtable.Clear
  parent: System.Collections.Hashtable
  isExternal: false
  name: Clear()
  nameWithType: Hashtable.Clear()
  fullName: System.Collections.Hashtable.Clear()
- uid: System.Collections.Hashtable.Clone
  parent: System.Collections.Hashtable
  isExternal: false
  name: Clone()
  nameWithType: Hashtable.Clone()
  fullName: System.Collections.Hashtable.Clone()
- uid: System.Collections.Hashtable.comparer
  parent: System.Collections.Hashtable
  isExternal: false
  name: comparer
  nameWithType: Hashtable.comparer
  fullName: System.Collections.Hashtable.comparer
- uid: System.Collections.Hashtable.Contains(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Contains(Object)
  nameWithType: Hashtable.Contains(Object)
  fullName: System.Collections.Hashtable.Contains(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Collections.Hashtable.ContainsKey(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: ContainsKey(Object)
  nameWithType: Hashtable.ContainsKey(Object)
  fullName: System.Collections.Hashtable.ContainsKey(Object)
- uid: System.Collections.Hashtable.ContainsValue(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: ContainsValue(Object)
  nameWithType: Hashtable.ContainsValue(Object)
  fullName: System.Collections.Hashtable.ContainsValue(Object)
- uid: System.Collections.Hashtable.CopyTo(System.Array,System.Int32)
  parent: System.Collections.Hashtable
  isExternal: false
  name: CopyTo(Array,Int32)
  nameWithType: Hashtable.CopyTo(Array,Int32)
  fullName: System.Collections.Hashtable.CopyTo(Array,Int32)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: System.Collections.Hashtable.Count
  parent: System.Collections.Hashtable
  isExternal: false
  name: Count
  nameWithType: Hashtable.Count
  fullName: System.Collections.Hashtable.Count
- uid: System.Collections.Hashtable.EqualityComparer
  parent: System.Collections.Hashtable
  isExternal: false
  name: EqualityComparer
  nameWithType: Hashtable.EqualityComparer
  fullName: System.Collections.Hashtable.EqualityComparer
- uid: System.Collections.Hashtable.GetEnumerator
  parent: System.Collections.Hashtable
  isExternal: false
  name: GetEnumerator()
  nameWithType: Hashtable.GetEnumerator()
  fullName: System.Collections.Hashtable.GetEnumerator()
- uid: System.Collections.IDictionaryEnumerator
  parent: System.Collections
  isExternal: true
  name: IDictionaryEnumerator
  nameWithType: IDictionaryEnumerator
  fullName: System.Collections.IDictionaryEnumerator
- uid: System.Collections.Hashtable.GetHash(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: GetHash(Object)
  nameWithType: Hashtable.GetHash(Object)
  fullName: System.Collections.Hashtable.GetHash(Object)
- uid: System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Collections.Hashtable
  isExternal: false
  name: GetObjectData(SerializationInfo,StreamingContext)
  nameWithType: Hashtable.GetObjectData(SerializationInfo,StreamingContext)
  fullName: System.Collections.Hashtable.GetObjectData(SerializationInfo,StreamingContext)
- uid: System.Collections.Hashtable.hcp
  parent: System.Collections.Hashtable
  isExternal: false
  name: hcp
  nameWithType: Hashtable.hcp
  fullName: System.Collections.Hashtable.hcp
- uid: System.Collections.Hashtable.IsFixedSize
  parent: System.Collections.Hashtable
  isExternal: false
  name: IsFixedSize
  nameWithType: Hashtable.IsFixedSize
  fullName: System.Collections.Hashtable.IsFixedSize
- uid: System.Collections.Hashtable.IsReadOnly
  parent: System.Collections.Hashtable
  isExternal: false
  name: IsReadOnly
  nameWithType: Hashtable.IsReadOnly
  fullName: System.Collections.Hashtable.IsReadOnly
- uid: System.Collections.Hashtable.IsSynchronized
  parent: System.Collections.Hashtable
  isExternal: false
  name: IsSynchronized
  nameWithType: Hashtable.IsSynchronized
  fullName: System.Collections.Hashtable.IsSynchronized
- uid: System.Collections.Hashtable.Item(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Item(Object)
  nameWithType: Hashtable.Item(Object)
  fullName: System.Collections.Hashtable.Item(Object)
- uid: System.Collections.Hashtable.KeyEquals(System.Object,System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: KeyEquals(Object,Object)
  nameWithType: Hashtable.KeyEquals(Object,Object)
  fullName: System.Collections.Hashtable.KeyEquals(Object,Object)
- uid: System.Collections.Hashtable.Keys
  parent: System.Collections.Hashtable
  isExternal: false
  name: Keys
  nameWithType: Hashtable.Keys
  fullName: System.Collections.Hashtable.Keys
- uid: System.Collections.ICollection
  parent: System.Collections
  isExternal: true
  name: ICollection
  nameWithType: ICollection
  fullName: System.Collections.ICollection
- uid: System.Collections.Hashtable.OnDeserialization(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: OnDeserialization(Object)
  nameWithType: Hashtable.OnDeserialization(Object)
  fullName: System.Collections.Hashtable.OnDeserialization(Object)
- uid: System.Collections.Hashtable.Remove(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Remove(Object)
  nameWithType: Hashtable.Remove(Object)
  fullName: System.Collections.Hashtable.Remove(Object)
- uid: System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Synchronized(Hashtable)
  nameWithType: Hashtable.Synchronized(Hashtable)
  fullName: System.Collections.Hashtable.Synchronized(Hashtable)
- uid: System.Collections.Hashtable
  parent: System.Collections
  isExternal: false
  name: Hashtable
  nameWithType: Hashtable
  fullName: System.Collections.Hashtable
- uid: System.Collections.Hashtable.SyncRoot
  parent: System.Collections.Hashtable
  isExternal: false
  name: SyncRoot
  nameWithType: Hashtable.SyncRoot
  fullName: System.Collections.Hashtable.SyncRoot
- uid: System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator
  parent: System.Collections.Hashtable
  isExternal: false
  name: System.Collections.IEnumerable.GetEnumerator()
  nameWithType: Hashtable.System.Collections.IEnumerable.GetEnumerator()
  fullName: System.Collections.Hashtable.System.Collections.IEnumerable.GetEnumerator()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Collections.Hashtable.Values
  parent: System.Collections.Hashtable
  isExternal: false
  name: Values
  nameWithType: Hashtable.Values
  fullName: System.Collections.Hashtable.Values
- uid: System.Collections.Hashtable.#ctor*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable
  nameWithType: Hashtable.Hashtable
- uid: System.Collections.Hashtable.Add*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Add
  nameWithType: Hashtable.Add
- uid: System.Collections.Hashtable.Clear*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Clear
  nameWithType: Hashtable.Clear
- uid: System.Collections.Hashtable.Clone*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Clone
  nameWithType: Hashtable.Clone
- uid: System.Collections.Hashtable.comparer*
  parent: System.Collections.Hashtable
  isExternal: false
  name: comparer
  nameWithType: Hashtable.comparer
- uid: System.Collections.Hashtable.Contains*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Contains
  nameWithType: Hashtable.Contains
- uid: System.Collections.Hashtable.ContainsKey*
  parent: System.Collections.Hashtable
  isExternal: false
  name: ContainsKey
  nameWithType: Hashtable.ContainsKey
- uid: System.Collections.Hashtable.ContainsValue*
  parent: System.Collections.Hashtable
  isExternal: false
  name: ContainsValue
  nameWithType: Hashtable.ContainsValue
- uid: System.Collections.Hashtable.CopyTo*
  parent: System.Collections.Hashtable
  isExternal: false
  name: CopyTo
  nameWithType: Hashtable.CopyTo
- uid: System.Collections.Hashtable.Count*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Count
  nameWithType: Hashtable.Count
- uid: System.Collections.Hashtable.EqualityComparer*
  parent: System.Collections.Hashtable
  isExternal: false
  name: EqualityComparer
  nameWithType: Hashtable.EqualityComparer
- uid: System.Collections.Hashtable.GetEnumerator*
  parent: System.Collections.Hashtable
  isExternal: false
  name: GetEnumerator
  nameWithType: Hashtable.GetEnumerator
- uid: System.Collections.Hashtable.GetHash*
  parent: System.Collections.Hashtable
  isExternal: false
  name: GetHash
  nameWithType: Hashtable.GetHash
- uid: System.Collections.Hashtable.GetObjectData*
  parent: System.Collections.Hashtable
  isExternal: false
  name: GetObjectData
  nameWithType: Hashtable.GetObjectData
- uid: System.Collections.Hashtable.hcp*
  parent: System.Collections.Hashtable
  isExternal: false
  name: hcp
  nameWithType: Hashtable.hcp
- uid: System.Collections.Hashtable.IsFixedSize*
  parent: System.Collections.Hashtable
  isExternal: false
  name: IsFixedSize
  nameWithType: Hashtable.IsFixedSize
- uid: System.Collections.Hashtable.IsReadOnly*
  parent: System.Collections.Hashtable
  isExternal: false
  name: IsReadOnly
  nameWithType: Hashtable.IsReadOnly
- uid: System.Collections.Hashtable.IsSynchronized*
  parent: System.Collections.Hashtable
  isExternal: false
  name: IsSynchronized
  nameWithType: Hashtable.IsSynchronized
- uid: System.Collections.Hashtable.Item*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Item
  nameWithType: Hashtable.Item
- uid: System.Collections.Hashtable.KeyEquals*
  parent: System.Collections.Hashtable
  isExternal: false
  name: KeyEquals
  nameWithType: Hashtable.KeyEquals
- uid: System.Collections.Hashtable.Keys*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Keys
  nameWithType: Hashtable.Keys
- uid: System.Collections.Hashtable.OnDeserialization*
  parent: System.Collections.Hashtable
  isExternal: false
  name: OnDeserialization
  nameWithType: Hashtable.OnDeserialization
- uid: System.Collections.Hashtable.Remove*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Remove
  nameWithType: Hashtable.Remove
- uid: System.Collections.Hashtable.Synchronized*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Synchronized
  nameWithType: Hashtable.Synchronized
- uid: System.Collections.Hashtable.SyncRoot*
  parent: System.Collections.Hashtable
  isExternal: false
  name: SyncRoot
  nameWithType: Hashtable.SyncRoot
- uid: System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator*
  parent: System.Collections.Hashtable
  isExternal: false
  name: System.Collections.IEnumerable.GetEnumerator
  nameWithType: Hashtable.System.Collections.IEnumerable.GetEnumerator
- uid: System.Collections.Hashtable.Values*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Values
  nameWithType: Hashtable.Values
