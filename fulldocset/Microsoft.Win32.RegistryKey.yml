### YamlMime:ManagedReference
items:
- uid: Microsoft.Win32.RegistryKey
  id: RegistryKey
  children:
  - Microsoft.Win32.RegistryKey.Close
  - Microsoft.Win32.RegistryKey.CreateSubKey(System.String)
  - Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck)
  - Microsoft.Win32.RegistryKey.CreateSubKey(System.String,System.Boolean)
  - Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,Microsoft.Win32.RegistryOptions)
  - Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,System.Security.AccessControl.RegistrySecurity)
  - Microsoft.Win32.RegistryKey.CreateSubKey(System.String,System.Boolean,Microsoft.Win32.RegistryOptions)
  - Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,Microsoft.Win32.RegistryOptions,System.Security.AccessControl.RegistrySecurity)
  - Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)
  - Microsoft.Win32.RegistryKey.DeleteSubKey(System.String,System.Boolean)
  - Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)
  - Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String,System.Boolean)
  - Microsoft.Win32.RegistryKey.DeleteValue(System.String)
  - Microsoft.Win32.RegistryKey.DeleteValue(System.String,System.Boolean)
  - Microsoft.Win32.RegistryKey.Dispose
  - Microsoft.Win32.RegistryKey.Flush
  - Microsoft.Win32.RegistryKey.FromHandle(Microsoft.Win32.SafeHandles.SafeRegistryHandle)
  - Microsoft.Win32.RegistryKey.FromHandle(Microsoft.Win32.SafeHandles.SafeRegistryHandle,Microsoft.Win32.RegistryView)
  - Microsoft.Win32.RegistryKey.GetAccessControl
  - Microsoft.Win32.RegistryKey.GetAccessControl(System.Security.AccessControl.AccessControlSections)
  - Microsoft.Win32.RegistryKey.GetSubKeyNames
  - Microsoft.Win32.RegistryKey.GetValue(System.String)
  - Microsoft.Win32.RegistryKey.GetValue(System.String,System.Object)
  - Microsoft.Win32.RegistryKey.GetValue(System.String,System.Object,Microsoft.Win32.RegistryValueOptions)
  - Microsoft.Win32.RegistryKey.GetValueKind(System.String)
  - Microsoft.Win32.RegistryKey.GetValueNames
  - Microsoft.Win32.RegistryKey.Handle
  - Microsoft.Win32.RegistryKey.Name
  - Microsoft.Win32.RegistryKey.OpenBaseKey(Microsoft.Win32.RegistryHive,Microsoft.Win32.RegistryView)
  - Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)
  - Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String,Microsoft.Win32.RegistryView)
  - Microsoft.Win32.RegistryKey.OpenSubKey(System.String)
  - Microsoft.Win32.RegistryKey.OpenSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck)
  - Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)
  - Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Security.AccessControl.RegistryRights)
  - Microsoft.Win32.RegistryKey.OpenSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,System.Security.AccessControl.RegistryRights)
  - Microsoft.Win32.RegistryKey.SetAccessControl(System.Security.AccessControl.RegistrySecurity)
  - Microsoft.Win32.RegistryKey.SetValue(System.String,System.Object)
  - Microsoft.Win32.RegistryKey.SetValue(System.String,System.Object,Microsoft.Win32.RegistryValueKind)
  - Microsoft.Win32.RegistryKey.SubKeyCount
  - Microsoft.Win32.RegistryKey.ToString
  - Microsoft.Win32.RegistryKey.ValueCount
  - Microsoft.Win32.RegistryKey.View
  langs:
  - csharp
  name: RegistryKey
  nameWithType: RegistryKey
  fullName: Microsoft.Win32.RegistryKey
  type: Class
  summary: "表示 Windows 注册表中的项级节点。 此类是注册表封装。"
  remarks: "To get an instance of RegistryKey, use one of the static members of the <xref:Microsoft.Win32.Registry> class.  \n  \n The registry acts as a central repository of information for the operating system and the applications on a computer. The registry is organized in a hierarchical format, based on a logical ordering of the elements stored within it (please see <xref:Microsoft.Win32.Registry> for the base-level items in this hierarchy). When storing information in the registry, select the appropriate location based on the type of information being stored. Be sure to avoid destroying information created by other applications, because this can cause those applications to exhibit unexpected behavior, and can also have an adverse effect upon your own application.  \n  \n> [!IMPORTANT]\n>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  \n  \n Registry keys are the base unit of organization in the registry, and can be compared to folders in File Explorer. A particular key can have subkeys, just as a folder can have subfolders. Each key can be deleted, as long as the user has the appropriate permissions to do so, and the key is not a base key or at the level directly under the base keys. Each key can also have multiple values associated with it (a value can be compared to a file), which are used to store the information — for example, information about an application installed on the computer. Each value holds one particular piece of information, which can be retrieved or updated when required. For instance, you can create a RegistryKey for your company, under the key HKEY_LOCAL_MACHINE\\Software, and then a subkey for each application that your company creates. Each subkey holds the information specific to that application, such as color settings, screen location and size, or recognized file extensions.  \n  \n Note that information stored in the registry is available to other applications and users, and therefore should not be used to store security data or critical application information.  \n  \n> [!CAUTION]\n>  Do not expose RegistryKey objects in such a way that a malicious program could create thousands of meaningless subkeys or key/value pairs. For example, do not allow callers to enter arbitrary keys or values.  \n  \n Starting in the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the length of a registry key is no longer limited to 255 characters."
  example:
  - "The following code example shows how to create a subkey under HKEY_CURRENT_USER, manipulate its contents, and then delete the subkey.  \n  \n [!code-cpp[Microsoft.Win32.RegistryKey2#1](~/add/codesnippet/cpp/t-microsoft.win32.regist_2_1.cpp)]\n [!code-cs[Microsoft.Win32.RegistryKey2#1](~/add/codesnippet/csharp/t-microsoft.win32.regist_2_1.cs)]\n [!code-vb[Microsoft.Win32.RegistryKey2#1](~/add/codesnippet/visualbasic/t-microsoft.win32.regist_2_1.vb)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class RegistryKey : MarshalByRefObject, IDisposable
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  implements:
  - System.IDisposable
  inheritedMembers:
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.Close
  id: Close
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: Close()
  nameWithType: RegistryKey.Close()
  fullName: Microsoft.Win32.RegistryKey.Close()
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "关闭该项并将其刷新到磁盘如果其内容进行了修改。"
  remarks: "在系统项上调用此方法不会产生不起作用，因为永远不会关闭系统密钥。       如果实例上调用的此方法不执行任何操作`RegistryKey`已关闭的。"
  example:
  - "This code example is part of a larger example provided for the <xref:Microsoft.Win32.RegistryKey> class.  \n  \n [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/add/codesnippet/cpp/m-microsoft.win32.regist_4_1.cpp)]\n [!code-cs[Microsoft.Win32.RegistryKey2#4](~/add/codesnippet/csharp/m-microsoft.win32.regist_4_1.cs)]\n [!code-vb[Microsoft.Win32.RegistryKey2#4](~/add/codesnippet/visualbasic/m-microsoft.win32.regist_4_1.vb)]"
  syntax:
    content: public void Close ();
    parameters: []
  overload: Microsoft.Win32.RegistryKey.Close*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.CreateSubKey(System.String)
  id: CreateSubKey(System.String)
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: CreateSubKey(String)
  nameWithType: RegistryKey.CreateSubKey(String)
  fullName: Microsoft.Win32.RegistryKey.CreateSubKey(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "创建一个新子项或打开一个现有子项以进行写访问。"
  remarks: "若要执行此操作，用户必须具有注册表层次结构中的权限在此级别和更低版本。      1> [!CAUTION]&1;> 不会公开<xref:Microsoft.Win32.RegistryKey>，恶意程序无法创建数千个无意义的子项或键/值对的方式的对象。</xref:Microsoft.Win32.RegistryKey> 例如，不允许调用方输入任意键或值。"
  example:
  - "The following code example shows how to create a subkey under HKEY_CURRENT_USER, manipulate its contents, and then delete the subkey.  \n  \n [!code-cpp[Microsoft.Win32.RegistryKey2#1](~/add/codesnippet/cpp/m-microsoft.win32.regist_15_1.cpp)]\n [!code-cs[Microsoft.Win32.RegistryKey2#1](~/add/codesnippet/csharp/m-microsoft.win32.regist_15_1.cs)]\n [!code-vb[Microsoft.Win32.RegistryKey2#1](~/add/codesnippet/visualbasic/m-microsoft.win32.regist_15_1.vb)]"
  syntax:
    content: public Microsoft.Win32.RegistryKey CreateSubKey (string subkey);
    parameters:
    - id: subkey
      type: System.String
      description: "名称或要创建或打开的子项的路径。 此字符串不区分大小写。"
    return:
      type: Microsoft.Win32.RegistryKey
      description: "新创建的子项中，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果操作失败。 如果一个零长度字符串，指定为<code> subkey </code>，当前<xref href=&quot;Microsoft.Win32.RegistryKey&quot;></xref>返回对象。"
  overload: Microsoft.Win32.RegistryKey.CreateSubKey*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>subkey</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有创建或打开注册表项所需的权限。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>上其调用此方法关闭 （不能访问已关闭的项）。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>无法写入; 例如，它不打开作为可写的键，或者用户没有必要的访问权限。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "嵌套级别超过 510 层。       -发生系统错误，例如删除了项，或者尝试创建中的键<xref href=&quot;Microsoft.Win32.Registry.LocalMachine&quot;></xref>根。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck)
  id: CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck)
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: CreateSubKey(String,RegistryKeyPermissionCheck)
  nameWithType: RegistryKey.CreateSubKey(String,RegistryKeyPermissionCheck)
  fullName: Microsoft.Win32.RegistryKey.CreateSubKey(String,RegistryKeyPermissionCheck)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "创建一个新子项或打开一个现有子项以进行写访问，使用指定的权限检查选项。"
  remarks: "若要执行此操作，用户必须具有注册表层次结构中的权限在此级别和更低版本。      1> [!CAUTION]&1;> 不会公开<xref:Microsoft.Win32.RegistryKey>，恶意程序无法创建数千个无意义的子项或键/值对的方式的对象。</xref:Microsoft.Win32.RegistryKey> 例如，不允许调用方输入任意键或值。       若要使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法，你必须有<xref:Microsoft.Win32.RegistryKey>类</xref:Microsoft.Win32.RegistryKey>的实例</xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 若要获取其实例<xref:Microsoft.Win32.RegistryKey>，请使用<xref:Microsoft.Win32.Registry>类</xref:Microsoft.Win32.Registry>的静态成员之一</xref:Microsoft.Win32.RegistryKey>"
  syntax:
    content: public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck);
    parameters:
    - id: subkey
      type: System.String
      description: "名称或要创建或打开的子项的路径。 此字符串不区分大小写。"
    - id: permissionCheck
      type: Microsoft.Win32.RegistryKeyPermissionCheck
      description: "一个枚举值，用于指定打开该项是是否进行读取或读/写访问。"
    return:
      type: Microsoft.Win32.RegistryKey
      description: "新创建的子项中，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果操作失败。 如果一个零长度字符串，指定为<code> subkey </code>，当前<xref href=&quot;Microsoft.Win32.RegistryKey&quot;></xref>返回对象。"
  overload: Microsoft.Win32.RegistryKey.CreateSubKey*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>subkey</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有创建或打开注册表项所需的权限。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>permissionCheck</code>包含无效值。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>上其调用此方法关闭 （不能访问已关闭的项）。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>无法写入; 例如，它不打开作为可写的键，或者用户没有必要的访问权限。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "嵌套级别超过 510 层。       -发生系统错误，例如删除了项，或者尝试创建中的键<xref href=&quot;Microsoft.Win32.Registry.LocalMachine&quot;></xref>根。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.CreateSubKey(System.String,System.Boolean)
  id: CreateSubKey(System.String,System.Boolean)
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: CreateSubKey(String,Boolean)
  nameWithType: RegistryKey.CreateSubKey(String,Boolean)
  fullName: Microsoft.Win32.RegistryKey.CreateSubKey(String,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "创建一个新子项或打开一个现有子项的指定访问权限。       可以开始于[!INCLUDE[net_v46](~/add/includes/net-v46-md.md)]"
  remarks: "若要执行此操作，用户必须具有注册表层次结构中的权限在此级别和更低版本。      1> [!CAUTION]&1;> 不会公开<xref:Microsoft.Win32.RegistryKey>，恶意程序无法创建数千个无意义的子项或键/值对的方式的对象。</xref:Microsoft.Win32.RegistryKey> 例如，不允许调用方输入任意键或值。       若要使用 CreateSubKey 方法，你必须有<xref:Microsoft.Win32.RegistryKey>类</xref:Microsoft.Win32.RegistryKey>的实例 若要获取其实例<xref:Microsoft.Win32.RegistryKey>，请使用<xref:Microsoft.Win32.Registry>类</xref:Microsoft.Win32.Registry>的静态成员之一</xref:Microsoft.Win32.RegistryKey>"
  syntax:
    content: public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, bool writable);
    parameters:
    - id: subkey
      type: System.String
      description: "名称或要创建或打开的子项的路径。 此字符串不区分大小写。"
    - id: writable
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要指示新子项可写;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    return:
      type: Microsoft.Win32.RegistryKey
      description: "新创建的子项中，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果操作失败。 如果一个零长度字符串，指定为<code> subkey </code>，当前<xref href=&quot;Microsoft.Win32.RegistryKey&quot;></xref>返回对象。"
  overload: Microsoft.Win32.RegistryKey.CreateSubKey*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>subkey</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有创建或打开注册表项所需的权限。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "当前<xref href=&quot;Microsoft.Win32.RegistryKey&quot;></xref>无法写入; 例如，它不打开作为可写的键，或者用户没有必要的访问权限。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "嵌套级别超过 510 层。       -发生系统错误，例如删除了项，或者尝试创建中的键<xref href=&quot;Microsoft.Win32.Registry.LocalMachine&quot;></xref>根。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,Microsoft.Win32.RegistryOptions)
  id: CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,Microsoft.Win32.RegistryOptions)
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: CreateSubKey(String,RegistryKeyPermissionCheck,RegistryOptions)
  nameWithType: RegistryKey.CreateSubKey(String,RegistryKeyPermissionCheck,RegistryOptions)
  fullName: Microsoft.Win32.RegistryKey.CreateSubKey(String,RegistryKeyPermissionCheck,RegistryOptions)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "创建一个子项或打开子项以进行写访问，使用指定的权限检查和注册表选项。"
  remarks: "若要获取当前<xref:Microsoft.Win32.RegistryKey>对象，请指定一个空字符串 (&quot;&quot;) 为`subkey`。</xref:Microsoft.Win32.RegistryKey>"
  syntax:
    content: public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, Microsoft.Win32.RegistryOptions options);
    parameters:
    - id: subkey
      type: System.String
      description: "名称或要创建或打开的子项的路径。"
    - id: permissionCheck
      type: Microsoft.Win32.RegistryKeyPermissionCheck
      description: "一个枚举值，用于指定打开该项是是否进行读取或读/写访问。"
    - id: options
      type: Microsoft.Win32.RegistryOptions
      description: "要使用; 的注册表选项例如，创建易失性的键。"
    return:
      type: Microsoft.Win32.RegistryKey
      description: "新创建的子项中，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果操作失败。"
  overload: Microsoft.Win32.RegistryKey.CreateSubKey*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>subkey </code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "当前<xref href=&quot;Microsoft.Win32.RegistryKey&quot;></xref>对象已关闭 （不能访问已关闭的项）。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "当前<xref href=&quot;Microsoft.Win32.RegistryKey&quot;></xref>无法写入到的对象; 例如，它不打开作为可写的键，或用户没有所需的访问权限。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "嵌套级别超过 510 层。       -发生系统错误，例如删除密钥或尝试创建中的键<xref href=&quot;Microsoft.Win32.Registry.LocalMachine&quot;></xref>根。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有创建或打开注册表项所需的权限。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,System.Security.AccessControl.RegistrySecurity)
  id: CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,System.Security.AccessControl.RegistrySecurity)
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: CreateSubKey(String,RegistryKeyPermissionCheck,RegistrySecurity)
  nameWithType: RegistryKey.CreateSubKey(String,RegistryKeyPermissionCheck,RegistrySecurity)
  fullName: Microsoft.Win32.RegistryKey.CreateSubKey(String,RegistryKeyPermissionCheck,RegistrySecurity)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "创建一个新子项或打开一个现有子项以进行写访问，使用指定的权限检查选项和注册表安全性。"
  remarks: "CreateSubKey 方法创建一个具有指定的访问控制的注册表项`registrySecurity`参数。 <xref:Microsoft.Win32.RegistryKey>返回对象表示的注册表项，但该对象不受中指定的访问控制`registrySecurity`参数。</xref:Microsoft.Win32.RegistryKey>       如果`permissionCheck`是<xref:Microsoft.Win32.RegistryKeyPermissionCheck?displayProperty=fullName>，则打开该项进行读/写访问。</xref:Microsoft.Win32.RegistryKeyPermissionCheck?displayProperty=fullName> 如果`permissionCheck`是<xref:Microsoft.Win32.RegistryKeyPermissionCheck?displayProperty=fullName>，打开该项是进行读取访问。</xref:Microsoft.Win32.RegistryKeyPermissionCheck?displayProperty=fullName>       用于读取和写入如果打开该项是为了向后兼容， `permissionCheck` ，而且<xref:Microsoft.Win32.RegistryKeyPermissionCheck?displayProperty=fullName>父项还具有<xref:Microsoft.Win32.RegistryKeyPermissionCheck?displayProperty=fullName>.</xref:Microsoft.Win32.RegistryKeyPermissionCheck?displayProperty=fullName> </xref:Microsoft.Win32.RegistryKeyPermissionCheck?displayProperty=fullName> 如果父项具有任何其他设置，由父项的设置控制读/写状态。       若要执行此操作，用户必须注册表层次结构中具有此级别和更低的权限。      1> [!CAUTION]&1;> 不会公开<xref:Microsoft.Win32.RegistryKey>，恶意程序无法创建数千个无意义的子项或键/值对的方式的对象。</xref:Microsoft.Win32.RegistryKey> 例如，不允许调用方输入任意键或值。       若要使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法，你必须有<xref:Microsoft.Win32.RegistryKey>类</xref:Microsoft.Win32.RegistryKey>的实例</xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 若要获取其实例<xref:Microsoft.Win32.RegistryKey>，请使用<xref:Microsoft.Win32.Registry>类</xref:Microsoft.Win32.Registry>的静态成员之一</xref:Microsoft.Win32.RegistryKey>"
  syntax:
    content: public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, System.Security.AccessControl.RegistrySecurity registrySecurity);
    parameters:
    - id: subkey
      type: System.String
      description: "名称或要创建或打开的子项的路径。 此字符串不区分大小写。"
    - id: permissionCheck
      type: Microsoft.Win32.RegistryKeyPermissionCheck
      description: "一个枚举值，用于指定打开该项是是否进行读取或读/写访问。"
    - id: registrySecurity
      type: System.Security.AccessControl.RegistrySecurity
      description: "新的密钥访问控制安全性。"
    return:
      type: Microsoft.Win32.RegistryKey
      description: "新创建的子项中，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果操作失败。 如果一个零长度字符串，指定为<code> subkey </code>，当前<xref href=&quot;Microsoft.Win32.RegistryKey&quot;></xref>返回对象。"
  overload: Microsoft.Win32.RegistryKey.CreateSubKey*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>subkey</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有创建或打开注册表项所需的权限。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>permissionCheck</code>包含无效值。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>上其调用此方法关闭 （不能访问已关闭的项）。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "当前<xref href=&quot;Microsoft.Win32.RegistryKey&quot;></xref>无法写入; 例如，它不打开作为可写的键，或者用户没有必要的访问权限。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "嵌套级别超过 510 层。       -发生系统错误，例如删除了项，或者尝试创建中的键<xref href=&quot;Microsoft.Win32.Registry.LocalMachine&quot;></xref>根。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.CreateSubKey(System.String,System.Boolean,Microsoft.Win32.RegistryOptions)
  id: CreateSubKey(System.String,System.Boolean,Microsoft.Win32.RegistryOptions)
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: CreateSubKey(String,Boolean,RegistryOptions)
  nameWithType: RegistryKey.CreateSubKey(String,Boolean,RegistryOptions)
  fullName: Microsoft.Win32.RegistryKey.CreateSubKey(String,Boolean,RegistryOptions)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "创建一个新子项或打开一个现有子项的指定访问权限。       可以开始于[!INCLUDE[net_v46](~/add/includes/net-v46-md.md)]"
  remarks: "若要执行此操作，用户必须具有注册表层次结构中的权限在此级别和更低版本。      1> [!CAUTION]&1;> 不会公开<xref:Microsoft.Win32.RegistryKey>，恶意程序无法创建数千个无意义的子项或键/值对的方式的对象。</xref:Microsoft.Win32.RegistryKey> 例如，不允许调用方输入任意键或值。       若要使用 CreateSubKey 方法，你必须有<xref:Microsoft.Win32.RegistryKey>类</xref:Microsoft.Win32.RegistryKey>的实例 若要获取其实例<xref:Microsoft.Win32.RegistryKey>，请使用<xref:Microsoft.Win32.Registry>类</xref:Microsoft.Win32.Registry>的静态成员之一</xref:Microsoft.Win32.RegistryKey>"
  syntax:
    content: public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, bool writable, Microsoft.Win32.RegistryOptions options);
    parameters:
    - id: subkey
      type: System.String
      description: "名称或要创建或打开的子项的路径。 此字符串不区分大小写。"
    - id: writable
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要指示新子项可写;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    - id: options
      type: Microsoft.Win32.RegistryOptions
      description: "要使用的注册表选项。"
    return:
      type: Microsoft.Win32.RegistryKey
      description: "新创建的子项中，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果操作失败。 如果一个零长度字符串，指定为<code> subkey </code>，当前<xref href=&quot;Microsoft.Win32.RegistryKey&quot;></xref>返回对象。"
  overload: Microsoft.Win32.RegistryKey.CreateSubKey*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>subkey</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>options</code>未指定有效的选项"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有创建或打开注册表项所需的权限。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "当前<xref href=&quot;Microsoft.Win32.RegistryKey&quot;></xref>无法写入; 例如，它不打开作为可写的键，或者用户没有必要的访问权限。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "嵌套级别超过 510 层。       -发生系统错误，例如删除了项，或者尝试创建中的键<xref href=&quot;Microsoft.Win32.Registry.LocalMachine&quot;></xref>根。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,Microsoft.Win32.RegistryOptions,System.Security.AccessControl.RegistrySecurity)
  id: CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,Microsoft.Win32.RegistryOptions,System.Security.AccessControl.RegistrySecurity)
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: CreateSubKey(String,RegistryKeyPermissionCheck,RegistryOptions,RegistrySecurity)
  nameWithType: RegistryKey.CreateSubKey(String,RegistryKeyPermissionCheck,RegistryOptions,RegistrySecurity)
  fullName: Microsoft.Win32.RegistryKey.CreateSubKey(String,RegistryKeyPermissionCheck,RegistryOptions,RegistrySecurity)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "创建一个子项或打开以进行写访问，使用指定的权限检查选项、 注册表选项和注册表安全子项。"
  remarks: "若要获取当前<xref:Microsoft.Win32.RegistryKey>对象，请指定一个空字符串 (&quot;&quot;) 为`subkey`。</xref:Microsoft.Win32.RegistryKey>"
  syntax:
    content: public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, Microsoft.Win32.RegistryOptions registryOptions, System.Security.AccessControl.RegistrySecurity registrySecurity);
    parameters:
    - id: subkey
      type: System.String
      description: "名称或要创建或打开的子项的路径。"
    - id: permissionCheck
      type: Microsoft.Win32.RegistryKeyPermissionCheck
      description: "一个枚举值，用于指定打开该项是是否进行读取或读/写访问。"
    - id: registryOptions
      type: Microsoft.Win32.RegistryOptions
      description: "要使用的注册表选项。"
    - id: registrySecurity
      type: System.Security.AccessControl.RegistrySecurity
      description: "新的子项访问控制安全性。"
    return:
      type: Microsoft.Win32.RegistryKey
      description: "新创建的子项中，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果操作失败。"
  overload: Microsoft.Win32.RegistryKey.CreateSubKey*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>subkey </code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "当前<xref href=&quot;Microsoft.Win32.RegistryKey&quot;></xref>对象已关闭。 无法访问已关闭的项。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "当前<xref href=&quot;Microsoft.Win32.RegistryKey&quot;></xref>无法写入到的对象; 例如，它不打开作为可写的键，或用户没有所需的访问权限。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "嵌套级别超过 510 层。       -发生系统错误，例如删除密钥或尝试创建中的键<xref href=&quot;Microsoft.Win32.Registry.LocalMachine&quot;></xref>根。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有创建或打开注册表项所需的权限。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)
  id: DeleteSubKey(System.String)
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: DeleteSubKey(String)
  nameWithType: RegistryKey.DeleteSubKey(String)
  fullName: Microsoft.Win32.RegistryKey.DeleteSubKey(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "删除指定的子项。"
  remarks: "若要删除子子项，请使用<xref:Microsoft.Win32.RegistryKey.DeleteSubKeyTree%2A>。</xref:Microsoft.Win32.RegistryKey.DeleteSubKeyTree%2A>       正在删除注册表项时要格外小心。"
  example:
  - "The following example demonstrates how to use DeleteSubKey.  \n  \n [!code-cpp[Microsoft.Win32.RegistryKey2#5](~/add/codesnippet/cpp/m-microsoft.win32.regist_5_1.cpp)]\n [!code-cs[Microsoft.Win32.RegistryKey2#5](~/add/codesnippet/csharp/m-microsoft.win32.regist_5_1.cs)]\n [!code-vb[Microsoft.Win32.RegistryKey2#5](~/add/codesnippet/visualbasic/m-microsoft.win32.regist_5_1.vb)]"
  syntax:
    content: public void DeleteSubKey (string subkey);
    parameters:
    - id: subkey
      type: System.String
      description: "要删除的子项名称。 此字符串不区分大小写。"
  overload: Microsoft.Win32.RegistryKey.DeleteSubKey*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code> subkey </code>有子级子项"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> subkey </code>参数未指定有效的注册表项"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>subkey</code>是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有删除注册表项所需的权限。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>操作关闭 （不能访问已关闭的项）。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "用户没有必要的注册表权限。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.DeleteSubKey(System.String,System.Boolean)
  id: DeleteSubKey(System.String,System.Boolean)
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: DeleteSubKey(String,Boolean)
  nameWithType: RegistryKey.DeleteSubKey(String,Boolean)
  fullName: Microsoft.Win32.RegistryKey.DeleteSubKey(String,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "删除指定的子项，并指定在找不到子项时是否引发异常。"
  remarks: "若要删除子子项，请使用<xref:Microsoft.Win32.RegistryKey.DeleteSubKeyTree%2A>。</xref:Microsoft.Win32.RegistryKey.DeleteSubKeyTree%2A>       正在删除注册表项时要格外小心。"
  syntax:
    content: public void DeleteSubKey (string subkey, bool throwOnMissingSubKey);
    parameters:
    - id: subkey
      type: System.String
      description: "要删除的子项名称。 此字符串不区分大小写。"
    - id: throwOnMissingSubKey
      type: System.Boolean
      description: "指示是否应引发异常，是否找不到指定的子项。 如果此参数为<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>和指定的子项不存在，则将引发异常。 如果此参数为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>和指定的子项不存在，则不执行任何操作。"
  overload: Microsoft.Win32.RegistryKey.DeleteSubKey*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>subkey</code>有子级子项。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>subkey</code>未指定有效的注册表项，和<code>throwOnMissingSubKey</code>是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>subkey</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有删除注册表项所需的权限。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>操作关闭 （不能访问已关闭的项）。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "用户没有必要的注册表权限。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)
  id: DeleteSubKeyTree(System.String)
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: DeleteSubKeyTree(String)
  nameWithType: RegistryKey.DeleteSubKeyTree(String)
  fullName: Microsoft.Win32.RegistryKey.DeleteSubKeyTree(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "删除子项和任何子子项以递归方式。"
  remarks: "你必须具有适当权限才能删除该子项和其树。      1> [!CAUTION]&1;> 删除特定密钥将在树中删除该项下的所有条目。 将不提供任何警告。 如果你想要仅当不有任何子级子项，使用时删除子项<xref:Microsoft.Win32.RegistryKey.DeleteSubKey%2A>方法。</xref:Microsoft.Win32.RegistryKey.DeleteSubKey%2A>"
  example:
  - "This code example is part of a larger example provided for the <xref:Microsoft.Win32.RegistryKey> class.  \n  \n [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/add/codesnippet/cpp/m-microsoft.win32.regist_12_1.cpp)]\n [!code-cs[Microsoft.Win32.RegistryKey2#4](~/add/codesnippet/csharp/m-microsoft.win32.regist_12_1.cs)]\n [!code-vb[Microsoft.Win32.RegistryKey2#4](~/add/codesnippet/visualbasic/m-microsoft.win32.regist_12_1.vb)]"
  syntax:
    content: public void DeleteSubKeyTree (string subkey);
    parameters:
    - id: subkey
      type: System.String
      description: "要删除的子项。 此字符串不区分大小写。"
  overload: Microsoft.Win32.RegistryKey.DeleteSubKeyTree*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>subkey</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "试图删除根配置单元。       - <code> subkey </code>未指定有效的注册表子项。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "发生了 I/O 错误。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有删除注册表项所需的权限。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>操作关闭 （不能访问已关闭的项）。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "用户没有必要的注册表权限。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String,System.Boolean)
  id: DeleteSubKeyTree(System.String,System.Boolean)
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: DeleteSubKeyTree(String,Boolean)
  nameWithType: RegistryKey.DeleteSubKeyTree(String,Boolean)
  fullName: Microsoft.Win32.RegistryKey.DeleteSubKeyTree(String,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "删除指定的子项和任何子子项以递归方式，并指定在找不到子项时是否引发异常。"
  syntax:
    content: public void DeleteSubKeyTree (string subkey, bool throwOnMissingSubKey);
    parameters:
    - id: subkey
      type: System.String
      description: "要删除的子项名称。 此字符串不区分大小写。"
    - id: throwOnMissingSubKey
      type: System.Boolean
      description: "指示是否应引发异常，是否找不到指定的子项。 如果此参数为<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>和指定的子项不存在，则将引发异常。 如果此参数为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>和指定的子项不存在，则不执行任何操作。"
  overload: Microsoft.Win32.RegistryKey.DeleteSubKeyTree*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "尝试删除的树的根配置单元。       - <code> subkey </code>未指定有效的注册表子项，和<code> throwOnMissingSubKey </code>是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>subkey</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>关闭 （不能访问已关闭的项）。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "用户没有必要的注册表权限。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有删除注册表项所需的权限。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.DeleteValue(System.String)
  id: DeleteValue(System.String)
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: DeleteValue(String)
  nameWithType: RegistryKey.DeleteValue(String)
  fullName: Microsoft.Win32.RegistryKey.DeleteValue(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "从此项中删除指定的值。"
  remarks: "在 Windows 95、 Windows 98、 Windows 98 Second Edition 和 Windows Millennium Edition 上，指定为空字符串`name`参数不会删除默认值。"
  example:
  - "This code example is part of a larger example provided for the <xref:Microsoft.Win32.RegistryKey> class.  \n  \n [!code-cpp[Microsoft.Win32.RegistryKey2#3](~/add/codesnippet/cpp/m-microsoft.win32.regist_13_1.cpp)]\n [!code-cs[Microsoft.Win32.RegistryKey2#3](~/add/codesnippet/csharp/m-microsoft.win32.regist_13_1.cs)]\n [!code-vb[Microsoft.Win32.RegistryKey2#3](~/add/codesnippet/visualbasic/m-microsoft.win32.regist_13_1.vb)]"
  syntax:
    content: public void DeleteValue (string name);
    parameters:
    - id: name
      type: System.String
      description: "要删除的值的名称。"
  overload: Microsoft.Win32.RegistryKey.DeleteValue*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>name</code>不是对一个值的有效引用。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有删除值所需的权限。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>操作关闭 （不能访问已关闭的项）。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>操作是只读的。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.DeleteValue(System.String,System.Boolean)
  id: DeleteValue(System.String,System.Boolean)
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: DeleteValue(String,Boolean)
  nameWithType: RegistryKey.DeleteValue(String,Boolean)
  fullName: Microsoft.Win32.RegistryKey.DeleteValue(String,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "删除指定的值从此密钥，并指定在找不到值时是否引发异常。"
  remarks: "如果`throwOnMissingValue`是`false`，没有方法来告诉删除是否成功，而无需随后尝试访问刚删除的值。 因此，从这种方式注册表中删除值时要谨慎。       在 Windows 95、 Windows 98、 Windows 98 Second Edition 和 Windows Millennium Edition 上，指定为空字符串`name`参数不会删除默认值。"
  syntax:
    content: public void DeleteValue (string name, bool throwOnMissingValue);
    parameters:
    - id: name
      type: System.String
      description: "要删除的值的名称。"
    - id: throwOnMissingValue
      type: System.Boolean
      description: "指示是否找不到指定的值是否应引发异常。 如果此参数为<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>和指定的值不存在，则将引发异常。 如果此参数为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>和指定的值不存在，则不执行任何操作。"
  overload: Microsoft.Win32.RegistryKey.DeleteValue*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>name</code>不是对一个值的有效引用和<code>throwOnMissingValue</code>是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。       -or-       <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有删除值所需的权限。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>操作关闭 （不能访问已关闭的项）。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>操作是只读的。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.Dispose
  id: Dispose
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: Dispose()
  nameWithType: RegistryKey.Dispose()
  fullName: Microsoft.Win32.RegistryKey.Dispose()
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "释放当前实例所使用的所有资源<xref href=&quot;Microsoft.Win32.RegistryKey&quot;></xref>类。"
  remarks: "调用`Dispose`在完成使用<xref:Microsoft.Win32.RegistryKey>.</xref:Microsoft.Win32.RegistryKey>时 `Dispose`方法使<xref:Microsoft.Win32.RegistryKey>中不可用状态。</xref:Microsoft.Win32.RegistryKey> 在调用`Dispose`，必须释放对所有引用<xref:Microsoft.Win32.RegistryKey>以便垃圾回收器才能回收的内存，<xref:Microsoft.Win32.RegistryKey>占用。</xref:Microsoft.Win32.RegistryKey> </xref:Microsoft.Win32.RegistryKey>       有关详细信息，请参阅[清洗向上非托管资源](~/add/includes/ajax-current-ext-md.md)和[实现 Dispose 方法](~/add/includes/ajax-current-ext-md.md)。      1> [!NOTE]&1;> 始终调用`Dispose`在发布到<xref:Microsoft.Win32.RegistryKey>。</xref:Microsoft.Win32.RegistryKey>最后一个引用之前 否则，它所使用的资源之前，不会释放垃圾回收器调用<xref:Microsoft.Win32.RegistryKey>对象的`Finalize`方法。</xref:Microsoft.Win32.RegistryKey>"
  syntax:
    content: public void Dispose ();
    parameters: []
  overload: Microsoft.Win32.RegistryKey.Dispose*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.Flush
  id: Flush
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: Flush()
  nameWithType: RegistryKey.Flush()
  fullName: Microsoft.Win32.RegistryKey.Flush()
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "将指定的打开注册表项的所有属性都写入到注册表。"
  remarks: "不需要调用`Flush`写出对项的更改。 注册表更改刷新到磁盘时注册表使用其惰性刷新器。 系统指定的时间间隔后，惰性刷新则会自动地定期。 注册表更改也会刷新到磁盘上的系统关闭。       与不同<xref:Microsoft.Win32.RegistryKey.Close%2A>、`Flush`函数将返回仅当所有数据已都写入到注册表。</xref:Microsoft.Win32.RegistryKey.Close%2A>       `Flush`函数还可能写出的部分或所有其他键。 过度调用此函数可以产生负面影响对应用程序的性能。       应用程序应只调用`Flush`如果它必须是绝对某些注册表更改记录到磁盘。 一般情况下，`Flush`极少数情况下，需要使用如果曾经。"
  syntax:
    content: public void Flush ();
    parameters: []
  overload: Microsoft.Win32.RegistryKey.Flush*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.FromHandle(Microsoft.Win32.SafeHandles.SafeRegistryHandle)
  id: FromHandle(Microsoft.Win32.SafeHandles.SafeRegistryHandle)
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: FromHandle(SafeRegistryHandle)
  nameWithType: RegistryKey.FromHandle(SafeRegistryHandle)
  fullName: Microsoft.Win32.RegistryKey.FromHandle(SafeRegistryHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "从指定的句柄创建注册表项。"
  syntax:
    content: public static Microsoft.Win32.RegistryKey FromHandle (Microsoft.Win32.SafeHandles.SafeRegistryHandle handle);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeRegistryHandle
      description: "注册表项的句柄。"
    return:
      type: Microsoft.Win32.RegistryKey
      description: "注册表项。"
  overload: Microsoft.Win32.RegistryKey.FromHandle*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>handle</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "用户没有必要的注册表权限。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有执行此操作所需的权限。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.FromHandle(Microsoft.Win32.SafeHandles.SafeRegistryHandle,Microsoft.Win32.RegistryView)
  id: FromHandle(Microsoft.Win32.SafeHandles.SafeRegistryHandle,Microsoft.Win32.RegistryView)
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: FromHandle(SafeRegistryHandle,RegistryView)
  nameWithType: RegistryKey.FromHandle(SafeRegistryHandle,RegistryView)
  fullName: Microsoft.Win32.RegistryKey.FromHandle(SafeRegistryHandle,RegistryView)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "从指定的句柄和注册表视图设置创建注册表项。"
  remarks: "`view`在后续操作，例如，打开子项中使用此方法的参数。       如果`view`是<xref:Microsoft.Win32.RegistryView>但计算机运行 32 位操作系统上，则返回的键将使用<xref:Microsoft.Win32.RegistryView>视图。</xref:Microsoft.Win32.RegistryView> </xref:Microsoft.Win32.RegistryView>"
  syntax:
    content: public static Microsoft.Win32.RegistryKey FromHandle (Microsoft.Win32.SafeHandles.SafeRegistryHandle handle, Microsoft.Win32.RegistryView view);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeRegistryHandle
      description: "注册表项的句柄。"
    - id: view
      type: Microsoft.Win32.RegistryView
      description: "要使用的注册表视图。"
    return:
      type: Microsoft.Win32.RegistryKey
      description: "注册表项。"
  overload: Microsoft.Win32.RegistryKey.FromHandle*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>view</code>是无效的。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>handle</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "用户没有必要的注册表权限。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有执行此操作所需的权限。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.GetAccessControl
  id: GetAccessControl
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: GetAccessControl()
  nameWithType: RegistryKey.GetAccessControl()
  fullName: Microsoft.Win32.RegistryKey.GetAccessControl()
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "返回当前注册表项的访问控制安全性。"
  remarks: "此方法重载是等效于调用<xref:Microsoft.Win32.RegistryKey.GetAccessControl%28System.Security.AccessControl.AccessControlSections%29>带有以下标志的按位组合的方法重载︰ <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>， <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>，和<xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>。</xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName> </xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName> </xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName> </xref:Microsoft.Win32.RegistryKey.GetAccessControl%28System.Security.AccessControl.AccessControlSections%29> 该重载可用于搜索其他权限。       用户必须具有<xref:System.Security.AccessControl.RegistryRights?displayProperty=fullName>权限才能调用此方法。</xref:System.Security.AccessControl.RegistryRights?displayProperty=fullName>"
  syntax:
    content: public System.Security.AccessControl.RegistrySecurity GetAccessControl ();
    parameters: []
    return:
      type: System.Security.AccessControl.RegistrySecurity
      description: "一个对象，表示由当前的注册表项中描述的访问控制权限<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>。"
  overload: Microsoft.Win32.RegistryKey.GetAccessControl*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有所需的权限。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>操作关闭 （不能访问已关闭的项）。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "当前项已被删除。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.GetAccessControl(System.Security.AccessControl.AccessControlSections)
  id: GetAccessControl(System.Security.AccessControl.AccessControlSections)
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: GetAccessControl(AccessControlSections)
  nameWithType: RegistryKey.GetAccessControl(AccessControlSections)
  fullName: Microsoft.Win32.RegistryKey.GetAccessControl(AccessControlSections)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "返回当前注册表项的访问控制安全性的指定的部分。"
  remarks: "若要请求当前授予用户的访问权限，指定以下标志的按位组合︰ <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>， <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>，和<xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>。</xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName> </xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName> </xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName> 或者，可以使用<xref:Microsoft.Win32.RegistryKey.GetAccessControl>方法重载，它指定确切的值的组合。</xref:Microsoft.Win32.RegistryKey.GetAccessControl>       用户必须具有<xref:System.Security.AccessControl.RegistryRights?displayProperty=fullName>权限才能调用此方法。</xref:System.Security.AccessControl.RegistryRights?displayProperty=fullName>"
  syntax:
    content: public System.Security.AccessControl.RegistrySecurity GetAccessControl (System.Security.AccessControl.AccessControlSections includeSections);
    parameters:
    - id: includeSections
      type: System.Security.AccessControl.AccessControlSections
      description: "枚举值的按位组合，指定的安全信息，若要获取的类型。"
    return:
      type: System.Security.AccessControl.RegistrySecurity
      description: "一个对象，表示由当前的注册表项中描述的访问控制权限<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>。"
  overload: Microsoft.Win32.RegistryKey.GetAccessControl*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有所需的权限。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>操作关闭 （不能访问已关闭的项）。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "当前项已被删除。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.GetSubKeyNames
  id: GetSubKeyNames
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: GetSubKeyNames()
  nameWithType: RegistryKey.GetSubKeyNames()
  fullName: Microsoft.Win32.RegistryKey.GetSubKeyNames()
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "检索包含所有子项的名称的字符串数组。"
  remarks: "此方法执行不是以递归方式查找名称。 它调用它的基级上返回的名称。"
  example:
  - "This code example is part of a larger example provided for the <xref:Microsoft.Win32.RegistryKey> class.  \n  \n [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/add/codesnippet/cpp/m-microsoft.win32.regist_7_1.cpp)]\n [!code-cs[Microsoft.Win32.RegistryKey2#2](~/add/codesnippet/csharp/m-microsoft.win32.regist_7_1.cs)]\n [!code-vb[Microsoft.Win32.RegistryKey2#2](~/add/codesnippet/visualbasic/m-microsoft.win32.regist_7_1.vb)]"
  syntax:
    content: public string[] GetSubKeyNames ();
    parameters: []
    return:
      type: System.String[]
      description: "包含当前项的子项的名称的字符串数组。"
  overload: Microsoft.Win32.RegistryKey.GetSubKeyNames*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有从注册表项读取所需的权限。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>操作关闭 （不能访问已关闭的项）。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "用户没有必要的注册表权限。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "出现系统错误，例如当前项已被删除。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.GetValue(System.String)
  id: GetValue(System.String)
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: GetValue(String)
  nameWithType: RegistryKey.GetValue(String)
  fullName: Microsoft.Win32.RegistryKey.GetValue(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "检索具有指定名称关联的值。 返回<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果注册表中不存在的名称/值对。"
  remarks: "> [!NOTE]1> 注册表项可以具有不与任何名称关联的一个值。 在注册表编辑器中显示了此未命名的值，而不是名称将显示字符串&quot;（默认值）&quot;。 若要检索此未命名的值，指定`null`或为空字符串 (&quot;&quot;) 为`name`。       GetValue 方法检索可扩展字符串值时 (<xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName>)，它就会展开环境字符串使用本地环境中的数据。</xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName> 若要从远程计算机上的注册表中检索可扩展字符串值，使用<xref:Microsoft.Win32.RegistryKey.GetValue%28System.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueOptions%29>方法重载来指定不希望展开环境字符串。</xref:Microsoft.Win32.RegistryKey.GetValue%28System.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueOptions%29>      1> [!NOTE]&1;> 如果包含对环境变量的可展开引用的值已存储为 string (<xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName>)，而不是可扩展字符串 (<xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName>)，GetValue 不展开它。</xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName> </xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName> 已检索到它通过调用后，你可以展开此类字符串<xref:System.Environment.ExpandEnvironmentVariables%2A>方法。</xref:System.Environment.ExpandEnvironmentVariables%2A>      1> [!NOTE]&1;> 要从中检索数据的建议的方法<xref:Microsoft.Win32.Registry.PerformanceData>密钥是使用<xref:System.Diagnostics.PerformanceCounter>类而不是<xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=fullName>方法。</xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=fullName> </xref:System.Diagnostics.PerformanceCounter> </xref:Microsoft.Win32.Registry.PerformanceData>   >> GetValue 不支持类型 REG_NONE 或 REG_LINK 读取的值。  在这两种情况下，默认值 (`null`) 返回而不是实际值。"
  example:
  - "The following code example creates a test key and adds values of different data types to the key. The example then reads the name/value pairs and displays them to the console, using the <xref:Microsoft.Win32.RegistryKey.GetValueKind%2A> method to retrieve the corresponding registry data types.  \n  \n [!code-cpp[Microsoft.Win32.RegistryValueKind#1](~/add/codesnippet/cpp/m-microsoft.win32.regist_3_1.cpp)]\n [!code-cs[Microsoft.Win32.RegistryValueKind#1](~/add/codesnippet/csharp/m-microsoft.win32.regist_3_1.cs)]\n [!code-vb[Microsoft.Win32.RegistryValueKind#1](~/add/codesnippet/visualbasic/m-microsoft.win32.regist_3_1.vb)]"
  syntax:
    content: public object GetValue (string name);
    parameters:
    - id: name
      type: System.String
      description: "要检索的值的名称。 此字符串不区分大小写。"
    return:
      type: System.Object
      description: "与关联的值<code> name </code>，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果<code> name </code>找不到。"
  overload: Microsoft.Win32.RegistryKey.GetValue*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有读取注册表项所需的权限。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref> ，该字符串包含指定值为已关闭 （不能访问已关闭的项）。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref> ，该字符串包含指定值已标记为删除。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "用户没有必要的注册表权限。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.GetValue(System.String,System.Object)
  id: GetValue(System.String,System.Object)
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: GetValue(String,Object)
  nameWithType: RegistryKey.GetValue(String,Object)
  fullName: Microsoft.Win32.RegistryKey.GetValue(String,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "检索具有指定名称关联的值。 如果未找到的名称，将返回你提供的默认值。"
  remarks: "请使用此重载<xref:Microsoft.Win32.RegistryKey.GetValue%2A>以处理其中尚不存在名称的情况-例如，首次运行你的应用程序。</xref:Microsoft.Win32.RegistryKey.GetValue%2A> 每当调用此重载时，使用`defaultValue`参数来指定要返回如果的值`name`不存在。      1> [!NOTE]&1;> 注册表项可以具有不与任何名称关联的一个值。 在注册表编辑器中显示了此未命名的值，而不是名称将显示字符串&quot;（默认值）&quot;。 若要检索此未命名的值，指定`null`或为空字符串 (&quot;&quot;) 为`name`。       当<xref:Microsoft.Win32.RegistryKey.GetValue%2A>方法检索可扩展字符串值 (<xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName>)，它就会展开环境字符串使用本地环境中的数据。</xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName> </xref:Microsoft.Win32.RegistryKey.GetValue%2A> 若要从远程计算机上的注册表中检索可扩展字符串值，使用<xref:Microsoft.Win32.RegistryKey.GetValue%2A>重载来指定不希望展开环境字符串。</xref:Microsoft.Win32.RegistryKey.GetValue%2A>      1> [!NOTE]&1;> 如果包含对环境变量的可展开引用的值已存储为 string (<xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName>)，而不是可扩展字符串 (<xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName>)，<xref:Microsoft.Win32.RegistryKey.GetValue%2A>方法不会展开它。</xref:Microsoft.Win32.RegistryKey.GetValue%2A> </xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName> </xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName> 已检索到它通过调用后，你可以展开此类字符串<xref:System.Environment.ExpandEnvironmentVariables%2A>方法。</xref:System.Environment.ExpandEnvironmentVariables%2A>      1> [!NOTE]&1;> 要从中检索数据的建议的方法<xref:Microsoft.Win32.Registry.PerformanceData>密钥是使用<xref:System.Diagnostics.PerformanceCounter>类而不是<xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=fullName>方法。</xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=fullName> </xref:System.Diagnostics.PerformanceCounter> </xref:Microsoft.Win32.Registry.PerformanceData>   >> GetValue 不支持类型 REG_NONE 或 REG_LINK 读取的值。  在这两种情况下，默认值 (`null`) 返回而不是实际值。"
  example:
  - "The following code example creates a test key with a value and retrieves that value. The example then attempts to retrieve a nonexistent value from the key; in this case the GetValue method returns the specified default value.  \n  \n [!code-cs[Classic RegistryKey.GetValue Example#1](~/add/codesnippet/csharp/m-microsoft.win32.regist_6_1.cs)]\n [!code-cpp[Classic RegistryKey.GetValue Example#1](~/add/codesnippet/cpp/m-microsoft.win32.regist_6_1.cpp)]\n [!code-vb[Classic RegistryKey.GetValue Example#1](~/add/codesnippet/visualbasic/m-microsoft.win32.regist_6_1.vb)]"
  syntax:
    content: public object GetValue (string name, object defaultValue);
    parameters:
    - id: name
      type: System.String
      description: "要检索的值的名称。 此字符串不区分大小写。"
    - id: defaultValue
      type: System.Object
      description: "如果返回的值`name`不存在。"
    return:
      type: System.Object
      description: "与关联的值<code> name </code>，嵌入的任何环境变量不展开，或<code> defaultValue </code>如果<code> name </code>找不到。"
  overload: Microsoft.Win32.RegistryKey.GetValue*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有读取注册表项所需的权限。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref> ，该字符串包含指定值为已关闭 （不能访问已关闭的项）。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref> ，该字符串包含指定值已标记为删除。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "用户没有必要的注册表权限。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.GetValue(System.String,System.Object,Microsoft.Win32.RegistryValueOptions)
  id: GetValue(System.String,System.Object,Microsoft.Win32.RegistryValueOptions)
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: GetValue(String,Object,RegistryValueOptions)
  nameWithType: RegistryKey.GetValue(String,Object,RegistryValueOptions)
  fullName: Microsoft.Win32.RegistryKey.GetValue(String,Object,RegistryValueOptions)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "检索与指定的名称和检索选项关联的值。 如果未找到的名称，将返回你提供的默认值。"
  remarks: "此重载用于指定的检索到的值的特殊处理。 例如，可以指定<xref:Microsoft.Win32.RegistryValueOptions?displayProperty=fullName>检索类型的注册表值时<xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName>来检索字符串而不扩展嵌入的环境变量。</xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName> </xref:Microsoft.Win32.RegistryValueOptions?displayProperty=fullName>       使用`defaultValue`参数来指定要返回如果的值`name`不存在。      1> [!NOTE]&1;> 注册表项可以具有不与任何名称关联的一个值。 在注册表编辑器中显示了此未命名的值，而不是名称将显示字符串&quot;（默认值）&quot;。 若要检索此未命名的值，指定`null`或为空字符串 (&quot;&quot;) 为`name`。   >> GetValue 不支持类型 REG_NONE 或 REG_LINK 读取的值。  在这两种情况下，默认值 (`null`) 返回而不是实际值。"
  example:
  - "The following code sample creates a test key, adds a value with an embedded environment variable, and retrieves the value in both expanded and unexpanded forms.  \n  \n [!code-cs[RegistryValueOptions#1](~/add/codesnippet/csharp/0ecb41d1-0eb1-4d34-96b2-_1.cs)]\n [!code-cpp[RegistryValueOptions#1](~/add/codesnippet/cpp/0ecb41d1-0eb1-4d34-96b2-_1.cpp)]\n [!code-vb[RegistryValueOptions#1](~/add/codesnippet/visualbasic/0ecb41d1-0eb1-4d34-96b2-_1.vb)]"
  syntax:
    content: public object GetValue (string name, object defaultValue, Microsoft.Win32.RegistryValueOptions options);
    parameters:
    - id: name
      type: System.String
      description: "要检索的值的名称。 此字符串不区分大小写。"
    - id: defaultValue
      type: System.Object
      description: "如果返回的值`name`不存在。"
    - id: options
      type: Microsoft.Win32.RegistryValueOptions
      description: "指定的检索到的值的可选处理的枚举值之一。"
    return:
      type: System.Object
      description: "与关联的值<code> name </code>，按照指定处理<code> options </code>，或<code> defaultValue </code>如果<code> name </code>找不到。"
  overload: Microsoft.Win32.RegistryKey.GetValue*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有读取注册表项所需的权限。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref> ，该字符串包含指定值为已关闭 （不能访问已关闭的项）。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref> ，该字符串包含指定值已标记为删除。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>options</code>不是有效<xref href=&quot;Microsoft.Win32.RegistryValueOptions&quot;></xref>值; 例如，无效的值被强制转换为<xref href=&quot;Microsoft.Win32.RegistryValueOptions&quot;> </xref>。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "用户没有必要的注册表权限。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.GetValueKind(System.String)
  id: GetValueKind(System.String)
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: GetValueKind(String)
  nameWithType: RegistryKey.GetValueKind(String)
  fullName: Microsoft.Win32.RegistryKey.GetValueKind(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "检索具有指定名称关联的值的注册表数据类型。"
  remarks: "> [!NOTE]1> 注册表项可以具有不与任何名称关联的一个值。 在注册表编辑器中显示了此未命名的值，而不是名称将显示字符串&quot;（默认值）&quot;。 若要检索此未命名的值的注册表数据类型，指定`null`或为空字符串 (&quot;&quot;) 为`name`。       有关受支持的注册表数据类型的说明，请参阅<xref:Microsoft.Win32.RegistryValueKind>枚举。</xref:Microsoft.Win32.RegistryValueKind>"
  example:
  - "The following code example creates a test key and adds values of different data types to the key. The example then reads the name/value pairs and displays them to the console, using the GetValueKind method to retrieve the corresponding registry data types.  \n  \n [!code-cpp[Microsoft.Win32.RegistryValueKind#1](~/add/codesnippet/cpp/m-microsoft.win32.regist_0_1.cpp)]\n [!code-cs[Microsoft.Win32.RegistryValueKind#1](~/add/codesnippet/csharp/m-microsoft.win32.regist_0_1.cs)]\n [!code-vb[Microsoft.Win32.RegistryValueKind#1](~/add/codesnippet/visualbasic/m-microsoft.win32.regist_0_1.vb)]"
  syntax:
    content: public Microsoft.Win32.RegistryValueKind GetValueKind (string name);
    parameters:
    - id: name
      type: System.String
      description: "注册表数据类型是要检索的值的名称。 此字符串不区分大小写。"
    return:
      type: Microsoft.Win32.RegistryValueKind
      description: "与关联的值的注册表数据类型<code> name </code>。"
  overload: Microsoft.Win32.RegistryKey.GetValueKind*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有读取注册表项所需的权限。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref> ，该字符串包含指定值为已关闭 （不能访问已关闭的项）。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "包含指定的值中的子项不存在。       -由指定的名称/值对<code> name </code>不存在。       在 Windows 95、 Windows 98 或 Windows Millennium Edition 上不会引发此异常。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "用户没有必要的注册表权限。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.GetValueNames
  id: GetValueNames
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: GetValueNames()
  nameWithType: RegistryKey.GetValueNames()
  fullName: Microsoft.Win32.RegistryKey.GetValueNames()
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "检索包含与此键关联的所有值名称的字符串数组。"
  remarks: "如果找到项没有值名称，则返回一个空数组。       注册表项可以具有默认值-即，在其中名称为空字符串的名称/值对 (&quot;&quot;)。 如果已经为注册表项设置了默认值，GetValueNames 方法返回的数组将包含空字符串。"
  example:
  - "This code example is part of a larger example provided for the <xref:Microsoft.Win32.RegistryKey> class.  \n  \n [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/add/codesnippet/cpp/m-microsoft.win32.regist_2_1.cpp)]\n [!code-cs[Microsoft.Win32.RegistryKey2#2](~/add/codesnippet/csharp/m-microsoft.win32.regist_2_1.cs)]\n [!code-vb[Microsoft.Win32.RegistryKey2#2](~/add/codesnippet/visualbasic/m-microsoft.win32.regist_2_1.vb)]"
  syntax:
    content: public string[] GetValueNames ();
    parameters: []
    return:
      type: System.String[]
      description: "包含当前密钥的值名称的字符串数组。"
  overload: Microsoft.Win32.RegistryKey.GetValueNames*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有读取注册表项所需的权限。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>操作关闭 （不能访问已关闭的项）。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "用户没有必要的注册表权限。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "发生系统错误;例如，当前的密钥已被删除。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.Handle
  id: Handle
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: Handle
  nameWithType: RegistryKey.Handle
  fullName: Microsoft.Win32.RegistryKey.Handle
  type: Property
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "获取<xref href=&quot;Microsoft.Win32.SafeHandles.SafeRegistryHandle&quot;></xref>对象，表示注册表项当前<xref href=&quot;Microsoft.Win32.RegistryKey&quot;></xref>对象所封装。"
  syntax:
    content: public Microsoft.Win32.SafeHandles.SafeRegistryHandle Handle { get; }
    return:
      type: Microsoft.Win32.SafeHandles.SafeRegistryHandle
      description: "注册表项的句柄。"
  overload: Microsoft.Win32.RegistryKey.Handle*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "注册表项已关闭。 无法访问已关闭的项。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "用户没有必要的注册表权限。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "将发生系统错误，例如删除当前的密钥。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有读取注册表项所需的权限。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.Name
  id: Name
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: Name
  nameWithType: RegistryKey.Name
  fullName: Microsoft.Win32.RegistryKey.Name
  type: Property
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "检索密钥的名称。"
  remarks: "键的名称在注册表中，始终从开始是基项，例如，在 HKEY_LOCAL_MACHINE 包括此项的绝对路径。"
  example:
  - "This code example is part of a larger example provided for the <xref:Microsoft.Win32.RegistryKey> class.  \n  \n [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/add/codesnippet/cpp/p-microsoft.win32.regist_0_1.cpp)]\n [!code-cs[Microsoft.Win32.RegistryKey2#4](~/add/codesnippet/csharp/p-microsoft.win32.regist_0_1.cs)]\n [!code-vb[Microsoft.Win32.RegistryKey2#4](~/add/codesnippet/visualbasic/p-microsoft.win32.regist_0_1.vb)]"
  syntax:
    content: public string Name { get; }
    return:
      type: System.String
      description: "键的绝对 （限定） 名称。"
  overload: Microsoft.Win32.RegistryKey.Name*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>关闭 （不能访问已关闭的项）。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.OpenBaseKey(Microsoft.Win32.RegistryHive,Microsoft.Win32.RegistryView)
  id: OpenBaseKey(Microsoft.Win32.RegistryHive,Microsoft.Win32.RegistryView)
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: OpenBaseKey(RegistryHive,RegistryView)
  nameWithType: RegistryKey.OpenBaseKey(RegistryHive,RegistryView)
  fullName: Microsoft.Win32.RegistryKey.OpenBaseKey(RegistryHive,RegistryView)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "打开一个新<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref> ，表示具有指定的视图的本地计算机上请求的项。"
  syntax:
    content: public static Microsoft.Win32.RegistryKey OpenBaseKey (Microsoft.Win32.RegistryHive hKey, Microsoft.Win32.RegistryView view);
    parameters:
    - id: hKey
      type: Microsoft.Win32.RegistryHive
      description: "要打开的 HKEY。"
    - id: view
      type: Microsoft.Win32.RegistryView
      description: "要使用的注册表视图。"
    return:
      type: Microsoft.Win32.RegistryKey
      description: "请求的注册表项。"
  overload: Microsoft.Win32.RegistryKey.OpenBaseKey*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>hKey</code>或<code>view</code>无效。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "用户没有必要的注册表权限。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有执行此操作所需的权限。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)
  id: OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: OpenRemoteBaseKey(RegistryHive,String)
  nameWithType: RegistryKey.OpenRemoteBaseKey(RegistryHive,String)
  fullName: Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(RegistryHive,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "打开一个新<xref href=&quot;Microsoft.Win32.RegistryKey&quot;></xref>表示远程计算机上请求的项。"
  remarks: "如果打开本地计算机注册表`machineName`为<xref:System.String?displayProperty=fullName>。</xref:System.String?displayProperty=fullName> 请求的项必须是远程计算机上的根项，并由相应标识<xref:Microsoft.Win32.RegistryHive>值。</xref:Microsoft.Win32.RegistryHive>       为了使远程打开的密钥，服务器和客户端计算机必须是运行远程注册表服务，而且必须启用远程管理。"
  example:
  - "The following code example shows how to open a registry key on a remote computer and enumerate the values of the key. The remote computer must be running the remote registry service. Specify the name of the remote computer as a command-line argument when invoking the program.  \n  \n [!code-cpp[Microsoft.Win32.RegistryKey.OpenRemoteBaseKey#1](~/add/codesnippet/cpp/e08e963c-edd7-45e7-b967-_1.cpp)]\n [!code-cs[Microsoft.Win32.RegistryKey.OpenRemoteBaseKey#1](~/add/codesnippet/csharp/e08e963c-edd7-45e7-b967-_1.cs)]\n [!code-vb[Microsoft.Win32.RegistryKey.OpenRemoteBaseKey#1](~/add/codesnippet/visualbasic/e08e963c-edd7-45e7-b967-_1.vb)]"
  syntax:
    content: public static Microsoft.Win32.RegistryKey OpenRemoteBaseKey (Microsoft.Win32.RegistryHive hKey, string machineName);
    parameters:
    - id: hKey
      type: Microsoft.Win32.RegistryHive
      description: "若要打开，HKEY 从<xref href=&quot;Microsoft.Win32.RegistryHive&quot;></xref>枚举。"
    - id: machineName
      type: System.String
      description: "远程计算机。"
    return:
      type: Microsoft.Win32.RegistryKey
      description: "请求的注册表项。"
  overload: Microsoft.Win32.RegistryKey.OpenRemoteBaseKey*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>hKey</code>是无效的。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>machineName</code>未找到。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>machineName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有适当的权限来执行此操作。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "用户没有必要的注册表权限。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String,Microsoft.Win32.RegistryView)
  id: OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String,Microsoft.Win32.RegistryView)
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: OpenRemoteBaseKey(RegistryHive,String,RegistryView)
  nameWithType: RegistryKey.OpenRemoteBaseKey(RegistryHive,String,RegistryView)
  fullName: Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(RegistryHive,String,RegistryView)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "将打开一个新的注册表项，表示具有指定的视图的远程计算机上请求的项。"
  remarks: "如果打开本地计算机注册表`machineName`为<xref:System.String?displayProperty=fullName>。</xref:System.String?displayProperty=fullName> 请求的项必须是远程计算机上的根项，并由相应标识<xref:Microsoft.Win32.RegistryHive>值。</xref:Microsoft.Win32.RegistryHive>       为了使远程打开的密钥，服务器和客户端计算机必须是运行远程注册表服务，而且必须启用远程管理。       在 64 位版本的 Windows 中，对于 32 位和 64 位应用程序可以单独存储注册表的不同部分。 有了 32 位应用程序的 32 位视图和 64 位应用程序的 64 位视图。 如果`view`是<xref:Microsoft.Win32.RegistryView>但远程计算机正在运行 32 位操作系统，则返回的键将使用<xref:Microsoft.Win32.RegistryView>视图。</xref:Microsoft.Win32.RegistryView> </xref:Microsoft.Win32.RegistryView>"
  syntax:
    content: public static Microsoft.Win32.RegistryKey OpenRemoteBaseKey (Microsoft.Win32.RegistryHive hKey, string machineName, Microsoft.Win32.RegistryView view);
    parameters:
    - id: hKey
      type: Microsoft.Win32.RegistryHive
      description: "要从打开的 HKEY <xref href=&quot;Microsoft.Win32.RegistryHive&quot;> </xref>枚举..."
    - id: machineName
      type: System.String
      description: "远程计算机。"
    - id: view
      type: Microsoft.Win32.RegistryView
      description: "要使用的注册表视图。"
    return:
      type: Microsoft.Win32.RegistryKey
      description: "请求的注册表项。"
  overload: Microsoft.Win32.RegistryKey.OpenRemoteBaseKey*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>hKey</code>或<code>view</code>无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>machineName</code>未找到。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>machineName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "用户没有必要的注册表权限。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有所需的权限来执行此操作。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.OpenSubKey(System.String)
  id: OpenSubKey(System.String)
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: OpenSubKey(String)
  nameWithType: RegistryKey.OpenSubKey(String)
  fullName: Microsoft.Win32.RegistryKey.OpenSubKey(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "检索以只读方式子项。"
  remarks: "必须先与其他方法和属性而对其进行操作来打开密钥。 若要修改键，必须打开的重载与它<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法，您可以指定写访问权限，如<xref:Microsoft.Win32.RegistryKey.OpenSubKey%28System.String%2CMicrosoft.Win32.RegistryKeyPermissionCheck%29>重载或<xref:Microsoft.Win32.RegistryKey.OpenSubKey%28System.String%2CSystem.Boolean%29>重载。</xref:Microsoft.Win32.RegistryKey.OpenSubKey%28System.String%2CSystem.Boolean%29> </xref:Microsoft.Win32.RegistryKey.OpenSubKey%28System.String%2CMicrosoft.Win32.RegistryKeyPermissionCheck%29> </xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>       如果没有找到指定的子项，然后`null`返回。       为了使用 OpenSubKey 方法，你必须具有<xref:Microsoft.Win32.RegistryKey>.</xref:Microsoft.Win32.RegistryKey>的实例 若要获取其实例<xref:Microsoft.Win32.RegistryKey>，请使用<xref:Microsoft.Win32.Registry>类</xref:Microsoft.Win32.Registry>的静态成员之一</xref:Microsoft.Win32.RegistryKey>"
  example:
  - "The following code example creates a test key and uses the <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> method to open it, demonstrating both overloads of the method.  \n  \n [!code-cs[RegistryKey.OpenSubKey#1](~/add/codesnippet/csharp/m-microsoft.win32.regist_11_1.cs)]\n [!code-vb[RegistryKey.OpenSubKey#1](~/add/codesnippet/visualbasic/m-microsoft.win32.regist_11_1.vb)]\n [!code-cpp[RegistryKey.OpenSubKey#1](~/add/codesnippet/cpp/m-microsoft.win32.regist_11_1.cpp)]"
  syntax:
    content: public Microsoft.Win32.RegistryKey OpenSubKey (string name);
    parameters:
    - id: name
      type: System.String
      description: "名称或要以只读方式打开的子项的路径。"
    return:
      type: Microsoft.Win32.RegistryKey
      description: "请求的子项或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果操作失败。"
  overload: Microsoft.Win32.RegistryKey.OpenSubKey*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>关闭 （不能访问已关闭的项）。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有进行读取的注册表项所需的权限。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.OpenSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck)
  id: OpenSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck)
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: OpenSubKey(String,RegistryKeyPermissionCheck)
  nameWithType: RegistryKey.OpenSubKey(String,RegistryKeyPermissionCheck)
  fullName: Microsoft.Win32.RegistryKey.OpenSubKey(String,RegistryKeyPermissionCheck)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "检索指定的子项以进行读取或读/写访问。"
  remarks: "而不是引发异常，此方法返回`null`如果请求的项不存在。       如果`permissionCheck`是<xref:Microsoft.Win32.RegistryKeyPermissionCheck?displayProperty=fullName>，则打开该项进行读取和写入; 如果`permissionCheck` <xref:Microsoft.Win32.RegistryKeyPermissionCheck?displayProperty=fullName> <xref:Microsoft.Win32.RegistryKeyPermissionCheck?displayProperty=fullName>，除非<xref:Microsoft.Win32.RegistryKeyPermissionCheck?displayProperty=fullName>.</xref:Microsoft.Win32.RegistryKeyPermissionCheck?displayProperty=fullName>已打开的父项，打开的注册表项以进行读取</xref:Microsoft.Win32.RegistryKeyPermissionCheck?displayProperty=fullName></xref:Microsoft.Win32.RegistryKeyPermissionCheck?displayProperty=fullName>或</xref:Microsoft.Win32.RegistryKeyPermissionCheck?displayProperty=fullName>       若要使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法，你必须有<xref:Microsoft.Win32.RegistryKey>类</xref:Microsoft.Win32.RegistryKey>的实例</xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 若要获取其实例<xref:Microsoft.Win32.RegistryKey>，请使用<xref:Microsoft.Win32.Registry>类</xref:Microsoft.Win32.Registry>的静态成员之一</xref:Microsoft.Win32.RegistryKey>"
  example:
  - "The following code example creates a subkey containing 100 key/value pairs and closes it. The example opens the subkey with <xref:Microsoft.Win32.RegistryKeyPermissionCheck>, records the time it takes to read all the values, and closes the subkey. The example opens the subkey with <xref:Microsoft.Win32.RegistryKeyPermissionCheck> and records the time it takes to read all the values. Finally, the example computes and displays the percentage improvement.  \n  \n [!code-cs[RegistryKey.OpenSubKey_PermCheck#1](~/add/codesnippet/csharp/1404fbf5-0fde-46f3-9877-_1.cs)]\n [!code-vb[RegistryKey.OpenSubKey_PermCheck#1](~/add/codesnippet/visualbasic/1404fbf5-0fde-46f3-9877-_1.vb)]"
  syntax:
    content: public Microsoft.Win32.RegistryKey OpenSubKey (string name, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck);
    parameters:
    - id: name
      type: System.String
      description: "名称或要创建或打开的子项的路径。"
    - id: permissionCheck
      type: Microsoft.Win32.RegistryKeyPermissionCheck
      description: "一个枚举值，用于指定打开该项是是否进行读取或读/写访问。"
    return:
      type: Microsoft.Win32.RegistryKey
      description: "请求的子项或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果操作失败。"
  overload: Microsoft.Win32.RegistryKey.OpenSubKey*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>permissionCheck</code>包含无效值。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>关闭 （不能访问已关闭的项）。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有进行读取的注册表项所需的权限。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)
  id: OpenSubKey(System.String,System.Boolean)
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: OpenSubKey(String,Boolean)
  nameWithType: RegistryKey.OpenSubKey(String,Boolean)
  fullName: Microsoft.Win32.RegistryKey.OpenSubKey(String,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "检索指定的子项，并指定是否要应用于密钥写访问权限。"
  remarks: "如果请求的项不存在，此方法返回`null`而不是引发异常。       如果`writable`是`true`的项将打开用于读取和写入，否则，将以只读方式打开的注册表项。       若要使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法，您必须拥有的实例<xref:Microsoft.Win32.RegistryKey>方法。</xref:Microsoft.Win32.RegistryKey> </xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 若要获取其实例<xref:Microsoft.Win32.RegistryKey>，请使用<xref:Microsoft.Win32.Registry>类</xref:Microsoft.Win32.Registry>的静态成员之一</xref:Microsoft.Win32.RegistryKey>"
  example:
  - "The following code example creates a test key and uses the <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> method to open it, demonstrating both overloads of the method.  \n  \n [!code-cs[RegistryKey.OpenSubKey#1](~/add/codesnippet/csharp/m-microsoft.win32.regist_1_1.cs)]\n [!code-vb[RegistryKey.OpenSubKey#1](~/add/codesnippet/visualbasic/m-microsoft.win32.regist_1_1.vb)]\n [!code-cpp[RegistryKey.OpenSubKey#1](~/add/codesnippet/cpp/m-microsoft.win32.regist_1_1.cpp)]"
  syntax:
    content: public Microsoft.Win32.RegistryKey OpenSubKey (string name, bool writable);
    parameters:
    - id: name
      type: System.String
      description: "名称或要打开的子项的路径。"
    - id: writable
      type: System.Boolean
      description: "设置为<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果需要写访问密钥。"
    return:
      type: Microsoft.Win32.RegistryKey
      description: "请求的子项或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果操作失败。"
  overload: Microsoft.Win32.RegistryKey.OpenSubKey*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>关闭 （不能访问已关闭的项）。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有访问指定的模式中的注册表项所需的权限。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Security.AccessControl.RegistryRights)
  id: OpenSubKey(System.String,System.Security.AccessControl.RegistryRights)
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: OpenSubKey(String,RegistryRights)
  nameWithType: RegistryKey.OpenSubKey(String,RegistryRights)
  fullName: Microsoft.Win32.RegistryKey.OpenSubKey(String,RegistryRights)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "检索具有指定名称的子项和。       可以开始于[!INCLUDE[net_2015](~/add/includes/net-2015-md.md)]"
  remarks: "必须先与其他方法和属性而对其进行操作来打开密钥。 若要修改键，必须打开的重载与它<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>允许你指定写入访问权限的方法。</xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>"
  syntax:
    content: public Microsoft.Win32.RegistryKey OpenSubKey (string name, System.Security.AccessControl.RegistryRights rights);
    parameters:
    - id: name
      type: System.String
      description: "名称或要创建或打开的子项的路径。"
    - id: rights
      type: System.Security.AccessControl.RegistryRights
      description: "注册表项权限。"
    return:
      type: Microsoft.Win32.RegistryKey
      description: "请求的子项或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果操作失败。"
  overload: Microsoft.Win32.RegistryKey.OpenSubKey*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>关闭 （不能访问已关闭的项）。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有访问指定的模式中的注册表项所需的权限。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.OpenSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,System.Security.AccessControl.RegistryRights)
  id: OpenSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,System.Security.AccessControl.RegistryRights)
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: OpenSubKey(String,RegistryKeyPermissionCheck,RegistryRights)
  nameWithType: RegistryKey.OpenSubKey(String,RegistryKeyPermissionCheck,RegistryRights)
  fullName: Microsoft.Win32.RegistryKey.OpenSubKey(String,RegistryKeyPermissionCheck,RegistryRights)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "检索指定的子项以进行读取或读/写访问，请求指定的访问权限。"
  remarks: "而不是引发异常，此方法返回`null`如果请求的项不存在。       如果`permissionCheck`是<xref:Microsoft.Win32.RegistryKeyPermissionCheck?displayProperty=fullName>，则打开该项进行读取和写入; 如果`permissionCheck` <xref:Microsoft.Win32.RegistryKeyPermissionCheck?displayProperty=fullName> <xref:Microsoft.Win32.RegistryKeyPermissionCheck?displayProperty=fullName>，除非<xref:Microsoft.Win32.RegistryKeyPermissionCheck?displayProperty=fullName>.</xref:Microsoft.Win32.RegistryKeyPermissionCheck?displayProperty=fullName>已打开的父项，打开的注册表项以进行读取</xref:Microsoft.Win32.RegistryKeyPermissionCheck?displayProperty=fullName></xref:Microsoft.Win32.RegistryKeyPermissionCheck?displayProperty=fullName>或</xref:Microsoft.Win32.RegistryKeyPermissionCheck?displayProperty=fullName>       为指定的访问权限`permissionCheck`优先于为指定的访问权限`rights`。 例如，如果你指定<xref:Microsoft.Win32.RegistryKeyPermissionCheck?displayProperty=fullName>为`permissionCheck`和<xref:System.Security.AccessControl.RegistryRights?displayProperty=fullName>为`rights`，尝试写入到子项引发异常。</xref:System.Security.AccessControl.RegistryRights?displayProperty=fullName> </xref:Microsoft.Win32.RegistryKeyPermissionCheck?displayProperty=fullName>       若要使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法，你必须有<xref:Microsoft.Win32.RegistryKey>类</xref:Microsoft.Win32.RegistryKey>的实例</xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 若要获取其实例<xref:Microsoft.Win32.RegistryKey>，请使用<xref:Microsoft.Win32.Registry>类</xref:Microsoft.Win32.Registry>的静态成员之一</xref:Microsoft.Win32.RegistryKey>"
  syntax:
    content: public Microsoft.Win32.RegistryKey OpenSubKey (string name, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, System.Security.AccessControl.RegistryRights rights);
    parameters:
    - id: name
      type: System.String
      description: "名称或要创建或打开的子项的路径。"
    - id: permissionCheck
      type: Microsoft.Win32.RegistryKeyPermissionCheck
      description: "一个枚举值，用于指定打开该项是是否进行读取或读/写访问。"
    - id: rights
      type: System.Security.AccessControl.RegistryRights
      description: "枚举值的按位组合，指定所需的安全访问权限。"
    return:
      type: Microsoft.Win32.RegistryKey
      description: "请求的子项或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果操作失败。"
  overload: Microsoft.Win32.RegistryKey.OpenSubKey*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>permissionCheck</code>包含无效值。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>关闭 （不能访问已关闭的项）。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<code>rights</code>包含无效的注册表权限值。       -或者-用户没有所请求的权限。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.SetAccessControl(System.Security.AccessControl.RegistrySecurity)
  id: SetAccessControl(System.Security.AccessControl.RegistrySecurity)
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: SetAccessControl(RegistrySecurity)
  nameWithType: RegistryKey.SetAccessControl(RegistrySecurity)
  fullName: Microsoft.Win32.RegistryKey.SetAccessControl(RegistrySecurity)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "适用于现有的注册表项的 Windows 访问控制安全性。"
  remarks: "若要修改的注册表项的权限，请使用<xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A>方法来获取<xref:System.Security.AccessControl.RegistrySecurity>表示现有的 Windows 访问控制安全性的对象，修改该<xref:System.Security.AccessControl.RegistrySecurity>对象，，然后使用 SetAccessControl 方法以更新项安全性。</xref:System.Security.AccessControl.RegistrySecurity> </xref:System.Security.AccessControl.RegistrySecurity> </xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A>      1> [!CAUTION]&1;><xref:System.Security.AccessControl.RegistrySecurity>对象指定的用于`registrySecurity`替换注册表项的现有安全性。</xref:System.Security.AccessControl.RegistrySecurity> 若要添加的新用户的权限，请使用<xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A>方法以获取现有的访问控制安全性，，然后修改它。</xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A>"
  example:
  - "The following code example creates a test key. The current user is allowed <xref:System.Security.AccessControl.RegistryRights> and <xref:System.Security.AccessControl.RegistryRights> rights but denied <xref:System.Security.AccessControl.RegistryRights> and <xref:System.Security.AccessControl.RegistryRights> rights. Subsequent attempts to manipulate the key succeed or fail depending on these permissions.  \n  \n Before the key is deleted, the code pauses. You can switch to the registry editor and verify that the same access rights apply when the key is accessed using the registry editor. (This works best if you use **RunAs** from the command line to run the registry editor and the sample code as a local user without administrator rights. The registry editor always allows an administrator to change permissions, even if the particular administrator has been denied those rights. If you have defined a local user named TestUser, the command `runas /user:TestUser cmd` opens a command window from which you can run the registry editor and then the sample code.)  \n  \n [!code-cpp[RegistrySecurity101#1](~/add/codesnippet/cpp/463455ee-8295-4a1a-9af9-_1.cpp)]\n [!code-cs[RegistrySecurity101#1](~/add/codesnippet/csharp/463455ee-8295-4a1a-9af9-_1.cs)]\n [!code-vb[RegistrySecurity101#1](~/add/codesnippet/visualbasic/463455ee-8295-4a1a-9af9-_1.vb)]"
  syntax:
    content: public void SetAccessControl (System.Security.AccessControl.RegistrySecurity registrySecurity);
    parameters:
    - id: registrySecurity
      type: System.Security.AccessControl.RegistrySecurity
      description: "要应用于当前子项的访问控制安全性。"
  overload: Microsoft.Win32.RegistryKey.SetAccessControl*
  exceptions:
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "当前<xref href=&quot;Microsoft.Win32.RegistryKey&quot;></xref>对象表示一个密钥与访问控制安全性，并且调用方没有<xref href=&quot;System.Security.AccessControl.RegistryRights&quot;></xref>权限。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>registrySecurity</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>操作关闭 （不能访问已关闭的项）。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.SetValue(System.String,System.Object)
  id: SetValue(System.String,System.Object)
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: SetValue(String,Object)
  nameWithType: RegistryKey.SetValue(String,Object)
  fullName: Microsoft.Win32.RegistryKey.SetValue(String,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "设置指定的名称/值对。"
  remarks: "由于多个值可以存储在注册表中的每个项，你必须使用`name`参数来指定你想要设置的特定值。      1> [!NOTE]&1;> 注册表项可以具有不与任何名称关联的一个值。 在注册表编辑器中显示了此未命名的值，而不是名称将显示字符串&quot;（默认值）&quot;。 若要设置此未命名的值，指定`null`或为空字符串 (&quot;&quot;) 为`name`。       若要在密钥中设置值，必须具有写访问权限来打开密钥。 具有写访问权限打开一个键后，你可以更改任何该注册表项中的名称/值对。       如果指定`name`不存在的项中创建和关联的值设置为`value`。       此重载<xref:Microsoft.Win32.RegistryKey.SetValue%2A>将 64 位整数存储为字符串 (<xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName>)。</xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName> </xref:Microsoft.Win32.RegistryKey.SetValue%2A> 作为<xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName>值，请使用<xref:Microsoft.Win32.RegistryKey.SetValue%28System.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29>重载，它指定<xref:Microsoft.Win32.RegistryValueKind>.</xref:Microsoft.Win32.RegistryValueKind></xref:Microsoft.Win32.RegistryKey.SetValue%28System.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29></xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName>存储 64 位数字       此重载<xref:Microsoft.Win32.RegistryKey.SetValue%2A>存储所有的字符串值作为<xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName>，即使它们包含对环境变量的可展开引用。</xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName> </xref:Microsoft.Win32.RegistryKey.SetValue%2A> 若要保存为可展开的字符串的字符串值 (<xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName>)，请使用<xref:Microsoft.Win32.RegistryKey.SetValue%28System.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29>重载，它指定<xref:Microsoft.Win32.RegistryValueKind>.</xref:Microsoft.Win32.RegistryValueKind> </xref:Microsoft.Win32.RegistryKey.SetValue%28System.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> </xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName>       通过此方法重载以字符串形式存储以外 32 位整数的数值类型。 枚举元素存储为包含的元素名称的字符串。      1> [!CAUTION]&1;> 不会公开<xref:Microsoft.Win32.RegistryKey>，恶意程序无法创建数千个无意义的子项或键/值对的方式的对象。</xref:Microsoft.Win32.RegistryKey> 例如，不允许调用方输入任意键或值。      1> [!NOTE] 1> 上 Windows 98 和 Windows Millennium Edition 注册表不是 Unicode，而不是所有 Unicode 字符都是有效的所有代码页。 对于当前的代码页无效的 Unicode 字符都替换为最佳的匹配项。 不引发异常。"
  example:
  - "The following code example shows how the SetValue method determines the registry data type when it sets values. The example creates a test key and adds values of different data types to the key. The example then reads the name/value pairs and displays them to the console, using the <xref:Microsoft.Win32.RegistryKey.GetValueKind%2A> method to display the corresponding registry data types.  \n  \n [!code-vb[Microsoft.Win32.RegistryKey.SetValue1#1](~/add/codesnippet/visualbasic/m-microsoft.win32.regist_10_1.vb)]\n [!code-cs[Microsoft.Win32.RegistryKey.SetValue1#1](~/add/codesnippet/csharp/m-microsoft.win32.regist_10_1.cs)]\n [!code-cpp[Microsoft.Win32.RegistryKey.SetValue1#1](~/add/codesnippet/cpp/m-microsoft.win32.regist_10_1.cpp)]"
  syntax:
    content: public void SetValue (string name, object value);
    parameters:
    - id: name
      type: System.String
      description: "要存储的值的名称。"
    - id: value
      type: System.Object
      description: "要存储的数据。"
  overload: Microsoft.Win32.RegistryKey.SetValue*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>value</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>value</code>不是不受支持的数据类型。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref> ，该字符串包含指定值为已关闭 （不能访问已关闭的项）。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>是只读的并且无法写入; 例如，不具有写访问权限打开的注册表项。       -或- <xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>对象表示根级节点，并且操作系统是 Windows Millennium Edition 或 Windows 98。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有创建或修改注册表项所需的权限。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>对象表示根级节点，并且操作系统是 Windows 2000、 Windows XP 或 Windows Server 2003。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.SetValue(System.String,System.Object,Microsoft.Win32.RegistryValueKind)
  id: SetValue(System.String,System.Object,Microsoft.Win32.RegistryValueKind)
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: SetValue(String,Object,RegistryValueKind)
  nameWithType: RegistryKey.SetValue(String,Object,RegistryValueKind)
  fullName: Microsoft.Win32.RegistryKey.SetValue(String,Object,RegistryValueKind)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "使用指定的注册表数据类型的注册表项中设置的名称/值对的值。"
  remarks: "由于多个值可以存储在注册表中的每个项，你必须使用`name`参数来指定你想要设置的特定值。      1> [!NOTE]&1;> 注册表项可以具有不与任何名称关联的一个值。 在注册表编辑器中显示了此未命名的值，而不是名称将显示字符串&quot;（默认值）&quot;。 若要设置此未命名的值，指定`null`或为空字符串 (&quot;&quot;) 为`name`。       若要在密钥中设置值，必须具有写访问权限来打开密钥。 具有写访问权限打开一个键后，你可以更改任何该注册表项中的名称/值对。       如果指定`name`不存在的项，它创建，并且相关联的值设置为`value`。      1> [!NOTE]&1;> 指定的注册表数据类型<xref:Microsoft.Win32.RegistryValueKind>等同于使用<xref:Microsoft.Win32.RegistryKey.SetValue%2A>重载。</xref:Microsoft.Win32.RegistryKey.SetValue%2A> </xref:Microsoft.Win32.RegistryValueKind>       如果指定的类型`value`不匹配指定`valueKind`，和数据不能转换，<xref:System.ArgumentException>引发。</xref:System.ArgumentException> 例如，你可以存储<xref:System.Int64?displayProperty=fullName>作为<xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName>，但仅当其值为一种<xref:System.Int32?displayProperty=fullName>。</xref:System.Int32?displayProperty=fullName>的最大值小于</xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName></xref:System.Int64?displayProperty=fullName> 不能将单个字符串值存储为一种<xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName>。</xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName>      1> [!NOTE]&1;> 如果都传递装箱的值<xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName>或<xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName>，完成转换后使用固定区域性。</xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName> </xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName>      1> [!CAUTION]&1;> 不会公开<xref:Microsoft.Win32.RegistryKey>，恶意程序无法创建数千个无意义的子项或键/值对的方式的对象。</xref:Microsoft.Win32.RegistryKey> 例如，不允许调用方输入任意键或值。      1> [!NOTE] 1> 上 Windows 98 和 Windows Millennium Edition 注册表不是 Unicode，而不是所有 Unicode 字符都是有效的所有代码页。 对于当前的代码页无效的 Unicode 字符都替换为最佳的匹配项。 不引发异常。"
  example:
  - "The following code example creates a test key and uses the <xref:Microsoft.Win32.RegistryKey.SetValue%2A> method to store several values, specifying the registry data type for each value. The example then reads the name/value pairs and displays them to the console, using the <xref:Microsoft.Win32.RegistryKey.GetValueKind%2A> method to display the corresponding registry data types.  \n  \n [!code-cpp[Microsoft.Win32.RegistryValueKind#1](~/add/codesnippet/cpp/4d7d6152-5710-4faa-8e5f-_1.cpp)]\n [!code-cs[Microsoft.Win32.RegistryValueKind#1](~/add/codesnippet/csharp/4d7d6152-5710-4faa-8e5f-_1.cs)]\n [!code-vb[Microsoft.Win32.RegistryValueKind#1](~/add/codesnippet/visualbasic/4d7d6152-5710-4faa-8e5f-_1.vb)]"
  syntax:
    content: public void SetValue (string name, object value, Microsoft.Win32.RegistryValueKind valueKind);
    parameters:
    - id: name
      type: System.String
      description: "要存储的值的名称。"
    - id: value
      type: System.Object
      description: "要存储的数据。"
    - id: valueKind
      type: Microsoft.Win32.RegistryValueKind
      description: "要存储数据时使用的注册表数据类型。"
  overload: Microsoft.Win32.RegistryKey.SetValue*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>value</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一种<code> value </code>与由指定的注册表数据类型不匹配<code> valueKind </code>，因此可能不会正确转换该数据。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref> ，该字符串包含指定值为已关闭 （不能访问已关闭的项）。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>是只读的并且无法写入; 例如，不具有写访问权限打开的注册表项。       -或- <xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>对象表示根级节点，并且操作系统是 Windows Millennium Edition 或 Windows 98。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有创建或修改注册表项所需的权限。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>对象表示根级节点，并且操作系统是 Windows 2000、 Windows XP 或 Windows Server 2003。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.SubKeyCount
  id: SubKeyCount
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: SubKeyCount
  nameWithType: RegistryKey.SubKeyCount
  fullName: Microsoft.Win32.RegistryKey.SubKeyCount
  type: Property
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "检索当前项的子项计数。"
  remarks: "此属性执行不是以递归方式计数名称。 它只返回调用它的基级上的名称的计数。"
  example:
  - "This code example is part of a larger example provided for the <xref:Microsoft.Win32.RegistryKey> class.  \n  \n [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/add/codesnippet/cpp/p-microsoft.win32.regist_1_1.cpp)]\n [!code-cs[Microsoft.Win32.RegistryKey2#2](~/add/codesnippet/csharp/p-microsoft.win32.regist_1_1.cs)]\n [!code-vb[Microsoft.Win32.RegistryKey2#2](~/add/codesnippet/visualbasic/p-microsoft.win32.regist_1_1.vb)]"
  syntax:
    content: public int SubKeyCount { get; }
    return:
      type: System.Int32
      description: "当前项的子项数。"
  overload: Microsoft.Win32.RegistryKey.SubKeyCount*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有密钥的读取的权限。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>操作关闭 （不能访问已关闭的项）。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "用户没有必要的注册表权限。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "出现系统错误，例如当前项已被删除。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.ToString
  id: ToString
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: ToString()
  nameWithType: RegistryKey.ToString()
  fullName: Microsoft.Win32.RegistryKey.ToString()
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "检索此密钥的字符串表示。"
  remarks: "返回的值包含指定的键和键的十六进制值的注册表路径。 注册表路径包含指定键的绝对根，始终从&1; 开始的基键的注册表中，例如，HKEY_LOCAL_MACHINE。"
  example:
  - "This code example is part of a larger example provided for the <xref:Microsoft.Win32.RegistryKey> class.  \n  \n [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/add/codesnippet/cpp/m-microsoft.win32.regist_9_1.cpp)]\n [!code-cs[Microsoft.Win32.RegistryKey2#4](~/add/codesnippet/csharp/m-microsoft.win32.regist_9_1.cs)]\n [!code-vb[Microsoft.Win32.RegistryKey2#4](~/add/codesnippet/visualbasic/m-microsoft.win32.regist_9_1.vb)]"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "表示键的字符串。 如果指定的键是无效 （找不到） 然后<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>返回。"
  overload: Microsoft.Win32.RegistryKey.ToString*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>正在访问已关闭 （不能访问已关闭的项）。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.ValueCount
  id: ValueCount
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: ValueCount
  nameWithType: RegistryKey.ValueCount
  fullName: Microsoft.Win32.RegistryKey.ValueCount
  type: Property
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "检索的项中的值的计数。"
  remarks: "每个注册表项具有不与任何名称相关联的默认值。 此未命名的值可以通过使用设置<xref:Microsoft.Win32.RegistryKey.SetValue%2A>方法并指定`null`或为空字符串 (&quot;&quot;) 为`name`。</xref:Microsoft.Win32.RegistryKey.SetValue%2A> 如果具有永远不会设置默认值，它不影响 ValueCount 属性中; 返回的总计数一旦设置，但是，则将始终计。"
  example:
  - "This code example is part of a larger example provided for the <xref:Microsoft.Win32.RegistryKey> class.  \n  \n [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/add/codesnippet/cpp/p-microsoft.win32.regist_2_1.cpp)]\n [!code-cs[Microsoft.Win32.RegistryKey2#2](~/add/codesnippet/csharp/p-microsoft.win32.regist_2_1.cs)]\n [!code-vb[Microsoft.Win32.RegistryKey2#2](~/add/codesnippet/visualbasic/p-microsoft.win32.regist_2_1.vb)]"
  syntax:
    content: public int ValueCount { get; }
    return:
      type: System.Int32
      description: "在项中的名称/值对的数目。"
  overload: Microsoft.Win32.RegistryKey.ValueCount*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "用户没有密钥的读取的权限。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref>操作关闭 （不能访问已关闭的项）。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "用户没有必要的注册表权限。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "出现系统错误，例如当前项已被删除。"
  platform:
  - net462
- uid: Microsoft.Win32.RegistryKey.View
  id: View
  parent: Microsoft.Win32.RegistryKey
  langs:
  - csharp
  name: View
  nameWithType: RegistryKey.View
  fullName: Microsoft.Win32.RegistryKey.View
  type: Property
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "获取用于创建注册表项的视图。"
  remarks: "在 64 位版本的 Windows 中，对于 32 位和 64 位应用程序可以单独存储注册表的不同部分。 有了 32 位应用程序的 32 位视图和 64 位应用程序的 64 位视图。       不会假定其视图始终对应于<xref:Microsoft.Win32.RegistryKey>.</xref:Microsoft.Win32.RegistryKey>的实际视图"
  syntax:
    content: public Microsoft.Win32.RegistryView View { get; }
    return:
      type: Microsoft.Win32.RegistryView
      description: "用于创建注册表项的视图。       - <xref href=&quot;Microsoft.Win32.RegistryView&quot;> </xref>，如果已使用无视图。"
  overload: Microsoft.Win32.RegistryKey.View*
  exceptions: []
  platform:
  - net462
references:
- uid: System.MarshalByRefObject
  isExternal: false
  name: System.MarshalByRefObject
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: Microsoft.Win32.RegistryKey.Close
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: Close()
  nameWithType: RegistryKey.Close()
  fullName: Microsoft.Win32.RegistryKey.Close()
- uid: Microsoft.Win32.RegistryKey.CreateSubKey(System.String)
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: CreateSubKey(String)
  nameWithType: RegistryKey.CreateSubKey(String)
  fullName: Microsoft.Win32.RegistryKey.CreateSubKey(String)
- uid: Microsoft.Win32.RegistryKey
  parent: Microsoft.Win32
  isExternal: false
  name: RegistryKey
  nameWithType: RegistryKey
  fullName: Microsoft.Win32.RegistryKey
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck)
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: CreateSubKey(String,RegistryKeyPermissionCheck)
  nameWithType: RegistryKey.CreateSubKey(String,RegistryKeyPermissionCheck)
  fullName: Microsoft.Win32.RegistryKey.CreateSubKey(String,RegistryKeyPermissionCheck)
- uid: Microsoft.Win32.RegistryKeyPermissionCheck
  parent: Microsoft.Win32
  isExternal: false
  name: RegistryKeyPermissionCheck
  nameWithType: RegistryKeyPermissionCheck
  fullName: Microsoft.Win32.RegistryKeyPermissionCheck
- uid: Microsoft.Win32.RegistryKey.CreateSubKey(System.String,System.Boolean)
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: CreateSubKey(String,Boolean)
  nameWithType: RegistryKey.CreateSubKey(String,Boolean)
  fullName: Microsoft.Win32.RegistryKey.CreateSubKey(String,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,Microsoft.Win32.RegistryOptions)
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: CreateSubKey(String,RegistryKeyPermissionCheck,RegistryOptions)
  nameWithType: RegistryKey.CreateSubKey(String,RegistryKeyPermissionCheck,RegistryOptions)
  fullName: Microsoft.Win32.RegistryKey.CreateSubKey(String,RegistryKeyPermissionCheck,RegistryOptions)
- uid: Microsoft.Win32.RegistryOptions
  parent: Microsoft.Win32
  isExternal: false
  name: RegistryOptions
  nameWithType: RegistryOptions
  fullName: Microsoft.Win32.RegistryOptions
- uid: Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,System.Security.AccessControl.RegistrySecurity)
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: CreateSubKey(String,RegistryKeyPermissionCheck,RegistrySecurity)
  nameWithType: RegistryKey.CreateSubKey(String,RegistryKeyPermissionCheck,RegistrySecurity)
  fullName: Microsoft.Win32.RegistryKey.CreateSubKey(String,RegistryKeyPermissionCheck,RegistrySecurity)
- uid: System.Security.AccessControl.RegistrySecurity
  parent: System.Security.AccessControl
  isExternal: false
  name: RegistrySecurity
  nameWithType: RegistrySecurity
  fullName: System.Security.AccessControl.RegistrySecurity
- uid: Microsoft.Win32.RegistryKey.CreateSubKey(System.String,System.Boolean,Microsoft.Win32.RegistryOptions)
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: CreateSubKey(String,Boolean,RegistryOptions)
  nameWithType: RegistryKey.CreateSubKey(String,Boolean,RegistryOptions)
  fullName: Microsoft.Win32.RegistryKey.CreateSubKey(String,Boolean,RegistryOptions)
- uid: Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,Microsoft.Win32.RegistryOptions,System.Security.AccessControl.RegistrySecurity)
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: CreateSubKey(String,RegistryKeyPermissionCheck,RegistryOptions,RegistrySecurity)
  nameWithType: RegistryKey.CreateSubKey(String,RegistryKeyPermissionCheck,RegistryOptions,RegistrySecurity)
  fullName: Microsoft.Win32.RegistryKey.CreateSubKey(String,RegistryKeyPermissionCheck,RegistryOptions,RegistrySecurity)
- uid: Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: DeleteSubKey(String)
  nameWithType: RegistryKey.DeleteSubKey(String)
  fullName: Microsoft.Win32.RegistryKey.DeleteSubKey(String)
- uid: Microsoft.Win32.RegistryKey.DeleteSubKey(System.String,System.Boolean)
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: DeleteSubKey(String,Boolean)
  nameWithType: RegistryKey.DeleteSubKey(String,Boolean)
  fullName: Microsoft.Win32.RegistryKey.DeleteSubKey(String,Boolean)
- uid: Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: DeleteSubKeyTree(String)
  nameWithType: RegistryKey.DeleteSubKeyTree(String)
  fullName: Microsoft.Win32.RegistryKey.DeleteSubKeyTree(String)
- uid: Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String,System.Boolean)
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: DeleteSubKeyTree(String,Boolean)
  nameWithType: RegistryKey.DeleteSubKeyTree(String,Boolean)
  fullName: Microsoft.Win32.RegistryKey.DeleteSubKeyTree(String,Boolean)
- uid: Microsoft.Win32.RegistryKey.DeleteValue(System.String)
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: DeleteValue(String)
  nameWithType: RegistryKey.DeleteValue(String)
  fullName: Microsoft.Win32.RegistryKey.DeleteValue(String)
- uid: Microsoft.Win32.RegistryKey.DeleteValue(System.String,System.Boolean)
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: DeleteValue(String,Boolean)
  nameWithType: RegistryKey.DeleteValue(String,Boolean)
  fullName: Microsoft.Win32.RegistryKey.DeleteValue(String,Boolean)
- uid: Microsoft.Win32.RegistryKey.Dispose
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: Dispose()
  nameWithType: RegistryKey.Dispose()
  fullName: Microsoft.Win32.RegistryKey.Dispose()
- uid: Microsoft.Win32.RegistryKey.Flush
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: Flush()
  nameWithType: RegistryKey.Flush()
  fullName: Microsoft.Win32.RegistryKey.Flush()
- uid: Microsoft.Win32.RegistryKey.FromHandle(Microsoft.Win32.SafeHandles.SafeRegistryHandle)
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: FromHandle(SafeRegistryHandle)
  nameWithType: RegistryKey.FromHandle(SafeRegistryHandle)
  fullName: Microsoft.Win32.RegistryKey.FromHandle(SafeRegistryHandle)
- uid: Microsoft.Win32.SafeHandles.SafeRegistryHandle
  parent: Microsoft.Win32.SafeHandles
  isExternal: false
  name: SafeRegistryHandle
  nameWithType: SafeRegistryHandle
  fullName: Microsoft.Win32.SafeHandles.SafeRegistryHandle
- uid: Microsoft.Win32.RegistryKey.FromHandle(Microsoft.Win32.SafeHandles.SafeRegistryHandle,Microsoft.Win32.RegistryView)
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: FromHandle(SafeRegistryHandle,RegistryView)
  nameWithType: RegistryKey.FromHandle(SafeRegistryHandle,RegistryView)
  fullName: Microsoft.Win32.RegistryKey.FromHandle(SafeRegistryHandle,RegistryView)
- uid: Microsoft.Win32.RegistryView
  parent: Microsoft.Win32
  isExternal: false
  name: RegistryView
  nameWithType: RegistryView
  fullName: Microsoft.Win32.RegistryView
- uid: Microsoft.Win32.RegistryKey.GetAccessControl
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: GetAccessControl()
  nameWithType: RegistryKey.GetAccessControl()
  fullName: Microsoft.Win32.RegistryKey.GetAccessControl()
- uid: Microsoft.Win32.RegistryKey.GetAccessControl(System.Security.AccessControl.AccessControlSections)
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: GetAccessControl(AccessControlSections)
  nameWithType: RegistryKey.GetAccessControl(AccessControlSections)
  fullName: Microsoft.Win32.RegistryKey.GetAccessControl(AccessControlSections)
- uid: System.Security.AccessControl.AccessControlSections
  parent: System.Security.AccessControl
  isExternal: false
  name: AccessControlSections
  nameWithType: AccessControlSections
  fullName: System.Security.AccessControl.AccessControlSections
- uid: Microsoft.Win32.RegistryKey.GetSubKeyNames
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: GetSubKeyNames()
  nameWithType: RegistryKey.GetSubKeyNames()
  fullName: Microsoft.Win32.RegistryKey.GetSubKeyNames()
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: Microsoft.Win32.RegistryKey.GetValue(System.String)
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: GetValue(String)
  nameWithType: RegistryKey.GetValue(String)
  fullName: Microsoft.Win32.RegistryKey.GetValue(String)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: Microsoft.Win32.RegistryKey.GetValue(System.String,System.Object)
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: GetValue(String,Object)
  nameWithType: RegistryKey.GetValue(String,Object)
  fullName: Microsoft.Win32.RegistryKey.GetValue(String,Object)
- uid: Microsoft.Win32.RegistryKey.GetValue(System.String,System.Object,Microsoft.Win32.RegistryValueOptions)
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: GetValue(String,Object,RegistryValueOptions)
  nameWithType: RegistryKey.GetValue(String,Object,RegistryValueOptions)
  fullName: Microsoft.Win32.RegistryKey.GetValue(String,Object,RegistryValueOptions)
- uid: Microsoft.Win32.RegistryValueOptions
  parent: Microsoft.Win32
  isExternal: false
  name: RegistryValueOptions
  nameWithType: RegistryValueOptions
  fullName: Microsoft.Win32.RegistryValueOptions
- uid: Microsoft.Win32.RegistryKey.GetValueKind(System.String)
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: GetValueKind(String)
  nameWithType: RegistryKey.GetValueKind(String)
  fullName: Microsoft.Win32.RegistryKey.GetValueKind(String)
- uid: Microsoft.Win32.RegistryValueKind
  parent: Microsoft.Win32
  isExternal: false
  name: RegistryValueKind
  nameWithType: RegistryValueKind
  fullName: Microsoft.Win32.RegistryValueKind
- uid: Microsoft.Win32.RegistryKey.GetValueNames
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: GetValueNames()
  nameWithType: RegistryKey.GetValueNames()
  fullName: Microsoft.Win32.RegistryKey.GetValueNames()
- uid: Microsoft.Win32.RegistryKey.Handle
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: Handle
  nameWithType: RegistryKey.Handle
  fullName: Microsoft.Win32.RegistryKey.Handle
- uid: Microsoft.Win32.RegistryKey.Name
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: Name
  nameWithType: RegistryKey.Name
  fullName: Microsoft.Win32.RegistryKey.Name
- uid: Microsoft.Win32.RegistryKey.OpenBaseKey(Microsoft.Win32.RegistryHive,Microsoft.Win32.RegistryView)
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: OpenBaseKey(RegistryHive,RegistryView)
  nameWithType: RegistryKey.OpenBaseKey(RegistryHive,RegistryView)
  fullName: Microsoft.Win32.RegistryKey.OpenBaseKey(RegistryHive,RegistryView)
- uid: Microsoft.Win32.RegistryHive
  parent: Microsoft.Win32
  isExternal: false
  name: RegistryHive
  nameWithType: RegistryHive
  fullName: Microsoft.Win32.RegistryHive
- uid: Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: OpenRemoteBaseKey(RegistryHive,String)
  nameWithType: RegistryKey.OpenRemoteBaseKey(RegistryHive,String)
  fullName: Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(RegistryHive,String)
- uid: Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String,Microsoft.Win32.RegistryView)
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: OpenRemoteBaseKey(RegistryHive,String,RegistryView)
  nameWithType: RegistryKey.OpenRemoteBaseKey(RegistryHive,String,RegistryView)
  fullName: Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(RegistryHive,String,RegistryView)
- uid: Microsoft.Win32.RegistryKey.OpenSubKey(System.String)
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: OpenSubKey(String)
  nameWithType: RegistryKey.OpenSubKey(String)
  fullName: Microsoft.Win32.RegistryKey.OpenSubKey(String)
- uid: Microsoft.Win32.RegistryKey.OpenSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck)
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: OpenSubKey(String,RegistryKeyPermissionCheck)
  nameWithType: RegistryKey.OpenSubKey(String,RegistryKeyPermissionCheck)
  fullName: Microsoft.Win32.RegistryKey.OpenSubKey(String,RegistryKeyPermissionCheck)
- uid: Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: OpenSubKey(String,Boolean)
  nameWithType: RegistryKey.OpenSubKey(String,Boolean)
  fullName: Microsoft.Win32.RegistryKey.OpenSubKey(String,Boolean)
- uid: Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Security.AccessControl.RegistryRights)
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: OpenSubKey(String,RegistryRights)
  nameWithType: RegistryKey.OpenSubKey(String,RegistryRights)
  fullName: Microsoft.Win32.RegistryKey.OpenSubKey(String,RegistryRights)
- uid: System.Security.AccessControl.RegistryRights
  parent: System.Security.AccessControl
  isExternal: false
  name: RegistryRights
  nameWithType: RegistryRights
  fullName: System.Security.AccessControl.RegistryRights
- uid: Microsoft.Win32.RegistryKey.OpenSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,System.Security.AccessControl.RegistryRights)
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: OpenSubKey(String,RegistryKeyPermissionCheck,RegistryRights)
  nameWithType: RegistryKey.OpenSubKey(String,RegistryKeyPermissionCheck,RegistryRights)
  fullName: Microsoft.Win32.RegistryKey.OpenSubKey(String,RegistryKeyPermissionCheck,RegistryRights)
- uid: Microsoft.Win32.RegistryKey.SetAccessControl(System.Security.AccessControl.RegistrySecurity)
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: SetAccessControl(RegistrySecurity)
  nameWithType: RegistryKey.SetAccessControl(RegistrySecurity)
  fullName: Microsoft.Win32.RegistryKey.SetAccessControl(RegistrySecurity)
- uid: Microsoft.Win32.RegistryKey.SetValue(System.String,System.Object)
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: SetValue(String,Object)
  nameWithType: RegistryKey.SetValue(String,Object)
  fullName: Microsoft.Win32.RegistryKey.SetValue(String,Object)
- uid: Microsoft.Win32.RegistryKey.SetValue(System.String,System.Object,Microsoft.Win32.RegistryValueKind)
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: SetValue(String,Object,RegistryValueKind)
  nameWithType: RegistryKey.SetValue(String,Object,RegistryValueKind)
  fullName: Microsoft.Win32.RegistryKey.SetValue(String,Object,RegistryValueKind)
- uid: Microsoft.Win32.RegistryKey.SubKeyCount
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: SubKeyCount
  nameWithType: RegistryKey.SubKeyCount
  fullName: Microsoft.Win32.RegistryKey.SubKeyCount
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: Microsoft.Win32.RegistryKey.ToString
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: ToString()
  nameWithType: RegistryKey.ToString()
  fullName: Microsoft.Win32.RegistryKey.ToString()
- uid: Microsoft.Win32.RegistryKey.ValueCount
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: ValueCount
  nameWithType: RegistryKey.ValueCount
  fullName: Microsoft.Win32.RegistryKey.ValueCount
- uid: Microsoft.Win32.RegistryKey.View
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: View
  nameWithType: RegistryKey.View
  fullName: Microsoft.Win32.RegistryKey.View
- uid: Microsoft.Win32.RegistryKey.Close*
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: Close
  nameWithType: RegistryKey.Close
- uid: Microsoft.Win32.RegistryKey.CreateSubKey*
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: CreateSubKey
  nameWithType: RegistryKey.CreateSubKey
- uid: Microsoft.Win32.RegistryKey.DeleteSubKey*
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: DeleteSubKey
  nameWithType: RegistryKey.DeleteSubKey
- uid: Microsoft.Win32.RegistryKey.DeleteSubKeyTree*
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: DeleteSubKeyTree
  nameWithType: RegistryKey.DeleteSubKeyTree
- uid: Microsoft.Win32.RegistryKey.DeleteValue*
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: DeleteValue
  nameWithType: RegistryKey.DeleteValue
- uid: Microsoft.Win32.RegistryKey.Dispose*
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: Dispose
  nameWithType: RegistryKey.Dispose
- uid: Microsoft.Win32.RegistryKey.Flush*
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: Flush
  nameWithType: RegistryKey.Flush
- uid: Microsoft.Win32.RegistryKey.FromHandle*
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: FromHandle
  nameWithType: RegistryKey.FromHandle
- uid: Microsoft.Win32.RegistryKey.GetAccessControl*
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: GetAccessControl
  nameWithType: RegistryKey.GetAccessControl
- uid: Microsoft.Win32.RegistryKey.GetSubKeyNames*
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: GetSubKeyNames
  nameWithType: RegistryKey.GetSubKeyNames
- uid: Microsoft.Win32.RegistryKey.GetValue*
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: GetValue
  nameWithType: RegistryKey.GetValue
- uid: Microsoft.Win32.RegistryKey.GetValueKind*
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: GetValueKind
  nameWithType: RegistryKey.GetValueKind
- uid: Microsoft.Win32.RegistryKey.GetValueNames*
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: GetValueNames
  nameWithType: RegistryKey.GetValueNames
- uid: Microsoft.Win32.RegistryKey.Handle*
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: Handle
  nameWithType: RegistryKey.Handle
- uid: Microsoft.Win32.RegistryKey.Name*
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: Name
  nameWithType: RegistryKey.Name
- uid: Microsoft.Win32.RegistryKey.OpenBaseKey*
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: OpenBaseKey
  nameWithType: RegistryKey.OpenBaseKey
- uid: Microsoft.Win32.RegistryKey.OpenRemoteBaseKey*
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: OpenRemoteBaseKey
  nameWithType: RegistryKey.OpenRemoteBaseKey
- uid: Microsoft.Win32.RegistryKey.OpenSubKey*
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: OpenSubKey
  nameWithType: RegistryKey.OpenSubKey
- uid: Microsoft.Win32.RegistryKey.SetAccessControl*
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: SetAccessControl
  nameWithType: RegistryKey.SetAccessControl
- uid: Microsoft.Win32.RegistryKey.SetValue*
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: SetValue
  nameWithType: RegistryKey.SetValue
- uid: Microsoft.Win32.RegistryKey.SubKeyCount*
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: SubKeyCount
  nameWithType: RegistryKey.SubKeyCount
- uid: Microsoft.Win32.RegistryKey.ToString*
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: ToString
  nameWithType: RegistryKey.ToString
- uid: Microsoft.Win32.RegistryKey.ValueCount*
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: ValueCount
  nameWithType: RegistryKey.ValueCount
- uid: Microsoft.Win32.RegistryKey.View*
  parent: Microsoft.Win32.RegistryKey
  isExternal: false
  name: View
  nameWithType: RegistryKey.View
