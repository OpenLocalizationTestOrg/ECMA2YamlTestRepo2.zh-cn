### YamlMime:ManagedReference
items:
- uid: System.Runtime.Remoting.RemotingServices
  id: RemotingServices
  children:
  - System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String)
  - System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String,System.Object)
  - System.Runtime.Remoting.RemotingServices.Disconnect(System.MarshalByRefObject)
  - System.Runtime.Remoting.RemotingServices.ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)
  - System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(System.MarshalByRefObject)
  - System.Runtime.Remoting.RemotingServices.GetLifetimeService(System.MarshalByRefObject)
  - System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  - System.Runtime.Remoting.RemotingServices.GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Runtime.Remoting.RemotingServices.GetObjectUri(System.MarshalByRefObject)
  - System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(System.MarshalByRefObject)
  - System.Runtime.Remoting.RemotingServices.GetRealProxy(System.Object)
  - System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(System.String)
  - System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  - System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)
  - System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(System.Object)
  - System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(System.Object)
  - System.Runtime.Remoting.RemotingServices.IsOneWay(System.Reflection.MethodBase)
  - System.Runtime.Remoting.RemotingServices.IsTransparentProxy(System.Object)
  - System.Runtime.Remoting.RemotingServices.LogRemotingStage(System.Int32)
  - System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)
  - System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String)
  - System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String,System.Type)
  - System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(System.MarshalByRefObject,System.String)
  - System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef)
  - System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)
  langs:
  - csharp
  name: RemotingServices
  nameWithType: RemotingServices
  fullName: System.Runtime.Remoting.RemotingServices
  type: Class
  summary: "有关使用和发布进行远程处理对象和代理提供若干方法。 此类不能被继承。"
  remarks: "除非您是问题，如激活、 生存期管理或事务处理的服务提供商，你不需要区分代理引用和对象引用。 远程处理基础结构使用给出的远程对象驻留在客户端的空间的印象的透明代理。 代理服务器来实现此调用在远程位置的实际对象对其进行转发。"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public static class RemotingServices
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String)
  id: Connect(System.Type,System.String)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Connect(Type,String)
  nameWithType: RemotingServices.Connect(Type,String)
  fullName: System.Runtime.Remoting.RemotingServices.Connect(Type,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "为创建一个代理的已知对象，提供<xref:System.Type>和 URL。</xref:System.Type>"
  remarks: "返回的代理对象指向由指定的已知对象服务的终结点。 对此代理调用方法之前通过网络不发送任何消息。"
  example:
  - "The following code example demonstrates how to use the Connect method to create a proxy to a well-known object.  \n  \n [!code-cpp[RemotingServices.BasicSample#1](~/add/codesnippet/cpp/m-system.runtime.remotin_104_1.cpp)]\n [!code-cs[RemotingServices.BasicSample#1](~/add/codesnippet/csharp/m-system.runtime.remotin_104_1.cs)]\n [!code-vb[RemotingServices.BasicSample#1](~/add/codesnippet/visualbasic/m-system.runtime.remotin_104_1.vb)]"
  syntax:
    content: public static object Connect (Type classToProxy, string url);
    parameters:
    - id: classToProxy
      type: System.Type
      description: "<xref:System.Type>你想要连接的服务器端上的已知对象。</xref:System.Type>"
    - id: url
      type: System.String
      description: "服务器类的 URL。"
    return:
      type: System.Object
      description: "指向由指定的已知对象服务的终结点的远程对象的代理。"
  overload: System.Runtime.Remoting.RemotingServices.Connect*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "直接调用方没有权限来配置远程处理类型和信道。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String,System.Object)
  id: Connect(System.Type,System.String,System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Connect(Type,String,Object)
  nameWithType: RemotingServices.Connect(Type,String,Object)
  fullName: System.Runtime.Remoting.RemotingServices.Connect(Type,String,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "为创建一个代理的已知对象，提供<xref:System.Type>，URL 和通道特定的数据。</xref:System.Type>"
  remarks: "返回的代理对象指向由指定的已知对象服务的终结点。 对此代理调用方法之前通过网络不发送任何消息。       `data`对象可用于将信息传递给通道，并传递给<xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=fullName>方法。</xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=fullName>"
  syntax:
    content: public static object Connect (Type classToProxy, string url, object data);
    parameters:
    - id: classToProxy
      type: System.Type
      description: "<xref:System.Type>你想要连接的已知对象。</xref:System.Type>"
    - id: url
      type: System.String
      description: "已知对象的 URL。"
    - id: data
      type: System.Object
      description: "通道特定的数据。 Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Object
      description: "代理，它指向由所请求的已知对象服务的终结点。"
  overload: System.Runtime.Remoting.RemotingServices.Connect*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "直接调用方没有权限来配置远程处理类型和信道。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Disconnect(System.MarshalByRefObject)
  id: Disconnect(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Disconnect(MarshalByRefObject)
  nameWithType: RemotingServices.Disconnect(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.Disconnect(MarshalByRefObject)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "停止接收通过已注册的远程处理信道更多的信息的对象。"
  remarks: ''
  example:
  - "The following code example demonstrates how to use the Disconnect method to disconnect an object from the remoting channels.  \n  \n [!code-cpp[RemotingServices.BasicSample#2](~/add/codesnippet/cpp/m-system.runtime.remotin_81_1.cpp)]\n [!code-cs[RemotingServices.BasicSample#2](~/add/codesnippet/csharp/m-system.runtime.remotin_81_1.cs)]\n [!code-vb[RemotingServices.BasicSample#2](~/add/codesnippet/visualbasic/m-system.runtime.remotin_81_1.vb)]"
  syntax:
    content: public static bool Disconnect (MarshalByRefObject obj);
    parameters:
    - id: obj
      type: System.MarshalByRefObject
      description: "若要从其通道断开连接的对象。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果对象已成功，则与已注册的远程处理信道断开连接否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Runtime.Remoting.RemotingServices.Disconnect*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>obj</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> obj </code>参数是一个代理。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "直接调用方没有权限来配置远程处理类型和信道。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)
  id: ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: ExecuteMessage(MarshalByRefObject,IMethodCallMessage)
  nameWithType: RemotingServices.ExecuteMessage(MarshalByRefObject,IMethodCallMessage)
  fullName: System.Runtime.Remoting.RemotingServices.ExecuteMessage(MarshalByRefObject,IMethodCallMessage)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "连接到指定的远程对象，并执行提供<xref href=&quot;System.Runtime.Remoting.Messaging.IMethodCallMessage&quot;></xref>在其上。"
  remarks: "当前方法用于在特殊情况下由服务器转发到另一个，可能是远程对象指定的方法调用。 只有当调用方处于合适的上下文中时，可以调用此方法。"
  example:
  - "The following code example demonstrates how to use the ExecuteMessage method to forward method calls to remote objects.  \n  \n [!code-cs[RemotingServices.ExecuteMessage#1](~/add/codesnippet/csharp/491f5c62-582d-42d8-b526-_1.cs)]\n [!code-cpp[RemotingServices.ExecuteMessage#1](~/add/codesnippet/cpp/491f5c62-582d-42d8-b526-_1.cpp)]\n [!code-vb[RemotingServices.ExecuteMessage#1](~/add/codesnippet/visualbasic/491f5c62-582d-42d8-b526-_1.vb)]"
  syntax:
    content: public static System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage (MarshalByRefObject target, System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg);
    parameters:
    - id: target
      type: System.MarshalByRefObject
      description: "远程对象你想要调用的方法。"
    - id: reqMsg
      type: System.Runtime.Remoting.Messaging.IMethodCallMessage
      description: "方法调用消息到指定的远程对象的方法。"
    return:
      type: System.Runtime.Remoting.Messaging.IMethodReturnMessage
      description: "远程方法的响应。"
  overload: System.Runtime.Remoting.RemotingServices.ExecuteMessage*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "直接调用方没有基础结构权限。"
  - type: System.Runtime.Remoting.RemotingException
    commentId: T:System.Runtime.Remoting.RemotingException
    description: "对象的本机上下文之外的上下文从调用了方法。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(System.MarshalByRefObject)
  id: GetEnvoyChainForProxy(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetEnvoyChainForProxy(MarshalByRefObject)
  nameWithType: RemotingServices.GetEnvoyChainForProxy(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(MarshalByRefObject)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "返回将消息发送到由指定的代理的远程对象时应使用的 envoy 接收器链。"
  remarks: "Envoy 接收器是一起发送的接收器<xref:System.Runtime.Remoting.ObjRef>时向该对象返回消息使用的对象。</xref:System.Runtime.Remoting.ObjRef> 当前方法返回的对象的代理和对象本身之间进行通信时使用的 envoy 接收器。"
  syntax:
    content: public static System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy (MarshalByRefObject obj);
    parameters:
    - id: obj
      type: System.MarshalByRefObject
      description: "与之关联的代理服务器的请求 envoy 接收器的远程对象。"
    return:
      type: System.Runtime.Remoting.Messaging.IMessageSink
      description: "与指定的代理相关联的 envoy 接收器链。"
  overload: System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "直接调用方没有基础结构权限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetLifetimeService(System.MarshalByRefObject)
  id: GetLifetimeService(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetLifetimeService(MarshalByRefObject)
  nameWithType: RemotingServices.GetLifetimeService(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetLifetimeService(MarshalByRefObject)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "返回的生存期服务对象，控制指定的对象的生存期策略。"
  remarks: "对于默认值将<xref:System.Runtime.Remoting.Lifetime.ILease>.</xref:System.Runtime.Remoting.Lifetime.ILease>类型的对象生存期服务返回的对象。 如果`obj`参数是`null`，该方法返回`null`。"
  example:
  - "The following code example demonstrates how to use the GetLifetimeService method to get a lifetime lease for the specified object.  \n  \n [!code-cpp[RemotingServices.TimerSample#1](~/add/codesnippet/cpp/a7d2891c-3dad-448c-949c-_1.cpp)]\n [!code-cs[RemotingServices.TimerSample#1](~/add/codesnippet/csharp/a7d2891c-3dad-448c-949c-_1.cs)]\n [!code-vb[RemotingServices.TimerSample#1](~/add/codesnippet/visualbasic/a7d2891c-3dad-448c-949c-_1.vb)]  \n  \n To compile and run this example, you will need to compile and run a server, timerserver.exe, and compile a shared library, timerservice.dll.  \n  \n The source for timerserver.exe follows:  \n  \n [!code-vb[RemotingServices.TimerSample#2](~/add/codesnippet/visualbasic/a7d2891c-3dad-448c-949c-_2.vb)]\n [!code-cs[RemotingServices.TimerSample#2](~/add/codesnippet/csharp/a7d2891c-3dad-448c-949c-_2.cs)]  \n  \n The source for timerservice.dll follows:  \n  \n [!code-vb[RemotingServices.TimerSample#3](~/add/codesnippet/visualbasic/a7d2891c-3dad-448c-949c-_3.vb)]\n [!code-cs[RemotingServices.TimerSample#3](~/add/codesnippet/csharp/a7d2891c-3dad-448c-949c-_3.cs)]"
  syntax:
    content: public static object GetLifetimeService (MarshalByRefObject obj);
    parameters:
    - id: obj
      type: System.MarshalByRefObject
      description: "要获得生存期服务的对象。"
    return:
      type: System.Object
      description: "控制的生存期的对象<code> obj </code>。"
  overload: System.Runtime.Remoting.RemotingServices.GetLifetimeService*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "直接调用方没有基础结构权限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  id: GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetMethodBaseFromMethodMessage(IMethodMessage)
  nameWithType: RemotingServices.GetMethodBaseFromMethodMessage(IMethodMessage)
  fullName: System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(IMethodMessage)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "返回方法的给定<xref href=&quot;System.Runtime.Remoting.Messaging.IMethodMessage&quot;> </xref>。"
  remarks: "这将确定从基方法<xref:System.Runtime.Remoting.Messaging.IMethodMessage.TypeName%2A>， <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodName%2A>，和<xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodSignature%2A>属性<xref:System.Runtime.Remoting.Messaging.IMethodMessage>和实现的类使用<xref:System.Runtime.Remoting.Messaging.IMethodMessage>接口。</xref:System.Runtime.Remoting.Messaging.IMethodMessage> </xref:System.Runtime.Remoting.Messaging.IMethodMessage> </xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodSignature%2A> </xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodName%2A> </xref:System.Runtime.Remoting.Messaging.IMethodMessage.TypeName%2A> 使用者<xref:System.Runtime.Remoting.Messaging.IMethodMessage>类应引用<xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodBase%2A?displayProperty=fullName>属性。</xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodBase%2A?displayProperty=fullName> </xref:System.Runtime.Remoting.Messaging.IMethodMessage>"
  syntax:
    content: public static System.Reflection.MethodBase GetMethodBaseFromMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);
    parameters:
    - id: msg
      type: System.Runtime.Remoting.Messaging.IMethodMessage
      description: "方法将消息以提取从基本的方法。"
    return:
      type: System.Reflection.MethodBase
      description: "从提取方法基<code> msg </code>参数。"
  overload: System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "直接调用方没有基础结构权限，或者至少一个调用堆栈中较高的调用方没有权限检索的非公共成员的类型信息。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetObjectData(Object,SerializationInfo,StreamingContext)
  nameWithType: RemotingServices.GetObjectData(Object,SerializationInfo,StreamingContext)
  fullName: System.Runtime.Remoting.RemotingServices.GetObjectData(Object,SerializationInfo,StreamingContext)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "将指定的封送按引用对象序列化到提供<xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref>。"
  syntax:
    content: public static void GetObjectData (object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: obj
      type: System.Object
      description: "要序列化的对象。"
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "<xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref>到的对象序列化。"
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "源和目标的序列化。"
  overload: System.Runtime.Remoting.RemotingServices.GetObjectData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>obj</code> or <code>info</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "直接调用方没有基础结构权限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetObjectUri(System.MarshalByRefObject)
  id: GetObjectUri(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetObjectUri(MarshalByRefObject)
  nameWithType: RemotingServices.GetObjectUri(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetObjectUri(MarshalByRefObject)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "检索指定对象的 URI。"
  remarks: ''
  example:
  - >-
    [!code-vb[System.Runtime.Remoting.RemotingServices#18](~/add/codesnippet/visualbasic/318892c3-7b62-40bd-9e3b-_1.vb)]
     [!code-cs[System.Runtime.Remoting.RemotingServices#18](~/add/codesnippet/csharp/318892c3-7b62-40bd-9e3b-_1.cs)]
     [!code-cpp[System.Runtime.Remoting.RemotingServices#18](~/add/codesnippet/cpp/318892c3-7b62-40bd-9e3b-_1.cpp)]
  syntax:
    content: public static string GetObjectUri (MarshalByRefObject obj);
    parameters:
    - id: obj
      type: System.MarshalByRefObject
      description: "<xref href=&quot;System.MarshalByRefObject&quot;> </xref>为其请求 URI。"
    return:
      type: System.String
      description: "如果有，指定的对象的 URI 或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果该对象尚未被封送。"
  overload: System.Runtime.Remoting.RemotingServices.GetObjectUri*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "直接调用方没有基础结构权限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(System.MarshalByRefObject)
  id: GetObjRefForProxy(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetObjRefForProxy(MarshalByRefObject)
  nameWithType: RemotingServices.GetObjRefForProxy(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(MarshalByRefObject)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "返回<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> ，表示从指定的代理的远程对象。"
  remarks: "A<xref:System.Runtime.Remoting.ObjRef>是用于跨应用程序域边界传输对象引用的对象的可序列化表示。</xref:System.Runtime.Remoting.ObjRef> 创建<xref:System.Runtime.Remoting.ObjRef>的对象称为封送处理。</xref:System.Runtime.Remoting.ObjRef> <xref:System.Runtime.Remoting.ObjRef>可以通过信道传输到另一个应用程序域 （可能在另一个进程或计算机）。</xref:System.Runtime.Remoting.ObjRef> 在其他应用程序域中一次<xref:System.Runtime.Remoting.ObjRef>必须对其进行分析以创建对象，通常连接到真实的对象的代理。</xref:System.Runtime.Remoting.ObjRef> 此操作称为取消封送。 在取消封送，<xref:System.Runtime.Remoting.ObjRef>进行分析，以提取远程对象和透明的代理的方法信息和<xref:System.Runtime.Remoting.Proxies.RealProxy>创建对象。</xref:System.Runtime.Remoting.Proxies.RealProxy> </xref:System.Runtime.Remoting.ObjRef>       A<xref:System.Runtime.Remoting.ObjRef>包含描述信息<xref:System.Type>和正封送的对象类，一个 URI，唯一标识的特定对象实例和通信相关的有关如何访问远程应用程序对象所在的位置的信息。</xref:System.Type> </xref:System.Runtime.Remoting.ObjRef>"
  example:
  - "The following code example demonstrates how to get a <xref:System.Runtime.Remoting.ObjRef> instance for the specified object.  \n  \n [!code-cpp[RemotingServices.GetObjRefForProxy#1](~/add/codesnippet/cpp/d6ce9a9a-8ec9-4559-9b2d-_1.cpp)]\n [!code-vb[RemotingServices.GetObjRefForProxy#1](~/add/codesnippet/visualbasic/d6ce9a9a-8ec9-4559-9b2d-_1.vb)]\n [!code-cs[RemotingServices.GetObjRefForProxy#1](~/add/codesnippet/csharp/d6ce9a9a-8ec9-4559-9b2d-_1.cs)]"
  syntax:
    content: public static System.Runtime.Remoting.ObjRef GetObjRefForProxy (MarshalByRefObject obj);
    parameters:
    - id: obj
      type: System.MarshalByRefObject
      description: "代理连接到你想要创建的对象<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;></xref>有关。"
    return:
      type: System.Runtime.Remoting.ObjRef
      description: "A <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref>表示指定的代理连接到，该远程对象或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果对象或代理不已封送。"
  overload: System.Runtime.Remoting.RemotingServices.GetObjRefForProxy*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "直接调用方没有基础结构权限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetRealProxy(System.Object)
  id: GetRealProxy(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetRealProxy(Object)
  nameWithType: RemotingServices.GetRealProxy(Object)
  fullName: System.Runtime.Remoting.RemotingServices.GetRealProxy(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "返回指定的透明代理后面的真实代理。"
  remarks: "使用对象在任何类型的远程边界之间的客户端实际的对象使用透明的代理。 透明代理使效果实际对象驻留在客户端的空间。 它从而实现此目的转发到使用远程处理基础结构的实际对象对其进行调用。       由类型<xref:System.Runtime.Remoting.Proxies.RealProxy>.</xref:System.Runtime.Remoting.Proxies.RealProxy>的托管的运行时类的实例支持透明代理 <xref:System.Runtime.Remoting.Proxies.RealProxy>实现透明代理转发操作所需的功能的一部分。</xref:System.Runtime.Remoting.Proxies.RealProxy>       代理对象继承关联的托管对象，如垃圾收集、 成员和方法，支持语义，可以扩展以形成新类。 代理充当远程对象 （透明代理），与相同的类的对象，并且也是托管的对象。"
  syntax:
    content: public static System.Runtime.Remoting.Proxies.RealProxy GetRealProxy (object proxy);
    parameters:
    - id: proxy
      type: System.Object
      description: "一个透明的代理。"
    return:
      type: System.Runtime.Remoting.Proxies.RealProxy
      description: "透明代理后面真实代理实例。"
  overload: System.Runtime.Remoting.RemotingServices.GetRealProxy*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "直接调用方没有基础结构权限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(System.String)
  id: GetServerTypeForUri(System.String)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetServerTypeForUri(String)
  nameWithType: RemotingServices.GetServerTypeForUri(String)
  fullName: System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "返回<xref:System.Type>，该对象具有指定的 URI。</xref:System.Type>"
  remarks: "远程处理使用标识终结点 Uri，因为 GetServerTypeForUri 方法是在使用远程处理基础结构 （例如，信道接收器、 动态接收器和上下文接收器） 的可插入部分中非常有用<xref:System.Runtime.Remoting.Messaging.IMessage>对象，因为当前方法将返回的 URI 中的关联的类型对象。</xref:System.Runtime.Remoting.Messaging.IMessage>"
  example:
  - >-
    [!code-vb[System.Runtime.Remoting.RemotingServices#7](~/add/codesnippet/visualbasic/m-system.runtime.remotin_84_1.vb)]
     [!code-cs[System.Runtime.Remoting.RemotingServices#7](~/add/codesnippet/csharp/m-system.runtime.remotin_84_1.cs)]
     [!code-cpp[System.Runtime.Remoting.RemotingServices#7](~/add/codesnippet/cpp/m-system.runtime.remotin_84_1.cpp)]
  syntax:
    content: public static Type GetServerTypeForUri (string URI);
    parameters:
    - id: URI
      type: System.String
      description: "对象的 URI 其<xref:System.Type>请求。</xref:System.Type>"
    return:
      type: System.Type
      description: "<xref:System.Type>，该对象具有指定的 URI。</xref:System.Type>"
  overload: System.Runtime.Remoting.RemotingServices.GetServerTypeForUri*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "直接调用方没有基础结构权限，或者至少一个调用堆栈中较高的调用方没有权限检索的非公共成员的类型信息。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  id: GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetSessionIdForMethodMessage(IMethodMessage)
  nameWithType: RemotingServices.GetSessionIdForMethodMessage(IMethodMessage)
  fullName: System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(IMethodMessage)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "检索消息的会话 ID。"
  remarks: "相同的会话 ID 可能返回的对象在同一应用程序，但此方法将永远不会返回不同的远程应用程序中的两个对象相同的会话 ID。       有关会话和会话 Id 标识的详细信息，请参阅 ASP.Net [ASP.NET 会话状态概述](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example demonstrates how to get the session ID string for the current session.  \n  \n [!code-cs[RemotingServices.ExecuteMessage#1](~/add/codesnippet/csharp/b83444fc-48c3-47e9-b264-_1.cs)]\n [!code-cpp[RemotingServices.ExecuteMessage#1](~/add/codesnippet/cpp/b83444fc-48c3-47e9-b264-_1.cpp)]\n [!code-vb[RemotingServices.ExecuteMessage#1](~/add/codesnippet/visualbasic/b83444fc-48c3-47e9-b264-_1.vb)]"
  syntax:
    content: public static string GetSessionIdForMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);
    parameters:
    - id: msg
      type: System.Runtime.Remoting.Messaging.IMethodMessage
      description: "<xref href=&quot;System.Runtime.Remoting.Messaging.IMethodMessage&quot;> </xref>为其请求的会话 ID。"
    return:
      type: System.String
      description: "唯一标识当前会话的会话 ID 字符串。"
  overload: System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "直接调用方没有基础结构权限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)
  id: IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: IsMethodOverloaded(IMethodMessage)
  nameWithType: RemotingServices.IsMethodOverloaded(IMethodMessage)
  fullName: System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(IMethodMessage)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "返回一个布尔值，该值指示是否重载中给定的消息的方法。"
  syntax:
    content: public static bool IsMethodOverloaded (System.Runtime.Remoting.Messaging.IMethodMessage msg);
    parameters:
    - id: msg
      type: System.Runtime.Remoting.Messaging.IMethodMessage
      description: "包含对问题的方法的调用的消息。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果调用该方法<code> msg </code>重载; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Runtime.Remoting.RemotingServices.IsMethodOverloaded*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "直接调用方没有基础结构权限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(System.Object)
  id: IsObjectOutOfAppDomain(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: IsObjectOutOfAppDomain(Object)
  nameWithType: RemotingServices.IsObjectOutOfAppDomain(Object)
  fullName: System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "返回一个布尔值，指示在调用当前方法的对象的不同的应用程序域中是否包含给定的透明代理指定的对象。"
  remarks: "有关应用程序域的信息，请参阅[应用程序域](http://msdn.microsoft.com/en-us/39e57d07-a740-4cd4-ae82-e119ea3856c1)。"
  example:
  - >-
    [!code-cpp[RemotingServices IsObject Snippets#1](~/add/codesnippet/cpp/m-system.runtime.remotin_103_1.cpp)]
     [!code-vb[RemotingServices IsObject Snippets#1](~/add/codesnippet/visualbasic/m-system.runtime.remotin_103_1.vb)]
     [!code-cs[RemotingServices IsObject Snippets#1](~/add/codesnippet/csharp/m-system.runtime.remotin_103_1.cs)]
  syntax:
    content: public static bool IsObjectOutOfAppDomain (object tp);
    parameters:
    - id: tp
      type: System.Object
      description: "要检查的对象。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果对象超出当前的应用程序域;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(System.Object)
  id: IsObjectOutOfContext(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: IsObjectOutOfContext(Object)
  nameWithType: RemotingServices.IsObjectOutOfContext(Object)
  fullName: System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "返回一个布尔值，指示调用当前方法的对象之外的其他上下文中是否包含给定代理所表示的对象。"
  remarks: "上下文是定义的环境可用于驻留在其中的对象的属性的有序。 在配置为要求某些自动服务，此类同步、 事务、 中实时激活、 安全性和等等的对象的激活过程会创建上下文。 多个对象可以存在于一个上下文。"
  example:
  - >-
    [!code-cpp[RemotingServices IsObject Snippets#1](~/add/codesnippet/cpp/m-system.runtime.remotin_37_1.cpp)]
     [!code-vb[RemotingServices IsObject Snippets#1](~/add/codesnippet/visualbasic/m-system.runtime.remotin_37_1.vb)]
     [!code-cs[RemotingServices IsObject Snippets#1](~/add/codesnippet/csharp/m-system.runtime.remotin_37_1.cs)]
  syntax:
    content: public static bool IsObjectOutOfContext (object tp);
    parameters:
    - id: tp
      type: System.Object
      description: "要检查的对象。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果对象不在当前上下文中;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.IsOneWay(System.Reflection.MethodBase)
  id: IsOneWay(System.Reflection.MethodBase)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: IsOneWay(MethodBase)
  nameWithType: RemotingServices.IsOneWay(MethodBase)
  fullName: System.Runtime.Remoting.RemotingServices.IsOneWay(MethodBase)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "返回一个布尔值，该值指示给定的消息中指定客户端调用了方法是否正在等待服务器以完成才会继续执行处理的方法。"
  remarks: "当调用单向方法时，客户端不会等待服务器以完成处理消息。 在客户端方法返回的应用程序不知道服务器将成功处理该消息。 方法被标记为一种方法使用<xref:System.Runtime.Remoting.Messaging.OneWayAttribute>.</xref:System.Runtime.Remoting.Messaging.OneWayAttribute>       单向方法不能有返回值或任何 out 参数。"
  example:
  - >-
    [!code-vb[System.Runtime.Remoting.RemotingServices#2](~/add/codesnippet/visualbasic/e9c4a9fc-d92a-4e43-97a5-_1.vb)]
     [!code-cs[System.Runtime.Remoting.RemotingServices#2](~/add/codesnippet/csharp/e9c4a9fc-d92a-4e43-97a5-_1.cs)]
     [!code-cpp[System.Runtime.Remoting.RemotingServices#2](~/add/codesnippet/cpp/e9c4a9fc-d92a-4e43-97a5-_1.cpp)]
  syntax:
    content: public static bool IsOneWay (System.Reflection.MethodBase method);
    parameters:
    - id: method
      type: System.Reflection.MethodBase
      description: "该问题的方法。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果该方法是一种方法;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Runtime.Remoting.RemotingServices.IsOneWay*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "直接调用方没有基础结构权限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.IsTransparentProxy(System.Object)
  id: IsTransparentProxy(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: IsTransparentProxy(Object)
  nameWithType: RemotingServices.IsTransparentProxy(Object)
  fullName: System.Runtime.Remoting.RemotingServices.IsTransparentProxy(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "返回一个布尔值，该值指示给定的对象是否透明代理还是真实对象。"
  remarks: "使用对象在任何类型的远程边界之间的客户端实际的对象使用透明的代理。 透明代理使效果实际对象驻留在客户端的空间。 它从而实现此目的转发到使用远程处理基础结构的实际对象对其进行调用。       透明代理是本身由类型<xref:System.Runtime.Remoting.Proxies.RealProxy>.</xref:System.Runtime.Remoting.Proxies.RealProxy>的托管的运行时类的实例 <xref:System.Runtime.Remoting.Proxies.RealProxy>实现透明代理转发操作所需的功能的一部分。</xref:System.Runtime.Remoting.Proxies.RealProxy> 代理对象继承关联的托管对象，如垃圾收集、 成员和方法，支持语义，可以扩展以形成新类。 因此，该代理具有双重特性;一方面它需要充当远程对象 （透明代理），与相同的类的对象，并且在其他它是托管的对象本身。       代理对象可以使用一种<xref:System.AppDomain>。</xref:System.AppDomain>中不考虑 应用程序不需要区分代理引用和对象引用。 但是，处理问题，如激活的服务提供商，生命期管理和事务需要进行这种区分。"
  example:
  - "The following code example demonstrates the use of the IsTransparentProxy method to determine whether an object is a proxy or a real object. For the complete example code, see the example for the <xref:System.Runtime.Remoting.Messaging.AsyncResult> class.  \n  \n [!code-cpp[AsyncResult.NewExamples#6](~/add/codesnippet/cpp/m-system.runtime.remotin_47_1.cpp)]\n [!code-vb[AsyncResult.NewExamples#6](~/add/codesnippet/visualbasic/m-system.runtime.remotin_47_1.vb)]\n [!code-cs[AsyncResult.NewExamples#6](~/add/codesnippet/csharp/m-system.runtime.remotin_47_1.cs)]"
  syntax:
    content: public static bool IsTransparentProxy (object proxy);
    parameters:
    - id: proxy
      type: System.Object
      description: "对要检查的对象的引用。"
    return:
      type: System.Boolean
      description: "一个布尔值，该值指示是否在指定的对象<code> proxy </code>参数是透明的代理或真实对象。"
  overload: System.Runtime.Remoting.RemotingServices.IsTransparentProxy*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.LogRemotingStage(System.Int32)
  id: LogRemotingStage(System.Int32)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: LogRemotingStage(Int32)
  nameWithType: RemotingServices.LogRemotingStage(Int32)
  fullName: System.Runtime.Remoting.RemotingServices.LogRemotingStage(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "在远程处理交换外部调试器中记录阶段。"
  remarks: "A`&quot;REMOTING_PERF&quot;`预处理符号应用于此方法使用<xref:System.Diagnostics.ConditionalAttribute>属性。</xref:System.Diagnostics.ConditionalAttribute>"
  syntax:
    content: public static void LogRemotingStage (int stage);
    parameters:
    - id: stage
      type: System.Int32
      description: "标识在远程处理交换中的阶段的内部定义的常数。"
  overload: System.Runtime.Remoting.RemotingServices.LogRemotingStage*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)
  id: Marshal(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Marshal(MarshalByRefObject)
  nameWithType: RemotingServices.Marshal(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.Marshal(MarshalByRefObject)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "采用<xref href=&quot;System.MarshalByRefObject&quot;> </xref>、 将其注册远程处理基础结构，并将其转换到的实例<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;></xref>类。"
  remarks: "A<xref:System.Runtime.Remoting.ObjRef>是用于跨应用程序域边界传输对象引用的对象的可序列化表示。</xref:System.Runtime.Remoting.ObjRef> 创建<xref:System.Runtime.Remoting.ObjRef>的对象称为封送处理。</xref:System.Runtime.Remoting.ObjRef> <xref:System.Runtime.Remoting.ObjRef>可以通过信道传输到另一个应用程序域 （可能在另一个进程或计算机）。</xref:System.Runtime.Remoting.ObjRef> 在其他应用程序域中一次<xref:System.Runtime.Remoting.ObjRef>必须对其进行分析以创建对象，通常连接到真实的对象的代理。</xref:System.Runtime.Remoting.ObjRef> 此操作称为取消封送。       A<xref:System.Runtime.Remoting.ObjRef>包含描述信息<xref:System.Type>和正封送的对象类，一个 URI，唯一标识的特定对象实例和通信相关的有关如何访问该对象所在的远程处理分支的信息。</xref:System.Type> </xref:System.Runtime.Remoting.ObjRef>       在封送处理，使用从当前线程的上下文，但不是用上下文，处于活动状态时创建对象时。 如果未显式设置一个 URI<xref:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal%2A>方法，由远程处理标识基础结构自动生成。</xref:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal%2A>       无法将一个 URI 与代理关联的两个原因之一︰ 在它表示的对象的服务器端生成了 URI 或该对象是众所周知的 URI 在此情况下为已知。 因此，如果`Obj`参数是一个代理，将引发异常。 自定义代理的此限制是很宽松，因为透明代理将被视为该服务器对象。"
  syntax:
    content: public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj);
    parameters:
    - id: Obj
      type: System.MarshalByRefObject
      description: "要转换的对象。"
    return:
      type: System.Runtime.Remoting.ObjRef
      description: "实例<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;></xref>表示中指定的对象的类<code> Obj </code>参数。"
  overload: System.Runtime.Remoting.RemotingServices.Marshal*
  exceptions:
  - type: System.Runtime.Remoting.RemotingException
    commentId: T:System.Runtime.Remoting.RemotingException
    description: "<code> Obj </code>参数是一个对象代理。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一个调用堆栈中较高的调用方没有权限来配置远程处理类型和信道。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String)
  id: Marshal(System.MarshalByRefObject,System.String)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Marshal(MarshalByRefObject,String)
  nameWithType: RemotingServices.Marshal(MarshalByRefObject,String)
  fullName: System.Runtime.Remoting.RemotingServices.Marshal(MarshalByRefObject,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "将转换给定<xref href=&quot;System.MarshalByRefObject&quot;></xref>到的实例<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;></xref>用指定的 URI 的类。"
  remarks: "A<xref:System.Runtime.Remoting.ObjRef>是用于跨应用程序域边界传输对象引用的对象的可序列化表示。</xref:System.Runtime.Remoting.ObjRef> 创建<xref:System.Runtime.Remoting.ObjRef>的对象称为封送处理。</xref:System.Runtime.Remoting.ObjRef> <xref:System.Runtime.Remoting.ObjRef>可以通过信道传输到另一个应用程序域 （可能在另一个进程或计算机）。</xref:System.Runtime.Remoting.ObjRef> 在其他应用程序域中一次<xref:System.Runtime.Remoting.ObjRef>必须对其进行分析以创建对象，通常连接到真实的对象的代理。</xref:System.Runtime.Remoting.ObjRef> 此操作称为取消封送。       A<xref:System.Runtime.Remoting.ObjRef>包含描述信息<xref:System.Type>和正封送的对象类，一个 URI，唯一标识的特定对象实例和通信相关的有关如何访问该对象所在的远程处理分支的信息。</xref:System.Type> </xref:System.Runtime.Remoting.ObjRef>       在封送处理，使用从当前线程的上下文，但不是用上下文，处于活动状态时创建对象时。       无法将一个 URI 与代理关联的两个原因之一︰ 在它表示的对象的服务器端生成了 URI 或该对象是众所周知的 URI 在此情况下为已知。 因此，如果`Obj`参数是一个代理，将引发异常。 自定义代理的此限制是很宽松，因为透明代理将被视为该服务器对象。"
  example:
  - "The following code example demonstrates how to use the current <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> method to marshal a specified object.  \n  \n [!code-cpp[RemotingServices.BasicSample#2](~/add/codesnippet/cpp/01236a8e-f8c3-4b7b-875d-_1.cpp)]\n [!code-cs[RemotingServices.BasicSample#2](~/add/codesnippet/csharp/01236a8e-f8c3-4b7b-875d-_1.cs)]\n [!code-vb[RemotingServices.BasicSample#2](~/add/codesnippet/visualbasic/01236a8e-f8c3-4b7b-875d-_1.vb)]"
  syntax:
    content: public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string URI);
    parameters:
    - id: Obj
      type: System.MarshalByRefObject
      description: "要转换的对象。"
    - id: URI
      type: System.String
      description: "指定的 URI 来初始化新<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref>。 Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Runtime.Remoting.ObjRef
      description: "实例<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;></xref>表示中指定的对象的类<code> Obj </code>参数。"
  overload: System.Runtime.Remoting.RemotingServices.Marshal*
  exceptions:
  - type: System.Runtime.Remoting.RemotingException
    commentId: T:System.Runtime.Remoting.RemotingException
    description: "<code>Obj</code>是一个对象代理，和<code>URI</code>参数不是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一个调用堆栈中较高的调用方没有权限来配置远程处理类型和信道。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String,System.Type)
  id: Marshal(System.MarshalByRefObject,System.String,System.Type)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Marshal(MarshalByRefObject,String,Type)
  nameWithType: RemotingServices.Marshal(MarshalByRefObject,String,Type)
  fullName: System.Runtime.Remoting.RemotingServices.Marshal(MarshalByRefObject,String,Type)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "采用<xref href=&quot;System.MarshalByRefObject&quot;></xref>并将其转换到的实例<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;></xref>类，该类具有指定的 URI，并提供<xref:System.Type>.</xref:System.Type>"
  remarks: "A<xref:System.Runtime.Remoting.ObjRef>是用于跨应用程序域边界传输对象引用的对象的可序列化表示。</xref:System.Runtime.Remoting.ObjRef> 创建<xref:System.Runtime.Remoting.ObjRef>的对象称为封送处理。</xref:System.Runtime.Remoting.ObjRef> <xref:System.Runtime.Remoting.ObjRef>可以通过信道传输到另一个应用程序域 （可能在另一个进程或计算机）。</xref:System.Runtime.Remoting.ObjRef> 在其他应用程序域中一次<xref:System.Runtime.Remoting.ObjRef>必须对其进行分析以创建对象，通常连接到真实的对象的代理。</xref:System.Runtime.Remoting.ObjRef> 此操作称为取消封送。       A<xref:System.Runtime.Remoting.ObjRef>包含描述信息<xref:System.Type>和正封送的对象类，一个 URI，唯一标识的特定对象实例和通信相关的有关如何访问该对象所在的远程处理分支的信息。</xref:System.Type> </xref:System.Runtime.Remoting.ObjRef>       指定<xref:System.Type>远程处理基础结构用于限制公开的类型层次结构的作用域。</xref:System.Type> 例如，如果对象 A 派生自对象 B，后者派生自对象 C，并且调用了<xref:System.Runtime.Remoting.RemotingServices.Marshal%2A>，然后客户端可以强制转换代理 C 和 B 之间但不是到 a。      封送处理，期间使用从当前线程的上下文时，不是用上下文，处于活动状态时创建对象时。</xref:System.Runtime.Remoting.RemotingServices.Marshal%2A>       无法将一个 URI 与代理关联的两个原因之一︰ 在它表示的对象的服务器端生成了 URI 或该对象是众所周知的 URI 在此情况下为已知。 因此，如果`Obj`参数是一个代理，将引发异常。 自定义代理的此限制是很宽松，因为透明代理将被视为该服务器对象。"
  syntax:
    content: public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string ObjURI, Type RequestedType);
    parameters:
    - id: Obj
      type: System.MarshalByRefObject
      description: "要转换为对象<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref>。"
    - id: ObjURI
      type: System.String
      description: "URI 中指定的对象`Obj`与封送参数。 Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    - id: RequestedType
      type: System.Type
      description: "<xref:System.Type>`Obj`作为封送。</xref:System.Type> Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Runtime.Remoting.ObjRef
      description: "实例<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;></xref>表示中指定的对象的类<code> Obj </code>参数。"
  overload: System.Runtime.Remoting.RemotingServices.Marshal*
  exceptions:
  - type: System.Runtime.Remoting.RemotingException
    commentId: T:System.Runtime.Remoting.RemotingException
    description: "<code>Obj</code>为远程对象的代理和<code>ObjUri</code>参数不是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一个调用堆栈中较高的调用方没有权限来配置远程处理类型和信道。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(System.MarshalByRefObject,System.String)
  id: SetObjectUriForMarshal(System.MarshalByRefObject,System.String)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: SetObjectUriForMarshal(MarshalByRefObject,String)
  nameWithType: RemotingServices.SetObjectUriForMarshal(MarshalByRefObject,String)
  fullName: System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(MarshalByRefObject,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "设置后续调用的 URI<xref:System.Runtime.Remoting.RemotingServices.Marshal*>方法。</xref:System.Runtime.Remoting.RemotingServices.Marshal*>"
  remarks: "The URI set by the current method is used when marshaling the given object.  \n  \n After marshaling, the URI of the specified object is set to the string in the `uri` parameter appended onto the <xref:System.Guid> of the current <xref:System.AppDomain>.  \n  \n If the current application is listening on an HTTP port, then both the string specified in the `uri` parameter and the `uri` string appended onto the <xref:System.Guid> of the current <xref:System.AppDomain> route to the specified object. For example, if the application is listening on HTTP port 9000, then both http://localhost:9000/objectUri, and http://localhost:9000/\\<appdomainguid>/objectUri route to the object specified in the `obj` parameter."
  example:
  - "The following code example demonstrates how to set the URI that will be used by the <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> method when marshaling the specified object.  \n  \n [!code-cpp[RemotingServices.SetObjectUriForMarshal#1](~/add/codesnippet/cpp/2ed6d271-806d-4778-95aa-_1.cpp)]\n [!code-cs[RemotingServices.SetObjectUriForMarshal#1](~/add/codesnippet/csharp/2ed6d271-806d-4778-95aa-_1.cs)]\n [!code-vb[RemotingServices.SetObjectUriForMarshal#1](~/add/codesnippet/visualbasic/2ed6d271-806d-4778-95aa-_1.vb)]"
  syntax:
    content: public static void SetObjectUriForMarshal (MarshalByRefObject obj, string uri);
    parameters:
    - id: obj
      type: System.MarshalByRefObject
      description: "要设置的 URI 的对象。"
    - id: uri
      type: System.String
      description: "要将分配给指定的对象的 URI。"
  overload: System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal*
  exceptions:
  - type: System.Runtime.Remoting.RemotingException
    commentId: T:System.Runtime.Remoting.RemotingException
    description: "<code>obj</code>不是本地对象被封送，或已在调用当前方法。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一个调用堆栈中较高的调用方没有权限来配置远程处理类型和信道。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef)
  id: Unmarshal(System.Runtime.Remoting.ObjRef)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Unmarshal(ObjRef)
  nameWithType: RemotingServices.Unmarshal(ObjRef)
  fullName: System.Runtime.Remoting.RemotingServices.Unmarshal(ObjRef)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "采用<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;></xref>并创建代理对象退出。"
  remarks: "A<xref:System.Runtime.Remoting.ObjRef>是用于跨应用程序域边界传输对象引用的对象的可序列化表示。</xref:System.Runtime.Remoting.ObjRef> 创建<xref:System.Runtime.Remoting.ObjRef>的对象称为封送处理。</xref:System.Runtime.Remoting.ObjRef> <xref:System.Runtime.Remoting.ObjRef>可以通过信道传输到另一个应用程序域 （可能在另一个进程或计算机）。</xref:System.Runtime.Remoting.ObjRef> 在其他应用程序域中一次<xref:System.Runtime.Remoting.ObjRef>必须对其进行分析以创建对象，通常连接到真实的对象的代理。</xref:System.Runtime.Remoting.ObjRef> 此操作称为取消封送。 在取消封送，<xref:System.Runtime.Remoting.ObjRef>进行分析，以提取远程对象和透明的代理的方法信息和<xref:System.Runtime.Remoting.Proxies.RealProxy>创建对象。</xref:System.Runtime.Remoting.Proxies.RealProxy> </xref:System.Runtime.Remoting.ObjRef> 已分析的内容<xref:System.Runtime.Remoting.ObjRef>之前向公共语言运行时注册透明代理添加到透明的代理。</xref:System.Runtime.Remoting.ObjRef>       A<xref:System.Runtime.Remoting.ObjRef>包含描述信息<xref:System.Type>和正封送的对象类，一个 URI，唯一标识的特定对象实例和通信相关的有关如何访问该对象所在的远程处理分支的信息。</xref:System.Type> </xref:System.Runtime.Remoting.ObjRef>"
  example:
  - "The following code example demonstrates how to unmarshal an object.  \n  \n [!code-vb[RemotingServices.Unmarshal#2](~/add/codesnippet/visualbasic/b4be8871-533a-4641-8763-_1.vb)]\n [!code-cpp[RemotingServices.Unmarshal#2](~/add/codesnippet/cpp/b4be8871-533a-4641-8763-_1.cpp)]\n [!code-cs[RemotingServices.Unmarshal#2](~/add/codesnippet/csharp/b4be8871-533a-4641-8763-_1.cs)]"
  syntax:
    content: public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef);
    parameters:
    - id: objectRef
      type: System.Runtime.Remoting.ObjRef
      description: "<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref>表示为其创建代理的远程对象。"
    return:
      type: System.Object
      description: "对象的代理，给定<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;></xref>表示。"
  overload: System.Runtime.Remoting.RemotingServices.Unmarshal*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref>中指定的实例<code> objectRef </code>参数不是格式正确。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一个调用堆栈中较高的调用方没有权限来配置远程处理类型和信道。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)
  id: Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Unmarshal(ObjRef,Boolean)
  nameWithType: RemotingServices.Unmarshal(ObjRef,Boolean)
  fullName: System.Runtime.Remoting.RemotingServices.Unmarshal(ObjRef,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "采用<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;></xref>并创建代理对象外，优化到服务器上的类型。"
  remarks: "A<xref:System.Runtime.Remoting.ObjRef>是用于跨应用程序域边界传输对象引用的对象的可序列化表示。</xref:System.Runtime.Remoting.ObjRef> 创建<xref:System.Runtime.Remoting.ObjRef>的对象称为封送处理。</xref:System.Runtime.Remoting.ObjRef> <xref:System.Runtime.Remoting.ObjRef>可以通过信道传输到另一个应用程序域 （可能在另一个进程或计算机）。</xref:System.Runtime.Remoting.ObjRef> 在其他应用程序域中一次<xref:System.Runtime.Remoting.ObjRef>必须对其进行分析以创建对象，通常连接到真实的对象的代理。</xref:System.Runtime.Remoting.ObjRef> 此操作称为取消封送。 在取消封送，<xref:System.Runtime.Remoting.ObjRef>进行分析，以提取远程对象和透明的代理的方法信息和<xref:System.Runtime.Remoting.Proxies.RealProxy>创建对象。</xref:System.Runtime.Remoting.Proxies.RealProxy> </xref:System.Runtime.Remoting.ObjRef> 已分析的内容<xref:System.Runtime.Remoting.ObjRef>之前向公共语言运行时注册透明代理添加到透明的代理。</xref:System.Runtime.Remoting.ObjRef>       A<xref:System.Runtime.Remoting.ObjRef>包含描述信息<xref:System.Type>和正封送的对象类，一个 URI，唯一标识的特定对象实例和通信相关的有关如何访问该对象所在的远程处理分支的信息。</xref:System.Type> </xref:System.Runtime.Remoting.ObjRef>       代理时第一次创建，属于类型<xref:System.MarshalByRefObject>.</xref:System.MarshalByRefObject> 如将其转换为不同类型时，远程处理基础结构将跟踪的最常用的类型，以避免不必要地加载该类型。"
  syntax:
    content: public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef, bool fRefine);
    parameters:
    - id: objectRef
      type: System.Runtime.Remoting.ObjRef
      description: "<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref>表示为其创建代理的远程对象。"
    - id: fRefine
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>以优化该代理与服务器; 上的类型否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.Object
      description: "对象的代理，给定<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;></xref>表示。"
  overload: System.Runtime.Remoting.RemotingServices.Unmarshal*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref>中指定的实例<code> objectRef </code>参数不是格式正确。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一个调用堆栈中较高的调用方没有权限来配置远程处理类型和信道。"
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Runtime.Remoting.RemotingException
  parent: System.Runtime.Remoting
  isExternal: false
  name: RemotingException
  nameWithType: RemotingException
  fullName: System.Runtime.Remoting.RemotingException
- uid: System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Connect(Type,String)
  nameWithType: RemotingServices.Connect(Type,String)
  fullName: System.Runtime.Remoting.RemotingServices.Connect(Type,String)
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String,System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Connect(Type,String,Object)
  nameWithType: RemotingServices.Connect(Type,String,Object)
  fullName: System.Runtime.Remoting.RemotingServices.Connect(Type,String,Object)
- uid: System.Runtime.Remoting.RemotingServices.Disconnect(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Disconnect(MarshalByRefObject)
  nameWithType: RemotingServices.Disconnect(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.Disconnect(MarshalByRefObject)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.MarshalByRefObject
  parent: System
  isExternal: false
  name: MarshalByRefObject
  nameWithType: MarshalByRefObject
  fullName: System.MarshalByRefObject
- uid: System.Runtime.Remoting.RemotingServices.ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: ExecuteMessage(MarshalByRefObject,IMethodCallMessage)
  nameWithType: RemotingServices.ExecuteMessage(MarshalByRefObject,IMethodCallMessage)
  fullName: System.Runtime.Remoting.RemotingServices.ExecuteMessage(MarshalByRefObject,IMethodCallMessage)
- uid: System.Runtime.Remoting.Messaging.IMethodReturnMessage
  parent: System.Runtime.Remoting.Messaging
  isExternal: false
  name: IMethodReturnMessage
  nameWithType: IMethodReturnMessage
  fullName: System.Runtime.Remoting.Messaging.IMethodReturnMessage
- uid: System.Runtime.Remoting.Messaging.IMethodCallMessage
  parent: System.Runtime.Remoting.Messaging
  isExternal: false
  name: IMethodCallMessage
  nameWithType: IMethodCallMessage
  fullName: System.Runtime.Remoting.Messaging.IMethodCallMessage
- uid: System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetEnvoyChainForProxy(MarshalByRefObject)
  nameWithType: RemotingServices.GetEnvoyChainForProxy(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(MarshalByRefObject)
- uid: System.Runtime.Remoting.Messaging.IMessageSink
  parent: System.Runtime.Remoting.Messaging
  isExternal: false
  name: IMessageSink
  nameWithType: IMessageSink
  fullName: System.Runtime.Remoting.Messaging.IMessageSink
- uid: System.Runtime.Remoting.RemotingServices.GetLifetimeService(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetLifetimeService(MarshalByRefObject)
  nameWithType: RemotingServices.GetLifetimeService(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetLifetimeService(MarshalByRefObject)
- uid: System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetMethodBaseFromMethodMessage(IMethodMessage)
  nameWithType: RemotingServices.GetMethodBaseFromMethodMessage(IMethodMessage)
  fullName: System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(IMethodMessage)
- uid: System.Reflection.MethodBase
  parent: System.Reflection
  isExternal: true
  name: MethodBase
  nameWithType: MethodBase
  fullName: System.Reflection.MethodBase
- uid: System.Runtime.Remoting.Messaging.IMethodMessage
  parent: System.Runtime.Remoting.Messaging
  isExternal: false
  name: IMethodMessage
  nameWithType: IMethodMessage
  fullName: System.Runtime.Remoting.Messaging.IMethodMessage
- uid: System.Runtime.Remoting.RemotingServices.GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetObjectData(Object,SerializationInfo,StreamingContext)
  nameWithType: RemotingServices.GetObjectData(Object,SerializationInfo,StreamingContext)
  fullName: System.Runtime.Remoting.RemotingServices.GetObjectData(Object,SerializationInfo,StreamingContext)
- uid: System.Runtime.Serialization.SerializationInfo
  parent: System.Runtime.Serialization
  isExternal: false
  name: SerializationInfo
  nameWithType: SerializationInfo
  fullName: System.Runtime.Serialization.SerializationInfo
- uid: System.Runtime.Serialization.StreamingContext
  parent: System.Runtime.Serialization
  isExternal: true
  name: StreamingContext
  nameWithType: StreamingContext
  fullName: System.Runtime.Serialization.StreamingContext
- uid: System.Runtime.Remoting.RemotingServices.GetObjectUri(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetObjectUri(MarshalByRefObject)
  nameWithType: RemotingServices.GetObjectUri(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetObjectUri(MarshalByRefObject)
- uid: System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetObjRefForProxy(MarshalByRefObject)
  nameWithType: RemotingServices.GetObjRefForProxy(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(MarshalByRefObject)
- uid: System.Runtime.Remoting.ObjRef
  parent: System.Runtime.Remoting
  isExternal: false
  name: ObjRef
  nameWithType: ObjRef
  fullName: System.Runtime.Remoting.ObjRef
- uid: System.Runtime.Remoting.RemotingServices.GetRealProxy(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetRealProxy(Object)
  nameWithType: RemotingServices.GetRealProxy(Object)
  fullName: System.Runtime.Remoting.RemotingServices.GetRealProxy(Object)
- uid: System.Runtime.Remoting.Proxies.RealProxy
  parent: System.Runtime.Remoting.Proxies
  isExternal: false
  name: RealProxy
  nameWithType: RealProxy
  fullName: System.Runtime.Remoting.Proxies.RealProxy
- uid: System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(System.String)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetServerTypeForUri(String)
  nameWithType: RemotingServices.GetServerTypeForUri(String)
  fullName: System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(String)
- uid: System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetSessionIdForMethodMessage(IMethodMessage)
  nameWithType: RemotingServices.GetSessionIdForMethodMessage(IMethodMessage)
  fullName: System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(IMethodMessage)
- uid: System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsMethodOverloaded(IMethodMessage)
  nameWithType: RemotingServices.IsMethodOverloaded(IMethodMessage)
  fullName: System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(IMethodMessage)
- uid: System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsObjectOutOfAppDomain(Object)
  nameWithType: RemotingServices.IsObjectOutOfAppDomain(Object)
  fullName: System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(Object)
- uid: System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsObjectOutOfContext(Object)
  nameWithType: RemotingServices.IsObjectOutOfContext(Object)
  fullName: System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(Object)
- uid: System.Runtime.Remoting.RemotingServices.IsOneWay(System.Reflection.MethodBase)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsOneWay(MethodBase)
  nameWithType: RemotingServices.IsOneWay(MethodBase)
  fullName: System.Runtime.Remoting.RemotingServices.IsOneWay(MethodBase)
- uid: System.Runtime.Remoting.RemotingServices.IsTransparentProxy(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsTransparentProxy(Object)
  nameWithType: RemotingServices.IsTransparentProxy(Object)
  fullName: System.Runtime.Remoting.RemotingServices.IsTransparentProxy(Object)
- uid: System.Runtime.Remoting.RemotingServices.LogRemotingStage(System.Int32)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: LogRemotingStage(Int32)
  nameWithType: RemotingServices.LogRemotingStage(Int32)
  fullName: System.Runtime.Remoting.RemotingServices.LogRemotingStage(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Marshal(MarshalByRefObject)
  nameWithType: RemotingServices.Marshal(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.Marshal(MarshalByRefObject)
- uid: System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Marshal(MarshalByRefObject,String)
  nameWithType: RemotingServices.Marshal(MarshalByRefObject,String)
  fullName: System.Runtime.Remoting.RemotingServices.Marshal(MarshalByRefObject,String)
- uid: System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String,System.Type)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Marshal(MarshalByRefObject,String,Type)
  nameWithType: RemotingServices.Marshal(MarshalByRefObject,String,Type)
  fullName: System.Runtime.Remoting.RemotingServices.Marshal(MarshalByRefObject,String,Type)
- uid: System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(System.MarshalByRefObject,System.String)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: SetObjectUriForMarshal(MarshalByRefObject,String)
  nameWithType: RemotingServices.SetObjectUriForMarshal(MarshalByRefObject,String)
  fullName: System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(MarshalByRefObject,String)
- uid: System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Unmarshal(ObjRef)
  nameWithType: RemotingServices.Unmarshal(ObjRef)
  fullName: System.Runtime.Remoting.RemotingServices.Unmarshal(ObjRef)
- uid: System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Unmarshal(ObjRef,Boolean)
  nameWithType: RemotingServices.Unmarshal(ObjRef,Boolean)
  fullName: System.Runtime.Remoting.RemotingServices.Unmarshal(ObjRef,Boolean)
- uid: System.Runtime.Remoting.RemotingServices.Connect*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Connect
  nameWithType: RemotingServices.Connect
- uid: System.Runtime.Remoting.RemotingServices.Disconnect*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Disconnect
  nameWithType: RemotingServices.Disconnect
- uid: System.Runtime.Remoting.RemotingServices.ExecuteMessage*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: ExecuteMessage
  nameWithType: RemotingServices.ExecuteMessage
- uid: System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetEnvoyChainForProxy
  nameWithType: RemotingServices.GetEnvoyChainForProxy
- uid: System.Runtime.Remoting.RemotingServices.GetLifetimeService*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetLifetimeService
  nameWithType: RemotingServices.GetLifetimeService
- uid: System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetMethodBaseFromMethodMessage
  nameWithType: RemotingServices.GetMethodBaseFromMethodMessage
- uid: System.Runtime.Remoting.RemotingServices.GetObjectData*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetObjectData
  nameWithType: RemotingServices.GetObjectData
- uid: System.Runtime.Remoting.RemotingServices.GetObjectUri*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetObjectUri
  nameWithType: RemotingServices.GetObjectUri
- uid: System.Runtime.Remoting.RemotingServices.GetObjRefForProxy*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetObjRefForProxy
  nameWithType: RemotingServices.GetObjRefForProxy
- uid: System.Runtime.Remoting.RemotingServices.GetRealProxy*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetRealProxy
  nameWithType: RemotingServices.GetRealProxy
- uid: System.Runtime.Remoting.RemotingServices.GetServerTypeForUri*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetServerTypeForUri
  nameWithType: RemotingServices.GetServerTypeForUri
- uid: System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetSessionIdForMethodMessage
  nameWithType: RemotingServices.GetSessionIdForMethodMessage
- uid: System.Runtime.Remoting.RemotingServices.IsMethodOverloaded*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsMethodOverloaded
  nameWithType: RemotingServices.IsMethodOverloaded
- uid: System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsObjectOutOfAppDomain
  nameWithType: RemotingServices.IsObjectOutOfAppDomain
- uid: System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsObjectOutOfContext
  nameWithType: RemotingServices.IsObjectOutOfContext
- uid: System.Runtime.Remoting.RemotingServices.IsOneWay*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsOneWay
  nameWithType: RemotingServices.IsOneWay
- uid: System.Runtime.Remoting.RemotingServices.IsTransparentProxy*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsTransparentProxy
  nameWithType: RemotingServices.IsTransparentProxy
- uid: System.Runtime.Remoting.RemotingServices.LogRemotingStage*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: LogRemotingStage
  nameWithType: RemotingServices.LogRemotingStage
- uid: System.Runtime.Remoting.RemotingServices.Marshal*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Marshal
  nameWithType: RemotingServices.Marshal
- uid: System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: SetObjectUriForMarshal
  nameWithType: RemotingServices.SetObjectUriForMarshal
- uid: System.Runtime.Remoting.RemotingServices.Unmarshal*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Unmarshal
  nameWithType: RemotingServices.Unmarshal
