### YamlMime:ManagedReference
items:
- uid: System.AppDomain
  id: AppDomain
  children:
  - System.AppDomain.ActivationContext
  - System.AppDomain.AppendPrivatePath(System.String)
  - System.AppDomain.ApplicationIdentity
  - System.AppDomain.ApplicationTrust
  - System.AppDomain.ApplyPolicy(System.String)
  - System.AppDomain.AssemblyLoad
  - System.AppDomain.AssemblyResolve
  - System.AppDomain.BaseDirectory
  - System.AppDomain.ClearPrivatePath
  - System.AppDomain.ClearShadowCopyPath
  - System.AppDomain.CreateComInstanceFrom(System.String,System.String)
  - System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  - System.AppDomain.CreateDomain(System.String)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  - System.AppDomain.CreateInstance(System.String,System.String)
  - System.AppDomain.CreateInstance(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CreateInstanceFrom(System.String,System.String)
  - System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CurrentDomain
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  - System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)
  - System.AppDomain.DomainManager
  - System.AppDomain.DomainUnload
  - System.AppDomain.DynamicDirectory
  - System.AppDomain.Evidence
  - System.AppDomain.ExecuteAssembly(System.String)
  - System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.ExecuteAssembly(System.String,System.String[])
  - System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  - System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  - System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  - System.AppDomain.ExecuteAssemblyByName(System.String)
  - System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  - System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])
  - System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  - System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  - System.AppDomain.FirstChanceException
  - System.AppDomain.FriendlyName
  - System.AppDomain.GetAssemblies
  - System.AppDomain.GetCurrentThreadId
  - System.AppDomain.GetData(System.String)
  - System.AppDomain.GetType
  - System.AppDomain.Id
  - System.AppDomain.InitializeLifetimeService
  - System.AppDomain.IsCompatibilitySwitchSet(System.String)
  - System.AppDomain.IsDefaultAppDomain
  - System.AppDomain.IsFinalizingForUnload
  - System.AppDomain.IsFullyTrusted
  - System.AppDomain.IsHomogenous
  - System.AppDomain.Load(System.Byte[])
  - System.AppDomain.Load(System.Reflection.AssemblyName)
  - System.AppDomain.Load(System.String)
  - System.AppDomain.Load(System.Byte[],System.Byte[])
  - System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  - System.AppDomain.Load(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  - System.AppDomain.MonitoringIsEnabled
  - System.AppDomain.MonitoringSurvivedMemorySize
  - System.AppDomain.MonitoringSurvivedProcessMemorySize
  - System.AppDomain.MonitoringTotalAllocatedMemorySize
  - System.AppDomain.MonitoringTotalProcessorTime
  - System.AppDomain.PermissionSet
  - System.AppDomain.ProcessExit
  - System.AppDomain.ReflectionOnlyAssemblyResolve
  - System.AppDomain.ReflectionOnlyGetAssemblies
  - System.AppDomain.RelativeSearchPath
  - System.AppDomain.ResourceResolve
  - System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  - System.AppDomain.SetCachePath(System.String)
  - System.AppDomain.SetData(System.String,System.Object)
  - System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)
  - System.AppDomain.SetDynamicBase(System.String)
  - System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  - System.AppDomain.SetShadowCopyFiles
  - System.AppDomain.SetShadowCopyPath(System.String)
  - System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)
  - System.AppDomain.SetupInformation
  - System.AppDomain.ShadowCopyFiles
  - System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  - System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  - System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  - System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  - System.AppDomain.ToString
  - System.AppDomain.TypeResolve
  - System.AppDomain.UnhandledException
  - System.AppDomain.Unload(System.AppDomain)
  langs:
  - csharp
  name: AppDomain
  nameWithType: AppDomain
  fullName: System.AppDomain
  type: Class
  summary: "表示应用程序域，它是一个独立应用程序在其中执行的环境。 此类不能被继承。"
  remarks: "应用程序域，它们由 AppDomain 对象的形式表示，帮助提供有关执行托管的代码的隔离、 卸载和安全边界。      -使用应用程序域隔离可能会终止进程的任务。 如果正在执行任务的 appdomain 状态变得不稳定，AppDomain 可以卸载而不会影响该过程。 进程必须运行很长一段无需重新启动时，这很重要。 你还可以使用应用程序域隔离不应共享数据的任务。      -如果程序集被加载到默认应用程序域，它不能从内存中卸载过程运行时。 但是，如果您打开第二个应用程序域加载和执行程序集，程序集是卸载卸载该应用程序域时。 使用此方法最大程度减少偶尔使用大型 Dll 的长时间运行进程的工作集。       多个应用程序域可以运行在一个进程中;但是，没有应用程序域和线程之间的一对一的相关性。 多个线程可以属于单个应用程序域，并且单个应用程序域中时的给定的线程并不局限于单个应用程序域，在任何给定时间，执行线程。       使用创建应用程序域<xref:System.AppDomain.CreateDomain%2A>方法。</xref:System.AppDomain.CreateDomain%2A> AppDomain 实例用于加载和执行程序集 (<xref:System.Reflection.Assembly>)。</xref:System.Reflection.Assembly> AppDomain 中不再使用时，它可以卸载。       AppDomain 类实现一的组启用应用程序时加载的程序集，当应用程序域将被卸载，或引发未经处理的异常时进行响应的事件。       有关使用应用程序域的详细信息，请参阅[应用程序域](~/add/includes/ajax-current-ext-md.md)。       此类实现<xref:System.MarshalByRefObject>， <xref:System._AppDomain>，和<xref:System.Security.IEvidenceFactory>接口。</xref:System.Security.IEvidenceFactory> </xref:System._AppDomain> </xref:System.MarshalByRefObject>       切勿创建 AppDomain 对象的远程操作包装器。 这样可以将发布到该 AppDomain 中，如公开方法的远程引用<xref:System.AppDomain.CreateInstance%2A>与远程访问和有效地销毁该 appdomain 的代码访问安全性。</xref:System.AppDomain.CreateInstance%2A> 连接到远程连接的 AppDomain 的恶意客户端无法获取到 AppDomain 本身有权访问任何资源的访问权限。 不创建任何扩展的类型的远程操作包装<xref:System.MarshalByRefObject>并实现恶意客户端无法用于绕过安全系统的方法。</xref:System.MarshalByRefObject>      1> [!CAUTION]&1;> 的默认值为<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName>属性是`false`。</xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName> 此设置是不安全的服务。 若要防止服务下载部分受信任的代码，请将此属性设置为`true`。"
  example:
  - "This example shows how to create a new AppDomain, instantiate a type in that new AppDomain, and communicate with that type’s object. In addition, this example shows how to unload the AppDomain causing the object to be garbage collected.  \n  \n [!code-vb[AppDomainX#1](~/add/codesnippet/visualbasic/t-system.appdomain_1.vb)]\n [!code-cs[AppDomainX#1](~/add/codesnippet/csharp/t-system.appdomain_1.cs)]\n [!code-cpp[AppDomainX#1](~/add/codesnippet/cpp/t-system.appdomain_1.cpp)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]

      [System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  implements:
  - System._AppDomain
  - System.Security.IEvidenceFactory
  inheritedMembers:
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.AppDomain.ActivationContext
  id: ActivationContext
  parent: System.AppDomain
  langs:
  - csharp
  name: ActivationContext
  nameWithType: AppDomain.ActivationContext
  fullName: System.AppDomain.ActivationContext
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取当前的应用程序域的激活上下文。"
  syntax:
    content: public ActivationContext ActivationContext { get; }
    return:
      type: System.ActivationContext
      description: "一个对象，表示当前的应用程序域中的激活上下文或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果域具有没有激活上下文。"
  overload: System.AppDomain.ActivationContext*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.AppendPrivatePath(System.String)
  id: AppendPrivatePath(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: AppendPrivatePath(String)
  nameWithType: AppDomain.AppendPrivatePath(String)
  fullName: System.AppDomain.AppendPrivatePath(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "将指定的目录名追加到专用路径列表中。"
  remarks: "不建议使用此属性，因为它可能会更改之后它们都已加载程序集的探测路径。 使用<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>属性改为。</xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>       专用路径或相对搜索路径是相对于此程序集冲突解决程序从中探测专用程序集的基目录的路径。"
  syntax:
    content: public void AppendPrivatePath (string path);
    parameters:
    - id: path
      type: System.String
      description: "要追加到专用路径的目录的名称。"
  overload: System.AppDomain.AppendPrivatePath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.ApplicationIdentity
  id: ApplicationIdentity
  parent: System.AppDomain
  langs:
  - csharp
  name: ApplicationIdentity
  nameWithType: AppDomain.ApplicationIdentity
  fullName: System.AppDomain.ApplicationIdentity
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "应用程序域中获取的应用程序的标识。"
  syntax:
    content: public ApplicationIdentity ApplicationIdentity { get; }
    return:
      type: System.ApplicationIdentity
      description: "用于标识应用程序域中的应用程序的对象。"
  overload: System.AppDomain.ApplicationIdentity*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ApplicationTrust
  id: ApplicationTrust
  parent: System.AppDomain
  langs:
  - csharp
  name: ApplicationTrust
  nameWithType: AppDomain.ApplicationTrust
  fullName: System.AppDomain.ApplicationTrust
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取说明授予应用程序和应用程序是否拥有允许其运行的信任级别的权限信息。"
  syntax:
    content: public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }
    return:
      type: System.Security.Policy.ApplicationTrust
      description: "封装应用程序域中应用程序的权限及信任信息的对象。"
  overload: System.AppDomain.ApplicationTrust*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ApplyPolicy(System.String)
  id: ApplyPolicy(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: ApplyPolicy(String)
  nameWithType: AppDomain.ApplyPolicy(String)
  fullName: System.AppDomain.ApplyPolicy(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "返回应用策略后的程序集显示名称。"
  remarks: "方法采用程序集 ApplyPolicy 显示名称，并返回应用策略后显示名称。 这是你需要使用策略，将程序集的加载，因为只反射上下文不适用于策略的情况下很有用。"
  syntax:
    content: public string ApplyPolicy (string assemblyName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "程序集显示名称，在提供的格式&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;属性。"
    return:
      type: System.String
      description: "在应用策略后，显示名称包含该程序集的字符串。"
  overload: System.AppDomain.ApplyPolicy*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.AssemblyLoad
  id: AssemblyLoad
  parent: System.AppDomain
  langs:
  - csharp
  name: AssemblyLoad
  nameWithType: AppDomain.AssemblyLoad
  fullName: System.AppDomain.AssemblyLoad
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "加载程序集时发生。"
  remarks: "<xref:System.AssemblyLoadEventHandler>委托此事件指示哪些程序集被加载。</xref:System.AssemblyLoadEventHandler>       若要注册的事件处理程序此事件，你必须具有所需的权限，或<xref:System.Security.SecurityException>引发。</xref:System.Security.SecurityException>       有关处理事件的详细信息，请参阅[事件](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following sample demonstrates the AssemblyLoad event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_AssemblyLoad#1](~/add/codesnippet/csharp/e-system.appdomain.assem_1_1.cs)]\n [!code-vb[AppDomain_AssemblyLoad#1](~/add/codesnippet/visualbasic/e-system.appdomain.assem_1_1.vb)]\n [!code-cpp[AppDomain_AssemblyLoad#1](~/add/codesnippet/cpp/e-system.appdomain.assem_1_1.cpp)]"
  syntax:
    content: public event AssemblyLoadEventHandler AssemblyLoad;
    return:
      type: System.AssemblyLoadEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.AssemblyResolve
  id: AssemblyResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: AssemblyResolve
  nameWithType: AppDomain.AssemblyResolve
  fullName: System.AppDomain.AssemblyResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "程序集的解析失败时发生。"
  remarks: "它负责<xref:System.ResolveEventHandler>此事件返回的程序集指定<xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>属性，或者若要返回无法识别程序集的情况下为 null。</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName> </xref:System.ResolveEventHandler> 该程序集必须加载到执行上下文;如果它加载到只反射上下文，导致引发此事件加载会失败。       有关使用此事件的指南，请参阅[解析程序集加载](~/add/includes/ajax-current-ext-md.md)。       开头[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]、<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>属性返回的请求无法解析的程序集加载的程序集。</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> 例如，加载程序可能无法加载请求的程序集的依赖项，因为请求的程序集和其依赖项不探测路径中。 了解请求的程序集的标识可能定位依赖项或者在很有用标识正确的版本，如果多个依赖项的版本可用。 有关详细信息，请参阅<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>。</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>      1> [!IMPORTANT]&1;> 开头[!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]、<xref:System.ResolveEventHandler>事件引发的所有程序集，包括资源程序集。</xref:System.ResolveEventHandler> 在早期版本中的资源程序集不引发事件。 如果本地化操作系统，则可能会调用处理程序多次︰ 一次针对回退链中每个区域性。       对于此事件，<xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>属性返回的程序集名称，应用策略之前。</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>      1> [!IMPORTANT]&1;> 如果多个事件处理程序已注册用于此事件，事件 handlersarecalled 顺序，直到事件处理程序返回一个值，不`null`。 将忽略后续的事件处理程序。       有关处理事件的详细信息，请参阅[事件](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following sample demonstrates the AssemblyResolve event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cpp[AssemblyResolve#1](~/add/codesnippet/cpp/e-system.appdomain.assem_0_1.cpp)]\n [!code-cs[AssemblyResolve#1](~/add/codesnippet/csharp/e-system.appdomain.assem_0_1.cs)]\n [!code-vb[AssemblyResolve#1](~/add/codesnippet/visualbasic/e-system.appdomain.assem_0_1.vb)]"
  syntax:
    content: public event ResolveEventHandler AssemblyResolve;
    return:
      type: System.ResolveEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.BaseDirectory
  id: BaseDirectory
  parent: System.AppDomain
  langs:
  - csharp
  name: BaseDirectory
  nameWithType: AppDomain.BaseDirectory
  fullName: System.AppDomain.BaseDirectory
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取程序集冲突解决程序用来探测程序集的基目录。"
  remarks: "此属性对应于<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>属性。</xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName> 它可以还使用检索<xref:System.AppDomain.GetData%2A>与字符串&quot;APPBASE&quot;的方法。</xref:System.AppDomain.GetData%2A>"
  example:
  - "The following code example creates a new application domain, specifying a base directory to use when searching for assemblies to load into the domain. The example then uses the BaseDirectory property to obtain the base directory path, for display to the console.  \n  \n [!code-cs[ADSetup#1](~/add/codesnippet/csharp/p-system.appdomain.based_1.cs)]\n [!code-cpp[ADSetup#1](~/add/codesnippet/cpp/p-system.appdomain.based_1.cpp)]\n [!code-vb[ADSetup#1](~/add/codesnippet/visualbasic/p-system.appdomain.based_1.vb)]"
  syntax:
    content: public string BaseDirectory { get; }
    return:
      type: System.String
      description: "程序集冲突解决程序用来探测程序集基目录。"
  overload: System.AppDomain.BaseDirectory*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.ClearPrivatePath
  id: ClearPrivatePath
  parent: System.AppDomain
  langs:
  - csharp
  name: ClearPrivatePath()
  nameWithType: AppDomain.ClearPrivatePath()
  fullName: System.AppDomain.ClearPrivatePath()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "重置指定专用程序集为空字符串的位置的路径 (&quot;&quot;)。"
  remarks: "专用的路径是相对于基目录，公共语言运行时搜索来查找私有程序集的路径。       有关详细信息，请参阅<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>。</xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>"
  example:
  - "The following code example demonstrates how to use the ClearPrivatePath method to remove all entries from the list of private paths to search when assemblies are loaded.  \n  \n This method is now obsolete, and should not be used for new development.  \n  \n [!code-cpp[ADClearPrivatePath#1](~/add/codesnippet/cpp/m-system.appdomain.clear_1.cpp)]\n [!code-cs[ADClearPrivatePath#1](~/add/codesnippet/csharp/m-system.appdomain.clear_1.cs)]\n [!code-vb[ADClearPrivatePath#1](~/add/codesnippet/visualbasic/m-system.appdomain.clear_1.vb)]"
  syntax:
    content: public void ClearPrivatePath ();
    parameters: []
  overload: System.AppDomain.ClearPrivatePath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.ClearShadowCopyPath
  id: ClearShadowCopyPath
  parent: System.AppDomain
  langs:
  - csharp
  name: ClearShadowCopyPath()
  nameWithType: AppDomain.ClearShadowCopyPath()
  fullName: System.AppDomain.ClearShadowCopyPath()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "将包含影像复制程序集为空字符串的目录列表重置 (&quot;&quot;)。"
  remarks: "卷影复制路径是存储的卷影复制的程序集的目录列表。       有关详细信息，请参阅<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>和[影像复制程序集](~/add/includes/ajax-current-ext-md.md)。</xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>"
  syntax:
    content: public void ClearShadowCopyPath ();
    parameters: []
  overload: System.AppDomain.ClearShadowCopyPath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String)
  id: CreateComInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateComInstanceFrom(String,String)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "创建指定 COM 类型的新实例。 参数指定包含程序集包含类型的文件的名称和类型的名称。"
  remarks: "使用此方法以远程创建对象，而无需本地加载该类型。       返回值需要打开包装才能访问真实对象。       A<xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>属性值为`true`必须以显式或默认方式对此方法 COM 类型，来创建该类型; 的实例应用否则为<xref:System.TypeLoadException>引发。</xref:System.TypeLoadException> </xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>"
  example:
  - "The following sample demonstrates  \n  \n [!code-cs[AppDomain_CreateComInstanceFrom#1](~/add/codesnippet/csharp/m-system.appdomain.creat_4_1.cs)]\n [!code-vb[AppDomain_CreateComInstanceFrom#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_4_1.vb)]\n [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/add/codesnippet/cpp/m-system.appdomain.creat_4_1.cpp)]"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "包含定义所请求的类型的程序集的文件的名称。"
    - id: typeName
      type: System.String
      description: "请求类型的名称。"
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "一个对象，它指定的新实例的包装<code> typeName </code>。 返回值需要打开包装才能访问真实对象。"
  overload: System.AppDomain.CreateComInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "无法加载此类型。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找到没有公共的无参数构造函数。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>未找到。"
  - type: System.MemberAccessException
    commentId: T:System.MemberAccessException
    description: "<code>typeName</code>是一个抽象类。       -或者-此成员使用晚期绑定机制调用。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "调用方不能为不是继承自的对象提供激活属性<xref href=&quot;System.MarshalByRefObject&quot;> </xref>。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>assemblyName</code>为空字符串 (&quot;&quot;)。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>不是有效的程序集。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "所引用的 COM 对象是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  id: CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "创建指定 COM 类型的新实例。 参数指定包含程序集包含类型的文件的名称和类型的名称。"
  remarks: "使用此方法以远程创建对象，而无需本地加载该类型。       返回值需要打开包装才能访问真实对象。       A<xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>属性值为`true`必须以显式或默认方式对此方法 COM 类型，来创建该类型; 的实例应用否则为<xref:System.TypeLoadException>引发。</xref:System.TypeLoadException> </xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "包含定义所请求的类型的程序集的文件的名称。"
    - id: typeName
      type: System.String
      description: "请求类型的名称。"
    - id: hashValue
      type: System.Byte[]
      description: "表示计算所得的哈希代码的值。"
    - id: hashAlgorithm
      type: System.Configuration.Assemblies.AssemblyHashAlgorithm
      description: "表示程序集清单使用的哈希算法。"
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "一个对象，它指定的新实例的包装<code> typeName </code>。 返回值需要打开包装才能访问真实对象。"
  overload: System.AppDomain.CreateComInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "无法加载此类型。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找到没有公共的无参数构造函数。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>未找到。"
  - type: System.MemberAccessException
    commentId: T:System.MemberAccessException
    description: "<code>typeName</code>是一个抽象类。       -或者-此成员使用晚期绑定机制调用。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "调用方不能为不是继承自的对象提供激活属性<xref href=&quot;System.MarshalByRefObject&quot;> </xref>。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>assemblyFile</code>为空字符串 (&quot;&quot;)。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>不是有效的程序集。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "所引用的 COM 对象是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String)
  id: CreateDomain(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String)
  nameWithType: AppDomain.CreateDomain(String)
  fullName: System.AppDomain.CreateDomain(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "具有指定名称创建新的应用程序域。"
  remarks: "`friendlyName`参数用于确定对用户有意义的方式的域。 此字符串应适合在用户界面中显示。       此方法重载使用<xref:System.AppDomainSetup>从默认应用程序域的信息。</xref:System.AppDomainSetup>"
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_1_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/m-system.appdomain.creat_1_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/m-system.appdomain.creat_1_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName);
    parameters:
    - id: friendlyName
      type: System.String
      description: "域的友好名称。"
    return:
      type: System.AppDomain
      description: "新创建的应用程序域中。"
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)
  id: CreateDomain(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence)
  nameWithType: AppDomain.CreateDomain(String,Evidence)
  fullName: System.AppDomain.CreateDomain(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "具有给定名称使用提供的证据创建新的应用程序域。"
  remarks: "This method overload uses the <xref:System.AppDomainSetup> information from the default application domain.  \n  \n If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the CreateDomain overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_0_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/m-system.appdomain.creat_0_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/m-system.appdomain.creat_0_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);
    parameters:
    - id: friendlyName
      type: System.String
      description: "域的友好名称。 此友好名称可以显示在用户界面，以标识域中。 有关详细信息，请参阅<xref:System.AppDomain.FriendlyName*>。</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "确定在应用程序域中运行代码的标识的证据。 传递<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>以使用当前的应用程序域的证据。"
    return:
      type: System.AppDomain
      description: "新创建的应用程序域中。"
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,AppDomainSetup)
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "创建一个新的应用程序域，使用指定的名称、 证据和应用程序域设置信息。"
  remarks: "If `info` is not supplied, this method overload uses the <xref:System.AppDomainSetup> information from the default application domain.  \n  \n If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/f22a5c12-7605-4011-8d1c-_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/f22a5c12-7605-4011-8d1c-_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/f22a5c12-7605-4011-8d1c-_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);
    parameters:
    - id: friendlyName
      type: System.String
      description: "域的友好名称。 此友好名称可以显示在用户界面，以标识域中。 有关详细信息，请参阅<xref:System.AppDomain.FriendlyName*>。</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "确定在应用程序域中运行代码的标识的证据。 传递<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>以使用当前的应用程序域的证据。"
    - id: info
      type: System.AppDomainSetup
      description: "包含应用程序域初始化信息的对象。"
    return:
      type: System.AppDomain
      description: "新创建的应用程序域中。"
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "创建一个新的应用程序域，使用指定的名称、 证据、 应用程序域设置信息、 默认权限集和完全信任程序集的数组。"
  remarks: "必须设置<xref:System.AppDomainSetup.ApplicationBase%2A>属性<xref:System.AppDomainSetup>为提供的对象`info`。</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.ApplicationBase%2A> 否则，会引发异常。       如果`securityInfo`是未提供，用于从当前的应用程序域的证据。       为提供的信息`grantSet`和`fullTrustAssemblies`用于创建<xref:System.Security.Policy.ApplicationTrust>新的应用程序域的对象。</xref:System.Security.Policy.ApplicationTrust>"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, System.Security.Policy.StrongName[] fullTrustAssemblies);
    parameters:
    - id: friendlyName
      type: System.String
      description: "域的友好名称。 此友好名称可以显示在用户界面，以标识域中。 有关详细信息，请参阅<xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>的说明"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "确定在应用程序域中运行代码的标识的证据。 传递<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>以使用当前的应用程序域的证据。"
    - id: info
      type: System.AppDomainSetup
      description: "包含应用程序域初始化信息的对象。"
    - id: grantSet
      type: System.Security.PermissionSet
      description: "默认权限集，它是授予到所有程序集加载到不具有特定权限的新应用程序域。"
    - id: fullTrustAssemblies
      type: System.Security.Policy.StrongName[]
      description: "数组的强名称，表示程序集被认为完全受信任新的应用程序域中。"
    return:
      type: System.AppDomain
      description: "新创建的应用程序域中。"
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "应用程序域<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。       -或-<xref:System.AppDomainSetup.ApplicationBase*>上未设置属性<xref href=&quot;System.AppDomainSetup&quot;></xref>为提供的对象<code> info </code>。</xref:System.AppDomainSetup.ApplicationBase*>"
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,String,String,Boolean)
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "具有给定名称，使用证据、 应用程序基路径、 相对搜索路径和一个参数，指定是否要加载到应用程序域的程序集卷影副本创建新的应用程序域。"
  remarks: "If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A>and [Shadow Copying Assemblies](~/add/includes/ajax-current-ext-md.md).  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/9bed52ed-b275-4e3a-b9e6-_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/9bed52ed-b275-4e3a-b9e6-_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/9bed52ed-b275-4e3a-b9e6-_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);
    parameters:
    - id: friendlyName
      type: System.String
      description: "域的友好名称。 此友好名称可以显示在用户界面，以标识域中。 有关详细信息，请参阅<xref:System.AppDomain.FriendlyName*>。</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "确定在应用程序域中运行代码的标识的证据。 传递<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>以使用当前的应用程序域的证据。"
    - id: appBasePath
      type: System.String
      description: "程序集冲突解决程序用来探测程序集基目录。 有关详细信息，请参阅<xref:System.AppDomain.BaseDirectory*>。</xref:System.AppDomain.BaseDirectory*>"
    - id: appRelativeSearchPath
      type: System.String
      description: "相对于基目录在此程序集冲突解决程序应探测专用程序集路径。 有关详细信息，请参阅<xref:System.AppDomain.RelativeSearchPath*>。</xref:System.AppDomain.RelativeSearchPath*>"
    - id: shadowCopyFiles
      type: System.Boolean
      description: "如果<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>，到此应用程序域加载程序集的卷影副本。"
    return:
      type: System.AppDomain
      description: "新创建的应用程序域中。"
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "具有给定名称，使用证据、 应用程序基路径、 相对搜索路径和一个参数，指定是否要加载到应用程序域的程序集卷影副本创建新的应用程序域。 指定初始化应用程序域时，调用的回调方法以及传递回调方法的字符串参数的数组。"
  remarks: "The method represented by `adInit` is executed in the context of the newly created application domain.  \n  \n If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A>and [Shadow Copying Assemblies](~/add/includes/ajax-current-ext-md.md).  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);
    parameters:
    - id: friendlyName
      type: System.String
      description: "域的友好名称。 此友好名称可以显示在用户界面，以标识域中。 有关详细信息，请参阅<xref:System.AppDomain.FriendlyName*>。</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "确定在应用程序域中运行代码的标识的证据。 传递<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>以使用当前的应用程序域的证据。"
    - id: appBasePath
      type: System.String
      description: "程序集冲突解决程序用来探测程序集基目录。 有关详细信息，请参阅<xref:System.AppDomain.BaseDirectory*>。</xref:System.AppDomain.BaseDirectory*>"
    - id: appRelativeSearchPath
      type: System.String
      description: "相对于基目录在此程序集冲突解决程序应探测专用程序集路径。 有关详细信息，请参阅<xref:System.AppDomain.RelativeSearchPath*>。</xref:System.AppDomain.RelativeSearchPath*>"
    - id: shadowCopyFiles
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>程序集卷影副本加载到应用程序域。"
    - id: adInit
      type: System.AppDomainInitializer
      description: "<xref href=&quot;System.AppDomainInitializer&quot;> </xref>表示时调用的回调方法的委托新<xref href=&quot;System.AppDomain&quot;></xref>初始化对象。"
    - id: adInitArgs
      type: System.String[]
      description: "数组的字符串实自变量传递给由回调`adInit`，当新<xref href=&quot;System.AppDomain&quot;></xref>初始化对象。"
    return:
      type: System.AppDomain
      description: "新创建的应用程序域中。"
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String)
  id: CreateInstance(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String)
  nameWithType: AppDomain.CreateInstance(String,String)
  fullName: System.AppDomain.CreateInstance(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "创建在指定的程序集中定义的指定类型的新实例。"
  remarks: "此方法调用的默认构造函数`typeName`。       请参阅<xref:System.Reflection.AssemblyName>的格式`assemblyName`。</xref:System.Reflection.AssemblyName>       尝试在不是当前的应用程序域的目标应用程序域上调用 CreateInstance 将导致目标应用程序域中的程序集成功加载。 由于<xref:System.Reflection.Assembly>不<xref:System.MarshalByRefObject>，当此方法尝试返回<xref:System.Reflection.Assembly>到当前的应用程序域加载程序集，公共语言运行时将尝试到当前的应用程序域加载程序集和负载可能会失败。</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> 可能不同于不同的两个应用程序域的路径设置是否首先加载的程序集加载到当前的应用程序域的程序集。"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "程序集的显示名称。 请参阅&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;。"
    - id: typeName
      type: System.String
      description: "包括命名空间而不是程序集，以返回所请求类型的完全限定的名称&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;属性。"
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "一个对象，它指定的新实例的包装<code> typeName </code>。 返回值需要打开包装才能访问真实对象。"
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>不是有效的程序集。       -或-当前加载版本 2.0 或更高版本的公共语言运行时和<code>assemblyName</code>用更高版本编译。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>未找到。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "调用方没有权限调用此构造函数。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找不匹配的公共构造函数。"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>中未找到<code>assemblyName</code>。"
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "此实例是否<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Object[])
  id: CreateInstance(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "创建在指定的程序集中定义的指定类型的新实例。 一个参数指定包含激活特性的数组。"
  remarks: "此方法调用的默认构造函数`typeName`。       请参阅<xref:System.Reflection.AssemblyName>的格式`assemblyName`。</xref:System.Reflection.AssemblyName>       尝试调用<xref:System.AppDomain.CreateInstance%2A>在目标上不是当前的应用程序域的应用程序域将导致目标应用程序域中的程序集成功加载。</xref:System.AppDomain.CreateInstance%2A> 由于<xref:System.Reflection.Assembly>不<xref:System.MarshalByRefObject>，当此方法尝试返回<xref:System.Reflection.Assembly>到当前的应用程序域加载程序集，公共语言运行时将尝试到当前的应用程序域加载程序集和负载可能会失败。</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> 可能不同于不同的两个应用程序域的路径设置是否首先加载的程序集加载到当前的应用程序域的程序集。"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "程序集的显示名称。 请参阅&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;。"
    - id: typeName
      type: System.String
      description: "包括命名空间而不是程序集，以返回所请求类型的完全限定的名称&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;属性。"
    - id: activationAttributes
      type: System.Object[]
      description: "一个或多个可以参与激活的特性的数组。 通常情况下，一个数组，包含单个<xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;></xref>指定激活远程对象所需的 URL 的对象。       此参数与客户端激活的对象。客户端激活是一项传统技术，保留用于向后兼容，但不是建议新的开发。 分布式应用程序应改用 Windows Communication Foundation。"
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "一个对象，它指定的新实例的包装<code> typeName </code>。 返回值需要打开包装才能访问真实对象。"
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>不是有效的程序集。       -或-当前加载版本 2.0 或更高版本的公共语言运行时和<code>assemblyName</code>用更高版本编译。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>未找到。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "调用方没有权限调用此构造函数。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找不匹配的公共构造函数。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "调用方不能为不是继承自的对象提供激活属性<xref href=&quot;System.MarshalByRefObject&quot;> </xref>。"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>中未找到<code>assemblyName</code>。"
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "此实例是否<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "创建在指定的程序集中定义的指定类型的新实例。 参数指定联编程序、 绑定标志、 构造函数自变量、 区域性特定信息用于解释自变量，以及可选激活特性。"
  remarks: "请参阅<xref:System.Reflection.AssemblyName>的格式`assemblyName`。</xref:System.Reflection.AssemblyName>       尝试调用<xref:System.AppDomain.CreateInstance%2A>在目标上不是当前的应用程序域的应用程序域将导致目标应用程序域中的程序集成功加载。</xref:System.AppDomain.CreateInstance%2A> 由于<xref:System.Reflection.Assembly>不<xref:System.MarshalByRefObject>，当此方法尝试返回<xref:System.Reflection.Assembly>到当前的应用程序域加载程序集，公共语言运行时将尝试到当前的应用程序域加载程序集和负载可能会失败。</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> 可能不同于不同的两个应用程序域的路径设置是否首先加载的程序集加载到当前的应用程序域的程序集。"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "程序集的显示名称。 请参阅&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;。"
    - id: typeName
      type: System.String
      description: "包括命名空间而不是程序集，以返回所请求类型的完全限定的名称&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;属性。"
    - id: ignoreCase
      type: System.Boolean
      description: "一个布尔值，指定是否执行区分大小写的搜索。"
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "影响搜索的零个或多个位标志的组合`typeName`构造函数。 如果`bindingAttr`为零，区分大小写的搜索，对公共构造函数。"
    - id: binder
      type: System.Reflection.Binder
      description: "启用绑定、 强制自变量的对象类型、 成员的调用，以及检索<xref:System.Reflection.MemberInfo>对象使用反射。</xref:System.Reflection.MemberInfo> 如果`binder`是 null，则使用默认的联编程序。"
    - id: args
      type: System.Object[]
      description: "要传递给构造函数的参数。 此自变量数组必须在数量、 顺序中匹配的参数和类型的构造函数调用。 如果默认构造函数是首选方法，`args`必须是空数组或 null。"
    - id: culture
      type: System.Globalization.CultureInfo
      description: "控制强制转换的区域性特定信息`args`为声明的正式类型`typeName`构造函数。 如果`culture`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>、<xref:System.Globalization.CultureInfo>则使用当前线程。</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "一个或多个可以参与激活的特性的数组。 通常情况下，一个数组，包含单个<xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;></xref>指定激活远程对象所需的 URL 的对象。       此参数与客户端激活的对象。 客户端激活是一项传统技术，保留用于向后兼容，但不是建议新的开发。 分布式应用程序应改用 Windows Communication Foundation。"
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "一个对象，它指定的新实例的包装<code> typeName </code>。 返回值需要打开包装才能访问真实对象。"
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>不是有效的程序集。       -或-<code>assemblyName</code>用比当前加载的版本更高版本的公共语言运行时编译。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>未找到。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "调用方没有权限调用此构造函数。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找不匹配的构造函数。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "调用方不能为不是继承自的对象提供激活属性<xref href=&quot;System.MarshalByRefObject&quot;> </xref>。"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>中未找到<code>assemblyName</code>。"
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "此实例是否<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "创建在指定的程序集中定义的指定类型的新实例。 参数指定联编程序、 绑定标志、 构造函数自变量、 区域性特定信息用于解释自变量、 激活特性和授权，以创建类型。"
  remarks: "请参阅<xref:System.Reflection.AssemblyName>的格式`assemblyName`。</xref:System.Reflection.AssemblyName>       尝试调用<xref:System.AppDomain.CreateInstance%2A>在目标上不是当前的应用程序域的应用程序域将导致目标应用程序域中的程序集成功加载。</xref:System.AppDomain.CreateInstance%2A> 由于<xref:System.Reflection.Assembly>不<xref:System.MarshalByRefObject>，当此方法尝试返回<xref:System.Reflection.Assembly>到当前的应用程序域加载程序集，公共语言运行时将尝试到当前的应用程序域加载程序集和负载可能会失败。</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> 可能不同于不同的两个应用程序域的路径设置是否首先加载的程序集加载到当前的应用程序域的程序集。"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "程序集的显示名称。 请参阅&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;。"
    - id: typeName
      type: System.String
      description: "包括命名空间而不是程序集，以返回所请求类型的完全限定的名称&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;属性。"
    - id: ignoreCase
      type: System.Boolean
      description: "一个布尔值，指定是否执行区分大小写的搜索。"
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "影响搜索的零个或多个位标志的组合`typeName`构造函数。 如果`bindingAttr`为零，区分大小写的搜索，对公共构造函数。"
    - id: binder
      type: System.Reflection.Binder
      description: "启用绑定、 强制自变量的对象类型、 成员的调用，以及检索<xref:System.Reflection.MemberInfo>对象使用反射。</xref:System.Reflection.MemberInfo> 如果`binder`是 null，则使用默认的联编程序。"
    - id: args
      type: System.Object[]
      description: "要传递给构造函数的参数。 此自变量数组必须在数量、 顺序中匹配的参数和类型的构造函数调用。 如果默认构造函数是首选方法，`args`必须是空数组或 null。"
    - id: culture
      type: System.Globalization.CultureInfo
      description: "控制强制转换的区域性特定信息`args`为声明的正式类型`typeName`构造函数。 如果`culture`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>、<xref:System.Globalization.CultureInfo>则使用当前线程。</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "一个或多个可以参与激活的特性的数组。 通常情况下，一个数组，包含单个<xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;></xref>指定激活远程对象所需的 URL 的对象。       此参数与客户端激活的对象。客户端激活是一项传统技术，保留用于向后兼容，但不是建议新的开发。 分布式应用程序应改用 Windows Communication Foundation。"
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "用于授权创建信息`typeName`。"
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "一个对象，它指定的新实例的包装<code> typeName </code>。 返回值需要打开包装才能访问真实对象。"
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>不是有效的程序集。       -或-当前加载版本 2.0 或更高版本的公共语言运行时和<code>assemblyName</code>用更高版本编译。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>未找到。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "调用方没有权限调用此构造函数。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找不匹配的构造函数。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "调用方不能为不是继承自的对象提供激活属性<xref href=&quot;System.MarshalByRefObject&quot;> </xref>。       -or-       <code>securityAttributes</code> is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. 当未启用旧版 CAS 策略时， <code> securityAttributes </code>应为<xref uid=&quot;langword_csharp_null.&quot; name=&quot;null.&quot; href=&quot;&quot;></xref>"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>中未找到<code>assemblyName</code>。"
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "此实例是否<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)
  id: CreateInstanceAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "创建指定类型的新实例。 参数指定定义类型的程序集和类型的名称。"
  remarks: "这是将<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName></xref:System.AppDomain.CreateInstance%2A>合并的便捷方法 此方法调用的默认构造函数`typeName`。       请参阅<xref:System.Reflection.AssemblyName>的格式`assemblyName`。</xref:System.Reflection.AssemblyName> 请参阅<xref:System.Type.FullName%2A?displayProperty=fullName>属性的格式`typeName`。</xref:System.Type.FullName%2A?displayProperty=fullName>      1> [!NOTE]&1;> 如果你进行早期绑定调用的方法`M`类型的对象的`T1`由 CreateInstanceAndUnwrap，返回并该方法使对类型的对象的方法的早期绑定调用`T2`的程序集中`C`当前程序集或包含的程序集以外`T1`，程序集`C`会加载到当前的应用程序域。 如果即使早期绑定调用，则会发生此加载`T1.M()`的正文中进行<xref:System.Reflection.Emit.DynamicMethod>，或在其他动态生成的代码中。</xref:System.Reflection.Emit.DynamicMethod> 如果当前域是默认域，程序集`C`进程结束前不能卸载。 如果当前域稍后尝试加载程序集`C`，则加载可能失败。"
  example:
  - "The following code example shows the simplest way to execute code in another application domain. The example defines a class named `Worker` that inherits from <xref:System.MarshalByRefObject>. The `Worker` class defines a method that displays the name of the application domain in which it is executing. The example creates instances of `Worker` in the default application domain and in a new application domain.  \n  \n> [!NOTE]\n>  The assembly that contains `Worker` must be loaded into both application domains, but it can load other assemblies that exist only in the new application domain.  \n  \n [!code-cpp[CreateInstanceAndUnwrap2#1](~/add/codesnippet/cpp/m-system.appdomain.creat_2_1.cpp)]\n [!code-cs[CreateInstanceAndUnwrap2#1](~/add/codesnippet/csharp/m-system.appdomain.creat_2_1.cs)]\n [!code-vb[CreateInstanceAndUnwrap2#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_2_1.vb)]"
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "程序集的显示名称。 请参阅&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;。"
    - id: typeName
      type: System.String
      description: "包括命名空间而不是程序集，以返回所请求类型的完全限定的名称&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;属性。"
    return:
      type: System.Object
      description: "指定的对象的实例<code> typeName </code>。"
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找不匹配的公共构造函数。"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>中未找到<code>assemblyName</code>。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>未找到。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "调用方没有权限调用此构造函数。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>不是有效的程序集。       -或-当前加载版本 2.0 或更高版本的公共语言运行时和<code>assemblyName</code>用更高版本编译。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  id: CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "创建指定类型的新实例。 参数指定定义该类型的程序集、 类型的名称和激活特性的数组。"
  remarks: "这是将<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName></xref:System.AppDomain.CreateInstance%2A>合并的便捷方法 此方法调用的默认构造函数`typeName`。       请参阅<xref:System.Reflection.AssemblyName>的格式`assemblyName`。</xref:System.Reflection.AssemblyName> 请参阅<xref:System.Type.FullName%2A?displayProperty=fullName>属性的格式`typeName`。</xref:System.Type.FullName%2A?displayProperty=fullName>      1> [!NOTE]&1;> 如果你进行早期绑定调用的方法`M`类型的对象的`T1`由返回<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>，并方法使对类型的对象的方法的早期绑定调用`T2`的程序集中`C`当前程序集或包含的程序集以外`T1`，程序集`C`会加载到当前的应用程序域。</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> 如果即使早期绑定调用，则会发生此加载`T1.M()`的正文中进行<xref:System.Reflection.Emit.DynamicMethod>，或在其他动态生成的代码中。</xref:System.Reflection.Emit.DynamicMethod> 如果当前域是默认域，程序集`C`进程结束前不能卸载。 如果当前域稍后尝试加载程序集`C`，则加载可能失败。"
  example:
  - >-
    [!code-cpp[ADDyno#1](~/add/codesnippet/cpp/ec186439-6d54-4090-82e0-_1.cpp)]
     [!code-cs[ADDyno#1](~/add/codesnippet/csharp/ec186439-6d54-4090-82e0-_1.cs)]
     [!code-vb[ADDyno#1](~/add/codesnippet/visualbasic/ec186439-6d54-4090-82e0-_1.vb)]
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "程序集的显示名称。 请参阅&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;。"
    - id: typeName
      type: System.String
      description: "包括命名空间而不是程序集，以返回所请求类型的完全限定的名称&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;属性。"
    - id: activationAttributes
      type: System.Object[]
      description: "一个或多个可以参与激活的特性的数组。 通常情况下，一个数组，包含单个<xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;></xref>指定激活远程对象所需的 URL 的对象。       此参数与客户端激活的对象。客户端激活是一项传统技术，保留用于向后兼容，但不是建议新的开发。 分布式应用程序应改用 Windows Communication Foundation。"
    return:
      type: System.Object
      description: "指定的对象的实例<code> typeName </code>。"
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找不匹配的公共构造函数。"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>中未找到<code>assemblyName</code>。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>未找到。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "调用方没有权限调用此构造函数。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "调用方不能为不是继承自的对象提供激活属性<xref href=&quot;System.MarshalByRefObject&quot;> </xref>。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>不是有效的程序集。       -或-当前加载版本 2.0 或更高版本的公共语言运行时和<code>assemblyName</code>用更高版本编译。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "创建在指定的程序集中，指定是否忽略类型名称的大小写; 定义的指定类型的新实例绑定特性和用于选择要创建; 类型的联编构造函数; 参数区域性;以及激活特性。"
  remarks: "这是将<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName></xref:System.AppDomain.CreateInstance%2A>合并的便捷方法       请参阅<xref:System.Reflection.AssemblyName>的格式`assemblyName`。</xref:System.Reflection.AssemblyName> 请参阅<xref:System.Type.FullName%2A?displayProperty=fullName>属性的格式`typeName`。</xref:System.Type.FullName%2A?displayProperty=fullName>      1> [!NOTE]&1;> 如果你进行早期绑定调用的方法`M`类型的对象的`T1`由返回<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>，并方法使对类型的对象的方法的早期绑定调用`T2`的程序集中`C`当前程序集或包含的程序集以外`T1`，程序集`C`会加载到当前的应用程序域。</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> 如果即使早期绑定调用，则会发生此加载`T1.M()`的正文中进行<xref:System.Reflection.Emit.DynamicMethod>，或在其他动态生成的代码中。</xref:System.Reflection.Emit.DynamicMethod> 如果当前域是默认域，程序集`C`进程结束前不能卸载。 如果当前域稍后尝试加载程序集`C`，则加载可能失败。"
  example:
  - "The following sample demonstrates the use of the `ignoreCase` parameter.  \n  \n [!code-cs[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/csharp/7b1dcc86-9680-463d-b78c-_1.cs)]\n [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/cpp/7b1dcc86-9680-463d-b78c-_1.cpp)]\n [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/visualbasic/7b1dcc86-9680-463d-b78c-_1.vb)]"
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "程序集的显示名称。 请参阅&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;。"
    - id: typeName
      type: System.String
      description: "包括命名空间而不是程序集，以返回所请求类型的完全限定的名称&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;属性。"
    - id: ignoreCase
      type: System.Boolean
      description: "一个布尔值，指定是否执行区分大小写的搜索。"
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "影响搜索的零个或多个位标志的组合`typeName`构造函数。 如果`bindingAttr`为零，区分大小写的搜索，对公共构造函数。"
    - id: binder
      type: System.Reflection.Binder
      description: "启用绑定、 强制自变量的对象类型、 成员的调用，以及检索<xref:System.Reflection.MemberInfo>对象使用反射。</xref:System.Reflection.MemberInfo> 如果`binder`是 null，则使用默认的联编程序。"
    - id: args
      type: System.Object[]
      description: "要传递给构造函数的参数。 此自变量数组必须在数量、 顺序中匹配的参数和类型的构造函数调用。 如果默认构造函数是首选方法，`args`必须是空数组或 null。"
    - id: culture
      type: System.Globalization.CultureInfo
      description: "用于控制类型强制的特定于区域性的对象。 如果`culture`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>、 <xref uid=&quot;langword_csharp_CultureInfo&quot; name=&quot;CultureInfo&quot; href=&quot;&quot;> </xref>则使用当前线程。"
    - id: activationAttributes
      type: System.Object[]
      description: "一个或多个可以参与激活的特性的数组。 通常情况下，一个数组，包含单个<xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;></xref>对象。 指定激活远程对象所需的 URL。       此参数与客户端激活的对象。 客户端激活是一项传统技术，保留用于向后兼容，但不是建议新的开发。 分布式应用程序应改用 Windows Communication Foundation。"
    return:
      type: System.Object
      description: "指定的对象的实例<code> typeName </code>。"
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找不匹配的构造函数。"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>中未找到<code>assemblyName</code>。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>未找到。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "调用方没有权限调用此构造函数。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "调用方不能为不是继承自的对象提供激活属性<xref href=&quot;System.MarshalByRefObject&quot;> </xref>。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>不是有效的程序集。       -或-<code>assemblyName</code>用比当前加载的版本更高版本的公共语言运行时编译。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "创建指定类型的新实例。 参数指定的类型，以及如何查找和创建它的名称。"
  remarks: "这是将<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName></xref:System.AppDomain.CreateInstance%2A>合并的便捷方法       请参阅<xref:System.Reflection.AssemblyName>的格式`assemblyName`。</xref:System.Reflection.AssemblyName> 请参阅<xref:System.Type.FullName%2A?displayProperty=fullName>属性的格式`typeName`。</xref:System.Type.FullName%2A?displayProperty=fullName>      1> [!NOTE]&1;> 如果你进行早期绑定调用的方法`M`类型的对象的`T1`由返回<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>，并方法使对类型的对象的方法的早期绑定调用`T2`的程序集中`C`当前程序集或包含的程序集以外`T1`，程序集`C`会加载到当前的应用程序域。</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> 如果即使早期绑定调用，则会发生此加载`T1.M()`的正文中进行<xref:System.Reflection.Emit.DynamicMethod>，或在其他动态生成的代码中。</xref:System.Reflection.Emit.DynamicMethod> 如果当前域是默认域，程序集`C`进程结束前不能卸载。 如果当前域稍后尝试加载程序集`C`，则加载可能失败。"
  example:
  - "The following sample demonstrates the use of the `ignoreCase` parameter.  \n  \n [!code-cs[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/csharp/8e0d44ad-3def-4658-8d9d-_1.cs)]\n [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/cpp/8e0d44ad-3def-4658-8d9d-_1.cpp)]\n [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/visualbasic/8e0d44ad-3def-4658-8d9d-_1.vb)]"
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "程序集的显示名称。 请参阅&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;。"
    - id: typeName
      type: System.String
      description: "包括命名空间而不是程序集，以返回所请求类型的完全限定的名称&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;属性。"
    - id: ignoreCase
      type: System.Boolean
      description: "一个布尔值，指定是否执行区分大小写的搜索。"
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "影响搜索的零个或多个位标志的组合`typeName`构造函数。 如果`bindingAttr`为零，区分大小写的搜索，对公共构造函数。"
    - id: binder
      type: System.Reflection.Binder
      description: "启用绑定、 强制自变量的对象类型、 成员的调用，以及检索<xref:System.Reflection.MemberInfo>对象使用反射。</xref:System.Reflection.MemberInfo> 如果`binder`是 null，则使用默认的联编程序。"
    - id: args
      type: System.Object[]
      description: "要传递给构造函数的参数。 此自变量数组必须在数量、 顺序中匹配的参数和类型的构造函数调用。 如果默认构造函数是首选方法，`args`必须是空数组或 null。"
    - id: culture
      type: System.Globalization.CultureInfo
      description: "用于控制类型强制的特定于区域性的对象。 如果`culture`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>、 <xref uid=&quot;langword_csharp_CultureInfo&quot; name=&quot;CultureInfo&quot; href=&quot;&quot;> </xref>则使用当前线程。"
    - id: activationAttributes
      type: System.Object[]
      description: "一个或多个可以参与激活的特性的数组。 通常情况下，一个数组，包含单个<xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;></xref>指定激活远程对象所需的 URL 的对象。       此参数与客户端激活的对象。 客户端激活是一项传统技术，保留用于向后兼容，但不是建议新的开发。 分布式应用程序应改用 Windows Communication Foundation。"
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "用于授权创建信息`typeName`。"
    return:
      type: System.Object
      description: "指定的对象的实例<code> typeName </code>。"
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找不匹配的构造函数。"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>中未找到<code>assemblyName</code>。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>未找到。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "调用方没有权限调用此构造函数。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "调用方不能为不是继承自的对象提供激活属性<xref href=&quot;System.MarshalByRefObject&quot;> </xref>。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>不是有效的程序集。       -或-当前加载版本 2.0 或更高版本的公共语言运行时和<code>assemblyName</code>用更高版本编译。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String)
  id: CreateInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String)
  nameWithType: AppDomain.CreateInstanceFrom(String,String)
  fullName: System.AppDomain.CreateInstanceFrom(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "创建在指定的程序集文件中定义的指定类型的新实例。"
  remarks: "默认构造函数`typeName`调用。       有关详细信息，请参阅<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>方法。</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       当 CreateInstanceFrom 方法用于在目标应用程序域中，而不从其进行调用时，应用程序域中创建实例时程序集加载位于目标应用程序域。 但是，如果该实例调用的应用程序域处于解包，则以某些方式使用解包的实例会导致要加载到调用应用程序域的程序集。 例如，实例解包后，可能会请求其类型信息、 要调用其方法后期绑定。 程序集加载到调用应用程序域时，可能会发生异常。      -如果以前的同一个程序集的另一个版本加载到调用应用程序域，或如果调用应用程序域的负载路径是不同的目标应用程序域，异常诸如<xref:System.MissingMethodException>可以发生。</xref:System.MissingMethodException>      -如果调用应用程序域进行早期绑定调用实例类型，<xref:System.InvalidCastException>当尝试强制转换实例可能会引发。</xref:System.InvalidCastException>"
  example:
  - "The following example shows how to use the CreateInstanceFrom method overload to create an instance of an object in a target application domain and call its methods.  \n  \n The example defines the `MarshallableExample` class, which can be marshaled across application domain boundaries. The example builds a path to the currently executing assembly, creates a target application domain, and uses the CreateInstanceFrom method overload to load the example assembly into the target application domain and create an instance of `MarshallableExample`.  \n  \n> [!NOTE]\n>  The path is absolute in this example, but a relative path would also work because the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=fullName> method is used to load the assembly.  \n  \n After unwrapping the object handle, the example demonstrates three ways to use an object in a target application domain:  \n  \n-   Invoking a method with late binding, using reflection. This requires type information, which causes the assembly to be loaded into the application domain of the caller. (In this example, it is already loaded.)  \n  \n-   Casting the object to an interface known to both the caller and the callee. If the interface is defined in the calling assembly or in a third assembly referenced by both the caller and the callee, the called assembly is not loaded into the application domain of the caller.  \n  \n-   Using the object directly when its type is known to the caller. The assembly must be loaded into the application domain of the caller.  \n  \n Another way to avoid loading the called assembly into the application domain of the caller is for the caller to derive from the <xref:System.MarshalByRefObject> class and to define a method that can be run in the target application domain. That method can use reflection to examine a target assembly, because the target assembly is already loaded into the target application domain. See the example for the <xref:System.AppDomain.DynamicDirectory%2A> property.  \n  \n [!code-cs[System.AppDomain.CreateInstanceFrom_StringString#1](~/add/codesnippet/csharp/m-system.appdomain.creat_3_1.cs)]\n [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/add/codesnippet/cpp/m-system.appdomain.creat_3_1.cpp)]\n [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_3_1.vb)]"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "包括包含定义所请求的类型的程序集的文件的路径名称。 使用加载的程序集<xref:System.Reflection.Assembly.LoadFrom*>方法。</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "包括命名空间而不是程序集，以返回所请求类型的完全限定的名称&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;属性。"
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "一个对象，它的新实例，包装或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果<code> typeName </code>找不到。 返回值需要打开包装才能访问真实对象。"
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>未找到。"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>中未找到<code>assemblyFile</code>。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找到没有无参数公共构造函数。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "调用方没有足够的权限调用此构造函数。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>不是有效的程序集。       -或-当前加载版本 2.0 或更高版本的公共语言运行时和<code>assemblyFile</code>用更高版本编译。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "此实例是否<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])
  id: CreateInstanceFrom(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "创建在指定的程序集文件中定义的指定类型的新实例。"
  remarks: "默认构造函数`typeName`调用。       有关此方法的详细信息，请参阅<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>方法。</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       当<xref:System.AppDomain.CreateInstanceFrom%2A>方法用于在目标应用程序域中，而不从其进行调用的应用程序域中创建实例时，目标应用程序域中则加载程序集。</xref:System.AppDomain.CreateInstanceFrom%2A> 但是，如果该实例调用的应用程序域处于解包，则以某些方式使用解包的实例会导致要加载到调用应用程序域的程序集。 例如，实例解包后，可能会请求其类型信息、 要调用其方法后期绑定。 程序集加载到调用应用程序域时，可能会发生异常。      -如果以前的同一个程序集的另一个版本加载到调用应用程序域，或如果调用应用程序域的负载路径是不同的目标应用程序域，异常诸如<xref:System.MissingMethodException>可以发生。</xref:System.MissingMethodException>      -如果调用应用程序域进行早期绑定调用实例类型，<xref:System.InvalidCastException>当尝试强制转换实例可能会引发。</xref:System.InvalidCastException>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "包括包含定义所请求的类型的程序集的文件的路径名称。 使用加载的程序集<xref:System.Reflection.Assembly.LoadFrom*>方法。</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "包括命名空间而不是程序集，以返回所请求类型的完全限定的名称&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;属性。"
    - id: activationAttributes
      type: System.Object[]
      description: "一个或多个可以参与激活的特性的数组。 通常情况下，一个数组，包含单个<xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;></xref>指定激活远程对象所需的 URL 的对象。       此参数与客户端激活的对象。客户端激活是一项传统技术，保留用于向后兼容，但不是建议新的开发。 分布式应用程序应改用 Windows Communication Foundation。"
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "一个对象，它的新实例，包装或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果<code> typeName </code>找不到。 返回值需要打开包装才能访问真实对象。"
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>未找到。"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>中未找到<code>assemblyFile</code>。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "调用方没有足够的权限调用此构造函数。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找不匹配的公共构造函数。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "调用方不能为不是继承自的对象提供激活属性<xref href=&quot;System.MarshalByRefObject&quot;> </xref>。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>不是有效的程序集。       -或-当前加载版本 2.0 或更高版本的公共语言运行时和<code>assemblyFile</code>用更高版本编译。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "此实例是否<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "创建在指定的程序集文件中定义的指定类型的新实例。"
  remarks: "有关详细信息，请参阅<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>方法。</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       当<xref:System.AppDomain.CreateInstanceFrom%2A>方法用于在目标应用程序域中，而不从其进行调用的应用程序域中创建实例时，目标应用程序域中则加载程序集。</xref:System.AppDomain.CreateInstanceFrom%2A> 但是，如果该实例调用的应用程序域处于解包，则以某些方式使用解包的实例会导致要加载到调用应用程序域的程序集。 例如，实例解包后，可能会请求其类型信息、 要调用其方法后期绑定。 程序集加载到调用应用程序域时，可能会发生异常。      -如果以前的同一个程序集的另一个版本加载到调用应用程序域，或如果调用应用程序域的负载路径是不同的目标应用程序域，异常诸如<xref:System.MissingMethodException>可以发生。</xref:System.MissingMethodException>      -如果调用应用程序域进行早期绑定调用实例类型，<xref:System.InvalidCastException>当尝试强制转换实例可能会引发。</xref:System.InvalidCastException>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "包括包含定义所请求的类型的程序集的文件的路径名称。 使用加载的程序集<xref:System.Reflection.Assembly.LoadFrom*>方法。</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "包括命名空间而不是程序集，以返回所请求类型的完全限定的名称&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;属性。"
    - id: ignoreCase
      type: System.Boolean
      description: "一个布尔值，指定是否执行区分大小写的搜索。"
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "影响搜索的零个或多个位标志的组合`typeName`构造函数。 如果`bindingAttr`为零，区分大小写的搜索，对公共构造函数。"
    - id: binder
      type: System.Reflection.Binder
      description: "启用绑定、 强制自变量的对象类型、 成员的调用，以及检索<xref:System.Reflection.MemberInfo>通过反射的对象。</xref:System.Reflection.MemberInfo> 如果`binder`是 null，则使用默认的联编程序。"
    - id: args
      type: System.Object[]
      description: "要传递给构造函数的参数。 此自变量数组必须在数量、 顺序中匹配的参数和类型的构造函数调用。 如果默认构造函数是首选方法，`args`必须是空数组或 null。"
    - id: culture
      type: System.Globalization.CultureInfo
      description: "控制强制转换的区域性特定信息`args`为声明的正式类型`typeName`构造函数。 如果`culture`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>、<xref:System.Globalization.CultureInfo>则使用当前线程。</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "一个或多个可以参与激活的特性的数组。 通常情况下，一个数组，包含单个<xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;></xref>指定激活远程对象所需的 URL 的对象。       此参数与客户端激活的对象。 客户端激活是一项传统技术，保留用于向后兼容，但不是建议新的开发。 分布式应用程序应改用 Windows Communication Foundation。"
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "一个对象，它的新实例，包装或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果<code> typeName </code>找不到。 返回值需要打开包装才能访问真实对象。"
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "调用方不能为不是继承自的对象提供激活属性<xref href=&quot;System.MarshalByRefObject&quot;> </xref>。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>未找到。"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>中未找到<code>assemblyFile</code>。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找不匹配的公共构造函数。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "调用方没有足够的权限调用此构造函数。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>不是有效的程序集。       -或-<code>assemblyFile</code>用比当前加载的版本更高版本的公共语言运行时编译。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "此实例是否<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "创建在指定的程序集文件中定义的指定类型的新实例。"
  remarks: "有关此方法的详细信息，请参阅<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>方法。</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       当<xref:System.AppDomain.CreateInstanceFrom%2A>方法用于在目标应用程序域中，而不从其进行调用的应用程序域中创建实例时，目标应用程序域中则加载程序集。</xref:System.AppDomain.CreateInstanceFrom%2A> 但是，如果该实例调用的应用程序域处于解包，则以某些方式使用解包的实例会导致要加载到调用应用程序域的程序集。 例如，实例解包后，可能会请求其类型信息、 要调用其方法后期绑定。 程序集加载到调用应用程序域时，可能会发生异常。      -如果以前的同一个程序集的另一个版本加载到调用应用程序域，或如果调用应用程序域的负载路径是不同的目标应用程序域，异常诸如<xref:System.MissingMethodException>可以发生。</xref:System.MissingMethodException>      -如果调用应用程序域进行早期绑定调用实例类型，<xref:System.InvalidCastException>当尝试强制转换实例可能会引发。</xref:System.InvalidCastException>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "包括包含定义所请求的类型的程序集的文件的路径名称。 使用加载的程序集<xref:System.Reflection.Assembly.LoadFrom*>方法。</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "包括命名空间而不是程序集，以返回所请求类型的完全限定的名称&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;属性。"
    - id: ignoreCase
      type: System.Boolean
      description: "一个布尔值，指定是否执行区分大小写的搜索。"
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "影响搜索的零个或多个位标志的组合`typeName`构造函数。 如果`bindingAttr`为零，区分大小写的搜索，对公共构造函数。"
    - id: binder
      type: System.Reflection.Binder
      description: "启用绑定、 强制自变量的对象类型、 成员的调用，以及检索<xref:System.Reflection.MemberInfo>通过反射的对象。</xref:System.Reflection.MemberInfo> 如果`binder`是 null，则使用默认的联编程序。"
    - id: args
      type: System.Object[]
      description: "要传递给构造函数的参数。 此自变量数组必须在数量、 顺序中匹配的参数和类型的构造函数调用。 如果默认构造函数是首选方法，`args`必须是空数组或 null。"
    - id: culture
      type: System.Globalization.CultureInfo
      description: "控制强制转换的区域性特定信息`args`为声明的正式类型`typeName`构造函数。 如果`culture`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>、<xref:System.Globalization.CultureInfo>则使用当前线程。</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "一个或多个可以参与激活的特性的数组。 通常情况下，一个数组，包含单个<xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;></xref>指定激活远程对象所需的 URL 的对象。       此参数与客户端激活的对象。 客户端激活是一项传统技术，保留用于向后兼容，但不是建议新的开发。 分布式应用程序应改用 Windows Communication Foundation。"
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "用于授权创建信息`typeName`。"
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "一个对象，它的新实例，包装或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果<code> typeName </code>找不到。 返回值需要打开包装才能访问真实对象。"
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "调用方不能为不是继承自的对象提供激活属性<xref href=&quot;System.MarshalByRefObject&quot;> </xref>。       -or-       <code>securityAttributes</code> is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. 当未启用旧版 CAS 策略时， <code> securityAttributes </code>应<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>未找到。"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>中未找到<code>assemblyFile</code>。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找不匹配的公共构造函数。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "调用方没有足够的权限调用此构造函数。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>不是有效的程序集。       -或-当前加载版本 2.0 或更高版本的公共语言运行时和<code>assemblyFile</code>用更高版本编译。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "此实例是否<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)
  id: CreateInstanceFromAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "创建在指定的程序集文件中定义的指定类型的新实例。"
  remarks: "这是将<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName></xref:System.AppDomain.CreateInstanceFrom%2A>合并的便捷方法 此方法调用的默认构造函数`typeName`。       有关详细信息，请参阅<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>方法。</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "文件名称和定义所请求的类型的程序集的路径。"
    - id: typeName
      type: System.String
      description: "包括命名空间而不是程序集，以返回所请求类型的完全限定的名称&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;属性。"
    return:
      type: System.Object
      description: "请求的对象，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果<code> typeName </code>找不到。"
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>未找到。"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>中未找到<code>assemblyName</code>。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找到没有无参数公共构造函数。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "调用方没有足够的权限调用此构造函数。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>不是有效的程序集。       -或-当前加载版本 2.0 或更高版本的公共语言运行时和<code>assemblyName</code>用更高版本编译。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  id: CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "创建在指定的程序集文件中定义的指定类型的新实例。"
  remarks: "这是将<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName></xref:System.AppDomain.CreateInstanceFrom%2A>合并的便捷方法 此方法调用的默认构造函数`typeName`。       有关此方法的详细信息，请参阅<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>方法。</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "文件名称和定义所请求的类型的程序集的路径。"
    - id: typeName
      type: System.String
      description: "请求的类型，包括命名空间而不是程序集的完全限定的名称 (请参阅&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;属性)。"
    - id: activationAttributes
      type: System.Object[]
      description: "一个或多个可以参与激活的特性的数组。 通常情况下，一个数组，包含单个<xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;></xref>指定激活远程对象所需的 URL 的对象。       此参数与客户端激活的对象。客户端激活是一项传统技术，保留用于向后兼容，但不是建议新的开发。 分布式应用程序应改用 Windows Communication Foundation。"
    return:
      type: System.Object
      description: "请求的对象，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果<code> typeName </code>找不到。"
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "调用方不能为不是继承自的对象提供激活属性<xref href=&quot;System.MarshalByRefObject&quot;> </xref>。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>未找到。"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>中未找到<code>assemblyName</code>。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找到没有无参数公共构造函数。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "调用方没有足够的权限调用此构造函数。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>不是有效的程序集。       -或-当前加载版本 2.0 或更高版本的公共语言运行时和<code>assemblyName</code>用更高版本编译。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "创建定义在指定的程序集文件中，指定是否忽略类型名称的大小写; 的指定类型的新实例绑定特性和用于选择要创建; 类型的联编构造函数; 参数区域性;以及激活特性。"
  remarks: "这是将<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName></xref:System.AppDomain.CreateInstanceFrom%2A>合并的便捷方法       有关此方法的详细信息，请参阅<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>方法。</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "文件名称和定义所请求的类型的程序集的路径。"
    - id: typeName
      type: System.String
      description: "包括命名空间而不是程序集，以返回所请求类型的完全限定的名称&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;属性。"
    - id: ignoreCase
      type: System.Boolean
      description: "一个布尔值，指定是否执行区分大小写的搜索。"
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "影响搜索的零个或多个位标志的组合`typeName`构造函数。 如果`bindingAttr`为零，区分大小写的搜索，对公共构造函数。"
    - id: binder
      type: System.Reflection.Binder
      description: "启用绑定、 强制自变量的对象类型、 成员的调用，以及检索<xref:System.Reflection.MemberInfo>通过反射的对象。</xref:System.Reflection.MemberInfo> 如果`binder`是 null，则使用默认的联编程序。"
    - id: args
      type: System.Object[]
      description: "要传递给构造函数的参数。 此自变量数组必须在数量、 顺序中匹配的参数和类型的构造函数调用。 如果默认构造函数是首选方法，`args`必须是空数组或 null。"
    - id: culture
      type: System.Globalization.CultureInfo
      description: "控制强制转换的区域性特定信息`args`为声明的正式类型`typeName`构造函数。 如果`culture`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>、<xref:System.Globalization.CultureInfo>则使用当前线程。</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "一个或多个可以参与激活的特性的数组。 通常情况下，一个数组，包含单个<xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;></xref>指定激活远程对象所需的 URL 的对象。       此参数与客户端激活的对象。 客户端激活是一项传统技术，保留用于向后兼容，但不是建议新的开发。 分布式应用程序应改用 Windows Communication Foundation。"
    return:
      type: System.Object
      description: "请求的对象，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果<code> typeName </code>找不到。"
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "调用方不能为不是继承自的对象提供激活属性<xref href=&quot;System.MarshalByRefObject&quot;> </xref>。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>未找到。"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>中未找到<code>assemblyName</code>。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找不匹配的公共构造函数。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "调用方没有足够的权限调用此构造函数。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>不是有效的程序集。       -或-<code>assemblyName</code>用更高版本的公共语言运行时编译的版本，是当前加载。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "创建在指定的程序集文件中定义的指定类型的新实例。"
  remarks: "这是将<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName></xref:System.AppDomain.CreateInstanceFrom%2A>合并的便捷方法       有关此方法的详细信息，请参阅<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>方法。</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "文件名称和定义所请求的类型的程序集的路径。"
    - id: typeName
      type: System.String
      description: "包括命名空间而不是程序集，以返回所请求类型的完全限定的名称&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;属性。"
    - id: ignoreCase
      type: System.Boolean
      description: "一个布尔值，指定是否执行区分大小写的搜索。"
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "影响搜索的零个或多个位标志的组合`typeName`构造函数。 如果`bindingAttr`为零，区分大小写的搜索，对公共构造函数。"
    - id: binder
      type: System.Reflection.Binder
      description: "启用绑定、 强制自变量的对象类型、 成员的调用，以及检索<xref:System.Reflection.MemberInfo>通过反射的对象。</xref:System.Reflection.MemberInfo> 如果`binder`是 null，则使用默认的联编程序。"
    - id: args
      type: System.Object[]
      description: "要传递给构造函数的参数。 此自变量数组必须在数量、 顺序中匹配的参数和类型的构造函数调用。 如果默认构造函数是首选方法，`args`必须是空数组或 null。"
    - id: culture
      type: System.Globalization.CultureInfo
      description: "控制强制转换的区域性特定信息`args`为声明的正式类型`typeName`构造函数。 如果`culture`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>、<xref:System.Globalization.CultureInfo>则使用当前线程。</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "一个或多个可以参与激活的特性的数组。 通常情况下，一个数组，包含单个<xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;></xref>指定激活远程对象所需的 URL 的对象。       此参数与客户端激活的对象。 客户端激活是一项传统技术，保留用于向后兼容，但不是建议新的开发。 分布式应用程序应改用 Windows Communication Foundation。"
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "用于授权创建信息`typeName`。"
    return:
      type: System.Object
      description: "请求的对象，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果<code> typeName </code>找不到。"
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "调用方不能为不是继承自的对象提供激活属性<xref href=&quot;System.MarshalByRefObject&quot;> </xref>。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>未找到。"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>中未找到<code>assemblyName</code>。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找不匹配的公共构造函数。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "调用方没有足够的权限调用此构造函数。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>不是有效的程序集。       -或-当前加载版本 2.0 或更高版本的公共语言运行时和<code>assemblyName</code>用更高版本编译。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  platform:
  - net462
- uid: System.AppDomain.CurrentDomain
  id: CurrentDomain
  parent: System.AppDomain
  langs:
  - csharp
  name: CurrentDomain
  nameWithType: AppDomain.CurrentDomain
  fullName: System.AppDomain.CurrentDomain
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取当前应用程序域当前<xref href=&quot;System.Threading.Thread&quot;> </xref>。"
  remarks: ''
  example:
  - "The following code example creates a new application domain. The CurrentDomain property is used to obtain an <xref:System.AppDomain> object that represents the current application domain. The <xref:System.AppDomain.FriendlyName%2A> property provides the name of the current application domain, which is then displayed at the command line.  \n  \n [!code-vb[ADApplicationBase#1](~/add/codesnippet/visualbasic/p-system.appdomain.curre_1.vb)]\n [!code-cpp[ADApplicationBase#1](~/add/codesnippet/cpp/p-system.appdomain.curre_1.cpp)]\n [!code-cs[ADApplicationBase#1](~/add/codesnippet/csharp/p-system.appdomain.curre_1.cs)]"
  syntax:
    content: public static AppDomain CurrentDomain { get; }
    return:
      type: System.AppDomain
      description: "当前的应用程序域中。"
  overload: System.AppDomain.CurrentDomain*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "定义具有指定名称和访问模式的动态程序集。"
  remarks: "此方法仅应使用当前的应用程序域中定义的动态程序集。 有关详细信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      1> [!NOTE]&1;> 在开发期间用于发出动态程序集的代码，建议你使用的重载<xref:System.AppDomain.DefineDynamicAssembly%2A>方法，它指定证据和权限，提供你想要具有，并且包含的动态程序集的证据<xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>中`refusedPermissions`。</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> 包括<xref:System.Security.Permissions.SecurityPermissionFlag>中`refusedPermissions`参数可确保验证 MSIL。</xref:System.Security.Permissions.SecurityPermissionFlag> 此技术的局限性是它还使<xref:System.Security.SecurityException>要求完全信任的代码一起使用时引发。</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the DefineDynamicAssembly method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/ec69fa93-4aea-4fc8-90e1-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/ec69fa93-4aea-4fc8-90e1-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/ec69fa93-4aea-4fc8-90e1-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "动态程序集的唯一标识。"
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "动态程序集的访问模式。"
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "具有指定名称和访问模式的动态程序集。"
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref>属性<code> name </code>开头空格，或包含向前或向后的斜杠。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "定义具有指定的名称、 访问模式和自定义特性的动态程序集。"
  remarks: "使用此方法重载来指定属性，除非在已应用创建的动态程序集时，可能无法正常工作。 例如，安全特性例如<xref:System.Security.SecurityTransparentAttribute>和<xref:System.Security.SecurityCriticalAttribute>如果它们未添加创建的动态程序集后，可能无法正常工作。</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       应使用此方法只能用于当前的应用程序域中定义的动态程序集。 有关此限制的详细信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>       此方法重载在中引入[!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)]。"
  example:
  - "The following code sample shows how to create a dynamic assembly that has the <xref:System.Security.SecurityTransparentAttribute>. The attribute must be specified as an element of an array of <xref:System.Reflection.Emit.CustomAttributeBuilder> objects.  \n  \n The first step in creating the <xref:System.Reflection.Emit.CustomAttributeBuilder> is to obtain a constructor for the attribute. The constructor has no parameters, so the <xref:System.Type.GetConstructor%2A> method is called with an empty array of <xref:System.Type> objects to represent the types of the parameters. The second step is to pass the resulting <xref:System.Reflection.ConstructorInfo> object to the constructor for the <xref:System.Reflection.Emit.CustomAttributeBuilder> class, together with an empty array of type <xref:System.Object> to represent the arguments.  \n  \n The resulting <xref:System.Reflection.Emit.CustomAttributeBuilder> is then passed to the DefineDynamicAssembly method as the only element of an array.  \n  \n The example code defines a module and a type in the new dynamic assembly, and then displays the assembly's attributes.  \n  \n [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/add/codesnippet/cpp/02b9ff71-a699-4692-a2ae-_1.cpp)]\n [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/add/codesnippet/visualbasic/02b9ff71-a699-4692-a2ae-_1.vb)]\n [!code-cs[DefineDynamicAssemblyWithAttributes#1](~/add/codesnippet/csharp/02b9ff71-a699-4692-a2ae-_1.cs)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "动态程序集的唯一标识。"
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "动态程序集的访问模式。"
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "要应用于程序集的特性的可枚举列表或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>是否存在任何属性。"
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "具有指定的名称和功能的动态程序集。"
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref>属性<code> name </code>开头为空格，或包含向前或向后的斜杠。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "定义动态程序集使用指定的名称、 访问模式和证据。"
  remarks: "仅完全受信任的调用方可以提供其`evidence`定义动态<xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly>时 运行时将映射<xref:System.Security.Policy.Evidence>通过安全策略以确定授予的权限。</xref:System.Security.Policy.Evidence> 部分受信任的调用方必须提供一个为 null 的`evidence`。 如果`evidence`是`null`、 运行时将复制的权限集，也就是说，当前授予和拒绝集，从调用方的<xref:System.Reflection.Assembly>为动态<xref:System.Reflection.Assembly>正在定义并将策略标记为已解决。</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       如果动态<xref:System.Reflection.Assembly>是保存到磁盘，后面的加载将获得授予基于与位置关联的策略其中<xref:System.Reflection.Assembly>已保存。</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       此方法仅应使用当前的应用程序域中定义的动态程序集。 有关详细信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      1> [!NOTE]&1;> 在开发期间用于发出动态程序集的代码，建议你使用的重载<xref:System.AppDomain.DefineDynamicAssembly%2A>方法，它指定证据和权限，提供你想要具有，并且包含的动态程序集的证据<xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>中`refusedPermissions`。</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> 包括<xref:System.Security.Permissions.SecurityPermissionFlag>中`refusedPermissions`参数可确保验证 MSIL。</xref:System.Security.Permissions.SecurityPermissionFlag> 此技术的局限性是它还使<xref:System.Security.SecurityException>要求完全信任的代码一起使用时引发。</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and the <xref:System.AppDomain.AssemblyResolve> event.  \n  \n First, the code example tries to create an instance of `MyDynamicType` by calling the <xref:System.AppDomain.CreateInstance%2A> method with an invalid assembly name, and catches the resulting exception.  \n  \n The code example then adds an event handler for the <xref:System.AppDomain.AssemblyResolve> event, and again tries to create an instance of`MyDynamicType`. During the call to <xref:System.AppDomain.CreateInstance%2A>, the <xref:System.AppDomain.AssemblyResolve> event is raised for the invalid assembly. The event handler creates a dynamic assembly that contains a type named `MyDynamicType`, gives the type a parameterless constructor, and returns the new dynamic assembly. The call to <xref:System.AppDomain.CreateInstance%2A> then finishes successfully, and the constructor for `MyDynamicType` displays a message at the console.  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/1d1d705b-aac9-4233-8756-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/1d1d705b-aac9-4233-8756-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/1d1d705b-aac9-4233-8756-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "动态程序集的唯一标识。"
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "将在其中访问动态程序集的模式。"
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "为动态程序集提供的证据。 使用证据始终作为最后一组用于策略解析的证据。"
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "具有指定的名称和功能的动态程序集。"
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref>属性<code> name </code>开头空格，或包含向前或向后的斜杠。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "定义动态程序集使用指定的名称、 访问模式和存储目录。"
  remarks: "此方法仅应使用当前的应用程序域中定义的动态程序集。 有关详细信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      1> [!NOTE]&1;> 在开发期间用于发出动态程序集的代码，建议你使用的重载<xref:System.AppDomain.DefineDynamicAssembly%2A>方法，它指定证据和权限，提供你想要具有，并且包含的动态程序集的证据<xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>中`refusedPermissions`。</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> 包括<xref:System.Security.Permissions.SecurityPermissionFlag>中`refusedPermissions`参数可确保验证 MSIL。</xref:System.Security.Permissions.SecurityPermissionFlag> 此技术的局限性是它还使<xref:System.Security.SecurityException>要求完全信任的代码一起使用时引发。</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/f3a30d18-28ff-4503-b1c6-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/f3a30d18-28ff-4503-b1c6-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/f3a30d18-28ff-4503-b1c6-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "动态程序集的唯一标识。"
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "将在其中访问动态程序集的模式。"
    - id: dir
      type: System.String
      description: "保存程序集的目录的名称。 如果`dir`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，目录将默认为当前目录。"
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "具有指定的名称和功能的动态程序集。"
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref>属性<code> name </code>开头空格，或包含向前或向后的斜杠。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "定义具有指定的名称、 访问模式和自定义特性的动态程序集并指定的源用于它的安全上下文。"
  remarks: "使用此方法重载来指定属性，除非在已应用创建的动态程序集时，可能无法正常工作。 例如，安全特性例如<xref:System.Security.SecurityTransparentAttribute>和<xref:System.Security.SecurityCriticalAttribute>如果它们未添加创建的动态程序集后，可能无法正常工作。</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       应使用此方法只能用于当前的应用程序域中定义的动态程序集。 有关此限制的详细信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes, System.Security.SecurityContextSource securityContextSource);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "动态程序集的唯一标识。"
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "动态程序集的访问模式。"
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "要应用于程序集的特性的可枚举列表或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>是否存在任何属性。"
    - id: securityContextSource
      type: System.Security.SecurityContextSource
      description: "安全上下文的源。"
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "具有指定的名称和功能的动态程序集。"
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref>属性<code> name </code>开头为空格，或包含向前或向后的斜杠。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "值<code> securityContextSource </code>不是枚举值之一。"
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "定义动态程序集使用指定的名称、 访问模式、 存储目录和证据。"
  remarks: "仅完全受信任的调用方可以提供其`evidence`定义动态<xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly>时 运行时将映射<xref:System.Security.Policy.Evidence>通过安全策略以确定授予的权限。</xref:System.Security.Policy.Evidence> 部分受信任的调用方必须提供一个为 null 的`evidence`。 如果`evidence`是`null`、 运行时将复制的权限集，也就是说，当前授予和拒绝集，从调用方的<xref:System.Reflection.Assembly>为动态<xref:System.Reflection.Assembly>正在定义并将策略标记为已解决。</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       如果动态<xref:System.Reflection.Assembly>是保存到磁盘，后面的加载将获得授予基于与位置关联的策略其中<xref:System.Reflection.Assembly>已保存。</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       此方法仅应使用当前的应用程序域中定义的动态程序集。 有关详细信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      1> [!NOTE]&1;> 在开发期间用于发出动态程序集的代码，建议你使用的重载<xref:System.AppDomain.DefineDynamicAssembly%2A>方法，它指定证据和权限，提供你想要具有，并且包含的动态程序集的证据<xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>中`refusedPermissions`。</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> 包括<xref:System.Security.Permissions.SecurityPermissionFlag>中`refusedPermissions`参数可确保验证 MSIL。</xref:System.Security.Permissions.SecurityPermissionFlag> 此技术的局限性是它还使<xref:System.Security.SecurityException>要求完全信任的代码一起使用时引发。</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/2cf98986-7843-48cf-a73f-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/2cf98986-7843-48cf-a73f-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/2cf98986-7843-48cf-a73f-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "动态程序集的唯一标识。"
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "将在其中访问动态程序集的模式。"
    - id: dir
      type: System.String
      description: "保存程序集的目录的名称。 如果`dir`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，目录将默认为当前目录。"
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "为动态程序集提供的证据。 使用证据始终作为最后一组用于策略解析的证据。"
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "具有指定的名称和功能的动态程序集。"
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref>属性<code> name </code>开头空格，或包含向前或向后的斜杠。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "定义动态程序集使用指定的名称、 访问模式和权限请求。"
  remarks: "为指定的权限请求`requiredPermissions`， `optionalPermissions`，和`refusedPermissions`不使用除非保存动态程序集并将其重新加载到内存。 若要指定从不会保存到磁盘中，使用的重载的瞬态程序集的权限请求<xref:System.AppDomain.DefineDynamicAssembly%2A>方法，它指定证据和所请求的权限，并提供<xref:System.Security.Policy.Evidence>对象。</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.DefineDynamicAssembly%2A>      1> [!NOTE]&1;> 在开发期间用于发出动态程序集的代码，建议你使用的重载<xref:System.AppDomain.DefineDynamicAssembly%2A>方法，它指定证据和权限，提供你想要具有，并且包含的动态程序集的证据<xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>中`refusedPermissions`。</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> 包括<xref:System.Security.Permissions.SecurityPermissionFlag>中`refusedPermissions`参数可确保验证 MSIL。</xref:System.Security.Permissions.SecurityPermissionFlag> 此技术的局限性是它还使<xref:System.Security.SecurityException>要求完全信任的代码一起使用时引发。</xref:System.Security.SecurityException>       此方法仅应使用当前的应用程序域中定义的动态程序集。 有关详细信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/be48f0dd-e58f-4a8c-bdad-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/be48f0dd-e58f-4a8c-bdad-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/be48f0dd-e58f-4a8c-bdad-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "动态程序集的唯一标识。"
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "将在其中访问动态程序集的模式。"
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "必需的权限请求。"
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "可选的权限请求。"
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "请求被拒绝的权限。"
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "具有指定的名称和功能的动态程序集。"
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref>属性<code> name </code>开头空格，或包含向前或向后的斜杠。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "定义动态程序集使用指定的名称、 访问模式、 存储目录和同步选项。"
  remarks: "使用此方法重载来指定属性，除非在已应用创建的动态程序集时，可能无法正常工作。 例如，安全特性例如<xref:System.Security.SecurityTransparentAttribute>和<xref:System.Security.SecurityCriticalAttribute>如果它们未添加创建的动态程序集后，可能无法正常工作。</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       如果`isSynchronized`是`true`，生成的以下方法<xref:System.Reflection.Emit.AssemblyBuilder>将同步︰ <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>，和<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>。</xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> </xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> </xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder> 如果其中两种方法在不同的线程调用的一个将其他完成之前一直阻止。"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "动态程序集的唯一标识。"
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "将在其中访问动态程序集的模式。"
    - id: dir
      type: System.String
      description: "保存动态程序集的目录的名称。 如果`dir`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，则使用当前目录。"
    - id: isSynchronized
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要同步的模块、 类型和成员在动态程序集，则创建否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "要应用于程序集的特性的可枚举列表或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>是否存在任何属性。"
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "具有指定的名称和功能的动态程序集。"
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref>属性<code> name </code>开头为空格，或包含向前或向后的斜杠。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "定义动态程序集使用指定的名称、 访问模式、 证据和权限请求。"
  remarks: "为指定的权限请求`requiredPermissions`， `optionalPermissions`，和`refusedPermissions`才会使用`evidence`还提供，或如果动态程序集保存并重新加载到内存。      1> [!NOTE]&1;> 在开发期间用于发出动态程序集的代码，建议你在包含<xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>中`refusedPermissions`。</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> 包括<xref:System.Security.Permissions.SecurityPermissionFlag>中`refusedPermissions`参数可确保验证 MSIL。</xref:System.Security.Permissions.SecurityPermissionFlag> 此技术的局限性是它还使<xref:System.Security.SecurityException>要求完全信任的代码一起使用时引发。</xref:System.Security.SecurityException>       仅完全受信任的调用方可以提供其`evidence`定义动态<xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly>时 运行时将映射<xref:System.Security.Policy.Evidence>通过安全策略以确定授予的权限。</xref:System.Security.Policy.Evidence> 部分受信任的调用方必须提供一个为 null 的`evidence`。 如果`evidence`是`null`、 运行时将复制的权限集，也就是说，当前授予和拒绝集，从调用方的<xref:System.Reflection.Assembly>为动态<xref:System.Reflection.Assembly>正在定义并将策略标记为已解决。</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       如果动态<xref:System.Reflection.Assembly>是保存到磁盘，后面的加载将获得授予基于与位置关联的策略其中<xref:System.Reflection.Assembly>已保存。</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       此方法仅应使用当前的应用程序域中定义的动态程序集。 有关详细信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/7d7c7162-9e00-4b91-93d0-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/7d7c7162-9e00-4b91-93d0-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/7d7c7162-9e00-4b91-93d0-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "动态程序集的唯一标识。"
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "将在其中访问动态程序集的模式。"
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "为动态程序集提供的证据。 使用证据始终作为最后一组用于策略解析的证据。"
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "必需的权限请求。"
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "可选的权限请求。"
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "请求被拒绝的权限。"
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "具有指定的名称和功能的动态程序集。"
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref>属性<code> name </code>开头空格，或包含向前或向后的斜杠。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "定义动态程序集使用指定的名称、 访问模式、 存储目录和权限请求。"
  remarks: "为指定的权限请求`requiredPermissions`， `optionalPermissions`，和`refusedPermissions`不使用除非保存动态程序集并将其重新加载到内存。 若要指定从不会保存到磁盘中，使用的重载的瞬态程序集的权限请求<xref:System.AppDomain.DefineDynamicAssembly%2A>方法，它指定证据和所请求的权限，并提供<xref:System.Security.Policy.Evidence>对象。</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.DefineDynamicAssembly%2A>      1> [!NOTE]&1;> 在开发期间用于发出动态程序集的代码，建议你使用的重载<xref:System.AppDomain.DefineDynamicAssembly%2A>方法，它指定证据和权限，提供你想要具有，并且包含的动态程序集的证据<xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>中`refusedPermissions`。</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> 包括<xref:System.Security.Permissions.SecurityPermissionFlag>中`refusedPermissions`参数可确保验证 MSIL。</xref:System.Security.Permissions.SecurityPermissionFlag> 此技术的局限性是它还使<xref:System.Security.SecurityException>要求完全信任的代码一起使用时引发。</xref:System.Security.SecurityException>       此方法仅应使用当前的应用程序域中定义的动态程序集。 有关详细信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/0fc3676e-96ff-42c6-ad25-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/0fc3676e-96ff-42c6-ad25-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/0fc3676e-96ff-42c6-ad25-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "动态程序集的唯一标识。"
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "将在其中访问动态程序集的模式。"
    - id: dir
      type: System.String
      description: "保存程序集的目录的名称。 如果`dir`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，目录将默认为当前目录。"
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "必需的权限请求。"
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "可选的权限请求。"
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "请求被拒绝的权限。"
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "具有指定的名称和功能的动态程序集。"
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref>属性<code> name </code>开头空格，或包含向前或向后的斜杠。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "定义动态程序集使用指定的名称、 访问模式、 存储目录、 证据和权限请求。"
  remarks: "为指定的权限请求`requiredPermissions`， `optionalPermissions`，和`refusedPermissions`才会使用`evidence`还提供，或如果动态程序集保存并重新加载到内存。      1> [!NOTE]&1;> 在开发期间用于发出动态程序集的代码，建议你在包含<xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>中`refusedPermissions`。</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> 包括<xref:System.Security.Permissions.SecurityPermissionFlag>中`refusedPermissions`参数可确保验证 MSIL。</xref:System.Security.Permissions.SecurityPermissionFlag> 此技术的局限性是它还使<xref:System.Security.SecurityException>要求完全信任的代码一起使用时引发。</xref:System.Security.SecurityException>       仅完全受信任的调用方可以提供其`evidence`定义动态<xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly>时 运行时将映射<xref:System.Security.Policy.Evidence>通过安全策略以确定授予的权限。</xref:System.Security.Policy.Evidence> 部分受信任的调用方必须提供一个为 null 的`evidence`。 如果`evidence`是`null`、 运行时将复制的权限集，也就是说，当前授予和拒绝集，从调用方的<xref:System.Reflection.Assembly>为动态<xref:System.Reflection.Assembly>正在定义并将策略标记为已解决。</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       如果动态<xref:System.Reflection.Assembly>是保存到磁盘，后面的加载将获得授予基于与位置关联的策略其中<xref:System.Reflection.Assembly>已保存。</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       此方法仅应使用当前的应用程序域中定义的动态程序集。 有关详细信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/0baa3466-02cf-4d9c-bb66-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/0baa3466-02cf-4d9c-bb66-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/0baa3466-02cf-4d9c-bb66-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "动态程序集的唯一标识。"
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "将在其中访问动态程序集的模式。"
    - id: dir
      type: System.String
      description: "保存程序集的目录的名称。 如果`dir`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，目录将默认为当前目录。"
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "为动态程序集提供的证据。 使用证据始终作为最后一组用于策略解析的证据。"
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "必需的权限请求。"
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "可选的权限请求。"
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "请求被拒绝的权限。"
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "具有指定的名称和功能的动态程序集。"
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref>属性<code> name </code>开头空格，或包含向前或向后的斜杠。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "定义动态程序集使用指定的名称、 访问模式、 存储目录、 证据、 权限请求和同步选项。"
  remarks: "为指定的权限请求`requiredPermissions`， `optionalPermissions`，和`refusedPermissions`才会使用`evidence`还提供，或如果动态程序集保存并重新加载到内存。      1> [!NOTE]&1;> 在开发期间用于发出动态程序集的代码，建议你在包含<xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>中`refusedPermissions`。</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> 包括<xref:System.Security.Permissions.SecurityPermissionFlag>中`refusedPermissions`参数可确保验证 MSIL。</xref:System.Security.Permissions.SecurityPermissionFlag> 此技术的局限性是它还使<xref:System.Security.SecurityException>要求完全信任的代码一起使用时引发。</xref:System.Security.SecurityException>       只有完全受信任的调用可以提供其证据定义动态<xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly>时 运行时将映射<xref:System.Security.Policy.Evidence>通过安全策略以确定授予的权限。</xref:System.Security.Policy.Evidence> 部分受信任的调用方必须提供`null`为`evidence`参数。 如果`evidence`是`null`、 运行时将复制的权限集，也就是说，当前授予和拒绝集，从调用方的<xref:System.Reflection.Assembly>为动态<xref:System.Reflection.Assembly>正在定义并将策略标记为已解决。</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       如果动态<xref:System.Reflection.Assembly>是保存到磁盘，后面的加载将获得授予基于与位置关联的策略其中<xref:System.Reflection.Assembly>已保存。</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       如果`isSynchronized`是`true`，生成的以下方法<xref:System.Reflection.Emit.AssemblyBuilder>将同步︰ <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>，和<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>。</xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> </xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> </xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder> 如果其中两种方法在不同的线程调用的一个将其他完成之前一直阻止。"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/84dd3b17-5601-467b-b1e3-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/84dd3b17-5601-467b-b1e3-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/84dd3b17-5601-467b-b1e3-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "动态程序集的唯一标识。"
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "将在其中访问动态程序集的模式。"
    - id: dir
      type: System.String
      description: "保存动态程序集的目录的名称。 如果`dir`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，目录将默认为当前目录。"
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "为动态程序集提供的证据。 使用证据始终作为最后一组用于策略解析的证据。"
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "必需的权限请求。"
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "可选的权限请求。"
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "请求被拒绝的权限。"
    - id: isSynchronized
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要同步的模块、 类型和成员在动态程序集，则创建否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "具有指定的名称和功能的动态程序集。"
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref>属性<code> name </code>开头空格，或包含向前或向后的斜杠。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "定义具有指定的名称、 访问模式、 存储目录、 证据、 权限请求、 同步选项和自定义特性的动态程序集。"
  remarks: "使用此方法重载来指定属性，除非在已应用创建的动态程序集时，可能无法正常工作。 例如，安全特性例如<xref:System.Security.SecurityTransparentAttribute>和<xref:System.Security.SecurityCriticalAttribute>如果它们未添加创建的动态程序集后，可能无法正常工作。</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       为指定的权限请求`requiredPermissions`， `optionalPermissions`，和`refusedPermissions`参数才会使用`evidence`还提供参数，或如果动态程序集保存并重新加载到内存。      1> [!NOTE]&1;> 开发时发出动态程序集的代码，我们建议您包括<xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>中标记出来`refusedPermissions`参数。</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> 此标志包含可确保的 Microsoft 中间语言 (MSIL) 将进行验证。 此方法会检测无意间生成无法验证的代码，否则为它是很难检测到了。 此技术的局限性是它还使<xref:System.Security.SecurityException>当它用于要求完全信任的代码时引发。</xref:System.Security.SecurityException>       只有完全受信任的调用可以提供证据定义动态<xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly>时 运行时将映射<xref:System.Security.Policy.Evidence>通过安全策略以确定授予的权限。</xref:System.Security.Policy.Evidence> 部分受信任的调用方必须提供`null`为`evidence`参数。 如果`evidence`是`null`，运行时将从调用方的程序集的权限集 （即，当前授予和拒绝集） 复制到正在定义中，并将策略标记为已解决的动态程序集。       如果将动态程序集保存到磁盘，后续加载将获得授予基于保存动态程序集的位置与关联的策略。       如果`isSynchronized`是`true`，生成的以下方法<xref:System.Reflection.Emit.AssemblyBuilder>将同步︰ <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>，和<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>。</xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> </xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> </xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder> 如果其中两种方法在不同的线程调用的一个将其他完成之前一直阻止。       此方法重载在中引入[!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)]。"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "动态程序集的唯一标识。"
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "将在其中访问动态程序集的模式。"
    - id: dir
      type: System.String
      description: "保存动态程序集的目录的名称。 如果`dir`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，则使用当前目录。"
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "为动态程序集提供的证据。 使用证据始终作为最后一组用于策略解析的证据。"
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "必需的权限请求。"
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "可选的权限请求。"
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "请求被拒绝的权限。"
    - id: isSynchronized
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要同步的模块、 类型和成员在动态程序集，则创建否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "要应用于程序集的特性的可枚举列表或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>是否存在任何属性。"
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "具有指定的名称和功能的动态程序集。"
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref>属性<code> name </code>开头为空格，或包含向前或向后的斜杠。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)
  id: DoCallBack(System.CrossAppDomainDelegate)
  parent: System.AppDomain
  langs:
  - csharp
  name: DoCallBack(CrossAppDomainDelegate)
  nameWithType: AppDomain.DoCallBack(CrossAppDomainDelegate)
  fullName: System.AppDomain.DoCallBack(CrossAppDomainDelegate)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "在由指定的委托标识的另一个应用程序域中执行代码。"
  remarks: '`callBackDelegate`可以指定封送按值， <xref:System.MarshalByRefObject>，或<xref:System.ContextBoundObject>。</xref:System.ContextBoundObject> </xref:System.MarshalByRefObject>'
  example:
  - "The following sample demonstrates using a static DoCallBack method.  \n  \n [!code-vb[AppDomain_DoCallBack#1](~/add/codesnippet/visualbasic/m-system.appdomain.docal_1.vb)]\n [!code-cpp[AppDomain_DoCallBack#1](~/add/codesnippet/cpp/m-system.appdomain.docal_1.cpp)]\n [!code-cs[AppDomain_DoCallBack#1](~/add/codesnippet/csharp/m-system.appdomain.docal_1.cs)]  \n  \n The following sample demonstrates using the DoCallBack method by value.  \n  \n [!code-vb[AppDomain_DoCallBack#2](~/add/codesnippet/visualbasic/m-system.appdomain.docal_2.vb)]\n [!code-cs[AppDomain_DoCallBack#2](~/add/codesnippet/csharp/m-system.appdomain.docal_2.cs)]\n [!code-cpp[AppDomain_DoCallBack#2](~/add/codesnippet/cpp/m-system.appdomain.docal_2.cpp)]  \n  \n The following sample demonstrates using the DoCallBack method by reference.  \n  \n [!code-cpp[AppDomain_DoCallBack#3](~/add/codesnippet/cpp/m-system.appdomain.docal_3.cpp)]\n [!code-cs[AppDomain_DoCallBack#3](~/add/codesnippet/csharp/m-system.appdomain.docal_3.cs)]\n [!code-vb[AppDomain_DoCallBack#3](~/add/codesnippet/visualbasic/m-system.appdomain.docal_3.vb)]"
  syntax:
    content: public void DoCallBack (CrossAppDomainDelegate callBackDelegate);
    parameters:
    - id: callBackDelegate
      type: System.CrossAppDomainDelegate
      description: "指定要调用的方法的委托。"
  overload: System.AppDomain.DoCallBack*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBackDelegate</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.DomainManager
  id: DomainManager
  parent: System.AppDomain
  langs:
  - csharp
  name: DomainManager
  nameWithType: AppDomain.DomainManager
  fullName: System.AppDomain.DomainManager
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获得初始化应用程序域时主机提供的域管理器。"
  remarks: "公共语言运行时 (CLR) 的非托管的主机可以提供域管理器。 域管理器可以参与初始化新的应用程序域，并提供其他管理器，如<xref:System.Security.HostSecurityManager>，该元素参与应用程序域的操作。</xref:System.Security.HostSecurityManager>"
  syntax:
    content: public AppDomainManager DomainManager { get; }
    return:
      type: System.AppDomainManager
      description: "一个对象，表示初始化应用程序域时, 主机提供的域管理器或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果没有域管理器提供。"
  overload: System.AppDomain.DomainManager*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.DomainUnload
  id: DomainUnload
  parent: System.AppDomain
  langs:
  - csharp
  name: DomainUnload
  nameWithType: AppDomain.DomainUnload
  fullName: System.AppDomain.DomainUnload
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "发生时<xref href=&quot;System.AppDomain&quot;></xref>将被卸载。"
  remarks: "<xref:System.EventHandler>委托中卸载应用程序域之前，此事件可以执行任何终止活动。</xref:System.EventHandler>       需要用来执行处理卸载时每个应用程序域应该注册的事件处理程序此事件。 共享的事件处理程序不应使用，因为<xref:System.EventHandler>委托不会确定正在卸载的域。</xref:System.EventHandler>      1> [!NOTE]&1;> 默认应用程序域中永远不会引发此事件。       不进行有关线程引发该事件的假设。 可以在与调用的一个不同的线程上引发该事件<xref:System.AppDomain.Unload%2A>方法。</xref:System.AppDomain.Unload%2A>       有关处理事件的详细信息，请参阅[事件](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public event EventHandler DomainUnload;
    return:
      type: System.EventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.DynamicDirectory
  id: DynamicDirectory
  parent: System.AppDomain
  langs:
  - csharp
  name: DynamicDirectory
  nameWithType: AppDomain.DynamicDirectory
  fullName: System.AppDomain.DynamicDirectory
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取此程序集冲突解决程序用来探测动态创建的程序集的目录。"
  remarks: "若要设置的动态目录，分配的基目录路径<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName>属性<xref:System.AppDomainSetup>将用于创建新的应用程序域的对象。</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> 分配给属性的基目录路径修改通过其简单的名称是你将分配给字符串的哈希代码的子目录添加<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>属性，因此基目录的格式是*原始路径*\\\\*哈希代码*。</xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName> 动态目录是此基目录的子目录。 其简单的名称为的值<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>属性，因此其格式是*原始路径*\\\\*哈希代码*\\\\*应用程序名称*。</xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>"
  example:
  - "The following example creates an application domain with a directory for dynamic assemblies, emits a dynamic assembly and stores it in the dynamic directory, and then loads the assembly into the new application domain and uses it.  \n  \n The example creates an <xref:System.AppDomainSetup> object and sets its <xref:System.AppDomainSetup.ApplicationName%2A> property to \"Example\" and its <xref:System.AppDomainSetup.DynamicBase%2A> property to \"C:\\DynamicAssemblyDir\". The example then displays the <xref:System.AppDomainSetup.DynamicBase%2A> property, to show that the hash code of the application name has been appended as a subdirectory of the path that was originally assigned.  \n  \n> [!NOTE]\n>  The base directory in this example is intended to be outside the probing path for the example application. Be sure to compile the example in a different location. Delete the base directory and all its subdirectories each time you run the example.  \n  \n The example creates a new application domain, using the <xref:System.AppDomainSetup> object. The example uses the DynamicDirectory property to retrieve the name of the directory, so it can create the directory. (The example could just as easily create the directory beforehand by concatenating the original path, the hash code of the application name, and the application name.)  \n  \n The example has a `GenerateDynamicAssembly` method that emits an assembly named `DynamicHelloWorld.dll` and stores it in the new application domain's dynamic directory. The dynamic assembly contains one type, `HelloWorld`, that has a static method (`Shared` method in Visual Basic) named `HelloFromAD`. Calling this method displays the name of the application domain.  \n  \n The `Example` class derives from <xref:System.MarshalByRefObject>, so the example can create an instance of the class in the new application domain and call its `Test` method. The `Test` method loads the dynamic assembly by its display name and calls the static `HelloFromAD` method.  \n  \n You can show that the dynamic directory is searched after the normal probing paths by writing code for an assembly named `DynamicHelloWorld.dll` and compiling it in the same directory as this example. The assembly must have a class named `HelloWorld` with a static method named `HelloFromAD`. This method does not have to have the same functionality as the one in the example; it can simply display a string to the console. The assembly must also have an <xref:System.Reflection.AssemblyVersionAttribute> attribute that sets its version to 1.0.0.0. When you run the example, the assembly you compiled in the current directory is found before the dynamic directory is searched.  \n  \n [!code-cpp[ADDynamicBase#1](~/add/codesnippet/cpp/p-system.appdomain.dynam_1.cpp)]\n [!code-cs[ADDynamicBase#1](~/add/codesnippet/csharp/p-system.appdomain.dynam_1.cs)]\n [!code-vb[ADDynamicBase#1](~/add/codesnippet/visualbasic/p-system.appdomain.dynam_1.vb)]"
  syntax:
    content: public string DynamicDirectory { get; }
    return:
      type: System.String
      description: "目录，它由程序集冲突解决程序用来探测动态创建的程序集。"
  overload: System.AppDomain.DynamicDirectory*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.Evidence
  id: Evidence
  parent: System.AppDomain
  langs:
  - csharp
  name: Evidence
  nameWithType: AppDomain.Evidence
  fullName: System.AppDomain.Evidence
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取<xref href=&quot;System.Security.Policy.Evidence&quot;></xref>与该应用程序域关联。"
  syntax:
    content: public System.Security.Policy.Evidence Evidence { get; }
    return:
      type: System.Security.Policy.Evidence
      description: "与此应用程序域关联的证据。"
  overload: System.AppDomain.Evidence*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String)
  id: ExecuteAssembly(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String)
  nameWithType: AppDomain.ExecuteAssembly(String)
  fullName: System.AppDomain.ExecuteAssembly(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "执行指定文件中包含的程序集。"
  remarks: "程序集开始在.NET Framework 标头中指定的入口点执行。       此方法不会创建新的进程或应用程序域，并且不会在新线程上执行入口点方法。       此方法加载程序集使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。</xref:System.Reflection.Assembly.LoadFile%2A> 你还可以执行程序集使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，后者将加载程序集使用<xref:System.Reflection.Assembly.Load%2A>方法。</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       若要创建<xref:System.AppDomain>加载并执行，请使用<xref:System.AppDomain.CreateDomain%2A>方法。</xref:System.AppDomain.CreateDomain%2A> </xref:System.AppDomain>"
  example:
  - "The following sample demonstrates using one of the overloads of ExecuteAssembly on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/m-system.appdomain.execu_0_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/m-system.appdomain.execu_0_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/m-system.appdomain.execu_0_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "包含要执行的程序集的文件的名称。"
    return:
      type: System.Int32
      description: "程序集的入口点返回的值。"
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>未找到。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>不是有效的程序集。       -或-当前加载版本 2.0 或更高版本的公共语言运行时和<code>assemblyFile</code>用更高版本编译。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "指定程序集具有不到入口点。"
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  id: ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,Evidence)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "执行程序集包含在指定的文件中，使用指定的证据。"
  remarks: "程序集开始在.NET Framework 标头中指定的入口点执行。       <xref:System.AppDomain.ExecuteAssembly%2A>方法不会创建新的进程或应用程序域，并且不会在新线程上执行入口点方法。</xref:System.AppDomain.ExecuteAssembly%2A>       此方法加载程序集使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。</xref:System.Reflection.Assembly.LoadFile%2A> 你还可以执行程序集使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，后者将加载程序集使用<xref:System.Reflection.Assembly.Load%2A>方法。</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/8a3b95e3-eb51-4f5b-bb93-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/8a3b95e3-eb51-4f5b-bb93-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/8a3b95e3-eb51-4f5b-bb93-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "包含要执行的程序集的文件的名称。"
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "用于加载程序集的证据。"
    return:
      type: System.Int32
      description: "程序集的入口点返回的值。"
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>未找到。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>不是有效的程序集。       -或-当前加载版本 2.0 或更高版本的公共语言运行时和<code>assemblyFile</code>用更高版本编译。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "指定程序集具有不到入口点。"
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[])
  id: ExecuteAssembly(System.String,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "执行使用指定的参数指定的文件中包含的程序集。"
  remarks: "程序集开始在.NET Framework 标头中指定的入口点执行。       此方法不会创建新的进程或应用程序域，并且不会在新线程上执行入口点方法。       此方法加载程序集使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。</xref:System.Reflection.Assembly.LoadFile%2A> 你还可以执行程序集使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，后者将加载程序集使用<xref:System.Reflection.Assembly.Load%2A>方法。</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/m-system.appdomain.execu_1_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/m-system.appdomain.execu_1_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/m-system.appdomain.execu_1_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, string[] args);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "包含要执行的程序集的文件的名称。"
    - id: args
      type: System.String[]
      description: "程序集的入口点参数。"
    return:
      type: System.Int32
      description: "程序集的入口点返回的值。"
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>未找到。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>不是有效的程序集。       -或-<code>assemblyFile</code>用比当前加载的版本更高版本的公共语言运行时编译。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "指定程序集具有不到入口点。"
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  id: ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "执行使用指定的证据和自变量指定的文件中包含的程序集。"
  remarks: "程序集开始在.NET Framework 标头中指定的入口点执行。       此方法不会创建新的进程或应用程序域，并且不会在新线程上执行入口点方法。       此方法加载程序集使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。</xref:System.Reflection.Assembly.LoadFile%2A> 你还可以执行程序集使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，后者将加载程序集使用<xref:System.Reflection.Assembly.Load%2A>方法。</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/cb15b913-548c-4cb1-bbc5-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/cb15b913-548c-4cb1-bbc5-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/cb15b913-548c-4cb1-bbc5-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "包含要执行的程序集的文件的名称。"
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "程序集提供的证据。"
    - id: args
      type: System.String[]
      description: "程序集的入口点参数。"
    return:
      type: System.Int32
      description: "程序集的入口点返回的值。"
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>未找到。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>不是有效的程序集。       -或-当前加载版本 2.0 或更高版本的公共语言运行时和<code>assemblyFile</code>用更高版本编译。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. 当未启用旧版 CAS 策略时，<code>assemblySecurity</code>应<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "指定程序集具有不到入口点。"
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  id: ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "执行使用指定的参数、 哈希值和哈希算法指定的文件中包含的程序集。"
  remarks: "程序集开始在.NET Framework 标头中指定的入口点执行。       此方法不会创建新的进程或应用程序域，并且不会在新线程上执行入口点方法。       此方法加载程序集使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。</xref:System.Reflection.Assembly.LoadFile%2A> 你还可以执行程序集使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，后者将加载程序集使用<xref:System.Reflection.Assembly.Load%2A>方法。</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/ccb3b356-1169-4d65-9fdd-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/ccb3b356-1169-4d65-9fdd-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/ccb3b356-1169-4d65-9fdd-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "包含要执行的程序集的文件的名称。"
    - id: args
      type: System.String[]
      description: "程序集的入口点参数。"
    - id: hashValue
      type: System.Byte[]
      description: "表示计算所得的哈希代码的值。"
    - id: hashAlgorithm
      type: System.Configuration.Assemblies.AssemblyHashAlgorithm
      description: "表示程序集清单使用的哈希算法。"
    return:
      type: System.Int32
      description: "程序集的入口点返回的值。"
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>未找到。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>不是有效的程序集。       -或-<code>assemblyFile</code>用比当前加载的版本更高版本的公共语言运行时编译。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "指定程序集具有不到入口点。"
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  id: ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "执行使用指定的证据、 参数、 哈希值和哈希算法指定的文件中包含的程序集。"
  remarks: "程序集开始在.NET Framework 标头中指定的入口点执行。       此方法不会创建新的进程或应用程序域，并且不会在新线程上执行入口点方法。       此方法加载程序集使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。</xref:System.Reflection.Assembly.LoadFile%2A> 你还可以执行程序集使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，后者将加载程序集使用<xref:System.Reflection.Assembly.Load%2A>方法。</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "Thefollowing sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/c176353b-cef5-4b78-b4a8-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/c176353b-cef5-4b78-b4a8-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/c176353b-cef5-4b78-b4a8-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "包含要执行的程序集的文件的名称。"
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "程序集提供的证据。"
    - id: args
      type: System.String[]
      description: "程序集的入口点参数。"
    - id: hashValue
      type: System.Byte[]
      description: "表示计算所得的哈希代码的值。"
    - id: hashAlgorithm
      type: System.Configuration.Assemblies.AssemblyHashAlgorithm
      description: "表示程序集清单使用的哈希算法。"
    return:
      type: System.Int32
      description: "程序集的入口点返回的值。"
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>未找到。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>不是有效的程序集。       -或-当前加载版本 2.0 或更高版本的公共语言运行时和<code>assemblyFile</code>用更高版本编译。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. 当未启用旧版 CAS 策略时，<code>assemblySecurity</code>应<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "指定程序集具有不到入口点。"
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String)
  id: ExecuteAssemblyByName(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String)
  nameWithType: AppDomain.ExecuteAssemblyByName(String)
  fullName: System.AppDomain.ExecuteAssemblyByName(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "执行在给定其显示名称的程序集。"
  remarks: "<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法提供与类似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但按显示名称指定的程序集或<xref:System.Reflection.AssemblyName>而不是文件位置。</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>加载程序集与<xref:System.Reflection.Assembly.Load%2A>方法而不是与<xref:System.Reflection.Assembly.LoadFile%2A>方法。</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       程序集开始在.NET Framework 标头中指定的入口点执行。       此方法不会创建新的进程或应用程序域，并且不会在新线程上执行入口点方法。       若要创建<xref:System.AppDomain>加载并执行，请使用<xref:System.AppDomain.CreateDomain%2A>方法。</xref:System.AppDomain.CreateDomain%2A> </xref:System.AppDomain>"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "程序集的显示名称。 请参阅&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;。"
    return:
      type: System.Int32
      description: "程序集的入口点返回的值。"
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "通过指定的程序集<code> assemblyName </code>找不到。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "通过指定的程序集<code> assemblyName </code>不是有效的程序集。       -或-当前加载版本 2.0 或更高版本的公共语言运行时和<code> assemblyName </code>用更高版本编译。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "通过指定的程序集<code> assemblyName </code>已找到，但无法加载。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "指定程序集具有不到入口点。"
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  id: ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(AssemblyName,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "执行给定的程序集<xref:System.Reflection.AssemblyName>，使用指定的参数。</xref:System.Reflection.AssemblyName>"
  remarks: "<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法提供与类似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但按显示名称指定的程序集或<xref:System.Reflection.AssemblyName>而不是文件位置。</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>加载程序集与<xref:System.Reflection.Assembly.Load%2A>方法而不是与<xref:System.Reflection.Assembly.LoadFile%2A>方法。</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       程序集开始在.NET Framework 标头中指定的入口点执行。       此方法不会创建新的进程或应用程序域，并且不会在新线程上执行入口点方法。"
  syntax:
    content: public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, string[] args);
    parameters:
    - id: assemblyName
      type: System.Reflection.AssemblyName
      description: "<xref:System.Reflection.AssemblyName>对象，表示程序集的名称。</xref:System.Reflection.AssemblyName>"
    - id: args
      type: System.String[]
      description: "若要启动进程时传递的命令行参数。"
    return:
      type: System.Int32
      description: "程序集的入口点返回的值。"
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "通过指定的程序集<code> assemblyName </code>找不到。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "通过指定的程序集<code> assemblyName </code>已找到，但无法加载。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "通过指定的程序集<code> assemblyName </code>不是有效的程序集。       - <code> assemblyName </code>用比当前加载的版本更高版本的公共语言运行时编译。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "指定程序集具有不到入口点。"
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  id: ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String,Evidence)
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence)
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "执行在给定其显示名称，使用指定的证据程序集。"
  remarks: "<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法提供与类似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但按显示名称指定的程序集或<xref:System.Reflection.AssemblyName>而不是文件位置。</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>加载程序集与<xref:System.Reflection.Assembly.Load%2A>方法而不是与<xref:System.Reflection.Assembly.LoadFile%2A>方法。</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       程序集开始在.NET Framework 标头中指定的入口点执行。       <xref:System.AppDomain.ExecuteAssemblyByName%2A>方法不会创建新的进程或应用程序域，并且不会在新线程上执行入口点方法。</xref:System.AppDomain.ExecuteAssemblyByName%2A>      1> [!NOTE]&1;> 当你使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法替换<xref:System.Security.Policy.Evidence>合并参数，证据。</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.ExecuteAssemblyByName%2A> 作为参数提供的证据<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法取代加载程序提供的证据。</xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyName
      type: System.String
      description: "程序集的显示名称。 请参阅&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;。"
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "用于加载程序集的证据。"
    return:
      type: System.Int32
      description: "程序集的入口点返回的值。"
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "通过指定的程序集<code> assemblyName </code>找不到。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "通过指定的程序集<code> assemblyName </code>已找到，但无法加载。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "通过指定的程序集<code> assemblyName </code>不是有效的程序集。       -或-当前加载版本 2.0 或更高版本的公共语言运行时和<code> assemblyName </code>用更高版本编译。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "指定程序集具有不到入口点。"
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])
  id: ExecuteAssemblyByName(System.String,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "执行程序集在给定其显示名称，使用指定的参数。"
  remarks: "<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法提供与类似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但按显示名称指定的程序集或<xref:System.Reflection.AssemblyName>而不是文件位置。</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>加载程序集与<xref:System.Reflection.Assembly.Load%2A>方法而不是与<xref:System.Reflection.Assembly.LoadFile%2A>方法。</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       程序集开始在.NET Framework 标头中指定的入口点执行。       此方法不会创建新的进程或应用程序域，并且不会在新线程上执行入口点方法。"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName, string[] args);
    parameters:
    - id: assemblyName
      type: System.String
      description: "程序集的显示名称。 请参阅&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;。"
    - id: args
      type: System.String[]
      description: "若要启动进程时传递的命令行参数。"
    return:
      type: System.Int32
      description: "程序集的入口点返回的值。"
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "通过指定的程序集<code> assemblyName </code>找不到。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "通过指定的程序集<code> assemblyName </code>已找到，但无法加载。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "通过指定的程序集<code> assemblyName </code>不是有效的程序集。       - <code> assemblyName </code>用比当前加载的版本更高版本的公共语言运行时编译。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "指定程序集具有不到入口点。"
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  id: ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "执行给定的程序集<xref:System.Reflection.AssemblyName>，使用指定的证据和自变量。</xref:System.Reflection.AssemblyName>"
  remarks: "<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法提供与类似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但按显示名称指定的程序集或<xref:System.Reflection.AssemblyName>而不是文件位置。</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>加载程序集与<xref:System.Reflection.Assembly.Load%2A>方法而不是与<xref:System.Reflection.Assembly.LoadFile%2A>方法。</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       程序集开始在.NET Framework 标头中指定的入口点执行。       此方法不会创建新的进程或应用程序域，并且不会在新线程上执行入口点方法。      1> [!NOTE]&1;> 当你使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法替换<xref:System.Security.Policy.Evidence>合并参数，证据。</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.ExecuteAssemblyByName%2A> 作为参数提供的证据<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法取代加载程序提供的证据。</xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  syntax:
    content: public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, string[] args);
    parameters:
    - id: assemblyName
      type: System.Reflection.AssemblyName
      description: "<xref:System.Reflection.AssemblyName>对象，表示程序集的名称。</xref:System.Reflection.AssemblyName>"
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "用于加载程序集的证据。"
    - id: args
      type: System.String[]
      description: "若要启动进程时传递的命令行参数。"
    return:
      type: System.Int32
      description: "程序集的入口点返回的值。"
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "通过指定的程序集<code> assemblyName </code>找不到。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "通过指定的程序集<code> assemblyName </code>已找到，但无法加载。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "通过指定的程序集<code> assemblyName </code>不是有效的程序集。       -或-当前加载版本 2.0 或更高版本的公共语言运行时和<code> assemblyName </code>用更高版本编译。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. 当未启用旧版 CAS 策略时，<code>assemblySecurity</code>应<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "指定程序集具有不到入口点。"
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  id: ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "执行程序集在给定其显示名称，使用指定的证据和自变量。"
  remarks: "<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法提供与类似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但按显示名称指定的程序集或<xref:System.Reflection.AssemblyName>而不是文件位置。</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>加载程序集与<xref:System.Reflection.Assembly.Load%2A>方法而不是与<xref:System.Reflection.Assembly.LoadFile%2A>方法。</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       程序集开始在.NET Framework 标头中指定的入口点执行。       此方法不会创建新的进程或应用程序域，并且不会在新线程上执行入口点方法。      1> [!NOTE]&1;> 当你使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法替换<xref:System.Security.Policy.Evidence>合并参数，证据。</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.ExecuteAssemblyByName%2A> 作为参数提供的证据<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法取代加载程序提供的证据。</xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, string[] args);
    parameters:
    - id: assemblyName
      type: System.String
      description: "程序集的显示名称。 请参阅&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;。"
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "用于加载程序集的证据。"
    - id: args
      type: System.String[]
      description: "若要启动进程时传递的命令行参数。"
    return:
      type: System.Int32
      description: "程序集的入口点返回的值。"
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "通过指定的程序集<code> assemblyName </code>找不到。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "通过指定的程序集<code> assemblyName </code>已找到，但无法加载。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "通过指定的程序集<code> assemblyName </code>不是有效的程序集。       -或-当前加载版本 2.0 或更高版本的公共语言运行时和<code> assemblyName </code>用更高版本编译。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. 当未启用旧版 CAS 策略时，<code>assemblySecurity</code>应<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "指定程序集具有不到入口点。"
  platform:
  - net462
- uid: System.AppDomain.FirstChanceException
  id: FirstChanceException
  parent: System.AppDomain
  langs:
  - csharp
  name: FirstChanceException
  nameWithType: AppDomain.FirstChanceException
  fullName: System.AppDomain.FirstChanceException
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "当运行时应用程序域中搜索调用堆栈的异常处理程序之前，在托管代码中，引发的异常时发生。"
  remarks: "此事件是仅一个通知。 处理此事件不会处理的异常或会影响后续以任何方式处理的异常。 引发事件并在调用事件处理程序后，公共语言运行时 (CLR) 开始搜索的异常处理程序。 FirstChanceException 提供与第一个机会检查任何托管的异常的应用程序域。       每个应用程序域可以处理此事件。 如果一个线程通过多个应用程序域传递执行调用时，CLR 开始搜索该应用程序域中的匹配异常处理程序之前已注册事件处理程序，每个应用程序域中将引发事件。 处理此事件后，将为该应用程序域中的匹配异常处理程序中进行搜索。 如果找不到下, 一步的应用程序域中将引发事件。       你必须处理在事件发生 FirstChanceException 事件处理程序的所有异常。 否则，FirstChanceException 为引发以递归方式。 这可能导致堆栈上溢和终止应用程序。 我们建议你实现此事件的事件处理程序作为受约束的执行区域 (Cer)，以防止与基础结构相关的异常，例如内存不足或堆栈溢出异常通知在处理时影响虚拟机。       此事件不会引发的异常的指示损坏进程的状态，例如访问冲突，除非事件处理程序是安全关键，并且具有<xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>属性。</xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>       公共语言运行时挂起线程中止时正在处理此通知事件。"
  example:
  - "The following example creates a series of application domains named `AD0` through `AD3`, with a `Worker` object in each application domain. Each `Worker` object has a reference to the `Worker` object in the next application domain, except for the `Worker` in the last application domain. The FirstChanceException event is handled in all application domains except `AD1`.  \n  \n> [!NOTE]\n>  In addition to this example, which demonstrates first-chance exception notifications in multiple application domains, you can find simple use cases in [How to: Receive First-Chance Exception Notifications](~/add/includes/ajax-current-ext-md.md).  \n  \n When the application domains have been created, the default application domain calls the `TestException` method for the first application domain. Each `Worker` object calls the `TestException` method for the next application domain, until the last `Worker` throws an exception that is either handled or unhandled. Thus, the current thread passes through all the application domains, and `TestException` is added to the stack in each application domain.  \n  \n When the last `Worker` object handles the exception, the FirstChanceException event is raised only in the last application domain. The other application domains never get a chance to handle the exception, so the event is not raised.  \n  \n When the last `Worker` object does not handle the exception, the FirstChanceException event is raised in each application domain that has an event handler. After each event handler has finished, the stack continues to unwind until the exception is caught by the default application domain.  \n  \n> [!NOTE]\n>  To see how the stack display grows as the event is raised closer and closer to the default application domain, change `e.Exception.Message` to `e.Exception` in the `FirstChanceHandler` event handlers. Notice that when `TestException` is called across application domain boundaries, it appears twice: once for the proxy and once for the stub.  \n  \n [!code-vb[System.AppDomain.FirstChanceException#1](~/add/codesnippet/visualbasic/e-system.appdomain.first_1.vb)]\n [!code-cs[System.AppDomain.FirstChanceException#1](~/add/codesnippet/csharp/e-system.appdomain.first_1.cs)]"
  syntax:
    content: public event EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs> FirstChanceException;
    return:
      type: System.EventHandler{System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs}
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.FriendlyName
  id: FriendlyName
  parent: System.AppDomain
  langs:
  - csharp
  name: FriendlyName
  nameWithType: AppDomain.FriendlyName
  fullName: System.AppDomain.FriendlyName
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取此应用程序域的友好名称。"
  remarks: "默认应用程序域的友好名称是进程可执行文件的文件名。 例如，如果使用可执行文件以启动该过程是`&quot;c:\\MyAppDirectory\\MyAssembly.exe&quot;`，默认应用程序域的友好名称是`&quot;MyAssembly.exe&quot;`。"
  example:
  - "The following code example uses the FriendlyName property to get the friendly name of the current application domain. For the default application domain, the friendly name is the name of the application's executable file. The code example also displays additional information about the application domain.  \n  \n [!code-vb[ADApplicationBase#1](~/add/codesnippet/visualbasic/p-system.appdomain.frien_1.vb)]\n [!code-cpp[ADApplicationBase#1](~/add/codesnippet/cpp/p-system.appdomain.frien_1.cpp)]\n [!code-cs[ADApplicationBase#1](~/add/codesnippet/csharp/p-system.appdomain.frien_1.cs)]"
  syntax:
    content: public string FriendlyName { get; }
    return:
      type: System.String
      description: "此应用程序域的友好名称。"
  overload: System.AppDomain.FriendlyName*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.GetAssemblies
  id: GetAssemblies
  parent: System.AppDomain
  langs:
  - csharp
  name: GetAssemblies()
  nameWithType: AppDomain.GetAssemblies()
  fullName: System.AppDomain.GetAssemblies()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取已加载到此应用程序域的执行上下文的程序集。"
  remarks: ''
  example:
  - "The following code example uses the GetAssemblies method to get a list of all assemblies that have been loaded into the application domain. The assemblies are then displayed to the console.  \n  \n To run this code example, you need to create an assembly named `CustomLibrary.dll`, or change the assembly name that is passed to the GetAssemblies method.  \n  \n [!code-cpp[ADGetAssemblies#1](~/add/codesnippet/cpp/m-system.appdomain.getas_1.cpp)]\n [!code-cs[ADGetAssemblies#1](~/add/codesnippet/csharp/m-system.appdomain.getas_1.cs)]\n [!code-vb[ADGetAssemblies#1](~/add/codesnippet/visualbasic/m-system.appdomain.getas_1.vb)]"
  syntax:
    content: public System.Reflection.Assembly[] GetAssemblies ();
    parameters: []
    return:
      type: System.Reflection.Assembly[]
      description: "此应用程序域中的程序集的数组。"
  overload: System.AppDomain.GetAssemblies*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.GetCurrentThreadId
  id: GetCurrentThreadId
  parent: System.AppDomain
  langs:
  - csharp
  name: GetCurrentThreadId()
  nameWithType: AppDomain.GetCurrentThreadId()
  fullName: System.AppDomain.GetCurrentThreadId()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取当前线程标识符。"
  remarks: "使用<xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=fullName>属性，它是稳定甚至.NET Framework 承载环境支持纤程 （即，轻量级线程）。</xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=fullName>"
  syntax:
    content: public static int GetCurrentThreadId ();
    parameters: []
    return:
      type: System.Int32
      description: "一个 32 位有符号的整数，是当前线程的标识符。"
  overload: System.AppDomain.GetCurrentThreadId*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.GetData(System.String)
  id: GetData(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: GetData(String)
  nameWithType: AppDomain.GetData(String)
  fullName: System.AppDomain.GetData(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取存储在当前应用程序域中为指定名称的值。"
  remarks: "使用此方法来检索描述<xref:System.AppDomain>.</xref:System.AppDomain>此实例的属性的名称数据对内部缓存中的项的值 请注意，比较`name`同名的键 / 值对是区分大小写。       该缓存自动包含在创建应用程序域后插入的预定义的系统项。 你可以检查它们的值与 GetData 方法中或等效<xref:System.AppDomainSetup>属性。</xref:System.AppDomainSetup>       你可以插入或修改与自己用户定义名称数据对<xref:System.AppDomain.SetData%2A>方法，并使用 GetData 方法检查其值。</xref:System.AppDomain.SetData%2A>       下表描述了`name`每个预定义系统条目和其对应<xref:System.AppDomainSetup>属性。</xref:System.AppDomainSetup>      |Name 的值 |属性 |  |---------------------|--------------|  |&quot;APPBASE&quot;|<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>|  |&quot;APP_CONFIG_FILE&quot;|<xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=fullName>|  |&quot;APP_LAUNCH_URL&quot;|（没有属性）</xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=fullName> </xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName><br /><br /> &quot;APP_LAUNCH_URL&quot;表示最初由用户之前任何重定向请求的 URL。 仅当使用如 Internet Explorer 浏览器中启动应用程序时，才，它才可用。 并非所有浏览器都提供此值。 |  |&quot;APP_NAME&quot;|<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>|  |&quot;BINPATH_PROBE_ONLY&quot;|<xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=fullName>|  |&quot;CACHE_BASE&quot;|<xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName>|  |&quot;CODE_DOWNLOAD_DISABLED&quot;|<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName>|  |&quot;DEV_PATH&quot;|（没有属性） |  |&quot;DISALLOW_APP&quot;|<xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=fullName>|  |&quot;DISALLOW_APP_BASE_PROBING&quot;|<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=fullName>|  |&quot;DISALLOW_APP_REDIRECTS&quot;|<xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=fullName>|  |&quot;DYNAMIC_BASE&quot;|<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName>|  |&quot;FORCE_CACHE_INSTALL&quot;|<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName>|  |&quot;LICENSE_FILE&quot;，或应用程序特有字符串 |<xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=fullName>|  |&quot;LOADER_OPTIMIZATION&quot;|<xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=fullName>|  |&quot;LOCATION_URI&quot;|（没有属性） |  |&quot;PRIVATE_BINPATH&quot;|<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>|  |&quot;REGEX_DEFAULT_MATCH_TIMEOUT&quot;|<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=fullName></xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=fullName></xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName></xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=fullName></xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=fullName></xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName></xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName></xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName></xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=fullName></xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName><br /><br /> &quot;REGEX_DEFAULT_MATCH_TIMEOUT&quot;不是一个系统项，并且可通过调用<xref:System.AppDomain.SetData%2A>方法设置其值。 |  |&quot;SHADOW_COPY_DIRS&quot;|<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>|</xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName></xref:System.AppDomain.SetData%2A>"
  example:
  - "The following example creates a new application domain, sets a system-provided value for the domain, and adds a new value pair for the domain. The example then demonstrates how to use the GetData method to retrieve the data from these value pairs and display them to the console.  \n  \n [!code-cpp[ADGetData#1](~/add/codesnippet/cpp/m-system.appdomain.getda_1.cpp)]\n [!code-vb[ADGetData#1](~/add/codesnippet/visualbasic/m-system.appdomain.getda_1.vb)]\n [!code-cs[ADGetData#1](~/add/codesnippet/csharp/m-system.appdomain.getda_1.cs)]"
  syntax:
    content: public object GetData (string name);
    parameters:
    - id: name
      type: System.String
      description: "预定义的应用程序域属性的名称或你定义应用程序域属性的名称。"
    return:
      type: System.Object
      description: "值<code> name </code>属性，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果属性不存在。"
  overload: System.AppDomain.GetData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.GetType
  id: GetType
  parent: System.AppDomain
  langs:
  - csharp
  name: GetType()
  nameWithType: AppDomain.GetType()
  fullName: System.AppDomain.GetType()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取当前实例的类型。"
  syntax:
    content: public Type GetType ();
    parameters: []
    return:
      type: System.Type
      description: "当前实例的类型。"
  overload: System.AppDomain.GetType*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.Id
  id: Id
  parent: System.AppDomain
  langs:
  - csharp
  name: Id
  nameWithType: AppDomain.Id
  fullName: System.AppDomain.Id
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取一个整数，唯一标识进程中的应用程序域。"
  remarks: ''
  example:
  - "The following code example creates a second application domain and displays information about the default domain and the new domain.  \n  \n [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/visualbasic/p-system.appdomain.id_1.vb)]\n [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/cpp/p-system.appdomain.id_1.cpp)]\n [!code-cs[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/csharp/p-system.appdomain.id_1.cs)]"
  syntax:
    content: public int Id { get; }
    return:
      type: System.Int32
      description: "一个用于标识应用程序域的整数。"
  overload: System.AppDomain.Id*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.InitializeLifetimeService
  id: InitializeLifetimeService
  parent: System.AppDomain
  langs:
  - csharp
  name: InitializeLifetimeService()
  nameWithType: AppDomain.InitializeLifetimeService()
  fullName: System.AppDomain.InitializeLifetimeService()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "提供<xref href=&quot;System.AppDomain&quot;></xref>通过防止创建租约无限生存期。"
  syntax:
    content: public override object InitializeLifetimeService ();
    parameters: []
    return:
      type: System.Object
      description: "Always <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  overload: System.AppDomain.InitializeLifetimeService*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.IsCompatibilitySwitchSet(System.String)
  id: IsCompatibilitySwitchSet(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: IsCompatibilitySwitchSet(String)
  nameWithType: AppDomain.IsCompatibilitySwitchSet(String)
  fullName: System.AppDomain.IsCompatibilitySwitchSet(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取可以为 null 的布尔值，该值指示是否设置了任何兼容性开关，如果是这样，是否设置了指定的兼容性开关。"
  remarks: "This method tests whether the specified compatibility switch has been set for the current application domain. Compatibility switches typically restore a behavior (such as the way strings are sorted) that was changed between versions of the .NET Framework.  They are set by calling the <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=fullName> method before creating an application domain.  \n  \n The following table provides examples of compatibility switches that can be set to restore the behavior of earlier versions of the .NET Framework.  \n  \n|Switch|Meaning|  \n|------------|-------------|  \n|\"NetFx40_LegacySecurityPolicy\"|Code access security (CAS) for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] is enabled in this application domain. See [\\&lt;NetFx40_LegacySecurityPolicy\\&gt; Element](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md).|  \n|\"NetFx40_Legacy20SortingBehavior\"|String sorting defaults for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] are enabled in this application domain. Its success requires sort00001000.dll to be installed. See [\\&lt;CompatSortNLSVersion\\&gt; Element](../Topic/%3CCompatSortNLSVersion%3E%20Element.md).|  \n|\"NetFx40_Legacy40SortingBehavior\"|String sorting defaults for the [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]and Unicode 5.0 are enabled in this application domain. Its success requires sort00060101.dll to be installed.|  \n|\"NetFx40_TimeSpanLegacyFormatMode\"|<xref:System.TimeSpan> formatting behavior for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] is enabled in this application domain.  See [\\&lt;TimeSpan_LegacyFormatMode\\&gt; Element](../Topic/%3CTimeSpan_LegacyFormatMode%3E%20Element.md) and the \"Restoring Legacy TimeSpan Formatting\" section of the <xref:System.TimeSpan> topic.|  \n|\"UseRandomizedStringHashAlgorithm\"|The runtime calculates hash codes for strings on a per application domain basis instead of using a single hashing algorithm that produces a consistent hash code across application domains. See [\\&lt;UseRandomizedStringHashAlgorithm\\&gt; Element](../Topic/%3CUseRandomizedStringHashAlgorithm%3E%20Element.md).|"
  syntax:
    content: public Nullable<bool> IsCompatibilitySwitchSet (string value);
    parameters:
    - id: value
      type: System.String
      description: "要测试的兼容性开关。"
    return:
      type: System.Nullable{System.Boolean}
      description: "空引用 (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref>在 Visual Basic 中) 如果未不设置任何兼容性开关; 否则为一个布尔值，该值指示指定的兼容性开关， <code> value </code>设置。"
  overload: System.AppDomain.IsCompatibilitySwitchSet*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsDefaultAppDomain
  id: IsDefaultAppDomain
  parent: System.AppDomain
  langs:
  - csharp
  name: IsDefaultAppDomain()
  nameWithType: AppDomain.IsDefaultAppDomain()
  fullName: System.AppDomain.IsDefaultAppDomain()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "返回一个值，该值指示应用程序域是否进程的默认应用程序域。"
  remarks: "每个托管的进程都有默认应用程序域。 默认域中开始执行。"
  example:
  - "The following code example creates a second application domain and displays information about the default domain and the new domain.  \n  \n [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/visualbasic/m-system.appdomain.isdef_1.vb)]\n [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/cpp/m-system.appdomain.isdef_1.cpp)]\n [!code-cs[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/csharp/m-system.appdomain.isdef_1.cs)]"
  syntax:
    content: public bool IsDefaultAppDomain ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果当前<xref href=&quot;System.AppDomain&quot;></xref>对象表示的默认应用程序域的进程; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.AppDomain.IsDefaultAppDomain*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsFinalizingForUnload
  id: IsFinalizingForUnload
  parent: System.AppDomain
  langs:
  - csharp
  name: IsFinalizingForUnload()
  nameWithType: AppDomain.IsFinalizingForUnload()
  fullName: System.AppDomain.IsFinalizingForUnload()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "指示是否正在卸载此应用程序域，并且公共语言运行时正在终止该域包含的对象。"
  remarks: "一个对象的完成方法提供机会在对象垃圾回收之前执行任何必要的清理操作。 完成后，该对象处于可访问但处于无效状态，因而无法使用。 最终，垃圾回收完成，并回收对象。       在下列情况之一调用对象的完成方法︰ 垃圾回收期间时公共语言运行时正在关闭，或卸载应用程序域包含的对象时。 IsFinalizingForUnload 方法返回`true`仅在最后一种情况; 它不返回`true`如果终止结果从例程垃圾回收或 CLR 关闭。      1> [!NOTE]&1;> 若要确定终止是否由于 CLR 已关闭，请使用<xref:System.Environment.HasShutdownStarted%2A?displayProperty=fullName>属性。</xref:System.Environment.HasShutdownStarted%2A?displayProperty=fullName> 它将返回`true`终止是否由于应用程序域正在卸载或者 CLR 正在关闭。       执行时终止方法中在域卸载过程，你可能想要访问另一个对象引用的静态字段，已终止方法。 但是，不能可靠地这样做是因为访问的对象可能已终止。      1> [!NOTE]&1;> 此规则的唯一例外是<xref:System.Console>类，该类包含引用流对象的静态字段，但该类实现，以便你可以始终写入系统控制台中，即使在域卸载或系统关闭期间专门。</xref:System.Console>       在对象的完成方法使用此方法，以确定是否包含对象的应用程序域正在卸载。 如果是这种情况，你无法可靠地访问任何对象，具有完成方法并由静态字段引用。"
  syntax:
    content: public bool IsFinalizingForUnload ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果此应用程序域卸载，并且公共语言运行时已开始调用终结器;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.AppDomain.IsFinalizingForUnload*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsFullyTrusted
  id: IsFullyTrusted
  parent: System.AppDomain
  langs:
  - csharp
  name: IsFullyTrusted
  nameWithType: AppDomain.IsFullyTrusted
  fullName: System.AppDomain.IsFullyTrusted
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取一个值，该值指示是否加载到当前的应用程序域的程序集以完全信任方式执行。"
  remarks: "此方法始终返回`true`在桌面上运行的应用程序的默认应用程序域。 它将返回`false`通过使用创建的沙盒应用程序域[AppDomain.CreateDomain (字符串、 证据、 AppDomainSetup、 PermissionSet、 StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False)方法重载，除非授予应用程序域的权限是等效于完全信任。"
  example:
  - "The following example demonstrates the IsFullyTrusted property and the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> property with fully trusted and partially trusted application domains. The fully trusted application domain is the default application domain for the application. The partially trusted application domain is created by using the [AppDomain.CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) method overload.  \n  \n The example uses a `Worker` class that derives from <xref:System.MarshalByRefObject>, so it can be marshaled across application domain boundaries. The example creates a `Worker` object in the default application domain. It then calls the `TestIsFullyTrusted` method to display the property value for the application domain and for two assemblies that are loaded into the application domain: mscorlib, which is part of the .NET Framework, and the example assembly. The application domain is fully trusted, so both assemblies are fully trusted.  \n  \n The example creates another `Worker` object in a sandboxed application domain and again calls the `TestIsFullyTrusted` method. Mscorlib is always trusted, even in a partially trusted application domain, but the example assembly is partially trusted.  \n  \n [!code-vb[System.AppDomain.IsFullyTrusted#1](~/add/codesnippet/visualbasic/p-system.appdomain.isful_1.vb)]\n [!code-cs[System.AppDomain.IsFullyTrusted#1](~/add/codesnippet/csharp/p-system.appdomain.isful_1.cs)]"
  syntax:
    content: public bool IsFullyTrusted { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果加载到当前的应用程序域的程序集执行完全信任;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.AppDomain.IsFullyTrusted*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsHomogenous
  id: IsHomogenous
  parent: System.AppDomain
  langs:
  - csharp
  name: IsHomogenous
  nameWithType: AppDomain.IsHomogenous
  fullName: System.AppDomain.IsHomogenous
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取一个值，该值指示当前的应用程序域是否已加载到应用程序域的所有程序集授予的权限集。"
  remarks: "This property returns `true` for sandboxed application domains that were created by using the [AppDomain.CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) method overload. Sandboxed application domains have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain. A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.  \n  \n Fully trusted code can use the <xref:System.AppDomain.PermissionSet%2A> property to determine the homogenous grant set of a sandboxed application domain.  \n  \n This property also returns `true` for the default application domain of a desktop application, because that application domain grants full trust to all assemblies."
  syntax:
    content: public bool IsHomogenous { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果当前的应用程序域具有一组同构权限;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.AppDomain.IsHomogenous*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.Load(System.Byte[])
  id: Load(System.Byte[])
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(Byte[])
  nameWithType: AppDomain.Load(Byte[])
  fullName: System.AppDomain.Load(Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "加载<xref:System.Reflection.Assembly>与包含发出<xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly>通用对象文件格式 (COFF) 基于图像</xref:System.Reflection.Assembly>"
  remarks: "开头[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]，使用此方法加载程序集的信任级别是应用程序域的信任级别相同。       应使用此方法只是为了将程序集加载到当前的应用程序域。 为方便起见那些不能调用静态的互操作性调用方提供此方法是<xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>方法。</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> 若要将程序集加载到其他应用程序域中，使用<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>之类的方法       普遍适用于此方法的所有重载的信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the use of loading a raw assembly.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AppDomain_LoadRaw#1](~/add/codesnippet/visualbasic/m-system.appdomain.load-_1_1.vb)]\n [!code-cs[AppDomain_LoadRaw#1](~/add/codesnippet/csharp/m-system.appdomain.load-_1_1.cs)]\n [!code-cpp[AppDomain_LoadRaw#1](~/add/codesnippet/cpp/m-system.appdomain.load-_1_1.cpp)]"
  syntax:
    content: public System.Reflection.Assembly Load (byte[] rawAssembly);
    parameters:
    - id: rawAssembly
      type: System.Byte[]
      description: "类型的数组<xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> ，它是基于 COFF 的图像包含已发出程序集。"
    return:
      type: System.Reflection.Assembly
      description: "加载的程序集。"
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rawAssembly</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>rawAssembly</code>不是有效的程序集。       -或-当前加载版本 2.0 或更高版本的公共语言运行时和<code>rawAssembly</code>用更高版本编译。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  platform:
  - net462
- uid: System.AppDomain.Load(System.Reflection.AssemblyName)
  id: Load(System.Reflection.AssemblyName)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(AssemblyName)
  nameWithType: AppDomain.Load(AssemblyName)
  fullName: System.AppDomain.Load(AssemblyName)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "<xref:System.Reflection.Assembly>给定其<xref:System.Reflection.AssemblyName>.</xref:System.Reflection.AssemblyName></xref:System.Reflection.Assembly>加载"
  remarks: "应使用此方法只是为了将程序集加载到当前的应用程序域。 为方便起见那些不能调用静态的互操作性调用方提供此方法是<xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>方法。</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> 若要将程序集加载到其他应用程序域中，使用<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>之类的方法       如果已加载请求的程序集的版本，则此方法返回加载的程序集，即使请求的不同版本。       提供的部分程序集名称`assemblyRef`不建议。 （一个或多个区域性、 版本或公钥标记，则会忽略部分名称。 对于采用字符串而不是重载<xref:System.Reflection.AssemblyName>对象，&quot;MyAssembly，Version =&1;.0.0.0&quot;是一个示例部分的名称和&quot;MyAssembly，Version =&1;.0.0.0，Culture = neutral，PublicKeyToken =&18;ab3442da84b47&quot;举例说明的完整名称。)</xref:System.Reflection.AssemblyName>使用部分名称具有负面性能影响。 此外，部分程序集名称可以加载程序集从全局程序集缓存只有在应用程序基目录中的程序集的一个精确副本 (<xref:System.AppDomain.BaseDirectory%2A>或<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>)。</xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName> </xref:System.AppDomain.BaseDirectory%2A>       如果当前<xref:System.AppDomain>对象表示应用程序域`A`，和<xref:System.AppDomain.Load%2A>方法从应用程序域调用`B`，程序集将会加载到这两个应用程序域。</xref:System.AppDomain.Load%2A> </xref:System.AppDomain> 例如，下面的代码加载`MyAssembly`到新的应用程序域`ChildDomain`和也到代码的执行位置的应用程序域︰ [!code-vb [System.AppDomain.Load#1](~/add/codesnippet/visualbasic/m-system.appdomain.load-_2_1.vb)][!code-cpp[System.AppDomain.Load#1](~/add/codesnippet/cpp/m-system.appdomain.load-_2_1.cpp)][!code-cs[System.AppDomain.Load#1](~/add/codesnippet/csharp/m-system.appdomain.load-_2_1.cs) ]程序集加载到这两个域，因为<xref:System.Reflection.Assembly>不是派生自<xref:System.MarshalByRefObject>，和的因此返回的值<xref:System.AppDomain.Load%2A>方法不能进行封送处理。</xref:System.AppDomain.Load%2A> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly>     相反，公共语言运行时尝试加载到调用应用程序域的程序集。 如果两个应用程序域的路径设置不同，到两个应用程序域加载的程序集可能有所不同。      1> [!NOTE]&1;> 如果这两个<xref:System.Reflection.AssemblyName.Name%2A?displayProperty=fullName>属性和<xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=fullName>属性设置，在首次尝试加载程序集使用的显示名称 (包括版本、 区域性和等等，返回为<xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName>属性)。</xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName> </xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=fullName> </xref:System.Reflection.AssemblyName.Name%2A?displayProperty=fullName> 如果未找到该文件，<xref:System.Reflection.AssemblyName.CodeBase%2A>属性用于搜索程序集。</xref:System.Reflection.AssemblyName.CodeBase%2A> 如果使用找到的程序集<xref:System.Reflection.AssemblyName.CodeBase%2A>，与程序集匹配的显示名称。</xref:System.Reflection.AssemblyName.CodeBase%2A> 如果匹配失败，<xref:System.IO.FileLoadException>引发。</xref:System.IO.FileLoadException>"
  syntax:
    content: public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);
    parameters:
    - id: assemblyRef
      type: System.Reflection.AssemblyName
      description: "一个对象，描述要加载的程序集。"
    return:
      type: System.Reflection.Assembly
      description: "加载的程序集。"
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyRef</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyRef</code>未找到。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyRef</code>不是有效的程序集。       -或-当前加载版本 2.0 或更高版本的公共语言运行时和<code>assemblyRef</code>用更高版本编译。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  platform:
  - net462
- uid: System.AppDomain.Load(System.String)
  id: Load(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(String)
  nameWithType: AppDomain.Load(String)
  fullName: System.AppDomain.Load(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "加载<xref:System.Reflection.Assembly>给定其显示名称。</xref:System.Reflection.Assembly>"
  remarks: "应使用此方法只是为了将程序集加载到当前的应用程序域。 为方便起见那些不能调用静态的互操作性调用方提供此方法是<xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>方法。</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> 若要将程序集加载到其他应用程序域中，使用<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>之类的方法       普遍适用于此方法的所有重载的信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Assembly Load (string assemblyString);
    parameters:
    - id: assemblyString
      type: System.String
      description: "程序集的显示名称。 请参阅&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;。"
    return:
      type: System.Reflection.Assembly
      description: "加载的程序集。"
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyString</code>是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyString</code>未找到。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyString</code>不是有效的程序集。       -或-当前加载版本 2.0 或更高版本的公共语言运行时和<code>assemblyString</code>用更高版本编译。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  platform:
  - net462
- uid: System.AppDomain.Load(System.Byte[],System.Byte[])
  id: Load(System.Byte[],System.Byte[])
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(Byte[],Byte[])
  nameWithType: AppDomain.Load(Byte[],Byte[])
  fullName: System.AppDomain.Load(Byte[],Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "加载<xref:System.Reflection.Assembly>与包含发出<xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly>通用对象文件格式 (COFF) 基于图像</xref:System.Reflection.Assembly> 表示的符号的原始字节<xref:System.Reflection.Assembly>还有加载。</xref:System.Reflection.Assembly>"
  remarks: "开头[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]，使用此方法加载程序集的信任级别是应用程序域的信任级别相同。       应使用此方法只是为了将程序集加载到当前的应用程序域。 为方便起见那些不能调用静态的互操作性调用方提供此方法是<xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>方法。</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> 若要将程序集加载到其他应用程序域中，使用<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>之类的方法       普遍适用于此方法的所有重载的信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the use of loading a raw assembly.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AppDomain_LoadRaw#1](~/add/codesnippet/visualbasic/m-system.appdomain.load-_0_1.vb)]\n [!code-cs[AppDomain_LoadRaw#1](~/add/codesnippet/csharp/m-system.appdomain.load-_0_1.cs)]\n [!code-cpp[AppDomain_LoadRaw#1](~/add/codesnippet/cpp/m-system.appdomain.load-_0_1.cpp)]"
  syntax:
    content: public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);
    parameters:
    - id: rawAssembly
      type: System.Byte[]
      description: "类型的数组<xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> ，它是基于 COFF 的图像包含已发出程序集。"
    - id: rawSymbolStore
      type: System.Byte[]
      description: "类型的数组<xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;></xref>包含表示程序集符号的原始字节。"
    return:
      type: System.Reflection.Assembly
      description: "加载的程序集。"
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rawAssembly</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>rawAssembly</code>不是有效的程序集。       -或-当前加载版本 2.0 或更高版本的公共语言运行时和<code>rawAssembly</code>用更高版本编译。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  platform:
  - net462
- uid: System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  id: Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(AssemblyName,Evidence)
  nameWithType: AppDomain.Load(AssemblyName,Evidence)
  fullName: System.AppDomain.Load(AssemblyName,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "<xref:System.Reflection.Assembly>给定其<xref:System.Reflection.AssemblyName>.</xref:System.Reflection.AssemblyName></xref:System.Reflection.Assembly>加载"
  remarks: "应使用此方法只是为了将程序集加载到当前的应用程序域。 为方便起见那些不能调用静态的互操作性调用方提供此方法是<xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>方法。</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> 若要将程序集加载到其他应用程序域中，使用<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>之类的方法       普遍适用于此方法的所有重载的信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyRef
      type: System.Reflection.AssemblyName
      description: "一个对象，描述要加载的程序集。"
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "用于加载程序集的证据。"
    return:
      type: System.Reflection.Assembly
      description: "加载的程序集。"
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyRef</code>是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyRef</code>未找到。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyRef</code>不是有效的程序集。       -或-当前加载版本 2.0 或更高版本的公共语言运行时和<code>assemblyRef</code>用更高版本编译。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  platform:
  - net462
- uid: System.AppDomain.Load(System.String,System.Security.Policy.Evidence)
  id: Load(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(String,Evidence)
  nameWithType: AppDomain.Load(String,Evidence)
  fullName: System.AppDomain.Load(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "加载<xref:System.Reflection.Assembly>给定其显示名称。</xref:System.Reflection.Assembly>"
  remarks: "应使用此方法只是为了将程序集加载到当前的应用程序域。 为方便起见那些不能调用静态的互操作性调用方提供此方法是<xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>方法。</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> 若要将程序集加载到其他应用程序域中，使用<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>之类的方法       普遍适用于此方法的所有重载的信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyString
      type: System.String
      description: "程序集的显示名称。 请参阅&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;。"
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "用于加载程序集的证据。"
    return:
      type: System.Reflection.Assembly
      description: "加载的程序集。"
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyString</code>是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyString</code>未找到。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyString</code>不是有效的程序集。       -或-当前加载版本 2.0 或更高版本的公共语言运行时和<code>assemblyString</code>用更高版本编译。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  platform:
  - net462
- uid: System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  id: Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(Byte[],Byte[],Evidence)
  nameWithType: AppDomain.Load(Byte[],Byte[],Evidence)
  fullName: System.AppDomain.Load(Byte[],Byte[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "加载<xref:System.Reflection.Assembly>与包含发出<xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly>通用对象文件格式 (COFF) 基于图像</xref:System.Reflection.Assembly> 表示的符号的原始字节<xref:System.Reflection.Assembly>还有加载。</xref:System.Reflection.Assembly>"
  remarks: "开头[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]，使用此方法加载程序集的信任级别是应用程序域的信任级别相同。       应使用此方法只是为了将程序集加载到当前的应用程序域。 为方便起见那些不能调用静态的互操作性调用方提供此方法是<xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>方法。</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> 若要将程序集加载到其他应用程序域中，使用<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>之类的方法       普遍适用于此方法的所有重载的信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the use of loading a raw assembly.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AppDomain_LoadRaw#1](~/add/codesnippet/visualbasic/1e204365-b0ec-4650-8d52-_1.vb)]\n [!code-cs[AppDomain_LoadRaw#1](~/add/codesnippet/csharp/1e204365-b0ec-4650-8d52-_1.cs)]\n [!code-cpp[AppDomain_LoadRaw#1](~/add/codesnippet/cpp/1e204365-b0ec-4650-8d52-_1.cpp)]"
  syntax:
    content: public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);
    parameters:
    - id: rawAssembly
      type: System.Byte[]
      description: "类型的数组<xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> ，它是基于 COFF 的图像包含已发出程序集。"
    - id: rawSymbolStore
      type: System.Byte[]
      description: "类型的数组<xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;></xref>包含表示程序集符号的原始字节。"
    - id: securityEvidence
      type: System.Security.Policy.Evidence
      description: "用于加载程序集的证据。"
    return:
      type: System.Reflection.Assembly
      description: "加载的程序集。"
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rawAssembly</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>rawAssembly</code>不是有效的程序集。       -或-当前加载版本 2.0 或更高版本的公共语言运行时和<code>rawAssembly</code>用更高版本编译。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>securityEvidence</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. 当未启用旧版 CAS 策略时，<code>securityEvidence</code>应<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.AppDomain.MonitoringIsEnabled
  id: MonitoringIsEnabled
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringIsEnabled
  nameWithType: AppDomain.MonitoringIsEnabled
  fullName: System.AppDomain.MonitoringIsEnabled
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取或设置一个值，该值指示是否对当前进程启用 CPU 和内存监视的应用程序域。 一旦进程的情况下，启用监视，则不能禁用。"
  remarks: "这`static`属性 (`Shared`属性在 Visual Basic) 控制 CPU 和内存监视的进程中的所有应用程序域。       如果你尝试将此属性设置为`false`、<xref:System.ArgumentException>引发异常，即使该属性的当前值是`false`。</xref:System.ArgumentException>       一旦启用了监视，则可以使用<xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>， <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>， <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>，和<xref:System.AppDomain.MonitoringTotalProcessorTime%2A>实例监视 CPU 和内存使用情况的各个应用程序域的属性。</xref:System.AppDomain.MonitoringTotalProcessorTime%2A> </xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A> </xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A> </xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>"
  syntax:
    content: public static bool MonitoringIsEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果启用了监视;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.AppDomain.MonitoringIsEnabled*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "当前进程试图将值分配<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>到此属性。"
  platform:
  - net462
- uid: System.AppDomain.MonitoringSurvivedMemorySize
  id: MonitoringSurvivedMemorySize
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringSurvivedMemorySize
  nameWithType: AppDomain.MonitoringSurvivedMemorySize
  fullName: System.AppDomain.MonitoringSurvivedMemorySize
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取上次回收后保留下来和，已知由当前的应用程序域引用的字节数。"
  remarks: "与每个垃圾回收更新统计信息。 但是，可确保只有在完整、 阻碍性回收; 后才会准确也就是说，的集合包含所有代并停止应用程序时集合时发生。 例如，<xref:System.GC.Collect?displayProperty=fullName>方法重载执行的完整、 阻碍性回收。</xref:System.GC.Collect?displayProperty=fullName> （并发回收发生在后台，并且不会阻止应用程序。）"
  syntax:
    content: public long MonitoringSurvivedMemorySize { get; }
    return:
      type: System.Int64
      description: "保留下来的字节数。"
  overload: System.AppDomain.MonitoringSurvivedMemorySize*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref>在 Visual Basic 中)<xref:System.AppDomain.MonitoringIsEnabled*>属性设置为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.MonitoringSurvivedProcessMemorySize
  id: MonitoringSurvivedProcessMemorySize
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringSurvivedProcessMemorySize
  nameWithType: AppDomain.MonitoringSurvivedProcessMemorySize
  fullName: System.AppDomain.MonitoringSurvivedProcessMemorySize
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取从进程中的所有应用程序域的上次回收后保留下来的总字节数。"
  remarks: "完整的阻碍性回收之后，字节数当前实时上保留该数字表示托管堆。 它应接近其报告的使用期限<xref:System.GC.GetTotalMemory%2A>方法。</xref:System.GC.GetTotalMemory%2A> 暂时回收之后，该数字表示的字节数当前中实时保留暂时代。"
  syntax:
    content: public static long MonitoringSurvivedProcessMemorySize { get; }
    return:
      type: System.Int64
      description: "保留下来的字节的进程总数。"
  overload: System.AppDomain.MonitoringSurvivedProcessMemorySize*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref>在 Visual Basic 中)<xref:System.AppDomain.MonitoringIsEnabled*>属性设置为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.MonitoringTotalAllocatedMemorySize
  id: MonitoringTotalAllocatedMemorySize
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringTotalAllocatedMemorySize
  nameWithType: AppDomain.MonitoringTotalAllocatedMemorySize
  fullName: System.AppDomain.MonitoringTotalAllocatedMemorySize
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取用字节表示，已由应用程序域创建以来，不扣除已回收的内存的所有内存分配的总大小。"
  syntax:
    content: public long MonitoringTotalAllocatedMemorySize { get; }
    return:
      type: System.Int64
      description: "所有内存分配的总大小。"
  overload: System.AppDomain.MonitoringTotalAllocatedMemorySize*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref>在 Visual Basic 中)<xref:System.AppDomain.MonitoringIsEnabled*>属性设置为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.MonitoringTotalProcessorTime
  id: MonitoringTotalProcessorTime
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringTotalProcessorTime
  nameWithType: AppDomain.MonitoringTotalProcessorTime
  fullName: System.AppDomain.MonitoringTotalProcessorTime
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取进程启动后，在当前的应用程序域中，执行时使用的所有线程的总处理器时间。"
  remarks: "应用程序域报告的总时间包括在该应用程序域中执行的过程中的每个线程所用的时间。       调入非托管代码的线程仍关联与应用程序域，并且执行非托管的代码报告应用程序域调用已花费的处理器时间。       当线程被阻止或睡眠，它不占用处理器时间。"
  syntax:
    content: public TimeSpan MonitoringTotalProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "当前的应用程序域的总处理器时间。"
  overload: System.AppDomain.MonitoringTotalProcessorTime*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref>在 Visual Basic 中)<xref:System.AppDomain.MonitoringIsEnabled*>属性设置为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.PermissionSet
  id: PermissionSet
  parent: System.AppDomain
  langs:
  - csharp
  name: PermissionSet
  nameWithType: AppDomain.PermissionSet
  fullName: System.AppDomain.PermissionSet
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取沙盒应用程序域的权限集。"
  remarks: "使用创建的沙盒应用程序域[AppDomain.CreateDomain (字符串、 证据、 AppDomainSetup、 PermissionSet、 StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False)方法重载具有一组同构权限; 也就是说，对所有部分受信任的程序集加载到应用程序域授予相同的权限集。 沙盒应用程序域 （可选） 有不受此权限集，并改为使用完全信任运行具有强名称程序集的列表。"
  syntax:
    content: public System.Security.PermissionSet PermissionSet { get; }
    return:
      type: System.Security.PermissionSet
      description: "沙盒应用程序域的权限集。"
  overload: System.AppDomain.PermissionSet*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ProcessExit
  id: ProcessExit
  parent: System.AppDomain
  langs:
  - csharp
  name: ProcessExit
  nameWithType: AppDomain.ProcessExit
  fullName: System.AppDomain.ProcessExit
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "当默认应用程序域的父进程存在时发生。"
  remarks: "<xref:System.EventHandler>此事件可以执行终止活动，如关闭文件，释放存储空间等，进程结束之前。</xref:System.EventHandler>       从.NET Framework 2.0 版开始，每个应用程序域中注册事件处理程序中引发此事件。      1> [!NOTE]&1;> 所有 ProcessExit 事件处理程序的总执行时间是有限的正如所有终结器的总执行时间是有限进程关闭时一样。 默认值为两秒。 非托管的主机可以通过调用来更改此执行时间[iclrpolicymanager:: Settimeout](~/add/includes/ajax-current-ext-md.md)方法替换[OPR_ProcessExit](~/add/includes/ajax-current-ext-md.md)枚举值。       在.NET framework 1.0 和 1.1 版中，此事件是引发仅在默认应用程序域，且仅当在默认应用程序域中注册事件处理程序。       若要注册的事件处理程序此事件，你必须具有所需的权限，或<xref:System.Security.SecurityException>引发。</xref:System.Security.SecurityException>       有关处理事件的详细信息，请参阅[事件](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public event EventHandler ProcessExit;
    return:
      type: System.EventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ReflectionOnlyAssemblyResolve
  id: ReflectionOnlyAssemblyResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: ReflectionOnlyAssemblyResolve
  nameWithType: AppDomain.ReflectionOnlyAssemblyResolve
  fullName: System.AppDomain.ReflectionOnlyAssemblyResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "程序集的解析在仅限反射上下文中失败时发生。"
  remarks: "在仅限反射上下文中，依赖关系将不自动解析。 它们必须预加载或返回的此事件的处理程序。 当程序集具有尚未加载到只反射上下文的依赖项时，引发此事件。 通过指定缺少的依赖关系<xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>属性。</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName> <xref:System.ResolveEventHandler>此事件必须返回满足此依赖关系的程序集。</xref:System.ResolveEventHandler> 返回程序集必须加载到只反射上下文。      1> [!IMPORTANT]&1;> 仅为缺少的依赖关系，若要加载到只反射上下文的程序集将引发此事件 (例如，通过使用<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=fullName>方法)。</xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=fullName> 它不被引发如果找不到要加载的程序集。       开头[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]、<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>属性返回的请求无法解析的程序集加载的程序集。</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> 了解请求的程序集的标识可能很有用中标识正确版本的依赖项，如果多个版本可用。 有关详细信息，请参阅<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>。</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>       对于此事件，<xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>属性返回的程序集名称，应用策略之前。</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>       有关处理事件的详细信息，请参阅[事件](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public event ResolveEventHandler ReflectionOnlyAssemblyResolve;
    return:
      type: System.ResolveEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ReflectionOnlyGetAssemblies
  id: ReflectionOnlyGetAssemblies
  parent: System.AppDomain
  langs:
  - csharp
  name: ReflectionOnlyGetAssemblies()
  nameWithType: AppDomain.ReflectionOnlyGetAssemblies()
  fullName: System.AppDomain.ReflectionOnlyGetAssemblies()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "返回已加载到应用程序域的只反射上下文的程序集。"
  remarks: "此方法返回已加载到只反射上下文的程序集。 若要获取有关执行的已加载的程序集，请使用<xref:System.AppDomain.GetAssemblies%2A>方法。</xref:System.AppDomain.GetAssemblies%2A>"
  example:
  - "The following code example loads the System.dll assembly into the execution context and then into the reflection-only context. The <xref:System.AppDomain.GetAssemblies%2A> and ReflectionOnlyGetAssemblies methods are used to display the assemblies loaded into each context.  \n  \n [!code-cs[AppDomain.ReflectionOnlyGetAssemblies#1](~/add/codesnippet/csharp/m-system.appdomain.refle_1.cs)]\n [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/add/codesnippet/cpp/m-system.appdomain.refle_1.cpp)]\n [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/add/codesnippet/visualbasic/m-system.appdomain.refle_1.vb)]"
  syntax:
    content: public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();
    parameters: []
    return:
      type: System.Reflection.Assembly[]
      description: "数组<xref:System.Reflection.Assembly>表示程序集的对象加载到应用程序域的只反射上下文。</xref:System.Reflection.Assembly>"
  overload: System.AppDomain.ReflectionOnlyGetAssemblies*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试操作。"
  platform:
  - net462
- uid: System.AppDomain.RelativeSearchPath
  id: RelativeSearchPath
  parent: System.AppDomain
  langs:
  - csharp
  name: RelativeSearchPath
  nameWithType: AppDomain.RelativeSearchPath
  fullName: System.AppDomain.RelativeSearchPath
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取专用程序集在此程序集冲突解决程序应探测的基目录下的路径。"
  remarks: "专用程序集部署在与应用程序相同的目录结构中。 如果 RelativeSearchPath 属性指定的路径不是下<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>，它将被忽略。</xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>       此属性返回的值使用<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>.</xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>设置"
  syntax:
    content: public string RelativeSearchPath { get; }
    return:
      type: System.String
      description: "在此程序集冲突解决程序应探测专用程序集的基目录下的路径。"
  overload: System.AppDomain.RelativeSearchPath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.ResourceResolve
  id: ResourceResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: ResourceResolve
  nameWithType: AppDomain.ResourceResolve
  fullName: System.AppDomain.ResourceResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "当资源解析因资源不是程序集中的有效链接或嵌入资源而失败时发生。"
  remarks: "<xref:System.ResolveEventHandler>此事件可以尝试查找包含该资源的程序集并返回它。</xref:System.ResolveEventHandler>      1> [!IMPORTANT]&1;> 如果解析失败，因为没有文件可以找到有效链接资源，则不会引发此事件。 如果找不到的清单资源流，但它不会引发如果找不到单独的资源键，则将引发此事件。       开头[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]、<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>属性包含请求资源的程序集。</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> 有关详细信息，请参阅<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>。</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>       若要注册的事件处理程序此事件，你必须具有所需的权限，或<xref:System.Security.SecurityException>引发。</xref:System.Security.SecurityException>       有关处理事件的详细信息，请参阅[事件](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public event ResolveEventHandler ResourceResolve;
    return:
      type: System.ResolveEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  id: SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetAppDomainPolicy(PolicyLevel)
  nameWithType: AppDomain.SetAppDomainPolicy(PolicyLevel)
  fullName: System.AppDomain.SetAppDomainPolicy(PolicyLevel)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "确定此应用程序域安全策略级别。"
  remarks: "程序集加载到之前调用此方法<xref:System.AppDomain>顺序安全策略以产生影响。</xref:System.AppDomain>"
  example:
  - "The following example demonstrates how to use the SetAppDomainPolicymethod to set the security policy level of an application domain.  \n  \n [!code-cs[ADSetAppDomainPolicy#1](~/add/codesnippet/csharp/m-system.appdomain.setap_1.cs)]\n [!code-cpp[ADSetAppDomainPolicy#1](~/add/codesnippet/cpp/m-system.appdomain.setap_1.cpp)]\n [!code-vb[ADSetAppDomainPolicy#1](~/add/codesnippet/visualbasic/m-system.appdomain.setap_1.vb)]"
  syntax:
    content: public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);
    parameters:
    - id: domainPolicy
      type: System.Security.Policy.PolicyLevel
      description: "安全策略级别。"
  overload: System.AppDomain.SetAppDomainPolicy*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>domainPolicy</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.Policy.PolicyException
    commentId: T:System.Security.Policy.PolicyException
    description: "安全策略级别已设置。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.SetCachePath(System.String)
  id: SetCachePath(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetCachePath(String)
  nameWithType: AppDomain.SetCachePath(String)
  fullName: System.AppDomain.SetCachePath(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "确定指定的目录路径为程序集进行影像复制的位置。"
  remarks: "如果缓存路径将被忽略<xref:System.AppDomainSetup.ApplicationName%2A>未设置属性。</xref:System.AppDomainSetup.ApplicationName%2A> 请参阅<xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName>属性。</xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName>       卷影复制的详细信息请参阅[影像复制程序集](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public void SetCachePath (string path);
    parameters:
    - id: path
      type: System.String
      description: "到卷影副本位置的完全限定的路径。"
  overload: System.AppDomain.SetCachePath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.SetData(System.String,System.Object)
  id: SetData(System.String,System.Object)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetData(String,Object)
  nameWithType: AppDomain.SetData(String,Object)
  fullName: System.AppDomain.SetData(String,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "将指定的值分配给指定的应用程序域属性。"
  remarks: "使用此方法来插入项时，或者修改描述<xref:System.AppDomain>.</xref:System.AppDomain>此实例的属性的名称数据对内部缓存中的条目的值       该缓存自动包含在创建应用程序域后插入的预定义的系统项。 无法插入或修改系统项使用此方法。 尝试来修改系统条目的方法调用起任何作用;该方法不引发异常。 你可以检查的<xref:System.AppDomain.GetData%2A>方法或<xref:System.AppDomainSetup>属性所述<xref:System.AppDomain.GetData%2A>.</xref:System.AppDomain.GetData%2A></xref:System.AppDomainSetup>等效</xref:System.AppDomain.GetData%2A>系统条目的值       你可以调用此方法以设置由供电&quot;REGEX_DEFAULT_MATCH_TIMEOUT&quot;评估正则表达式模式的默认超时间隔的值的值作为`name`自变量和一个<xref:System.TimeSpan>值，该值表示超时间隔的值作为`data`自变量。</xref:System.TimeSpan> 此外可以插入或修改你自己的用户定义名称数据对使用此方法，并检查它们的值与<xref:System.AppDomain.GetData%2A>方法。</xref:System.AppDomain.GetData%2A>"
  example:
  - "The following example demonstrates how to use the SetData method to create a new value pair. The example then uses the <xref:System.AppDomain.GetData%2A> method to retrieve the value, and displays it to the console.  \n  \n [!code-cpp[ADGetData#1](~/add/codesnippet/cpp/m-system.appdomain.setda_1.cpp)]\n [!code-vb[ADGetData#1](~/add/codesnippet/visualbasic/m-system.appdomain.setda_1.vb)]\n [!code-cs[ADGetData#1](~/add/codesnippet/csharp/m-system.appdomain.setda_1.cs)]"
  syntax:
    content: public void SetData (string name, object data);
    parameters:
    - id: name
      type: System.String
      description: "要创建或更改的用户定义的应用程序域属性的名称。"
    - id: data
      type: System.Object
      description: "属性的值。"
  overload: System.AppDomain.SetData*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)
  id: SetData(System.String,System.Object,System.Security.IPermission)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetData(String,Object,IPermission)
  nameWithType: AppDomain.SetData(String,Object,IPermission)
  fullName: System.AppDomain.SetData(String,Object,IPermission)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "将指定的值分配给指定的应用程序域属性，具有对需求的指定权限的调用方时检索该属性。"
  remarks: "此方法用于插入或修改你自己描述应用程序域的属性的名称/数据对的内部缓存中的用户定义条目。 当将一个条目时，你可以指定权限请求来强制执行时检索条目。此外，可以调用此方法以设置由供电&quot;REGEX_DEFAULT_MATCH_TIMEOUT&quot;评估正则表达式模式的默认超时间隔的值的值作为`name`自变量和一个<xref:System.TimeSpan>值，该值表示超时间隔的值作为`data`自变量。</xref:System.TimeSpan>       此方法不能用于将安全要求分配给系统定义的属性字符串。       该缓存自动包含在创建应用程序域后插入的预定义的系统项。 无法插入或修改系统项使用此方法。 尝试来修改系统条目的方法调用起任何作用;该方法不引发异常。 你可以检查与系统项的值<xref:System.AppDomain.GetData%2A>方法或等效<xref:System.AppDomainSetup>属性中的备注部分所述<xref:System.AppDomain.GetData%2A>方法。</xref:System.AppDomain.GetData%2A> </xref:System.AppDomainSetup> </xref:System.AppDomain.GetData%2A>"
  syntax:
    content: public void SetData (string name, object data, System.Security.IPermission permission);
    parameters:
    - id: name
      type: System.String
      description: "要创建或更改的用户定义的应用程序域属性的名称。"
    - id: data
      type: System.Object
      description: "属性的值。"
    - id: permission
      type: System.Security.IPermission
      description: "对请求时已检索该属性调用方的权限。"
  overload: System.AppDomain.SetData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>name</code>指定系统定义的属性字符串和<code>permission</code>不<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.AppDomain.SetDynamicBase(System.String)
  id: SetDynamicBase(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetDynamicBase(String)
  nameWithType: AppDomain.SetDynamicBase(String)
  fullName: System.AppDomain.SetDynamicBase(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "确定指定的目录路径为的存储和访问动态生成的文件的子目录的基目录。"
  remarks: "此方法会设置<xref:System.AppDomainSetup.DynamicBase%2A>内部属性<xref:System.AppDomainSetup>与此实例关联。</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.DynamicBase%2A>"
  example:
  - "This method is now obsolete, and should not be used for new development. The following example shows how to use the non-obsolete alternative, the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> property. For an explanation of this example, see the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> property or the <xref:System.AppDomain.DynamicDirectory%2A> property.  \n  \n [!code-cpp[ADDynamicBase#1](~/add/codesnippet/cpp/m-system.appdomain.setdy_1.cpp)]\n [!code-cs[ADDynamicBase#1](~/add/codesnippet/csharp/m-system.appdomain.setdy_1.cs)]\n [!code-vb[ADDynamicBase#1](~/add/codesnippet/visualbasic/m-system.appdomain.setdy_1.vb)]"
  syntax:
    content: public void SetDynamicBase (string path);
    parameters:
    - id: path
      type: System.String
      description: "是动态程序集的存储位置的子目录的基目录的完全限定的路径。"
  overload: System.AppDomain.SetDynamicBase*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  id: SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetPrincipalPolicy(PrincipalPolicy)
  nameWithType: AppDomain.SetPrincipalPolicy(PrincipalPolicy)
  fullName: System.AppDomain.SetPrincipalPolicy(PrincipalPolicy)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "指定如何主体和标识对象应附加到线程如果线程尝试在此应用程序域中执行时绑定到主体。"
  remarks: "设置此值才有效，如果你在使用前设置<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>属性。</xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> 例如，如果你设置<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>到给定的主体 （例如，泛型主体），然后使用 SetPrincipalPolicy 方法以设置<xref:System.Security.Principal.PrincipalPolicy>到<xref:System.Security.Principal.PrincipalPolicy>，当前主体将保持泛型主体。</xref:System.Security.Principal.PrincipalPolicy> </xref:System.Security.Principal.PrincipalPolicy> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>"
  example:
  - "The following example shows the effect on threads of using the SetPrincipalPolicy method to change the principal policy of the application domain. It also shows the effect of using the <xref:System.AppDomain.SetThreadPrincipal%2A> method to change the principal that is available for attaching to threads in the application domain.  \n  \n [!code-cpp[ADPrincipal#1](~/add/codesnippet/cpp/m-system.appdomain.setpr_1.cpp)]\n [!code-vb[ADPrincipal#1](~/add/codesnippet/visualbasic/m-system.appdomain.setpr_1.vb)]\n [!code-cs[ADPrincipal#1](~/add/codesnippet/csharp/m-system.appdomain.setpr_1.cs)]"
  syntax:
    content: public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);
    parameters:
    - id: policy
      type: System.Security.Principal.PrincipalPolicy
      description: "之一<xref href=&quot;System.Security.Principal.PrincipalPolicy&quot;></xref>指定要附加到线程的主体对象的类型的值。"
  overload: System.AppDomain.SetPrincipalPolicy*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.SetShadowCopyFiles
  id: SetShadowCopyFiles
  parent: System.AppDomain
  langs:
  - csharp
  name: SetShadowCopyFiles()
  nameWithType: AppDomain.SetShadowCopyFiles()
  fullName: System.AppDomain.SetShadowCopyFiles()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "打开影像复制。"
  remarks: "卷影复制的详细信息，请参阅[影像复制程序集](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "This method is now obsolete, and should not be used for new development.  \n  \n [!code-cpp[adproperties#1](~/add/codesnippet/cpp/m-system.appdomain.setsh_0_1.cpp)]\n [!code-vb[adproperties#1](~/add/codesnippet/visualbasic/m-system.appdomain.setsh_0_1.vb)]\n [!code-cs[adproperties#1](~/add/codesnippet/csharp/m-system.appdomain.setsh_0_1.cs)]"
  syntax:
    content: public void SetShadowCopyFiles ();
    parameters: []
  overload: System.AppDomain.SetShadowCopyFiles*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.SetShadowCopyPath(System.String)
  id: SetShadowCopyPath(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetShadowCopyPath(String)
  nameWithType: AppDomain.SetShadowCopyPath(String)
  fullName: System.AppDomain.SetShadowCopyPath(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "确定指定的目录路径为要进行卷影复制的程序集的位置。"
  remarks: "默认情况下，卷影副本包括通过探测所发现的所有程序集。 SetShadowCopyPath 方法将卷影副本限制到指定的目录中的程序集`path`。       SetShadowCopyPath 方法未指定要在其中搜索程序集的其他目录。 要进行影像复制程序集已必须位于的搜索路径，例如在<xref:System.AppDomain.BaseDirectory%2A>.</xref:System.AppDomain.BaseDirectory%2A> SetShadowCopyPath 方法指定的搜索路径有资格卷影复制。       此方法会设置<xref:System.AppDomainSetup.ShadowCopyDirectories%2A>内部属性<xref:System.AppDomainSetup>与此实例关联。</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.ShadowCopyDirectories%2A>       卷影复制的详细信息，请参阅[影像复制程序集](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "This method is now obsolete, and should not be used for new development.  \n  \n [!code-cpp[ADShadowCopy#1](~/add/codesnippet/cpp/m-system.appdomain.setsh_1_1.cpp)]\n [!code-vb[ADShadowCopy#1](~/add/codesnippet/visualbasic/m-system.appdomain.setsh_1_1.vb)]\n [!code-cs[ADShadowCopy#1](~/add/codesnippet/csharp/m-system.appdomain.setsh_1_1.cs)]"
  syntax:
    content: public void SetShadowCopyPath (string path);
    parameters:
    - id: path
      type: System.String
      description: "目录名称，其中每个名称用分号隔开的列表。"
  overload: System.AppDomain.SetShadowCopyPath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)
  id: SetThreadPrincipal(System.Security.Principal.IPrincipal)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetThreadPrincipal(IPrincipal)
  nameWithType: AppDomain.SetThreadPrincipal(IPrincipal)
  fullName: System.AppDomain.SetThreadPrincipal(IPrincipal)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "设置要附加到线程中，如果用户尝试在此应用程序域中执行时绑定到用户的默认主体对象。"
  remarks: ''
  example:
  - "The following example shows the effect of using the SetThreadPrincipal method to change the principal that is available for attaching to threads that are executing in the application domain. It also shows the effect on threads of using the <xref:System.AppDomain.SetPrincipalPolicy%2A> method to change the principal policy of the application domain.  \n  \n [!code-cpp[ADPrincipal#1](~/add/codesnippet/cpp/m-system.appdomain.setth_1.cpp)]\n [!code-vb[ADPrincipal#1](~/add/codesnippet/visualbasic/m-system.appdomain.setth_1.vb)]\n [!code-cs[ADPrincipal#1](~/add/codesnippet/csharp/m-system.appdomain.setth_1.cs)]"
  syntax:
    content: public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);
    parameters:
    - id: principal
      type: System.Security.Principal.IPrincipal
      description: "要附加到线程的主体对象。"
  overload: System.AppDomain.SetThreadPrincipal*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>principal</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.Policy.PolicyException
    commentId: T:System.Security.Policy.PolicyException
    description: "已设置线程的主体。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.SetupInformation
  id: SetupInformation
  parent: System.AppDomain
  langs:
  - csharp
  name: SetupInformation
  nameWithType: AppDomain.SetupInformation
  fullName: System.AppDomain.SetupInformation
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取此实例的应用程序域配置信息。"
  syntax:
    content: public AppDomainSetup SetupInformation { get; }
    return:
      type: System.AppDomainSetup
      description: "应用程序域初始化信息。"
  overload: System.AppDomain.SetupInformation*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.ShadowCopyFiles
  id: ShadowCopyFiles
  parent: System.AppDomain
  langs:
  - csharp
  name: ShadowCopyFiles
  nameWithType: AppDomain.ShadowCopyFiles
  fullName: System.AppDomain.ShadowCopyFiles
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取应用程序域配置为卷影副本文件的指示。"
  remarks: "有关详细信息，请参阅<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName>和[影像复制程序集](~/add/includes/ajax-current-ext-md.md)。</xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName>"
  syntax:
    content: public bool ShadowCopyFiles { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果应用程序域是否配置为卷影副本文件;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.AppDomain.ShadowCopyFiles*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "卸载的应用程序域上尝试该操作。"
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  id: System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "将一组名称映射到对应的一组调度标识符。"
  remarks: "此方法用于访问托管类从非托管代码，不应从托管代码调用。 有关详细信息`IDispatch::GetIDsOfNames`，请参阅 MSDN 库。"
  syntax:
    content: void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
    parameters:
    - id: riid
      type: System.Guid
      description: "保留供将来使用。 必须为 IID_NULL。"
    - id: rgszNames
      type: System.IntPtr
      description: "传递数组要映射的名称。"
    - id: cNames
      type: System.UInt32
      description: "要映射的名称的计数。"
    - id: lcid
      type: System.UInt32
      description: "在其中解释名称的区域设置上下文。"
    - id: rgDispId
      type: System.IntPtr
      description: "调用方分配的数组用于接收与名称对应的 Id。"
  overload: System.AppDomain.System#_AppDomain#GetIDsOfNames*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "使用 COM 的后期绑定访问`IDispatch`接口不支持。"
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  id: System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "检索一个对象，它用于获取接口的类型信息的类型信息。"
  remarks: "此方法用于访问托管类从非托管代码，不应从托管代码调用。 有关详细信息`IDispatch::GetTypeInfo`，请参阅 MSDN 库。"
  syntax:
    content: void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);
    parameters:
    - id: iTInfo
      type: System.UInt32
      description: "要返回的类型信息。"
    - id: lcid
      type: System.UInt32
      description: "类型信息的区域设置标识符。"
    - id: ppTInfo
      type: System.IntPtr
      description: "接收一个指针，指向请求的类型信息对象。"
  overload: System.AppDomain.System#_AppDomain#GetTypeInfo*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "使用 COM 的后期绑定访问`IDispatch`接口不支持。"
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  id: System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.GetTypeInfoCount(UInt32)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "检索对象提供 （0 或 1） 的类型信息接口的数量。"
  remarks: "此方法用于访问托管类从非托管代码，不应从托管代码调用。 有关详细信息`IDispatch::GetTypeInfoCount`，请参阅 MSDN 库。"
  syntax:
    content: void _AppDomain.GetTypeInfoCount (out uint pcTInfo);
    parameters:
    - id: pcTInfo
      type: System.UInt32
      description: "指向接收对象提供的类型信息接口的数量的位置。"
  overload: System.AppDomain.System#_AppDomain#GetTypeInfoCount*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "使用 COM 的后期绑定访问`IDispatch`接口不支持。"
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  id: System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "提供对由对象公开属性和方法访问。"
  remarks: "此方法用于访问托管类从非托管代码，不应从托管代码调用。 有关详细信息`IDispatch::Invoke`，请参阅 MSDN 库。"
  syntax:
    content: void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    parameters:
    - id: dispIdMember
      type: System.UInt32
      description: "标识成员。"
    - id: riid
      type: System.Guid
      description: "保留供将来使用。 必须为 IID_NULL。"
    - id: lcid
      type: System.UInt32
      description: "在其中解释自变量的区域设置上下文。"
    - id: wFlags
      type: System.Int16
      description: "描述调用的上下文的标志。"
    - id: pDispParams
      type: System.IntPtr
      description: "包含参数的数组，数组的命名自变量和数组中元素数的计数 dispid 的结构的指针。"
    - id: pVarResult
      type: System.IntPtr
      description: "到其中的结果是要存储的位置的指针。"
    - id: pExcepInfo
      type: System.IntPtr
      description: "指向包含异常信息的结构的指针。"
    - id: puArgErr
      type: System.IntPtr
      description: "出错的第一个参数的索引。"
  overload: System.AppDomain.System#_AppDomain#Invoke*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "使用 COM 的后期绑定访问`IDispatch`接口不支持。"
  platform:
  - net462
- uid: System.AppDomain.ToString
  id: ToString
  parent: System.AppDomain
  langs:
  - csharp
  name: ToString()
  nameWithType: AppDomain.ToString()
  fullName: System.AppDomain.ToString()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取包含应用程序域和任意上下文策略的友好名称的字符串表示形式。"
  remarks: ''
  example:
  - "The following code example displays the return value of the ToString method.  \n  \n [!code-cpp[ADToString#1](~/add/codesnippet/cpp/m-system.appdomain.tostr_1.cpp)]\n [!code-cs[ADToString#1](~/add/codesnippet/csharp/m-system.appdomain.tostr_1.cs)]\n [!code-vb[ADToString#1](~/add/codesnippet/visualbasic/m-system.appdomain.tostr_1.vb)]"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "字符串的格式正确的连接字符串&quot;名称:&quot;，应用程序域以及上下文策略的字符串表示或字符串&quot;There are no context policies。&quot;的友好名称"
  overload: System.AppDomain.ToString*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "表示由当前的应用程序域<xref href=&quot;System.AppDomain&quot;></xref>已卸载。"
  platform:
  - net462
- uid: System.AppDomain.TypeResolve
  id: TypeResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: TypeResolve
  nameWithType: AppDomain.TypeResolve
  fullName: System.AppDomain.TypeResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "一种类型的解析失败时发生。"
  remarks: "当公共语言运行时不能确定程序集，可以创建请求的类型时，将发生 TypeResolve 事件。 如果在动态程序集，定义的类型或类型未定义动态程序集中，但运行时不知道程序集类型中定义的类型便会出现此问题。 后一种情况可能发生时<xref:System.Type.GetType%2A?displayProperty=fullName>调用时使用程序集名称未限定的类型名称。</xref:System.Type.GetType%2A?displayProperty=fullName>       <xref:System.ResolveEventHandler>为此事件可以尝试查找并创建类型。</xref:System.ResolveEventHandler>       但是，如果运行时知道不能以查找特定的程序集中的类型，也不会发生 TypeResolve 事件。 例如，如果因为运行时知道类型不能动态添加到静态程序集不在静态程序集中找到了类型，也不会发生此事件。       开头[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]、<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>属性包含请求的类型的程序集。</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> 有关详细信息，请参阅<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>。</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>       若要注册的事件处理程序此事件，你必须具有所需的权限，或<xref:System.Security.SecurityException>引发。</xref:System.Security.SecurityException>       有关处理事件的详细信息，请参阅[事件](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following sample demonstrates the TypeResolve event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_TypeResolve#1](~/add/codesnippet/csharp/e-system.appdomain.typer_1.cs)]\n [!code-vb[AppDomain_TypeResolve#1](~/add/codesnippet/visualbasic/e-system.appdomain.typer_1.vb)]\n [!code-cpp[AppDomain_TypeResolve#1](~/add/codesnippet/cpp/e-system.appdomain.typer_1.cpp)]"
  syntax:
    content: public event ResolveEventHandler TypeResolve;
    return:
      type: System.ResolveEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.UnhandledException
  id: UnhandledException
  parent: System.AppDomain
  langs:
  - csharp
  name: UnhandledException
  nameWithType: AppDomain.UnhandledException
  fullName: System.AppDomain.UnhandledException
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "当某个异常未被捕获时发生。"
  remarks: "此事件提供通知未捕获的异常。 它允许应用程序来记录有关异常的信息，系统默认处理程序将异常报告给用户和终止应用程序之前。 如果提供了有关状态的应用程序的足够信息，可以采取其他措施-例如保存更高版本的恢复的程序数据。 建议小心，因为不处理异常时，可能会损坏程序数据。      1> [!NOTE] 1> 在.NET framework 1.0 和 1.1 版中，应用程序终止时和调试选项会报告给用户将引发此事件之前，而不是之后。       可以在任何应用程序域中处理此事件。 但是，引发该事件是不一定在何处出现异常的应用程序域中。 仅当没有找到适用的异常处理程序，因此可以引发该事件的第一个位置是在生成该线程的应用程序域已被线程的整个堆栈展开，会处理异常。      1> [!NOTE] 1> 在.NET Framework 1.0 和 1.1 版中，会发生此事件仅为应用程序启动时由系统创建的默认应用程序域。 如果应用程序创建其他应用程序域，在这些应用程序域中指定为此事件的委托无效。       如果 UnhandledException 事件在默认应用程序域中处理，引发该事件那里任何线程，无论该线程启动中哪些应用程序域中任何未处理异常。 如果线程启动的应用程序域中具有 UnhandledException 事件处理程序，该应用程序域中将引发事件。 如果该应用程序域不是默认应用程序域，并且还存在一个事件处理程序在默认应用程序域中，将两个应用程序域中引发事件。       例如，假设在线程启动应用程序域&quot;AD1&quot;应用程序域&quot;AD2&quot;中调用的方法，并从那里调用的方法在应用程序域&quot;AD3&quot;，它将引发异常。 可以在其中引发 UnhandledException 事件的第一个应用程序域是&quot;AD1&quot;。 如果该应用程序域不是默认应用程序域，那么还可以在默认应用程序域中引发事件。      1> [!NOTE]&1;> UnhandledException 事件的事件处理程序执行时，公共语言运行时挂起线程中止。       如果事件处理程序具有<xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>属性具有相应的标志，事件处理程序被视为受约束的执行区域。</xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>       从开始[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]，此事件不会引发的异常的损坏状态的进程，如堆栈溢出或访问冲突，除非事件处理程序是安全关键，并且具有<xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>属性。</xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>       在.NET framework 1.0 和 1.1 版中，在主应用程序线程外的线程中出现未经处理的异常将由运行时捕获，并因此不会导致应用程序终止。 因此，很可能在不终止的应用程序的情况下引发 UnhandledException 事件。 从.NET Framework 2.0 版开始，此对子子线程中未经处理的异常已被移除，因为这种无提示故障的累积效应包括性能下降，损坏的数据和锁定，它们都很难进行调试。 有关详细信息，包括列表的情况下在其中运行时不会终止，请参阅[托管线程中的异常](~/add/includes/ajax-current-ext-md.md)。       若要注册的事件处理程序此事件，你必须具有所需的权限，或<xref:System.Security.SecurityException>引发。</xref:System.Security.SecurityException>       有关处理事件的详细信息，请参阅[事件](~/add/includes/ajax-current-ext-md.md)。      ## 某些应用程序的未处理异常的其他事件模型时，的 UnhandledException 事件可以由其他事件抢先，如果在主应用程序线程中出现未经处理的异常。       使用 Windows 窗体的应用程序中未经处理的异常中的主应用程序线程原因<xref:System.Windows.Forms.Application.ThreadException?displayProperty=fullName>引发事件。</xref:System.Windows.Forms.Application.ThreadException?displayProperty=fullName> 如果处理此事件，默认行为是未处理的异常不会终止该应用程序，尽管应用程序处于未知状态。 在这种情况下，则不会引发 UnhandledException 事件。 可以更改此行为，通过使用应用程序配置文件，或通过<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=fullName>方法来将模式更改为<xref:System.Windows.Forms.UnhandledExceptionMode?displayProperty=fullName>之前的<xref:System.Windows.Forms.Application.ThreadException>事件处理程序已挂钩相符。</xref:System.Windows.Forms.Application.ThreadException> </xref:System.Windows.Forms.UnhandledExceptionMode?displayProperty=fullName> </xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=fullName> 这仅适用于主应用程序线程。 引发在其他线程的未处理异常的情况下，将引发 UnhandledException 事件。       Visual Basic 应用程序框架从 Microsoft Visual Studio 2005 开始，提供有关在主应用程序线程中未经处理的异常的另一个事件。 请参阅<xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=fullName>事件。</xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=fullName> 此事件有一个事件自变量对象与 UnhandledException，使用的事件自变量对象同名但具有不同的属性。 具体而言，此事件自变量对象具有<xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A>属性，它允许应用程序能够继续运行，忽略未经处理的异常 （并会使应用程序处于未知状态）。</xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> 在这种情况下，则不会引发 UnhandledException 事件。"
  example:
  - "The followingexample demonstrates the UnhandledException event. It defines an event handler, `MyHandler`, that is invoked whenever an unhandled exception is thrown in the default application domain. It then throws two exceptions. The first is handled by a **try/catch** block. The second is unhandled and invokes the `MyHandle` routine before the application terminates.  \n  \n [!code-cs[AppDomain_UnhandledException#1](~/add/codesnippet/csharp/e-system.appdomain.unhan_1.cs)]\n [!code-vb[AppDomain_UnhandledException#1](~/add/codesnippet/visualbasic/e-system.appdomain.unhan_1.vb)]\n [!code-cpp[AppDomain_UnhandledException#1](~/add/codesnippet/cpp/e-system.appdomain.unhan_1.cpp)]"
  syntax:
    content: public event UnhandledExceptionEventHandler UnhandledException;
    return:
      type: System.UnhandledExceptionEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.Unload(System.AppDomain)
  id: Unload(System.AppDomain)
  parent: System.AppDomain
  langs:
  - csharp
  name: Unload(AppDomain)
  nameWithType: AppDomain.Unload(AppDomain)
  fullName: System.AppDomain.Unload(AppDomain)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "卸载指定的应用程序域。"
  remarks: ".NET Framework 2.0 版中没有一个线程专用于卸载应用程序域。 这将提高可靠性，尤其是在.NET Framework 承载。 当线程调用卸载时，目标域标记为要卸载。 专用的线程尝试卸载的域和域中的所有线程都将立即都中止。 如果一个线程不会中止，例如因为它执行非托管的代码，或是因为正在执行`finally`块，然后在一段时间后的<xref:System.CannotUnloadAppDomainException>最初调用卸载线程中引发。</xref:System.CannotUnloadAppDomainException> 如果不可能最终会中止的线程结束，则目标域不卸载。 因此，在.NET Framework 2.0 版`domain`不能保证卸载，因为它可能不能终止正在执行的线程。      1> [!NOTE]&1;> 在某些情况下，调用卸载会导致立即<xref:System.CannotUnloadAppDomainException>，例如如果就是在终结器。</xref:System.CannotUnloadAppDomainException>       中的线程`domain`被终止使用<xref:System.Threading.Thread.Abort%2A>方法，将引发<xref:System.Threading.ThreadAbortException>线程中。</xref:System.Threading.ThreadAbortException> </xref:System.Threading.Thread.Abort%2A> 尽管线程应立即终止，它可以继续执行可不可预测的时间量中`finally`子句。      ## 版本兼容性在.NET Framework 版本 1.0 和 1.1 中，如果运行调用卸载该线程`domain`，另一个线程开始执行卸载操作。 如果`domain`无法卸载， <xref:System.CannotUnloadAppDomainException>，不在原始线程调用卸载该线程中引发。</xref:System.CannotUnloadAppDomainException> 但是，如果调用的线程，则卸载运行外部`domain`，线程将收到异常。"
  example:
  - "The following code example shows how to unload an application domain.  \n  \n [!code-cpp[ADUnload#1](~/add/codesnippet/cpp/m-system.appdomain.unloa_1.cpp)]\n [!code-vb[ADUnload#1](~/add/codesnippet/visualbasic/m-system.appdomain.unloa_1.vb)]\n [!code-cs[ADUnload#1](~/add/codesnippet/csharp/m-system.appdomain.unloa_1.cs)]"
  syntax:
    content: public static void Unload (AppDomain domain);
    parameters:
    - id: domain
      type: System.AppDomain
      description: "卸载应用程序域。"
  overload: System.AppDomain.Unload*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>domain</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.CannotUnloadAppDomainException
    commentId: T:System.CannotUnloadAppDomainException
    description: "<code>domain</code>无法卸载。"
  - type: System.Exception
    commentId: T:System.Exception
    description: "在卸载过程中出错。"
  platform:
  - net462
references:
- uid: System.MarshalByRefObject
  isExternal: false
  name: System.MarshalByRefObject
- uid: System.AppDomainUnloadedException
  parent: System
  isExternal: false
  name: AppDomainUnloadedException
  nameWithType: AppDomainUnloadedException
  fullName: System.AppDomainUnloadedException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.TypeLoadException
  isExternal: true
  name: System.TypeLoadException
- uid: System.MissingMethodException
  isExternal: true
  name: System.MissingMethodException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.MemberAccessException
  isExternal: true
  name: System.MemberAccessException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.BadImageFormatException
  isExternal: true
  name: System.BadImageFormatException
- uid: System.IO.FileLoadException
  isExternal: true
  name: System.IO.FileLoadException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.MethodAccessException
  isExternal: true
  name: System.MethodAccessException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Security.Policy.PolicyException
  parent: System.Security.Policy
  isExternal: false
  name: PolicyException
  nameWithType: PolicyException
  fullName: System.Security.Policy.PolicyException
- uid: System.NotImplementedException
  isExternal: true
  name: System.NotImplementedException
- uid: System.CannotUnloadAppDomainException
  parent: System
  isExternal: false
  name: CannotUnloadAppDomainException
  nameWithType: CannotUnloadAppDomainException
  fullName: System.CannotUnloadAppDomainException
- uid: System.Exception
  isExternal: true
  name: System.Exception
- uid: System.AppDomain.ActivationContext
  parent: System.AppDomain
  isExternal: false
  name: ActivationContext
  nameWithType: AppDomain.ActivationContext
  fullName: System.AppDomain.ActivationContext
- uid: System.ActivationContext
  parent: System
  isExternal: false
  name: ActivationContext
  nameWithType: ActivationContext
  fullName: System.ActivationContext
- uid: System.AppDomain.AppendPrivatePath(System.String)
  parent: System.AppDomain
  isExternal: false
  name: AppendPrivatePath(String)
  nameWithType: AppDomain.AppendPrivatePath(String)
  fullName: System.AppDomain.AppendPrivatePath(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.AppDomain.ApplicationIdentity
  parent: System.AppDomain
  isExternal: false
  name: ApplicationIdentity
  nameWithType: AppDomain.ApplicationIdentity
  fullName: System.AppDomain.ApplicationIdentity
- uid: System.ApplicationIdentity
  parent: System
  isExternal: false
  name: ApplicationIdentity
  nameWithType: ApplicationIdentity
  fullName: System.ApplicationIdentity
- uid: System.AppDomain.ApplicationTrust
  parent: System.AppDomain
  isExternal: false
  name: ApplicationTrust
  nameWithType: AppDomain.ApplicationTrust
  fullName: System.AppDomain.ApplicationTrust
- uid: System.Security.Policy.ApplicationTrust
  parent: System.Security.Policy
  isExternal: false
  name: ApplicationTrust
  nameWithType: ApplicationTrust
  fullName: System.Security.Policy.ApplicationTrust
- uid: System.AppDomain.ApplyPolicy(System.String)
  parent: System.AppDomain
  isExternal: false
  name: ApplyPolicy(String)
  nameWithType: AppDomain.ApplyPolicy(String)
  fullName: System.AppDomain.ApplyPolicy(String)
- uid: System.AppDomain.AssemblyLoad
  parent: System.AppDomain
  isExternal: false
  name: AssemblyLoad
  nameWithType: AppDomain.AssemblyLoad
  fullName: System.AppDomain.AssemblyLoad
- uid: System.AssemblyLoadEventHandler
  parent: System
  isExternal: false
  name: AssemblyLoadEventHandler
  nameWithType: AssemblyLoadEventHandler
  fullName: System.AssemblyLoadEventHandler
- uid: System.AppDomain.AssemblyResolve
  parent: System.AppDomain
  isExternal: false
  name: AssemblyResolve
  nameWithType: AppDomain.AssemblyResolve
  fullName: System.AppDomain.AssemblyResolve
- uid: System.ResolveEventHandler
  parent: System
  isExternal: false
  name: ResolveEventHandler
  nameWithType: ResolveEventHandler
  fullName: System.ResolveEventHandler
- uid: System.AppDomain.BaseDirectory
  parent: System.AppDomain
  isExternal: false
  name: BaseDirectory
  nameWithType: AppDomain.BaseDirectory
  fullName: System.AppDomain.BaseDirectory
- uid: System.AppDomain.ClearPrivatePath
  parent: System.AppDomain
  isExternal: false
  name: ClearPrivatePath()
  nameWithType: AppDomain.ClearPrivatePath()
  fullName: System.AppDomain.ClearPrivatePath()
- uid: System.AppDomain.ClearShadowCopyPath
  parent: System.AppDomain
  isExternal: false
  name: ClearShadowCopyPath()
  nameWithType: AppDomain.ClearShadowCopyPath()
  fullName: System.AppDomain.ClearShadowCopyPath()
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateComInstanceFrom(String,String)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String)
- uid: System.Runtime.Remoting.ObjectHandle
  parent: System.Runtime.Remoting
  isExternal: false
  name: ObjectHandle
  nameWithType: ObjectHandle
  fullName: System.Runtime.Remoting.ObjectHandle
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  isExternal: false
  name: CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Configuration.Assemblies.AssemblyHashAlgorithm
  parent: System.Configuration.Assemblies
  isExternal: false
  name: AssemblyHashAlgorithm
  nameWithType: AssemblyHashAlgorithm
  fullName: System.Configuration.Assemblies.AssemblyHashAlgorithm
- uid: System.AppDomain.CreateDomain(System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String)
  nameWithType: AppDomain.CreateDomain(String)
  fullName: System.AppDomain.CreateDomain(String)
- uid: System.AppDomain
  parent: System
  isExternal: false
  name: AppDomain
  nameWithType: AppDomain
  fullName: System.AppDomain
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence)
  nameWithType: AppDomain.CreateDomain(String,Evidence)
  fullName: System.AppDomain.CreateDomain(String,Evidence)
- uid: System.Security.Policy.Evidence
  parent: System.Security.Policy
  isExternal: false
  name: Evidence
  nameWithType: Evidence
  fullName: System.Security.Policy.Evidence
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,AppDomainSetup)
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
- uid: System.AppDomainSetup
  parent: System
  isExternal: false
  name: AppDomainSetup
  nameWithType: AppDomainSetup
  fullName: System.AppDomainSetup
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
- uid: System.Security.PermissionSet
  parent: System.Security
  isExternal: false
  name: PermissionSet
  nameWithType: PermissionSet
  fullName: System.Security.PermissionSet
- uid: System.Security.Policy.StrongName[]
  parent: System.Security.Policy
  isExternal: false
  name: StrongName
  nameWithType: StrongName
  fullName: System.Security.Policy.StrongName[]
  spec.csharp:
  - uid: System.Security.Policy.StrongName
    name: StrongName
    nameWithType: StrongName
    fullName: StrongName[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,String,String,Boolean)
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
- uid: System.AppDomainInitializer
  parent: System
  isExternal: false
  name: AppDomainInitializer
  nameWithType: AppDomainInitializer
  fullName: System.AppDomainInitializer
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.CreateInstance(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String)
  nameWithType: AppDomain.CreateInstance(String,String)
  fullName: System.AppDomain.CreateInstance(String,String)
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Object[])
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.Reflection.BindingFlags
  parent: System.Reflection
  isExternal: false
  name: BindingFlags
  nameWithType: BindingFlags
  fullName: System.Reflection.BindingFlags
- uid: System.Reflection.Binder
  parent: System.Reflection
  isExternal: false
  name: Binder
  nameWithType: Binder
  fullName: System.Reflection.Binder
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: true
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String)
  nameWithType: AppDomain.CreateInstanceFrom(String,String)
  fullName: System.AppDomain.CreateInstanceFrom(String,String)
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Object[])
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String)
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CurrentDomain
  parent: System.AppDomain
  isExternal: false
  name: CurrentDomain
  nameWithType: AppDomain.CurrentDomain
  fullName: System.AppDomain.CurrentDomain
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
- uid: System.Reflection.Emit.AssemblyBuilder
  parent: System.Reflection.Emit
  isExternal: true
  name: AssemblyBuilder
  nameWithType: AssemblyBuilder
  fullName: System.Reflection.Emit.AssemblyBuilder
- uid: System.Reflection.AssemblyName
  parent: System.Reflection
  isExternal: true
  name: AssemblyName
  nameWithType: AssemblyName
  fullName: System.Reflection.AssemblyName
- uid: System.Reflection.Emit.AssemblyBuilderAccess
  parent: System.Reflection.Emit
  isExternal: true
  name: AssemblyBuilderAccess
  nameWithType: AssemblyBuilderAccess
  fullName: System.Reflection.Emit.AssemblyBuilderAccess
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
- uid: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<CustomAttributeBuilder>
  nameWithType: IEnumerable<CustomAttributeBuilder>
  fullName: System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.Reflection.Emit.CustomAttributeBuilder>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Reflection.Emit.CustomAttributeBuilder
    name: CustomAttributeBuilder
    nameWithType: CustomAttributeBuilder
    fullName: CustomAttributeBuilder
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
- uid: System.Security.SecurityContextSource
  parent: System.Security
  isExternal: false
  name: SecurityContextSource
  nameWithType: SecurityContextSource
  fullName: System.Security.SecurityContextSource
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
- uid: System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)
  parent: System.AppDomain
  isExternal: false
  name: DoCallBack(CrossAppDomainDelegate)
  nameWithType: AppDomain.DoCallBack(CrossAppDomainDelegate)
  fullName: System.AppDomain.DoCallBack(CrossAppDomainDelegate)
- uid: System.CrossAppDomainDelegate
  parent: System
  isExternal: false
  name: CrossAppDomainDelegate
  nameWithType: CrossAppDomainDelegate
  fullName: System.CrossAppDomainDelegate
- uid: System.AppDomain.DomainManager
  parent: System.AppDomain
  isExternal: false
  name: DomainManager
  nameWithType: AppDomain.DomainManager
  fullName: System.AppDomain.DomainManager
- uid: System.AppDomainManager
  parent: System
  isExternal: false
  name: AppDomainManager
  nameWithType: AppDomainManager
  fullName: System.AppDomainManager
- uid: System.AppDomain.DomainUnload
  parent: System.AppDomain
  isExternal: false
  name: DomainUnload
  nameWithType: AppDomain.DomainUnload
  fullName: System.AppDomain.DomainUnload
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.AppDomain.DynamicDirectory
  parent: System.AppDomain
  isExternal: false
  name: DynamicDirectory
  nameWithType: AppDomain.DynamicDirectory
  fullName: System.AppDomain.DynamicDirectory
- uid: System.AppDomain.Evidence
  parent: System.AppDomain
  isExternal: false
  name: Evidence
  nameWithType: AppDomain.Evidence
  fullName: System.AppDomain.Evidence
- uid: System.AppDomain.ExecuteAssembly(System.String)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String)
  nameWithType: AppDomain.ExecuteAssembly(String)
  fullName: System.AppDomain.ExecuteAssembly(String)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,Evidence)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence)
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,String[])
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[])
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
- uid: System.AppDomain.ExecuteAssemblyByName(System.String)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String)
  nameWithType: AppDomain.ExecuteAssemblyByName(String)
  fullName: System.AppDomain.ExecuteAssemblyByName(String)
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(AssemblyName,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String,Evidence)
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence)
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence)
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,String[])
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
- uid: System.AppDomain.FirstChanceException
  parent: System.AppDomain
  isExternal: false
  name: FirstChanceException
  nameWithType: AppDomain.FirstChanceException
  fullName: System.AppDomain.FirstChanceException
- uid: System.EventHandler{System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<FirstChanceExceptionEventArgs>
  nameWithType: EventHandler<FirstChanceExceptionEventArgs>
  fullName: System.EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs
    name: FirstChanceExceptionEventArgs
    nameWithType: FirstChanceExceptionEventArgs
    fullName: FirstChanceExceptionEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomain.FriendlyName
  parent: System.AppDomain
  isExternal: false
  name: FriendlyName
  nameWithType: AppDomain.FriendlyName
  fullName: System.AppDomain.FriendlyName
- uid: System.AppDomain.GetAssemblies
  parent: System.AppDomain
  isExternal: false
  name: GetAssemblies()
  nameWithType: AppDomain.GetAssemblies()
  fullName: System.AppDomain.GetAssemblies()
- uid: System.Reflection.Assembly[]
  parent: System.Reflection
  isExternal: true
  name: Assembly
  nameWithType: Assembly
  fullName: System.Reflection.Assembly[]
  spec.csharp:
  - uid: System.Reflection.Assembly
    name: Assembly
    nameWithType: Assembly
    fullName: Assembly[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.GetCurrentThreadId
  parent: System.AppDomain
  isExternal: false
  name: GetCurrentThreadId()
  nameWithType: AppDomain.GetCurrentThreadId()
  fullName: System.AppDomain.GetCurrentThreadId()
- uid: System.AppDomain.GetData(System.String)
  parent: System.AppDomain
  isExternal: false
  name: GetData(String)
  nameWithType: AppDomain.GetData(String)
  fullName: System.AppDomain.GetData(String)
- uid: System.AppDomain.GetType
  parent: System.AppDomain
  isExternal: false
  name: GetType()
  nameWithType: AppDomain.GetType()
  fullName: System.AppDomain.GetType()
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.AppDomain.Id
  parent: System.AppDomain
  isExternal: false
  name: Id
  nameWithType: AppDomain.Id
  fullName: System.AppDomain.Id
- uid: System.AppDomain.InitializeLifetimeService
  parent: System.AppDomain
  isExternal: false
  name: InitializeLifetimeService()
  nameWithType: AppDomain.InitializeLifetimeService()
  fullName: System.AppDomain.InitializeLifetimeService()
- uid: System.AppDomain.IsCompatibilitySwitchSet(System.String)
  parent: System.AppDomain
  isExternal: false
  name: IsCompatibilitySwitchSet(String)
  nameWithType: AppDomain.IsCompatibilitySwitchSet(String)
  fullName: System.AppDomain.IsCompatibilitySwitchSet(String)
- uid: System.Nullable{System.Boolean}
  parent: System
  isExternal: true
  name: Nullable<Boolean>
  nameWithType: Nullable<Boolean>
  fullName: System.Nullable<System.Boolean>
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    nameWithType: Nullable
    fullName: Nullable<System.Boolean>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Boolean
    name: Boolean
    nameWithType: Boolean
    fullName: Boolean
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomain.IsDefaultAppDomain
  parent: System.AppDomain
  isExternal: false
  name: IsDefaultAppDomain()
  nameWithType: AppDomain.IsDefaultAppDomain()
  fullName: System.AppDomain.IsDefaultAppDomain()
- uid: System.AppDomain.IsFinalizingForUnload
  parent: System.AppDomain
  isExternal: false
  name: IsFinalizingForUnload()
  nameWithType: AppDomain.IsFinalizingForUnload()
  fullName: System.AppDomain.IsFinalizingForUnload()
- uid: System.AppDomain.IsFullyTrusted
  parent: System.AppDomain
  isExternal: false
  name: IsFullyTrusted
  nameWithType: AppDomain.IsFullyTrusted
  fullName: System.AppDomain.IsFullyTrusted
- uid: System.AppDomain.IsHomogenous
  parent: System.AppDomain
  isExternal: false
  name: IsHomogenous
  nameWithType: AppDomain.IsHomogenous
  fullName: System.AppDomain.IsHomogenous
- uid: System.AppDomain.Load(System.Byte[])
  parent: System.AppDomain
  isExternal: false
  name: Load(Byte[])
  nameWithType: AppDomain.Load(Byte[])
  fullName: System.AppDomain.Load(Byte[])
- uid: System.Reflection.Assembly
  parent: System.Reflection
  isExternal: true
  name: Assembly
  nameWithType: Assembly
  fullName: System.Reflection.Assembly
- uid: System.AppDomain.Load(System.Reflection.AssemblyName)
  parent: System.AppDomain
  isExternal: false
  name: Load(AssemblyName)
  nameWithType: AppDomain.Load(AssemblyName)
  fullName: System.AppDomain.Load(AssemblyName)
- uid: System.AppDomain.Load(System.String)
  parent: System.AppDomain
  isExternal: false
  name: Load(String)
  nameWithType: AppDomain.Load(String)
  fullName: System.AppDomain.Load(String)
- uid: System.AppDomain.Load(System.Byte[],System.Byte[])
  parent: System.AppDomain
  isExternal: false
  name: Load(Byte[],Byte[])
  nameWithType: AppDomain.Load(Byte[],Byte[])
  fullName: System.AppDomain.Load(Byte[],Byte[])
- uid: System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: Load(AssemblyName,Evidence)
  nameWithType: AppDomain.Load(AssemblyName,Evidence)
  fullName: System.AppDomain.Load(AssemblyName,Evidence)
- uid: System.AppDomain.Load(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: Load(String,Evidence)
  nameWithType: AppDomain.Load(String,Evidence)
  fullName: System.AppDomain.Load(String,Evidence)
- uid: System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: Load(Byte[],Byte[],Evidence)
  nameWithType: AppDomain.Load(Byte[],Byte[],Evidence)
  fullName: System.AppDomain.Load(Byte[],Byte[],Evidence)
- uid: System.AppDomain.MonitoringIsEnabled
  parent: System.AppDomain
  isExternal: false
  name: MonitoringIsEnabled
  nameWithType: AppDomain.MonitoringIsEnabled
  fullName: System.AppDomain.MonitoringIsEnabled
- uid: System.AppDomain.MonitoringSurvivedMemorySize
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedMemorySize
  nameWithType: AppDomain.MonitoringSurvivedMemorySize
  fullName: System.AppDomain.MonitoringSurvivedMemorySize
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.AppDomain.MonitoringSurvivedProcessMemorySize
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedProcessMemorySize
  nameWithType: AppDomain.MonitoringSurvivedProcessMemorySize
  fullName: System.AppDomain.MonitoringSurvivedProcessMemorySize
- uid: System.AppDomain.MonitoringTotalAllocatedMemorySize
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalAllocatedMemorySize
  nameWithType: AppDomain.MonitoringTotalAllocatedMemorySize
  fullName: System.AppDomain.MonitoringTotalAllocatedMemorySize
- uid: System.AppDomain.MonitoringTotalProcessorTime
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalProcessorTime
  nameWithType: AppDomain.MonitoringTotalProcessorTime
  fullName: System.AppDomain.MonitoringTotalProcessorTime
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.AppDomain.PermissionSet
  parent: System.AppDomain
  isExternal: false
  name: PermissionSet
  nameWithType: AppDomain.PermissionSet
  fullName: System.AppDomain.PermissionSet
- uid: System.AppDomain.ProcessExit
  parent: System.AppDomain
  isExternal: false
  name: ProcessExit
  nameWithType: AppDomain.ProcessExit
  fullName: System.AppDomain.ProcessExit
- uid: System.AppDomain.ReflectionOnlyAssemblyResolve
  parent: System.AppDomain
  isExternal: false
  name: ReflectionOnlyAssemblyResolve
  nameWithType: AppDomain.ReflectionOnlyAssemblyResolve
  fullName: System.AppDomain.ReflectionOnlyAssemblyResolve
- uid: System.AppDomain.ReflectionOnlyGetAssemblies
  parent: System.AppDomain
  isExternal: false
  name: ReflectionOnlyGetAssemblies()
  nameWithType: AppDomain.ReflectionOnlyGetAssemblies()
  fullName: System.AppDomain.ReflectionOnlyGetAssemblies()
- uid: System.AppDomain.RelativeSearchPath
  parent: System.AppDomain
  isExternal: false
  name: RelativeSearchPath
  nameWithType: AppDomain.RelativeSearchPath
  fullName: System.AppDomain.RelativeSearchPath
- uid: System.AppDomain.ResourceResolve
  parent: System.AppDomain
  isExternal: false
  name: ResourceResolve
  nameWithType: AppDomain.ResourceResolve
  fullName: System.AppDomain.ResourceResolve
- uid: System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  parent: System.AppDomain
  isExternal: false
  name: SetAppDomainPolicy(PolicyLevel)
  nameWithType: AppDomain.SetAppDomainPolicy(PolicyLevel)
  fullName: System.AppDomain.SetAppDomainPolicy(PolicyLevel)
- uid: System.Security.Policy.PolicyLevel
  parent: System.Security.Policy
  isExternal: false
  name: PolicyLevel
  nameWithType: PolicyLevel
  fullName: System.Security.Policy.PolicyLevel
- uid: System.AppDomain.SetCachePath(System.String)
  parent: System.AppDomain
  isExternal: false
  name: SetCachePath(String)
  nameWithType: AppDomain.SetCachePath(String)
  fullName: System.AppDomain.SetCachePath(String)
- uid: System.AppDomain.SetData(System.String,System.Object)
  parent: System.AppDomain
  isExternal: false
  name: SetData(String,Object)
  nameWithType: AppDomain.SetData(String,Object)
  fullName: System.AppDomain.SetData(String,Object)
- uid: System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)
  parent: System.AppDomain
  isExternal: false
  name: SetData(String,Object,IPermission)
  nameWithType: AppDomain.SetData(String,Object,IPermission)
  fullName: System.AppDomain.SetData(String,Object,IPermission)
- uid: System.Security.IPermission
  parent: System.Security
  isExternal: false
  name: IPermission
  nameWithType: IPermission
  fullName: System.Security.IPermission
- uid: System.AppDomain.SetDynamicBase(System.String)
  parent: System.AppDomain
  isExternal: false
  name: SetDynamicBase(String)
  nameWithType: AppDomain.SetDynamicBase(String)
  fullName: System.AppDomain.SetDynamicBase(String)
- uid: System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  parent: System.AppDomain
  isExternal: false
  name: SetPrincipalPolicy(PrincipalPolicy)
  nameWithType: AppDomain.SetPrincipalPolicy(PrincipalPolicy)
  fullName: System.AppDomain.SetPrincipalPolicy(PrincipalPolicy)
- uid: System.Security.Principal.PrincipalPolicy
  parent: System.Security.Principal
  isExternal: false
  name: PrincipalPolicy
  nameWithType: PrincipalPolicy
  fullName: System.Security.Principal.PrincipalPolicy
- uid: System.AppDomain.SetShadowCopyFiles
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyFiles()
  nameWithType: AppDomain.SetShadowCopyFiles()
  fullName: System.AppDomain.SetShadowCopyFiles()
- uid: System.AppDomain.SetShadowCopyPath(System.String)
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyPath(String)
  nameWithType: AppDomain.SetShadowCopyPath(String)
  fullName: System.AppDomain.SetShadowCopyPath(String)
- uid: System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)
  parent: System.AppDomain
  isExternal: false
  name: SetThreadPrincipal(IPrincipal)
  nameWithType: AppDomain.SetThreadPrincipal(IPrincipal)
  fullName: System.AppDomain.SetThreadPrincipal(IPrincipal)
- uid: System.Security.Principal.IPrincipal
  parent: System.Security.Principal
  isExternal: true
  name: IPrincipal
  nameWithType: IPrincipal
  fullName: System.Security.Principal.IPrincipal
- uid: System.AppDomain.SetupInformation
  parent: System.AppDomain
  isExternal: false
  name: SetupInformation
  nameWithType: AppDomain.SetupInformation
  fullName: System.AppDomain.SetupInformation
- uid: System.AppDomain.ShadowCopyFiles
  parent: System.AppDomain
  isExternal: false
  name: ShadowCopyFiles
  nameWithType: AppDomain.ShadowCopyFiles
  fullName: System.AppDomain.ShadowCopyFiles
- uid: System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
- uid: System.Guid
  parent: System
  isExternal: true
  name: Guid
  nameWithType: Guid
  fullName: System.Guid
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.UInt32
  parent: System
  isExternal: true
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
- uid: System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfoCount(UInt32)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
- uid: System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: System.AppDomain.ToString
  parent: System.AppDomain
  isExternal: false
  name: ToString()
  nameWithType: AppDomain.ToString()
  fullName: System.AppDomain.ToString()
- uid: System.AppDomain.TypeResolve
  parent: System.AppDomain
  isExternal: false
  name: TypeResolve
  nameWithType: AppDomain.TypeResolve
  fullName: System.AppDomain.TypeResolve
- uid: System.AppDomain.UnhandledException
  parent: System.AppDomain
  isExternal: false
  name: UnhandledException
  nameWithType: AppDomain.UnhandledException
  fullName: System.AppDomain.UnhandledException
- uid: System.UnhandledExceptionEventHandler
  parent: System
  isExternal: false
  name: UnhandledExceptionEventHandler
  nameWithType: UnhandledExceptionEventHandler
  fullName: System.UnhandledExceptionEventHandler
- uid: System.AppDomain.Unload(System.AppDomain)
  parent: System.AppDomain
  isExternal: false
  name: Unload(AppDomain)
  nameWithType: AppDomain.Unload(AppDomain)
  fullName: System.AppDomain.Unload(AppDomain)
- uid: System.AppDomain.ActivationContext*
  parent: System.AppDomain
  isExternal: false
  name: ActivationContext
  nameWithType: AppDomain.ActivationContext
- uid: System.AppDomain.AppendPrivatePath*
  parent: System.AppDomain
  isExternal: false
  name: AppendPrivatePath
  nameWithType: AppDomain.AppendPrivatePath
- uid: System.AppDomain.ApplicationIdentity*
  parent: System.AppDomain
  isExternal: false
  name: ApplicationIdentity
  nameWithType: AppDomain.ApplicationIdentity
- uid: System.AppDomain.ApplicationTrust*
  parent: System.AppDomain
  isExternal: false
  name: ApplicationTrust
  nameWithType: AppDomain.ApplicationTrust
- uid: System.AppDomain.ApplyPolicy*
  parent: System.AppDomain
  isExternal: false
  name: ApplyPolicy
  nameWithType: AppDomain.ApplyPolicy
- uid: System.AppDomain.BaseDirectory*
  parent: System.AppDomain
  isExternal: false
  name: BaseDirectory
  nameWithType: AppDomain.BaseDirectory
- uid: System.AppDomain.ClearPrivatePath*
  parent: System.AppDomain
  isExternal: false
  name: ClearPrivatePath
  nameWithType: AppDomain.ClearPrivatePath
- uid: System.AppDomain.ClearShadowCopyPath*
  parent: System.AppDomain
  isExternal: false
  name: ClearShadowCopyPath
  nameWithType: AppDomain.ClearShadowCopyPath
- uid: System.AppDomain.CreateComInstanceFrom*
  parent: System.AppDomain
  isExternal: false
  name: CreateComInstanceFrom
  nameWithType: AppDomain.CreateComInstanceFrom
- uid: System.AppDomain.CreateDomain*
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain
  nameWithType: AppDomain.CreateDomain
- uid: System.AppDomain.CreateInstance*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance
  nameWithType: AppDomain.CreateInstance
- uid: System.AppDomain.CreateInstanceAndUnwrap*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap
  nameWithType: AppDomain.CreateInstanceAndUnwrap
- uid: System.AppDomain.CreateInstanceFrom*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom
  nameWithType: AppDomain.CreateInstanceFrom
- uid: System.AppDomain.CreateInstanceFromAndUnwrap*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap
- uid: System.AppDomain.CurrentDomain*
  parent: System.AppDomain
  isExternal: false
  name: CurrentDomain
  nameWithType: AppDomain.CurrentDomain
- uid: System.AppDomain.DefineDynamicAssembly*
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly
  nameWithType: AppDomain.DefineDynamicAssembly
- uid: System.AppDomain.DoCallBack*
  parent: System.AppDomain
  isExternal: false
  name: DoCallBack
  nameWithType: AppDomain.DoCallBack
- uid: System.AppDomain.DomainManager*
  parent: System.AppDomain
  isExternal: false
  name: DomainManager
  nameWithType: AppDomain.DomainManager
- uid: System.AppDomain.DynamicDirectory*
  parent: System.AppDomain
  isExternal: false
  name: DynamicDirectory
  nameWithType: AppDomain.DynamicDirectory
- uid: System.AppDomain.Evidence*
  parent: System.AppDomain
  isExternal: false
  name: Evidence
  nameWithType: AppDomain.Evidence
- uid: System.AppDomain.ExecuteAssembly*
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly
  nameWithType: AppDomain.ExecuteAssembly
- uid: System.AppDomain.ExecuteAssemblyByName*
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName
  nameWithType: AppDomain.ExecuteAssemblyByName
- uid: System.AppDomain.FriendlyName*
  parent: System.AppDomain
  isExternal: false
  name: FriendlyName
  nameWithType: AppDomain.FriendlyName
- uid: System.AppDomain.GetAssemblies*
  parent: System.AppDomain
  isExternal: false
  name: GetAssemblies
  nameWithType: AppDomain.GetAssemblies
- uid: System.AppDomain.GetCurrentThreadId*
  parent: System.AppDomain
  isExternal: false
  name: GetCurrentThreadId
  nameWithType: AppDomain.GetCurrentThreadId
- uid: System.AppDomain.GetData*
  parent: System.AppDomain
  isExternal: false
  name: GetData
  nameWithType: AppDomain.GetData
- uid: System.AppDomain.GetType*
  parent: System.AppDomain
  isExternal: false
  name: GetType
  nameWithType: AppDomain.GetType
- uid: System.AppDomain.Id*
  parent: System.AppDomain
  isExternal: false
  name: Id
  nameWithType: AppDomain.Id
- uid: System.AppDomain.InitializeLifetimeService*
  parent: System.AppDomain
  isExternal: false
  name: InitializeLifetimeService
  nameWithType: AppDomain.InitializeLifetimeService
- uid: System.AppDomain.IsCompatibilitySwitchSet*
  parent: System.AppDomain
  isExternal: false
  name: IsCompatibilitySwitchSet
  nameWithType: AppDomain.IsCompatibilitySwitchSet
- uid: System.AppDomain.IsDefaultAppDomain*
  parent: System.AppDomain
  isExternal: false
  name: IsDefaultAppDomain
  nameWithType: AppDomain.IsDefaultAppDomain
- uid: System.AppDomain.IsFinalizingForUnload*
  parent: System.AppDomain
  isExternal: false
  name: IsFinalizingForUnload
  nameWithType: AppDomain.IsFinalizingForUnload
- uid: System.AppDomain.IsFullyTrusted*
  parent: System.AppDomain
  isExternal: false
  name: IsFullyTrusted
  nameWithType: AppDomain.IsFullyTrusted
- uid: System.AppDomain.IsHomogenous*
  parent: System.AppDomain
  isExternal: false
  name: IsHomogenous
  nameWithType: AppDomain.IsHomogenous
- uid: System.AppDomain.Load*
  parent: System.AppDomain
  isExternal: false
  name: Load
  nameWithType: AppDomain.Load
- uid: System.AppDomain.MonitoringIsEnabled*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringIsEnabled
  nameWithType: AppDomain.MonitoringIsEnabled
- uid: System.AppDomain.MonitoringSurvivedMemorySize*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedMemorySize
  nameWithType: AppDomain.MonitoringSurvivedMemorySize
- uid: System.AppDomain.MonitoringSurvivedProcessMemorySize*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedProcessMemorySize
  nameWithType: AppDomain.MonitoringSurvivedProcessMemorySize
- uid: System.AppDomain.MonitoringTotalAllocatedMemorySize*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalAllocatedMemorySize
  nameWithType: AppDomain.MonitoringTotalAllocatedMemorySize
- uid: System.AppDomain.MonitoringTotalProcessorTime*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalProcessorTime
  nameWithType: AppDomain.MonitoringTotalProcessorTime
- uid: System.AppDomain.PermissionSet*
  parent: System.AppDomain
  isExternal: false
  name: PermissionSet
  nameWithType: AppDomain.PermissionSet
- uid: System.AppDomain.ReflectionOnlyGetAssemblies*
  parent: System.AppDomain
  isExternal: false
  name: ReflectionOnlyGetAssemblies
  nameWithType: AppDomain.ReflectionOnlyGetAssemblies
- uid: System.AppDomain.RelativeSearchPath*
  parent: System.AppDomain
  isExternal: false
  name: RelativeSearchPath
  nameWithType: AppDomain.RelativeSearchPath
- uid: System.AppDomain.SetAppDomainPolicy*
  parent: System.AppDomain
  isExternal: false
  name: SetAppDomainPolicy
  nameWithType: AppDomain.SetAppDomainPolicy
- uid: System.AppDomain.SetCachePath*
  parent: System.AppDomain
  isExternal: false
  name: SetCachePath
  nameWithType: AppDomain.SetCachePath
- uid: System.AppDomain.SetData*
  parent: System.AppDomain
  isExternal: false
  name: SetData
  nameWithType: AppDomain.SetData
- uid: System.AppDomain.SetDynamicBase*
  parent: System.AppDomain
  isExternal: false
  name: SetDynamicBase
  nameWithType: AppDomain.SetDynamicBase
- uid: System.AppDomain.SetPrincipalPolicy*
  parent: System.AppDomain
  isExternal: false
  name: SetPrincipalPolicy
  nameWithType: AppDomain.SetPrincipalPolicy
- uid: System.AppDomain.SetShadowCopyFiles*
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyFiles
  nameWithType: AppDomain.SetShadowCopyFiles
- uid: System.AppDomain.SetShadowCopyPath*
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyPath
  nameWithType: AppDomain.SetShadowCopyPath
- uid: System.AppDomain.SetThreadPrincipal*
  parent: System.AppDomain
  isExternal: false
  name: SetThreadPrincipal
  nameWithType: AppDomain.SetThreadPrincipal
- uid: System.AppDomain.SetupInformation*
  parent: System.AppDomain
  isExternal: false
  name: SetupInformation
  nameWithType: AppDomain.SetupInformation
- uid: System.AppDomain.ShadowCopyFiles*
  parent: System.AppDomain
  isExternal: false
  name: ShadowCopyFiles
  nameWithType: AppDomain.ShadowCopyFiles
- uid: System.AppDomain.System#_AppDomain#GetIDsOfNames*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetIDsOfNames
  nameWithType: AppDomain.System._AppDomain.GetIDsOfNames
- uid: System.AppDomain.System#_AppDomain#GetTypeInfo*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfo
  nameWithType: AppDomain.System._AppDomain.GetTypeInfo
- uid: System.AppDomain.System#_AppDomain#GetTypeInfoCount*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfoCount
  nameWithType: AppDomain.System._AppDomain.GetTypeInfoCount
- uid: System.AppDomain.System#_AppDomain#Invoke*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.Invoke
  nameWithType: AppDomain.System._AppDomain.Invoke
- uid: System.AppDomain.ToString*
  parent: System.AppDomain
  isExternal: false
  name: ToString
  nameWithType: AppDomain.ToString
- uid: System.AppDomain.Unload*
  parent: System.AppDomain
  isExternal: false
  name: Unload
  nameWithType: AppDomain.Unload
