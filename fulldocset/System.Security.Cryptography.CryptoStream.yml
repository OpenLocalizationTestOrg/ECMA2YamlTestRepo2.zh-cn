### YamlMime:ManagedReference
items:
- uid: System.Security.Cryptography.CryptoStream
  id: CryptoStream
  children:
  - System.Security.Cryptography.CryptoStream.#ctor(System.IO.Stream,System.Security.Cryptography.ICryptoTransform,System.Security.Cryptography.CryptoStreamMode)
  - System.Security.Cryptography.CryptoStream.CanRead
  - System.Security.Cryptography.CryptoStream.CanSeek
  - System.Security.Cryptography.CryptoStream.CanWrite
  - System.Security.Cryptography.CryptoStream.Clear
  - System.Security.Cryptography.CryptoStream.Dispose(System.Boolean)
  - System.Security.Cryptography.CryptoStream.Flush
  - System.Security.Cryptography.CryptoStream.FlushAsync(System.Threading.CancellationToken)
  - System.Security.Cryptography.CryptoStream.FlushFinalBlock
  - System.Security.Cryptography.CryptoStream.HasFlushedFinalBlock
  - System.Security.Cryptography.CryptoStream.Length
  - System.Security.Cryptography.CryptoStream.Position
  - System.Security.Cryptography.CryptoStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.Security.Cryptography.CryptoStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.Security.Cryptography.CryptoStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.Security.Cryptography.CryptoStream.SetLength(System.Int64)
  - System.Security.Cryptography.CryptoStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.Security.Cryptography.CryptoStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  langs:
  - csharp
  name: CryptoStream
  nameWithType: CryptoStream
  fullName: System.Security.Cryptography.CryptoStream
  type: Class
  summary: "定义将数据流链接到加密转换的流。"
  remarks: "公共语言运行时使用面向流的设计进行加密。 这种设计的核心是 CryptoStream。 实现 CryptoStream 任何加密对象可以链接以及实现的任何对象<xref:System.IO.Stream>，因此可以需要一个对象的流式处理的输出传递给另一个对象的输入。</xref:System.IO.Stream> 中间结果 （从第一个对象的输出） 不需要单独存储。      1> [!IMPORTANT]&1;> 此类型实现<xref:System.IDisposable>接口。</xref:System.IDisposable> 在完成使用类型后，您应释放它的直接或间接通过调用其<xref:System.Security.Cryptography.CryptoStream.Clear%2A>方法，后者反过来调用其<xref:System.IDisposable>实现。</xref:System.IDisposable> </xref:System.Security.Cryptography.CryptoStream.Clear%2A> 若要直接释放类型，调用其<xref:System.Security.Cryptography.CryptoStream.Clear%2A>中的方法`try` / `catch`块。</xref:System.Security.Cryptography.CryptoStream.Clear%2A> 若要间接释放类型，使用一种语言构造如`using`（在 C# 中) 或`Using`（在 Visual Basic 中)。 有关详细信息，请参阅中的&quot;使用实现 IDisposable 的对象&quot;部分<xref:System.IDisposable>接口主题。</xref:System.IDisposable>       在完成之后，应始终显式关闭 CryptoStream 对象使用通过调用<xref:System.Security.Cryptography.CryptoStream.Clear%2A>方法。</xref:System.Security.Cryptography.CryptoStream.Clear%2A>  这样做刷新基础流并导致所有剩余 CryptoStream 对象处理的数据块。  但是，如果你在调用之前，则会发生异常<xref:System.IO.Stream.Close%2A>方法，对象可能不会关闭 CryptoStream。</xref:System.IO.Stream.Close%2A>  若要确保<xref:System.IO.Stream.Close%2A>始终调用方法，请将放到调用<xref:System.Security.Cryptography.CryptoStream.Clear%2A>方法内的`finally`块`try` / `catch`语句。</xref:System.Security.Cryptography.CryptoStream.Clear%2A> </xref:System.IO.Stream.Close%2A>"
  example:
  - "The following example demonstrates how to use a CryptoStream to encrypt a string. This method uses <xref:System.Security.Cryptography.RijndaelManaged> class with the specified <xref:System.Security.Cryptography.SymmetricAlgorithm.Key%2A> and initialization vector (<xref:System.Security.Cryptography.SymmetricAlgorithm.IV%2A>).  \n  \n [!code-cs[Cryptography.Rijndael.Create.File#1](~/add/codesnippet/csharp/t-system.security.crypto_78_1.cs)]\n [!code-vb[Cryptography.Rijndael.Create.File#1](~/add/codesnippet/visualbasic/t-system.security.crypto_78_1.vb)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public class CryptoStream : System.IO.Stream
  inheritance:
  - System.IO.Stream
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Security.Cryptography.CryptoStream.#ctor(System.IO.Stream,System.Security.Cryptography.ICryptoTransform,System.Security.Cryptography.CryptoStreamMode)
  id: '#ctor(System.IO.Stream,System.Security.Cryptography.ICryptoTransform,System.Security.Cryptography.CryptoStreamMode)'
  parent: System.Security.Cryptography.CryptoStream
  langs:
  - csharp
  name: CryptoStream(Stream,ICryptoTransform,CryptoStreamMode)
  nameWithType: CryptoStream.CryptoStream(Stream,ICryptoTransform,CryptoStreamMode)
  fullName: System.Security.Cryptography.CryptoStream.CryptoStream(Stream,ICryptoTransform,CryptoStreamMode)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "初始化的新实例<xref href=&quot;System.Security.Cryptography.CryptoStream&quot;></xref>用目标数据流、 要使用，转换和流模式的类。"
  remarks: "派生自任何对象<xref:System.IO.Stream>可传入`stream`参数。</xref:System.IO.Stream> 实现任何对象<xref:System.Security.Cryptography.ICryptoTransform>(如<xref:System.Security.Cryptography.HashAlgorithm>) 可将传入`transform`参数。</xref:System.Security.Cryptography.HashAlgorithm> </xref:System.Security.Cryptography.ICryptoTransform>"
  syntax:
    content: public CryptoStream (System.IO.Stream stream, System.Security.Cryptography.ICryptoTransform transform, System.Security.Cryptography.CryptoStreamMode mode);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "对其执行加密转换的流。"
    - id: transform
      type: System.Security.Cryptography.ICryptoTransform
      description: "要在流上执行加密转换。"
    - id: mode
      type: System.Security.Cryptography.CryptoStreamMode
      description: "之一<xref href=&quot;System.Security.Cryptography.CryptoStreamMode&quot;></xref>值。"
  overload: System.Security.Cryptography.CryptoStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>stream</code>是无效的。"
  platform:
  - net462
- uid: System.Security.Cryptography.CryptoStream.CanRead
  id: CanRead
  parent: System.Security.Cryptography.CryptoStream
  langs:
  - csharp
  name: CanRead
  nameWithType: CryptoStream.CanRead
  fullName: System.Security.Cryptography.CryptoStream.CanRead
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "获取一个值，该值指示是否当前<xref href=&quot;System.Security.Cryptography.CryptoStream&quot;></xref>是可读。"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果当前流可读，则为否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Security.Cryptography.CryptoStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Cryptography.CryptoStream.CanSeek
  id: CanSeek
  parent: System.Security.Cryptography.CryptoStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: CryptoStream.CanSeek
  fullName: System.Security.Cryptography.CryptoStream.CanSeek
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "获取一个值，该值指示是否可以在当前查找<xref href=&quot;System.Security.Cryptography.CryptoStream&quot;> </xref>。"
  remarks: "查找中未启用<xref:System.Security.Cryptography.CryptoStream>，因此此方法始终返回`false`。</xref:System.Security.Cryptography.CryptoStream>"
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "Always <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>."
  overload: System.Security.Cryptography.CryptoStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Cryptography.CryptoStream.CanWrite
  id: CanWrite
  parent: System.Security.Cryptography.CryptoStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: CryptoStream.CanWrite
  fullName: System.Security.Cryptography.CryptoStream.CanWrite
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "获取一个值，该值指示是否当前<xref href=&quot;System.Security.Cryptography.CryptoStream&quot;></xref>是可写。"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果当前流可写，则为否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Security.Cryptography.CryptoStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Cryptography.CryptoStream.Clear
  id: Clear
  parent: System.Security.Cryptography.CryptoStream
  langs:
  - csharp
  name: Clear()
  nameWithType: CryptoStream.Clear()
  fullName: System.Security.Cryptography.CryptoStream.Clear()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "释放使用的所有资源<xref href=&quot;System.Security.Cryptography.CryptoStream&quot;> </xref>。"
  remarks: "此方法会包装类型的调用<xref:System.IDisposable.Dispose%2A?displayProperty=fullName>实现。</xref:System.IDisposable.Dispose%2A?displayProperty=fullName>       调用`Dispose`允许使用的资源<xref:System.Security.Cryptography.CryptoStream>可以重新分配用于其他目的。</xref:System.Security.Cryptography.CryptoStream> 有关详细信息`Dispose`，请参阅[清洗向上非托管资源](~/add/includes/ajax-current-ext-md.md)"
  syntax:
    content: public void Clear ();
    parameters: []
  overload: System.Security.Cryptography.CryptoStream.Clear*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Cryptography.CryptoStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Security.Cryptography.CryptoStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: CryptoStream.Dispose(Boolean)
  fullName: System.Security.Cryptography.CryptoStream.Dispose(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "释放由非托管的资源<xref href=&quot;System.Security.Cryptography.CryptoStream&quot;> </xref> ，还可以释放托管的资源。"
  remarks: "此方法称为由公共`Dispose()`方法和`Finalize`方法。 `Dispose()`调用受保护`Dispose(Boolean)`方法释放参数设置为`true`。 `Finalize`调用`Dispose`释放设置为`false`。       当`disposing`参数是`true`，此方法释放由任何托管对象持有的全部资源此<xref:System.Security.Cryptography.CryptoStream>引用。</xref:System.Security.Cryptography.CryptoStream> 此方法调用`Dispose()`每个引用对象的方法。"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要释放托管和非托管资源;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>若要仅释放非托管的资源。"
  overload: System.Security.Cryptography.CryptoStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Cryptography.CryptoStream.Flush
  id: Flush
  parent: System.Security.Cryptography.CryptoStream
  langs:
  - csharp
  name: Flush()
  nameWithType: CryptoStream.Flush()
  fullName: System.Security.Cryptography.CryptoStream.Flush()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "清除当前流的所有缓冲区，使得所有缓冲的数据都写入基础设备。"
  remarks: "除非你明确地调用刷新或<xref:System.IO.Stream.Close%2A>。</xref:System.IO.Stream.Close%2A> ，刷新该流不会刷新其基础的编码器 设置<xref:System.IO.StreamWriter.AutoFlush%2A>到`true`意味着数据从缓冲区刷新到流中，但不是会刷新编码器状态。</xref:System.IO.StreamWriter.AutoFlush%2A> 这将允许编码器，以便它可以正确编码的字符的下一步块保持其状态 （部分字符）。 这种情况下会影响 UTF8 和 UTF7 其中某些字符仅后才能进行编码的编码器收到的相邻字符。      1> [!NOTE]&1;> 应通过调用<xref:System.IO.Stream.Close%2A>方法或<xref:System.Security.Cryptography.CryptoStream.FlushFinalBlock%2A>方法以完成刷新缓冲区。</xref:System.Security.Cryptography.CryptoStream.FlushFinalBlock%2A> </xref:System.IO.Stream.Close%2A>"
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.Security.Cryptography.CryptoStream.Flush*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Cryptography.CryptoStream.FlushAsync(System.Threading.CancellationToken)
  id: FlushAsync(System.Threading.CancellationToken)
  parent: System.Security.Cryptography.CryptoStream
  langs:
  - csharp
  name: FlushAsync(CancellationToken)
  nameWithType: CryptoStream.FlushAsync(CancellationToken)
  fullName: System.Security.Cryptography.CryptoStream.FlushAsync(CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "异步清理当前流的所有缓冲区，使得所有缓冲的数据都写入到基础设备，并监视取消请求。"
  remarks: "必须在与 FlushAsync 调用之前添加`await`(C#) 或`Await`(Visual Basic 中) 运算符可暂停执行方法，直到完成该任务为止。 有关详细信息，请参阅[使用 Async 和 Await 进行异步编程](~/add/includes/ajax-current-ext-md.md)。       如果在完成之前，将取消该操作，返回的任务包含<xref:System.Threading.Tasks.TaskStatus>值<xref:System.Threading.Tasks.Task.Status%2A>属性。</xref:System.Threading.Tasks.Task.Status%2A> </xref:System.Threading.Tasks.TaskStatus>"
  syntax:
    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "要监视取消请求的标记。 默认值为<xref:System.Threading.CancellationToken.None*>。</xref:System.Threading.CancellationToken.None*>"
    return:
      type: System.Threading.Tasks.Task
      description: "表示异步刷新操作的任务。"
  overload: System.Security.Cryptography.CryptoStream.FlushAsync*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已释放流。"
  platform:
  - net462
- uid: System.Security.Cryptography.CryptoStream.FlushFinalBlock
  id: FlushFinalBlock
  parent: System.Security.Cryptography.CryptoStream
  langs:
  - csharp
  name: FlushFinalBlock()
  nameWithType: CryptoStream.FlushFinalBlock()
  fullName: System.Security.Cryptography.CryptoStream.FlushFinalBlock()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "使用的缓冲区的当前状态更新基础数据源或存储库，随后清除缓冲区。"
  remarks: "调用<xref:System.IO.Stream.Close%2A>方法将调用 FlushFinalBlock。</xref:System.IO.Stream.Close%2A> 如果不调用<xref:System.IO.Stream.Close%2A>，调用 FlushFinalBlock 完成刷新缓冲区。</xref:System.IO.Stream.Close%2A> 只能在流的所有活动完成都后，请调用 FlushFinalBlock。"
  syntax:
    content: public void FlushFinalBlock ();
    parameters: []
  overload: System.Security.Cryptography.CryptoStream.FlushFinalBlock*
  exceptions:
  - type: System.Security.Cryptography.CryptographicException
    commentId: T:System.Security.Cryptography.CryptographicException
    description: "密钥已损坏，这可以导致无效填充到流。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "当前流不是可写的。       -或者-已转换最终块。"
  platform:
  - net462
- uid: System.Security.Cryptography.CryptoStream.HasFlushedFinalBlock
  id: HasFlushedFinalBlock
  parent: System.Security.Cryptography.CryptoStream
  langs:
  - csharp
  name: HasFlushedFinalBlock
  nameWithType: CryptoStream.HasFlushedFinalBlock
  fullName: System.Security.Cryptography.CryptoStream.HasFlushedFinalBlock
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "获取一个值，该值指示最终缓冲区块是否已写入基础流。"
  remarks: "设置此属性`true`时<xref:System.Security.Cryptography.CryptoStream.FlushFinalBlock%2A>调用方法。</xref:System.Security.Cryptography.CryptoStream.FlushFinalBlock%2A>"
  syntax:
    content: public bool HasFlushedFinalBlock { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果已刷新最终块;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Security.Cryptography.CryptoStream.HasFlushedFinalBlock*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Cryptography.CryptoStream.Length
  id: Length
  parent: System.Security.Cryptography.CryptoStream
  langs:
  - csharp
  name: Length
  nameWithType: CryptoStream.Length
  fullName: System.Security.Cryptography.CryptoStream.Length
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "获取用字节表示的流长度。"
  remarks: "此属性存在只是为了支持从继承<xref:System.IO.Stream>，并且不能使用。</xref:System.IO.Stream>"
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "不支持此属性。"
  overload: System.Security.Cryptography.CryptoStream.Length*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "不支持此属性。"
  platform:
  - net462
- uid: System.Security.Cryptography.CryptoStream.Position
  id: Position
  parent: System.Security.Cryptography.CryptoStream
  langs:
  - csharp
  name: Position
  nameWithType: CryptoStream.Position
  fullName: System.Security.Cryptography.CryptoStream.Position
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "获取或设置当前流中的位置。"
  remarks: "此属性存在只是为了支持从继承<xref:System.IO.Stream>，并且不能使用。</xref:System.IO.Stream>"
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "不支持此属性。"
  overload: System.Security.Cryptography.CryptoStream.Position*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "不支持此属性。"
  platform:
  - net462
- uid: System.Security.Cryptography.CryptoStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.Security.Cryptography.CryptoStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: CryptoStream.Read(Byte[],Int32,Int32)
  fullName: System.Security.Cryptography.CryptoStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "从当前流读取的字节序列，并将流内的位置提升读取的字节数。"
  syntax:
    content: public override int Read (byte[] buffer, int offset, int count);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "字节数组。 最多个`count`从当前流中读取和存储在字节`buffer`。"
    - id: offset
      type: System.Int32
      description: "中的字节偏移量`buffer`从此处开始存储读取的数据从当前流。"
    - id: count
      type: System.Int32
      description: "最大要从当前流中读取的字节数。"
    return:
      type: System.Int32
      description: "读取到缓冲区的字节总数。 这可能小于请求的字节数如果很多字节当前不可用，或零个如果已到达流结尾。"
  overload: System.Security.Cryptography.CryptoStream.Read*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Security.Cryptography.CryptoStreamMode&quot;> </xref>与当前关联<xref href=&quot;System.Security.Cryptography.CryptoStream&quot;></xref>对象与基础流不匹配。  例如，将引发此异常，使用时<xref href=&quot;System.Security.Cryptography.CryptoStreamMode&quot;></xref>与是只写的基础流。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> offset </code>参数小于零。       -或- <code> count </code>参数小于零。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "参数的<code> count </code>和<code> offset </code>参数的长度超过缓冲区的长度。"
  platform:
  - net462
- uid: System.Security.Cryptography.CryptoStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.Security.Cryptography.CryptoStream
  langs:
  - csharp
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: CryptoStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.Security.Cryptography.CryptoStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "从当前流异步读取的字节序列，将流内的位置提升读取字节数，并监视取消请求。"
  remarks: "必须在对 ReadAsync 与调用之前添加`await`(C#) 或`Await`(Visual Basic 中) 运算符可暂停执行方法，直到完成该任务为止。 有关详细信息，请参阅[使用 Async 和 Await 进行异步编程](~/add/includes/ajax-current-ext-md.md)。       如果在完成之前，将取消该操作，返回的任务包含<xref:System.Threading.Tasks.TaskStatus>值<xref:System.Threading.Tasks.Task.Status%2A>属性。</xref:System.Threading.Tasks.Task.Status%2A> </xref:System.Threading.Tasks.TaskStatus>"
  syntax:
    content: public override System.Threading.Tasks.Task<int> ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "要写入到数据的缓冲区。"
    - id: offset
      type: System.Int32
      description: "中的字节偏移量`buffer`从此处开始写入从流读取的数据。"
    - id: count
      type: System.Int32
      description: "最大读取的字节数。"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "要监视取消请求的标记。 默认值为<xref:System.Threading.CancellationToken.None*>。</xref:System.Threading.CancellationToken.None*>"
    return:
      type: System.Threading.Tasks.Task{System.Int32}
      description: "一个任务，它表示异步读取操作。 任务对象的值<code> TResult </code>参数包含读入缓冲区的字节总数。 结果可能小于请求的字节数的如果当前可用字节数小于所请求的数目，或如果已到达流结尾，它可以是 0 （零）。"
  overload: System.Security.Cryptography.CryptoStream.ReadAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>或<code>count</code>为负。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "总和<code> offset </code>和<code> count </code>大于缓冲区长度。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "流不支持读取。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已释放流。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "当前正在使用以前的读取操作流。"
  platform:
  - net462
- uid: System.Security.Cryptography.CryptoStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.Security.Cryptography.CryptoStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: CryptoStream.Seek(Int64,SeekOrigin)
  fullName: System.Security.Cryptography.CryptoStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "设置当前流中的位置。"
  remarks: "此方法存在只是为了支持从继承<xref:System.IO.Stream>，并且不能使用。</xref:System.IO.Stream>"
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "相对于的字节偏移量`origin`参数。"
    - id: origin
      type: System.IO.SeekOrigin
      description: "A<xref:System.IO.SeekOrigin>对象，它指示用于获取新位置的参考点。</xref:System.IO.SeekOrigin>"
    return:
      type: System.Int64
      description: "不支持此方法。"
  overload: System.Security.Cryptography.CryptoStream.Seek*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "不支持此方法。"
  platform:
  - net462
- uid: System.Security.Cryptography.CryptoStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.Security.Cryptography.CryptoStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: CryptoStream.SetLength(Int64)
  fullName: System.Security.Cryptography.CryptoStream.SetLength(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "设置当前流的长度。"
  remarks: "此属性存在只是为了支持从继承<xref:System.IO.Stream>，并且不能使用。</xref:System.IO.Stream>"
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "当前流以字节为单位的所需的长度。"
  overload: System.Security.Cryptography.CryptoStream.SetLength*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "此属性存在只是为了支持从继承<xref:System.IO.Stream>，并且不能使用。</xref:System.IO.Stream>"
  platform:
  - net462
- uid: System.Security.Cryptography.CryptoStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.Security.Cryptography.CryptoStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: CryptoStream.Write(Byte[],Int32,Int32)
  fullName: System.Security.Cryptography.CryptoStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "将一个字节序列写入当前<xref href=&quot;System.Security.Cryptography.CryptoStream&quot;> </xref> ，并使流中的当前位置提升写入的字节数。"
  syntax:
    content: public override void Write (byte[] buffer, int offset, int count);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "字节数组。 此方法会复制`count`个字节从`buffer`写入当前流。"
    - id: offset
      type: System.Int32
      description: "中的字节偏移量`buffer`从此处开始将字节复制到当前流。"
    - id: count
      type: System.Int32
      description: "要写入当前流的字节数。"
  overload: System.Security.Cryptography.CryptoStream.Write*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Security.Cryptography.CryptoStreamMode&quot;> </xref>与当前关联<xref href=&quot;System.Security.Cryptography.CryptoStream&quot;></xref>对象与基础流不匹配。  例如，将引发此异常，使用时<xref href=&quot;System.Security.Cryptography.CryptoStreamMode&quot;></xref>与具有只读属性的基础流。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> offset </code>参数小于零。       -或- <code> count </code>参数小于零。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "总和<code> count </code>和<code> offset </code>参数的长度超过缓冲区的长度。"
  platform:
  - net462
- uid: System.Security.Cryptography.CryptoStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.Security.Cryptography.CryptoStream
  langs:
  - csharp
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: CryptoStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.Security.Cryptography.CryptoStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "将一个字节序列异步写入当前流，使流中的当前位置提升写入字节数，并监视取消请求。"
  remarks: "必须在对 WriteAsync 与调用之前添加`await`(C#) 或`Await`(Visual Basic 中) 运算符可暂停执行方法，直到完成该任务为止。 有关详细信息，请参阅[使用 Async 和 Await 进行异步编程](~/add/includes/ajax-current-ext-md.md)。       如果在完成之前，将取消该操作，返回的任务包含<xref:System.Threading.Tasks.TaskStatus>值<xref:System.Threading.Tasks.Task.Status%2A>属性。</xref:System.Threading.Tasks.Task.Status%2A> </xref:System.Threading.Tasks.TaskStatus>"
  syntax:
    content: public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "要写入数据的缓冲区。"
    - id: offset
      type: System.Int32
      description: "中的从零开始的字节偏移量`buffer`从此处开始将字节写入流。"
    - id: count
      type: System.Int32
      description: "最大写入的字节数。"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "要监视取消请求的标记。 默认值为<xref:System.Threading.CancellationToken.None*>。</xref:System.Threading.CancellationToken.None*>"
    return:
      type: System.Threading.Tasks.Task
      description: "表示异步写入操作的任务。"
  overload: System.Security.Cryptography.CryptoStream.WriteAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>或<code>count</code>为负。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "总和<code> offset </code>和<code> count </code>大于缓冲区长度。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "流不支持写入。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已释放流。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "当前正在由前一个写操作使用流。"
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.Security.Cryptography.CryptographicException
  parent: System.Security.Cryptography
  isExternal: false
  name: CryptographicException
  nameWithType: CryptographicException
  fullName: System.Security.Cryptography.CryptographicException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Security.Cryptography.CryptoStream.#ctor(System.IO.Stream,System.Security.Cryptography.ICryptoTransform,System.Security.Cryptography.CryptoStreamMode)
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: CryptoStream(Stream,ICryptoTransform,CryptoStreamMode)
  nameWithType: CryptoStream.CryptoStream(Stream,ICryptoTransform,CryptoStreamMode)
  fullName: System.Security.Cryptography.CryptoStream.CryptoStream(Stream,ICryptoTransform,CryptoStreamMode)
- uid: System.Security.Cryptography.ICryptoTransform
  parent: System.Security.Cryptography
  isExternal: false
  name: ICryptoTransform
  nameWithType: ICryptoTransform
  fullName: System.Security.Cryptography.ICryptoTransform
- uid: System.Security.Cryptography.CryptoStreamMode
  parent: System.Security.Cryptography
  isExternal: false
  name: CryptoStreamMode
  nameWithType: CryptoStreamMode
  fullName: System.Security.Cryptography.CryptoStreamMode
- uid: System.Security.Cryptography.CryptoStream.CanRead
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: CanRead
  nameWithType: CryptoStream.CanRead
  fullName: System.Security.Cryptography.CryptoStream.CanRead
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Security.Cryptography.CryptoStream.CanSeek
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: CanSeek
  nameWithType: CryptoStream.CanSeek
  fullName: System.Security.Cryptography.CryptoStream.CanSeek
- uid: System.Security.Cryptography.CryptoStream.CanWrite
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: CanWrite
  nameWithType: CryptoStream.CanWrite
  fullName: System.Security.Cryptography.CryptoStream.CanWrite
- uid: System.Security.Cryptography.CryptoStream.Clear
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: Clear()
  nameWithType: CryptoStream.Clear()
  fullName: System.Security.Cryptography.CryptoStream.Clear()
- uid: System.Security.Cryptography.CryptoStream.Dispose(System.Boolean)
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: CryptoStream.Dispose(Boolean)
  fullName: System.Security.Cryptography.CryptoStream.Dispose(Boolean)
- uid: System.Security.Cryptography.CryptoStream.Flush
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: Flush()
  nameWithType: CryptoStream.Flush()
  fullName: System.Security.Cryptography.CryptoStream.Flush()
- uid: System.Security.Cryptography.CryptoStream.FlushAsync(System.Threading.CancellationToken)
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: FlushAsync(CancellationToken)
  nameWithType: CryptoStream.FlushAsync(CancellationToken)
  fullName: System.Security.Cryptography.CryptoStream.FlushAsync(CancellationToken)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.Security.Cryptography.CryptoStream.FlushFinalBlock
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: FlushFinalBlock()
  nameWithType: CryptoStream.FlushFinalBlock()
  fullName: System.Security.Cryptography.CryptoStream.FlushFinalBlock()
- uid: System.Security.Cryptography.CryptoStream.HasFlushedFinalBlock
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: HasFlushedFinalBlock
  nameWithType: CryptoStream.HasFlushedFinalBlock
  fullName: System.Security.Cryptography.CryptoStream.HasFlushedFinalBlock
- uid: System.Security.Cryptography.CryptoStream.Length
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: Length
  nameWithType: CryptoStream.Length
  fullName: System.Security.Cryptography.CryptoStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Security.Cryptography.CryptoStream.Position
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: Position
  nameWithType: CryptoStream.Position
  fullName: System.Security.Cryptography.CryptoStream.Position
- uid: System.Security.Cryptography.CryptoStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: CryptoStream.Read(Byte[],Int32,Int32)
  fullName: System.Security.Cryptography.CryptoStream.Read(Byte[],Int32,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Security.Cryptography.CryptoStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: CryptoStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.Security.Cryptography.CryptoStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.Threading.Tasks.Task{System.Int32}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<Int32>
  nameWithType: Task<Int32>
  fullName: System.Threading.Tasks.Task<System.Int32>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Int32>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Security.Cryptography.CryptoStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: CryptoStream.Seek(Int64,SeekOrigin)
  fullName: System.Security.Cryptography.CryptoStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.Security.Cryptography.CryptoStream.SetLength(System.Int64)
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: CryptoStream.SetLength(Int64)
  fullName: System.Security.Cryptography.CryptoStream.SetLength(Int64)
- uid: System.Security.Cryptography.CryptoStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: CryptoStream.Write(Byte[],Int32,Int32)
  fullName: System.Security.Cryptography.CryptoStream.Write(Byte[],Int32,Int32)
- uid: System.Security.Cryptography.CryptoStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: CryptoStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.Security.Cryptography.CryptoStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.Security.Cryptography.CryptoStream.#ctor*
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: CryptoStream
  nameWithType: CryptoStream.CryptoStream
- uid: System.Security.Cryptography.CryptoStream.CanRead*
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: CanRead
  nameWithType: CryptoStream.CanRead
- uid: System.Security.Cryptography.CryptoStream.CanSeek*
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: CanSeek
  nameWithType: CryptoStream.CanSeek
- uid: System.Security.Cryptography.CryptoStream.CanWrite*
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: CanWrite
  nameWithType: CryptoStream.CanWrite
- uid: System.Security.Cryptography.CryptoStream.Clear*
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: Clear
  nameWithType: CryptoStream.Clear
- uid: System.Security.Cryptography.CryptoStream.Dispose*
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: Dispose
  nameWithType: CryptoStream.Dispose
- uid: System.Security.Cryptography.CryptoStream.Flush*
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: Flush
  nameWithType: CryptoStream.Flush
- uid: System.Security.Cryptography.CryptoStream.FlushAsync*
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: FlushAsync
  nameWithType: CryptoStream.FlushAsync
- uid: System.Security.Cryptography.CryptoStream.FlushFinalBlock*
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: FlushFinalBlock
  nameWithType: CryptoStream.FlushFinalBlock
- uid: System.Security.Cryptography.CryptoStream.HasFlushedFinalBlock*
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: HasFlushedFinalBlock
  nameWithType: CryptoStream.HasFlushedFinalBlock
- uid: System.Security.Cryptography.CryptoStream.Length*
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: Length
  nameWithType: CryptoStream.Length
- uid: System.Security.Cryptography.CryptoStream.Position*
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: Position
  nameWithType: CryptoStream.Position
- uid: System.Security.Cryptography.CryptoStream.Read*
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: Read
  nameWithType: CryptoStream.Read
- uid: System.Security.Cryptography.CryptoStream.ReadAsync*
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: ReadAsync
  nameWithType: CryptoStream.ReadAsync
- uid: System.Security.Cryptography.CryptoStream.Seek*
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: Seek
  nameWithType: CryptoStream.Seek
- uid: System.Security.Cryptography.CryptoStream.SetLength*
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: SetLength
  nameWithType: CryptoStream.SetLength
- uid: System.Security.Cryptography.CryptoStream.Write*
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: Write
  nameWithType: CryptoStream.Write
- uid: System.Security.Cryptography.CryptoStream.WriteAsync*
  parent: System.Security.Cryptography.CryptoStream
  isExternal: false
  name: WriteAsync
  nameWithType: CryptoStream.WriteAsync
