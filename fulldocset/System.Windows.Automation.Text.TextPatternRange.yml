### YamlMime:ManagedReference
items:
- uid: System.Windows.Automation.Text.TextPatternRange
  id: TextPatternRange
  children:
  - System.Windows.Automation.Text.TextPatternRange.AddToSelection
  - System.Windows.Automation.Text.TextPatternRange.Clone
  - System.Windows.Automation.Text.TextPatternRange.Compare(System.Windows.Automation.Text.TextPatternRange)
  - System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  - System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)
  - System.Windows.Automation.Text.TextPatternRange.FindAttribute(System.Windows.Automation.AutomationTextAttribute,System.Object,System.Boolean)
  - System.Windows.Automation.Text.TextPatternRange.FindText(System.String,System.Boolean,System.Boolean)
  - System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(System.Windows.Automation.AutomationTextAttribute)
  - System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles
  - System.Windows.Automation.Text.TextPatternRange.GetChildren
  - System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement
  - System.Windows.Automation.Text.TextPatternRange.GetText(System.Int32)
  - System.Windows.Automation.Text.TextPatternRange.Move(System.Windows.Automation.Text.TextUnit,System.Int32)
  - System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  - System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)
  - System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection
  - System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(System.Boolean)
  - System.Windows.Automation.Text.TextPatternRange.Select
  - System.Windows.Automation.Text.TextPatternRange.TextPattern
  langs:
  - csharp
  name: TextPatternRange
  nameWithType: TextPatternRange
  fullName: System.Windows.Automation.Text.TextPatternRange
  type: Class
  summary: "表示中的一块连续文本<xref href=&quot;System.Windows.Automation.TextPattern&quot;></xref>容器。"
  remarks: "TextPatternRange 可以表示的插入点、 一个子集，或所有中的文本<xref:System.Windows.Automation.TextPattern>容器。</xref:System.Windows.Automation.TextPattern>       TextPatternRange 将变为无效，如果发生以下之一︰ 中的文本<xref:System.Windows.Automation.TextPattern>由于某些用户活动的容器更改或<xref:System.Windows.Automation.ValuePattern.SetValue%2A>方法<xref:System.Windows.Automation.ValuePattern>用于以编程方式更改中的文本值<xref:System.Windows.Automation.TextPattern>容器。</xref:System.Windows.Automation.TextPattern> </xref:System.Windows.Automation.ValuePattern> </xref:System.Windows.Automation.ValuePattern.SetValue%2A> </xref:System.Windows.Automation.TextPattern>"
  syntax:
    content: public class TextPatternRange
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.AddToSelection
  id: AddToSelection
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: AddToSelection()
  nameWithType: TextPatternRange.AddToSelection()
  fullName: System.Windows.Automation.Text.TextPatternRange.AddToSelection()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "将添加到的支持多个的文本容器中的突出显示文本集合中，不连续选择。"
  remarks: "文本插入点移到新选择的区域。       提供退化文本范围移动插入点。"
  syntax:
    content: public void AddToSelection ();
    parameters: []
  overload: System.Windows.Automation.Text.TextPatternRange.AddToSelection*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "如果文本提供程序不支持多个不连续选择 (例如，<xref:System.Windows.Automation.TextPattern.SupportedTextSelection*>的值必须<xref uid=&quot;langword_csharp_Multiple&quot; name=&quot;Multiple&quot; href=&quot;&quot;> </xref>)。</xref:System.Windows.Automation.TextPattern.SupportedTextSelection*>"
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.Clone
  id: Clone
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: Clone()
  nameWithType: TextPatternRange.Clone()
  fullName: System.Windows.Automation.Text.TextPatternRange.Clone()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "检索新<xref href=&quot;System.Windows.Automation.Text.TextPatternRange&quot;></xref>等于原始<xref href=&quot;System.Windows.Automation.Text.TextPatternRange&quot;></xref>并且继承了其原始的所有属性。"
  remarks: "或者，创建一个新<xref:System.Windows.Automation.TextPattern.DocumentRange%2A>从<xref:System.Windows.Automation.TextPattern>并移动两个终结点以与原始的文本范围的终结点对应。</xref:System.Windows.Automation.TextPattern> </xref:System.Windows.Automation.TextPattern.DocumentRange%2A>       新的范围可以从原始独立操作。"
  example:
  - "[!code-cs[UIATextPattern_snip#1060](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1060)]  \n  \n [!code-vb[UIATextPattern_snip#2060](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2060)]"
  syntax:
    content: public System.Windows.Automation.Text.TextPatternRange Clone ();
    parameters: []
    return:
      type: System.Windows.Automation.Text.TextPatternRange
      description: "新的文本范围。 空引用 (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref>中[!INCLUDE[TLA#tla_visualbnet](~/add/includes/tlasharptla-visualbnet-md.md)]) 永远不会返回。"
  overload: System.Windows.Automation.Text.TextPatternRange.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.Compare(System.Windows.Automation.Text.TextPatternRange)
  id: Compare(System.Windows.Automation.Text.TextPatternRange)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: Compare(TextPatternRange)
  nameWithType: TextPatternRange.Compare(TextPatternRange)
  fullName: System.Windows.Automation.Text.TextPatternRange.Compare(TextPatternRange)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "返回<xref:System.Boolean>值，该值指示是否跨度 ( <xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref>终结点<xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;></xref>终结点) 的文本范围是另一个文本范围相同。</xref:System.Boolean>"
  remarks: ''
  example:
  - "[!code-cs[UIATextPattern_snip#1061](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1061)]  \n  \n [!code-vb[UIATextPattern_snip#2061](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2061)]"
  syntax:
    content: public bool Compare (System.Windows.Automation.Text.TextPatternRange range);
    parameters:
    - id: range
      type: System.Windows.Automation.Text.TextPatternRange
      description: "要比较的文本范围。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果两个文本范围的跨度相同;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.Automation.Text.TextPatternRange.Compare*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "如果要比较的范围不是来自同一文本提供程序。"
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  id: CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: CompareEndpoints(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  nameWithType: TextPatternRange.CompareEndpoints(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  fullName: System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "返回<xref:System.Int32>，该值指示两个文本范围是否具有相同的终结点。</xref:System.Int32>"
  remarks: "通过比较相同的文本范围的起始和结束终结点可以识别退化文本范围是否或终结点的顺序是否与逻辑文本流。"
  example:
  - "[!code-cs[UIATextPattern_snip#1062](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1062)]  \n  \n [!code-vb[UIATextPattern_snip#2062](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2062)]"
  syntax:
    content: public int CompareEndpoints (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextPatternRange targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);
    parameters:
    - id: endpoint
      type: System.Windows.Automation.Text.TextPatternRangeEndpoint
      description: "<xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref>或<xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;></xref>调用方的终结点。"
    - id: targetRange
      type: System.Windows.Automation.Text.TextPatternRange
      description: "比较在目标范围。"
    - id: targetEndpoint
      type: System.Windows.Automation.Text.TextPatternRangeEndpoint
      description: "<xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref>或<xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;></xref>的目标终结点。"
    return:
      type: System.Int32
      description: "如果调用方的端点出现前面的文本中比目标端点，则，返回一个负值。       如果调用方的终结点位于与目标终结点相同的位置，则返回零。       如果调用方的端点在文本中比目标端点后出现，则，返回一个正值。"
  overload: System.Windows.Automation.Text.TextPatternRange.CompareEndpoints*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "如果范围为空引用 (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref>中[!INCLUDE[TLA#tla_visualbnet](~/add/includes/tlasharptla-visualbnet-md.md)])。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "如果范围是从另一个容器。"
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)
  id: ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: ExpandToEnclosingUnit(TextUnit)
  nameWithType: TextPatternRange.ExpandToEnclosingUnit(TextUnit)
  fullName: System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(TextUnit)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "将文本范围扩展到指定<xref href=&quot;System.Windows.Automation.Text.TextUnit&quot;> </xref>。"
  remarks: "如果已指定的单位的确切数量范围。 它保持不变。       为了使 expandtoenclosingunit 进行方法才能成功执行，在后台执行一系列操作。      1.  文本范围进行了规范化;也就是说，将文本范围折叠为退化范围，在<xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>终结点，使<xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>终结点成为多余。</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> </xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> 此步骤是必需的文本范围跨越其中的情况下消除歧义`unit`边界; 例如，&quot;{The U} RL [http://www.microsoft.com](http://www.microsoft.com)文本中嵌入&quot;位置&quot;{&quot;和&quot;}&quot;是文本范围端点。      2.  生成的范围中向后移动<xref:System.Windows.Automation.TextPattern.DocumentRange%2A>到所请求的开头`unit`边界。</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>      3.  该区域中向前或向后移动<xref:System.Windows.Automation.TextPattern.DocumentRange%2A>的请求数`unit`边界。</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>      4.  然后扩展范围从退化范围状态通过移动<xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>一个所请求的终结点`unit`边界。</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>       ![通过移动 & expandtoenclosingunit 进行的范围调整](~/add/media/uia-textpattern-moveandexpand-examples.png &quot;通过移动 & expandtoenclosingunit 进行的范围调整&quot;)如何 （） 和 expandtoenclosingunit （） 调整文本范围的示例&1;> [!NOTE]&1;> 这些步骤是必需的因为它是常见的屏幕读取器读取出完整单词、 句子或在插入点或任何虚拟光标位置处的整个段落。       Expandtoenclosingunit 进行尊重隐藏和显示文本。 UI 自动化客户端可以检查<xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>文本可见性。</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>       下一步将 expandtoenclosingunit 进行遵从最大<xref:System.Windows.Automation.Text.TextUnit>支持的如果给定<xref:System.Windows.Automation.Text.TextUnit>控件不支持。</xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit>       下面列出的顺序，从最小单位到最大值。      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit>"
  example:
  - "[!code-cs[UIATextPattern_snip#1063](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1063)]  \n  \n [!code-vb[UIATextPattern_snip#2063](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2063)]"
  syntax:
    content: public void ExpandToEnclosingUnit (System.Windows.Automation.Text.TextUnit unit);
    parameters:
    - id: unit
      type: System.Windows.Automation.Text.TextUnit
      description: "文本单位。"
  overload: System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.FindAttribute(System.Windows.Automation.AutomationTextAttribute,System.Object,System.Boolean)
  id: FindAttribute(System.Windows.Automation.AutomationTextAttribute,System.Object,System.Boolean)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: FindAttribute(AutomationTextAttribute,Object,Boolean)
  nameWithType: TextPatternRange.FindAttribute(AutomationTextAttribute,Object,Boolean)
  fullName: System.Windows.Automation.Text.TextPatternRange.FindAttribute(AutomationTextAttribute,Object,Boolean)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "返回具有指定的特性值的文本范围子集。"
  remarks: "隐藏和显示文本之间没有差异。 UI 自动化客户端可以使用<xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>检查文本可见性。</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>      1> [!NOTE]&1;> 使用<xref:System.Windows.Automation.TextPattern.DocumentRange%2A>要搜索整个文档。</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>"
  example:
  - "[!code-cs[UIATextPattern_snip#1064](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1064)]  \n  \n [!code-vb[UIATextPattern_snip#2064](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2064)]"
  syntax:
    content: public System.Windows.Automation.Text.TextPatternRange FindAttribute (System.Windows.Automation.AutomationTextAttribute attribute, object value, bool backward);
    parameters:
    - id: attribute
      type: System.Windows.Automation.AutomationTextAttribute
      description: "要搜索的属性。"
    - id: value
      type: System.Object
      description: "要搜索的属性值。 此值必须匹配的属性指定的类型。"
    - id: backward
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果最后一个匹配的文本范围应返回而不是第一个;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.Windows.Automation.Text.TextPatternRange
      description: "具有匹配特性和属性值，则为文本范围否则为 null (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref>中[!INCLUDE[TLA#tla_visualbnet](~/add/includes/tlasharptla-visualbnet-md.md)])。"
  overload: System.Windows.Automation.Text.TextPatternRange.FindAttribute*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.FindText(System.String,System.Boolean,System.Boolean)
  id: FindText(System.String,System.Boolean,System.Boolean)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: FindText(String,Boolean,Boolean)
  nameWithType: TextPatternRange.FindText(String,Boolean,Boolean)
  fullName: System.Windows.Automation.Text.TextPatternRange.FindText(String,Boolean,Boolean)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "返回包含指定的文本的文本范围子集。"
  remarks: "隐藏和显示文本之间没有差异。 UI 自动化客户端可以使用<xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>检查文本可见性。</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>      1> [!NOTE]&1;> 使用<xref:System.Windows.Automation.TextPattern.DocumentRange%2A>要搜索整个文档。</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>"
  example:
  - "[!code-cs[UIATextPattern_snip#1065](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1065)]  \n  \n [!code-vb[UIATextPattern_snip#2065](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2065)]"
  syntax:
    content: public System.Windows.Automation.Text.TextPatternRange FindText (string text, bool backward, bool ignoreCase);
    parameters:
    - id: text
      type: System.String
      description: "要搜索的文本字符串。"
    - id: backward
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果最后一个匹配的文本范围应返回而不是第一个;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    - id: ignoreCase
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果应该忽略大小写;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.Windows.Automation.Text.TextPatternRange
      description: "指定的文本; 匹配的文本范围否则为 null (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref>中[!INCLUDE[TLA#tla_visualbnet](~/add/includes/tlasharptla-visualbnet-md.md)])。"
  overload: System.Windows.Automation.Text.TextPatternRange.FindText*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(System.Windows.Automation.AutomationTextAttribute)
  id: GetAttributeValue(System.Windows.Automation.AutomationTextAttribute)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: GetAttributeValue(AutomationTextAttribute)
  nameWithType: TextPatternRange.GetAttributeValue(AutomationTextAttribute)
  fullName: System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(AutomationTextAttribute)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "返回整个文本范围内的指定属性的值。"
  remarks: "隐藏和显示文本之间没有差异。 UI 自动化客户端可以使用<xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>检查文本可见性。</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>"
  example:
  - "[!code-cs[UIATextPattern_snip#1066](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1066)]  \n  \n [!code-vb[UIATextPattern_snip#2066](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2066)]"
  syntax:
    content: public object GetAttributeValue (System.Windows.Automation.AutomationTextAttribute attribute);
    parameters:
    - id: attribute
      type: System.Windows.Automation.AutomationTextAttribute
      description: "文本特性。"
    return:
      type: System.Object
      description: "返回指定的属性的值。 例如，getattributevalue （textpattern.fontnameattribute） 将返回一个字符串，表示字体名称，如果唯一的而 getattributevalue （textpattern.isitalicattribute） 的文本范围将返回一个布尔值。       返回<xref href=&quot;System.Windows.Automation.TextPattern.MixedAttributeValue&quot;></xref>如果在文本范围内的指定属性的值会发生变化。       返回<xref href=&quot;System.Windows.Automation.AutomationElement.NotSupported&quot;></xref>如果提供程序或控件不支持指定的属性。"
  overload: System.Windows.Automation.Text.TextPatternRange.GetAttributeValue*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "如果指定的属性不是有效的。"
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles
  id: GetBoundingRectangles
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: GetBoundingRectangles()
  nameWithType: TextPatternRange.GetBoundingRectangles()
  fullName: System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "检索文本范围中的文本的每个完全或部分可见的行个边框组成的集合。"
  remarks: ''
  example:
  - "[!code-cs[UIATextPattern_snip#1067](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1067)]  \n  \n [!code-vb[UIATextPattern_snip#2067](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2067)]"
  syntax:
    content: public System.Windows.Rect[] GetBoundingRectangles ();
    parameters: []
    return:
      type: System.Windows.Rect[]
      description: "边框的文本范围中的文本每整个或部分行组成的数组。       对于退化文本范围为空数组。       文本范围具有其屏幕坐标完全位于屏幕之外，为一个空数组滚动到视图中，或者被某个重叠窗口遮盖住。"
  overload: System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.GetChildren
  id: GetChildren
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: GetChildren()
  nameWithType: TextPatternRange.GetChildren()
  fullName: System.Windows.Automation.Text.TextPatternRange.GetChildren()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "检索文本范围内的所有嵌入对象的集合。"
  remarks: ''
  example:
  - "[!code-vb[UIATextPattern_snip#StartTarget](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#starttarget)]\n [!code-cs[UIATextPattern_snip#StartTarget](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#starttarget)]  \n[!code-vb[UIATextPattern_snip#GetTextElement](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#gettextelement)]\n[!code-cs[UIATextPattern_snip#GetTextElement](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#gettextelement)]  \n[!code-vb[UIATextPattern_snip#GetEmbeddedObjects](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#getembeddedobjects)]\n[!code-cs[UIATextPattern_snip#GetEmbeddedObjects](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#getembeddedobjects)]"
  syntax:
    content: public System.Windows.Automation.AutomationElement[] GetChildren ();
    parameters: []
    return:
      type: System.Windows.Automation.AutomationElement[]
      description: "在范围内的所有子对象的集合。 与范围发生重叠但是并未完全包括由它的子对象也会包括在集合中。       如果不有任何子对象，则返回一个空集合。"
  overload: System.Windows.Automation.Text.TextPatternRange.GetChildren*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement
  id: GetEnclosingElement
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: GetEnclosingElement()
  nameWithType: TextPatternRange.GetEnclosingElement()
  fullName: System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "返回最内层<xref href=&quot;System.Windows.Automation.AutomationElement&quot;></xref>包含该文本范围。"
  remarks: "封闭<xref:System.Windows.Automation.AutomationElement>，通常提供该文本范围的文本提供程序。</xref:System.Windows.Automation.AutomationElement> 但是，如果文本提供程序支持表格或超链接这样的子元素，那么包含元素可能为文本提供程序的子代。"
  example:
  - "[!code-cs[UIATextPattern_snip#1069](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1069)]  \n  \n [!code-vb[UIATextPattern_snip#2069](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2069)]"
  syntax:
    content: public System.Windows.Automation.AutomationElement GetEnclosingElement ();
    parameters: []
    return:
      type: System.Windows.Automation.AutomationElement
      description: "包含调用方的最内层元素。"
  overload: System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.GetText(System.Int32)
  id: GetText(System.Int32)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: GetText(Int32)
  nameWithType: TextPatternRange.GetText(Int32)
  fullName: System.Windows.Automation.Text.TextPatternRange.GetText(Int32)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "返回文本范围的纯文本。"
  remarks: "GetText 尊重隐藏和显示文本。 UI 自动化客户端可以检查<xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>文本可见性。</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>       如果`maxLength`大于长度的调用方的文本范围内，返回的字符串将文本范围的纯文本。       GetText 将不受影响的文本流; 中的终结点的顺序它将始终返回逻辑文本流顺序中的文本范围的开始和结束终结点之间的文本。"
  example:
  - "[!code-cs[UIATextPattern_snip#1070](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1070)]  \n  \n [!code-vb[UIATextPattern_snip#2070](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2070)]"
  syntax:
    content: public string GetText (int maxLength);
    parameters:
    - id: maxLength
      type: System.Int32
      description: "要返回的字符串的最大长度。 使用`-1`如果没有限制，则。"
    return:
      type: System.String
      description: "文本范围，可能截断在指定的纯文本<code> maxLength </code>。"
  overload: System.Windows.Automation.Text.TextPatternRange.GetText*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "如果<code> maxLength </code>小于-1。"
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.Move(System.Windows.Automation.Text.TextUnit,System.Int32)
  id: Move(System.Windows.Automation.Text.TextUnit,System.Int32)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: Move(TextUnit,Int32)
  nameWithType: TextPatternRange.Move(TextUnit,Int32)
  fullName: System.Windows.Automation.Text.TextPatternRange.Move(TextUnit,Int32)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "将移动文本范围指定数量的文本单位。"
  remarks: "需要遍历文本范围的内容时，为了让移动方法才能成功执行在幕后涉及一系列步骤。      1.  文本范围进行了规范化;也就是说，将文本范围折叠为退化范围，在<xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>终结点，这使得<xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>终结点成为多余。</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> </xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> 此步骤是必需的文本范围跨越其中的情况下消除歧义`unit`边界; 例如，&quot;{The U} RL [http://www.microsoft.com](http://www.microsoft.com)文本中嵌入&quot;位置&quot;{&quot;和&quot;}&quot;是文本范围端点。      2.  生成的范围中向后移动<xref:System.Windows.Automation.TextPattern.DocumentRange%2A>到所请求的开头`unit`边界。</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>      3.  该区域中向前或向后移动<xref:System.Windows.Automation.TextPattern.DocumentRange%2A>的请求数`unit`边界。</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>      4.  然后扩展范围从退化范围状态通过移动<xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>一个所请求的终结点`unit`边界。</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>       ![通过移动 & expandtoenclosingunit 进行的范围调整](~/add/media/uia-textpattern-moveandexpand-examples.png &quot;通过移动 & expandtoenclosingunit 进行的范围调整&quot;)Move() 和 expandtoenclosingunit （） 的文本内容 （或内部文本） 的文本容器和嵌入的对象，如超链接或表格单元格，如何调整文本范围的示例作为单个连续文本流中的控件视图和内容视图公开[!INCLUDE[TLA2#tla_uiautomation](~/add/includes/tla2sharptla-uiautomation-md.md)]树; 对象边界被忽略。 如果 UI 自动化客户端检索文本的目的叙述、 解释或分析以某种方式，应检查文本范围中的特殊情况下，例如含有文本内容或其他嵌入对象的表格。 这可以通过调用来实现<xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A>获取<xref:System.Windows.Automation.AutomationElement>每个嵌入对象，然后再调用<xref:System.Windows.Automation.TextPattern.RangeFromChild%2A>以获取每个元素; 的文本范围直到检索到所有文本内容这是以递归方式。</xref:System.Windows.Automation.TextPattern.RangeFromChild%2A> </xref:System.Windows.Automation.AutomationElement> </xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A>       ![跨的嵌入对象的文本范围。](~/add/media/uia-textpattern-embeddedobjecttextranges.png &quot;跨嵌入对象的文本范围。&quot;)   含有嵌入的对象以及它们的范围的文本流的示例跨移动方面这两个隐藏和可见文本。 UI 自动化客户端可以检查<xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>文本可见性。</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>       移动交下一个最大<xref:System.Windows.Automation.Text.TextUnit>支持的如果给定<xref:System.Windows.Automation.Text.TextUnit>控件不支持。</xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit>       下面列出的顺序，从最小单位到最大值。      - <xref:System.Windows.Automation.Text.TextUnit>- <xref:System.Windows.Automation.Text.TextUnit>- <xref:System.Windows.Automation.Text.TextUnit>- <xref:System.Windows.Automation.Text.TextUnit>- <xref:System.Windows.Automation.Text.TextUnit>- <xref:System.Windows.Automation.Text.TextUnit>- <xref:System.Windows.Automation.Text.TextUnit>1> [!NOTE]&1;> 文本不更改以任何方式，因为文本范围只跨越不同部分的文本。</xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit>"
  example:
  - "[!code-vb[UIATextPattern_snip#StartTarget](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#starttarget)]\n [!code-cs[UIATextPattern_snip#StartTarget](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#starttarget)]  \n[!code-vb[UIATextPattern_snip#GetTextElement](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#gettextelement)]\n[!code-cs[UIATextPattern_snip#GetTextElement](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#gettextelement)]  \n[!code-vb[UIATextPattern_snip#MoveSelection](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#moveselection)]\n[!code-cs[UIATextPattern_snip#MoveSelection](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#moveselection)]"
  syntax:
    content: public int Move (System.Windows.Automation.Text.TextUnit unit, int count);
    parameters:
    - id: unit
      type: System.Windows.Automation.Text.TextUnit
      description: "文本单位的边界。"
    - id: count
      type: System.Int32
      description: "要移动的文本单位数。 正值表示向前移动文本范围、 负值则表示移动文本范围倒退了，和 0 不起作用。"
    return:
      type: System.Int32
      description: "实际移动的单位数。 它可能小于请求移动数如果新的文本范围端点大于或小于比<xref:System.Windows.Automation.TextPattern.DocumentRange*>终结点。</xref:System.Windows.Automation.TextPattern.DocumentRange*>"
  overload: System.Windows.Automation.Text.TextPatternRange.Move*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  id: MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: MoveEndpointByRange(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  nameWithType: TextPatternRange.MoveEndpointByRange(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  fullName: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "将文本范围的一个端点移动到第二个文本范围的指定端点。"
  remarks: "如果要移动的终结点是跨相同的文本范围的其他终结点，则该其他终结点也会随，从而导致退化范围，并确保正确的顺序的终结点 (即，<xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>是否始终小于或等于<xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>)。</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> </xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>"
  example:
  - "[!code-cs[UIATextPattern_snip#1072](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1072)]  \n  \n [!code-vb[UIATextPattern_snip#2072](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2072)]"
  syntax:
    content: public void MoveEndpointByRange (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextPatternRange targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);
    parameters:
    - id: endpoint
      type: System.Windows.Automation.Text.TextPatternRangeEndpoint
      description: "要移动的端点。"
    - id: targetRange
      type: System.Windows.Automation.Text.TextPatternRange
      description: "从同一文本提供程序的另一个范围。"
    - id: targetEndpoint
      type: System.Windows.Automation.Text.TextPatternRangeEndpoint
      description: "另一个范围终结点。"
  overload: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)
  id: MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: MoveEndpointByUnit(TextPatternRangeEndpoint,TextUnit,Int32)
  nameWithType: TextPatternRange.MoveEndpointByUnit(TextPatternRangeEndpoint,TextUnit,Int32)
  fullName: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(TextPatternRangeEndpoint,TextUnit,Int32)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "一个终结点的文本范围的移动指定的数量的<xref href=&quot;System.Windows.Automation.Text.TextUnit&quot;></xref>文档范围。"
  remarks: "需要遍历文本范围的内容时，以便在后台涉及一系列步骤<xref:System.Windows.Automation.Text.TextPatternRange.Move%2A>方法才能成功执行。</xref:System.Windows.Automation.Text.TextPatternRange.Move%2A>      1.  文本范围进行了规范化;也就是说，将文本范围折叠为退化范围，在<xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>终结点，这使得<xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>终结点成为多余。</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> </xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> 此步骤是必需的文本范围跨越其中的情况下消除歧义`unit`边界; 例如，&quot;{The U} RL [http://www.microsoft.com](http://www.microsoft.com)文本中嵌入&quot;位置&quot;{&quot;和&quot;}&quot;是文本范围端点。      2.  生成的范围中向后移动<xref:System.Windows.Automation.TextPattern.DocumentRange%2A>到所请求的开头`unit`边界。</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>      3.  然后扩展范围从退化范围状态通过移动<xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>一个所请求的终结点`unit`边界。</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>       ![通过移动 & expandtoenclosingunit 进行的范围调整](~/add/media/uia-textpattern-moveandexpand-examples.png &quot;通过移动 & expandtoenclosingunit 进行的范围调整&quot;)Move() 和 expandtoenclosingunit （） 的文本内容 （或内部文本） 的文本容器和嵌入的对象，如超链接或表格单元格，如何调整文本范围的示例作为单个连续文本流中的控件视图和内容视图公开[!INCLUDE[TLA2#tla_uiautomation](~/add/includes/tla2sharptla-uiautomation-md.md)]树; 对象边界被忽略。 如果 UI 自动化客户端检索文本的目的叙述、 解释或分析以某种方式，应检查文本范围中的特殊情况下，例如含有文本内容或其他嵌入对象的表格。 这可以通过调用来实现<xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A>获取<xref:System.Windows.Automation.AutomationElement>每个嵌入对象，然后再调用<xref:System.Windows.Automation.TextPattern.RangeFromChild%2A>以获取每个元素; 的文本范围直到检索到所有文本内容这是以递归方式。</xref:System.Windows.Automation.TextPattern.RangeFromChild%2A> </xref:System.Windows.Automation.AutomationElement> </xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A>       ![跨的嵌入对象的文本范围。](~/add/media/uia-textpattern-embeddedobjecttextranges.png &quot;跨嵌入对象的文本范围。&quot;)   含有嵌入的对象和 MoveEndpointByUnit 交下一步及其范围跨度的文本流示例最大<xref:System.Windows.Automation.Text.TextUnit>支持的如果给定<xref:System.Windows.Automation.Text.TextUnit>控件不支持。</xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit>       下面列出的顺序，从最小单位到最大值。      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit>"
  example:
  - "[!code-cs[UIATextPattern_snip#1073](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1073)]  \n  \n [!code-vb[UIATextPattern_snip#2073](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2073)]"
  syntax:
    content: public int MoveEndpointByUnit (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextUnit unit, int count);
    parameters:
    - id: endpoint
      type: System.Windows.Automation.Text.TextPatternRangeEndpoint
      description: "要移动的端点。"
    - id: unit
      type: System.Windows.Automation.Text.TextUnit
      description: "移动文本单位。"
    - id: count
      type: System.Int32
      description: "要移动的单位数。 正值表示向前移动端点。 负值向后移动。 计数为 0 无任何影响。"
    return:
      type: System.Int32
      description: "实际移动的单位数，移动则可能小于请求如果端点时遇到的开头或末尾的文档。"
  overload: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection
  id: RemoveFromSelection
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: RemoveFromSelection()
  nameWithType: TextPatternRange.RemoveFromSelection()
  fullName: System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "删除与调用文本范围对应的突出显示的部分<xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;></xref>和<xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;></xref>终结点，从现有的支持多个的文本容器中的突出显示文本集合不连续选择。"
  remarks: "文本插入点将移到删除突出显示的区域中。       提供退化文本范围将移动插入点。"
  syntax:
    content: public void RemoveFromSelection ();
    parameters: []
  overload: System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "如果文本提供程序不支持多个不连续选择 (例如，<xref:System.Windows.Automation.TextPattern.SupportedTextSelection*>的值必须<xref uid=&quot;langword_csharp_Multiple&quot; name=&quot;Multiple&quot; href=&quot;&quot;> </xref>)。</xref:System.Windows.Automation.TextPattern.SupportedTextSelection*>"
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(System.Boolean)
  id: ScrollIntoView(System.Boolean)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: ScrollIntoView(Boolean)
  nameWithType: TextPatternRange.ScrollIntoView(Boolean)
  fullName: System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(Boolean)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "导致文本控件垂直滚动，直到文本范围在视区中可见。"
  remarks: "ScrollIntoView 尊重隐藏和显示文本。 UI 自动化客户端可以检查<xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>文本可见性。</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> 如果隐藏的文本范围，仅当隐藏的文本锚有视区中将滚动文本控件。"
  example:
  - "[!code-cs[UIATextPattern_snip#1074](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1074)]  \n  \n [!code-vb[UIATextPattern_snip#2074](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2074)]"
  syntax:
    content: public void ScrollIntoView (bool alignToTop);
    parameters:
    - id: alignToTop
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果文本控件应该滚动以便文本范围与视区; 顶部对齐<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>如果应该与视区底部对齐。"
  overload: System.Windows.Automation.Text.TextPatternRange.ScrollIntoView*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "如果控件不支持滚动。"
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.Select
  id: Select
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: Select()
  nameWithType: TextPatternRange.Select()
  fullName: System.Windows.Automation.Text.TextPatternRange.Select()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "突出显示对应于文本范围的文本控件中的文本<xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;></xref>和<xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;></xref>终结点。"
  remarks: "如果提供退化文本范围，则将将文本插入点移到<xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>的文本范围的终结点。</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>"
  example:
  - "[!code-cs[UIATextPattern_snip#1075](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1075)]  \n  \n [!code-vb[UIATextPattern_snip#2075](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2075)]"
  syntax:
    content: public void Select ();
    parameters: []
  overload: System.Windows.Automation.Text.TextPatternRange.Select*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "文本控件不支持文本选择时发生。"
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.TextPattern
  id: TextPattern
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: TextPattern
  nameWithType: TextPatternRange.TextPattern
  fullName: System.Windows.Automation.Text.TextPatternRange.TextPattern
  type: Property
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "获取<xref href=&quot;System.Windows.Automation.TextPattern&quot;></xref>与文本范围关联。"
  remarks: ''
  example:
  - "[!code-cs[UIATextPattern_snip#1076](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1076)]  \n  \n [!code-vb[UIATextPattern_snip#2076](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2076)]"
  syntax:
    content: public System.Windows.Automation.TextPattern TextPattern { get; }
    return:
      type: System.Windows.Automation.TextPattern
      description: "文本提供程序。"
  overload: System.Windows.Automation.Text.TextPatternRange.TextPattern*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Windows.Automation.Text.TextPatternRange.AddToSelection
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: AddToSelection()
  nameWithType: TextPatternRange.AddToSelection()
  fullName: System.Windows.Automation.Text.TextPatternRange.AddToSelection()
- uid: System.Windows.Automation.Text.TextPatternRange.Clone
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Clone()
  nameWithType: TextPatternRange.Clone()
  fullName: System.Windows.Automation.Text.TextPatternRange.Clone()
- uid: System.Windows.Automation.Text.TextPatternRange
  parent: System.Windows.Automation.Text
  isExternal: false
  name: TextPatternRange
  nameWithType: TextPatternRange
  fullName: System.Windows.Automation.Text.TextPatternRange
- uid: System.Windows.Automation.Text.TextPatternRange.Compare(System.Windows.Automation.Text.TextPatternRange)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Compare(TextPatternRange)
  nameWithType: TextPatternRange.Compare(TextPatternRange)
  fullName: System.Windows.Automation.Text.TextPatternRange.Compare(TextPatternRange)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: CompareEndpoints(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  nameWithType: TextPatternRange.CompareEndpoints(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  fullName: System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.Automation.Text.TextPatternRangeEndpoint
  parent: System.Windows.Automation.Text
  isExternal: false
  name: TextPatternRangeEndpoint
  nameWithType: TextPatternRangeEndpoint
  fullName: System.Windows.Automation.Text.TextPatternRangeEndpoint
- uid: System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: ExpandToEnclosingUnit(TextUnit)
  nameWithType: TextPatternRange.ExpandToEnclosingUnit(TextUnit)
  fullName: System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(TextUnit)
- uid: System.Windows.Automation.Text.TextUnit
  parent: System.Windows.Automation.Text
  isExternal: false
  name: TextUnit
  nameWithType: TextUnit
  fullName: System.Windows.Automation.Text.TextUnit
- uid: System.Windows.Automation.Text.TextPatternRange.FindAttribute(System.Windows.Automation.AutomationTextAttribute,System.Object,System.Boolean)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: FindAttribute(AutomationTextAttribute,Object,Boolean)
  nameWithType: TextPatternRange.FindAttribute(AutomationTextAttribute,Object,Boolean)
  fullName: System.Windows.Automation.Text.TextPatternRange.FindAttribute(AutomationTextAttribute,Object,Boolean)
- uid: System.Windows.Automation.AutomationTextAttribute
  parent: System.Windows.Automation
  isExternal: false
  name: AutomationTextAttribute
  nameWithType: AutomationTextAttribute
  fullName: System.Windows.Automation.AutomationTextAttribute
- uid: System.Windows.Automation.Text.TextPatternRange.FindText(System.String,System.Boolean,System.Boolean)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: FindText(String,Boolean,Boolean)
  nameWithType: TextPatternRange.FindText(String,Boolean,Boolean)
  fullName: System.Windows.Automation.Text.TextPatternRange.FindText(String,Boolean,Boolean)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(System.Windows.Automation.AutomationTextAttribute)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetAttributeValue(AutomationTextAttribute)
  nameWithType: TextPatternRange.GetAttributeValue(AutomationTextAttribute)
  fullName: System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(AutomationTextAttribute)
- uid: System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetBoundingRectangles()
  nameWithType: TextPatternRange.GetBoundingRectangles()
  fullName: System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles()
- uid: System.Windows.Rect[]
  parent: System.Windows
  isExternal: false
  name: Rect
  nameWithType: Rect
  fullName: System.Windows.Rect[]
  spec.csharp:
  - uid: System.Windows.Rect
    name: Rect
    nameWithType: Rect
    fullName: Rect[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Windows.Automation.Text.TextPatternRange.GetChildren
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetChildren()
  nameWithType: TextPatternRange.GetChildren()
  fullName: System.Windows.Automation.Text.TextPatternRange.GetChildren()
- uid: System.Windows.Automation.AutomationElement[]
  parent: System.Windows.Automation
  isExternal: false
  name: AutomationElement
  nameWithType: AutomationElement
  fullName: System.Windows.Automation.AutomationElement[]
  spec.csharp:
  - uid: System.Windows.Automation.AutomationElement
    name: AutomationElement
    nameWithType: AutomationElement
    fullName: AutomationElement[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetEnclosingElement()
  nameWithType: TextPatternRange.GetEnclosingElement()
  fullName: System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement()
- uid: System.Windows.Automation.AutomationElement
  parent: System.Windows.Automation
  isExternal: false
  name: AutomationElement
  nameWithType: AutomationElement
  fullName: System.Windows.Automation.AutomationElement
- uid: System.Windows.Automation.Text.TextPatternRange.GetText(System.Int32)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetText(Int32)
  nameWithType: TextPatternRange.GetText(Int32)
  fullName: System.Windows.Automation.Text.TextPatternRange.GetText(Int32)
- uid: System.Windows.Automation.Text.TextPatternRange.Move(System.Windows.Automation.Text.TextUnit,System.Int32)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Move(TextUnit,Int32)
  nameWithType: TextPatternRange.Move(TextUnit,Int32)
  fullName: System.Windows.Automation.Text.TextPatternRange.Move(TextUnit,Int32)
- uid: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: MoveEndpointByRange(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  nameWithType: TextPatternRange.MoveEndpointByRange(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  fullName: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
- uid: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: MoveEndpointByUnit(TextPatternRangeEndpoint,TextUnit,Int32)
  nameWithType: TextPatternRange.MoveEndpointByUnit(TextPatternRangeEndpoint,TextUnit,Int32)
  fullName: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(TextPatternRangeEndpoint,TextUnit,Int32)
- uid: System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: RemoveFromSelection()
  nameWithType: TextPatternRange.RemoveFromSelection()
  fullName: System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection()
- uid: System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(System.Boolean)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: ScrollIntoView(Boolean)
  nameWithType: TextPatternRange.ScrollIntoView(Boolean)
  fullName: System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(Boolean)
- uid: System.Windows.Automation.Text.TextPatternRange.Select
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Select()
  nameWithType: TextPatternRange.Select()
  fullName: System.Windows.Automation.Text.TextPatternRange.Select()
- uid: System.Windows.Automation.Text.TextPatternRange.TextPattern
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: TextPattern
  nameWithType: TextPatternRange.TextPattern
  fullName: System.Windows.Automation.Text.TextPatternRange.TextPattern
- uid: System.Windows.Automation.TextPattern
  parent: System.Windows.Automation
  isExternal: false
  name: TextPattern
  nameWithType: TextPattern
  fullName: System.Windows.Automation.TextPattern
- uid: System.Windows.Automation.Text.TextPatternRange.AddToSelection*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: AddToSelection
  nameWithType: TextPatternRange.AddToSelection
- uid: System.Windows.Automation.Text.TextPatternRange.Clone*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Clone
  nameWithType: TextPatternRange.Clone
- uid: System.Windows.Automation.Text.TextPatternRange.Compare*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Compare
  nameWithType: TextPatternRange.Compare
- uid: System.Windows.Automation.Text.TextPatternRange.CompareEndpoints*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: CompareEndpoints
  nameWithType: TextPatternRange.CompareEndpoints
- uid: System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: ExpandToEnclosingUnit
  nameWithType: TextPatternRange.ExpandToEnclosingUnit
- uid: System.Windows.Automation.Text.TextPatternRange.FindAttribute*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: FindAttribute
  nameWithType: TextPatternRange.FindAttribute
- uid: System.Windows.Automation.Text.TextPatternRange.FindText*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: FindText
  nameWithType: TextPatternRange.FindText
- uid: System.Windows.Automation.Text.TextPatternRange.GetAttributeValue*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetAttributeValue
  nameWithType: TextPatternRange.GetAttributeValue
- uid: System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetBoundingRectangles
  nameWithType: TextPatternRange.GetBoundingRectangles
- uid: System.Windows.Automation.Text.TextPatternRange.GetChildren*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetChildren
  nameWithType: TextPatternRange.GetChildren
- uid: System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetEnclosingElement
  nameWithType: TextPatternRange.GetEnclosingElement
- uid: System.Windows.Automation.Text.TextPatternRange.GetText*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetText
  nameWithType: TextPatternRange.GetText
- uid: System.Windows.Automation.Text.TextPatternRange.Move*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Move
  nameWithType: TextPatternRange.Move
- uid: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: MoveEndpointByRange
  nameWithType: TextPatternRange.MoveEndpointByRange
- uid: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: MoveEndpointByUnit
  nameWithType: TextPatternRange.MoveEndpointByUnit
- uid: System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: RemoveFromSelection
  nameWithType: TextPatternRange.RemoveFromSelection
- uid: System.Windows.Automation.Text.TextPatternRange.ScrollIntoView*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: ScrollIntoView
  nameWithType: TextPatternRange.ScrollIntoView
- uid: System.Windows.Automation.Text.TextPatternRange.Select*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Select
  nameWithType: TextPatternRange.Select
- uid: System.Windows.Automation.Text.TextPatternRange.TextPattern*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: TextPattern
  nameWithType: TextPatternRange.TextPattern
