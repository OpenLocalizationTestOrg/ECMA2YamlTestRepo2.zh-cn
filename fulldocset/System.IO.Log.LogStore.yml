### YamlMime:ManagedReference
items:
- uid: System.IO.Log.LogStore
  id: LogStore
  children:
  - System.IO.Log.LogStore.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)
  - System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode)
  - System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  - System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  - System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)
  - System.IO.Log.LogStore.Archivable
  - System.IO.Log.LogStore.BaseSequenceNumber
  - System.IO.Log.LogStore.CreateLogArchiveSnapshot
  - System.IO.Log.LogStore.CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)
  - System.IO.Log.LogStore.Delete(System.String)
  - System.IO.Log.LogStore.Dispose
  - System.IO.Log.LogStore.Extents
  - System.IO.Log.LogStore.FreeBytes
  - System.IO.Log.LogStore.Handle
  - System.IO.Log.LogStore.LastSequenceNumber
  - System.IO.Log.LogStore.Length
  - System.IO.Log.LogStore.Policy
  - System.IO.Log.LogStore.SetArchiveTail(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogStore.StreamCount
  langs:
  - csharp
  name: LogStore
  nameWithType: LogStore
  fullName: System.IO.Log.LogStore
  type: Class
  summary: "表示日志结构化存储。"
  remarks: "<xref:System.IO.Log.LogRecordSequence>类提供记录序列接口在公用日志文件系统 (CLFS) 日志之上的实现</xref:System.IO.Log.LogRecordSequence> 它适用于 LogStore 类，该类提供用于直接操作和管理 CLFS 日志文件的接口。 日志存储区提供跨一组磁盘范围的仅追加存储。 LogStore 类表示此存储区，并提供用于添加和移除容器、 设置策略，以及创建存档的方法。 它不用于从读取和写入到存储; 提供的方法这些方法提供的<xref:System.IO.Log.LogRecordSequence>类。</xref:System.IO.Log.LogRecordSequence>       LogStore 类之间的关系和<xref:System.IO.Log.LogRecordSequence>类是类似于磁盘文件之间的关系和<xref:System.IO.FileStream>对象。</xref:System.IO.FileStream> </xref:System.IO.Log.LogRecordSequence> 磁盘文件提供实际存储，具有诸如长度和上次访问时间，同时<xref:System.IO.FileStream>对象提供对可用来读取和写入它。 该文件的视图</xref:System.IO.FileStream>的属性 同样，LogStore 类具有策略和磁盘范围集合等属性和<xref:System.IO.Log.LogRecordSequence>类提供面向记录的机制，用于读取和写入数据。</xref:System.IO.Log.LogRecordSequence>       与所表示的文件记录序列不同<xref:System.IO.Log.FileRecordSequence>类，则 LogStore 实例会将其数据存储在磁盘范围，由表示集合<xref:System.IO.Log.LogExtent>实例。</xref:System.IO.Log.LogExtent> </xref:System.IO.Log.FileRecordSequence> 给定的 LogStore 实例中的范围都具有统一的大小，并添加到和移除中范围增量的形式的 LogStore 实例空间。 若要添加和移除日志范围，使用<xref:System.IO.Log.LogExtentCollection.Add%2A>和<xref:System.IO.Log.LogExtentCollection.Remove%2A>方法<xref:System.IO.Log.LogExtentCollection>对象，可以通过返回<xref:System.IO.Log.LogStore.Extents%2A>属性。</xref:System.IO.Log.LogStore.Extents%2A> </xref:System.IO.Log.LogExtentCollection> </xref:System.IO.Log.LogExtentCollection.Remove%2A> </xref:System.IO.Log.LogExtentCollection.Add%2A>       LogStore 实例可以具有与之关联的策略。 它们都由表示<xref:System.IO.Log.LogPolicy>实例可以返回的<xref:System.IO.Log.LogStore.Policy%2A>属性。</xref:System.IO.Log.LogStore.Policy%2A> </xref:System.IO.Log.LogPolicy> 策略定义日志将尝试按照，如的范围和最小大小，说明的最大数目扩大或缩小在某些情况下的 LogStore 上的规则。 此外，您可以指定是否可以存档 LogStore 实例。 策略每个日志设置和是可变的这意味着一旦日志每个句柄已关闭，策略不再存在。"
  example:
  - "The following example shows how to archive a LogStore to an XML document.  \n  \n [!code-vb[logarchievesnapshot#0](~/add/codesnippet/visualbasic/t-system.io.log.logstore_1.vb)]\n [!code-cs[logarchievesnapshot#0](~/add/codesnippet/csharp/t-system.io.log.logstore_1.cs)]"
  syntax:
    content: 'public sealed class LogStore : IDisposable'
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.Log.LogStore.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)'
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: LogStore(SafeFileHandle)
  nameWithType: LogStore.LogStore(SafeFileHandle)
  fullName: System.IO.Log.LogStore.LogStore(SafeFileHandle)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "初始化的新实例<xref href=&quot;System.IO.Log.LogStore&quot;></xref>指定句柄类。"
  syntax:
    content: public LogStore (Microsoft.Win32.SafeHandles.SafeFileHandle handle);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "文件的日志文件句柄当前<xref href=&quot;System.IO.Log.LogStore&quot;></xref>对象所封装。"
  overload: System.IO.Log.LogStore.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>handle</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "日志句柄无法绑定到线程池。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志存储区的访问被拒绝由操作系统。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  platform:
  - net462
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode)
  id: '#ctor(System.String,System.IO.FileMode)'
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: LogStore(String,FileMode)
  nameWithType: LogStore.LogStore(String,FileMode)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "初始化的新实例<xref href=&quot;System.IO.Log.LogStore&quot;></xref>使用指定的路径和模式的类。"
  remarks: "使用此构造函数使用指定的路径和模式打开的日志存储区。 存储打开具有读/写访问权限和共享读访问权限。       `path`参数应使用以下语法︰`log:<physical log name>[::<log client name>]`其中`<physical log name>`是日志文件的有效路径和`<log client name>`是唯一的客户端标识符。 物理日志存储区或虚拟日志存储区中，但不是同时，应为日志存储区。 一旦以物理方式或几乎已创建的日志存储区，将保持这样的整个生存期。 创建物理日志存储，则通过指定仅物理日志名称。 通过指定物理日志名称和日志客户端名称创建的虚拟日志存储区。       共享同一个物理日志名称的客户端将共享相同的范围集合与策略。"
  syntax:
    content: public LogStore (string path, System.IO.FileMode mode);
    parameters:
    - id: path
      type: System.String
      description: "要打开的日志存储区的基文件相对或绝对路径。"
    - id: mode
      type: System.IO.FileMode
      description: "之一<xref href=&quot;System.IO.FileMode&quot;></xref>确定如何打开或创建存储的值。"
  overload: System.IO.Log.LogStore.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>为空字符串 (&quot;&quot;)。       -或-<code>path</code>仅包含空格。       -或-<code>path</code>包含一个或多个无效字符。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>包含无效值。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到该文件。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "打开日志存储区时发生了 I/O 错误。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志存储区的访问被拒绝由操作系统。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogStore&quot;></xref>无法使用，因为未安装所需的公用日志文件系统 (CLFS) 组件。 安装 CLFS 组件，如果它不用于平台或使用<xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>类。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  platform:
  - net462
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)'
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: LogStore(String,FileMode,FileAccess)
  nameWithType: LogStore.LogStore(String,FileMode,FileAccess)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode,FileAccess)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "初始化的新实例<xref href=&quot;System.IO.Log.LogStore&quot;></xref>与指定的路径、 模式和访问的类。"
  remarks: "使用此构造函数打开具有指定的路径、 模式和访问新的日志存储区。 共享读访问权限打开的存储。       `path`参数应使用以下语法︰`log:<physical log name>[::<log client name>]`其中`<physical log name>`是日志文件的有效路径和`<log client name>`是唯一的客户端标识符。 物理日志存储区或虚拟日志存储区中，但不是同时，应为日志存储区。 一旦以物理方式或几乎已创建的日志存储区，将保持这样的整个生存期。 创建物理日志存储，则通过指定仅物理日志名称。 通过指定物理日志名称和日志客户端名称创建的虚拟日志存储区。       共享同一个物理日志名称的客户端将共享相同的范围集合与策略。"
  syntax:
    content: public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access);
    parameters:
    - id: path
      type: System.String
      description: "要打开的日志存储区的基文件相对或绝对路径。"
    - id: mode
      type: System.IO.FileMode
      description: "之一<xref href=&quot;System.IO.FileMode&quot;></xref>确定如何打开或创建存储的值。"
    - id: access
      type: System.IO.FileAccess
      description: "之一<xref href=&quot;System.IO.FileAccess&quot;></xref>确定如何通过访问文件的值<xref href=&quot;System.IO.Log.LogStore&quot;> </xref>。"
  overload: System.IO.Log.LogStore.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>为空字符串 (&quot;&quot;)。       -或-<code>path</code>仅包含空格。       -或-<code>path</code>包含一个或多个无效字符。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>包含无效值。       -或<code>access</code>包含无效值。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到该文件。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "打开日志存储区时发生了 I/O 错误。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志存储区的访问被拒绝由操作系统。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogStore&quot;></xref>无法使用，因为未安装所需的公用日志文件系统 (CLFS) 组件。 安装 CLFS 组件，如果它不用于平台或使用<xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>类。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  platform:
  - net462
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)'
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: LogStore(String,FileMode,FileAccess,FileShare)
  nameWithType: LogStore.LogStore(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode,FileAccess,FileShare)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "初始化的新实例<xref href=&quot;System.IO.Log.LogStore&quot;></xref>类。"
  remarks: "此构造函数初始化新<xref:System.IO.Log.LogStore>它以指定的路径、 模式和访问权限打开的对象。</xref:System.IO.Log.LogStore> 共享指定的访问权限打开的存储。       `path`参数应使用以下语法︰`log:<physical log name>[::<log client name>]`其中`<physical log name>`是日志文件的有效路径和`<log client name>`是唯一的客户端标识符。 物理日志存储区或虚拟日志存储区中，但不是同时，应为日志存储区。 一旦以物理方式或几乎已创建的日志存储区，将保持这样的整个生存期。 创建物理日志存储，则通过指定仅物理日志名称。 通过指定物理日志名称和日志客户端名称创建的虚拟日志存储区。       共享同一个物理日志名称的客户端将共享相同的范围集合与策略。"
  syntax:
    content: public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
    parameters:
    - id: path
      type: System.String
      description: "要打开的日志存储区的基文件相对或绝对路径。"
    - id: mode
      type: System.IO.FileMode
      description: "之一<xref href=&quot;System.IO.FileMode&quot;></xref>确定如何打开或创建存储的值。"
    - id: access
      type: System.IO.FileAccess
      description: "之一<xref href=&quot;System.IO.FileAccess&quot;></xref>确定如何通过访问文件的值<xref href=&quot;System.IO.Log.LogStore&quot;> </xref>。"
    - id: share
      type: System.IO.FileShare
      description: "之一<xref href=&quot;System.IO.FileShare&quot;></xref>确定将如何在进程之间共享的日志存储区的值。"
  overload: System.IO.Log.LogStore.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>为空字符串 (&quot;&quot;)。       -或-<code>path</code>仅包含空格。       -或-<code>path</code>包含一个或多个无效字符。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>包含无效值。       -或<code>access</code>包含无效值。       -或-<code>share</code>包含无效值。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到该文件。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "打开日志存储区时发生了 I/O 错误。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志存储区的访问被拒绝由操作系统。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogStore&quot;></xref>无法使用，因为未安装所需的公用日志文件系统 (CLFS) 组件。 安装 CLFS 组件，如果它不用于平台或使用<xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>类。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  platform:
  - net462
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)'
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: LogStore(String,FileMode,FileAccess,FileShare,FileSecurity)
  nameWithType: LogStore.LogStore(String,FileMode,FileAccess,FileShare,FileSecurity)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode,FileAccess,FileShare,FileSecurity)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "初始化的新实例<xref href=&quot;System.IO.Log.LogStore&quot;></xref>类。"
  remarks: "此构造函数初始化新<xref:System.IO.Log.LogStore>它以指定的路径、 模式和访问权限打开的对象。</xref:System.IO.Log.LogStore> 共享指定的访问权限打开的存储。 `path`参数应遵循以下语法︰`log:<physical log name>[::<log client name>]`其中`<physical log name>`是日志文件的有效路径和`<log client name>`是唯一的客户端标识符。 物理日志存储区或虚拟日志存储区中，但不是同时，应为日志存储区。 一旦以物理方式或几乎已创建的日志存储区，将保持这样的整个生存期。 创建物理日志存储，则通过指定仅物理日志名称。 通过指定物理日志名称和日志客户端名称创建的虚拟日志存储区。       共享同一个物理日志名称的客户端将共享相同的范围集合与策略。"
  syntax:
    content: public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: path
      type: System.String
      description: "要打开的日志存储区的基文件相对或绝对路径。"
    - id: mode
      type: System.IO.FileMode
      description: "之一<xref href=&quot;System.IO.FileMode&quot;></xref>确定如何打开或创建存储的值。"
    - id: access
      type: System.IO.FileAccess
      description: "之一<xref href=&quot;System.IO.FileAccess&quot;></xref>确定如何通过访问文件的值<xref href=&quot;System.IO.Log.LogStore&quot;> </xref>。"
    - id: share
      type: System.IO.FileShare
      description: "之一<xref href=&quot;System.IO.FileShare&quot;></xref>确定将如何在进程之间共享的日志存储区的值。"
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "之一<xref href=&quot;System.Security.AccessControl.FileSecurity&quot;></xref>值，该值指定要设置新创建的存储区中，如果必须创建存储区的安全性。"
  overload: System.IO.Log.LogStore.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "通过指定的日志存储区文件名<code> path </code>无效。       - <code> Mode </code>是<xref uid=&quot;langword_csharp_CreateNew&quot; name=&quot;CreateNew&quot; href=&quot;&quot;> </xref>，无法在没有写访问权限使用它。       - <code> Mode </code>是<xref uid=&quot;langword_csharp_OpenOrCreate&quot; name=&quot;OpenOrCreate&quot; href=&quot;&quot;> </xref>，无法在没有写访问权限使用它。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>包含无效值。       -或<code>access</code>包含无效值。       -或-<code>share</code>包含无效值。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到该文件。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "打开日志存储区时发生了 I/O 错误。       指定的文件<code> path </code>无法访问，因为它正在使用另一个进程。       -指定的文件<code> path </code>无法创建，因为该文件或目录已存在。       -或者-日志句柄无法绑定到线程池。       -或者-指定的日志文件格式或版本无效。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogStore&quot;></xref>无法使用，因为未安装所需的公用日志文件系统 (CLFS) 组件。 安装 CLFS 组件，如果它不用于平台或使用<xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>类。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列已满。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志存储区的访问被拒绝由操作系统。"
  platform:
  - net462
- uid: System.IO.Log.LogStore.Archivable
  id: Archivable
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Archivable
  nameWithType: LogStore.Archivable
  fullName: System.IO.Log.LogStore.Archivable
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "获取一个值，该值指示是否这<xref href=&quot;System.IO.Log.LogStore&quot;></xref>实例可以存档。"
  remarks: "如果<xref:System.IO.Log.LogStore>不可存档，则调用<xref:System.IO.Log.LogStore.CreateLogArchiveSnapshot%2A>和<xref:System.IO.Log.LogStore.SetArchiveTail%2A>方法都会导致<xref:System.NotSupportedException>引发。</xref:System.NotSupportedException> </xref:System.IO.Log.LogStore.SetArchiveTail%2A> </xref:System.IO.Log.LogStore.CreateLogArchiveSnapshot%2A> </xref:System.IO.Log.LogStore>"
  syntax:
    content: public bool Archivable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果此<xref href=&quot;System.IO.Log.LogStore&quot;></xref>实例可以存档; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.Log.LogStore.Archivable*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "在序列已释放的之后，已访问属性。"
  platform:
  - net462
- uid: System.IO.Log.LogStore.BaseSequenceNumber
  id: BaseSequenceNumber
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: BaseSequenceNumber
  nameWithType: LogStore.BaseSequenceNumber
  fullName: System.IO.Log.LogStore.BaseSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "获取有效记录对应的最低序列号，在此<xref href=&quot;System.IO.Log.LogStore&quot;></xref>实例。"
  remarks: "有效序列号是大于或等于 BaseSequenceNumber，并且小于<xref:System.IO.Log.LogStore.LastSequenceNumber%2A>.</xref:System.IO.Log.LogStore.LastSequenceNumber%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "在此有效记录对应的最低序列号<xref href=&quot;System.IO.Log.LogStore&quot;></xref>实例。"
  overload: System.IO.Log.LogStore.BaseSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "在序列已释放的之后，已访问属性。"
  platform:
  - net462
- uid: System.IO.Log.LogStore.CreateLogArchiveSnapshot
  id: CreateLogArchiveSnapshot
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: CreateLogArchiveSnapshot()
  nameWithType: LogStore.CreateLogArchiveSnapshot()
  fullName: System.IO.Log.LogStore.CreateLogArchiveSnapshot()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "采用以制作备份的日志存储区状态的快照。"
  remarks: ''
  example:
  - "The following example shows how to archive a <xref:System.IO.Log.LogStore> to an XML document.  \n  \n [!code-vb[logarchievesnapshot#0](~/add/codesnippet/visualbasic/m-system.io.log.logstore_1_1.vb)]\n [!code-cs[logarchievesnapshot#0](~/add/codesnippet/csharp/m-system.io.log.logstore_1_1.cs)]"
  syntax:
    content: public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot ();
    parameters: []
    return:
      type: System.IO.Log.LogArchiveSnapshot
      description: "A <xref href=&quot;System.IO.Log.LogArchiveSnapshot&quot;> </xref>包含制作存档所需状态的对象。"
  overload: System.IO.Log.LogStore.CreateLogArchiveSnapshot*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "日志存储区不可存档。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "创建存档快照时发生 I/O 错误。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "参数不是有效的。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "已执行了无效的操作。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列已满。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志存储区的访问被拒绝由操作系统。"
  platform:
  - net462
- uid: System.IO.Log.LogStore.CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)
  id: CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: CreateLogArchiveSnapshot(SequenceNumber,SequenceNumber)
  nameWithType: LogStore.CreateLogArchiveSnapshot(SequenceNumber,SequenceNumber)
  fullName: System.IO.Log.LogStore.CreateLogArchiveSnapshot(SequenceNumber,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "采用以制作备份指定的序列号之间的日志存储区状态的快照。"
  remarks: "从此方法返回的存档快照包含来自基序列号或存档序列号的信息，无论是更低时，到最后一个序列号。 不包含有关最后一个序列号，这意味着，存档仅包含截至但不是包括最后一条记录。 此外，使用此方法时，起始 SequenceNumber 必须等于 BaseSequenceNumber，以便保持一致的存档。"
  syntax:
    content: public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot (System.IO.Log.SequenceNumber first, System.IO.Log.SequenceNumber last);
    parameters:
    - id: first
      type: System.IO.Log.SequenceNumber
      description: "起始范围中要存档序列号。"
    - id: last
      type: System.IO.Log.SequenceNumber
      description: "结束范围中要存档序列号。"
    return:
      type: System.IO.Log.LogArchiveSnapshot
      description: "A <xref href=&quot;System.IO.Log.LogArchiveSnapshot&quot;> </xref>包含制作存档所需状态的对象。"
  overload: System.IO.Log.LogStore.CreateLogArchiveSnapshot*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>first</code>或<code>last</code>不在此序列的基和最后一个序列号之间。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>first</code>大于<code>last</code>。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "已执行了无效的操作。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "创建存档快照时发生 I/O 错误。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "日志存储区不可存档。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列已满。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志存储区的访问被拒绝由操作系统。"
  platform:
  - net462
- uid: System.IO.Log.LogStore.Delete(System.String)
  id: Delete(System.String)
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Delete(String)
  nameWithType: LogStore.Delete(String)
  fullName: System.IO.Log.LogStore.Delete(String)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "移除日志存储区。"
  syntax:
    content: public static void Delete (string path);
    parameters:
    - id: path
      type: System.String
      description: "要删除的日志存储区的基文件相对或绝对路径。"
  overload: System.IO.Log.LogStore.Delete*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>为空字符串 (&quot;&quot;)。       -或-<code>path</code>仅包含空格。       -或-<code>path</code>包含一个或多个无效字符。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到该文件。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "打开日志存储区时发生了 I/O 错误。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志存储区的访问被拒绝由操作系统。"
  platform:
  - net462
- uid: System.IO.Log.LogStore.Dispose
  id: Dispose
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Dispose()
  nameWithType: LogStore.Dispose()
  fullName: System.IO.Log.LogStore.Dispose()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "释放使用的所有资源<xref href=&quot;System.IO.Log.LogStore&quot;> </xref>。"
  remarks: "使用<xref:System.IO.Log.LogStore>.</xref:System.IO.Log.LogStore>完后，调用 Dispose Dispose 方法离开<xref:System.IO.Log.LogStore>中不可用状态。</xref:System.IO.Log.LogStore> 调用 Dispose 后，必须释放对所有引用<xref:System.IO.Log.LogStore>以便垃圾回收器才能回收的内存，<xref:System.IO.Log.LogStore>占用。</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogStore>      1> [!NOTE]&1;> 始终调用释放在发布到<xref:System.IO.Log.LogStore>。</xref:System.IO.Log.LogStore>最后一个引用之前 否则，它所使用的资源之前，不会释放垃圾回收器调用<xref:System.IO.Log.LogStore>对象的`Finalize`方法。</xref:System.IO.Log.LogStore>"
  syntax:
    content: public void Dispose ();
    parameters: []
  overload: System.IO.Log.LogStore.Dispose*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.LogStore.Extents
  id: Extents
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Extents
  nameWithType: LogStore.Extents
  fullName: System.IO.Log.LogStore.Extents
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "获取包含此日志存储区的数据的日志范围的集合。"
  remarks: "A<xref:System.IO.Log.LogStore>实例将其数据存储在磁盘范围，由表示集合<xref:System.IO.Log.LogExtent>实例。</xref:System.IO.Log.LogExtent> </xref:System.IO.Log.LogStore> 中的范围给定<xref:System.IO.Log.LogStore>实例都具有统一的大小，并添加到和移除空间<xref:System.IO.Log.LogStore>范围增量的形式中的实例。</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogStore> 若要添加和移除日志范围，使用<xref:System.IO.Log.LogExtentCollection.Add%2A>和<xref:System.IO.Log.LogExtentCollection.Remove%2A>方法<xref:System.IO.Log.LogExtentCollection>对象，此属性返回。</xref:System.IO.Log.LogExtentCollection> </xref:System.IO.Log.LogExtentCollection.Remove%2A> </xref:System.IO.Log.LogExtentCollection.Add%2A>"
  syntax:
    content: public System.IO.Log.LogExtentCollection Extents { get; }
    return:
      type: System.IO.Log.LogExtentCollection
      description: "A <xref href=&quot;System.IO.Log.LogExtentCollection&quot;> </xref>包含封装此日志存储区的数据的日志范围集合的实例。"
  overload: System.IO.Log.LogStore.Extents*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogStore.FreeBytes
  id: FreeBytes
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: FreeBytes
  nameWithType: LogStore.FreeBytes
  fullName: System.IO.Log.LogStore.FreeBytes
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "获取日志存储区中可用的字节数。"
  syntax:
    content: public long FreeBytes { get; }
    return:
      type: System.Int64
      description: "日志存储区中可用的字节数。"
  overload: System.IO.Log.LogStore.FreeBytes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "在序列已释放的之后，已访问属性。"
  platform:
  - net462
- uid: System.IO.Log.LogStore.Handle
  id: Handle
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Handle
  nameWithType: LogStore.Handle
  fullName: System.IO.Log.LogStore.Handle
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "获取操作系统文件句柄的日志文件的当前<xref href=&quot;System.IO.Log.LogStore&quot;></xref>实例封装。"
  syntax:
    content: public Microsoft.Win32.SafeHandles.SafeFileHandle Handle { get; }
    return:
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "日志的操作系统文件句柄文件当前<xref href=&quot;System.IO.Log.LogStore&quot;></xref>实例封装。"
  overload: System.IO.Log.LogStore.Handle*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogStore.LastSequenceNumber
  id: LastSequenceNumber
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: LastSequenceNumber
  nameWithType: LogStore.LastSequenceNumber
  fullName: System.IO.Log.LogStore.LastSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写，获取要追加到日志存储区的下一个记录的序列号。"
  remarks: "有效序列号是大于或等于<xref:System.IO.Log.LogStore.BaseSequenceNumber%2A>，并且小于 LastSequenceNumber。</xref:System.IO.Log.LogStore.BaseSequenceNumber%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber LastSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "要追加到日志存储区的下一个记录序列号。"
  overload: System.IO.Log.LogStore.LastSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "在序列已释放的之后，已访问属性。"
  platform:
  - net462
- uid: System.IO.Log.LogStore.Length
  id: Length
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Length
  nameWithType: LogStore.Length
  fullName: System.IO.Log.LogStore.Length
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "获取日志存储区，以字节为单位的大小。"
  remarks: "日志存储区的大小是日志范围的大小的总和。"
  syntax:
    content: public long Length { get; }
    return:
      type: System.Int64
      description: "日志存储区，以字节为单位的大小。"
  overload: System.IO.Log.LogStore.Length*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "在序列已释放的之后，已访问属性。"
  platform:
  - net462
- uid: System.IO.Log.LogStore.Policy
  id: Policy
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Policy
  nameWithType: LogStore.Policy
  fullName: System.IO.Log.LogStore.Policy
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "获取与此日志存储区关联的策略。"
  remarks: "你可以使用<xref:System.IO.Log.LogPolicy>实例检查和操作日志策略此属性返回与此<xref:System.IO.Log.LogStore>。</xref:System.IO.Log.LogStore>关联</xref:System.IO.Log.LogPolicy>"
  syntax:
    content: public System.IO.Log.LogPolicy Policy { get; }
    return:
      type: System.IO.Log.LogPolicy
      description: "A <xref href=&quot;System.IO.Log.LogPolicy&quot;> </xref>实例，它表示与此日志存储区关联的策略。"
  overload: System.IO.Log.LogStore.Policy*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogStore.SetArchiveTail(System.IO.Log.SequenceNumber)
  id: SetArchiveTail(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: SetArchiveTail(SequenceNumber)
  nameWithType: LogStore.SetArchiveTail(SequenceNumber)
  fullName: System.IO.Log.LogStore.SetArchiveTail(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "设置存档尾数据的序列号。"
  remarks: "较小的基序列号和存档尾数据确定日志尾部。"
  example:
  - "The following example shows how to archive a <xref:System.IO.Log.LogStore> to an XML document.  \n  \n [!code-vb[logarchievesnapshot#0](~/add/codesnippet/visualbasic/m-system.io.log.logstore_0_1.vb)]\n [!code-cs[logarchievesnapshot#0](~/add/codesnippet/csharp/m-system.io.log.logstore_0_1.cs)]"
  syntax:
    content: public void SetArchiveTail (System.IO.Log.SequenceNumber archiveTail);
    parameters:
    - id: archiveTail
      type: System.IO.Log.SequenceNumber
      description: "存档尾数据序列号。"
  overload: System.IO.Log.LogStore.SetArchiveTail*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>archiveTail</code>不是此序列的基和最后一个序列号号之间。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>archiveTail</code>不适合此序列。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "已执行了无效的操作。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "创建存档快照时发生 I/O 错误。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "日志存储区不可存档。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存来继续执行程序。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定的日志存储区的访问被拒绝由操作系统。"
  platform:
  - net462
- uid: System.IO.Log.LogStore.StreamCount
  id: StreamCount
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: StreamCount
  nameWithType: LogStore.StreamCount
  fullName: System.IO.Log.LogStore.StreamCount
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "获取此日志存储区中日志流的数量。"
  syntax:
    content: public int StreamCount { get; }
    return:
      type: System.Int32
      description: "此日志存储区中日志流的数量。"
  overload: System.IO.Log.LogStore.StreamCount*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.IO.Log.SequenceFullException
  parent: System.IO.Log
  isExternal: false
  name: SequenceFullException
  nameWithType: SequenceFullException
  fullName: System.IO.Log.SequenceFullException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.IO.Log.LogStore.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LogStore(SafeFileHandle)
  nameWithType: LogStore.LogStore(SafeFileHandle)
  fullName: System.IO.Log.LogStore.LogStore(SafeFileHandle)
- uid: Microsoft.Win32.SafeHandles.SafeFileHandle
  parent: Microsoft.Win32.SafeHandles
  isExternal: false
  name: SafeFileHandle
  nameWithType: SafeFileHandle
  fullName: Microsoft.Win32.SafeHandles.SafeFileHandle
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LogStore(String,FileMode)
  nameWithType: LogStore.LogStore(String,FileMode)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.FileMode
  parent: System.IO
  isExternal: false
  name: FileMode
  nameWithType: FileMode
  fullName: System.IO.FileMode
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LogStore(String,FileMode,FileAccess)
  nameWithType: LogStore.LogStore(String,FileMode,FileAccess)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LogStore(String,FileMode,FileAccess,FileShare)
  nameWithType: LogStore.LogStore(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode,FileAccess,FileShare)
- uid: System.IO.FileShare
  parent: System.IO
  isExternal: false
  name: FileShare
  nameWithType: FileShare
  fullName: System.IO.FileShare
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LogStore(String,FileMode,FileAccess,FileShare,FileSecurity)
  nameWithType: LogStore.LogStore(String,FileMode,FileAccess,FileShare,FileSecurity)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode,FileAccess,FileShare,FileSecurity)
- uid: System.Security.AccessControl.FileSecurity
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSecurity
  nameWithType: FileSecurity
  fullName: System.Security.AccessControl.FileSecurity
- uid: System.IO.Log.LogStore.Archivable
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Archivable
  nameWithType: LogStore.Archivable
  fullName: System.IO.Log.LogStore.Archivable
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.Log.LogStore.BaseSequenceNumber
  parent: System.IO.Log.LogStore
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: LogStore.BaseSequenceNumber
  fullName: System.IO.Log.LogStore.BaseSequenceNumber
- uid: System.IO.Log.SequenceNumber
  parent: System.IO.Log
  isExternal: false
  name: SequenceNumber
  nameWithType: SequenceNumber
  fullName: System.IO.Log.SequenceNumber
- uid: System.IO.Log.LogStore.CreateLogArchiveSnapshot
  parent: System.IO.Log.LogStore
  isExternal: false
  name: CreateLogArchiveSnapshot()
  nameWithType: LogStore.CreateLogArchiveSnapshot()
  fullName: System.IO.Log.LogStore.CreateLogArchiveSnapshot()
- uid: System.IO.Log.LogArchiveSnapshot
  parent: System.IO.Log
  isExternal: false
  name: LogArchiveSnapshot
  nameWithType: LogArchiveSnapshot
  fullName: System.IO.Log.LogArchiveSnapshot
- uid: System.IO.Log.LogStore.CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: CreateLogArchiveSnapshot(SequenceNumber,SequenceNumber)
  nameWithType: LogStore.CreateLogArchiveSnapshot(SequenceNumber,SequenceNumber)
  fullName: System.IO.Log.LogStore.CreateLogArchiveSnapshot(SequenceNumber,SequenceNumber)
- uid: System.IO.Log.LogStore.Delete(System.String)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Delete(String)
  nameWithType: LogStore.Delete(String)
  fullName: System.IO.Log.LogStore.Delete(String)
- uid: System.IO.Log.LogStore.Dispose
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Dispose()
  nameWithType: LogStore.Dispose()
  fullName: System.IO.Log.LogStore.Dispose()
- uid: System.IO.Log.LogStore.Extents
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Extents
  nameWithType: LogStore.Extents
  fullName: System.IO.Log.LogStore.Extents
- uid: System.IO.Log.LogExtentCollection
  parent: System.IO.Log
  isExternal: false
  name: LogExtentCollection
  nameWithType: LogExtentCollection
  fullName: System.IO.Log.LogExtentCollection
- uid: System.IO.Log.LogStore.FreeBytes
  parent: System.IO.Log.LogStore
  isExternal: false
  name: FreeBytes
  nameWithType: LogStore.FreeBytes
  fullName: System.IO.Log.LogStore.FreeBytes
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.Log.LogStore.Handle
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Handle
  nameWithType: LogStore.Handle
  fullName: System.IO.Log.LogStore.Handle
- uid: System.IO.Log.LogStore.LastSequenceNumber
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LastSequenceNumber
  nameWithType: LogStore.LastSequenceNumber
  fullName: System.IO.Log.LogStore.LastSequenceNumber
- uid: System.IO.Log.LogStore.Length
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Length
  nameWithType: LogStore.Length
  fullName: System.IO.Log.LogStore.Length
- uid: System.IO.Log.LogStore.Policy
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Policy
  nameWithType: LogStore.Policy
  fullName: System.IO.Log.LogStore.Policy
- uid: System.IO.Log.LogPolicy
  parent: System.IO.Log
  isExternal: false
  name: LogPolicy
  nameWithType: LogPolicy
  fullName: System.IO.Log.LogPolicy
- uid: System.IO.Log.LogStore.SetArchiveTail(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: SetArchiveTail(SequenceNumber)
  nameWithType: LogStore.SetArchiveTail(SequenceNumber)
  fullName: System.IO.Log.LogStore.SetArchiveTail(SequenceNumber)
- uid: System.IO.Log.LogStore.StreamCount
  parent: System.IO.Log.LogStore
  isExternal: false
  name: StreamCount
  nameWithType: LogStore.StreamCount
  fullName: System.IO.Log.LogStore.StreamCount
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.Log.LogStore.#ctor*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LogStore
  nameWithType: LogStore.LogStore
- uid: System.IO.Log.LogStore.Archivable*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Archivable
  nameWithType: LogStore.Archivable
- uid: System.IO.Log.LogStore.BaseSequenceNumber*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: LogStore.BaseSequenceNumber
- uid: System.IO.Log.LogStore.CreateLogArchiveSnapshot*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: CreateLogArchiveSnapshot
  nameWithType: LogStore.CreateLogArchiveSnapshot
- uid: System.IO.Log.LogStore.Delete*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Delete
  nameWithType: LogStore.Delete
- uid: System.IO.Log.LogStore.Dispose*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Dispose
  nameWithType: LogStore.Dispose
- uid: System.IO.Log.LogStore.Extents*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Extents
  nameWithType: LogStore.Extents
- uid: System.IO.Log.LogStore.FreeBytes*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: FreeBytes
  nameWithType: LogStore.FreeBytes
- uid: System.IO.Log.LogStore.Handle*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Handle
  nameWithType: LogStore.Handle
- uid: System.IO.Log.LogStore.LastSequenceNumber*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LastSequenceNumber
  nameWithType: LogStore.LastSequenceNumber
- uid: System.IO.Log.LogStore.Length*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Length
  nameWithType: LogStore.Length
- uid: System.IO.Log.LogStore.Policy*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Policy
  nameWithType: LogStore.Policy
- uid: System.IO.Log.LogStore.SetArchiveTail*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: SetArchiveTail
  nameWithType: LogStore.SetArchiveTail
- uid: System.IO.Log.LogStore.StreamCount*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: StreamCount
  nameWithType: LogStore.StreamCount
