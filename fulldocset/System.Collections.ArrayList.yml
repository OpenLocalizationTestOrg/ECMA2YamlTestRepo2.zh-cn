### YamlMime:ManagedReference
items:
- uid: System.Collections.ArrayList
  id: ArrayList
  children:
  - System.Collections.ArrayList.#ctor
  - System.Collections.ArrayList.#ctor(System.Collections.ICollection)
  - System.Collections.ArrayList.#ctor(System.Int32)
  - System.Collections.ArrayList.Adapter(System.Collections.IList)
  - System.Collections.ArrayList.Add(System.Object)
  - System.Collections.ArrayList.AddRange(System.Collections.ICollection)
  - System.Collections.ArrayList.BinarySearch(System.Object)
  - System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)
  - System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)
  - System.Collections.ArrayList.Capacity
  - System.Collections.ArrayList.Clear
  - System.Collections.ArrayList.Clone
  - System.Collections.ArrayList.Contains(System.Object)
  - System.Collections.ArrayList.CopyTo(System.Array)
  - System.Collections.ArrayList.CopyTo(System.Array,System.Int32)
  - System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)
  - System.Collections.ArrayList.Count
  - System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)
  - System.Collections.ArrayList.FixedSize(System.Collections.IList)
  - System.Collections.ArrayList.GetEnumerator
  - System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)
  - System.Collections.ArrayList.GetRange(System.Int32,System.Int32)
  - System.Collections.ArrayList.IndexOf(System.Object)
  - System.Collections.ArrayList.IndexOf(System.Object,System.Int32)
  - System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)
  - System.Collections.ArrayList.Insert(System.Int32,System.Object)
  - System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)
  - System.Collections.ArrayList.IsFixedSize
  - System.Collections.ArrayList.IsReadOnly
  - System.Collections.ArrayList.IsSynchronized
  - System.Collections.ArrayList.Item(System.Int32)
  - System.Collections.ArrayList.LastIndexOf(System.Object)
  - System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)
  - System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)
  - System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)
  - System.Collections.ArrayList.ReadOnly(System.Collections.IList)
  - System.Collections.ArrayList.Remove(System.Object)
  - System.Collections.ArrayList.RemoveAt(System.Int32)
  - System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)
  - System.Collections.ArrayList.Repeat(System.Object,System.Int32)
  - System.Collections.ArrayList.Reverse
  - System.Collections.ArrayList.Reverse(System.Int32,System.Int32)
  - System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)
  - System.Collections.ArrayList.Sort
  - System.Collections.ArrayList.Sort(System.Collections.IComparer)
  - System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)
  - System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)
  - System.Collections.ArrayList.Synchronized(System.Collections.IList)
  - System.Collections.ArrayList.SyncRoot
  - System.Collections.ArrayList.ToArray
  - System.Collections.ArrayList.ToArray(System.Type)
  - System.Collections.ArrayList.TrimToSize
  langs:
  - csharp
  name: ArrayList
  nameWithType: ArrayList
  fullName: System.Collections.ArrayList
  type: Class
  summary: "实现<xref:System.Collections.IList>接口使用动态增加其大小的数组所需的方式。</xref:System.Collections.IList>       若要浏览此类型的.NET Framework 源代码，请参阅[引用源](http://referencesource.microsoft.com/#mscorlib/system/collections/arraylist.cs#3e3f6715773d6643)。"
  remarks: "> [!NOTE]1> 要查看此类型的.NET Framework 源代码，请参阅[引用源](http://referencesource.microsoft.com/#mscorlib/system/collections/arraylist.cs#3e3f6715773d6643)。 你可以浏览源代码联机，请下载离线查看的引用并在调试; 过程中逐步执行源 （包括修补程序和更新）请参阅[说明](http://referencesource.microsoft.com/)。       ArrayList 类旨在保存异类对象的集合。 但是，它不始终提供最佳性能。 相反，我们建议采用以下做法:-对于一组不同的对象，使用`List<Object>`（在 C# 中) 或`List(Of Object)`（在 Visual Basic 中) 中，键入。      -对于同类对象的集合，使用<xref:System.Collections.Generic.List%601>类。</xref:System.Collections.Generic.List%601>       请参阅中的&quot;性能注意事项&quot;部分<xref:System.Collections.Generic.List%601>这些类的相对性能的讨论的参考主题。</xref:System.Collections.Generic.List%601>       ArrayList 不是一定进行排序。  您必须通过调用理 ArrayList 其<xref:System.Collections.ArrayList.Sort%2A>在执行操作之前的方法 (如<xref:System.Collections.ArrayList.BinarySearch%2A>) 需要阵列列表以进行排序。</xref:System.Collections.ArrayList.BinarySearch%2A> </xref:System.Collections.ArrayList.Sort%2A> 若要维护添加新元素时会自动进行排序的集合，你可以使用<xref:System.Collections.Generic.SortedSet%601>类。</xref:System.Collections.Generic.SortedSet%601>       ArrayList 容量是 ArrayList 可以容纳的元素数目。 向数组添加元素时，自动增加容量通过重新分配所需的方式。 可以通过调用减少容量<xref:System.Collections.ArrayList.TrimToSize%2A>或通过设置<xref:System.Collections.ArrayList.Capacity%2A>属性显式。</xref:System.Collections.ArrayList.Capacity%2A> </xref:System.Collections.ArrayList.TrimToSize%2A>       对于非常大的 ArrayList 对象，你可以通过设置增加到 20 亿元素在 64 位系统上的最大容量`enabled`到的配置元素的属性`true`在运行时环境中。       可以使用整数索引访问此集合中的元素。  在此集合中的索引是从零开始。       ArrayList 集合接受`null`作为有效的值。 它还允许重名的元素。       不支持多维数组用作 ArrayList 集合中的元素。"
  example:
  - "The following code example shows how to create and initialize an ArrayList and how to display its values.  \n  \n [!code-cpp[Classic ArrayList Example#1](~/add/codesnippet/cpp/t-system.collections.arr_1.cpp)]\n [!code-cs[Classic ArrayList Example#1](~/add/codesnippet/csharp/t-system.collections.arr_1.cs)]\n [!code-vb[Classic ArrayList Example#1](~/add/codesnippet/visualbasic/t-system.collections.arr_1.vb)]"
  syntax:
    content: >-
      [System.Diagnostics.DebuggerDisplay("Count = {Count}")]

      [System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.ArrayList/ArrayListDebugView))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public class ArrayList : ICloneable, System.Collections.IList
  inheritance:
  - System.Object
  implements:
  - System.Collections.IList
  - System.ICloneable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Collections.ArrayList.#ctor
  id: '#ctor'
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: ArrayList()
  nameWithType: ArrayList.ArrayList()
  fullName: System.Collections.ArrayList.ArrayList()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化的新实例<xref href=&quot;System.Collections.ArrayList&quot;></xref>为空并且具有默认初始容量的类。"
  remarks: "容量<xref:System.Collections.ArrayList>是元素的数目，<xref:System.Collections.ArrayList>可以容纳。</xref:System.Collections.ArrayList> </xref:System.Collections.ArrayList> 如元素添加到<xref:System.Collections.ArrayList>，自动增加容量通过重新分配在内部数组所需的方式。</xref:System.Collections.ArrayList>       如果可以估计集合的大小，指定的初始容量，则无需执行大量的大小将元素添加到<xref:System.Collections.ArrayList>。</xref:System.Collections.ArrayList>时调整操作       此构造函数是 o （1） 操作。"
  syntax:
    content: public ArrayList ();
    parameters: []
  overload: System.Collections.ArrayList.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.ArrayList.#ctor(System.Collections.ICollection)
  id: '#ctor(System.Collections.ICollection)'
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: ArrayList(ICollection)
  nameWithType: ArrayList.ArrayList(ICollection)
  fullName: System.Collections.ArrayList.ArrayList(ICollection)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化的新实例<xref href=&quot;System.Collections.ArrayList&quot;></xref>类，其中包含从指定集合中复制的元素，并具有相同的初始容量与复制的元素数。"
  remarks: "容量<xref:System.Collections.ArrayList>是元素的数目，<xref:System.Collections.ArrayList>可以容纳。</xref:System.Collections.ArrayList> </xref:System.Collections.ArrayList> 如元素添加到<xref:System.Collections.ArrayList>，自动增加容量通过重新分配在内部数组所需的方式。</xref:System.Collections.ArrayList>       如果可以估计集合的大小，指定的初始容量，则无需执行大量的大小将元素添加到<xref:System.Collections.ArrayList>。</xref:System.Collections.ArrayList>时调整操作       将元素复制到<xref:System.Collections.ArrayList>它们由<xref:System.Collections.IEnumerator>的<xref:System.Collections.ICollection>。</xref:System.Collections.ICollection></xref:System.Collections.IEnumerator>读取的相同顺序</xref:System.Collections.ArrayList>       此构造函数是 O (`n`) 操作，其中`n`是中的元素数`c`。"
  syntax:
    content: public ArrayList (System.Collections.ICollection c);
    parameters:
    - id: c
      type: System.Collections.ICollection
      description: "<xref:System.Collections.ICollection>其元素被复制到新列表。</xref:System.Collections.ICollection>"
  overload: System.Collections.ArrayList.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>c</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.ArrayList.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: ArrayList(Int32)
  nameWithType: ArrayList.ArrayList(Int32)
  fullName: System.Collections.ArrayList.ArrayList(Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化的新实例<xref href=&quot;System.Collections.ArrayList&quot;></xref>为空并且具有指定的初始容量的类。"
  remarks: "容量<xref:System.Collections.ArrayList>是元素的数目，<xref:System.Collections.ArrayList>可以容纳。</xref:System.Collections.ArrayList> </xref:System.Collections.ArrayList> 如元素添加到<xref:System.Collections.ArrayList>，自动增加容量通过重新分配在内部数组所需的方式。</xref:System.Collections.ArrayList>       如果可以估计集合的大小，指定的初始容量，则无需执行大量的大小将元素添加到<xref:System.Collections.ArrayList>。</xref:System.Collections.ArrayList>时调整操作       此构造函数是 O (`n`) 操作，其中`n`是`capacity`。"
  syntax:
    content: public ArrayList (int capacity);
    parameters:
    - id: capacity
      type: System.Int32
      description: "新列表最初可以存储的元素数。"
  overload: System.Collections.ArrayList.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>小于零。"
  platform:
  - net462
- uid: System.Collections.ArrayList.Adapter(System.Collections.IList)
  id: Adapter(System.Collections.IList)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: Adapter(IList)
  nameWithType: ArrayList.Adapter(IList)
  fullName: System.Collections.ArrayList.Adapter(IList)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "创建<xref href=&quot;System.Collections.ArrayList&quot;></xref>包装器特定<xref:System.Collections.IList>.</xref:System.Collections.IList>"
  remarks: "适配器不会复制<xref:System.Collections.IList>.</xref:System.Collections.IList>的内容 相反，它仅创建<xref:System.Collections.ArrayList><xref:System.Collections.IList>; 因此，更改<xref:System.Collections.IList>也会影响<xref:System.Collections.ArrayList>.</xref:System.Collections.ArrayList></xref:System.Collections.IList></xref:System.Collections.IList>周围包装</xref:System.Collections.ArrayList>       <xref:System.Collections.ArrayList>类提供了泛型<xref:System.Collections.ArrayList.Reverse%2A>，<xref:System.Collections.ArrayList.BinarySearch%2A>和<xref:System.Collections.ArrayList.Sort%2A>方法。</xref:System.Collections.ArrayList.Sort%2A> </xref:System.Collections.ArrayList.BinarySearch%2A> </xref:System.Collections.ArrayList.Reverse%2A> </xref:System.Collections.ArrayList> 此包装可以是一种方式来使用上<xref:System.Collections.IList>; 但是，执行通过包装这些泛型操作可能会比直接在<xref:System.Collections.IList>.</xref:System.Collections.IList>上应用的操作的效率较低</xref:System.Collections.IList>的那些方法       此方法为 o （1） 运算。      ## 版本兼容性在.NET Framework 版本 1.0 和 1.1 中，调用<xref:System.Collections.ArrayList.GetEnumerator%28System.Int32%2CSystem.Int32%29>上的方法重载<xref:System.Collections.ArrayList>包装返回的枚举数上限，而不是计数处理第二个参数。</xref:System.Collections.ArrayList> </xref:System.Collections.ArrayList.GetEnumerator%28System.Int32%2CSystem.Int32%29> 在[!INCLUDE[dnprdnlong](~/add/includes/dnprdnlong-md.md)]第二个参数正确视为计数。"
  syntax:
    content: public static System.Collections.ArrayList Adapter (System.Collections.IList list);
    parameters:
    - id: list
      type: System.Collections.IList
      description: "<xref:System.Collections.IList>包装。</xref:System.Collections.IList>"
    return:
      type: System.Collections.ArrayList
      description: "<xref href=&quot;System.Collections.ArrayList&quot;> </xref> <xref:System.Collections.IList>.</xref:System.Collections.IList>周围包装"
  overload: System.Collections.ArrayList.Adapter*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>list</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.ArrayList.Add(System.Object)
  id: Add(System.Object)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: Add(Object)
  nameWithType: ArrayList.Add(Object)
  fullName: System.Collections.ArrayList.Add(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "将对象添加到的末尾<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  remarks: "<xref:System.Collections.ArrayList>接受`null`作为有效的值，并允许重复的元素。</xref:System.Collections.ArrayList>       如果<xref:System.Collections.ArrayList.Count%2A>已经等于<xref:System.Collections.ArrayList.Capacity%2A>、 容量的<xref:System.Collections.ArrayList>增加通过自动重新分配在内部数组和现有元素被复制到新数组中，在添加新的元素之前。</xref:System.Collections.ArrayList> </xref:System.Collections.ArrayList.Capacity%2A> </xref:System.Collections.ArrayList.Count%2A>       如果<xref:System.Collections.ArrayList.Count%2A>是小于<xref:System.Collections.ArrayList.Capacity%2A>，此方法为 o （1） 运算。</xref:System.Collections.ArrayList.Capacity%2A> </xref:System.Collections.ArrayList.Count%2A> 如果容量需要增加以容纳新元素，此方法会成为 O (`n`) 操作，其中`n`为<xref:System.Collections.ArrayList.Count%2A>。</xref:System.Collections.ArrayList.Count%2A>"
  example:
  - "The following code example shows how to add elements to the <xref:System.Collections.ArrayList>.  \n  \n [!code-cs[Classic ArrayList.Add Example#1](~/add/codesnippet/csharp/m-system.collections.arr_4_1.cs)]\n [!code-vb[Classic ArrayList.Add Example#1](~/add/codesnippet/visualbasic/m-system.collections.arr_4_1.vb)]\n [!code-cpp[Classic ArrayList.Add Example#1](~/add/codesnippet/cpp/m-system.collections.arr_4_1.cpp)]"
  syntax:
    content: public virtual int Add (object value);
    parameters:
    - id: value
      type: System.Object
      description: "<xref:System.Object>要添加到末尾<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。</xref:System.Object> 该值可以为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.Int32
      description: "<xref href=&quot;System.Collections.ArrayList&quot;> </xref>开始的索引， <code> value </code>已添加。"
  overload: System.Collections.ArrayList.Add*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.ArrayList&quot;> </xref>是只读的。       -或- <xref href=&quot;System.Collections.ArrayList&quot;> </xref>具有固定的大小。"
  platform:
  - net462
- uid: System.Collections.ArrayList.AddRange(System.Collections.ICollection)
  id: AddRange(System.Collections.ICollection)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: AddRange(ICollection)
  nameWithType: ArrayList.AddRange(ICollection)
  fullName: System.Collections.ArrayList.AddRange(ICollection)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "添加的元素<xref:System.Collections.ICollection>到末尾<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。</xref:System.Collections.ICollection>"
  remarks: "<xref:System.Collections.ArrayList>接受`null`作为有效的值，并允许重复的元素。</xref:System.Collections.ArrayList>       中<xref:System.Collections.ICollection>保留在<xref:System.Collections.ArrayList>.</xref:System.Collections.ArrayList></xref:System.Collections.ICollection>元素的顺序       如果新<xref:System.Collections.ArrayList.Count%2A>(当前<xref:System.Collections.ArrayList.Count%2A>plus 集合的大小) 将大于<xref:System.Collections.ArrayList.Capacity%2A>、 容量的<xref:System.Collections.ArrayList>增加通过自动重新分配以容纳新元素，在内部数组和现有元素被复制到新数组中，在添加新的元素之前。</xref:System.Collections.ArrayList> </xref:System.Collections.ArrayList.Capacity%2A> </xref:System.Collections.ArrayList.Count%2A> </xref:System.Collections.ArrayList.Count%2A>       如果<xref:System.Collections.ArrayList>可以容纳新元素，而无需增加<xref:System.Collections.ArrayList.Capacity%2A>，此方法为 O (`n`) 操作，其中`n`是要添加的元素数。</xref:System.Collections.ArrayList.Capacity%2A> </xref:System.Collections.ArrayList> 如果增加以容纳新元素所需的容量，此方法会成为 O (`n` + `m`) 操作，其中`n`是要添加的元素的数目和`m`为<xref:System.Collections.ArrayList.Count%2A>。</xref:System.Collections.ArrayList.Count%2A>"
  example:
  - "The following code example shows how to add elements to the <xref:System.Collections.ArrayList>.  \n  \n [!code-cs[Classic ArrayList.Add Example#1](~/add/codesnippet/csharp/m-system.collections.arr_0_1.cs)]\n [!code-vb[Classic ArrayList.Add Example#1](~/add/codesnippet/visualbasic/m-system.collections.arr_0_1.vb)]\n [!code-cpp[Classic ArrayList.Add Example#1](~/add/codesnippet/cpp/m-system.collections.arr_0_1.cpp)]"
  syntax:
    content: public virtual void AddRange (System.Collections.ICollection c);
    parameters:
    - id: c
      type: System.Collections.ICollection
      description: "<xref:System.Collections.ICollection>其元素应添加到末尾<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。</xref:System.Collections.ICollection> 集合自身不能为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，但它可以包含的元素<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Collections.ArrayList.AddRange*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>c</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.ArrayList&quot;> </xref>是只读的。       -或- <xref href=&quot;System.Collections.ArrayList&quot;> </xref>具有固定的大小。"
  platform:
  - net462
- uid: System.Collections.ArrayList.BinarySearch(System.Object)
  id: BinarySearch(System.Object)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: BinarySearch(Object)
  nameWithType: ArrayList.BinarySearch(Object)
  fullName: System.Collections.ArrayList.BinarySearch(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "搜索在整个已排序<xref href=&quot;System.Collections.ArrayList&quot;></xref>元素使用默认比较器，并返回的元素的从零开始的索引。"
  remarks: "`value`参数和的每个元素<xref:System.Collections.ArrayList>必须实现<xref:System.IComparable>接口，用于比较。</xref:System.IComparable> </xref:System.Collections.ArrayList> 元素<xref:System.Collections.ArrayList>必须已在增加根据定义的排序顺序的值进行排序<xref:System.IComparable>实现; 否则，结果可能不正确。</xref:System.IComparable> </xref:System.Collections.ArrayList>       比较`null`允许与任何类型和使用<xref:System.IComparable>.</xref:System.IComparable>时不会生成异常 在排序时，`null`被视为小于任何其他对象。       如果<xref:System.Collections.ArrayList>多个元素具有相同的值，该方法返回仅包含一个匹配项，并且可能会返回任何一个匹配项，不一定是第一个。</xref:System.Collections.ArrayList>       如果<xref:System.Collections.ArrayList>不包含指定的值，该方法返回负整数。</xref:System.Collections.ArrayList> 你可以应用于此负的整数，以获取大于搜索值的第一个元素的索引的按位求补运算 （~）。 插入到的值时<xref:System.Collections.ArrayList>，此索引应使用的插入点，若要维护的排序顺序。</xref:System.Collections.ArrayList>       此方法为 O (日志`n`) 操作，其中`n`为<xref:System.Collections.ArrayList.Count%2A>。</xref:System.Collections.ArrayList.Count%2A>"
  example:
  - "The following code example shows how to use <xref:System.Collections.ArrayList.BinarySearch%2A> to locate a specific object in the <xref:System.Collections.ArrayList>.  \n  \n [!code-cpp[Classic ArrayList.BinarySearch1 Example#1](~/add/codesnippet/cpp/m-system.collections.arr_13_1.cpp)]\n [!code-cs[Classic ArrayList.BinarySearch1 Example#1](~/add/codesnippet/csharp/m-system.collections.arr_13_1.cs)]\n [!code-vb[Classic ArrayList.BinarySearch1 Example#1](~/add/codesnippet/visualbasic/m-system.collections.arr_13_1.vb)]"
  syntax:
    content: public virtual int BinarySearch (object value);
    parameters:
    - id: value
      type: System.Object
      description: "<xref:System.Object>查找。</xref:System.Object> 该值可以为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.Int32
      description: "从零开始的索引<code> value </code>则为已排序<xref href=&quot;System.Collections.ArrayList&quot;> </xref>，如果<code> value </code>找到; 否则为一个负数数字，即大于的下一个元素索引的按位求补<code> value </code>或如果没有更大的元素， <xref:System.Collections.ArrayList.Count*>.</xref:System.Collections.ArrayList.Count*>的按位求补"
  overload: System.Collections.ArrayList.BinarySearch*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "既不<code> value </code>也的元素不<xref href=&quot;System.Collections.ArrayList&quot;></xref>实现<xref:System.IComparable>接口。</xref:System.IComparable>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>value</code>不属于同一类型的元素<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  platform:
  - net462
- uid: System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)
  id: BinarySearch(System.Object,System.Collections.IComparer)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: BinarySearch(Object,IComparer)
  nameWithType: ArrayList.BinarySearch(Object,IComparer)
  fullName: System.Collections.ArrayList.BinarySearch(Object,IComparer)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "搜索在整个已排序<xref href=&quot;System.Collections.ArrayList&quot;></xref>元素使用指定的比较器，并返回的元素的从零开始的索引。"
  remarks: "比较器自定义如何比较元素。 例如，你可以使用<xref:System.Collections.CaseInsensitiveComparer>实例作为要执行不区分大小写的字符串搜索的比较器。</xref:System.Collections.CaseInsensitiveComparer>       如果`comparer`提供的元素<xref:System.Collections.ArrayList>与使用指定的指定值进行比较<xref:System.Collections.IComparer>实现。</xref:System.Collections.IComparer> </xref:System.Collections.ArrayList> 元素<xref:System.Collections.ArrayList>必须已在增加根据定义的排序顺序的值进行排序`comparer`; 否则为结果可能不正确。</xref:System.Collections.ArrayList>       如果`comparer`是`null`，完成比较使用<xref:System.IComparable>通过自身的元素或指定的值提供的实现。</xref:System.IComparable> 元素<xref:System.Collections.ArrayList>必须已在增加根据定义的排序顺序的值进行排序<xref:System.IComparable>实现; 否则，结果可能不正确。</xref:System.IComparable> </xref:System.Collections.ArrayList>       比较`null`允许与任何类型和使用<xref:System.IComparable>.</xref:System.IComparable>时不会生成异常 在排序时，`null`被视为小于任何其他对象。       如果<xref:System.Collections.ArrayList>多个元素具有相同的值，该方法返回仅包含一个匹配项，并且可能会返回任何一个匹配项，不一定是第一个。</xref:System.Collections.ArrayList>       如果<xref:System.Collections.ArrayList>不包含指定的值，该方法返回负整数。</xref:System.Collections.ArrayList> 你可以应用于此负的整数，以获取大于搜索值的第一个元素的索引的按位求补运算 （~）。 插入到的值时<xref:System.Collections.ArrayList>，此索引应使用的插入点，若要维护的排序顺序。</xref:System.Collections.ArrayList>       此方法为 O (日志`n`) 操作，其中`n`为<xref:System.Collections.ArrayList.Count%2A>。</xref:System.Collections.ArrayList.Count%2A>"
  example:
  - "The following example creates an <xref:System.Collections.ArrayList> of colored animals. The provided <xref:System.Collections.IComparer> performs the string comparison for the binary search. The results of both an iterative search and a binary search are displayed.  \n  \n [!code-cpp[Classic ArrayList.BinarySearch1 Example#2](~/add/codesnippet/cpp/51ebb232-4223-422e-9ecb-_1.cpp)]\n [!code-cs[Classic ArrayList.BinarySearch1 Example#2](~/add/codesnippet/csharp/51ebb232-4223-422e-9ecb-_1.cs)]\n [!code-vb[Classic ArrayList.BinarySearch1 Example#2](~/add/codesnippet/visualbasic/51ebb232-4223-422e-9ecb-_1.vb)]"
  syntax:
    content: public virtual int BinarySearch (object value, System.Collections.IComparer comparer);
    parameters:
    - id: value
      type: System.Object
      description: "<xref:System.Object>查找。</xref:System.Object> 该值可以为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
    - id: comparer
      type: System.Collections.IComparer
      description: "<xref:System.Collections.IComparer>比较元素时要使用的实现。</xref:System.Collections.IComparer>       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>若要使用的默认比较器是<xref:System.IComparable>每个元素的实现。</xref:System.IComparable>"
    return:
      type: System.Int32
      description: "从零开始的索引<code> value </code>则为已排序<xref href=&quot;System.Collections.ArrayList&quot;> </xref>，如果<code> value </code>找到; 否则为一个负数数字，即大于的下一个元素索引的按位求补<code> value </code>或如果没有更大的元素， <xref:System.Collections.ArrayList.Count*>.</xref:System.Collections.ArrayList.Count*>的按位求补"
  overload: System.Collections.ArrayList.BinarySearch*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>comparer</code>是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>并且不<code>value</code>也的元素不<xref href=&quot;System.Collections.ArrayList&quot;></xref>实现<xref:System.IComparable>接口。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>comparer</code>是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>和<code>value</code>不属于同一类型的元素<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  platform:
  - net462
- uid: System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)
  id: BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: BinarySearch(Int32,Int32,Object,IComparer)
  nameWithType: ArrayList.BinarySearch(Int32,Int32,Object,IComparer)
  fullName: System.Collections.ArrayList.BinarySearch(Int32,Int32,Object,IComparer)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "在已排序的元素范围搜索<xref href=&quot;System.Collections.ArrayList&quot;></xref>元素使用指定的比较器，并返回的元素的从零开始的索引。"
  remarks: "比较器自定义如何比较元素。 例如，你可以使用<xref:System.Collections.CaseInsensitiveComparer>实例作为要执行不区分大小写的字符串搜索的比较器。</xref:System.Collections.CaseInsensitiveComparer>       如果`comparer`提供的元素<xref:System.Collections.ArrayList>与使用指定的指定值进行比较<xref:System.Collections.IComparer>实现。</xref:System.Collections.IComparer> </xref:System.Collections.ArrayList> 元素<xref:System.Collections.ArrayList>必须已在增加根据定义的排序顺序的值进行排序`comparer`; 否则为结果可能不正确。</xref:System.Collections.ArrayList>       如果`comparer`是`null`，完成比较使用<xref:System.IComparable>通过自身的元素或指定的值提供的实现。</xref:System.IComparable> 元素<xref:System.Collections.ArrayList>必须已在增加根据定义的排序顺序的值进行排序<xref:System.IComparable>实现; 否则，结果可能不正确。</xref:System.IComparable> </xref:System.Collections.ArrayList>       比较`null`允许与任何类型和使用<xref:System.IComparable>.</xref:System.IComparable>时不会生成异常 在排序时，`null`被视为小于任何其他对象。       如果<xref:System.Collections.ArrayList>多个元素具有相同的值，该方法返回仅包含一个匹配项，并且可能会返回任何一个匹配项，不一定是第一个。</xref:System.Collections.ArrayList>       如果<xref:System.Collections.ArrayList>不包含指定的值，该方法返回负整数。</xref:System.Collections.ArrayList> 你可以应用于此负的整数，以获取大于搜索值的第一个元素的索引的按位求补运算 （~）。 插入到的值时<xref:System.Collections.ArrayList>，此索引应使用的插入点，若要维护的排序顺序。</xref:System.Collections.ArrayList>       此方法为 O (日志`n`) 操作，其中`n`是`count`。"
  syntax:
    content: public virtual int BinarySearch (int index, int count, object value, System.Collections.IComparer comparer);
    parameters:
    - id: index
      type: System.Int32
      description: "要搜索的范围的从零开始的起始索引。"
    - id: count
      type: System.Int32
      description: "要搜索的范围的长度。"
    - id: value
      type: System.Object
      description: "<xref:System.Object>查找。</xref:System.Object> 该值可以为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
    - id: comparer
      type: System.Collections.IComparer
      description: "<xref:System.Collections.IComparer>比较元素时要使用的实现。</xref:System.Collections.IComparer>       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>若要使用的默认比较器是<xref:System.IComparable>每个元素的实现。</xref:System.IComparable>"
    return:
      type: System.Int32
      description: "从零开始的索引<code> value </code>则为已排序<xref href=&quot;System.Collections.ArrayList&quot;> </xref>，如果<code> value </code>找到; 否则为一个负数数字，即大于的下一个元素索引的按位求补<code> value </code>或如果没有更大的元素， <xref:System.Collections.ArrayList.Count*>.</xref:System.Collections.ArrayList.Count*>的按位求补"
  overload: System.Collections.ArrayList.BinarySearch*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>index</code>和<code>count</code>不表示中的有效范围<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。       -<code>comparer</code>是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>并且不<code>value</code>也的元素不<xref href=&quot;System.Collections.ArrayList&quot;></xref>实现<xref:System.IComparable>接口。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>comparer</code>是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>和<code>value</code>不属于同一类型的元素<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>小于零。       -或-<code>count</code>小于零。"
  platform:
  - net462
- uid: System.Collections.ArrayList.Capacity
  id: Capacity
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: Capacity
  nameWithType: ArrayList.Capacity
  fullName: System.Collections.ArrayList.Capacity
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "获取或设置元素的数目<xref href=&quot;System.Collections.ArrayList&quot;></xref>可以包含。"
  remarks: "容量是元素的数目，<xref:System.Collections.ArrayList>可以存储。</xref:System.Collections.ArrayList> <xref:System.Collections.ArrayList.Count%2A>是其实是<xref:System.Collections.ArrayList>.</xref:System.Collections.ArrayList>的元素的数目</xref:System.Collections.ArrayList.Count%2A>       容量始终是大于或等于<xref:System.Collections.ArrayList.Count%2A>.</xref:System.Collections.ArrayList.Count%2A> 如果<xref:System.Collections.ArrayList.Count%2A>添加元素时超过容量，通过在复制旧元素和添加新的元素之前重新分配在内部数组自动增加容量。</xref:System.Collections.ArrayList.Count%2A>       可以通过调用减少容量<xref:System.Collections.ArrayList.TrimToSize%2A>或通过显式设置的容量属性。</xref:System.Collections.ArrayList.TrimToSize%2A> 当显式设置的容量的值时，在内部数组也会重新分配以适应指定的容量。       检索此属性的值的运算 o （1）;将属性设置为 O (`n`) 操作，其中`n`新容量。"
  syntax:
    content: public virtual int Capacity { get; set; }
    return:
      type: System.Int32
      description: "元素的数目， <xref href=&quot;System.Collections.ArrayList&quot;> </xref>可以包含。"
  overload: System.Collections.ArrayList.Capacity*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "容量设置为小于<xref:System.Collections.ArrayList.Count*>.</xref:System.Collections.ArrayList.Count*>值"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "没有足够的内存可用系统上。"
  platform:
  - net462
- uid: System.Collections.ArrayList.Clear
  id: Clear
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: Clear()
  nameWithType: ArrayList.Clear()
  fullName: System.Collections.ArrayList.Clear()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "移除所有元素从<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  remarks: "<xref:System.Collections.ArrayList.Count%2A>是设置为零，并且集合的元素对其他对象的引用也被释放。</xref:System.Collections.ArrayList.Count%2A>       <xref:System.Collections.ArrayList.Capacity%2A>保持不变。</xref:System.Collections.ArrayList.Capacity%2A>  若要重置的容量<xref:System.Collections.ArrayList>，调用<xref:System.Collections.ArrayList.TrimToSize%2A>或设置<xref:System.Collections.ArrayList.Capacity%2A>属性直接。</xref:System.Collections.ArrayList.Capacity%2A> </xref:System.Collections.ArrayList.TrimToSize%2A> </xref:System.Collections.ArrayList> 截去空<xref:System.Collections.ArrayList>的容量设置<xref:System.Collections.ArrayList>到默认的容量。</xref:System.Collections.ArrayList> </xref:System.Collections.ArrayList>       此方法为 O (`n`) 操作，其中`n`为<xref:System.Collections.ArrayList.Count%2A>。</xref:System.Collections.ArrayList.Count%2A>"
  example:
  - "The following code example shows how to trim the unused portions of the <xref:System.Collections.ArrayList> and how to clear the values of the <xref:System.Collections.ArrayList>.  \n  \n [!code-cs[Classic ArrayList.Clear Example#1](~/add/codesnippet/csharp/m-system.collections.arr_18_1.cs)]\n [!code-cpp[Classic ArrayList.Clear Example#1](~/add/codesnippet/cpp/m-system.collections.arr_18_1.cpp)]\n [!code-vb[Classic ArrayList.Clear Example#1](~/add/codesnippet/visualbasic/m-system.collections.arr_18_1.vb)]"
  syntax:
    content: public virtual void Clear ();
    parameters: []
  overload: System.Collections.ArrayList.Clear*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.ArrayList&quot;> </xref>是只读的。       -或- <xref href=&quot;System.Collections.ArrayList&quot;> </xref>具有固定的大小。"
  platform:
  - net462
- uid: System.Collections.ArrayList.Clone
  id: Clone
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: Clone()
  nameWithType: ArrayList.Clone()
  fullName: System.Collections.ArrayList.Clone()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "创建的浅表复制<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  remarks: "集合的浅表副本复制仅的元素集合，不论它们是引用类型还是值类型，但它不会复制引用所引用的对象。 新集合中的引用都指向原始集合中的引用指向同一对象。       与此相反，集合的深层副本复制这些元素，以及由这些元素直接或间接引用的所有内容。       此方法为 O (`n`) 操作，其中`n`为<xref:System.Collections.ArrayList.Count%2A>。</xref:System.Collections.ArrayList.Count%2A>"
  syntax:
    content: public virtual object Clone ();
    parameters: []
    return:
      type: System.Object
      description: "浅表复制<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  overload: System.Collections.ArrayList.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.ArrayList.Contains(System.Object)
  id: Contains(System.Object)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: Contains(Object)
  nameWithType: ArrayList.Contains(Object)
  fullName: System.Collections.ArrayList.Contains(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "确定某元素是否在<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  remarks: "此方法执行的线性搜索;因此，此方法为 O (`n`) 操作，其中`n`为<xref:System.Collections.ArrayList.Count%2A>。</xref:System.Collections.ArrayList.Count%2A>       此方法通过调用<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>确定相等性       从.NET Framework 2.0 开始，此方法使用集合的对象<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`以确定是否存在项。</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> 在.NET Framework 的早期版本，通过进行此决定<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`参数的集合中的对象。</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  syntax:
    content: public virtual bool Contains (object item);
    parameters:
    - id: item
      type: System.Object
      description: "<xref:System.Object>要在中查找<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。</xref:System.Object> 该值可以为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>if <code>item</code> is found in the <xref href=&quot;System.Collections.ArrayList&quot;></xref>; otherwise, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>."
  overload: System.Collections.ArrayList.Contains*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.ArrayList.CopyTo(System.Array)
  id: CopyTo(System.Array)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: CopyTo(Array)
  nameWithType: ArrayList.CopyTo(Array)
  fullName: System.Collections.ArrayList.CopyTo(Array)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "将复制整个<xref href=&quot;System.Collections.ArrayList&quot;></xref>到兼容的一维<xref:System.Array>，从目标数组的开头处开始。</xref:System.Array>"
  remarks: "指定的数组必须具有兼容类型。       此方法使用<xref:System.Array.Copy%2A?displayProperty=fullName>要复制的元素。</xref:System.Array.Copy%2A?displayProperty=fullName>       元素被复制到<xref:System.Array>与在其中的枚举数循环访问<xref:System.Collections.ArrayList>.</xref:System.Collections.ArrayList>相同的顺序</xref:System.Array>       此方法为 O (`n`) 操作，其中`n`为<xref:System.Collections.ArrayList.Count%2A>。</xref:System.Collections.ArrayList.Count%2A>"
  example:
  - "The following code example shows how to copy an <xref:System.Collections.ArrayList> into a one-dimensional <xref:System.Array?displayProperty=fullName>.  \n  \n [!code-cs[Classic ArrayList.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.arr_6_1.cs)]\n [!code-vb[Classic ArrayList.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.arr_6_1.vb)]\n [!code-cpp[Classic ArrayList.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.arr_6_1.cpp)]"
  syntax:
    content: public virtual void CopyTo (Array array);
    parameters:
    - id: array
      type: System.Array
      description: "一维<xref:System.Array>，它是从复制的元素的目标<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。</xref:System.Array> <xref:System.Array>必须具有从零开始的索引。</xref:System.Array>"
  overload: System.Collections.ArrayList.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>是多维的。       -源中的元素的数目<xref href=&quot;System.Collections.ArrayList&quot;></xref>大于元素的数目，目标<code>array</code>可以包含。"
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "源类型<xref href=&quot;System.Collections.ArrayList&quot;></xref>无法自动转换为目标的类型<code> array </code>。"
  platform:
  - net462
- uid: System.Collections.ArrayList.CopyTo(System.Array,System.Int32)
  id: CopyTo(System.Array,System.Int32)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: CopyTo(Array,Int32)
  nameWithType: ArrayList.CopyTo(Array,Int32)
  fullName: System.Collections.ArrayList.CopyTo(Array,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "将复制整个<xref href=&quot;System.Collections.ArrayList&quot;></xref>到兼容的一维<xref:System.Array>，从目标数组的指定索引处开始。</xref:System.Array>"
  remarks: "指定的数组必须具有兼容类型。       此方法使用<xref:System.Array.Copy%2A?displayProperty=fullName>要复制的元素。</xref:System.Array.Copy%2A?displayProperty=fullName>       元素被复制到<xref:System.Array>与在其中的枚举数循环访问<xref:System.Collections.ArrayList>.</xref:System.Collections.ArrayList>相同的顺序</xref:System.Array>       此方法为 O (`n`) 操作，其中`n`为<xref:System.Collections.ArrayList.Count%2A>。</xref:System.Collections.ArrayList.Count%2A>"
  example:
  - "The following code example shows how to copy an <xref:System.Collections.ArrayList> into a one-dimensional <xref:System.Array?displayProperty=fullName>.  \n  \n [!code-cpp[Classic ArrayList.CopyTo1 Example#1](~/add/codesnippet/cpp/m-system.collections.arr_27_1.cpp)]\n [!code-cs[Classic ArrayList.CopyTo1 Example#1](~/add/codesnippet/csharp/m-system.collections.arr_27_1.cs)]\n [!code-vb[Classic ArrayList.CopyTo1 Example#1](~/add/codesnippet/visualbasic/m-system.collections.arr_27_1.vb)]"
  syntax:
    content: public virtual void CopyTo (Array array, int arrayIndex);
    parameters:
    - id: array
      type: System.Array
      description: "一维<xref:System.Array>，它是从复制的元素的目标<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。</xref:System.Array> <xref:System.Array>必须具有从零开始的索引。</xref:System.Array>"
    - id: arrayIndex
      type: System.Int32
      description: "中的从零开始索引`array`复制开始处。"
  overload: System.Collections.ArrayList.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>arrayIndex</code>小于零。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>是多维的。       -源中的元素的数目<xref href=&quot;System.Collections.ArrayList&quot;></xref>大于从的可用空间<code>arrayIndex</code>到目标的末尾<code>array</code>。"
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "源类型<xref href=&quot;System.Collections.ArrayList&quot;></xref>无法自动转换为目标的类型<code> array </code>。"
  platform:
  - net462
- uid: System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)
  id: CopyTo(System.Int32,System.Array,System.Int32,System.Int32)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: CopyTo(Int32,Array,Int32,Int32)
  nameWithType: ArrayList.CopyTo(Int32,Array,Int32,Int32)
  fullName: System.Collections.ArrayList.CopyTo(Int32,Array,Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "将复制的一系列元素从<xref href=&quot;System.Collections.ArrayList&quot;></xref>到兼容的一维<xref:System.Array>，从目标数组的指定索引处开始。</xref:System.Array>"
  remarks: "指定的数组必须具有兼容类型。       此方法使用<xref:System.Array.Copy%2A?displayProperty=fullName>要复制的元素。</xref:System.Array.Copy%2A?displayProperty=fullName>       元素被复制到<xref:System.Array>与在其中的枚举数循环访问<xref:System.Collections.ArrayList>.</xref:System.Collections.ArrayList>相同的顺序</xref:System.Array>       此方法为 O (`n`) 操作，其中`n`是`count`。"
  example:
  - "The following code example shows how to copy an <xref:System.Collections.ArrayList> into a one-dimensional <xref:System.Array?displayProperty=fullName>.  \n  \n [!code-cpp[Classic ArrayList.CopyTo1 Example#1](~/add/codesnippet/cpp/971aa346-8de3-42af-8cd4-_1.cpp)]\n [!code-cs[Classic ArrayList.CopyTo1 Example#1](~/add/codesnippet/csharp/971aa346-8de3-42af-8cd4-_1.cs)]\n [!code-vb[Classic ArrayList.CopyTo1 Example#1](~/add/codesnippet/visualbasic/971aa346-8de3-42af-8cd4-_1.vb)]"
  syntax:
    content: public virtual void CopyTo (int index, Array array, int arrayIndex, int count);
    parameters:
    - id: index
      type: System.Int32
      description: "源中的从零开始索引<xref href=&quot;System.Collections.ArrayList&quot;></xref>复制开始处。"
    - id: array
      type: System.Array
      description: "一维<xref:System.Array>，它是从复制的元素的目标<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。</xref:System.Array> <xref:System.Array>必须具有从零开始的索引。</xref:System.Array>"
    - id: arrayIndex
      type: System.Int32
      description: "中的从零开始索引`array`复制开始处。"
    - id: count
      type: System.Int32
      description: "要复制的元素数。"
  overload: System.Collections.ArrayList.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>小于零。       -或-<code>arrayIndex</code>小于零。       -或-<code>count</code>小于零。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>是多维的。       -<code>index</code>等于或大于<xref:System.Collections.ArrayList.Count*>的源<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。       -从元素的数目<code>index</code>到源末尾<xref href=&quot;System.Collections.ArrayList&quot;></xref>大于从的可用空间<code>arrayIndex</code>到目标的末尾<code>array</code>。"
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "源类型<xref href=&quot;System.Collections.ArrayList&quot;></xref>无法自动转换为目标的类型<code> array </code>。"
  platform:
  - net462
- uid: System.Collections.ArrayList.Count
  id: Count
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: Count
  nameWithType: ArrayList.Count
  fullName: System.Collections.ArrayList.Count
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "获取中实际包含的元素数目<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  remarks: "<xref:System.Collections.ArrayList.Capacity%2A>是的元素数的<xref:System.Collections.ArrayList>可以存储。</xref:System.Collections.ArrayList></xref:System.Collections.ArrayList.Capacity%2A> 计数是其实是<xref:System.Collections.ArrayList>.</xref:System.Collections.ArrayList>的元素的数目       <xref:System.Collections.ArrayList.Capacity%2A>始终是大于或等于计数。</xref:System.Collections.ArrayList.Capacity%2A> 如果计数超过<xref:System.Collections.ArrayList.Capacity%2A>时添加元素，则自动增大容量通过重新在内部数组分配在复制旧元素和添加新的元素之前。</xref:System.Collections.ArrayList.Capacity%2A>       检索此属性的值是一个 o （1） 操作。"
  syntax:
    content: public virtual int Count { get; }
    return:
      type: System.Int32
      description: "中实际包含的元素的数目<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  overload: System.Collections.ArrayList.Count*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)
  id: FixedSize(System.Collections.ArrayList)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: FixedSize(ArrayList)
  nameWithType: ArrayList.FixedSize(ArrayList)
  fullName: System.Collections.ArrayList.FixedSize(ArrayList)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "返回<xref href=&quot;System.Collections.ArrayList&quot;></xref>具有固定大小的包装。"
  remarks: "可以使用此包装来防止原始<xref:System.Collections.ArrayList>.</xref:System.Collections.ArrayList> 元素仍可以修改或替换。       具有固定大小的集合是只是一个集合的包装器防止添加和移除元素;因此，如果对基础集合，包括添加或移除元素，进行更改的固定大小的集合将反映这些更改。       此方法为 o （1） 运算。"
  example:
  - "The following code example shows how to create a fixed-size wrapper around an <xref:System.Collections.ArrayList>.  \n  \n [!code-cs[Classic ArrayList.IsFixedSize Example#1](~/add/codesnippet/csharp/m-system.collections.arr_12_1.cs)]\n [!code-vb[Classic ArrayList.IsFixedSize Example#1](~/add/codesnippet/visualbasic/m-system.collections.arr_12_1.vb)]\n [!code-cpp[Classic ArrayList.IsFixedSize Example#1](~/add/codesnippet/cpp/m-system.collections.arr_12_1.cpp)]"
  syntax:
    content: public static System.Collections.ArrayList FixedSize (System.Collections.ArrayList list);
    parameters:
    - id: list
      type: System.Collections.ArrayList
      description: "<xref href=&quot;System.Collections.ArrayList&quot;> </xref>包装。"
    return:
      type: System.Collections.ArrayList
      description: "<xref href=&quot;System.Collections.ArrayList&quot;> </xref>具有固定大小的包装。"
  overload: System.Collections.ArrayList.FixedSize*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>list</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.ArrayList.FixedSize(System.Collections.IList)
  id: FixedSize(System.Collections.IList)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: FixedSize(IList)
  nameWithType: ArrayList.FixedSize(IList)
  fullName: System.Collections.ArrayList.FixedSize(IList)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "返回<xref:System.Collections.IList>具有固定大小的包装。</xref:System.Collections.IList>"
  remarks: "可以使用此包装来防止原始<xref:System.Collections.IList>.</xref:System.Collections.IList> 元素仍可以修改或替换。       具有固定大小的集合是只是一个集合的包装器防止添加和移除元素;因此，如果对基础集合，包括添加或移除元素，进行更改的固定大小的集合将反映这些更改。       此方法为 o （1） 运算。"
  syntax:
    content: public static System.Collections.IList FixedSize (System.Collections.IList list);
    parameters:
    - id: list
      type: System.Collections.IList
      description: "<xref:System.Collections.IList>包装。</xref:System.Collections.IList>"
    return:
      type: System.Collections.IList
      description: "<xref:System.Collections.IList>具有固定大小的包装。</xref:System.Collections.IList>"
  overload: System.Collections.ArrayList.FixedSize*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>list</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.ArrayList.GetEnumerator
  id: GetEnumerator
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: GetEnumerator()
  nameWithType: ArrayList.GetEnumerator()
  fullName: System.Collections.ArrayList.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "返回整个的枚举数<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  remarks: "`foreach` C# 语言的语句 (`for each`在 Visual Basic 中) 隐藏了枚举数的复杂性。  因此，使用`foreach`建议，而不是直接操作枚举数。       枚举器可用于读取集合中中的数据，但它们不能用于修改基础集合。       最初，枚举数定位在集合中的第一个元素之前。 <xref:System.Collections.IEnumerator.Reset%2A>此外会回此位置的枚举数。</xref:System.Collections.IEnumerator.Reset%2A>  在此位置上，<xref:System.Collections.IEnumerator.Current%2A>是不确定的。</xref:System.Collections.IEnumerator.Current%2A> 因此，你必须调用<xref:System.Collections.IEnumerator.MoveNext%2A>的第一个元素的集合，然后再读取<xref:System.Collections.IEnumerator.Current%2A>.</xref:System.Collections.IEnumerator.Current%2A>的值枚举器向前移动</xref:System.Collections.IEnumerator.MoveNext%2A>       <xref:System.Collections.IEnumerator.Current%2A>返回相同的对象之前<xref:System.Collections.IEnumerator.MoveNext%2A>或<xref:System.Collections.IEnumerator.Reset%2A>称为。</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>设置<xref:System.Collections.IEnumerator.Current%2A>到下一个元素。</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>       如果<xref:System.Collections.IEnumerator.MoveNext%2A>越过的末尾的集合，枚举数定位在集合中的最后一个元素的后面和<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`。</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> 当枚举器位于此位置上，后续调用<xref:System.Collections.IEnumerator.MoveNext%2A>还返回`false`。</xref:System.Collections.IEnumerator.MoveNext%2A> 如果最后一次调用到<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`，<xref:System.Collections.IEnumerator.Current%2A>是不确定的。</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> 若要设置<xref:System.Collections.IEnumerator.Current%2A>可以再次，集合的第一个元素调用<xref:System.Collections.IEnumerator.Reset%2A>后, 跟<xref:System.Collections.IEnumerator.MoveNext%2A>.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.Current%2A>       只要集合保持不变，枚举数就保持有效。 如果对集合进行更改，如添加、 修改或删除元素，则枚举数将失效且不可恢复，而且其行为是不确定。       枚举数没有对集合; 独占访问权因此，枚举整个集合本质上不是一个线程安全的过程。  若要确保枚举过程中的线程安全性，可以锁定在整个枚举期间的集合。  若要允许访问集合以进行读取和写入的多个线程，则必须实现自己的同步。       此方法为 o （1） 运算。"
  example:
  - "The following example gets the enumerator for an <xref:System.Collections.ArrayList>, and the enumerator for a range of elements in the <xref:System.Collections.ArrayList>.  \n  \n [!code-cs[Collections.ArrayList.GetEnumerator#1](~/add/codesnippet/csharp/m-system.collections.arr_2_1.cs)]\n [!code-vb[Collections.ArrayList.GetEnumerator#1](~/add/codesnippet/visualbasic/m-system.collections.arr_2_1.vb)]"
  syntax:
    content: public virtual System.Collections.IEnumerator GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: "<xref:System.Collections.IEnumerator>整个<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。</xref:System.Collections.IEnumerator>"
  overload: System.Collections.ArrayList.GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)
  id: GetEnumerator(System.Int32,System.Int32)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: GetEnumerator(Int32,Int32)
  nameWithType: ArrayList.GetEnumerator(Int32,Int32)
  fullName: System.Collections.ArrayList.GetEnumerator(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "返回的元素范围的枚举数<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  remarks: "`foreach` C# 语言的语句 (`for each` Visual c + + 中`For Each`Visual Basic) 隐藏了枚举数的复杂性。  因此，使用`foreach`建议，而不是直接操作枚举数。       枚举器可用于读取集合中中的数据，但它们不能用于修改基础集合。       最初，枚举数定位在集合中的第一个元素之前。 <xref:System.Collections.IEnumerator.Reset%2A>此外会回此位置的枚举数。</xref:System.Collections.IEnumerator.Reset%2A>  在此位置上，<xref:System.Collections.IEnumerator.Current%2A>是不确定的。</xref:System.Collections.IEnumerator.Current%2A> 因此，你必须调用<xref:System.Collections.IEnumerator.MoveNext%2A>的第一个元素的集合，然后再读取<xref:System.Collections.IEnumerator.Current%2A>.</xref:System.Collections.IEnumerator.Current%2A>的值枚举器向前移动</xref:System.Collections.IEnumerator.MoveNext%2A>       <xref:System.Collections.IEnumerator.Current%2A>返回相同的对象之前<xref:System.Collections.IEnumerator.MoveNext%2A>或<xref:System.Collections.IEnumerator.Reset%2A>称为。</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>设置<xref:System.Collections.IEnumerator.Current%2A>到下一个元素。</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>       如果<xref:System.Collections.IEnumerator.MoveNext%2A>越过的末尾的集合，枚举数定位在集合中的最后一个元素的后面和<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`。</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> 当枚举器位于此位置上，后续调用<xref:System.Collections.IEnumerator.MoveNext%2A>还返回`false`。</xref:System.Collections.IEnumerator.MoveNext%2A> 如果最后一次调用到<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`，<xref:System.Collections.IEnumerator.Current%2A>是不确定的。</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> 若要设置<xref:System.Collections.IEnumerator.Current%2A>可以再次，集合的第一个元素调用<xref:System.Collections.IEnumerator.Reset%2A>后, 跟<xref:System.Collections.IEnumerator.MoveNext%2A>.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.Current%2A>       只要集合保持不变，枚举数就保持有效。 如果对集合进行更改，如添加、 修改或删除元素，则枚举数将失效且不可恢复，而且其行为是不确定。       枚举数没有对集合; 独占访问权因此，枚举整个集合本质上不是一个线程安全的过程。  若要确保枚举过程中的线程安全性，可以锁定在整个枚举期间的集合。  若要允许访问集合以进行读取和写入的多个线程，则必须实现自己的同步。       此方法为 o （1） 运算。      ## 版本兼容性在.NET Framework 1.0 和 1.1 版，枚举数的<xref:System.Collections.ArrayList>包装返回<xref:System.Collections.ArrayList.Adapter%2A>方法被视为第二个参数，上限为而不是做一个计数。</xref:System.Collections.ArrayList.Adapter%2A> </xref:System.Collections.ArrayList> 在[!INCLUDE[dnprdnlong](~/add/includes/dnprdnlong-md.md)]第二个参数正确视为计数。"
  example:
  - "The following example gets the enumerator for an <xref:System.Collections.ArrayList>, and the enumerator for a range of elements in the <xref:System.Collections.ArrayList>.  \n  \n [!code-cs[Collections.ArrayList.GetEnumerator#1](~/add/codesnippet/csharp/m-system.collections.arr_10_1.cs)]\n [!code-vb[Collections.ArrayList.GetEnumerator#1](~/add/codesnippet/visualbasic/m-system.collections.arr_10_1.vb)]"
  syntax:
    content: public virtual System.Collections.IEnumerator GetEnumerator (int index, int count);
    parameters:
    - id: index
      type: System.Int32
      description: "从零开始的起始索引<xref href=&quot;System.Collections.ArrayList&quot;></xref>枚举器应引用的部分。"
    - id: count
      type: System.Int32
      description: "中的元素数<xref href=&quot;System.Collections.ArrayList&quot;></xref>枚举器应引用的部分。"
    return:
      type: System.Collections.IEnumerator
      description: "<xref:System.Collections.IEnumerator>指定范围中元素的<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。</xref:System.Collections.IEnumerator>"
  overload: System.Collections.ArrayList.GetEnumerator*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>小于零。       -或-<code>count</code>小于零。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>index</code>和<code>count</code>未指定中的有效范围<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  platform:
  - net462
- uid: System.Collections.ArrayList.GetRange(System.Int32,System.Int32)
  id: GetRange(System.Int32,System.Int32)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: GetRange(Int32,Int32)
  nameWithType: ArrayList.GetRange(Int32,Int32)
  fullName: System.Collections.ArrayList.GetRange(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "返回<xref href=&quot;System.Collections.ArrayList&quot;></xref>表示源中的元素子集<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  remarks: "此方法不创建的元素的副本。 新<xref:System.Collections.ArrayList>仅源<xref:System.Collections.ArrayList>.</xref:System.Collections.ArrayList>中的视图窗口</xref:System.Collections.ArrayList> 但是，所有后续更改<xref:System.Collections.ArrayList>必须通过此视图窗口<xref:System.Collections.ArrayList>.</xref:System.Collections.ArrayList>执行</xref:System.Collections.ArrayList>源 如果直接对源进行更改<xref:System.Collections.ArrayList>，视图窗口<xref:System.Collections.ArrayList>失效并对它的任何操作将返回<xref:System.InvalidOperationException>.</xref:System.InvalidOperationException> </xref:System.Collections.ArrayList> </xref:System.Collections.ArrayList>       此方法为 o （1） 运算。"
  example:
  - "The following code example shows how to set and get a range of elements in the <xref:System.Collections.ArrayList>.  \n  \n [!code-cs[Classic ArrayList.SetRange Example#1](~/add/codesnippet/csharp/m-system.collections.arr_7_1.cs)]\n [!code-cpp[Classic ArrayList.SetRange Example#1](~/add/codesnippet/cpp/m-system.collections.arr_7_1.cpp)]\n [!code-vb[Classic ArrayList.SetRange Example#1](~/add/codesnippet/visualbasic/m-system.collections.arr_7_1.vb)]"
  syntax:
    content: public virtual System.Collections.ArrayList GetRange (int index, int count);
    parameters:
    - id: index
      type: System.Int32
      description: "从零开始<xref href=&quot;System.Collections.ArrayList&quot;></xref>范围开始处的索引。"
    - id: count
      type: System.Int32
      description: "范围中元素数。"
    return:
      type: System.Collections.ArrayList
      description: "<xref href=&quot;System.Collections.ArrayList&quot;> </xref>表示源中的元素子集<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  overload: System.Collections.ArrayList.GetRange*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>小于零。       -或-<code>count</code>小于零。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>index</code>和<code>count</code>不表示有效的一系列元素中<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  platform:
  - net462
- uid: System.Collections.ArrayList.IndexOf(System.Object)
  id: IndexOf(System.Object)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: IndexOf(Object)
  nameWithType: ArrayList.IndexOf(Object)
  fullName: System.Collections.ArrayList.IndexOf(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "搜索指定<xref:System.Object>并返回在整个的第一个匹配项的从零开始索引<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。</xref:System.Object>"
  remarks: "<xref:System.Collections.ArrayList>向前从第一个元素开始和结束时间的最后一个元素搜索。</xref:System.Collections.ArrayList>       此方法执行的线性搜索;因此，此方法为 O (`n`) 操作，其中`n`为<xref:System.Collections.ArrayList.Count%2A>。</xref:System.Collections.ArrayList.Count%2A>       此方法通过调用<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>确定相等性       从.NET Framework 2.0 开始，此方法使用集合的对象<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`以确定是否存在项。</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> 在.NET Framework 的早期版本，通过进行此决定<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`参数的集合中的对象。</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  example:
  - "The following code example shows how to determine the index of the first occurrence of a specified element.  \n  \n [!code-cpp[Classic ArrayList.IndexOf Example#1](~/add/codesnippet/cpp/m-system.collections.arr_28_1.cpp)]\n [!code-cs[Classic ArrayList.IndexOf Example#1](~/add/codesnippet/csharp/m-system.collections.arr_28_1.cs)]\n [!code-vb[Classic ArrayList.IndexOf Example#1](~/add/codesnippet/visualbasic/m-system.collections.arr_28_1.vb)]"
  syntax:
    content: public virtual int IndexOf (object value);
    parameters:
    - id: value
      type: System.Object
      description: "<xref:System.Object>要在中查找<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。</xref:System.Object> 该值可以为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.Int32
      description: "第一个匹配项的从零开始索引<code> value </code>在整个<xref href=&quot;System.Collections.ArrayList&quot;> </xref>，如果找到; 否则为-1。"
  overload: System.Collections.ArrayList.IndexOf*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.ArrayList.IndexOf(System.Object,System.Int32)
  id: IndexOf(System.Object,System.Int32)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: IndexOf(Object,Int32)
  nameWithType: ArrayList.IndexOf(Object,Int32)
  fullName: System.Collections.ArrayList.IndexOf(Object,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "搜索指定<xref:System.Object>并返回中的元素范围内的第一个匹配项的从零开始索引<xref href=&quot;System.Collections.ArrayList&quot;></xref>扩展从指定索引到最后一个元素。</xref:System.Object>"
  remarks: "<xref:System.Collections.ArrayList>处开始向前搜索`startIndex`和结束时间的最后一个元素。</xref:System.Collections.ArrayList>       此方法执行的线性搜索;因此，此方法为 O (`n`) 操作，其中`n`是中的元素数`startIndex`到<xref:System.Collections.ArrayList>.</xref:System.Collections.ArrayList>末尾       此方法通过调用<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>确定相等性       从.NET Framework 2.0 开始，此方法使用集合的对象<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`以确定是否存在项。</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> 在.NET Framework 的早期版本，通过进行此决定<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`参数的集合中的对象。</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  example:
  - "The following code example shows how to determine the index of the first occurrence of a specified element.  \n  \n [!code-cpp[Classic ArrayList.IndexOf Example#1](~/add/codesnippet/cpp/m-system.collections.arr_22_1.cpp)]\n [!code-cs[Classic ArrayList.IndexOf Example#1](~/add/codesnippet/csharp/m-system.collections.arr_22_1.cs)]\n [!code-vb[Classic ArrayList.IndexOf Example#1](~/add/codesnippet/visualbasic/m-system.collections.arr_22_1.vb)]"
  syntax:
    content: public virtual int IndexOf (object value, int startIndex);
    parameters:
    - id: value
      type: System.Object
      description: "<xref:System.Object>要在中查找<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。</xref:System.Object> 该值可以为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
    - id: startIndex
      type: System.Int32
      description: "搜索的从零开始的起始索引。 0 （零） 为有效值空列表中。"
    return:
      type: System.Int32
      description: "第一个匹配项的从零开始索引<code> value </code>中的元素范围内<xref href=&quot;System.Collections.ArrayList&quot;></xref>扩展从<code> startIndex </code>到最后一个元素，如果找到; 否则为-1。"
  overload: System.Collections.ArrayList.IndexOf*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>startIndex</code>超出的有效索引范围<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  platform:
  - net462
- uid: System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)
  id: IndexOf(System.Object,System.Int32,System.Int32)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: IndexOf(Object,Int32,Int32)
  nameWithType: ArrayList.IndexOf(Object,Int32,Int32)
  fullName: System.Collections.ArrayList.IndexOf(Object,Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "搜索指定<xref:System.Object>并返回中的元素范围内的第一个匹配项的从零开始索引<xref href=&quot;System.Collections.ArrayList&quot;></xref>中指定索引处开始并包含指定的元素数。</xref:System.Object>"
  remarks: "<xref:System.Collections.ArrayList>处开始向前搜索`startIndex`结束`startIndex`加上`count`减 1，如果`count`大于 0。</xref:System.Collections.ArrayList>       此方法执行的线性搜索;因此，此方法为 O (`n`) 操作，其中`n`是`count`。       此方法通过调用<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>确定相等性       从.NET Framework 2.0 开始，此方法使用集合的对象<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`以确定是否存在项。</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> 在.NET Framework 的早期版本，通过进行此决定<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`参数的集合中的对象。</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  example:
  - "The following code example shows how to determine the index of the first occurrence of a specified element.  \n  \n [!code-cpp[Classic ArrayList.IndexOf Example#1](~/add/codesnippet/cpp/m-system.collections.arr_19_1.cpp)]\n [!code-cs[Classic ArrayList.IndexOf Example#1](~/add/codesnippet/csharp/m-system.collections.arr_19_1.cs)]\n [!code-vb[Classic ArrayList.IndexOf Example#1](~/add/codesnippet/visualbasic/m-system.collections.arr_19_1.vb)]"
  syntax:
    content: public virtual int IndexOf (object value, int startIndex, int count);
    parameters:
    - id: value
      type: System.Object
      description: "<xref:System.Object>要在中查找<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。</xref:System.Object> 该值可以为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
    - id: startIndex
      type: System.Int32
      description: "搜索的从零开始的起始索引。 0 （零） 为有效值空列表中。"
    - id: count
      type: System.Int32
      description: "要搜索的部分中的元素数。"
    return:
      type: System.Int32
      description: "第一个匹配项的从零开始索引<code> value </code>中的元素范围内<xref href=&quot;System.Collections.ArrayList&quot;></xref>开始<code> startIndex </code>和包含<code> count </code>个元素，如果找到; 否则为-1。"
  overload: System.Collections.ArrayList.IndexOf*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>startIndex</code>超出的有效索引范围<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。       -或-<code>count</code>小于零。       -<code>startIndex</code>和<code>count</code>未指定有效部分中的<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  platform:
  - net462
- uid: System.Collections.ArrayList.Insert(System.Int32,System.Object)
  id: Insert(System.Int32,System.Object)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: Insert(Int32,Object)
  nameWithType: ArrayList.Insert(Int32,Object)
  fullName: System.Collections.ArrayList.Insert(Int32,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "将元素插入<xref href=&quot;System.Collections.ArrayList&quot;></xref>的指定索引处。"
  remarks: "<xref:System.Collections.ArrayList>接受`null`作为有效的值，并允许重复的元素。</xref:System.Collections.ArrayList>       如果<xref:System.Collections.ArrayList.Count%2A>已经等于<xref:System.Collections.ArrayList.Capacity%2A>、 容量的<xref:System.Collections.ArrayList>增加通过自动重新分配在内部数组和现有元素被复制到新数组中，在添加新的元素之前。</xref:System.Collections.ArrayList> </xref:System.Collections.ArrayList.Capacity%2A> </xref:System.Collections.ArrayList.Count%2A>       如果`index`等同于<xref:System.Collections.ArrayList.Count%2A>，`value`添加到<xref:System.Collections.ArrayList>.</xref:System.Collections.ArrayList>末尾</xref:System.Collections.ArrayList.Count%2A>       在集合中的连续元素，如列表，在插入点之后的元素将下移以容纳新元素。 如果集合具有索引，则移动的元素的索引也将更新。 此行为不适用于元素按概念划分为不同存储桶，如哈希表的集合。       此方法为 O (`n`) 操作，其中`n`为<xref:System.Collections.ArrayList.Count%2A>。</xref:System.Collections.ArrayList.Count%2A>"
  example:
  - "The following code example shows how to insert elements into the <xref:System.Collections.ArrayList>.  \n  \n [!code-cs[Classic ArrayList.Insert Example#1](~/add/codesnippet/csharp/m-system.collections.arr_15_1.cs)]\n [!code-vb[Classic ArrayList.Insert Example#1](~/add/codesnippet/visualbasic/m-system.collections.arr_15_1.vb)]\n [!code-cpp[Classic ArrayList.Insert Example#1](~/add/codesnippet/cpp/m-system.collections.arr_15_1.cpp)]"
  syntax:
    content: public virtual void Insert (int index, object value);
    parameters:
    - id: index
      type: System.Int32
      description: "从零开始的索引位置`value`应插入。"
    - id: value
      type: System.Object
      description: "<xref:System.Object>插入。</xref:System.Object> 该值可以为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Collections.ArrayList.Insert*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>小于零。       -<code>index</code>大于<xref:System.Collections.ArrayList.Count*>。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.ArrayList&quot;> </xref>是只读的。       -或- <xref href=&quot;System.Collections.ArrayList&quot;> </xref>具有固定的大小。"
  platform:
  - net462
- uid: System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)
  id: InsertRange(System.Int32,System.Collections.ICollection)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: InsertRange(Int32,ICollection)
  nameWithType: ArrayList.InsertRange(Int32,ICollection)
  fullName: System.Collections.ArrayList.InsertRange(Int32,ICollection)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "将集合中的元素插入<xref href=&quot;System.Collections.ArrayList&quot;></xref>的指定索引处。"
  remarks: "<xref:System.Collections.ArrayList>接受`null`作为有效的值，并允许重复的元素。</xref:System.Collections.ArrayList>       如果新<xref:System.Collections.ArrayList.Count%2A>(当前<xref:System.Collections.ArrayList.Count%2A>plus 集合的大小) 将大于<xref:System.Collections.ArrayList.Capacity%2A>、 容量的<xref:System.Collections.ArrayList>增加通过自动重新分配以容纳新元素，在内部数组和现有元素被复制到新数组中，在添加新的元素之前。</xref:System.Collections.ArrayList> </xref:System.Collections.ArrayList.Capacity%2A> </xref:System.Collections.ArrayList.Count%2A> </xref:System.Collections.ArrayList.Count%2A>       如果`index`等于<xref:System.Collections.ArrayList.Count%2A>，元素添加到<xref:System.Collections.ArrayList>.</xref:System.Collections.ArrayList>末尾</xref:System.Collections.ArrayList.Count%2A>       中<xref:System.Collections.ICollection>保留在<xref:System.Collections.ArrayList>.</xref:System.Collections.ArrayList></xref:System.Collections.ICollection>元素的顺序       在集合中的连续元素，如列表，在插入点之后的元素将下移以容纳新元素。 如果集合具有索引，则移动的元素的索引也将更新。 此行为不适用于元素按概念划分为不同存储桶，如哈希表的集合。       此方法为 O (`n` + `m`) 操作，其中`n`是要添加的元素的数目和`m`为<xref:System.Collections.ArrayList.Count%2A>。</xref:System.Collections.ArrayList.Count%2A>"
  example:
  - "The following code example shows how to insert elements into the <xref:System.Collections.ArrayList>.  \n  \n [!code-cs[Classic ArrayList.Insert Example#1](~/add/codesnippet/csharp/2b051d32-7260-4f65-b4d6-_1.cs)]\n [!code-vb[Classic ArrayList.Insert Example#1](~/add/codesnippet/visualbasic/2b051d32-7260-4f65-b4d6-_1.vb)]\n [!code-cpp[Classic ArrayList.Insert Example#1](~/add/codesnippet/cpp/2b051d32-7260-4f65-b4d6-_1.cpp)]"
  syntax:
    content: public virtual void InsertRange (int index, System.Collections.ICollection c);
    parameters:
    - id: index
      type: System.Int32
      description: "从零开始的索引，应在此处插入新元素。"
    - id: c
      type: System.Collections.ICollection
      description: "<xref:System.Collections.ICollection>应将其元素插入到<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。</xref:System.Collections.ICollection> 集合自身不能为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，但它可以包含的元素<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Collections.ArrayList.InsertRange*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>c</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>小于零。       -<code>index</code>大于<xref:System.Collections.ArrayList.Count*>。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.ArrayList&quot;> </xref>是只读的。       -或- <xref href=&quot;System.Collections.ArrayList&quot;> </xref>具有固定的大小。"
  platform:
  - net462
- uid: System.Collections.ArrayList.IsFixedSize
  id: IsFixedSize
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: IsFixedSize
  nameWithType: ArrayList.IsFixedSize
  fullName: System.Collections.ArrayList.IsFixedSize
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "获取一个值，该值指示是否<xref href=&quot;System.Collections.ArrayList&quot;></xref>具有固定的大小。"
  remarks: "具有固定大小的集合不允许添加或移除元素后的集合在创建，但是允许修改现有元素。       具有固定大小的集合是只是一个集合的包装器防止添加和移除元素;因此，如果对基础集合，包括添加或移除元素，进行更改的固定大小的集合将反映这些更改。       检索此属性的值是一个 o （1） 操作。"
  example:
  - "The following code example shows how to create a fixed-size wrapper around an <xref:System.Collections.ArrayList>.  \n  \n [!code-cs[Classic ArrayList.IsFixedSize Example#1](~/add/codesnippet/csharp/p-system.collections.arr_2_1.cs)]\n [!code-vb[Classic ArrayList.IsFixedSize Example#1](~/add/codesnippet/visualbasic/p-system.collections.arr_2_1.vb)]\n [!code-cpp[Classic ArrayList.IsFixedSize Example#1](~/add/codesnippet/cpp/p-system.collections.arr_2_1.cpp)]"
  syntax:
    content: public virtual bool IsFixedSize { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Collections.ArrayList&quot;></xref>具有固定大小; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Collections.ArrayList.IsFixedSize*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.ArrayList.IsReadOnly
  id: IsReadOnly
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: IsReadOnly
  nameWithType: ArrayList.IsReadOnly
  fullName: System.Collections.ArrayList.IsReadOnly
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "获取一个值，该值指示是否<xref href=&quot;System.Collections.ArrayList&quot;></xref>是只读的。"
  remarks: "集合是只读的不允许添加、 移除或修改元素的集合在创建后。       集合是只读的是只是一个集合与防止集合; 进行修改的包装因此，如果对基础集合进行更改，只读集合将反映这些更改。       检索此属性的值是一个 o （1） 操作。"
  example:
  - "The following code example shows how to create a read-only wrapper around an <xref:System.Collections.ArrayList> and how to determine if an <xref:System.Collections.ArrayList> is read-only.  \n  \n [!code-cs[Classic ArrayList.ReadOnly1 Example#1](~/add/codesnippet/csharp/p-system.collections.arr_3_1.cs)]\n [!code-cpp[Classic ArrayList.ReadOnly1 Example#1](~/add/codesnippet/cpp/p-system.collections.arr_3_1.cpp)]\n [!code-vb[Classic ArrayList.ReadOnly1 Example#1](~/add/codesnippet/visualbasic/p-system.collections.arr_3_1.vb)]"
  syntax:
    content: public virtual bool IsReadOnly { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Collections.ArrayList&quot;></xref>只读的; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Collections.ArrayList.IsReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.ArrayList.IsSynchronized
  id: IsSynchronized
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: IsSynchronized
  nameWithType: ArrayList.IsSynchronized
  fullName: System.Collections.ArrayList.IsSynchronized
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "获取一个值，该值指示是否访问<xref href=&quot;System.Collections.ArrayList&quot;></xref>是同步的 （线程安全）。"
  remarks: "若要确保的线程安全性<xref:System.Collections.ArrayList>，所有操作必须通过返回的包装器来都完成<xref:System.Collections.ArrayList.Synchronized%2A>方法。</xref:System.Collections.ArrayList.Synchronized%2A> </xref:System.Collections.ArrayList>       枚举整个集合本质上不是一个线程安全的过程。 即使某个集合已同步，其他线程仍可以修改集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改导致的异常。"
  example:
  - "The following code example shows how to lock the collection using the <xref:System.Collections.ArrayList.SyncRoot%2A> during the entire enumeration.  \n  \n [!code-cpp[Classic ArrayList.IsSynchronized Example#2](~/add/codesnippet/cpp/p-system.collections.arr_0_1.cpp)]\n [!code-vb[Classic ArrayList.IsSynchronized Example#2](~/add/codesnippet/visualbasic/p-system.collections.arr_0_1.vb)]\n [!code-cs[Classic ArrayList.IsSynchronized Example#2](~/add/codesnippet/csharp/p-system.collections.arr_0_1.cs)]  \n  \n Retrieving the value of this property is an O(1) operation.  \n  \n The following code example shows how to synchronize an <xref:System.Collections.ArrayList>, determine if an <xref:System.Collections.ArrayList> is synchronized and use a synchronized <xref:System.Collections.ArrayList>.  \n  \n [!code-vb[Classic ArrayList.IsSynchronized Example#1](~/add/codesnippet/visualbasic/p-system.collections.arr_0_2.vb)]\n [!code-cpp[Classic ArrayList.IsSynchronized Example#1](~/add/codesnippet/cpp/p-system.collections.arr_0_2.cpp)]\n [!code-cs[Classic ArrayList.IsSynchronized Example#1](~/add/codesnippet/csharp/p-system.collections.arr_0_2.cs)]"
  syntax:
    content: public virtual bool IsSynchronized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果访问<xref href=&quot;System.Collections.ArrayList&quot;></xref>是同步的 （线程安全）; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Collections.ArrayList.IsSynchronized*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.ArrayList.Item(System.Int32)
  id: Item(System.Int32)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: Item(Int32)
  nameWithType: ArrayList.Item(Int32)
  fullName: System.Collections.ArrayList.Item(Int32)
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "获取或设置指定索引处的元素。"
  remarks: "项目返回的<xref:System.Object>，因此你可能需要强制转换为原始类型以便操作它。 返回的值</xref:System.Object> 务必请注意，<xref:System.Collections.ArrayList>不是强类型集合。</xref:System.Collections.ArrayList> 强类型的替代项，请参阅<xref:System.Collections.Generic.List%601>。</xref:System.Collections.Generic.List%601>       <xref:System.Collections.ArrayList>接受`null`作为有效的值，并允许重复的元素。</xref:System.Collections.ArrayList>       此属性提供能够通过使用以下语法访问集合中的特定元素︰ `myCollection[index]`。       C# 语言使用关键字来定义而不是实现项属性的索引器。 Visual Basic 实现为默认属性，它提供相同的索引功能的项。       检索此属性的值的运算 o （1）;设置属性也是 o （1） 运算。"
  example:
  - "The following code example creates an <xref:System.Collections.ArrayList> and adds several items. The example demonstrates accessing elements with the Item property (the indexer in C#), and changing an element by assigning a new value to the Item property for a specified index. The example also shows that the Item property cannot be used to access or add elements outside the current size of the list.  \n  \n [!code-cpp[System.Collections.ArrayList.Item#1](~/add/codesnippet/cpp/p-system.collections.arr_1_1.cpp)]\n [!code-cs[System.Collections.ArrayList.Item#1](~/add/codesnippet/csharp/p-system.collections.arr_1_1.cs)]\n [!code-vb[System.Collections.ArrayList.Item#1](~/add/codesnippet/visualbasic/p-system.collections.arr_1_1.vb)]  \n  \n The following example uses the Item property explicitly to assign values to items in the list. The example defines a class that inherits an <xref:System.Collections.ArrayList> and adds a method to scramble the list items.  \n  \n [!code-cpp[System.Collections.ArrayList.Item#2](~/add/codesnippet/cpp/p-system.collections.arr_1_2.cpp)]\n [!code-vb[System.Collections.ArrayList.Item#2](~/add/codesnippet/visualbasic/p-system.collections.arr_1_2.vb)]\n [!code-cs[System.Collections.ArrayList.Item#2](~/add/codesnippet/csharp/p-system.collections.arr_1_2.cs)]"
  syntax:
    content: public virtual object this[int index] { get; set; }
    parameters:
    - id: index
      type: System.Int32
      description: "要获取或设置元素的从零开始索引。"
    return:
      type: System.Object
      description: "指定索引处的元素。"
  overload: System.Collections.ArrayList.Item*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>小于零。       -<code>index</code>等于或大于<xref:System.Collections.ArrayList.Count*>。"
  platform:
  - net462
- uid: System.Collections.ArrayList.LastIndexOf(System.Object)
  id: LastIndexOf(System.Object)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: LastIndexOf(Object)
  nameWithType: ArrayList.LastIndexOf(Object)
  fullName: System.Collections.ArrayList.LastIndexOf(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "搜索指定<xref:System.Object>并返回在整个的最后一个匹配项的从零开始索引<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。</xref:System.Object>"
  remarks: "<xref:System.Collections.ArrayList>向后搜索的最后一个元素开始，在第一个元素结束。</xref:System.Collections.ArrayList>       此方法执行的线性搜索;因此，此方法为 O (`n`) 操作，其中`n`为<xref:System.Collections.ArrayList.Count%2A>。</xref:System.Collections.ArrayList.Count%2A>       从.NET Framework 2.0 开始，此方法使用集合的对象<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`以确定是否存在项。</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> 在.NET Framework 的早期版本，通过进行此决定<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`参数的集合中的对象。</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  example:
  - "The following code example shows how to determine the index of the last occurrence of a specified element.  \n  \n [!code-cpp[Classic ArrayList.LastIndexOf Example#1](~/add/codesnippet/cpp/m-system.collections.arr_14_1.cpp)]\n [!code-cs[Classic ArrayList.LastIndexOf Example#1](~/add/codesnippet/csharp/m-system.collections.arr_14_1.cs)]\n [!code-vb[Classic ArrayList.LastIndexOf Example#1](~/add/codesnippet/visualbasic/m-system.collections.arr_14_1.vb)]"
  syntax:
    content: public virtual int LastIndexOf (object value);
    parameters:
    - id: value
      type: System.Object
      description: "<xref:System.Object>要在中查找<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。</xref:System.Object> 该值可以为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.Int32
      description: "最后一个匹配项的从零开始索引<code> value </code>在整个<xref href=&quot;System.Collections.ArrayList&quot;> </xref>，如果找到; 否则为-1。"
  overload: System.Collections.ArrayList.LastIndexOf*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)
  id: LastIndexOf(System.Object,System.Int32)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: LastIndexOf(Object,Int32)
  nameWithType: ArrayList.LastIndexOf(Object,Int32)
  fullName: System.Collections.ArrayList.LastIndexOf(Object,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "搜索指定<xref:System.Object>并返回中的元素范围内最后一个匹配项的从零开始索引<xref href=&quot;System.Collections.ArrayList&quot;> </xref> ，扩展的第一个元素到指定的索引。</xref:System.Object>"
  remarks: "<xref:System.Collections.ArrayList>是搜索向后开始`startIndex`和结束的第一个元素。</xref:System.Collections.ArrayList>       此方法执行的线性搜索;因此，此方法为 O (`n`) 操作，其中`n`是从开始处的元素数目<xref:System.Collections.ArrayList>到`startIndex`。</xref:System.Collections.ArrayList>       此方法通过调用<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>确定相等性       从.NET Framework 2.0 开始，此方法使用集合的对象<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`以确定是否存在项。</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> 在.NET Framework 的早期版本，通过进行此决定<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`参数的集合中的对象。</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  example:
  - "The following code example shows how to determine the index of the last occurrence of a specified element.  \n  \n [!code-cpp[Classic ArrayList.LastIndexOf Example#1](~/add/codesnippet/cpp/m-system.collections.arr_26_1.cpp)]\n [!code-cs[Classic ArrayList.LastIndexOf Example#1](~/add/codesnippet/csharp/m-system.collections.arr_26_1.cs)]\n [!code-vb[Classic ArrayList.LastIndexOf Example#1](~/add/codesnippet/visualbasic/m-system.collections.arr_26_1.vb)]"
  syntax:
    content: public virtual int LastIndexOf (object value, int startIndex);
    parameters:
    - id: value
      type: System.Object
      description: "<xref:System.Object>要在中查找<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。</xref:System.Object> 该值可以为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
    - id: startIndex
      type: System.Int32
      description: "向后搜索的从零开始的起始索引。"
    return:
      type: System.Int32
      description: "最后一个匹配项的从零开始索引<code> value </code>中的元素范围内<xref href=&quot;System.Collections.ArrayList&quot;></xref>扩展从第一个元素到<code> startIndex </code>，如果找到; 否则为-1。"
  overload: System.Collections.ArrayList.LastIndexOf*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>startIndex</code>超出的有效索引范围<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  platform:
  - net462
- uid: System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)
  id: LastIndexOf(System.Object,System.Int32,System.Int32)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: LastIndexOf(Object,Int32,Int32)
  nameWithType: ArrayList.LastIndexOf(Object,Int32,Int32)
  fullName: System.Collections.ArrayList.LastIndexOf(Object,Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "搜索指定<xref:System.Object>并返回中的元素范围内最后一个匹配项的从零开始索引<xref href=&quot;System.Collections.ArrayList&quot;> </xref> ，其中包含指定的数量的元素以指定的索引位置结尾。</xref:System.Object>"
  remarks: "<xref:System.Collections.ArrayList>是搜索向后开始`startIndex`结束`startIndex`减`count`加上 1，如果`count`大于 0。</xref:System.Collections.ArrayList>       此方法执行的线性搜索;因此，此方法为 O (`n`) 操作，其中`n`是`count`。       此方法通过调用<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>确定相等性       从.NET Framework 2.0 开始，此方法使用集合的对象<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`以确定是否存在项。</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> 在.NET Framework 的早期版本，通过进行此决定<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`参数的集合中的对象。</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  example:
  - "The following code example shows how to determine the index of the last occurrence of a specified element. Note that `LastIndexOf` is a backward search; therefore, `count` must be less than or equal to `startIndex` + 1.  \n  \n [!code-cpp[Classic ArrayList.LastIndexOf Example#1](~/add/codesnippet/cpp/62fe9219-7086-43ad-b565-_1.cpp)]\n [!code-cs[Classic ArrayList.LastIndexOf Example#1](~/add/codesnippet/csharp/62fe9219-7086-43ad-b565-_1.cs)]\n [!code-vb[Classic ArrayList.LastIndexOf Example#1](~/add/codesnippet/visualbasic/62fe9219-7086-43ad-b565-_1.vb)]"
  syntax:
    content: public virtual int LastIndexOf (object value, int startIndex, int count);
    parameters:
    - id: value
      type: System.Object
      description: "<xref:System.Object>要在中查找<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。</xref:System.Object> 该值可以为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
    - id: startIndex
      type: System.Int32
      description: "向后搜索的从零开始的起始索引。"
    - id: count
      type: System.Int32
      description: "要搜索的部分中的元素数。"
    return:
      type: System.Int32
      description: "最后一个匹配项的从零开始索引<code> value </code>中的元素范围内<xref href=&quot;System.Collections.ArrayList&quot;></xref>包含<code> count </code>元素在为止的<code> startIndex </code>，如果找到; 否则为-1。"
  overload: System.Collections.ArrayList.LastIndexOf*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>startIndex</code>超出的有效索引范围<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。       -或-<code>count</code>小于零。       -<code>startIndex</code>和<code>count</code>未指定有效部分中的<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  platform:
  - net462
- uid: System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)
  id: ReadOnly(System.Collections.ArrayList)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: ReadOnly(ArrayList)
  nameWithType: ArrayList.ReadOnly(ArrayList)
  fullName: System.Collections.ArrayList.ReadOnly(ArrayList)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "返回只读的<xref href=&quot;System.Collections.ArrayList&quot;></xref>包装器。"
  remarks: "若要防止对`list`，公开`list`只通过此包装器。       是只读的集合是只需使用的包装器可防止修改集合的集合。 如果对基础集合进行更改，只读集合将反映这些更改。       此方法为 o （1） 运算。"
  example:
  - "The following code example shows how to create a read-only wrapper around an <xref:System.Collections.ArrayList> and how to determine if an <xref:System.Collections.ArrayList> is read-only.  \n  \n [!code-cs[Classic ArrayList.ReadOnly1 Example#1](~/add/codesnippet/csharp/m-system.collections.arr_9_1.cs)]\n [!code-cpp[Classic ArrayList.ReadOnly1 Example#1](~/add/codesnippet/cpp/m-system.collections.arr_9_1.cpp)]\n [!code-vb[Classic ArrayList.ReadOnly1 Example#1](~/add/codesnippet/visualbasic/m-system.collections.arr_9_1.vb)]"
  syntax:
    content: public static System.Collections.ArrayList ReadOnly (System.Collections.ArrayList list);
    parameters:
    - id: list
      type: System.Collections.ArrayList
      description: "<xref href=&quot;System.Collections.ArrayList&quot;> </xref>包装。"
    return:
      type: System.Collections.ArrayList
      description: "只读<xref href=&quot;System.Collections.ArrayList&quot;></xref>周围包装<code> list </code>。"
  overload: System.Collections.ArrayList.ReadOnly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>list</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.ArrayList.ReadOnly(System.Collections.IList)
  id: ReadOnly(System.Collections.IList)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: ReadOnly(IList)
  nameWithType: ArrayList.ReadOnly(IList)
  fullName: System.Collections.ArrayList.ReadOnly(IList)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "返回只读的<xref:System.Collections.IList>包装。</xref:System.Collections.IList>"
  remarks: "若要防止对`list`，公开`list`只通过此包装器。       是只读的集合是只需使用的包装器可防止修改集合的集合。 如果对基础集合进行更改，只读集合将反映这些更改。       此方法为 o （1） 运算。"
  syntax:
    content: public static System.Collections.IList ReadOnly (System.Collections.IList list);
    parameters:
    - id: list
      type: System.Collections.IList
      description: "<xref:System.Collections.IList>包装。</xref:System.Collections.IList>"
    return:
      type: System.Collections.IList
      description: "只读<xref:System.Collections.IList>周围包装<code> list </code>。</xref:System.Collections.IList>"
  overload: System.Collections.ArrayList.ReadOnly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>list</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.ArrayList.Remove(System.Object)
  id: Remove(System.Object)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: Remove(Object)
  nameWithType: ArrayList.Remove(Object)
  fullName: System.Collections.ArrayList.Remove(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "移除中的特定对象的第一个匹配项<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  remarks: "如果<xref:System.Collections.ArrayList>不包含指定的对象，<xref:System.Collections.ArrayList>保持不变。</xref:System.Collections.ArrayList> </xref:System.Collections.ArrayList> 不引发异常。       此方法执行的线性搜索;因此，此方法为 O (`n`) 操作，其中`n`为<xref:System.Collections.ArrayList.Count%2A>。</xref:System.Collections.ArrayList.Count%2A>       此方法通过调用<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>确定相等性       在由连续的元素，如列表，集合中移除的元素下面的元素的元素将上移以占据空出的位置。 如果集合具有索引，则移动的元素的索引也将更新。 此行为不适用于元素按概念划分为不同存储桶，如哈希表的集合。"
  example:
  - "The following code example shows how to remove elements from the <xref:System.Collections.ArrayList>.  \n  \n [!code-cpp[Classic ArrayList.Remove Example#1](~/add/codesnippet/cpp/m-system.collections.arr_5_1.cpp)]\n [!code-vb[Classic ArrayList.Remove Example#1](~/add/codesnippet/visualbasic/m-system.collections.arr_5_1.vb)]\n [!code-cs[Classic ArrayList.Remove Example#1](~/add/codesnippet/csharp/m-system.collections.arr_5_1.cs)]"
  syntax:
    content: public virtual void Remove (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "<xref:System.Object>要从此<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。</xref:System.Object> 该值可以为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Collections.ArrayList.Remove*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.ArrayList&quot;> </xref>是只读的。       -或- <xref href=&quot;System.Collections.ArrayList&quot;> </xref>具有固定的大小。"
  platform:
  - net462
- uid: System.Collections.ArrayList.RemoveAt(System.Int32)
  id: RemoveAt(System.Int32)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: RemoveAt(Int32)
  nameWithType: ArrayList.RemoveAt(Int32)
  fullName: System.Collections.ArrayList.RemoveAt(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "移除的指定索引处的元素<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  remarks: "移除元素后，调整集合的大小和的值<xref:System.Collections.ArrayList.Count%2A>属性减少&1;。</xref:System.Collections.ArrayList.Count%2A>       在由连续的元素，如列表，集合中移除的元素下面的元素的元素将上移以占据空出的位置。 如果集合具有索引，则移动的元素的索引也将更新。 此行为不适用于元素按概念划分为不同存储桶，如哈希表的集合。       此方法为 O (`n`) 操作，其中`n`为<xref:System.Collections.ArrayList.Count%2A>。</xref:System.Collections.ArrayList.Count%2A>"
  example:
  - "The following code example shows how to remove elements from the <xref:System.Collections.ArrayList>.  \n  \n [!code-cpp[Classic ArrayList.Remove Example#1](~/add/codesnippet/cpp/m-system.collections.arr_24_1.cpp)]\n [!code-vb[Classic ArrayList.Remove Example#1](~/add/codesnippet/visualbasic/m-system.collections.arr_24_1.vb)]\n [!code-cs[Classic ArrayList.Remove Example#1](~/add/codesnippet/csharp/m-system.collections.arr_24_1.cs)]"
  syntax:
    content: public virtual void RemoveAt (int index);
    parameters:
    - id: index
      type: System.Int32
      description: "要移除的元素的从零开始的索引。"
  overload: System.Collections.ArrayList.RemoveAt*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>小于零。       -<code>index</code>等于或大于<xref:System.Collections.ArrayList.Count*>。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.ArrayList&quot;> </xref>是只读的。       -或- <xref href=&quot;System.Collections.ArrayList&quot;> </xref>具有固定的大小。"
  platform:
  - net462
- uid: System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)
  id: RemoveRange(System.Int32,System.Int32)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: RemoveRange(Int32,Int32)
  nameWithType: ArrayList.RemoveRange(Int32,Int32)
  fullName: System.Collections.ArrayList.RemoveRange(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "中移除的元素从一系列<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  remarks: "在由连续的元素，如列表，集合中移除的元素下面的元素的元素将上移以占据空出的位置。 如果集合具有索引，则移动的元素的索引也将更新。 此行为不适用于元素按概念划分为不同存储桶，如哈希表的集合。       此方法为 O (`n`) 操作，其中`n`为<xref:System.Collections.ArrayList.Count%2A>。</xref:System.Collections.ArrayList.Count%2A>"
  example:
  - "The following code example shows how to remove elements from the <xref:System.Collections.ArrayList>.  \n  \n [!code-cpp[Classic ArrayList.Remove Example#1](~/add/codesnippet/cpp/m-system.collections.arr_21_1.cpp)]\n [!code-vb[Classic ArrayList.Remove Example#1](~/add/codesnippet/visualbasic/m-system.collections.arr_21_1.vb)]\n [!code-cs[Classic ArrayList.Remove Example#1](~/add/codesnippet/csharp/m-system.collections.arr_21_1.cs)]"
  syntax:
    content: public virtual void RemoveRange (int index, int count);
    parameters:
    - id: index
      type: System.Int32
      description: "要移除的元素范围的从零开始的起始索引。"
    - id: count
      type: System.Int32
      description: "要移除的元素数。"
  overload: System.Collections.ArrayList.RemoveRange*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>小于零。       -或-<code>count</code>小于零。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>index</code>和<code>count</code>不表示有效的一系列元素中<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.ArrayList&quot;> </xref>是只读的。       -或- <xref href=&quot;System.Collections.ArrayList&quot;> </xref>具有固定的大小。"
  platform:
  - net462
- uid: System.Collections.ArrayList.Repeat(System.Object,System.Int32)
  id: Repeat(System.Object,System.Int32)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: Repeat(Object,Int32)
  nameWithType: ArrayList.Repeat(Object,Int32)
  fullName: System.Collections.ArrayList.Repeat(Object,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "返回<xref href=&quot;System.Collections.ArrayList&quot;></xref>其元素是指定的值的副本。"
  remarks: "<xref:System.Collections.ArrayList>接受`null`作为有效的值，并允许重复的元素。</xref:System.Collections.ArrayList>       此方法为 O (`n`) 操作，其中`n`是`count`。"
  example:
  - "The following code example shows how to create and initialize a new <xref:System.Collections.ArrayList> with the same value.  \n  \n [!code-cpp[Classic ArrayList.Repeat Example#1](~/add/codesnippet/cpp/m-system.collections.arr_1_1.cpp)]\n [!code-cs[Classic ArrayList.Repeat Example#1](~/add/codesnippet/csharp/m-system.collections.arr_1_1.cs)]\n [!code-vb[Classic ArrayList.Repeat Example#1](~/add/codesnippet/visualbasic/m-system.collections.arr_1_1.vb)]"
  syntax:
    content: public static System.Collections.ArrayList Repeat (object value, int count);
    parameters:
    - id: value
      type: System.Object
      description: "<xref:System.Object>，多次将中复制新<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。</xref:System.Object> 该值可以为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
    - id: count
      type: System.Int32
      description: "次数`value`应复制。"
    return:
      type: System.Collections.ArrayList
      description: "<xref href=&quot;System.Collections.ArrayList&quot;> </xref>与<code> count </code>个元素，这些全部都是份<code> value </code>。"
  overload: System.Collections.ArrayList.Repeat*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>count</code>小于零。"
  platform:
  - net462
- uid: System.Collections.ArrayList.Reverse
  id: Reverse
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: Reverse()
  nameWithType: ArrayList.Reverse()
  fullName: System.Collections.ArrayList.Reverse()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "整个中的元素的顺序反转<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  remarks: "此方法使用<xref:System.Array.Reverse%2A?displayProperty=fullName>若要反转的元素的顺序以便处的元素<xref:System.Collections.ArrayList>[i] 其中 i 表示的范围内的任何索引移动到<xref:System.Collections.ArrayList>[j] 其中 j 等于`index`  +  `index`  +  `count` -i-1。</xref:System.Collections.ArrayList> </xref:System.Collections.ArrayList> </xref:System.Array.Reverse%2A?displayProperty=fullName>       此方法为 O (`n`) 操作，其中`n`为<xref:System.Collections.ArrayList.Count%2A>。</xref:System.Collections.ArrayList.Count%2A>"
  example:
  - "The following code example shows how to reverse the sort order of the values in an <xref:System.Collections.ArrayList>.  \n  \n [!code-cs[Classic ArrayList.Reverse Example#1](~/add/codesnippet/csharp/m-system.collections.arr_20_1.cs)]\n [!code-cpp[Classic ArrayList.Reverse Example#1](~/add/codesnippet/cpp/m-system.collections.arr_20_1.cpp)]\n [!code-vb[Classic ArrayList.Reverse Example#1](~/add/codesnippet/visualbasic/m-system.collections.arr_20_1.vb)]"
  syntax:
    content: public virtual void Reverse ();
    parameters: []
  overload: System.Collections.ArrayList.Reverse*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.ArrayList&quot;> </xref>是只读的。"
  platform:
  - net462
- uid: System.Collections.ArrayList.Reverse(System.Int32,System.Int32)
  id: Reverse(System.Int32,System.Int32)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: Reverse(Int32,Int32)
  nameWithType: ArrayList.Reverse(Int32,Int32)
  fullName: System.Collections.ArrayList.Reverse(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "指定范围中的元素的顺序反转。"
  remarks: "此方法使用<xref:System.Array.Reverse%2A?displayProperty=fullName>若要反转的元素的顺序以便处的元素<xref:System.Collections.ArrayList>[i] 其中 i 表示的范围内的任何索引移动到<xref:System.Collections.ArrayList>[j] 其中 j 等于`index`  +  `index`  +  `count` -i-1。</xref:System.Collections.ArrayList> </xref:System.Collections.ArrayList> </xref:System.Array.Reverse%2A?displayProperty=fullName>       此方法为 O (`n`) 操作，其中`n`是`count`。"
  example:
  - "The following code example shows how to reverse the sort order of the values in a range of elements in an <xref:System.Collections.ArrayList>.  \n  \n [!code-cpp[Classic ArrayList.Reverse1 Example#1](~/add/codesnippet/cpp/m-system.collections.arr_3_1.cpp)]\n [!code-cs[Classic ArrayList.Reverse1 Example#1](~/add/codesnippet/csharp/m-system.collections.arr_3_1.cs)]\n [!code-vb[Classic ArrayList.Reverse1 Example#1](~/add/codesnippet/visualbasic/m-system.collections.arr_3_1.vb)]"
  syntax:
    content: public virtual void Reverse (int index, int count);
    parameters:
    - id: index
      type: System.Int32
      description: "要反转的范围的从零开始的起始索引。"
    - id: count
      type: System.Int32
      description: "要反转的范围中的元素数。"
  overload: System.Collections.ArrayList.Reverse*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>小于零。       -或-<code>count</code>小于零。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>index</code>和<code>count</code>不表示有效的一系列元素中<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.ArrayList&quot;> </xref>是只读的。"
  platform:
  - net462
- uid: System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)
  id: SetRange(System.Int32,System.Collections.ICollection)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: SetRange(Int32,ICollection)
  nameWithType: ArrayList.SetRange(Int32,ICollection)
  fullName: System.Collections.ArrayList.SetRange(Int32,ICollection)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "集合的元素复制中的元素范围内<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  remarks: "<xref:System.Collections.ArrayList>接受`null`作为有效的值，并允许重复的元素。</xref:System.Collections.ArrayList>       中<xref:System.Collections.ICollection>保留在<xref:System.Collections.ArrayList>.</xref:System.Collections.ArrayList></xref:System.Collections.ICollection>元素的顺序       此方法为 O (`n` + 1) 操作，其中`n`为<xref:System.Collections.ArrayList.Count%2A>。</xref:System.Collections.ArrayList.Count%2A>"
  example:
  - "The following code example shows how to set and get a range of elements in the <xref:System.Collections.ArrayList>.  \n  \n [!code-cs[Classic ArrayList.SetRange Example#1](~/add/codesnippet/csharp/23e2a8fa-8e09-46ee-8256-_1.cs)]\n [!code-cpp[Classic ArrayList.SetRange Example#1](~/add/codesnippet/cpp/23e2a8fa-8e09-46ee-8256-_1.cpp)]\n [!code-vb[Classic ArrayList.SetRange Example#1](~/add/codesnippet/visualbasic/23e2a8fa-8e09-46ee-8256-_1.vb)]"
  syntax:
    content: public virtual void SetRange (int index, System.Collections.ICollection c);
    parameters:
    - id: index
      type: System.Int32
      description: "从零开始<xref href=&quot;System.Collections.ArrayList&quot;></xref>的索引，将开始复制的元素`c`。"
    - id: c
      type: System.Collections.ICollection
      description: "<xref:System.Collections.ICollection>其元素将复制到<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。</xref:System.Collections.ICollection> 集合自身不能为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，但它可以包含的元素<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Collections.ArrayList.SetRange*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>小于零。       - <code>index</code> plus 中的元素数<code>c</code>大于<xref:System.Collections.ArrayList.Count*>。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>c</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.ArrayList&quot;> </xref>是只读的。"
  platform:
  - net462
- uid: System.Collections.ArrayList.Sort
  id: Sort
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: Sort()
  nameWithType: ArrayList.Sort()
  fullName: System.Collections.ArrayList.Sort()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "在整个中的元素进行排序<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  remarks: "此方法使用<xref:System.Array.Sort%2A?displayProperty=fullName>，它使用快速排序算法。</xref:System.Array.Sort%2A?displayProperty=fullName> 快速排序算法是比较 （也称为不稳定排序），这意味着&quot;小于或等于&quot;的排序比较操作将确定这两个元素应首先出现在最后一个已排序的列表。 但是，如果两个元素相等，则可能不会保留其原始顺序。 与此相反，一个稳定排序保留相等的元素的顺序。 若要执行一个稳定排序，则必须实现一个自定义<xref:System.Collections.IComparer>接口若要使用此方法的其他重载。</xref:System.Collections.IComparer>       一般情况下，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>; 在最坏情况下它复杂度为 O (`n`^2) 操作。</xref:System.Collections.ArrayList.Count%2A>"
  example:
  - "The following code example shows how to sort the values in an <xref:System.Collections.ArrayList>.  \n  \n [!code-cs[Classic ArrayList.Sort Example#1](~/add/codesnippet/csharp/m-system.collections.arr_11_1.cs)]\n [!code-vb[Classic ArrayList.Sort Example#1](~/add/codesnippet/visualbasic/m-system.collections.arr_11_1.vb)]\n [!code-cpp[Classic ArrayList.Sort Example#1](~/add/codesnippet/cpp/m-system.collections.arr_11_1.cpp)]"
  syntax:
    content: public virtual void Sort ();
    parameters: []
  overload: System.Collections.ArrayList.Sort*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.ArrayList&quot;> </xref>是只读的。"
  platform:
  - net462
- uid: System.Collections.ArrayList.Sort(System.Collections.IComparer)
  id: Sort(System.Collections.IComparer)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: Sort(IComparer)
  nameWithType: ArrayList.Sort(IComparer)
  fullName: System.Collections.ArrayList.Sort(IComparer)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "在整个中的元素进行排序<xref href=&quot;System.Collections.ArrayList&quot;></xref>使用指定的比较器。"
  remarks: "使用排序方法的对象的列表进行排序的自定义比较器实现与<xref:System.Collections.IComparer>接口。</xref:System.Collections.IComparer> 如果你通过`null`为`comparer`，此方法使用<xref:System.IComparable>每个元素的实现。</xref:System.IComparable> 在这种情况下，你必须确保列表中包含的对象实现<xref:System.Collections.IComparer>接口或异常会发生。</xref:System.Collections.IComparer>       此外，使用<xref:System.IComparable>实现意味着此列表将执行比较排序 （也称为不稳定排序）; 即，如果两个元素相等，其顺序可能不会保留。</xref:System.IComparable> 与此相反，一个稳定排序保留相等的元素的顺序。 若要执行一个稳定排序，则必须实现一个自定义<xref:System.Collections.IComparer>接口。</xref:System.Collections.IComparer>       一般情况下，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>; 在最坏情况下它复杂度为 O (`n`^2) 操作。</xref:System.Collections.ArrayList.Count%2A>"
  example:
  - "The following code example shows how to sort the values in an <xref:System.Collections.ArrayList> using the default comparer and a custom comparer that reverses the sort order.  \n  \n [!code-cpp[System.Collections.ArrayList.Sort_2#1](~/add/codesnippet/cpp/m-system.collections.arr_16_1.cpp)]\n [!code-cs[System.Collections.ArrayList.Sort_2#1](~/add/codesnippet/csharp/m-system.collections.arr_16_1.cs)]\n [!code-vb[System.Collections.ArrayList.Sort_2#1](~/add/codesnippet/visualbasic/m-system.collections.arr_16_1.vb)]"
  syntax:
    content: public virtual void Sort (System.Collections.IComparer comparer);
    parameters:
    - id: comparer
      type: System.Collections.IComparer
      description: "<xref:System.Collections.IComparer>比较元素时要使用的实现。</xref:System.Collections.IComparer>       -空引用 (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref>在 Visual Basic 中) 使用<xref:System.IComparable>每个元素的实现。</xref:System.IComparable>"
  overload: System.Collections.ArrayList.Sort*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.ArrayList&quot;> </xref>是只读的。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "比较两个元素时出错。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>为传递<code> comparer </code>，并且列表中的元素不实现<xref:System.IComparable>.</xref:System.IComparable>"
  platform:
  - net462
- uid: System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)
  id: Sort(System.Int32,System.Int32,System.Collections.IComparer)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: Sort(Int32,Int32,IComparer)
  nameWithType: ArrayList.Sort(Int32,Int32,IComparer)
  fullName: System.Collections.ArrayList.Sort(Int32,Int32,IComparer)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "中的元素范围中的元素进行排序<xref href=&quot;System.Collections.ArrayList&quot;></xref>使用指定的比较器。"
  remarks: "如果`comparer`设置为`null`，此方法将执行比较排序 （也称为不稳定排序）; 即，如果两个元素相等，其顺序可能不会保留。 与此相反，一个稳定排序保留相等的元素的顺序。 若要执行一个稳定排序，则必须实现一个自定义<xref:System.Collections.IComparer>接口。</xref:System.Collections.IComparer>       一般情况下，此方法为 O (`n`日志`n`) 操作，其中`n`是`count`; 在最坏情况下此操作是 O(n^2) 操作。"
  example:
  - "The following code example shows how to sort the values in a range of elements in an <xref:System.Collections.ArrayList> using the default comparer and a custom comparer that reverses the sort order.  \n  \n [!code-cpp[System.Collections.ArrayList.Sort_3#1](~/add/codesnippet/cpp/b0a7df76-2f5d-45d4-bb7a-_1.cpp)]\n [!code-cs[System.Collections.ArrayList.Sort_3#1](~/add/codesnippet/csharp/b0a7df76-2f5d-45d4-bb7a-_1.cs)]\n [!code-vb[System.Collections.ArrayList.Sort_3#1](~/add/codesnippet/visualbasic/b0a7df76-2f5d-45d4-bb7a-_1.vb)]"
  syntax:
    content: public virtual void Sort (int index, int count, System.Collections.IComparer comparer);
    parameters:
    - id: index
      type: System.Int32
      description: "要排序的范围的从零开始的起始索引。"
    - id: count
      type: System.Int32
      description: "要排序的范围的长度。"
    - id: comparer
      type: System.Collections.IComparer
      description: "<xref:System.Collections.IComparer>比较元素时要使用的实现。</xref:System.Collections.IComparer>       -空引用 (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref>在 Visual Basic 中) 使用<xref:System.IComparable>每个元素的实现。</xref:System.IComparable>"
  overload: System.Collections.ArrayList.Sort*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>小于零。       -或-<code>count</code>小于零。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>index</code>和<code>count</code>未指定中的有效范围<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.ArrayList&quot;> </xref>是只读的。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "比较两个元素时出错。"
  platform:
  - net462
- uid: System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)
  id: Synchronized(System.Collections.ArrayList)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: Synchronized(ArrayList)
  nameWithType: ArrayList.Synchronized(ArrayList)
  fullName: System.Collections.ArrayList.Synchronized(ArrayList)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "返回<xref href=&quot;System.Collections.ArrayList&quot;></xref>同步 （线程安全） 的包装。"
  remarks: "若要确保的线程安全性<xref:System.Collections.ArrayList>，必须通过此包装器完成所有操作。</xref:System.Collections.ArrayList>       枚举整个集合本质上不是一个线程安全的过程。 即使某个集合已同步，其他线程仍可以修改集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改导致的异常。"
  example:
  - "The following code example shows how to lock the collection using the <xref:System.Collections.ArrayList.SyncRoot%2A> during the entire enumeration.  \n  \n [!code-cpp[Classic ArrayList.IsSynchronized Example#2](~/add/codesnippet/cpp/m-system.collections.arr_25_1.cpp)]\n [!code-vb[Classic ArrayList.IsSynchronized Example#2](~/add/codesnippet/visualbasic/m-system.collections.arr_25_1.vb)]\n [!code-cs[Classic ArrayList.IsSynchronized Example#2](~/add/codesnippet/csharp/m-system.collections.arr_25_1.cs)]  \n  \n This method is an O(1) operation.  \n  \n The following code example shows how to synchronize an <xref:System.Collections.ArrayList>, determine if an <xref:System.Collections.ArrayList> is synchronized and use a synchronized <xref:System.Collections.ArrayList>.  \n  \n [!code-vb[Classic ArrayList.IsSynchronized Example#1](~/add/codesnippet/visualbasic/m-system.collections.arr_25_2.vb)]\n [!code-cpp[Classic ArrayList.IsSynchronized Example#1](~/add/codesnippet/cpp/m-system.collections.arr_25_2.cpp)]\n [!code-cs[Classic ArrayList.IsSynchronized Example#1](~/add/codesnippet/csharp/m-system.collections.arr_25_2.cs)]"
  syntax:
    content: public static System.Collections.ArrayList Synchronized (System.Collections.ArrayList list);
    parameters:
    - id: list
      type: System.Collections.ArrayList
      description: "<xref href=&quot;System.Collections.ArrayList&quot;> </xref>进行同步。"
    return:
      type: System.Collections.ArrayList
      description: "<xref href=&quot;System.Collections.ArrayList&quot;> </xref>同步 （线程安全） 的包装。"
  overload: System.Collections.ArrayList.Synchronized*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>list</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.ArrayList.Synchronized(System.Collections.IList)
  id: Synchronized(System.Collections.IList)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: Synchronized(IList)
  nameWithType: ArrayList.Synchronized(IList)
  fullName: System.Collections.ArrayList.Synchronized(IList)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "返回<xref:System.Collections.IList>同步 （线程安全） 的包装。</xref:System.Collections.IList>"
  remarks: "若要确保的线程安全性<xref:System.Collections.ArrayList>，必须通过此包装器完成所有操作。</xref:System.Collections.ArrayList>       枚举整个集合本质上不是一个线程安全的过程。 即使某个集合已同步，其他线程仍可以修改集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改导致的异常。"
  example:
  - "The following code example shows how to lock the collection using the <xref:System.Collections.ArrayList.SyncRoot%2A> during the entire enumeration.  \n  \n [!code-cpp[Classic ArrayList.IsSynchronized Example#2](~/add/codesnippet/cpp/m-system.collections.arr_23_1.cpp)]\n [!code-vb[Classic ArrayList.IsSynchronized Example#2](~/add/codesnippet/visualbasic/m-system.collections.arr_23_1.vb)]\n [!code-cs[Classic ArrayList.IsSynchronized Example#2](~/add/codesnippet/csharp/m-system.collections.arr_23_1.cs)]  \n  \n This method is an O(1) operation."
  syntax:
    content: public static System.Collections.IList Synchronized (System.Collections.IList list);
    parameters:
    - id: list
      type: System.Collections.IList
      description: "<xref:System.Collections.IList>进行同步。</xref:System.Collections.IList>"
    return:
      type: System.Collections.IList
      description: "<xref:System.Collections.IList>同步 （线程安全） 的包装。</xref:System.Collections.IList>"
  overload: System.Collections.ArrayList.Synchronized*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>list</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.ArrayList.SyncRoot
  id: SyncRoot
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: SyncRoot
  nameWithType: ArrayList.SyncRoot
  fullName: System.Collections.ArrayList.SyncRoot
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "获取可以用于对访问进行同步的对象<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  remarks: "若要创建的同步的版本<xref:System.Collections.ArrayList>，使用<xref:System.Collections.ArrayList.Synchronized%2A>方法。</xref:System.Collections.ArrayList.Synchronized%2A> </xref:System.Collections.ArrayList> 但是，派生的类可以提供自己的同步的版本<xref:System.Collections.ArrayList>使用 SyncRoot 属性。</xref:System.Collections.ArrayList> 同步代码必须对执行操作的 SyncRoot <xref:System.Collections.ArrayList>，不是直接对<xref:System.Collections.ArrayList>.</xref:System.Collections.ArrayList> </xref:System.Collections.ArrayList> 这可确保正确地执行操作的从其他对象派生的集合。 具体地说，这样可保持正确的同步，与可能同时对修改其他线程<xref:System.Collections.ArrayList>对象。</xref:System.Collections.ArrayList>       枚举整个集合本质上不是一个线程安全的过程。 即使某个集合已同步，其他线程仍可以修改集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改导致的异常。"
  example:
  - "The following code example shows how to lock the collection using the SyncRoot during the entire enumeration.  \n  \n [!code-cpp[Classic ArrayList.IsSynchronized Example#2](~/add/codesnippet/cpp/p-system.collections.arr_4_1.cpp)]\n [!code-vb[Classic ArrayList.IsSynchronized Example#2](~/add/codesnippet/visualbasic/p-system.collections.arr_4_1.vb)]\n [!code-cs[Classic ArrayList.IsSynchronized Example#2](~/add/codesnippet/csharp/p-system.collections.arr_4_1.cs)]  \n  \n Retrieving the value of this property is an O(1) operation."
  syntax:
    content: public virtual object SyncRoot { get; }
    return:
      type: System.Object
      description: "可以用于对访问进行同步的对象<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  overload: System.Collections.ArrayList.SyncRoot*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.ArrayList.ToArray
  id: ToArray
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: ToArray()
  nameWithType: ArrayList.ToArray()
  fullName: System.Collections.ArrayList.ToArray()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "元素复制<xref href=&quot;System.Collections.ArrayList&quot;></xref>到新<xref:System.Object>数组。</xref:System.Object>"
  remarks: "使用复制元素<xref:System.Array.Copy%2A?displayProperty=fullName>，这是 O (`n`) 操作，其中`n`为<xref:System.Collections.ArrayList.Count%2A>。</xref:System.Collections.ArrayList.Count%2A> </xref:System.Array.Copy%2A?displayProperty=fullName>"
  syntax:
    content: public virtual object[] ToArray ();
    parameters: []
    return:
      type: System.Object[]
      description: "<xref:System.Object>数组，其中包含的元素副本<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。</xref:System.Object>"
  overload: System.Collections.ArrayList.ToArray*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.ArrayList.ToArray(System.Type)
  id: ToArray(System.Type)
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: ToArray(Type)
  nameWithType: ArrayList.ToArray(Type)
  fullName: System.Collections.ArrayList.ToArray(Type)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "元素复制<xref href=&quot;System.Collections.ArrayList&quot;></xref>到新数组的指定的元素类型。"
  remarks: "中的对象的所有<xref:System.Collections.ArrayList>对象强制转换为<xref:System.Type>中指定`type`参数。</xref:System.Type> </xref:System.Collections.ArrayList>       使用复制元素<xref:System.Array.Copy%2A?displayProperty=fullName>，这是 O (`n`) 操作，其中`n`为<xref:System.Collections.ArrayList.Count%2A>。</xref:System.Collections.ArrayList.Count%2A> </xref:System.Array.Copy%2A?displayProperty=fullName>"
  example:
  - "The following copy example shows how to copy the elements of an <xref:System.Collections.ArrayList> to a string array.  \n  \n [!code-cs[System.Collections.ArrayList.ToArray#1](~/add/codesnippet/csharp/m-system.collections.arr_17_1.cs)]\n [!code-cpp[System.Collections.ArrayList.ToArray#1](~/add/codesnippet/cpp/m-system.collections.arr_17_1.cpp)]\n [!code-vb[System.Collections.ArrayList.ToArray#1](~/add/codesnippet/visualbasic/m-system.collections.arr_17_1.vb)]"
  syntax:
    content: public virtual Array ToArray (Type type);
    parameters:
    - id: type
      type: System.Type
      description: "元素<xref:System.Type>要创建并向其复制元素的目标数组。</xref:System.Type>"
    return:
      type: System.Array
      description: "包含的元素副本的指定的元素类型的数组<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  overload: System.Collections.ArrayList.ToArray*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>type</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "源类型<xref href=&quot;System.Collections.ArrayList&quot;></xref>无法自动转换为指定的类型。"
  platform:
  - net462
- uid: System.Collections.ArrayList.TrimToSize
  id: TrimToSize
  parent: System.Collections.ArrayList
  langs:
  - csharp
  name: TrimToSize()
  nameWithType: ArrayList.TrimToSize()
  fullName: System.Collections.ArrayList.TrimToSize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "将容量设置中的元素的实际数目<xref href=&quot;System.Collections.ArrayList&quot;> </xref>。"
  remarks: "此方法可以用于降低集合的内存开销，如果没有新的元素将添加到集合。       若要重置<xref:System.Collections.ArrayList>为其初始状态，请在调用<xref:System.Collections.ArrayList.Clear%2A>方法之前调用 TrimToSize。</xref:System.Collections.ArrayList.Clear%2A> </xref:System.Collections.ArrayList> 截去空<xref:System.Collections.ArrayList>的容量设置<xref:System.Collections.ArrayList>到默认的容量。</xref:System.Collections.ArrayList> </xref:System.Collections.ArrayList>       此方法为 O (`n`) 操作，其中`n`为<xref:System.Collections.ArrayList.Count%2A>。</xref:System.Collections.ArrayList.Count%2A>"
  example:
  - "The following code example shows how to trim the unused portions of the <xref:System.Collections.ArrayList> and how to clear the values of the <xref:System.Collections.ArrayList>.  \n  \n [!code-cs[Classic ArrayList.Clear Example#1](~/add/codesnippet/csharp/m-system.collections.arr_8_1.cs)]\n [!code-cpp[Classic ArrayList.Clear Example#1](~/add/codesnippet/cpp/m-system.collections.arr_8_1.cpp)]\n [!code-vb[Classic ArrayList.Clear Example#1](~/add/codesnippet/visualbasic/m-system.collections.arr_8_1.vb)]"
  syntax:
    content: public virtual void TrimToSize ();
    parameters: []
  overload: System.Collections.ArrayList.TrimToSize*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.ArrayList&quot;> </xref>是只读的。       -或- <xref href=&quot;System.Collections.ArrayList&quot;> </xref>具有固定的大小。"
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.InvalidCastException
  isExternal: true
  name: System.InvalidCastException
- uid: System.Collections.ArrayList.#ctor
  parent: System.Collections.ArrayList
  isExternal: false
  name: ArrayList()
  nameWithType: ArrayList.ArrayList()
  fullName: System.Collections.ArrayList.ArrayList()
- uid: System.Collections.ArrayList.#ctor(System.Collections.ICollection)
  parent: System.Collections.ArrayList
  isExternal: false
  name: ArrayList(ICollection)
  nameWithType: ArrayList.ArrayList(ICollection)
  fullName: System.Collections.ArrayList.ArrayList(ICollection)
- uid: System.Collections.ICollection
  parent: System.Collections
  isExternal: true
  name: ICollection
  nameWithType: ICollection
  fullName: System.Collections.ICollection
- uid: System.Collections.ArrayList.#ctor(System.Int32)
  parent: System.Collections.ArrayList
  isExternal: false
  name: ArrayList(Int32)
  nameWithType: ArrayList.ArrayList(Int32)
  fullName: System.Collections.ArrayList.ArrayList(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Collections.ArrayList.Adapter(System.Collections.IList)
  parent: System.Collections.ArrayList
  isExternal: false
  name: Adapter(IList)
  nameWithType: ArrayList.Adapter(IList)
  fullName: System.Collections.ArrayList.Adapter(IList)
- uid: System.Collections.ArrayList
  parent: System.Collections
  isExternal: false
  name: ArrayList
  nameWithType: ArrayList
  fullName: System.Collections.ArrayList
- uid: System.Collections.IList
  parent: System.Collections
  isExternal: true
  name: IList
  nameWithType: IList
  fullName: System.Collections.IList
- uid: System.Collections.ArrayList.Add(System.Object)
  parent: System.Collections.ArrayList
  isExternal: false
  name: Add(Object)
  nameWithType: ArrayList.Add(Object)
  fullName: System.Collections.ArrayList.Add(Object)
- uid: System.Collections.ArrayList.AddRange(System.Collections.ICollection)
  parent: System.Collections.ArrayList
  isExternal: false
  name: AddRange(ICollection)
  nameWithType: ArrayList.AddRange(ICollection)
  fullName: System.Collections.ArrayList.AddRange(ICollection)
- uid: System.Collections.ArrayList.BinarySearch(System.Object)
  parent: System.Collections.ArrayList
  isExternal: false
  name: BinarySearch(Object)
  nameWithType: ArrayList.BinarySearch(Object)
  fullName: System.Collections.ArrayList.BinarySearch(Object)
- uid: System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)
  parent: System.Collections.ArrayList
  isExternal: false
  name: BinarySearch(Object,IComparer)
  nameWithType: ArrayList.BinarySearch(Object,IComparer)
  fullName: System.Collections.ArrayList.BinarySearch(Object,IComparer)
- uid: System.Collections.IComparer
  parent: System.Collections
  isExternal: true
  name: IComparer
  nameWithType: IComparer
  fullName: System.Collections.IComparer
- uid: System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)
  parent: System.Collections.ArrayList
  isExternal: false
  name: BinarySearch(Int32,Int32,Object,IComparer)
  nameWithType: ArrayList.BinarySearch(Int32,Int32,Object,IComparer)
  fullName: System.Collections.ArrayList.BinarySearch(Int32,Int32,Object,IComparer)
- uid: System.Collections.ArrayList.Capacity
  parent: System.Collections.ArrayList
  isExternal: false
  name: Capacity
  nameWithType: ArrayList.Capacity
  fullName: System.Collections.ArrayList.Capacity
- uid: System.Collections.ArrayList.Clear
  parent: System.Collections.ArrayList
  isExternal: false
  name: Clear()
  nameWithType: ArrayList.Clear()
  fullName: System.Collections.ArrayList.Clear()
- uid: System.Collections.ArrayList.Clone
  parent: System.Collections.ArrayList
  isExternal: false
  name: Clone()
  nameWithType: ArrayList.Clone()
  fullName: System.Collections.ArrayList.Clone()
- uid: System.Collections.ArrayList.Contains(System.Object)
  parent: System.Collections.ArrayList
  isExternal: false
  name: Contains(Object)
  nameWithType: ArrayList.Contains(Object)
  fullName: System.Collections.ArrayList.Contains(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Collections.ArrayList.CopyTo(System.Array)
  parent: System.Collections.ArrayList
  isExternal: false
  name: CopyTo(Array)
  nameWithType: ArrayList.CopyTo(Array)
  fullName: System.Collections.ArrayList.CopyTo(Array)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: System.Collections.ArrayList.CopyTo(System.Array,System.Int32)
  parent: System.Collections.ArrayList
  isExternal: false
  name: CopyTo(Array,Int32)
  nameWithType: ArrayList.CopyTo(Array,Int32)
  fullName: System.Collections.ArrayList.CopyTo(Array,Int32)
- uid: System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)
  parent: System.Collections.ArrayList
  isExternal: false
  name: CopyTo(Int32,Array,Int32,Int32)
  nameWithType: ArrayList.CopyTo(Int32,Array,Int32,Int32)
  fullName: System.Collections.ArrayList.CopyTo(Int32,Array,Int32,Int32)
- uid: System.Collections.ArrayList.Count
  parent: System.Collections.ArrayList
  isExternal: false
  name: Count
  nameWithType: ArrayList.Count
  fullName: System.Collections.ArrayList.Count
- uid: System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)
  parent: System.Collections.ArrayList
  isExternal: false
  name: FixedSize(ArrayList)
  nameWithType: ArrayList.FixedSize(ArrayList)
  fullName: System.Collections.ArrayList.FixedSize(ArrayList)
- uid: System.Collections.ArrayList.FixedSize(System.Collections.IList)
  parent: System.Collections.ArrayList
  isExternal: false
  name: FixedSize(IList)
  nameWithType: ArrayList.FixedSize(IList)
  fullName: System.Collections.ArrayList.FixedSize(IList)
- uid: System.Collections.ArrayList.GetEnumerator
  parent: System.Collections.ArrayList
  isExternal: false
  name: GetEnumerator()
  nameWithType: ArrayList.GetEnumerator()
  fullName: System.Collections.ArrayList.GetEnumerator()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)
  parent: System.Collections.ArrayList
  isExternal: false
  name: GetEnumerator(Int32,Int32)
  nameWithType: ArrayList.GetEnumerator(Int32,Int32)
  fullName: System.Collections.ArrayList.GetEnumerator(Int32,Int32)
- uid: System.Collections.ArrayList.GetRange(System.Int32,System.Int32)
  parent: System.Collections.ArrayList
  isExternal: false
  name: GetRange(Int32,Int32)
  nameWithType: ArrayList.GetRange(Int32,Int32)
  fullName: System.Collections.ArrayList.GetRange(Int32,Int32)
- uid: System.Collections.ArrayList.IndexOf(System.Object)
  parent: System.Collections.ArrayList
  isExternal: false
  name: IndexOf(Object)
  nameWithType: ArrayList.IndexOf(Object)
  fullName: System.Collections.ArrayList.IndexOf(Object)
- uid: System.Collections.ArrayList.IndexOf(System.Object,System.Int32)
  parent: System.Collections.ArrayList
  isExternal: false
  name: IndexOf(Object,Int32)
  nameWithType: ArrayList.IndexOf(Object,Int32)
  fullName: System.Collections.ArrayList.IndexOf(Object,Int32)
- uid: System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)
  parent: System.Collections.ArrayList
  isExternal: false
  name: IndexOf(Object,Int32,Int32)
  nameWithType: ArrayList.IndexOf(Object,Int32,Int32)
  fullName: System.Collections.ArrayList.IndexOf(Object,Int32,Int32)
- uid: System.Collections.ArrayList.Insert(System.Int32,System.Object)
  parent: System.Collections.ArrayList
  isExternal: false
  name: Insert(Int32,Object)
  nameWithType: ArrayList.Insert(Int32,Object)
  fullName: System.Collections.ArrayList.Insert(Int32,Object)
- uid: System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)
  parent: System.Collections.ArrayList
  isExternal: false
  name: InsertRange(Int32,ICollection)
  nameWithType: ArrayList.InsertRange(Int32,ICollection)
  fullName: System.Collections.ArrayList.InsertRange(Int32,ICollection)
- uid: System.Collections.ArrayList.IsFixedSize
  parent: System.Collections.ArrayList
  isExternal: false
  name: IsFixedSize
  nameWithType: ArrayList.IsFixedSize
  fullName: System.Collections.ArrayList.IsFixedSize
- uid: System.Collections.ArrayList.IsReadOnly
  parent: System.Collections.ArrayList
  isExternal: false
  name: IsReadOnly
  nameWithType: ArrayList.IsReadOnly
  fullName: System.Collections.ArrayList.IsReadOnly
- uid: System.Collections.ArrayList.IsSynchronized
  parent: System.Collections.ArrayList
  isExternal: false
  name: IsSynchronized
  nameWithType: ArrayList.IsSynchronized
  fullName: System.Collections.ArrayList.IsSynchronized
- uid: System.Collections.ArrayList.Item(System.Int32)
  parent: System.Collections.ArrayList
  isExternal: false
  name: Item(Int32)
  nameWithType: ArrayList.Item(Int32)
  fullName: System.Collections.ArrayList.Item(Int32)
- uid: System.Collections.ArrayList.LastIndexOf(System.Object)
  parent: System.Collections.ArrayList
  isExternal: false
  name: LastIndexOf(Object)
  nameWithType: ArrayList.LastIndexOf(Object)
  fullName: System.Collections.ArrayList.LastIndexOf(Object)
- uid: System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)
  parent: System.Collections.ArrayList
  isExternal: false
  name: LastIndexOf(Object,Int32)
  nameWithType: ArrayList.LastIndexOf(Object,Int32)
  fullName: System.Collections.ArrayList.LastIndexOf(Object,Int32)
- uid: System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)
  parent: System.Collections.ArrayList
  isExternal: false
  name: LastIndexOf(Object,Int32,Int32)
  nameWithType: ArrayList.LastIndexOf(Object,Int32,Int32)
  fullName: System.Collections.ArrayList.LastIndexOf(Object,Int32,Int32)
- uid: System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)
  parent: System.Collections.ArrayList
  isExternal: false
  name: ReadOnly(ArrayList)
  nameWithType: ArrayList.ReadOnly(ArrayList)
  fullName: System.Collections.ArrayList.ReadOnly(ArrayList)
- uid: System.Collections.ArrayList.ReadOnly(System.Collections.IList)
  parent: System.Collections.ArrayList
  isExternal: false
  name: ReadOnly(IList)
  nameWithType: ArrayList.ReadOnly(IList)
  fullName: System.Collections.ArrayList.ReadOnly(IList)
- uid: System.Collections.ArrayList.Remove(System.Object)
  parent: System.Collections.ArrayList
  isExternal: false
  name: Remove(Object)
  nameWithType: ArrayList.Remove(Object)
  fullName: System.Collections.ArrayList.Remove(Object)
- uid: System.Collections.ArrayList.RemoveAt(System.Int32)
  parent: System.Collections.ArrayList
  isExternal: false
  name: RemoveAt(Int32)
  nameWithType: ArrayList.RemoveAt(Int32)
  fullName: System.Collections.ArrayList.RemoveAt(Int32)
- uid: System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)
  parent: System.Collections.ArrayList
  isExternal: false
  name: RemoveRange(Int32,Int32)
  nameWithType: ArrayList.RemoveRange(Int32,Int32)
  fullName: System.Collections.ArrayList.RemoveRange(Int32,Int32)
- uid: System.Collections.ArrayList.Repeat(System.Object,System.Int32)
  parent: System.Collections.ArrayList
  isExternal: false
  name: Repeat(Object,Int32)
  nameWithType: ArrayList.Repeat(Object,Int32)
  fullName: System.Collections.ArrayList.Repeat(Object,Int32)
- uid: System.Collections.ArrayList.Reverse
  parent: System.Collections.ArrayList
  isExternal: false
  name: Reverse()
  nameWithType: ArrayList.Reverse()
  fullName: System.Collections.ArrayList.Reverse()
- uid: System.Collections.ArrayList.Reverse(System.Int32,System.Int32)
  parent: System.Collections.ArrayList
  isExternal: false
  name: Reverse(Int32,Int32)
  nameWithType: ArrayList.Reverse(Int32,Int32)
  fullName: System.Collections.ArrayList.Reverse(Int32,Int32)
- uid: System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)
  parent: System.Collections.ArrayList
  isExternal: false
  name: SetRange(Int32,ICollection)
  nameWithType: ArrayList.SetRange(Int32,ICollection)
  fullName: System.Collections.ArrayList.SetRange(Int32,ICollection)
- uid: System.Collections.ArrayList.Sort
  parent: System.Collections.ArrayList
  isExternal: false
  name: Sort()
  nameWithType: ArrayList.Sort()
  fullName: System.Collections.ArrayList.Sort()
- uid: System.Collections.ArrayList.Sort(System.Collections.IComparer)
  parent: System.Collections.ArrayList
  isExternal: false
  name: Sort(IComparer)
  nameWithType: ArrayList.Sort(IComparer)
  fullName: System.Collections.ArrayList.Sort(IComparer)
- uid: System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)
  parent: System.Collections.ArrayList
  isExternal: false
  name: Sort(Int32,Int32,IComparer)
  nameWithType: ArrayList.Sort(Int32,Int32,IComparer)
  fullName: System.Collections.ArrayList.Sort(Int32,Int32,IComparer)
- uid: System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)
  parent: System.Collections.ArrayList
  isExternal: false
  name: Synchronized(ArrayList)
  nameWithType: ArrayList.Synchronized(ArrayList)
  fullName: System.Collections.ArrayList.Synchronized(ArrayList)
- uid: System.Collections.ArrayList.Synchronized(System.Collections.IList)
  parent: System.Collections.ArrayList
  isExternal: false
  name: Synchronized(IList)
  nameWithType: ArrayList.Synchronized(IList)
  fullName: System.Collections.ArrayList.Synchronized(IList)
- uid: System.Collections.ArrayList.SyncRoot
  parent: System.Collections.ArrayList
  isExternal: false
  name: SyncRoot
  nameWithType: ArrayList.SyncRoot
  fullName: System.Collections.ArrayList.SyncRoot
- uid: System.Collections.ArrayList.ToArray
  parent: System.Collections.ArrayList
  isExternal: false
  name: ToArray()
  nameWithType: ArrayList.ToArray()
  fullName: System.Collections.ArrayList.ToArray()
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Collections.ArrayList.ToArray(System.Type)
  parent: System.Collections.ArrayList
  isExternal: false
  name: ToArray(Type)
  nameWithType: ArrayList.ToArray(Type)
  fullName: System.Collections.ArrayList.ToArray(Type)
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Collections.ArrayList.TrimToSize
  parent: System.Collections.ArrayList
  isExternal: false
  name: TrimToSize()
  nameWithType: ArrayList.TrimToSize()
  fullName: System.Collections.ArrayList.TrimToSize()
- uid: System.Collections.ArrayList.#ctor*
  parent: System.Collections.ArrayList
  isExternal: false
  name: ArrayList
  nameWithType: ArrayList.ArrayList
- uid: System.Collections.ArrayList.Adapter*
  parent: System.Collections.ArrayList
  isExternal: false
  name: Adapter
  nameWithType: ArrayList.Adapter
- uid: System.Collections.ArrayList.Add*
  parent: System.Collections.ArrayList
  isExternal: false
  name: Add
  nameWithType: ArrayList.Add
- uid: System.Collections.ArrayList.AddRange*
  parent: System.Collections.ArrayList
  isExternal: false
  name: AddRange
  nameWithType: ArrayList.AddRange
- uid: System.Collections.ArrayList.BinarySearch*
  parent: System.Collections.ArrayList
  isExternal: false
  name: BinarySearch
  nameWithType: ArrayList.BinarySearch
- uid: System.Collections.ArrayList.Capacity*
  parent: System.Collections.ArrayList
  isExternal: false
  name: Capacity
  nameWithType: ArrayList.Capacity
- uid: System.Collections.ArrayList.Clear*
  parent: System.Collections.ArrayList
  isExternal: false
  name: Clear
  nameWithType: ArrayList.Clear
- uid: System.Collections.ArrayList.Clone*
  parent: System.Collections.ArrayList
  isExternal: false
  name: Clone
  nameWithType: ArrayList.Clone
- uid: System.Collections.ArrayList.Contains*
  parent: System.Collections.ArrayList
  isExternal: false
  name: Contains
  nameWithType: ArrayList.Contains
- uid: System.Collections.ArrayList.CopyTo*
  parent: System.Collections.ArrayList
  isExternal: false
  name: CopyTo
  nameWithType: ArrayList.CopyTo
- uid: System.Collections.ArrayList.Count*
  parent: System.Collections.ArrayList
  isExternal: false
  name: Count
  nameWithType: ArrayList.Count
- uid: System.Collections.ArrayList.FixedSize*
  parent: System.Collections.ArrayList
  isExternal: false
  name: FixedSize
  nameWithType: ArrayList.FixedSize
- uid: System.Collections.ArrayList.GetEnumerator*
  parent: System.Collections.ArrayList
  isExternal: false
  name: GetEnumerator
  nameWithType: ArrayList.GetEnumerator
- uid: System.Collections.ArrayList.GetRange*
  parent: System.Collections.ArrayList
  isExternal: false
  name: GetRange
  nameWithType: ArrayList.GetRange
- uid: System.Collections.ArrayList.IndexOf*
  parent: System.Collections.ArrayList
  isExternal: false
  name: IndexOf
  nameWithType: ArrayList.IndexOf
- uid: System.Collections.ArrayList.Insert*
  parent: System.Collections.ArrayList
  isExternal: false
  name: Insert
  nameWithType: ArrayList.Insert
- uid: System.Collections.ArrayList.InsertRange*
  parent: System.Collections.ArrayList
  isExternal: false
  name: InsertRange
  nameWithType: ArrayList.InsertRange
- uid: System.Collections.ArrayList.IsFixedSize*
  parent: System.Collections.ArrayList
  isExternal: false
  name: IsFixedSize
  nameWithType: ArrayList.IsFixedSize
- uid: System.Collections.ArrayList.IsReadOnly*
  parent: System.Collections.ArrayList
  isExternal: false
  name: IsReadOnly
  nameWithType: ArrayList.IsReadOnly
- uid: System.Collections.ArrayList.IsSynchronized*
  parent: System.Collections.ArrayList
  isExternal: false
  name: IsSynchronized
  nameWithType: ArrayList.IsSynchronized
- uid: System.Collections.ArrayList.Item*
  parent: System.Collections.ArrayList
  isExternal: false
  name: Item
  nameWithType: ArrayList.Item
- uid: System.Collections.ArrayList.LastIndexOf*
  parent: System.Collections.ArrayList
  isExternal: false
  name: LastIndexOf
  nameWithType: ArrayList.LastIndexOf
- uid: System.Collections.ArrayList.ReadOnly*
  parent: System.Collections.ArrayList
  isExternal: false
  name: ReadOnly
  nameWithType: ArrayList.ReadOnly
- uid: System.Collections.ArrayList.Remove*
  parent: System.Collections.ArrayList
  isExternal: false
  name: Remove
  nameWithType: ArrayList.Remove
- uid: System.Collections.ArrayList.RemoveAt*
  parent: System.Collections.ArrayList
  isExternal: false
  name: RemoveAt
  nameWithType: ArrayList.RemoveAt
- uid: System.Collections.ArrayList.RemoveRange*
  parent: System.Collections.ArrayList
  isExternal: false
  name: RemoveRange
  nameWithType: ArrayList.RemoveRange
- uid: System.Collections.ArrayList.Repeat*
  parent: System.Collections.ArrayList
  isExternal: false
  name: Repeat
  nameWithType: ArrayList.Repeat
- uid: System.Collections.ArrayList.Reverse*
  parent: System.Collections.ArrayList
  isExternal: false
  name: Reverse
  nameWithType: ArrayList.Reverse
- uid: System.Collections.ArrayList.SetRange*
  parent: System.Collections.ArrayList
  isExternal: false
  name: SetRange
  nameWithType: ArrayList.SetRange
- uid: System.Collections.ArrayList.Sort*
  parent: System.Collections.ArrayList
  isExternal: false
  name: Sort
  nameWithType: ArrayList.Sort
- uid: System.Collections.ArrayList.Synchronized*
  parent: System.Collections.ArrayList
  isExternal: false
  name: Synchronized
  nameWithType: ArrayList.Synchronized
- uid: System.Collections.ArrayList.SyncRoot*
  parent: System.Collections.ArrayList
  isExternal: false
  name: SyncRoot
  nameWithType: ArrayList.SyncRoot
- uid: System.Collections.ArrayList.ToArray*
  parent: System.Collections.ArrayList
  isExternal: false
  name: ToArray
  nameWithType: ArrayList.ToArray
- uid: System.Collections.ArrayList.TrimToSize*
  parent: System.Collections.ArrayList
  isExternal: false
  name: TrimToSize
  nameWithType: ArrayList.TrimToSize
