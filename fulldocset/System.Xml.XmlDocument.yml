### YamlMime:ManagedReference
items:
- uid: System.Xml.XmlDocument
  id: XmlDocument
  children:
  - System.Xml.XmlDocument.#ctor
  - System.Xml.XmlDocument.#ctor(System.Xml.XmlImplementation)
  - System.Xml.XmlDocument.#ctor(System.Xml.XmlNameTable)
  - System.Xml.XmlDocument.BaseURI
  - System.Xml.XmlDocument.CloneNode(System.Boolean)
  - System.Xml.XmlDocument.CreateAttribute(System.String)
  - System.Xml.XmlDocument.CreateAttribute(System.String,System.String)
  - System.Xml.XmlDocument.CreateAttribute(System.String,System.String,System.String)
  - System.Xml.XmlDocument.CreateCDataSection(System.String)
  - System.Xml.XmlDocument.CreateComment(System.String)
  - System.Xml.XmlDocument.CreateDefaultAttribute(System.String,System.String,System.String)
  - System.Xml.XmlDocument.CreateDocumentFragment
  - System.Xml.XmlDocument.CreateDocumentType(System.String,System.String,System.String,System.String)
  - System.Xml.XmlDocument.CreateElement(System.String)
  - System.Xml.XmlDocument.CreateElement(System.String,System.String)
  - System.Xml.XmlDocument.CreateElement(System.String,System.String,System.String)
  - System.Xml.XmlDocument.CreateEntityReference(System.String)
  - System.Xml.XmlDocument.CreateNavigator
  - System.Xml.XmlDocument.CreateNavigator(System.Xml.XmlNode)
  - System.Xml.XmlDocument.CreateNode(System.String,System.String,System.String)
  - System.Xml.XmlDocument.CreateNode(System.Xml.XmlNodeType,System.String,System.String)
  - System.Xml.XmlDocument.CreateNode(System.Xml.XmlNodeType,System.String,System.String,System.String)
  - System.Xml.XmlDocument.CreateProcessingInstruction(System.String,System.String)
  - System.Xml.XmlDocument.CreateSignificantWhitespace(System.String)
  - System.Xml.XmlDocument.CreateTextNode(System.String)
  - System.Xml.XmlDocument.CreateWhitespace(System.String)
  - System.Xml.XmlDocument.CreateXmlDeclaration(System.String,System.String,System.String)
  - System.Xml.XmlDocument.DocumentElement
  - System.Xml.XmlDocument.DocumentType
  - System.Xml.XmlDocument.GetElementById(System.String)
  - System.Xml.XmlDocument.GetElementsByTagName(System.String)
  - System.Xml.XmlDocument.GetElementsByTagName(System.String,System.String)
  - System.Xml.XmlDocument.Implementation
  - System.Xml.XmlDocument.ImportNode(System.Xml.XmlNode,System.Boolean)
  - System.Xml.XmlDocument.InnerText
  - System.Xml.XmlDocument.InnerXml
  - System.Xml.XmlDocument.IsReadOnly
  - System.Xml.XmlDocument.Load(System.IO.Stream)
  - System.Xml.XmlDocument.Load(System.IO.TextReader)
  - System.Xml.XmlDocument.Load(System.String)
  - System.Xml.XmlDocument.Load(System.Xml.XmlReader)
  - System.Xml.XmlDocument.LoadXml(System.String)
  - System.Xml.XmlDocument.LocalName
  - System.Xml.XmlDocument.Name
  - System.Xml.XmlDocument.NameTable
  - System.Xml.XmlDocument.NodeChanged
  - System.Xml.XmlDocument.NodeChanging
  - System.Xml.XmlDocument.NodeInserted
  - System.Xml.XmlDocument.NodeInserting
  - System.Xml.XmlDocument.NodeRemoved
  - System.Xml.XmlDocument.NodeRemoving
  - System.Xml.XmlDocument.NodeType
  - System.Xml.XmlDocument.OwnerDocument
  - System.Xml.XmlDocument.ParentNode
  - System.Xml.XmlDocument.PreserveWhitespace
  - System.Xml.XmlDocument.ReadNode(System.Xml.XmlReader)
  - System.Xml.XmlDocument.Save(System.IO.Stream)
  - System.Xml.XmlDocument.Save(System.IO.TextWriter)
  - System.Xml.XmlDocument.Save(System.String)
  - System.Xml.XmlDocument.Save(System.Xml.XmlWriter)
  - System.Xml.XmlDocument.SchemaInfo
  - System.Xml.XmlDocument.Schemas
  - System.Xml.XmlDocument.Validate(System.Xml.Schema.ValidationEventHandler)
  - System.Xml.XmlDocument.Validate(System.Xml.Schema.ValidationEventHandler,System.Xml.XmlNode)
  - System.Xml.XmlDocument.WriteContentTo(System.Xml.XmlWriter)
  - System.Xml.XmlDocument.WriteTo(System.Xml.XmlWriter)
  - System.Xml.XmlDocument.XmlResolver
  langs:
  - csharp
  name: XmlDocument
  nameWithType: XmlDocument
  fullName: System.Xml.XmlDocument
  type: Class
  summary: "表示 XML 文档。 此类可用于加载、 验证、 编辑、 添加和放置 XML 文档中。"
  remarks: "<a name=\"Remarks\"></a> The XmlDocument class is an in-memory representation of an XML document. It implements the W3C [XML Document Object Model (DOM)](~/add/includes/ajax-current-ext-md.md) Level 1 Core and the Core DOM Level 2.  \n  \n *DOM* stands for *document object model*. To read more about it, see [XML Document Object Model (DOM)](../Topic/XML%20Document%20Object%20Model%20\\(DOM\\).md).  \n  \n You can load XML into the DOM by using the XmlDocument class, and then programmatically read, modify, and remove XML in the document.  \n  \n If you want to pry open the XmlDocument class and see how it’s implemented, see the [Reference Source](http://referencesource.microsoft.com/#System.Xml/Xml/System/Xml/Dom/XmlDocument.cs#f82a4c1bd1f0ee12).  \n  \n<a name=\"Common\"></a>   \n## Tasks  \n  \n-   [Load XML into the document object model](#Load)  \n  \n-   [Validate it against a schema](#Validation)  \n  \n-   [Navigate the document tree](#Navigate)  \n  \n-   [Find nodes](#Find)  \n  \n-   [Edit nodes](#Edit)  \n  \n-   [Add nodes](#Add)  \n  \n-   [Remove nodes](#Remove)  \n  \n-   [Position nodes](#Position)  \n  \n<a name=\"Load\"></a>   \n## Load XML into the document object model  \n Start with an XML document like this one. It’s just a few books in a collection. But it does contain the basic things that you’d find in any XML document; a namespace, elements that represent data and attributes that describe the data.  \n  \n```xml  \n<?xml version=\"1.0\" encoding=\"utf-8\"?>  \n<books xmlns=\"http://www.contoso.com/books\">  \n  <book genre=\"novel\" ISBN=\"1-861001-57-8\" publicationdate=\"1823-01-28\">  \n    <title>Pride And Prejudice</title>  \n    <price>24.95</price>  \n  </book>  \n  <book genre=\"novel\" ISBN=\"1-861002-30-1\" publicationdate=\"1985-01-01\">  \n    <title>The Handmaid's Tale</title>  \n    <price>29.95</price>  \n  </book>  \n  <book genre=\"novel\" ISBN=\"1-861001-45-3\" publicationdate=\"1811-01-01\">  \n    <title>Sense and Sensibility</title>  \n    <price>19.95</price>  \n  </book>  \n</books>  \n```  \n  \n Next, load this data into the DOM so that you can work with it in memory. The most popular way to do this is refer to a file on your local computer or on a network.  \n  \n This example loads XML from a file. If the file doesn’t exist, it just generates some XML and loads that.  \n  \n [!code-cpp[XMLProcessingApp#1](~/add/codesnippet/cpp/xmldomprocessing/xmldomprocessing.cpp#1)]\n [!code-cs[XMLProcessingApp#1](~/add/codesnippet/csharp/xmlprocessingapp/xmlhelpermethods.cs#1)]\n [!code-vb[XMLProcessingApp#1](~/add/codesnippet/visualbasic/xmlprocessingappvb/xmlhelpermethods.vb#1)]  \n  \n **Complete sample:** [Manipulate XML in-Memory by using the XmlDocument class and other related types](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  \n  \n **Learn more:** [Reading an XML Document into the DOM](~/add/includes/ajax-current-ext-md.md)  \n  \n<a name=\"Validation\"></a>   \n## Validate it against a schema  \n Start with an XML schema like this one. This schema defines the data types in the XML and which attributes are required.  \n  \n```xml  \n<?xml version=\"1.0\" encoding=\"utf-8\"?>  \n<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"  \n  attributeFormDefault=\"unqualified\"   \n  elementFormDefault=\"qualified\"  \n  targetNamespace=\"http://www.contoso.com/books\">   \n  <xs:element name=\"books\">  \n    <xs:complexType>  \n      <xs:sequence>  \n        <xs:element maxOccurs=\"unbounded\" name=\"book\">  \n          <xs:complexType>  \n            <xs:sequence>  \n              <xs:element name=\"title\" type=\"xs:string\" />  \n              <xs:element name=\"price\" type=\"xs:decimal\" />  \n            </xs:sequence>  \n            <xs:attribute name=\"genre\" type=\"xs:string\" use=\"required\" />  \n            <xs:attribute name=\"ISBN\" type=\"xs:string\" use=\"required\" />  \n            <xs:attribute name=\"publicationdate\" type=\"xs:date\" use=\"required\" />  \n          </xs:complexType>  \n        </xs:element>  \n      </xs:sequence>  \n    </xs:complexType>  \n  </xs:element>  \n</xs:schema>  \n```  \n  \n Create an <xref:System.Xml.XmlReader> object by using your schema, and then load that object into the DOM. Create an event handler that executes when code attempts to modify your XML file in ways that violate the rules of the schema.  \n  \n These blocks of code show helper methods that do all of this.  \n  \n [!code-cpp[XMLProcessingApp#2](~/add/codesnippet/cpp/xmldomprocessing/xmldomprocessing.cpp#2)]\n [!code-cs[XMLProcessingApp#2](~/add/codesnippet/csharp/xmlprocessingapp/xmlhelpermethods.cs#2)]\n [!code-vb[XMLProcessingApp#2](~/add/codesnippet/visualbasic/xmlprocessingappvb/xmlhelpermethods.vb#2)]  \n  \n **Complete sample:** [Manipulate XML in-Memory by using the XmlDocument class and other related types](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  \n  \n **Learn more:** [Validating an XML Document in the DOM](~/add/includes/ajax-current-ext-md.md)  \n  \n<a name=\"Navigate\"></a>   \n## Navigate the document tree  \n You can use properties to navigate around an XML document. But before you use any of them, let’s quickly review a few terms. Your document is composed of nodes. Each node has as single *parent* node directly above it. The only node that does not have a parent node is the document root, as it is the top-level node. Most nodes can have *child* nodes, which are nodes directly below them. Nodes that are at the same level are *siblings*.  \n  \n The following examples, show you how to obtain the root node, jump to the first child node of the root node, access any of its child nodes, get back out to the parent node, and then navigate across sibling nodes.  \n  \n **Start with the root node**  \n  \n This example gets the root node and then uses that node to output the contents of the document to the console.  \n  \n [!code-cs[Classic WebData XmlDocument.DocumentElement Example#1](~/add/codesnippet/csharp/t-system.xml.xmldocument_3.cs)]\n [!code-cpp[Classic WebData XmlDocument.DocumentElement Example#1](~/add/codesnippet/cpp/t-system.xml.xmldocument_3.cpp)]\n [!code-vb[Classic WebData XmlDocument.DocumentElement Example#1](~/add/codesnippet/visualbasic/t-system.xml.xmldocument_3.vb)]  \n  \n **Get child nodes**  \n  \n This example jumps to the first child node of the root node and then iterates through the child nodes of that node if any exist.  \n  \n [!code-cs[Classic WebData XmlNode.HasChildNodes Example#1](~/add/codesnippet/csharp/t-system.xml.xmldocument_4.cs)]\n [!code-cpp[Classic WebData XmlNode.HasChildNodes Example#1](~/add/codesnippet/cpp/t-system.xml.xmldocument_4.cpp)]\n [!code-vb[Classic WebData XmlNode.HasChildNodes Example#1](~/add/codesnippet/visualbasic/t-system.xml.xmldocument_4.vb)]  \n  \n **Get back to the parent node**  \n  \n Use the <xref:System.Xml.XmlDocument.ParentNode%2A> property.  \n  \n **Refer to the last child node**  \n  \n This example writes the price of a book to the console (which is the last child node of a book node).  \n  \n [!code-cpp[Classic WebData XmlNode.LastChild Example#1](~/add/codesnippet/cpp/t-system.xml.xmldocument_5.cpp)]\n [!code-cs[Classic WebData XmlNode.LastChild Example#1](~/add/codesnippet/csharp/t-system.xml.xmldocument_5.cs)]\n [!code-vb[Classic WebData XmlNode.LastChild Example#1](~/add/codesnippet/visualbasic/t-system.xml.xmldocument_5.vb)]  \n  \n **Navigate forward across siblings**  \n  \n This example moves forward from book to book. Book nodes are siblings to one another.  \n  \n [!code-vb[Classic WebData XmlNode.NextSibling Example#1](~/add/codesnippet/visualbasic/t-system.xml.xmldocument_6.vb)]\n [!code-cpp[Classic WebData XmlNode.NextSibling Example#1](~/add/codesnippet/cpp/t-system.xml.xmldocument_6.cpp)]\n [!code-cs[Classic WebData XmlNode.NextSibling Example#1](~/add/codesnippet/csharp/t-system.xml.xmldocument_6.cs)]  \n  \n **Navigate backwards across siblings**  \n  \n This example moves backwards from book to book.  \n  \n [!code-cs[Classic WebData XmlNode.PreviousSibling Example#1](~/add/codesnippet/csharp/t-system.xml.xmldocument_7.cs)]\n [!code-cpp[Classic WebData XmlNode.PreviousSibling Example#1](~/add/codesnippet/cpp/t-system.xml.xmldocument_7.cpp)]\n [!code-vb[Classic WebData XmlNode.PreviousSibling Example#1](~/add/codesnippet/visualbasic/t-system.xml.xmldocument_7.vb)]  \n  \n<a name=\"Find\"></a>   \n## Find nodes  \n The most popular way to find one or more nodes of data is to use an XPath query string, but there are also methods that don’t require one.  \n  \n **Get a single node**  \n  \n This example locates a book by using the ISBN number.  \n  \n [!code-cpp[XMLProcessingApp#3](~/add/codesnippet/cpp/xmldomprocessing/xmldomprocessing.cpp#3)]\n [!code-cs[XMLProcessingApp#3](~/add/codesnippet/csharp/xmlprocessingapp/xmlhelpermethods.cs#3)]\n [!code-vb[XMLProcessingApp#3](~/add/codesnippet/visualbasic/xmlprocessingappvb/xmlhelpermethods.vb#3)]  \n  \n The string used in this example is an Xpath query. You can find more examples of them here:   [XPath examples](https://msdn.microsoft.com/en-us/library/ms256086.aspx).  \n  \n You can also use the <xref:System.Xml.XmlDocument.GetElementById%2A> to retrieve nodes. To use this approach, you’ll have to define ID’s in the document type definition declarations of your XML file.  \n  \n After you get a node, you get the value of attributes or child nodes. This example does that with a book node.  \n  \n [!code-cpp[XMLProcessingApp#4](~/add/codesnippet/cpp/xmldomprocessing/xmldomprocessing.cpp#4)]\n [!code-cs[XMLProcessingApp#4](~/add/codesnippet/csharp/xmlprocessingapp/xmlhelpermethods.cs#4)]\n [!code-vb[XMLProcessingApp#4](~/add/codesnippet/visualbasic/xmlprocessingappvb/xmlhelpermethods.vb#4)]  \n  \n **Get a collection of nodes**  \n  \n This example selects all books where the author's last name is **Austen**, and then changes the price of those books.  \n  \n [!code-cpp[Classic WebData XmlNode.SelectNodes Example#1](~/add/codesnippet/cpp/t-system.xml.xmldocument_10.cpp)]\n [!code-cs[Classic WebData XmlNode.SelectNodes Example#1](~/add/codesnippet/csharp/t-system.xml.xmldocument_10.cs)]\n [!code-vb[Classic WebData XmlNode.SelectNodes Example#1](~/add/codesnippet/visualbasic/t-system.xml.xmldocument_10.vb)]  \n  \n You can also get a collection of nodes by using the name of the node. For example, this example gets a collection of all book titles.  \n  \n [!code-cs[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/add/codesnippet/csharp/t-system.xml.xmldocument_11.cs)]\n [!code-cpp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/add/codesnippet/cpp/t-system.xml.xmldocument_11.cpp)]\n [!code-vb[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/add/codesnippet/visualbasic/t-system.xml.xmldocument_11.vb)]  \n  \n **Complete sample:** [Manipulate XML in-Memory by using the XmlDocument class and other related types](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  \n  \n **Learn more:** [Select Nodes Using XPath Navigation](~/add/includes/ajax-current-ext-md.md)  \n  \n<a name=\"Edit\"></a>   \n## Edit nodes  \n This example edits a book node and its attributes.  \n  \n [!code-cpp[XMLProcessingApp#7](~/add/codesnippet/cpp/xmldomprocessing/xmldomprocessing.cpp#7)]\n [!code-cs[XMLProcessingApp#7](~/add/codesnippet/csharp/xmlprocessingapp/xmlhelpermethods.cs#7)]\n [!code-vb[XMLProcessingApp#7](~/add/codesnippet/visualbasic/xmlprocessingappvb/xmlhelpermethods.vb#7)]  \n  \n **Learn more:** [Modifying Nodes, Content, and Values in an XML Document](~/add/includes/ajax-current-ext-md.md)  \n  \n **Complete sample:** [Manipulate XML in-Memory by using the XmlDocument class and other related types](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  \n  \n<a name=\"Add\"></a>   \n## Add nodes  \n To add a node, use the <xref:System.Xml.XmlDocument.CreateElement%2A> method or the <xref:System.Xml.XmlDocument.CreateNode%2A> method.  \n  \n To add a data node such as a book, use the <xref:System.Xml.XmlDocument.CreateElement%2A> method.  \n  \n For any other type of node such as a comment, whitespace node, or CDATA node, use the <xref:System.Xml.XmlDocument.CreateNode%2A> method.  \n  \n This example creates a book node, adds attrubutes to that node, and then adds that node to the document.  \n  \n [!code-cpp[XMLProcessingApp#5](~/add/codesnippet/cpp/xmldomprocessing/xmldomprocessing.cpp#5)]\n [!code-cs[XMLProcessingApp#5](~/add/codesnippet/csharp/xmlprocessingapp/xmlhelpermethods.cs#5)]\n [!code-vb[XMLProcessingApp#5](~/add/codesnippet/visualbasic/xmlprocessingappvb/xmlhelpermethods.vb#5)]  \n  \n **Complete sample:** [Manipulate XML in-Memory by using the XmlDocument class and other related types](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  \n  \n **Learn more:** [Inserting Nodes into an XML Document](~/add/includes/ajax-current-ext-md.md)  \n  \n<a name=\"Remove\"></a>   \n## Remove nodes  \n To remove a node, use the <xref:System.Xml.XmlNode.RemoveChild%2A> method.  \n  \n This example removes a book from the document and any whitespace that appears just before the book node.  \n  \n [!code-cpp[XMLProcessingApp#6](~/add/codesnippet/cpp/xmldomprocessing/xmldomprocessing.cpp#6)]\n [!code-cs[XMLProcessingApp#6](~/add/codesnippet/csharp/xmlprocessingapp/xmlhelpermethods.cs#6)]\n [!code-vb[XMLProcessingApp#6](~/add/codesnippet/visualbasic/xmlprocessingappvb/xmlhelpermethods.vb#6)]  \n  \n **Complete sample:** [Manipulate XML in-Memory by using the XmlDocument class and other related types](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  \n  \n **Learn more:** [Removing Nodes, Content, and Values from an XML Document](~/add/includes/ajax-current-ext-md.md)  \n  \n<a name=\"Position\"></a>   \n## Position nodes  \n You can choose where you want a node to appear in your document by using the <xref:System.Xml.XmlNode.InsertBefore%2A> and <xref:System.Xml.XmlNode.InsertAfter%2A> methods.  \n  \n This example shows two helper methods. One of them moves a node higher in a list. The other one moves a node lower.  \n  \n These methods could be used in an application that enables users to move books up and down in a list of books. When a user chooses a book and presses an up or down button, your code could call methods like these to position the corresponding book node before or after other book nodes.  \n  \n [!code-cpp[XMLProcessingApp#8](~/add/codesnippet/cpp/xmldomprocessing/xmldomprocessing.cpp#8)]\n [!code-cs[XMLProcessingApp#8](~/add/codesnippet/csharp/xmlprocessingapp/xmlhelpermethods.cs#8)]\n [!code-vb[XMLProcessingApp#8](~/add/codesnippet/visualbasic/xmlprocessingappvb/xmlhelpermethods.vb#8)]  \n  \n **Complete sample:** [Manipulate XML in-Memory by using the XmlDocument class and other related types](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)"
  syntax:
    content: 'public class XmlDocument : System.Xml.XmlNode'
  inheritance:
  - System.Object
  - System.Xml.XmlNode
  implements: []
  inheritedMembers:
  - System.Xml.XmlNode.AppendChild(System.Xml.XmlNode)
  - System.Xml.XmlNode.Attributes
  - System.Xml.XmlNode.ChildNodes
  - System.Xml.XmlNode.Clone
  - System.Xml.XmlNode.FirstChild
  - System.Xml.XmlNode.GetEnumerator
  - System.Xml.XmlNode.GetNamespaceOfPrefix(System.String)
  - System.Xml.XmlNode.GetPrefixOfNamespace(System.String)
  - System.Xml.XmlNode.HasChildNodes
  - System.Xml.XmlNode.InsertAfter(System.Xml.XmlNode,System.Xml.XmlNode)
  - System.Xml.XmlNode.InsertBefore(System.Xml.XmlNode,System.Xml.XmlNode)
  - System.Xml.XmlNode.Item(System.String)
  - System.Xml.XmlNode.Item(System.String,System.String)
  - System.Xml.XmlNode.LastChild
  - System.Xml.XmlNode.NamespaceURI
  - System.Xml.XmlNode.NextSibling
  - System.Xml.XmlNode.Normalize
  - System.Xml.XmlNode.OuterXml
  - System.Xml.XmlNode.Prefix
  - System.Xml.XmlNode.PrependChild(System.Xml.XmlNode)
  - System.Xml.XmlNode.PreviousSibling
  - System.Xml.XmlNode.PreviousText
  - System.Xml.XmlNode.RemoveAll
  - System.Xml.XmlNode.RemoveChild(System.Xml.XmlNode)
  - System.Xml.XmlNode.ReplaceChild(System.Xml.XmlNode,System.Xml.XmlNode)
  - System.Xml.XmlNode.SelectNodes(System.String)
  - System.Xml.XmlNode.SelectNodes(System.String,System.Xml.XmlNamespaceManager)
  - System.Xml.XmlNode.SelectSingleNode(System.String)
  - System.Xml.XmlNode.SelectSingleNode(System.String,System.Xml.XmlNamespaceManager)
  - System.Xml.XmlNode.Supports(System.String,System.String)
  - System.Xml.XmlNode.System#Collections#IEnumerable#GetEnumerator
  - System.Xml.XmlNode.System#ICloneable#Clone
  - System.Xml.XmlNode.Value
  platform:
  - net462
- uid: System.Xml.XmlDocument.#ctor
  id: '#ctor'
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: XmlDocument()
  nameWithType: XmlDocument.XmlDocument()
  fullName: System.Xml.XmlDocument.XmlDocument()
  type: Constructor
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "初始化的新实例<xref href=&quot;System.Xml.XmlDocument&quot;></xref>类。"
  remarks: ''
  example:
  - "The following is an example of load-time validation. A document type definition (DTD) validating <xref:System.Xml.XmlReader> is passed to the <xref:System.Xml.XmlDocument.Load%2A> method and a <xref:System.Xml.Schema.ValidationEventHandler> is provided to notify users of any validation errors. In this example a validation error is found, but the document is still loaded. Alternatively, you can define a validating <xref:System.Xml.XmlReader> to throw an exception and stop the load process when a validation error is found by not specifying the <xref:System.Xml.Schema.ValidationEventHandler>. For more information about validating XML data, see the Remarks section of the <xref:System.Xml.XmlReader> reference page.  \n  \n [!code-vb[XmlDocument.cctor#1](~/add/codesnippet/visualbasic/m-system.xml.xmldocument_11_1.vb)]\n [!code-cs[XmlDocument.cctor#1](~/add/codesnippet/csharp/m-system.xml.xmldocument_11_1.cs)]\n [!code-cpp[XmlDocument.cctor#1](~/add/codesnippet/cpp/m-system.xml.xmldocument_11_1.cpp)]  \n  \n The example uses the `bookDTD.xml` file as input.  \n  \n [!code-xml[XmlDocument.cctor#2](~/add/codesnippet/xml/m-system.xml.xmldocument_11_2.xml)]"
  syntax:
    content: public XmlDocument ();
    parameters: []
  overload: System.Xml.XmlDocument.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.#ctor(System.Xml.XmlImplementation)
  id: '#ctor(System.Xml.XmlImplementation)'
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: XmlDocument(XmlImplementation)
  nameWithType: XmlDocument.XmlDocument(XmlImplementation)
  fullName: System.Xml.XmlDocument.XmlDocument(XmlImplementation)
  type: Constructor
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "初始化的新实例<xref uid=&quot;langword_csharp_XmlDocument&quot; name=&quot;XmlDocument&quot; href=&quot;&quot;></xref>使用指定的类<xref href=&quot;System.Xml.XmlImplementation&quot;> </xref>。"
  syntax:
    content: protected XmlDocument (System.Xml.XmlImplementation imp);
    parameters:
    - id: imp
      type: System.Xml.XmlImplementation
      description: "The <xref uid=&quot;langword_csharp_XmlImplementation&quot; name=&quot;XmlImplementation&quot; href=&quot;&quot;></xref> to use."
  overload: System.Xml.XmlDocument.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.#ctor(System.Xml.XmlNameTable)
  id: '#ctor(System.Xml.XmlNameTable)'
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: XmlDocument(XmlNameTable)
  nameWithType: XmlDocument.XmlDocument(XmlNameTable)
  fullName: System.Xml.XmlDocument.XmlDocument(XmlNameTable)
  type: Constructor
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "初始化的新实例<xref uid=&quot;langword_csharp_XmlDocument&quot; name=&quot;XmlDocument&quot; href=&quot;&quot;></xref>指定<xref:System.Xml.XmlNameTable>.</xref:System.Xml.XmlNameTable>类"
  syntax:
    content: public XmlDocument (System.Xml.XmlNameTable nt);
    parameters:
    - id: nt
      type: System.Xml.XmlNameTable
      description: "The <xref uid=&quot;langword_csharp_XmlNameTable&quot; name=&quot;XmlNameTable&quot; href=&quot;&quot;></xref> to use."
  overload: System.Xml.XmlDocument.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.BaseURI
  id: BaseURI
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: BaseURI
  nameWithType: XmlDocument.BaseURI
  fullName: System.Xml.XmlDocument.BaseURI
  type: Property
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "获取当前节点的基 URI。"
  remarks: "联网的 XML 文档的聚合使用各种 W3C 标准包含机制的数据块组成，因此包含来自不同位置的节点。 `BaseURI`告诉这些节点来自何处。       对于文档节点，`BaseURI`返回 XML 文档的位置。 例如，如果`XmlDocument`使用以下调用文档加载的。负载 (&quot;http://server/mydata.xml&quot;)`BaseURI`文档节点是 http://server/mydata.xml。 但是，如果<xref:System.Xml.XmlDocument.Load%2A>方法被重定向到不同的 URI，服务器`BaseURI`返回传递到的原始 URI`Load`方法。</xref:System.Xml.XmlDocument.Load%2A>       此属性是 Microsoft 扩展到文档对象模型 (DOM)。 有关其他信息`BaseURI`以及如何其行为与其他节点类型，请参阅<xref:System.Xml.XmlNode.BaseURI%2A?displayProperty=fullName>.</xref:System.Xml.XmlNode.BaseURI%2A?displayProperty=fullName>"
  syntax:
    content: public override string BaseURI { get; }
    return:
      type: System.String
      description: "从其加载节点的位置。"
  overload: System.Xml.XmlDocument.BaseURI*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.CloneNode(System.Boolean)
  id: CloneNode(System.Boolean)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: CloneNode(Boolean)
  nameWithType: XmlDocument.CloneNode(Boolean)
  fullName: System.Xml.XmlDocument.CloneNode(Boolean)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "创建此节点的副本。"
  remarks: "此方法可作为节点的复制构造函数。 克隆的节点具有没有父级 (<xref:System.Xml.XmlNode.ParentNode%2A>返回`null`)。</xref:System.Xml.XmlNode.ParentNode%2A>       如果`deep`是`true`，克隆的节点包含所有子节点，否则仅`XmlDocument`克隆节点。 请参阅<xref:System.Xml.XmlNode.CloneNode%2A?displayProperty=fullName>方法，以便查看此方法在其他节点类型上的行为方式。</xref:System.Xml.XmlNode.CloneNode%2A?displayProperty=fullName>"
  example:
  - "The following example shows the difference between a deep and shallow clone.  \n  \n [!code-cpp[Classic WebData XmlDocument.CloneNode Example#1](~/add/codesnippet/cpp/m-system.xml.xmldocument_13_1.cpp)]\n [!code-cs[Classic WebData XmlDocument.CloneNode Example#1](~/add/codesnippet/csharp/m-system.xml.xmldocument_13_1.cs)]\n [!code-vb[Classic WebData XmlDocument.CloneNode Example#1](~/add/codesnippet/visualbasic/m-system.xml.xmldocument_13_1.vb)]"
  syntax:
    content: public override System.Xml.XmlNode CloneNode (bool deep);
    parameters:
    - id: deep
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>递归地克隆指定节点; 下的子树<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>克隆节点本身。"
    return:
      type: System.Xml.XmlNode
      description: "克隆<xref uid=&quot;langword_csharp_XmlDocument&quot; name=&quot;XmlDocument&quot; href=&quot;&quot;></xref>节点。"
  overload: System.Xml.XmlDocument.CloneNode*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.CreateAttribute(System.String)
  id: CreateAttribute(System.String)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: CreateAttribute(String)
  nameWithType: XmlDocument.CreateAttribute(String)
  fullName: System.Xml.XmlDocument.CreateAttribute(String)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "创建<xref href=&quot;System.Xml.XmlAttribute&quot;></xref>指定<xref:System.Xml.XmlDocument.Name*>。</xref:System.Xml.XmlDocument.Name*>"
  remarks: "`XmlAttribute`可以添加到<xref:System.Xml.XmlElement>使用<xref:System.Xml.XmlElement.SetAttributeNode%2A>方法。</xref:System.Xml.XmlElement.SetAttributeNode%2A> </xref:System.Xml.XmlElement>"
  example:
  - "The following creates an attribute and adds it to an XML document.  \n  \n [!code-cs[Classic WebData XmlDocument.CreateAttribute Example#1](~/add/codesnippet/csharp/m-system.xml.xmldocument_1_1.cs)]\n [!code-cpp[Classic WebData XmlDocument.CreateAttribute Example#1](~/add/codesnippet/cpp/m-system.xml.xmldocument_1_1.cpp)]\n [!code-vb[Classic WebData XmlDocument.CreateAttribute Example#1](~/add/codesnippet/visualbasic/m-system.xml.xmldocument_1_1.vb)]"
  syntax:
    content: public System.Xml.XmlAttribute CreateAttribute (string name);
    parameters:
    - id: name
      type: System.String
      description: "属性的限定的名称。 如果名称包含冒号， <> </> *1> 属性反映名称中第一个冒号之前的部分和<> *1> 属性反映名称中第一个冒号之后的部分。 <xref:System.Xml.XmlNode.NamespaceURI*>保持为空，除非该前缀是一个可识别的内置前缀，例如 xmlns。</xref:System.Xml.XmlNode.NamespaceURI*> 在这种情况下<xref uid=&quot;langword_csharp_NamespaceURI&quot; name=&quot;NamespaceURI&quot; href=&quot;&quot;></xref>具有值 http://www.w3.org/2000/xmlns/。"
    return:
      type: System.Xml.XmlAttribute
      description: "The new <xref uid=&quot;langword_csharp_XmlAttribute&quot; name=&quot;XmlAttribute&quot; href=&quot;&quot;></xref>."
  overload: System.Xml.XmlDocument.CreateAttribute*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.CreateAttribute(System.String,System.String)
  id: CreateAttribute(System.String,System.String)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: CreateAttribute(String,String)
  nameWithType: XmlDocument.CreateAttribute(String,String)
  fullName: System.Xml.XmlDocument.CreateAttribute(String,String)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "创建<xref href=&quot;System.Xml.XmlAttribute&quot;></xref>具有指定限定的名称和<xref:System.Xml.XmlNode.NamespaceURI*>.</xref:System.Xml.XmlNode.NamespaceURI*>"
  remarks: "`XmlAttribute`可以添加到<xref:System.Xml.XmlElement>使用<xref:System.Xml.XmlElement.SetAttributeNode%2A>方法。</xref:System.Xml.XmlElement.SetAttributeNode%2A> </xref:System.Xml.XmlElement>"
  syntax:
    content: public System.Xml.XmlAttribute CreateAttribute (string qualifiedName, string namespaceURI);
    parameters:
    - id: qualifiedName
      type: System.String
      description: "属性的限定的名称。 如果名称包含冒号则<> *1> 属性将反映名称中冒号之前的部分和<> *1> 属性将反映位于冒号后的名称的一部分。"
    - id: namespaceURI
      type: System.String
      description: "该属性的 namespaceURI。 如果限定的名称包含前缀 xmlns，此参数必须是 http://www.w3.org/2000/xmlns/。"
    return:
      type: System.Xml.XmlAttribute
      description: "The new <xref uid=&quot;langword_csharp_XmlAttribute&quot; name=&quot;XmlAttribute&quot; href=&quot;&quot;></xref>."
  overload: System.Xml.XmlDocument.CreateAttribute*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.CreateAttribute(System.String,System.String,System.String)
  id: CreateAttribute(System.String,System.String,System.String)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: CreateAttribute(String,String,String)
  nameWithType: XmlDocument.CreateAttribute(String,String,String)
  fullName: System.Xml.XmlDocument.CreateAttribute(String,String,String)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "创建<xref href=&quot;System.Xml.XmlAttribute&quot;></xref>具有指定<> *1>， <> </> *1>，和<xref:System.Xml.XmlNode.NamespaceURI*>。</xref:System.Xml.XmlNode.NamespaceURI*>"
  remarks: "`XmlAttribute`可以添加到<xref:System.Xml.XmlElement>使用<xref:System.Xml.XmlElement.SetAttributeNode%2A>方法。</xref:System.Xml.XmlElement.SetAttributeNode%2A> </xref:System.Xml.XmlElement>       此方法是 Microsoft 扩展到文档对象模型 (DOM)。"
  syntax:
    content: public virtual System.Xml.XmlAttribute CreateAttribute (string prefix, string localName, string namespaceURI);
    parameters:
    - id: prefix
      type: System.String
      description: "属性 （如果有） 的前缀。 String.Empty 和<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>是等效的。"
    - id: localName
      type: System.String
      description: "属性的本地名称。"
    - id: namespaceURI
      type: System.String
      description: "命名空间 URI （如果有） 的属性。 String.Empty 和<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>是等效的。 如果`prefix`为 xmlns，则此参数必须是 http: //www.w3.org/2000/xmlns/; 否则为将引发异常。"
    return:
      type: System.Xml.XmlAttribute
      description: "The new <xref uid=&quot;langword_csharp_XmlAttribute&quot; name=&quot;XmlAttribute&quot; href=&quot;&quot;></xref>."
  overload: System.Xml.XmlDocument.CreateAttribute*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.CreateCDataSection(System.String)
  id: CreateCDataSection(System.String)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: CreateCDataSection(String)
  nameWithType: XmlDocument.CreateCDataSection(String)
  fullName: System.Xml.XmlDocument.CreateCDataSection(String)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "创建<xref href=&quot;System.Xml.XmlCDataSection&quot;></xref>包含指定的数据。"
  remarks: "尽管此方法在文档的上下文中创建新的对象，它不会自动添加新的对象到文档树。 若要添加新的对象，必须显式调用的节点插入方法之一。       根据 W3C 可扩展标记语言 (XML) 1.0 建议 (www.w3.org/TR/1998/REC-xml-19980210) 中，CDataSection 节点时，允许在元素节点和 EntityReference 节点 EntityReference 节点不是属性节点的子级。"
  example:
  - "The following example creates a CDATA node and adds it to the document.  \n  \n [!code-vb[Classic WebData XmlDocument.CreateCDataSection Example#1](~/add/codesnippet/visualbasic/m-system.xml.xmldocument_9_1.vb)]\n [!code-cpp[Classic WebData XmlDocument.CreateCDataSection Example#1](~/add/codesnippet/cpp/m-system.xml.xmldocument_9_1.cpp)]\n [!code-cs[Classic WebData XmlDocument.CreateCDataSection Example#1](~/add/codesnippet/csharp/m-system.xml.xmldocument_9_1.cs)]"
  syntax:
    content: public virtual System.Xml.XmlCDataSection CreateCDataSection (string data);
    parameters:
    - id: data
      type: System.String
      description: "新内容<xref uid=&quot;langword_csharp_XmlCDataSection&quot; name=&quot;XmlCDataSection&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.Xml.XmlCDataSection
      description: "The new <xref uid=&quot;langword_csharp_XmlCDataSection&quot; name=&quot;XmlCDataSection&quot; href=&quot;&quot;></xref>."
  overload: System.Xml.XmlDocument.CreateCDataSection*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.CreateComment(System.String)
  id: CreateComment(System.String)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: CreateComment(String)
  nameWithType: XmlDocument.CreateComment(String)
  fullName: System.Xml.XmlDocument.CreateComment(String)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "创建<xref href=&quot;System.Xml.XmlComment&quot;></xref>包含指定的数据。"
  remarks: "尽管此方法在文档的上下文中创建新的对象，它不会自动添加新的对象到文档树。 若要添加新的对象，必须显式调用的节点插入方法之一。       根据 W3C 可扩展标记语言 (XML) 1.0 建议 (www.w3.org/TR/1998/REC-xml-19980210) 中，注释节点时，只允许在文档、 元素和 EntityReference 节点内 EntityReference 节点不是属性节点的子级。"
  example:
  - "The following example creates a comment and adds it to an XML document.  \n  \n [!code-cs[Classic WebData XmlDocument.CreateComment Example#1](~/add/codesnippet/csharp/m-system.xml.xmldocument_12_1.cs)]\n [!code-vb[Classic WebData XmlDocument.CreateComment Example#1](~/add/codesnippet/visualbasic/m-system.xml.xmldocument_12_1.vb)]\n [!code-cpp[Classic WebData XmlDocument.CreateComment Example#1](~/add/codesnippet/cpp/m-system.xml.xmldocument_12_1.cpp)]"
  syntax:
    content: public virtual System.Xml.XmlComment CreateComment (string data);
    parameters:
    - id: data
      type: System.String
      description: "新内容<xref uid=&quot;langword_csharp_XmlComment&quot; name=&quot;XmlComment&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.Xml.XmlComment
      description: "The new <xref uid=&quot;langword_csharp_XmlComment&quot; name=&quot;XmlComment&quot; href=&quot;&quot;></xref>."
  overload: System.Xml.XmlDocument.CreateComment*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.CreateDefaultAttribute(System.String,System.String,System.String)
  id: CreateDefaultAttribute(System.String,System.String,System.String)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: CreateDefaultAttribute(String,String,String)
  nameWithType: XmlDocument.CreateDefaultAttribute(String,String,String)
  fullName: System.Xml.XmlDocument.CreateDefaultAttribute(String,String,String)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "创建具有指定的前缀、 本地名称和命名空间 URI 的默认属性。"
  remarks: "此方法是 Microsoft 扩展到文档对象模型 (DOM)。"
  syntax:
    content: protected virtual System.Xml.XmlAttribute CreateDefaultAttribute (string prefix, string localName, string namespaceURI);
    parameters:
    - id: prefix
      type: System.String
      description: "属性 （如果有） 的前缀。"
    - id: localName
      type: System.String
      description: "属性的本地名称。"
    - id: namespaceURI
      type: System.String
      description: "命名空间 URI （如果有） 的属性。"
    return:
      type: System.Xml.XmlAttribute
      description: "The new <xref href=&quot;System.Xml.XmlAttribute&quot;></xref>."
  overload: System.Xml.XmlDocument.CreateDefaultAttribute*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.CreateDocumentFragment
  id: CreateDocumentFragment
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: CreateDocumentFragment()
  nameWithType: XmlDocument.CreateDocumentFragment()
  fullName: System.Xml.XmlDocument.CreateDocumentFragment()
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "创建<xref href=&quot;System.Xml.XmlDocumentFragment&quot;> </xref>。"
  remarks: "DocumentFragment 节点不能插入到文档。 但是，你可以将 DocumentFragment 节点的子级插入文档。"
  example:
  - "The following example adds new nodes to an XML document.  \n  \n [!code-cpp[Classic WebData XmlDocument.CreateDocumentFragment Example#1](~/add/codesnippet/cpp/m-system.xml.xmldocument_14_1.cpp)]\n [!code-vb[Classic WebData XmlDocument.CreateDocumentFragment Example#1](~/add/codesnippet/visualbasic/m-system.xml.xmldocument_14_1.vb)]\n [!code-cs[Classic WebData XmlDocument.CreateDocumentFragment Example#1](~/add/codesnippet/csharp/m-system.xml.xmldocument_14_1.cs)]"
  syntax:
    content: public virtual System.Xml.XmlDocumentFragment CreateDocumentFragment ();
    parameters: []
    return:
      type: System.Xml.XmlDocumentFragment
      description: "The new <xref uid=&quot;langword_csharp_XmlDocumentFragment&quot; name=&quot;XmlDocumentFragment&quot; href=&quot;&quot;></xref>."
  overload: System.Xml.XmlDocument.CreateDocumentFragment*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.CreateDocumentType(System.String,System.String,System.String,System.String)
  id: CreateDocumentType(System.String,System.String,System.String,System.String)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: CreateDocumentType(String,String,String,String)
  nameWithType: XmlDocument.CreateDocumentType(String,String,String,String)
  fullName: System.Xml.XmlDocument.CreateDocumentType(String,String,String,String)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "返回一个新<xref href=&quot;System.Xml.XmlDocumentType&quot;></xref>对象。"
  remarks: "返回的节点将具有经过分析<xref:System.Xml.XmlDocumentType.Entities%2A>和<xref:System.Xml.XmlDocumentType.Notations%2A>集合。</xref:System.Xml.XmlDocumentType.Notations%2A> </xref:System.Xml.XmlDocumentType.Entities%2A>       尽管此方法在文档的上下文中创建新的对象，它不会自动添加新的对象到文档树。 若要添加新的对象，必须显式调用的节点插入方法之一。       根据 W3C 可扩展标记语言 (XML) 1.0 建议 (www.w3.org/TR/1998/REC-xml-19980210) 中，文档节点中仅允许 DocumentType 节点。 每个<xref:System.Xml.XmlDocument>可以只能有一个 DocumentType 节点。</xref:System.Xml.XmlDocument> 此外必须在的根元素之前插入 DocumentType 节点`XmlDocument`（如果该文档已有一个根元素，无法添加 DocumentType 节点）。       如果传递的参数不合并以生成有效`XmlDocumentType`，将引发异常。"
  example:
  - "The following example creates a DocumentType node and adds it to an XML document.  \n  \n [!code-cpp[Classic WebData XmlDocument.CreateDocumentType Example#1](~/add/codesnippet/cpp/8d2758e1-ca32-4a6b-b7e7-_1.cpp)]\n [!code-cs[Classic WebData XmlDocument.CreateDocumentType Example#1](~/add/codesnippet/csharp/8d2758e1-ca32-4a6b-b7e7-_1.cs)]\n [!code-vb[Classic WebData XmlDocument.CreateDocumentType Example#1](~/add/codesnippet/visualbasic/8d2758e1-ca32-4a6b-b7e7-_1.vb)]"
  syntax:
    content: public virtual System.Xml.XmlDocumentType CreateDocumentType (string name, string publicId, string systemId, string internalSubset);
    parameters:
    - id: name
      type: System.String
      description: "文档类型的名称。"
    - id: publicId
      type: System.String
      description: "文档类型的公共标识符或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。 你可以指定一个公共 URI 以及一个系统标识符以标识外部 DTD 子集的位置。"
    - id: systemId
      type: System.String
      description: "文档类型的系统标识符或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。 指定外部 DTD 子集的文件位置的 URL。"
    - id: internalSubset
      type: System.String
      description: "文档类型的 DTD 内部子集或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.Xml.XmlDocumentType
      description: "The new <xref uid=&quot;langword_csharp_XmlDocumentType&quot; name=&quot;XmlDocumentType&quot; href=&quot;&quot;></xref>."
  overload: System.Xml.XmlDocument.CreateDocumentType*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.CreateElement(System.String)
  id: CreateElement(System.String)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: CreateElement(String)
  nameWithType: XmlDocument.CreateElement(String)
  fullName: System.Xml.XmlDocument.CreateElement(String)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "创建具有指定名称的元素。"
  remarks: "请注意，该实例返回实现`XmlElement`接口，所以将直接在返回的对象上创建默认属性。       尽管此方法在文档的上下文中创建新的对象，它不会自动添加新的对象到文档树。 若要添加新的对象，必须显式调用的节点插入方法之一。       根据 W3C 可扩展标记语言 (XML) 1.0 建议 (www.w3.org/TR/1998/REC-xml-19980210) 中，元素节点时，允许在文档和元素节点和 EntityReference 节点 EntityReference 节点不是属性节点的子级。"
  example:
  - "The following example creates a new element and adds it to the document.  \n  \n [!code-cpp[Classic WebData XmlDocument.CreateElement Example#1](~/add/codesnippet/cpp/m-system.xml.xmldocument_17_1.cpp)]\n [!code-cs[Classic WebData XmlDocument.CreateElement Example#1](~/add/codesnippet/csharp/m-system.xml.xmldocument_17_1.cs)]\n [!code-vb[Classic WebData XmlDocument.CreateElement Example#1](~/add/codesnippet/visualbasic/m-system.xml.xmldocument_17_1.vb)]"
  syntax:
    content: public System.Xml.XmlElement CreateElement (string name);
    parameters:
    - id: name
      type: System.String
      description: "元素的限定的名称。 如果名称包含冒号则<> *1> 属性反映名称中冒号之前的部分和<> *1> 属性反映名称的一部分的冒号后面。 限定的名称不能包含 xmlns 前缀。"
    return:
      type: System.Xml.XmlElement
      description: "The new <xref uid=&quot;langword_csharp_XmlElement&quot; name=&quot;XmlElement&quot; href=&quot;&quot;></xref>."
  overload: System.Xml.XmlDocument.CreateElement*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.CreateElement(System.String,System.String)
  id: CreateElement(System.String,System.String)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: CreateElement(String,String)
  nameWithType: XmlDocument.CreateElement(String,String)
  fullName: System.Xml.XmlDocument.CreateElement(String,String)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "创建<xref href=&quot;System.Xml.XmlElement&quot;></xref>具有限定的名称和<xref:System.Xml.XmlNode.NamespaceURI*>.</xref:System.Xml.XmlNode.NamespaceURI*>"
  remarks: "下面的 C# 代码```   XmlElement elem;   elem=doc.CreateElement(&quot;xy:item&quot;, &quot;urn:abc&quot;);   ```结果等效于以下 XML 文本的元素中。      ```   <xy:item          xmlns:xy=&quot;urn:abc&quot;/>   ```尽管此方法在文档的上下文中创建新的对象，它不会自动添加新的对象到文档树。 若要添加新的对象，必须显式调用的节点插入方法之一。       根据 W3C 可扩展标记语言 (XML) 1.0 建议 (www.w3.org/TR/1998/REC-xml-19980210) 中，元素节点时，允许在文档和元素节点和 EntityReference 节点 EntityReference 节点不是属性节点的子级。"
  syntax:
    content: public System.Xml.XmlElement CreateElement (string qualifiedName, string namespaceURI);
    parameters:
    - id: qualifiedName
      type: System.String
      description: "元素的限定的名称。 如果名称包含冒号则<> *1> 属性将反映名称中冒号之前的部分和<> *1> 属性将反映位于冒号后的名称的一部分。 限定的名称不能包含 xmlns 前缀。"
    - id: namespaceURI
      type: System.String
      description: "命名空间 URI 的元素。"
    return:
      type: System.Xml.XmlElement
      description: "The new <xref uid=&quot;langword_csharp_XmlElement&quot; name=&quot;XmlElement&quot; href=&quot;&quot;></xref>."
  overload: System.Xml.XmlDocument.CreateElement*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.CreateElement(System.String,System.String,System.String)
  id: CreateElement(System.String,System.String,System.String)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: CreateElement(String,String,String)
  nameWithType: XmlDocument.CreateElement(String,String,String)
  fullName: System.Xml.XmlDocument.CreateElement(String,String,String)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "创建一个具有指定元素<> *1>， <> </> *1>，和<xref:System.Xml.XmlNode.NamespaceURI*>。</xref:System.Xml.XmlNode.NamespaceURI*>"
  remarks: "下面的 C# 代码```   XmlElement elem;   elem=doc.CreateElement(&quot;xy&quot;, &quot;item&quot;, &quot;urn:abc&quot;);   ```创建元素等效于以下 XML 文本︰```   <xy:item xmlns:xy=&quot;urn:abc&quot;/>   ```尽管此方法在文档的上下文中创建新的对象，该实用工具不会自动添加新的对象到文档树。 若要添加新的对象，必须显式调用的节点插入方法之一。       根据 W3C 可扩展标记语言 (XML) 1.0 建议 (www.w3.org/TR/1998/REC-xml-19980210) 中，元素节点时，允许在文档和元素节点和 EntityReference 节点 EntityReference 超出属性节点。       此方法是 Microsoft 扩展到文档对象模型 (DOM)。"
  example:
  - "The following example adds a new element to the existing XML document.  \n  \n [!code-cs[Classic WebData XmlDocument.CreateElement2 Example#1](~/add/codesnippet/csharp/9cc675fc-f986-4de5-bce9-_1.cs)]\n [!code-vb[Classic WebData XmlDocument.CreateElement2 Example#1](~/add/codesnippet/visualbasic/9cc675fc-f986-4de5-bce9-_1.vb)]\n [!code-cpp[Classic WebData XmlDocument.CreateElement2 Example#1](~/add/codesnippet/cpp/9cc675fc-f986-4de5-bce9-_1.cpp)]"
  syntax:
    content: public virtual System.Xml.XmlElement CreateElement (string prefix, string localName, string namespaceURI);
    parameters:
    - id: prefix
      type: System.String
      description: "新元素 （如果有） 的前缀。 String.Empty 和<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>是等效的。"
    - id: localName
      type: System.String
      description: "新元素的本地名称。"
    - id: namespaceURI
      type: System.String
      description: "命名空间 URI （如果有），则新元素。 String.Empty 和<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>是等效的。"
    return:
      type: System.Xml.XmlElement
      description: "The new <xref href=&quot;System.Xml.XmlElement&quot;></xref>."
  overload: System.Xml.XmlDocument.CreateElement*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.CreateEntityReference(System.String)
  id: CreateEntityReference(System.String)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: CreateEntityReference(String)
  nameWithType: XmlDocument.CreateEntityReference(String)
  fullName: System.Xml.XmlDocument.CreateEntityReference(String)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "创建<xref href=&quot;System.Xml.XmlEntityReference&quot;></xref>具有指定名称。"
  remarks: "如果被引用的实体已知的的子列表`XmlEntityReference`节点进行相同的相应<xref:System.Xml.XmlEntity>节点。</xref:System.Xml.XmlEntity>       实体引用的替换文本中使用的命名空间绑定在实体引用节点的父级第一次设置 （例如，如果实体引用节点插入到文档中） 的时间。 例如，给定以下实体︰```   <!ENTITY a &quot;<b>test</b>&quot;>   ```如果调用`CreateEntityReference(&quot;a&quot;)`则将取回类型 EntityReference 的单个节点无子项的。 如果将此节点追加以下节点中，是小孩```   <item xmlns=&quot;urn:1&quot;/>   ```然后，在调用时<xref:System.Xml.XmlNode.AppendChild%2A>、 设置新创建的实体引用节点的父级和子级在此命名空间上下文中扩展。</xref:System.Xml.XmlNode.AppendChild%2A> 子元素节点`b`将具有 NamespaceURI 等于`urn:1`。 即使移动到具有不同的默认命名空间上下文的文档中的位置的实体引用的实体引用的子节点保持不变。 这不会发生对于现有实体引用节点时删除并将它们插入或的<xref:System.Xml.XmlDocument.CloneNode%2A>。</xref:System.Xml.XmlDocument.CloneNode%2A>克隆的实体引用 它仅对新创建的实体引用时发生。       如果相应的实体中未定义 DocumentType 添加实体引用节点，因为未定义实体引用，其唯一的子节点将空文本节点。       此外允许内置实体 amp、 lt、 gt、 a p o s 和 q u o t，并且它们将具有相应的扩展的字符值的子文本节点。       尽管此方法在文档的上下文中创建新的对象，它不会自动添加新的对象到文档树。 若要添加新的对象，必须显式调用的节点插入方法之一。       根据 W3C 可扩展标记语言 (XML) 1.0 建议 (www.w3.org/TR/1998/REC-xml-19980210) 中，元素、 属性和 EntityReference 节点中仅允许 EntityReference 节点。"
  example:
  - "The following example creates two entity reference nodes and inserts them into an XML document.  \n  \n [!code-cpp[Classic WebData XmlDocument.CreateEntityReference Example#1](~/add/codesnippet/cpp/m-system.xml.xmldocument_7_1.cpp)]\n [!code-cs[Classic WebData XmlDocument.CreateEntityReference Example#1](~/add/codesnippet/csharp/m-system.xml.xmldocument_7_1.cs)]\n [!code-vb[Classic WebData XmlDocument.CreateEntityReference Example#1](~/add/codesnippet/visualbasic/m-system.xml.xmldocument_7_1.vb)]"
  syntax:
    content: public virtual System.Xml.XmlEntityReference CreateEntityReference (string name);
    parameters:
    - id: name
      type: System.String
      description: "实体引用的名称。"
    return:
      type: System.Xml.XmlEntityReference
      description: "The new <xref uid=&quot;langword_csharp_XmlEntityReference&quot; name=&quot;XmlEntityReference&quot; href=&quot;&quot;></xref>."
  overload: System.Xml.XmlDocument.CreateEntityReference*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "名称无效 （例如，以 &quot;#&quot; 开头的名称均无效。）"
  platform:
  - net462
- uid: System.Xml.XmlDocument.CreateNavigator
  id: CreateNavigator
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: CreateNavigator()
  nameWithType: XmlDocument.CreateNavigator()
  fullName: System.Xml.XmlDocument.CreateNavigator()
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "创建一个新<xref href=&quot;System.Xml.XPath.XPathNavigator&quot;></xref>用于导航此文档的对象。"
  remarks: "此方法是 Microsoft 扩展到文档对象模型 (DOM)。"
  example:
  - See <xref:System.Xml.XmlNode.CreateNavigator%2A?displayProperty=fullName> for an example using this method.
  syntax:
    content: public override System.Xml.XPath.XPathNavigator CreateNavigator ();
    parameters: []
    return:
      type: System.Xml.XPath.XPathNavigator
      description: "<xref href=&quot;System.Xml.XPath.XPathNavigator&quot;> </xref>对象。"
  overload: System.Xml.XmlDocument.CreateNavigator*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.CreateNavigator(System.Xml.XmlNode)
  id: CreateNavigator(System.Xml.XmlNode)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: CreateNavigator(XmlNode)
  nameWithType: XmlDocument.CreateNavigator(XmlNode)
  fullName: System.Xml.XmlDocument.CreateNavigator(XmlNode)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "创建<xref href=&quot;System.Xml.XPath.XPathNavigator&quot;></xref>对象用于导航此文档位于<xref href=&quot;System.Xml.XmlNode&quot;></xref>指定。"
  remarks: "此方法是 Microsoft 扩展到文档对象模型 (DOM)。"
  example:
  - See <xref:System.Xml.XmlNode.CreateNavigator%2A?displayProperty=fullName> for an example using this method.
  syntax:
    content: protected virtual System.Xml.XPath.XPathNavigator CreateNavigator (System.Xml.XmlNode node);
    parameters:
    - id: node
      type: System.Xml.XmlNode
      description: "<xref href=&quot;System.Xml.XmlNode&quot;> </xref>希望导航器最初定位在。"
    return:
      type: System.Xml.XPath.XPathNavigator
      description: "<xref href=&quot;System.Xml.XPath.XPathNavigator&quot;> </xref>对象。"
  overload: System.Xml.XmlDocument.CreateNavigator*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.CreateNode(System.String,System.String,System.String)
  id: CreateNode(System.String,System.String,System.String)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: CreateNode(String,String,String)
  nameWithType: XmlDocument.CreateNode(String,String,String)
  fullName: System.Xml.XmlDocument.CreateNode(String,String,String)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "创建<xref href=&quot;System.Xml.XmlNode&quot;></xref>使用指定的节点的类型、 <> </> *1>，和<> *1>。"
  remarks: "The `nodeTypeString` parameter is case sensitive and must be one of the values in the following table.  \n  \n|nodeTypeString|XmlNodeType|  \n|--------------------|-----------------|  \n|attribute|Attribute|  \n|cdatasection|CDATA|  \n|comment|Comment|  \n|document|Document|  \n|documentfragment|DocumentFragment|  \n|documenttype|DocumentType|  \n|element|Element|  \n|entityreference|EntityReference|  \n|processinginstruction|ProcessingInstruction|  \n|significantwhitespace|SignificantWhitespace|  \n|text|Text|  \n|whitespace|Whitespace|  \n  \n Although this method creates the new object in the context of the document, it does not automatically add the new object to the document tree. To add the new object, you must explicitly call one of the node insert methods.  \n  \n The following table shows you what NodeType[row] is allowed inside another NodeType[column] according to the W3C Extensible Markup Language (XML) 1.0 recommendation (www.w3.org/TR/1998/REC-xml-19980210).  \n  \n||Document|DocumentType|XmlDeclaration|Element|Attribute|Text|CDATA|Markup|EntityReference|  \n|------|--------------|------------------|--------------------|-------------|---------------|----------|-----------|------------|---------------------|  \n|`Document`|no|no|no|no|no|no|no|no|no|  \n|`DocumentType`|yes|no|no|no|no|no|no|no|no|  \n|`XmlDeclaration`|yes*|no|no|no|no|no|no|no|no|  \n|`Element`|yes|no|no|yes|no|no|no|no|yes***|  \n|`Attribute`|no|no|no|yes****|no|no|no|no|no|  \n|`Text`|no|no|no|yes|yes|no|no|no|yes|  \n|`CDATA`|no|no|no|yes|no|no|no|no|yes***|  \n|`Markup**`|yes|no|no|yes|no|no|no|no|no|  \n|`EntityReference`|no|no|no|yes|yes|no|no|no|yes|  \n  \n \\* The XmlDeclaration node must be the first child of the Document node.  \n  \n ** Markup includes ProcessingInstruction and Comment nodes.  \n  \n *** Element and CDATA nodes are only allowed in EntityReference nodes when the EntityReference node is not a child of an Attribute node.  \n  \n **** Attributes are not children of an Element node. Attributes are contained inside an attribute collection that belongs to an Element node.  \n  \n This method is a Microsoft extension to the Document Object Model (DOM)."
  example:
  - "The following example creates a new element and inserts it into the document.  \n  \n [!code-cpp[Classic WebData XmlDocument.CreateNode1 Example#1](~/add/codesnippet/cpp/m-system.xml.xmldocument_15_1.cpp)]\n [!code-vb[Classic WebData XmlDocument.CreateNode1 Example#1](~/add/codesnippet/visualbasic/m-system.xml.xmldocument_15_1.vb)]\n [!code-cs[Classic WebData XmlDocument.CreateNode1 Example#1](~/add/codesnippet/csharp/m-system.xml.xmldocument_15_1.cs)]"
  syntax:
    content: public virtual System.Xml.XmlNode CreateNode (string nodeTypeString, string name, string namespaceURI);
    parameters:
    - id: nodeTypeString
      type: System.String
      description: "字符串版本<xref:System.Xml.XmlNodeType>新节点。</xref:System.Xml.XmlNodeType> 此参数必须是下表中列出的值之一。"
    - id: name
      type: System.String
      description: "新节点的限定的名称。 如果名称包含冒号，则将它解析为<> *1> 和<> *1> 组件。"
    - id: namespaceURI
      type: System.String
      description: "命名空间的新节点的 URI。"
    return:
      type: System.Xml.XmlNode
      description: "The new <xref uid=&quot;langword_csharp_XmlNode&quot; name=&quot;XmlNode&quot; href=&quot;&quot;></xref>."
  overload: System.Xml.XmlDocument.CreateNode*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "未提供名称和<xref uid=&quot;langword_csharp_XmlNodeType&quot; name=&quot;XmlNodeType&quot; href=&quot;&quot;></xref>需要名称; 或<code> nodeTypeString </code>不是下列字符串之一。"
  platform:
  - net462
- uid: System.Xml.XmlDocument.CreateNode(System.Xml.XmlNodeType,System.String,System.String)
  id: CreateNode(System.Xml.XmlNodeType,System.String,System.String)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: CreateNode(XmlNodeType,String,String)
  nameWithType: XmlDocument.CreateNode(XmlNodeType,String,String)
  fullName: System.Xml.XmlDocument.CreateNode(XmlNodeType,String,String)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "创建<xref href=&quot;System.Xml.XmlNode&quot;></xref>具有指定<xref:System.Xml.XmlNodeType>， <> </> *1>，和<> *1>。</xref:System.Xml.XmlNodeType>"
  remarks: "Although this method creates the new object in the context of the document, it does not automatically add the new object to the document tree. To add the new object, you must explicitly call one of the node insert methods.  \n  \n The following table shows you what NodeType[row] is allowed inside another NodeType[column] according to the W3C Extensible Markup Language (XML) 1.0 recommendation (www.w3.org/TR/1998/REC-xml-19980210).  \n  \n||Document|DocumentType|XmlDeclaration|Element|Attribute|Text|CDATA|Markup|EntityReference|  \n|------|--------------|------------------|--------------------|-------------|---------------|----------|-----------|------------|---------------------|  \n|`Document`|no|no|no|no|no|no|no|no|no|  \n|`DocumentType`|yes|no|no|no|no|no|no|no|no|  \n|`XmlDeclaration`|yes*|no|no|no|no|no|no|no|no|  \n|`Element`|yes|no|no|yes|no|no|no|no|yes***|  \n|`Attribute`|no|no|no|yes****|no|no|no|no|no|  \n|`Text`|no|no|no|yes|yes|no|no|no|yes|  \n|`CDATA`|no|no|no|yes|no|no|no|no|yes***|  \n|`Markup**`|yes|no|no|yes|no|no|no|no|no|  \n|`EntityReference`|no|no|no|yes|yes|no|no|no|yes|  \n  \n \\* The XmlDeclaration node must be the first child of the Document node.  \n  \n ** Markup includes ProcessingInstruction and Comment nodes.  \n  \n *** Element and CDATA nodes are only allowed in EntityReference nodes when the EntityReference node is not a child of an Attribute node.  \n  \n **** Attributes are not children of an Element node. Attributes are contained inside an attribute collection that belongs to an Element node.  \n  \n This method is a Microsoft extension to the Document Object Model (DOM)."
  example:
  - "The following example creates a new element and inserts it into an XML document.  \n  \n [!code-cs[Classic WebData XmlDocument.CreateNode Example#1](~/add/codesnippet/csharp/5e223793-7104-464b-b797-_1.cs)]\n [!code-cpp[Classic WebData XmlDocument.CreateNode Example#1](~/add/codesnippet/cpp/5e223793-7104-464b-b797-_1.cpp)]\n [!code-vb[Classic WebData XmlDocument.CreateNode Example#1](~/add/codesnippet/visualbasic/5e223793-7104-464b-b797-_1.vb)]"
  syntax:
    content: public virtual System.Xml.XmlNode CreateNode (System.Xml.XmlNodeType type, string name, string namespaceURI);
    parameters:
    - id: type
      type: System.Xml.XmlNodeType
      description: "<xref uid=&quot;langword_csharp_XmlNodeType&quot; name=&quot;XmlNodeType&quot; href=&quot;&quot;> </xref>新节点。"
    - id: name
      type: System.String
      description: "新节点的限定的名称。 如果名称包含冒号，则将它解析为<> *1> 和<> *1> 组件。"
    - id: namespaceURI
      type: System.String
      description: "命名空间的新节点的 URI。"
    return:
      type: System.Xml.XmlNode
      description: "The new <xref uid=&quot;langword_csharp_XmlNode&quot; name=&quot;XmlNode&quot; href=&quot;&quot;></xref>."
  overload: System.Xml.XmlDocument.CreateNode*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "未提供名称和<xref uid=&quot;langword_csharp_XmlNodeType&quot; name=&quot;XmlNodeType&quot; href=&quot;&quot;></xref>需要名称。"
  platform:
  - net462
- uid: System.Xml.XmlDocument.CreateNode(System.Xml.XmlNodeType,System.String,System.String,System.String)
  id: CreateNode(System.Xml.XmlNodeType,System.String,System.String,System.String)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: CreateNode(XmlNodeType,String,String,String)
  nameWithType: XmlDocument.CreateNode(XmlNodeType,String,String,String)
  fullName: System.Xml.XmlDocument.CreateNode(XmlNodeType,String,String,String)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "Creates a <xref href=&quot;System.Xml.XmlNode&quot;></xref> with the specified <xref:System.Xml.XmlNodeType>, <>*>, <>*>, and <xref:System.Xml.XmlNode.NamespaceURI*>.</xref:System.Xml.XmlNode.NamespaceURI*></xref:System.Xml.XmlNodeType>"
  remarks: "Although this method creates the new object in the context of the document, it does not automatically add the new object to the document tree. To add the new object, you must explicitly call one of the node insert methods.  \n  \n The following table shows you what NodeType[row] is allowed inside another NodeType[column] according to the W3C Extensible Markup Language (XML) 1.0 recommendation (www.w3.org/TR/1998/REC-xml-19980210).  \n  \n||Document|DocumentType|XmlDeclaration|Element|Attribute|Text|CDATA|Markup|EntityReference|  \n|------|--------------|------------------|--------------------|-------------|---------------|----------|-----------|------------|---------------------|  \n|`Document`|no|no|no|no|no|no|no|no|no|  \n|`DocumentType`|yes|no|no|no|no|no|no|no|no|  \n|`XmlDeclaration`|yes*|no|no|no|no|no|no|no|no|  \n|`Element`|yes|no|no|yes|no|no|no|no|yes***|  \n|`Attribute`|no|no|no|yes****|no|no|no|no|no|  \n|`Text`|no|no|no|yes|yes|no|no|no|yes|  \n|`CDATA`|no|no|no|yes|no|no|no|no|yes***|  \n|`Markup**`|yes|no|no|yes|no|no|no|no|no|  \n|`EntityReference`|no|no|no|yes|yes|no|no|no|yes|  \n  \n \\* The XmlDeclaration node must be the first child of the Document node.  \n  \n ** Markup includes ProcessingInstruction and Comment nodes.  \n  \n *** Element and CDATA nodes are only allowed in EntityReference nodes when the EntityReference node is not a child of an Attribute node.  \n  \n **** Attributes are not children of an Element node. Attributes are contained inside an attribute collection that belongs to the Element node.  \n  \n This method is a Microsoft extension to the Document Object Model (DOM)."
  example:
  - "The following example adds a new element to the document.  \n  \n [!code-vb[Classic WebData XmlDocument.CreateNode2 Example#1](~/add/codesnippet/visualbasic/9b485b37-d267-4da7-a8ac-_1.vb)]\n [!code-cpp[Classic WebData XmlDocument.CreateNode2 Example#1](~/add/codesnippet/cpp/9b485b37-d267-4da7-a8ac-_1.cpp)]\n [!code-cs[Classic WebData XmlDocument.CreateNode2 Example#1](~/add/codesnippet/csharp/9b485b37-d267-4da7-a8ac-_1.cs)]"
  syntax:
    content: public virtual System.Xml.XmlNode CreateNode (System.Xml.XmlNodeType type, string prefix, string name, string namespaceURI);
    parameters:
    - id: type
      type: System.Xml.XmlNodeType
      description: "<xref uid=&quot;langword_csharp_XmlNodeType&quot; name=&quot;XmlNodeType&quot; href=&quot;&quot;> </xref>新节点。"
    - id: prefix
      type: System.String
      description: "新节点的前缀。"
    - id: name
      type: System.String
      description: "新节点的本地名称。"
    - id: namespaceURI
      type: System.String
      description: "命名空间的新节点的 URI。"
    return:
      type: System.Xml.XmlNode
      description: "The new <xref uid=&quot;langword_csharp_XmlNode&quot; name=&quot;XmlNode&quot; href=&quot;&quot;></xref>."
  overload: System.Xml.XmlDocument.CreateNode*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "未提供名称和<xref uid=&quot;langword_csharp_XmlNodeType&quot; name=&quot;XmlNodeType&quot; href=&quot;&quot;></xref>需要名称。"
  platform:
  - net462
- uid: System.Xml.XmlDocument.CreateProcessingInstruction(System.String,System.String)
  id: CreateProcessingInstruction(System.String,System.String)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: CreateProcessingInstruction(String,String)
  nameWithType: XmlDocument.CreateProcessingInstruction(String,String)
  fullName: System.Xml.XmlDocument.CreateProcessingInstruction(String,String)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "创建<xref href=&quot;System.Xml.XmlProcessingInstruction&quot;></xref>具有指定的名称和数据。"
  remarks: "尽管此方法在文档的上下文中创建新的对象，它不会自动添加新的对象到文档树。 若要添加新的对象，必须显式调用的节点插入方法之一。       根据 W3C 可扩展标记语言 (XML) 1.0 建议 (www.w3.org/TR/1998/REC-xml-19980210) 中，ProcessingInstruction 节点时，只允许在文档、 元素和 EntityReference 节点内 EntityReference 节点不是属性节点的子级。"
  example:
  - "The following example creates a ProcessingInstruction node and adds it to the document.  \n  \n [!code-cpp[Classic WebData XmlDocument.CreateProcessingInstruction Example#1](~/add/codesnippet/cpp/b628e59c-914d-4083-89f5-_1.cpp)]\n [!code-vb[Classic WebData XmlDocument.CreateProcessingInstruction Example#1](~/add/codesnippet/visualbasic/b628e59c-914d-4083-89f5-_1.vb)]\n [!code-cs[Classic WebData XmlDocument.CreateProcessingInstruction Example#1](~/add/codesnippet/csharp/b628e59c-914d-4083-89f5-_1.cs)]"
  syntax:
    content: public virtual System.Xml.XmlProcessingInstruction CreateProcessingInstruction (string target, string data);
    parameters:
    - id: target
      type: System.String
      description: "处理指令的名称。"
    - id: data
      type: System.String
      description: "处理指令的数据。"
    return:
      type: System.Xml.XmlProcessingInstruction
      description: "The new <xref uid=&quot;langword_csharp_XmlProcessingInstruction&quot; name=&quot;XmlProcessingInstruction&quot; href=&quot;&quot;></xref>."
  overload: System.Xml.XmlDocument.CreateProcessingInstruction*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.CreateSignificantWhitespace(System.String)
  id: CreateSignificantWhitespace(System.String)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: CreateSignificantWhitespace(String)
  nameWithType: XmlDocument.CreateSignificantWhitespace(String)
  fullName: System.Xml.XmlDocument.CreateSignificantWhitespace(String)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "创建<xref href=&quot;System.Xml.XmlSignificantWhitespace&quot;></xref>节点。"
  remarks: "此方法是 Microsoft 扩展到文档对象模型 (DOM)。 你想要手动设置你的文档的格式时使用。       尽管此方法在文档的上下文中创建新的对象，它不会自动添加新的对象到文档树。 若要添加新的对象，必须显式调用的节点插入方法之一。"
  example:
  - "The following example adds significant white space to the document.  \n  \n [!code-cpp[Classic WebData XmlDocument.CreateSignificantWhitespace Example#1](~/add/codesnippet/cpp/m-system.xml.xmldocument_24_1.cpp)]\n [!code-cs[Classic WebData XmlDocument.CreateSignificantWhitespace Example#1](~/add/codesnippet/csharp/m-system.xml.xmldocument_24_1.cs)]\n [!code-vb[Classic WebData XmlDocument.CreateSignificantWhitespace Example#1](~/add/codesnippet/visualbasic/m-system.xml.xmldocument_24_1.vb)]"
  syntax:
    content: public virtual System.Xml.XmlSignificantWhitespace CreateSignificantWhitespace (string text);
    parameters:
    - id: text
      type: System.String
      description: "该字符串必须包含以下字符&amp;#20;&amp;#10;&amp;#13; and &amp;#9;"
    return:
      type: System.Xml.XmlSignificantWhitespace
      description: "A new <xref uid=&quot;langword_csharp_XmlSignificantWhitespace&quot; name=&quot;XmlSignificantWhitespace&quot; href=&quot;&quot;></xref> node."
  overload: System.Xml.XmlDocument.CreateSignificantWhitespace*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.CreateTextNode(System.String)
  id: CreateTextNode(System.String)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: CreateTextNode(String)
  nameWithType: XmlDocument.CreateTextNode(String)
  fullName: System.Xml.XmlDocument.CreateTextNode(String)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "创建<xref href=&quot;System.Xml.XmlText&quot;></xref>使用指定的文本。"
  remarks: "尽管此方法在文档的上下文中创建新的对象，它不会自动添加新的对象到文档树。 若要添加新的对象，必须显式调用的节点插入方法之一。       根据 W3C 可扩展标记语言 (XML) 1.0 建议 (www.w3.org/TR/1998/REC-xml-19980210) 中，元素、 属性和 EntityReference 节点中仅允许文本节点。"
  example:
  - "The following example creates a new element and adds it to the document.  \n  \n [!code-cpp[Classic WebData XmlDocument.CreateElement Example#1](~/add/codesnippet/cpp/m-system.xml.xmldocument_3_1.cpp)]\n [!code-cs[Classic WebData XmlDocument.CreateElement Example#1](~/add/codesnippet/csharp/m-system.xml.xmldocument_3_1.cs)]\n [!code-vb[Classic WebData XmlDocument.CreateElement Example#1](~/add/codesnippet/visualbasic/m-system.xml.xmldocument_3_1.vb)]"
  syntax:
    content: public virtual System.Xml.XmlText CreateTextNode (string text);
    parameters:
    - id: text
      type: System.String
      description: "Text 节点的文本。"
    return:
      type: System.Xml.XmlText
      description: "新<xref uid=&quot;langword_csharp_XmlText&quot; name=&quot;XmlText&quot; href=&quot;&quot;></xref>节点。"
  overload: System.Xml.XmlDocument.CreateTextNode*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.CreateWhitespace(System.String)
  id: CreateWhitespace(System.String)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: CreateWhitespace(String)
  nameWithType: XmlDocument.CreateWhitespace(String)
  fullName: System.Xml.XmlDocument.CreateWhitespace(String)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "创建<xref href=&quot;System.Xml.XmlWhitespace&quot;></xref>节点。"
  remarks: "此方法是 Microsoft 扩展到文档对象模型 (DOM)。 你想要手动设置你的文档的格式时使用。       尽管此方法在文档的上下文中创建新的对象，它不会自动添加新的对象到文档树。 若要添加新的对象，必须显式调用的节点插入方法之一。"
  example:
  - "The following example adds white space to the document.  \n  \n [!code-cpp[Classic WebData XmlDocument.CreateWhitespace Example#1](~/add/codesnippet/cpp/m-system.xml.xmldocument_4_1.cpp)]\n [!code-vb[Classic WebData XmlDocument.CreateWhitespace Example#1](~/add/codesnippet/visualbasic/m-system.xml.xmldocument_4_1.vb)]\n [!code-cs[Classic WebData XmlDocument.CreateWhitespace Example#1](~/add/codesnippet/csharp/m-system.xml.xmldocument_4_1.cs)]"
  syntax:
    content: public virtual System.Xml.XmlWhitespace CreateWhitespace (string text);
    parameters:
    - id: text
      type: System.String
      description: "该字符串必须包含以下字符&amp;#20;&amp;#10;&amp;#13; and &amp;#9;"
    return:
      type: System.Xml.XmlWhitespace
      description: "A new <xref uid=&quot;langword_csharp_XmlWhitespace&quot; name=&quot;XmlWhitespace&quot; href=&quot;&quot;></xref> node."
  overload: System.Xml.XmlDocument.CreateWhitespace*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.CreateXmlDeclaration(System.String,System.String,System.String)
  id: CreateXmlDeclaration(System.String,System.String,System.String)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: CreateXmlDeclaration(String,String,String)
  nameWithType: XmlDocument.CreateXmlDeclaration(String,String,String)
  fullName: System.Xml.XmlDocument.CreateXmlDeclaration(String,String,String)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "创建<xref href=&quot;System.Xml.XmlDeclaration&quot;></xref>用指定的值的节点。"
  remarks: "该属性公开为特殊属性上`XmlDeclaration`节点，而不是作为<xref:System.Xml.XmlAttribute>节点。</xref:System.Xml.XmlAttribute>       尽管此方法在文档的上下文中创建新的对象，它不会自动添加新的对象到文档树。 若要添加新的对象，必须显式调用的节点插入方法之一。       根据 W3C 可扩展标记语言 (XML) 1.0 建议 (www.w3.org/TR/1998/REC-xml-19980210)`XmlDeclaration`节点必须是在文档中的第一个节点。       此方法是 Microsoft 扩展到文档对象模型 (DOM)。"
  example:
  - "The following example creates an XML declaration and adds it to the document.  \n  \n [!code-cs[Classic WebData XmlDocument.CreateXmlDeclaration Example#1](~/add/codesnippet/csharp/89cf6f87-55c5-4c7d-9c11-_1.cs)]\n [!code-cpp[Classic WebData XmlDocument.CreateXmlDeclaration Example#1](~/add/codesnippet/cpp/89cf6f87-55c5-4c7d-9c11-_1.cpp)]\n [!code-vb[Classic WebData XmlDocument.CreateXmlDeclaration Example#1](~/add/codesnippet/visualbasic/89cf6f87-55c5-4c7d-9c11-_1.vb)]"
  syntax:
    content: public virtual System.Xml.XmlDeclaration CreateXmlDeclaration (string version, string encoding, string standalone);
    parameters:
    - id: version
      type: System.String
      description: "版本必须为&quot;1.0&quot;。"
    - id: encoding
      type: System.String
      description: "编码属性的值。 这是你在保存时使用的编码<xref href=&quot;System.Xml.XmlDocument&quot;></xref>到一个文件或流; 因此，它必须设置为支持的字符串<xref:System.Text.Encoding>类，否则为<xref:System.Xml.XmlDocument.Save*>失败。</xref:System.Xml.XmlDocument.Save*> </xref:System.Text.Encoding> 如果这是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>或 String.Empty， <xref uid=&quot;langword_csharp_Save&quot; name=&quot;Save&quot; href=&quot;&quot;> </xref>方法不在 XML 声明上写出编码方式特性，因此使用默认的编码方式 utf-8。       注意︰ 如果<xref uid=&quot;langword_csharp_XmlDocument&quot; name=&quot;XmlDocument&quot; href=&quot;&quot;></xref>保存到<xref:System.IO.TextWriter>或<xref:System.Xml.XmlTextWriter>，则放弃该编码值。</xref:System.Xml.XmlTextWriter> </xref:System.IO.TextWriter> 相反，编码的<xref uid=&quot;langword_csharp_TextWriter&quot; name=&quot;TextWriter&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_XmlTextWriter&quot; name=&quot;XmlTextWriter&quot; href=&quot;&quot;></xref>使用。 这会确保可以使用正确的编码读写出的 XML。"
    - id: standalone
      type: System.String
      description: "值必须是&quot;yes&quot;否&quot;。 如果这是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>或 String.Empty， <xref uid=&quot;langword_csharp_Save&quot; name=&quot;Save&quot; href=&quot;&quot;> </xref>方法不在 XML 声明上写出独立特性。"
    return:
      type: System.Xml.XmlDeclaration
      description: "新<xref uid=&quot;langword_csharp_XmlDeclaration&quot; name=&quot;XmlDeclaration&quot; href=&quot;&quot;></xref>节点。"
  overload: System.Xml.XmlDocument.CreateXmlDeclaration*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "值<code> version </code>或<code> standalone </code>是除上面指定的内容。"
  platform:
  - net462
- uid: System.Xml.XmlDocument.DocumentElement
  id: DocumentElement
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: DocumentElement
  nameWithType: XmlDocument.DocumentElement
  fullName: System.Xml.XmlDocument.DocumentElement
  type: Property
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "获取根<xref href=&quot;System.Xml.XmlElement&quot;></xref>文档。"
  remarks: ''
  example:
  - "The following example displays the root element of the XML document.  \n  \n [!code-cs[Classic WebData XmlDocument.DocumentElement Example#1](~/add/codesnippet/csharp/p-system.xml.xmldocument_8_1.cs)]\n [!code-cpp[Classic WebData XmlDocument.DocumentElement Example#1](~/add/codesnippet/cpp/p-system.xml.xmldocument_8_1.cpp)]\n [!code-vb[Classic WebData XmlDocument.DocumentElement Example#1](~/add/codesnippet/visualbasic/p-system.xml.xmldocument_8_1.vb)]  \n  \n **Output:**  \n  \n```  \n<book genre=\"novel\" ISBN=\"1-861001-57-5\"><title>Pride And Prejudice</title></book>   \n```"
  syntax:
    content: public System.Xml.XmlElement DocumentElement { get; }
    return:
      type: System.Xml.XmlElement
      description: "<xref uid=&quot;langword_csharp_XmlElement&quot; name=&quot;XmlElement&quot; href=&quot;&quot;> </xref>表示的 XML 文档树的根。 如果不存在根， <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>返回。"
  overload: System.Xml.XmlDocument.DocumentElement*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.DocumentType
  id: DocumentType
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: DocumentType
  nameWithType: XmlDocument.DocumentType
  fullName: System.Xml.XmlDocument.DocumentType
  type: Property
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "获取包含 DOCTYPE 声明的节点。"
  remarks: "`XmlDocument`只能有一个且仅有一个子与<xref:System.Xml.XmlNodeType>等于 DocumentType。</xref:System.Xml.XmlNodeType>      1> [!NOTE]&1;> 此属性是只读的。 若要更改 DocumentType 节点，删除现有节点，创建一个新的一个使用<xref:System.Xml.XmlDocument.CreateDocumentType%2A>方法，并将新节点添加到文档。</xref:System.Xml.XmlDocument.CreateDocumentType%2A>"
  example:
  - "The following example gets and displays the DOCTYPE declaration for the document.  \n  \n [!code-cpp[Classic WebData XmlDocument.DocumentType Example#1](~/add/codesnippet/cpp/p-system.xml.xmldocument_4_1.cpp)]\n [!code-cs[Classic WebData XmlDocument.DocumentType Example#1](~/add/codesnippet/csharp/p-system.xml.xmldocument_4_1.cs)]\n [!code-vb[Classic WebData XmlDocument.DocumentType Example#1](~/add/codesnippet/visualbasic/p-system.xml.xmldocument_4_1.vb)]"
  syntax:
    content: public virtual System.Xml.XmlDocumentType DocumentType { get; }
    return:
      type: System.Xml.XmlDocumentType
      description: "<xref href=&quot;System.Xml.XmlNode&quot;> </xref>包含 DocumentType （DOCTYPE 声明）。"
  overload: System.Xml.XmlDocument.DocumentType*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.GetElementById(System.String)
  id: GetElementById(System.String)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: GetElementById(String)
  nameWithType: XmlDocument.GetElementById(String)
  fullName: System.Xml.XmlDocument.GetElementById(String)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "获取<xref href=&quot;System.Xml.XmlElement&quot;></xref>替换为指定的 id。"
  remarks: "如果文档包含具有匹配 ID 的多个元素，此方法将返回文档中的第一个匹配元素。      1> [!NOTE]&1;> DOM 实现必须具有信息定义哪些属性属于类型 id。 虽然可以在 XSD 架构或 Dtd 中定义的类型 ID 的属性，但此版本的产品仅支持那些 Dtd 中定义。 具有&quot;ID&quot;不是名称的属性类型 ID，除非因此 DTD 中定义。 其中是未知的类型 ID 是否包含以下属性的实现都应该返回`null`。"
  example:
  - "The following example uses the `GetElementById` method.  \n  \n [!code-cs[Classic WebData XmlDocument.GetElementById Example#1](~/add/codesnippet/csharp/m-system.xml.xmldocument_20_1.cs)]\n [!code-cpp[Classic WebData XmlDocument.GetElementById Example#1](~/add/codesnippet/cpp/m-system.xml.xmldocument_20_1.cpp)]\n [!code-vb[Classic WebData XmlDocument.GetElementById Example#1](~/add/codesnippet/visualbasic/m-system.xml.xmldocument_20_1.vb)]  \n  \n The example uses the file, `ids.xml`, as input.  \n  \n```xml  \n<!DOCTYPE root [  \n  <!ELEMENT root ANY>   \n  <!ELEMENT Person ANY>   \n  <!ELEMENT Customer EMPTY>  \n  <!ELEMENT Team EMPTY>  \n  <!ATTLIST Person SSN ID #REQUIRED>  \n  <!ATTLIST Customer id IDREF #REQUIRED >  \n  <!ATTLIST Team members IDREFS #REQUIRED>]>  \n<root>  \n  <Person SSN='A111' Name='Fred'/>  \n  <Person SSN='A222' Name='Tom'/>  \n  <Customer id='A222334444'/>  \n  <Team members='A222334444 A333445555'/>  \n</root>  \n```"
  syntax:
    content: public virtual System.Xml.XmlElement GetElementById (string elementId);
    parameters:
    - id: elementId
      type: System.String
      description: "要匹配的属性 ID。"
    return:
      type: System.Xml.XmlElement
      description: "<xref uid=&quot;langword_csharp_XmlElement&quot; name=&quot;XmlElement&quot; href=&quot;&quot;> </xref>具有匹配 ID 或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果不找到任何匹配元素。"
  overload: System.Xml.XmlDocument.GetElementById*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.GetElementsByTagName(System.String)
  id: GetElementsByTagName(System.String)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: GetElementsByTagName(String)
  nameWithType: XmlDocument.GetElementsByTagName(String)
  fullName: System.Xml.XmlDocument.GetElementsByTagName(String)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "返回<xref href=&quot;System.Xml.XmlNodeList&quot;></xref>包含匹配的指定<xref:System.Xml.XmlDocument.Name*>。</xref:System.Xml.XmlDocument.Name*>的所有子代元素的列表"
  remarks: "将文档中遇到的顺序放置这些节点。      1> [!NOTE]&1;> 建议你使用<xref:System.Xml.XmlNode.SelectNodes%2A?displayProperty=fullName>或<xref:System.Xml.XmlNode.SelectSingleNode%2A?displayProperty=fullName>方法而非 GetElementsByTagName 方法。</xref:System.Xml.XmlNode.SelectSingleNode%2A?displayProperty=fullName> </xref:System.Xml.XmlNode.SelectNodes%2A?displayProperty=fullName>"
  example:
  - "The following example creates a `XmlDocument` object and uses the `GetElementsByTagName` method and the resulting <xref:System.Xml.XmlNodeList> object to display all the book titles.  \n  \n [!code-cs[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/add/codesnippet/csharp/m-system.xml.xmldocument_10_1.cs)]\n [!code-cpp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/add/codesnippet/cpp/m-system.xml.xmldocument_10_1.cpp)]\n [!code-vb[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/add/codesnippet/visualbasic/m-system.xml.xmldocument_10_1.vb)]  \n  \n The example uses the `books.xml` file as input.  \n  \n [!code-xml[Classic WebData XslTransform.Transform7 Example#2](~/add/codesnippet/xml/m-system.xml.xmldocument_10_2.xml)]"
  syntax:
    content: public virtual System.Xml.XmlNodeList GetElementsByTagName (string name);
    parameters:
    - id: name
      type: System.String
      description: "要匹配的限定的名称。 它针对匹配<xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref>匹配节点的属性。 特殊值&quot;*&quot;匹配所有标记。"
    return:
      type: System.Xml.XmlNodeList
      description: "<xref href=&quot;System.Xml.XmlNodeList&quot;> </xref>包含所有匹配节点的列表。 如果没有任何节点与<code> name </code>，返回的集合将为空。"
  overload: System.Xml.XmlDocument.GetElementsByTagName*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.GetElementsByTagName(System.String,System.String)
  id: GetElementsByTagName(System.String,System.String)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: GetElementsByTagName(String,String)
  nameWithType: XmlDocument.GetElementsByTagName(String,String)
  fullName: System.Xml.XmlDocument.GetElementsByTagName(String,String)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "返回<xref href=&quot;System.Xml.XmlNodeList&quot;></xref>包含匹配指定的所有子代元素的列表<> *1> 和<> *1>。"
  remarks: "将在文档树中遇到的顺序放置这些节点。      1> [!NOTE]&1;> 建议你使用<xref:System.Xml.XmlNode.SelectNodes%2A?displayProperty=fullName>或<xref:System.Xml.XmlNode.SelectSingleNode%2A?displayProperty=fullName>方法而非 GetElementsByTagName 方法。</xref:System.Xml.XmlNode.SelectSingleNode%2A?displayProperty=fullName> </xref:System.Xml.XmlNode.SelectNodes%2A?displayProperty=fullName>"
  syntax:
    content: public virtual System.Xml.XmlNodeList GetElementsByTagName (string localName, string namespaceURI);
    parameters:
    - id: localName
      type: System.String
      description: "要匹配的 LocalName。 特殊值&quot;*&quot;匹配所有标记。"
    - id: namespaceURI
      type: System.String
      description: "要匹配的 NamespaceURI。"
    return:
      type: System.Xml.XmlNodeList
      description: "<xref href=&quot;System.Xml.XmlNodeList&quot;> </xref>包含所有匹配节点的列表。 如果没有任何节点与指定<code> localName </code>和<code> namespaceURI </code>，返回的集合将为空。"
  overload: System.Xml.XmlDocument.GetElementsByTagName*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.Implementation
  id: Implementation
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: Implementation
  nameWithType: XmlDocument.Implementation
  fullName: System.Xml.XmlDocument.Implementation
  type: Property
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "获取<xref href=&quot;System.Xml.XmlImplementation&quot;></xref>当前文档的对象。"
  remarks: "`XmlDocument`创建从同一个对象`XmlImplementation`共享相同的<xref:System.Xml.XmlNameTable>.</xref:System.Xml.XmlNameTable> 这样用户就可以为对象，而不是字符串比较属性和元素的名称。       尽管`XmlDocument`对象共享相同的实现，若要将节点从一个文档移到另一个必须使用<xref:System.Xml.XmlDocument.ImportNode%2A>方法。</xref:System.Xml.XmlDocument.ImportNode%2A>"
  example:
  - "The following example creates a new `XmlDocument` using another document's implementation.  \n  \n [!code-cs[Classic WebData XmlDocument.Implementation Example#1](~/add/codesnippet/csharp/p-system.xml.xmldocument_11_1.cs)]\n [!code-cpp[Classic WebData XmlDocument.Implementation Example#1](~/add/codesnippet/cpp/p-system.xml.xmldocument_11_1.cpp)]\n [!code-vb[Classic WebData XmlDocument.Implementation Example#1](~/add/codesnippet/visualbasic/p-system.xml.xmldocument_11_1.vb)]"
  syntax:
    content: public System.Xml.XmlImplementation Implementation { get; }
    return:
      type: System.Xml.XmlImplementation
      description: "<xref uid=&quot;langword_csharp_XmlImplementation&quot; name=&quot;XmlImplementation&quot; href=&quot;&quot;> </xref>当前文档的对象。"
  overload: System.Xml.XmlDocument.Implementation*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.ImportNode(System.Xml.XmlNode,System.Boolean)
  id: ImportNode(System.Xml.XmlNode,System.Boolean)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: ImportNode(XmlNode,Boolean)
  nameWithType: XmlDocument.ImportNode(XmlNode,Boolean)
  fullName: System.Xml.XmlDocument.ImportNode(XmlNode,Boolean)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "将节点从另一个文档导入到当前文档。"
  remarks: "返回的节点都有没有父级。 源节点未更改或删除从原始文档;`ImportNode`创建源节点的副本。       导入节点创建`XmlNode`对象拥有的导入的文档，与<xref:System.Xml.XmlNode.Name%2A>和<xref:System.Xml.XmlNode.NodeType%2A>与源节点相同。</xref:System.Xml.XmlNode.NodeType%2A> </xref:System.Xml.XmlNode.Name%2A> 新对象还具有与命名空间相关的属性 (<xref:System.Xml.XmlNode.Prefix%2A>， <xref:System.Xml.XmlNode.LocalName%2A>，和<xref:System.Xml.XmlNode.NamespaceURI%2A>)。</xref:System.Xml.XmlNode.NamespaceURI%2A> </xref:System.Xml.XmlNode.LocalName%2A> </xref:System.Xml.XmlNode.Prefix%2A>       具体取决于导入的节点和值的节点类型`deep`将复制适当的参数，其他信息。 此方法尝试的镜像预期的行为，如果 XML 或 HTML 源代码片断从一个文档复制到另一个 （认识到，在 XML 的情况下，两个文档可能具有不同 Dtd）。       下表描述了每个<xref:System.Xml.XmlNodeType>.</xref:System.Xml.XmlNodeType>的特定行为      |XmlNodeType |ImportNode(true) |ImportNode(false) |  |-----------------|------------------------|-------------------------|  |属性 |<xref:System.Xml.XmlAttribute.Specified%2A>属性设置为`true`生成<xref:System.Xml.XmlAttribute>。</xref:System.Xml.XmlAttribute> </xref:System.Xml.XmlAttribute.Specified%2A> 后代中的源`XmlAttribute`以递归方式导入和生成的节点重新合并以形成相应的子树。 |`deep`参数不适用于`XmlAttribute`节点; 它们始终会包含在导入时其子级。 |  |CData |将复制该节点，包括其数据。 |将复制该节点，包括其数据。 |  |注释 |将复制该节点，包括其数据。 |将复制该节点，包括其数据。 |  |DocumentFragment |源节点的后代是以递归方式导入和生成的节点重新合并以形成相应的子树。 |生成空<xref:System.Xml.XmlDocumentFragment>。 |  |DocumentType |将复制该节点，包括其数据。*|将复制该节点，包括其数据。*|  |元素 |源元素和其指定的属性节点的后代是以递归方式导入和生成的节点重新合并以形成相应的子树。</xref:System.Xml.XmlDocumentFragment><br /><br /> 注意︰ 不复制默认属性。 如果导入到的文档定义该元素名称的默认属性，则分配这些。 |指定的属性导入源元素的节点，并将生成`XmlAttribute`节点附加到生成<xref:System.Xml.XmlElement>。</xref:System.Xml.XmlElement><br /><br /> 注意︰ 不复制默认属性。 如果导入到的文档定义该元素名称的默认属性，则分配这些。 |  |EntityReference |因为源和目标文档可能以不同方式定义实体，该方法仅复制<xref:System.Xml.XmlEntityReference>节点。</xref:System.Xml.XmlEntityReference> 不包括替换文本。 如果目标文档定义了实体，它赋值。 |因为源和目标文档可能以不同方式定义实体，该方法仅复制<xref:System.Xml.XmlEntityReference>节点。</xref:System.Xml.XmlEntityReference> 不包括替换文本。 如果目标文档定义了实体，它赋值。 |  |ProcessingInstruction |从导入的节点复制目标和数据值。 |从导入的节点复制目标和数据值。 |  |文本 |将复制该节点，包括其数据。 |将复制该节点，包括其数据。 |  |SignificantWhitespace |将复制该节点，包括其数据。 |将复制该节点，包括其数据。 |  |空白 |将复制该节点，包括其数据。 |将复制该节点，包括其数据。 |  |XmlDeclaration |从导入的节点复制目标和数据值。 |从导入的节点复制目标和数据值。 |  |所有其他节点类型。 |无法导入这些节点类型。 |无法导入这些节点类型。 |      * 尽管可以导入 DocumentType 节点，文档只能有一个 DocumentType。 如果该文档当前具有 DocumenType 节点，则它必须删除然后再添加一个新。"
  example:
  - "The following example imports a book node from a second XML document into the original XML document.  \n  \n [!code-vb[Classic WebData XmlDocument.ImportNode Example#1](~/add/codesnippet/visualbasic/m-system.xml.xmldocument_22_1.vb)]\n [!code-cpp[Classic WebData XmlDocument.ImportNode Example#1](~/add/codesnippet/cpp/m-system.xml.xmldocument_22_1.cpp)]\n [!code-cs[Classic WebData XmlDocument.ImportNode Example#1](~/add/codesnippet/csharp/m-system.xml.xmldocument_22_1.cs)]  \n  \n The example uses the file, `books.xml`, as input.  \n  \n [!code-xml[Classic WebData XslTransform.Transform7 Example#2](~/add/codesnippet/xml/m-system.xml.xmldocument_22_2.xml)]"
  syntax:
    content: public virtual System.Xml.XmlNode ImportNode (System.Xml.XmlNode node, bool deep);
    parameters:
    - id: node
      type: System.Xml.XmlNode
      description: "正在导入的节点。"
    - id: deep
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要执行深层克隆，则否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.Xml.XmlNode
      description: "导入<xref href=&quot;System.Xml.XmlNode&quot;> </xref>。"
  overload: System.Xml.XmlDocument.ImportNode*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "无法导入的节点类型上调用此方法。"
  platform:
  - net462
- uid: System.Xml.XmlDocument.InnerText
  id: InnerText
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: InnerText
  nameWithType: XmlDocument.InnerText
  fullName: System.Xml.XmlDocument.InnerText
  type: Property
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "引发<xref:System.InvalidOperationException>在所有情况下。</xref:System.InvalidOperationException>"
  remarks: "未实现此属性。"
  syntax:
    content: public override string InnerText { set; }
    return:
      type: System.String
      description: "节点及其所有子节点的值。"
  overload: System.Xml.XmlDocument.InnerText*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "在所有情况下。"
  platform:
  - net462
- uid: System.Xml.XmlDocument.InnerXml
  id: InnerXml
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: InnerXml
  nameWithType: XmlDocument.InnerXml
  fullName: System.Xml.XmlDocument.InnerXml
  type: Property
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "获取或设置表示当前节点的子级的标记。"
  remarks: "将此属性设置给定字符串的已分析内容替换节点的子级。 分析在当前命名空间上下文中完成。       `InnerXml`删除多余的命名空间声明。 结果，大量的剪切和粘贴操作并不使增加多余的命名空间声明与文档的大小。 请考虑以下 XSL 文档︰ ```   <xsl:stylesheet version=&quot;1.0&quot;          xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;>        <xsl:template match=&quot;stock&quot;>            ...        </xsl:template>       </xsl:stylesheet>   ``` `InnerXml`样式表节点上的属性将返回以下字符串︰```   <xsl:template match=&quot;stock&quot;          xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;>        ...       </xsl:template>   ```请注意其他 xmlns:xsl 命名空间声明用于保留节点标识。 如果你重新插入此内部的 XML 字符串，将获取原始文档。 换而言之，`InnerXml`意识到 xmlns:xsl 命名空间声明是冗余的假设父 xsl:stylesheet 元素已具有 xmlns:xsl 命名空间 delcaration，并将其删除。       如果移动`InnerXml`从具有向文档没有默认命名空间与默认命名空间的文档，则行为是稍有不同。 请考虑以下 XML 字符串︰ ```   <test>         <item>123</item>       </test>   ``` `InnerXml`返回没有命名空间声明的纯 XML 字符串︰```   <item>123</item>   ```如果你然后将此字符串插入文档中没有默认命名空间，如下所示︰ ```   <test2 xmlns=&quot;urn:1&quot;>       </test>   ``` `InnerXml`分析在上下文中，字符串和新节点选取 urn:&1; 命名空间。               结果如下所示︰```   <test2 xmlns=&quot;urn:1&quot;>         <item>123</item>       </test>   ```现在当你请求`InnerXml`取回以下︰```   <item xmlns=&quot;urn:1&quot;>123</item>   ```是否显式插入的项，要记住这一点，它是来自于文档具有不在命名空间，则需要手动添加 xmlns =&quot;&quot;声明和插入结果的字符串︰```   <item xmlns=&quot;&quot;>123</item>   ```所有这些操作，如下所示的净效果︰ 1。  剪切和粘贴`InnerXml`在不使用的文档之间命名空间是干净、 简单和不会在您的字符串创建&quot;xmlns&quot;冗余。      2.  `InnerXml`此外可进行剪切和粘贴之间具有多个命名空间 （即 XSL 样式表） 的文档。      3.  xmlns:xsl 声明自动显示在您的字符串，在节点层次结构中消失。      4.  在你所在移动的情况下`InnerXml`具有默认命名空间的文档没有默认命名空间的文档，新的节点会选取新的默认命名空间。       如果`InnerXml`设置与文本包含不在文档中当前定义的实体引用，生成的树将包含空 EntityReference 节点。       此属性是 Microsoft 扩展到文档对象模型 (DOM)。"
  syntax:
    content: public override string InnerXml { get; set; }
    return:
      type: System.String
      description: "当前节点的子级的标记。"
  overload: System.Xml.XmlDocument.InnerXml*
  exceptions:
  - type: System.Xml.XmlException
    commentId: T:System.Xml.XmlException
    description: "将指定的 XML，当设置此属性不是格式良好。"
  platform:
  - net462
- uid: System.Xml.XmlDocument.IsReadOnly
  id: IsReadOnly
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: IsReadOnly
  nameWithType: XmlDocument.IsReadOnly
  fullName: System.Xml.XmlDocument.IsReadOnly
  type: Property
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "获取一个值，该值指示当前节点是否只读的。"
  remarks: "只读节点是一个无法更改其属性、 属性或子级。 你可以从树中删除只读节点，并将它的其他位置。       此属性是 Microsoft 扩展到文档对象模型 (DOM)。"
  example:
  - "The following example shows how to use the `IsReadOnly` property.  \n  \n [!code-cs[Classic WebData XmlDocument.IsReadOnly Example#1](~/add/codesnippet/csharp/p-system.xml.xmldocument_7_1.cs)]\n [!code-cpp[Classic WebData XmlDocument.IsReadOnly Example#1](~/add/codesnippet/cpp/p-system.xml.xmldocument_7_1.cpp)]\n [!code-vb[Classic WebData XmlDocument.IsReadOnly Example#1](~/add/codesnippet/visualbasic/p-system.xml.xmldocument_7_1.vb)]"
  syntax:
    content: public override bool IsReadOnly { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果当前节点是只读的;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 <xref uid=&quot;langword_csharp_XmlDocument&quot; name=&quot;XmlDocument&quot; href=&quot;&quot;></xref>节点始终返回<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Xml.XmlDocument.IsReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.Load(System.IO.Stream)
  id: Load(System.IO.Stream)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: Load(Stream)
  nameWithType: XmlDocument.Load(Stream)
  fullName: System.Xml.XmlDocument.Load(Stream)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "从指定的流加载 XML 文档。"
  remarks: "> [!NOTE]1>`Load`方法总是保留有效空白。 <xref:System.Xml.XmlDocument.PreserveWhitespace%2A>属性确定是否保留无关紧要的空白区域，即元素内容中的空白区域。</xref:System.Xml.XmlDocument.PreserveWhitespace%2A> 默认值是`false`; 元素内容中的空白区域不会保留。       如果你想要进行验证，你可以创建一个验证<xref:System.Xml.XmlReader>实例使用<xref:System.Xml.XmlReaderSettings>类和<xref:System.Xml.XmlReader.Create%2A>方法。</xref:System.Xml.XmlReader.Create%2A> </xref:System.Xml.XmlReaderSettings> </xref:System.Xml.XmlReader> 有关详细信息，请参阅备注部分的<xref:System.Xml.XmlReader>引用页。</xref:System.Xml.XmlReader>       此方法是 Microsoft 扩展到文档对象模型 (DOM)。       此方法会自动检测输入 （例如，utf-8、 ANSI，等） 的 XML 的字符串格式。 如果你的应用程序需要知道用于读取的流的编码，请考虑使用<xref:System.Xml.XmlTextReader>要读取的流对象，然后使用<xref:System.Xml.XmlTextReader.Encoding%2A?displayProperty=fullName>属性来确定编码。</xref:System.Xml.XmlTextReader.Encoding%2A?displayProperty=fullName> </xref:System.Xml.XmlTextReader> 如果你需要使用<xref:System.Xml.XmlDocument>对象处理的 XML，可以使用<xref:System.Xml.XmlTextReader>对象创建一个。</xref:System.Xml.XmlTextReader> </xref:System.Xml.XmlDocument> 有关详细信息，请参阅[使用了 XPathDocument 和 XmlDocument 读取 XML 数据](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public virtual void Load (System.IO.Stream inStream);
    parameters:
    - id: inStream
      type: System.IO.Stream
      description: "包含要加载的 XML 文档的流。"
  overload: System.Xml.XmlDocument.Load*
  exceptions:
  - type: System.Xml.XmlException
    commentId: T:System.Xml.XmlException
    description: "在 XML 中没有加载或分析错误。 在这种情况下，<xref:System.IO.FileNotFoundException>引发。</xref:System.IO.FileNotFoundException>"
  platform:
  - net462
- uid: System.Xml.XmlDocument.Load(System.IO.TextReader)
  id: Load(System.IO.TextReader)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: Load(TextReader)
  nameWithType: XmlDocument.Load(TextReader)
  fullName: System.Xml.XmlDocument.Load(TextReader)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "从指定的<xref:System.IO.TextReader>.</xref:System.IO.TextReader>加载 XML 文档"
  remarks: "> [!NOTE]1>`Load`方法总是保留有效空白。 <xref:System.Xml.XmlDocument.PreserveWhitespace%2A>属性确定是否保留无关紧要的空白区域，即元素内容中的空白区域。</xref:System.Xml.XmlDocument.PreserveWhitespace%2A> 默认值是`false`; 元素内容中的空白区域不会保留。       如果你想要进行验证，你可以创建一个验证<xref:System.Xml.XmlReader>实例使用<xref:System.Xml.XmlReaderSettings>类和<xref:System.Xml.XmlReader.Create%2A>方法。</xref:System.Xml.XmlReader.Create%2A> </xref:System.Xml.XmlReaderSettings> </xref:System.Xml.XmlReader> 有关详细信息，请参阅备注部分的<xref:System.Xml.XmlReader>引用页。</xref:System.Xml.XmlReader>       此方法是 Microsoft 扩展到文档对象模型 (DOM)。"
  example:
  - "The following example uses the <xref:System.IO.StringReader> class to load a string of XML data into the `XmlDocument` object.  \n  \n [!code-cs[Classic WebData XmlDocument.CreateElement2 Example#1](~/add/codesnippet/csharp/m-system.xml.xmldocument_8_1.cs)]\n [!code-vb[Classic WebData XmlDocument.CreateElement2 Example#1](~/add/codesnippet/visualbasic/m-system.xml.xmldocument_8_1.vb)]\n [!code-cpp[Classic WebData XmlDocument.CreateElement2 Example#1](~/add/codesnippet/cpp/m-system.xml.xmldocument_8_1.cpp)]"
  syntax:
    content: public virtual void Load (System.IO.TextReader txtReader);
    parameters:
    - id: txtReader
      type: System.IO.TextReader
      description: "<xref uid=&quot;langword_csharp_TextReader&quot; name=&quot;TextReader&quot; href=&quot;&quot;> </xref>用于将 XML 数据输送到文档中。"
  overload: System.Xml.XmlDocument.Load*
  exceptions:
  - type: System.Xml.XmlException
    commentId: T:System.Xml.XmlException
    description: "在 XML 中没有加载或分析错误。 在这种情况下，文档保留为空。"
  platform:
  - net462
- uid: System.Xml.XmlDocument.Load(System.String)
  id: Load(System.String)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: Load(String)
  nameWithType: XmlDocument.Load(String)
  fullName: System.Xml.XmlDocument.Load(String)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "从指定的 URL 加载 XML 文档。"
  remarks: "> [!NOTE]1>`Load`方法总是保留有效空白。 <xref:System.Xml.XmlDocument.PreserveWhitespace%2A>属性确定是否保留无关紧要的空白区域，即元素内容中的空白区域。</xref:System.Xml.XmlDocument.PreserveWhitespace%2A> 默认值是`false`; 元素内容中的空白区域不会保留。       如果你想要进行验证，你可以创建一个验证<xref:System.Xml.XmlReader>实例使用<xref:System.Xml.XmlReaderSettings>类和<xref:System.Xml.XmlReader.Create%2A>方法。</xref:System.Xml.XmlReader.Create%2A> </xref:System.Xml.XmlReaderSettings> </xref:System.Xml.XmlReader> 有关详细信息，请参阅备注部分的<xref:System.Xml.XmlReader>引用页。</xref:System.Xml.XmlReader>       此方法是 Microsoft 扩展到文档对象模型 (DOM)。"
  syntax:
    content: public virtual void Load (string filename);
    parameters:
    - id: filename
      type: System.String
      description: "要加载包含 XML 文档的文件 URL。 URL 可以是本地文件或 HTTP URL （Web 地址）。"
  overload: System.Xml.XmlDocument.Load*
  exceptions:
  - type: System.Xml.XmlException
    commentId: T:System.Xml.XmlException
    description: "在 XML 中没有加载或分析错误。 在这种情况下，<xref:System.IO.FileNotFoundException>引发。</xref:System.IO.FileNotFoundException>"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>filename</code>是零长度字符串，仅包含空格，或通过定义包含一个或多个无效字符<xref:System.IO.Path.InvalidPathChars>。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>filename</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路径无效 （例如，它位于未映射的驱动器上）。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "打开文件时发生 I/O 错误。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code>filename</code>指定的文件是只读的。       -或者-当前平台上不支持此操作。       -或-<code>filename</code>指定了一个目录。       -或者-调用方没有所要求的权限。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "中指定的文件<code> filename </code>找不到。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>filename</code>是无效的格式。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  platform:
  - net462
- uid: System.Xml.XmlDocument.Load(System.Xml.XmlReader)
  id: Load(System.Xml.XmlReader)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: Load(XmlReader)
  nameWithType: XmlDocument.Load(XmlReader)
  fullName: System.Xml.XmlDocument.Load(XmlReader)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "从指定的<xref:System.Xml.XmlReader>.</xref:System.Xml.XmlReader>加载 XML 文档"
  remarks: "> [!NOTE]1>`Load`方法总是保留有效空白。 <xref:System.Xml.XmlDocument.PreserveWhitespace%2A>属性确定是否保留无关紧要的空白区域，即元素内容中的空白区域。</xref:System.Xml.XmlDocument.PreserveWhitespace%2A> 默认值是`false`; 元素内容中的空白区域不会保留。       如果读取器处于初始状态 (<xref:System.Xml.XmlReader.ReadState%2A> = ReadState.Initial)，`Load`使用读取器的全部内容，并生成从它找到 DOM。</xref:System.Xml.XmlReader.ReadState%2A>       如果读取器已位于深度&quot;n&quot;在某个节点上，此方法将加载该节点和所有后续同级直到关闭&quot;n&quot;深度的结束标记。 这会产生下列结果。       如果当前节点及其同级如下所示︰ ```   <!--comment--><element1>one</element1><element2>two</element2>   ``` `Load`引发异常，因为文档不能有两个根级别元素。        如果当前节点及其同级如下所示︰ ```   <!--comment--><?process instruction?><!--comment--></endtag>   ``` `Load`成功，但你有一个不完整的 DOM 树，因为没有根级别元素。        保存文档之前，你必须添加一个根级别元素，否则<xref:System.Xml.XmlDocument.Save%2A>将引发异常。</xref:System.Xml.XmlDocument.Save%2A>       如果读取器定位于对于文档，例如空白或属性节点的根级别来说无效的叶节点的读取器继续读取，直到其定位在可用于根的节点上。 文档开始此时加载。       如果你想要进行验证，你可以创建一个验证<xref:System.Xml.XmlReader>实例使用<xref:System.Xml.XmlReaderSettings>类和<xref:System.Xml.XmlReader.Create%2A>方法。</xref:System.Xml.XmlReader.Create%2A> </xref:System.Xml.XmlReaderSettings> </xref:System.Xml.XmlReader> 有关详细信息，请参阅备注部分的<xref:System.Xml.XmlReader>引用页。</xref:System.Xml.XmlReader>       此方法是 Microsoft 扩展到文档对象模型 (DOM)。"
  example:
  - "The following example loads the last book node of the `books.xml` file into the XML document.  \n  \n [!code-cs[Classic WebData XmlDocument.Load2 Example#1](~/add/codesnippet/csharp/m-system.xml.xmldocument_23_1.cs)]\n [!code-vb[Classic WebData XmlDocument.Load2 Example#1](~/add/codesnippet/visualbasic/m-system.xml.xmldocument_23_1.vb)]\n [!code-cpp[Classic WebData XmlDocument.Load2 Example#1](~/add/codesnippet/cpp/m-system.xml.xmldocument_23_1.cpp)]  \n  \n The example uses the file, `books.xml`, as input.  \n  \n [!code-xml[Classic WebData XslTransform.Transform7 Example#2](~/add/codesnippet/xml/m-system.xml.xmldocument_23_2.xml)]"
  syntax:
    content: public virtual void Load (System.Xml.XmlReader reader);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "<xref uid=&quot;langword_csharp_XmlReader&quot; name=&quot;XmlReader&quot; href=&quot;&quot;> </xref>用于将 XML 数据输送到文档中。"
  overload: System.Xml.XmlDocument.Load*
  exceptions:
  - type: System.Xml.XmlException
    commentId: T:System.Xml.XmlException
    description: "在 XML 中没有加载或分析错误。 在这种情况下，文档保留为空。"
  platform:
  - net462
- uid: System.Xml.XmlDocument.LoadXml(System.String)
  id: LoadXml(System.String)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: LoadXml(String)
  nameWithType: XmlDocument.LoadXml(String)
  fullName: System.Xml.XmlDocument.LoadXml(String)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "从指定的字符串加载 XML 文档。"
  remarks: "默认情况下`LoadXml`方法不会保留空格或有意义的空白。       此方法分析 Dtd，但不会执行操作 DTD 或架构验证。 如果你想要进行验证，你可以创建一个验证<xref:System.Xml.XmlReader>实例使用<xref:System.Xml.XmlReaderSettings>类和<xref:System.Xml.XmlReader.Create%2A>方法。</xref:System.Xml.XmlReader.Create%2A> </xref:System.Xml.XmlReaderSettings> </xref:System.Xml.XmlReader> 有关详细信息，请参阅备注部分的<xref:System.Xml.XmlReader>引用页。</xref:System.Xml.XmlReader>       如果你想要从加载<xref:System.IO.Stream>， <xref:System.String>， <xref:System.IO.TextReader>，或<xref:System.Xml.XmlReader>，而不是此方法使用的 Load 方法。</xref:System.Xml.XmlReader> </xref:System.IO.TextReader> </xref:System.String> </xref:System.IO.Stream>       此方法是 Microsoft 扩展到文档对象模型 (DOM)。"
  example:
  - "The following example loads XML into an `XmlDocument` object and saves it out to a file.  \n  \n [!code-cpp[Classic WebData XmlDocument.LoadXml Example#1](~/add/codesnippet/cpp/m-system.xml.xmldocument_2_1.cpp)]\n [!code-cs[Classic WebData XmlDocument.LoadXml Example#1](~/add/codesnippet/csharp/m-system.xml.xmldocument_2_1.cs)]\n [!code-vb[Classic WebData XmlDocument.LoadXml Example#1](~/add/codesnippet/visualbasic/m-system.xml.xmldocument_2_1.vb)]"
  syntax:
    content: public virtual void LoadXml (string xml);
    parameters:
    - id: xml
      type: System.String
      description: "包含要加载的 XML 文档的字符串。"
  overload: System.Xml.XmlDocument.LoadXml*
  exceptions:
  - type: System.Xml.XmlException
    commentId: T:System.Xml.XmlException
    description: "在 XML 中没有加载或分析错误。 在这种情况下，文档保留为空。"
  platform:
  - net462
- uid: System.Xml.XmlDocument.LocalName
  id: LocalName
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: LocalName
  nameWithType: XmlDocument.LocalName
  fullName: System.Xml.XmlDocument.LocalName
  type: Property
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "获取节点的本地名称。"
  remarks: "取决于返回的本地名称<xref:System.Xml.XmlDocument.NodeType%2A>的节点。</xref:System.Xml.XmlDocument.NodeType%2A> 若要查看描述为每个节点类型返回的本地名称的表，请参阅<xref:System.Xml.XmlNode.LocalName%2A>在<xref:System.Xml.XmlNode>类</xref:System.Xml.XmlNode>中的属性</xref:System.Xml.XmlNode.LocalName%2A>"
  syntax:
    content: public override string LocalName { get; }
    return:
      type: System.String
      description: '有关<xref uid=&quot;langword_csharp_XmlDocument&quot; name=&quot;XmlDocument&quot; href=&quot;&quot;></xref>节点，本地名称是 #document。'
  overload: System.Xml.XmlDocument.LocalName*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.Name
  id: Name
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: Name
  nameWithType: XmlDocument.Name
  fullName: System.Xml.XmlDocument.Name
  type: Property
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "获取节点的限定的名称。"
  remarks: "返回的名称取决于<xref:System.Xml.XmlDocument.NodeType%2A>的节点。</xref:System.Xml.XmlDocument.NodeType%2A> 若要查看描述为每个节点类型返回的名称的表，请参阅<xref:System.Xml.XmlNode.Name%2A>在<xref:System.Xml.XmlNode>类</xref:System.Xml.XmlNode>中的属性</xref:System.Xml.XmlNode.Name%2A>"
  syntax:
    content: public override string Name { get; }
    return:
      type: System.String
      description: '有关<xref uid=&quot;langword_csharp_XmlDocument&quot; name=&quot;XmlDocument&quot; href=&quot;&quot;></xref>节点，该名称是 #document。'
  overload: System.Xml.XmlDocument.Name*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.NameTable
  id: NameTable
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: NameTable
  nameWithType: XmlDocument.NameTable
  fullName: System.Xml.XmlDocument.NameTable
  type: Property
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "获取<xref:System.Xml.XmlNameTable>与此实现关联。</xref:System.Xml.XmlNameTable>"
  remarks: "每个`XmlDocument`对象具有<xref:System.Xml.NameTable>对象。</xref:System.Xml.NameTable> 元素和属性名称存储在`NameTable`作为原子化字符串。 这意味着，即使名称引用文档中多次它存储一次在`NameTable`。 例如，如果文档具有多个具有名称&quot;客户&quot;元素`NameTable`在收到该名称的请求返回相同的对象。 因此，用户可以编写代码上这些字符串，而不是开销更大的字符串比较中使用对象比较。       原子化字符串的详细信息，请参阅<xref:System.Xml.XmlNameTable>。</xref:System.Xml.XmlNameTable>       此方法是 Microsoft 扩展到文档对象模型 (DOM)。"
  syntax:
    content: public System.Xml.XmlNameTable NameTable { get; }
    return:
      type: System.Xml.XmlNameTable
      description: "<xref uid=&quot;langword_csharp_XmlNameTable&quot; name=&quot;XmlNameTable&quot; href=&quot;&quot;> </xref>使您能够获取该文档中字符串的原子化的版本。"
  overload: System.Xml.XmlDocument.NameTable*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.NodeChanged
  id: NodeChanged
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: NodeChanged
  nameWithType: XmlDocument.NodeChanged
  fullName: System.Xml.XmlDocument.NodeChanged
  type: Event
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "发生时<xref:System.Xml.XmlNode.Value*>属于该文档已更改的一个节点。</xref:System.Xml.XmlNode.Value*>"
  remarks: "此事件仅适用于具有值的节点。       在这种情况将包含指示已插入到文档中，它们由本文档中，创建的所有节点。"
  syntax:
    content: public event System.Xml.XmlNodeChangedEventHandler NodeChanged;
    return:
      type: System.Xml.XmlNodeChangedEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.NodeChanging
  id: NodeChanging
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: NodeChanging
  nameWithType: XmlDocument.NodeChanging
  fullName: System.Xml.XmlDocument.NodeChanging
  type: Event
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "发生时<xref:System.Xml.XmlNode.Value*>的节点属于该文档是将被更改。</xref:System.Xml.XmlNode.Value*>"
  remarks: "此事件将允许用户执行额外的检查，并如有必要，引发异常来停止该操作。 如果引发异常`XmlDocument`返回到其原始状态。 此事件仅适用于具有值的节点。       在这种情况将包含指示已插入到文档中，它们由本文档中，创建的所有节点。"
  syntax:
    content: public event System.Xml.XmlNodeChangedEventHandler NodeChanging;
    return:
      type: System.Xml.XmlNodeChangedEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.NodeInserted
  id: NodeInserted
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: NodeInserted
  nameWithType: XmlDocument.NodeInserted
  fullName: System.Xml.XmlDocument.NodeInserted
  type: Event
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "属于此文档的节点插入另一个节点时发生。"
  remarks: "在这种情况将包含指示已插入到文档中，它们由本文档中，创建的所有节点。"
  syntax:
    content: public event System.Xml.XmlNodeChangedEventHandler NodeInserted;
    return:
      type: System.Xml.XmlNodeChangedEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.NodeInserting
  id: NodeInserting
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: NodeInserting
  nameWithType: XmlDocument.NodeInserting
  fullName: System.Xml.XmlDocument.NodeInserting
  type: Event
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "属于此文档的节点即将要插入到另一个节点时发生。"
  remarks: "此事件将允许用户执行额外的检查，并如有必要，引发异常来停止该操作。 如果引发异常`XmlDocument`返回到其原始状态。       在这种情况将包含指示已插入到文档中，它们由本文档中，创建的所有节点。"
  syntax:
    content: public event System.Xml.XmlNodeChangedEventHandler NodeInserting;
    return:
      type: System.Xml.XmlNodeChangedEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.NodeRemoved
  id: NodeRemoved
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: NodeRemoved
  nameWithType: XmlDocument.NodeRemoved
  fullName: System.Xml.XmlDocument.NodeRemoved
  type: Event
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "当属于该文档节点已从其父级中移除时发生。"
  remarks: "在这种情况将包含指示已插入到文档中，它们由本文档中，创建的所有节点。"
  syntax:
    content: public event System.Xml.XmlNodeChangedEventHandler NodeRemoved;
    return:
      type: System.Xml.XmlNodeChangedEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.NodeRemoving
  id: NodeRemoving
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: NodeRemoving
  nameWithType: XmlDocument.NodeRemoving
  fullName: System.Xml.XmlDocument.NodeRemoving
  type: Event
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "当属于该文档的节点将从文档中移除时发生。"
  remarks: "此事件将允许用户执行额外的检查，并如有必要，引发异常来停止该操作。 如果引发异常`XmlDocument`返回到其原始状态。       在这种情况将包含指示已插入到文档中，它们由本文档中，创建的所有节点。"
  syntax:
    content: public event System.Xml.XmlNodeChangedEventHandler NodeRemoving;
    return:
      type: System.Xml.XmlNodeChangedEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.NodeType
  id: NodeType
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: NodeType
  nameWithType: XmlDocument.NodeType
  fullName: System.Xml.XmlDocument.NodeType
  type: Property
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "获取当前节点的类型。"
  syntax:
    content: public override System.Xml.XmlNodeType NodeType { get; }
    return:
      type: System.Xml.XmlNodeType
      description: "节点类型。 有关<xref uid=&quot;langword_csharp_XmlDocument&quot; name=&quot;XmlDocument&quot; href=&quot;&quot;></xref>节点，该值是 XmlNodeType.Document。"
  overload: System.Xml.XmlDocument.NodeType*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.OwnerDocument
  id: OwnerDocument
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: OwnerDocument
  nameWithType: XmlDocument.OwnerDocument
  fullName: System.Xml.XmlDocument.OwnerDocument
  type: Property
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "获取<xref href=&quot;System.Xml.XmlDocument&quot;></xref>当前节点所属。"
  syntax:
    content: public override System.Xml.XmlDocument OwnerDocument { get; }
    return:
      type: System.Xml.XmlDocument
      description: "有关<xref uid=&quot;langword_csharp_XmlDocument&quot; name=&quot;XmlDocument&quot; href=&quot;&quot;></xref>节点 (<xref:System.Xml.XmlDocument.NodeType*>等于 XmlNodeType.Document)，此属性始终返回<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。</xref:System.Xml.XmlDocument.NodeType*>"
  overload: System.Xml.XmlDocument.OwnerDocument*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.ParentNode
  id: ParentNode
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: ParentNode
  nameWithType: XmlDocument.ParentNode
  fullName: System.Xml.XmlDocument.ParentNode
  type: Property
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "获取此节点的父节点 （针对可以拥有父级的节点）。"
  syntax:
    content: public override System.Xml.XmlNode ParentNode { get; }
    return:
      type: System.Xml.XmlNode
      description: "始终返回<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Xml.XmlDocument.ParentNode*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.PreserveWhitespace
  id: PreserveWhitespace
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: PreserveWhitespace
  nameWithType: XmlDocument.PreserveWhitespace
  fullName: System.Xml.XmlDocument.PreserveWhitespace
  type: Property
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "获取或设置一个值，该值指示是否保留元素内容中的空白区域。"
  remarks: "此属性确定在加载过程中如何处理空白区域，并保存过程。       如果`PreserveWhitespace`是`true`之前<xref:System.Xml.XmlDocument.Load%2A>或<xref:System.Xml.XmlDocument.LoadXml%2A>是调用，空白节点是保留; 否则为如果此属性为`false`（保留有效空白) 的空白区域不是。</xref:System.Xml.XmlDocument.LoadXml%2A> </xref:System.Xml.XmlDocument.Load%2A>       如果`PreserveWhitespace`是`true`之前<xref:System.Xml.XmlDocument.Save%2A>是调用，在文档中的空白是保留在输出中; 否则为如果此属性为`false`，`XmlDocument`自动缩进输出。</xref:System.Xml.XmlDocument.Save%2A>       此方法是 Microsoft 扩展到文档对象模型 (DOM)。"
  example:
  - "The following example shows how to strip white space from a file.  \n  \n [!code-cs[Classic WebData XmlDocument.PreserveWhitespace Example#1](~/add/codesnippet/csharp/p-system.xml.xmldocument_6_1.cs)]\n [!code-vb[Classic WebData XmlDocument.PreserveWhitespace Example#1](~/add/codesnippet/visualbasic/p-system.xml.xmldocument_6_1.vb)]\n [!code-cpp[Classic WebData XmlDocument.PreserveWhitespace Example#1](~/add/codesnippet/cpp/p-system.xml.xmldocument_6_1.cpp)]  \n  \n The example uses the file `book.xml` as input.  \n  \n [!code-xml[Classic WebData XmlDocument.PreserveWhitespace Example#2](~/add/codesnippet/xml/p-system.xml.xmldocument_6_2.xml)]"
  syntax:
    content: public bool PreserveWhitespace { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要保留空白;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Xml.XmlDocument.PreserveWhitespace*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.ReadNode(System.Xml.XmlReader)
  id: ReadNode(System.Xml.XmlReader)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: ReadNode(XmlReader)
  nameWithType: XmlDocument.ReadNode(XmlReader)
  fullName: System.Xml.XmlDocument.ReadNode(XmlReader)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "创建<xref href=&quot;System.Xml.XmlNode&quot;></xref>对象基于<xref:System.Xml.XmlReader>.</xref:System.Xml.XmlReader>中的信息 读取必须定位在节点或属性。"
  remarks: "读取一个`XmlNode`从给定的读取器和将读取器定位到下一个节点。 此方法创建的一种`XmlNode`匹配<xref:System.Xml.XmlNode.NodeType%2A>读取器当前定位在。</xref:System.Xml.XmlNode.NodeType%2A> (如果在读取器处于初始状态，`ReadNode`将读取器推进到第一个节点，然后在该节点上进行操作。)     如果读取器定位在的开始处的元素，`ReadNode`读取所有属性和任何子节点，最多，并包括当前节点的结束标记。 `XmlNode`返回包含表示所读取所有内容的子树。 读取器定位立即结束标记后面。       `ReadNode`此外可以读取属性，但在这种情况下它不会不使读取器前进到下一个属性。 这使您可以编写以下 C# 代码︰ ```   XmlDocument doc = new XmlDocument();   while (reader.MoveToNextAttribute())   {     XmlNode a = doc.ReadNode(reader);     // Do some more processing.   }   ``` `ReadNode`做会导致占用属性值但是，这意味着在调用`ReadNode`特性，<xref:System.Xml.XmlReader.ReadAttributeValue%2A?displayProperty=fullName>返回`false`。</xref:System.Xml.XmlReader.ReadAttributeValue%2A?displayProperty=fullName>       "
  example:
  - "The following example uses `ReadNode` to create a new node and then inserts the new node into the document.  \n  \n [!code-cs[Classic WebData XmlDocument.ReadNode Example#1](~/add/codesnippet/csharp/m-system.xml.xmldocument_21_1.cs)]\n [!code-cpp[Classic WebData XmlDocument.ReadNode Example#1](~/add/codesnippet/cpp/m-system.xml.xmldocument_21_1.cpp)]\n [!code-vb[Classic WebData XmlDocument.ReadNode Example#1](~/add/codesnippet/visualbasic/m-system.xml.xmldocument_21_1.vb)]  \n  \n The example uses the file, `cd.xml`, as input.  \n  \n [!code-xml[Classic WebData XmlDocument.ReadNode Example#2](~/add/codesnippet/xml/m-system.xml.xmldocument_21_2.xml)]"
  syntax:
    content: public virtual System.Xml.XmlNode ReadNode (System.Xml.XmlReader reader);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "XML 源"
    return:
      type: System.Xml.XmlNode
      description: "新<xref uid=&quot;langword_csharp_XmlNode&quot; name=&quot;XmlNode&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果不存在其他节点。"
  overload: System.Xml.XmlDocument.ReadNode*
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "读取器位于未转换为有效的 DOM 节点 （例如，EndElement 或 EndEntity） 的节点类型上。"
  platform:
  - net462
- uid: System.Xml.XmlDocument.Save(System.IO.Stream)
  id: Save(System.IO.Stream)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: Save(Stream)
  nameWithType: XmlDocument.Save(Stream)
  fullName: System.Xml.XmlDocument.Save(Stream)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "将 XML 文档保存到指定的流。"
  remarks: "仅当保留空白<xref:System.Xml.XmlDocument.PreserveWhitespace%2A>设置为`true`。</xref:System.Xml.XmlDocument.PreserveWhitespace%2A>       当前的 XmlDeclaration`XmlDocument`对象确定已保存的文档中的编码属性。 编码属性的值取自<xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=fullName>属性。</xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=fullName> 如果`XmlDocument`未没有出 XmlDeclaration，或如果 XmlDeclaration 没有出编码方式特性，保存的文档将不具有一个。       保存文档后，会生成的 xmlns 属性来正确保持节点标识 （本地名称 + 命名空间 URI）。 例如，以下 C# 代码```   XmlDocument doc = new XmlDocument();   doc.AppendChild(doc.CreateElement(&quot;item&quot;,&quot;urn:1&quot;));   doc.Save(Console.Out);   ```生成此 xml 属性`<item xmls=&quot;urn:1&quot;/>`。       此方法是 Microsoft 扩展到文档对象模型 (DOM)。       请注意，只有<xref:System.Xml.XmlDocument.Save%2A>方法强制执行格式良好的 XML 文档。</xref:System.Xml.XmlDocument.Save%2A> 所有其他`Save`重载只能保证格式良好的片段。"
  syntax:
    content: public virtual void Save (System.IO.Stream outStream);
    parameters:
    - id: outStream
      type: System.IO.Stream
      description: "你想要保存流。"
  overload: System.Xml.XmlDocument.Save*
  exceptions:
  - type: System.Xml.XmlException
    commentId: T:System.Xml.XmlException
    description: "该操作不会生成格式标准的 XML 文档 （例如，没有文档元素或 XML 声明重复） 中。"
  platform:
  - net462
- uid: System.Xml.XmlDocument.Save(System.IO.TextWriter)
  id: Save(System.IO.TextWriter)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: Save(TextWriter)
  nameWithType: XmlDocument.Save(TextWriter)
  fullName: System.Xml.XmlDocument.Save(TextWriter)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "将 XML 文档保存到指定<xref:System.IO.TextWriter>。</xref:System.IO.TextWriter>"
  remarks: "中的编码`TextWriter`确定写出的编码 (XmlDeclaration 节点的编码进行编码的替换`TextWriter`)。 如果没有指定在没有编码`TextWriter`、`XmlDocument`保存时没有出编码方式特性。       此方法是 Microsoft 扩展到文档对象模型 (DOM)。       请注意，只有<xref:System.Xml.XmlDocument.Save%2A>方法强制执行格式良好的 XML 文档。</xref:System.Xml.XmlDocument.Save%2A> 所有其他`Save`重载只能保证格式良好的片段。"
  syntax:
    content: public virtual void Save (System.IO.TextWriter writer);
    parameters:
    - id: writer
      type: System.IO.TextWriter
      description: "<xref uid=&quot;langword_csharp_TextWriter&quot; name=&quot;TextWriter&quot; href=&quot;&quot;> </xref>到想要保存。"
  overload: System.Xml.XmlDocument.Save*
  exceptions:
  - type: System.Xml.XmlException
    commentId: T:System.Xml.XmlException
    description: "该操作不会生成格式标准的 XML 文档 （例如，没有文档元素或 XML 声明重复） 中。"
  platform:
  - net462
- uid: System.Xml.XmlDocument.Save(System.String)
  id: Save(System.String)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: Save(String)
  nameWithType: XmlDocument.Save(String)
  fullName: System.Xml.XmlDocument.Save(String)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "将 XML 文档保存到指定的文件。 如果指定的文件存在，此方法会覆盖它。"
  remarks: "在输出文件才保留空白<xref:System.Xml.XmlDocument.PreserveWhitespace%2A>设置为`true`。</xref:System.Xml.XmlDocument.PreserveWhitespace%2A>       当前的 XmlDeclaration`XmlDocument`对象确定已保存的文档中的编码属性。 编码属性的值取自<xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=fullName>属性。</xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=fullName> 如果`XmlDocument`未没有出 XmlDeclaration，或如果 XmlDeclaration 没有出编码方式特性，保存的文档将不具有一个。       保存文档后，会生成的 xmlns 属性来正确保持节点标识 （本地名称 + 命名空间 URI）。 例如，以下 C# 代码```   XmlDocument doc = new XmlDocument();   doc.AppendChild(doc.CreateElement(&quot;item&quot;,&quot;urn:1&quot;));   doc.Save(Console.Out);   ```生成此 xml 属性`<item xmls=&quot;urn:1&quot;/>`。       此方法是 Microsoft 扩展到文档对象模型 (DOM)。       请注意，仅保存方法实施格式良好的 XML 文档。 所有其他`Save`重载只能保证格式良好的片段。"
  example:
  - "The following example loads XML into an XmlDocument object, modifies it, and then saves it to a file named data.xml.  \n  \n [!code-cs[Classic WebData XmlDocument.Save Example#1](~/add/codesnippet/csharp/m-system.xml.xmldocument_18_1.cs)]\n [!code-vb[Classic WebData XmlDocument.Save Example#1](~/add/codesnippet/visualbasic/m-system.xml.xmldocument_18_1.vb)]\n [!code-cpp[Classic WebData XmlDocument.Save Example#1](~/add/codesnippet/cpp/m-system.xml.xmldocument_18_1.cpp)]  \n  \n The data.xml file will contain the following XML: `<item><name>wrench</name><price>10.95</price></item>`."
  syntax:
    content: public virtual void Save (string filename);
    parameters:
    - id: filename
      type: System.String
      description: "你想要将文档保存文件的位置。"
  overload: System.Xml.XmlDocument.Save*
  exceptions:
  - type: System.Xml.XmlException
    commentId: T:System.Xml.XmlException
    description: "该操作不会生成格式标准的 XML 文档 （例如，没有文档元素或 XML 声明重复） 中。"
  platform:
  - net462
- uid: System.Xml.XmlDocument.Save(System.Xml.XmlWriter)
  id: Save(System.Xml.XmlWriter)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: Save(XmlWriter)
  nameWithType: XmlDocument.Save(XmlWriter)
  fullName: System.Xml.XmlDocument.Save(XmlWriter)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "将 XML 文档保存到指定<xref:System.Xml.XmlWriter>。</xref:System.Xml.XmlWriter>"
  remarks: "仅当保留空白<xref:System.Xml.XmlDocument.PreserveWhitespace%2A>设置为`true`。</xref:System.Xml.XmlDocument.PreserveWhitespace%2A>       中的编码`XmlWriter`确定写出的编码 (XmlDeclaration 节点的编码进行编码的替换`XmlWriter`)。 如果没有指定在没有编码`XmlWriter`、`XmlDocument`保存时没有出编码方式特性。       保存文档后，会生成的 xmlns 属性来正确保持节点标识 （LocalName + NamespaceURI）。 例如，以下 C# 代码```   XmlDocument doc = new XmlDocument();   doc.AppendChild(doc.CreateElement(&quot;item&quot;,&quot;urn:1&quot;));   doc.Save(Console.Out);   ```生成此 xml 属性︰```   <item       xmls=&quot;urn:1&quot;/>   ```此方法是 Microsoft 扩展到文档对象模型 (DOM)。       请注意，只有<xref:System.Xml.XmlDocument.Save%2A>方法强制执行格式良好的 XML 文档。</xref:System.Xml.XmlDocument.Save%2A> 所有其他`Save`重载只能保证格式良好的片段。"
  example:
  - "The following example loads XML into an `XmlDocument` object and saves it out to a file.  \n  \n [!code-cpp[Classic WebData XmlDocument.LoadXml Example#1](~/add/codesnippet/cpp/m-system.xml.xmldocument_5_1.cpp)]\n [!code-cs[Classic WebData XmlDocument.LoadXml Example#1](~/add/codesnippet/csharp/m-system.xml.xmldocument_5_1.cs)]\n [!code-vb[Classic WebData XmlDocument.LoadXml Example#1](~/add/codesnippet/visualbasic/m-system.xml.xmldocument_5_1.vb)]"
  syntax:
    content: public virtual void Save (System.Xml.XmlWriter w);
    parameters:
    - id: w
      type: System.Xml.XmlWriter
      description: "<xref uid=&quot;langword_csharp_XmlWriter&quot; name=&quot;XmlWriter&quot; href=&quot;&quot;> </xref>到想要保存。"
  overload: System.Xml.XmlDocument.Save*
  exceptions:
  - type: System.Xml.XmlException
    commentId: T:System.Xml.XmlException
    description: "该操作不会生成格式标准的 XML 文档 （例如，没有文档元素或 XML 声明重复） 中。"
  platform:
  - net462
- uid: System.Xml.XmlDocument.SchemaInfo
  id: SchemaInfo
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: SchemaInfo
  nameWithType: XmlDocument.SchemaInfo
  fullName: System.Xml.XmlDocument.SchemaInfo
  type: Property
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "返回后的架构验证的信息集 (PSVI) 的节点。"
  remarks: "已验证该节点之后设置此属性的 PSVI 内容。       此属性是 Microsoft 扩展到文档对象模型 (DOM)。"
  syntax:
    content: public override System.Xml.Schema.IXmlSchemaInfo SchemaInfo { get; }
    return:
      type: System.Xml.Schema.IXmlSchemaInfo
      description: "<xref href=&quot;System.Xml.Schema.IXmlSchemaInfo&quot;> </xref>表示节点的 PSVI 的对象。"
  overload: System.Xml.XmlDocument.SchemaInfo*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.Schemas
  id: Schemas
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: Schemas
  nameWithType: XmlDocument.Schemas
  fullName: System.Xml.XmlDocument.Schemas
  type: Property
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "获取或设置<xref href=&quot;System.Xml.Schema.XmlSchemaSet&quot;></xref>对象与此关联<xref href=&quot;System.Xml.XmlDocument&quot;> </xref>。"
  remarks: "中包含的架构<xref:System.Xml.Schema.XmlSchemaSet>与关联的对象<xref:System.Xml.XmlDocument>对象用于验证时<xref:System.Xml.XmlDocument.Validate%2A>方法<xref:System.Xml.XmlDocument>执行。</xref:System.Xml.XmlDocument> </xref:System.Xml.XmlDocument.Validate%2A> </xref:System.Xml.XmlDocument> </xref:System.Xml.Schema.XmlSchemaSet>       当<xref:System.Xml.XmlDocument>初始化对象时，从 XML 数据<xref:System.Xml.XmlReader>对象，<xref:System.Xml.Schema.XmlSchemaSet>对象加载从<xref:System.Xml.XmlReaderSettings.Schemas%2A>属性<xref:System.Xml.XmlReader>对象。</xref:System.Xml.XmlReader> </xref:System.Xml.XmlReaderSettings.Schemas%2A> </xref:System.Xml.Schema.XmlSchemaSet> </xref:System.Xml.XmlReader> </xref:System.Xml.XmlDocument>"
  syntax:
    content: public System.Xml.Schema.XmlSchemaSet Schemas { get; set; }
    return:
      type: System.Xml.Schema.XmlSchemaSet
      description: "<xref href=&quot;System.Xml.Schema.XmlSchemaSet&quot;> </xref>对象，其中包含与此关联的 XML 架构定义语言 (XSD) 架构<xref href=&quot;System.Xml.XmlDocument&quot;> </xref>; 否则为一个空<xref href=&quot;System.Xml.Schema.XmlSchemaSet&quot;></xref>对象。"
  overload: System.Xml.XmlDocument.Schemas*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.Validate(System.Xml.Schema.ValidationEventHandler)
  id: Validate(System.Xml.Schema.ValidationEventHandler)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: Validate(ValidationEventHandler)
  nameWithType: XmlDocument.Validate(ValidationEventHandler)
  fullName: System.Xml.XmlDocument.Validate(ValidationEventHandler)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "验证<xref href=&quot;System.Xml.XmlDocument&quot;></xref>中包含的 XML 架构定义语言 (XSD) 架构<xref:System.Xml.XmlDocument.Schemas*>属性。</xref:System.Xml.XmlDocument.Schemas*>"
  remarks: "Validate 方法验证中的 XML 数据<xref:System.Xml.XmlDocument>中包含的架构针对<xref:System.Xml.XmlDocument.Schemas%2A>属性。</xref:System.Xml.XmlDocument.Schemas%2A> </xref:System.Xml.XmlDocument> Validate 方法执行信息集增加。 具体而言，成功验证之后，将应用架构默认值、 文本值转换为所需的原子值和类型信息与经过验证的信息项关联。 结果是以前非类型化中的 XML 子树<xref:System.Xml.XmlDocument>替换为类型化的子树。</xref:System.Xml.XmlDocument>       以下是使用验证方法时要考虑的重要说明。      架构位置提示喜欢`xsi:schemaLocation`或`xsi:noNamespaceSchemaLocation`将被忽略。      将忽略内联架构。      -如果在验证期间出现架构验证错误<xref:System.Xml.XmlDocument>其中某些节点，使用正确的类型信息而另一些而无需将成为部分验证。</xref:System.Xml.XmlDocument>      验证过程包括检查唯一性和引用约束 (`xs:ID`， `xs:IDREF`， `xs:key`， `xs:keyref`，和`xs:unique`)。"
  example:
  - "The following example illustrates use of the Validate method. The example creates an <xref:System.Xml.XmlDocument> that contains an associated XSD schema using the <xref:System.Xml.XmlReaderSettings> and <xref:System.Xml.XmlReader> objects. The example then uses the <xref:System.Xml.XPath.XPathNavigator> class to incorrectly modify the typed value of an element in the XML document generating a schema validation error.  \n  \n [!code-cs[XPathValidation#1](~/add/codesnippet/csharp/m-system.xml.xmldocument_19_1.cs)]\n [!code-cpp[XPathValidation#1](~/add/codesnippet/cpp/m-system.xml.xmldocument_19_1.cpp)]\n [!code-vb[XPathValidation#1](~/add/codesnippet/visualbasic/m-system.xml.xmldocument_19_1.vb)]  \n  \n The example takes the `contosoBooks.xml` and `contosoBooks.xsd` files as input.  \n  \n [!code-xml[XPathXMLExamples#2](~/add/codesnippet/xml/m-system.xml.xmldocument_19_2.xml)]  \n  \n [!code-xml[XPathXMLExamples#3](~/add/codesnippet/xml/m-system.xml.xmldocument_19_3.xsd)]"
  syntax:
    content: public void Validate (System.Xml.Schema.ValidationEventHandler validationEventHandler);
    parameters:
    - id: validationEventHandler
      type: System.Xml.Schema.ValidationEventHandler
      description: "<xref href=&quot;System.Xml.Schema.ValidationEventHandler&quot;> </xref>接收有关架构验证警告和错误的信息的对象。"
  overload: System.Xml.XmlDocument.Validate*
  exceptions:
  - type: System.Xml.Schema.XmlSchemaValidationException
    commentId: T:System.Xml.Schema.XmlSchemaValidationException
    description: "发生了架构验证事件并且不<xref href=&quot;System.Xml.Schema.ValidationEventHandler&quot;></xref>指定的对象。"
  platform:
  - net462
- uid: System.Xml.XmlDocument.Validate(System.Xml.Schema.ValidationEventHandler,System.Xml.XmlNode)
  id: Validate(System.Xml.Schema.ValidationEventHandler,System.Xml.XmlNode)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: Validate(ValidationEventHandler,XmlNode)
  nameWithType: XmlDocument.Validate(ValidationEventHandler,XmlNode)
  fullName: System.Xml.XmlDocument.Validate(ValidationEventHandler,XmlNode)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "验证<xref href=&quot;System.Xml.XmlNode&quot;></xref>对象中的 XML 架构定义语言 (XSD) 架构指定<xref:System.Xml.XmlDocument.Schemas*>属性。</xref:System.Xml.XmlDocument.Schemas*>"
  remarks: "Validate 方法验证中的 XML 数据<xref:System.Xml.XmlNode>对象中包含的架构针对<xref:System.Xml.XmlDocument.Schemas%2A>属性。</xref:System.Xml.XmlDocument.Schemas%2A> </xref:System.Xml.XmlNode> Validate 方法执行信息集增加。 具体而言，成功验证之后，将应用架构默认值、 文本值转换为所需的原子值和类型信息与经过验证的信息项关联。 结果是以前非类型化中的 XML 子树<xref:System.Xml.XmlDocument>替换为类型化的子树。</xref:System.Xml.XmlDocument>       以下是使用验证方法时要考虑的重要说明。      架构位置提示喜欢`xsi:schemaLocation`或`xsi:noNamespaceSchemaLocation`将被忽略。      将忽略内联架构。      -如果在验证期间出现架构验证错误<xref:System.Xml.XmlDocument>其中某些节点，使用正确的类型信息而另一些而无需将成为部分验证。</xref:System.Xml.XmlDocument>       如果要验证的节点是根节点，则验证过程包括检查唯一性和引用约束 (`xs:ID`， `xs:IDREF`， `xs:key`， `xs:keyref`，和`xs:unique`); 否则为将省略唯一性和引用约束。"
  example:
  - For an example of the Validate method, see the <xref:System.Xml.XmlDocument.Validate%2A> method.
  syntax:
    content: public void Validate (System.Xml.Schema.ValidationEventHandler validationEventHandler, System.Xml.XmlNode nodeToValidate);
    parameters:
    - id: validationEventHandler
      type: System.Xml.Schema.ValidationEventHandler
      description: "<xref href=&quot;System.Xml.Schema.ValidationEventHandler&quot;> </xref>接收有关架构验证警告和错误的信息的对象。"
    - id: nodeToValidate
      type: System.Xml.XmlNode
      description: "<xref href=&quot;System.Xml.XmlNode&quot;> </xref>对象从创建<xref href=&quot;System.Xml.XmlDocument&quot;></xref>验证。"
  overload: System.Xml.XmlDocument.Validate*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<xref href=&quot;System.Xml.XmlNode&quot;> </xref>对象参数不从创建<xref href=&quot;System.Xml.XmlDocument&quot;> </xref>。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Xml.XmlNode&quot;> </xref>对象参数不是元素、 属性、 文档片段或根节点。"
  - type: System.Xml.Schema.XmlSchemaValidationException
    commentId: T:System.Xml.Schema.XmlSchemaValidationException
    description: "发生了架构验证事件并且不<xref href=&quot;System.Xml.Schema.ValidationEventHandler&quot;></xref>指定的对象。"
  platform:
  - net462
- uid: System.Xml.XmlDocument.WriteContentTo(System.Xml.XmlWriter)
  id: WriteContentTo(System.Xml.XmlWriter)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: WriteContentTo(XmlWriter)
  nameWithType: XmlDocument.WriteContentTo(XmlWriter)
  fullName: System.Xml.XmlDocument.WriteContentTo(XmlWriter)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "将保存的所有子级<xref uid=&quot;langword_csharp_XmlDocument&quot; name=&quot;XmlDocument&quot; href=&quot;&quot;></xref>节点到指定<xref:System.Xml.XmlWriter>。</xref:System.Xml.XmlWriter>"
  remarks: "此方法是 Microsoft 扩展到文档对象模型 (DOM)。 它在功能上等效于<xref:System.Xml.XmlDocument.InnerXml%2A>属性。</xref:System.Xml.XmlDocument.InnerXml%2A>       <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=fullName>属性确定写出的编码。</xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=fullName> 如果`Encoding`属性不具有一个值，`XmlDocument`而无需编码属性形式写出。"
  example:
  - "The following example displays the document onscreen.  \n  \n [!code-cs[Classic WebData XmlDocument.WriteContentTo Example#1](~/add/codesnippet/csharp/m-system.xml.xmldocument_0_1.cs)]\n [!code-vb[Classic WebData XmlDocument.WriteContentTo Example#1](~/add/codesnippet/visualbasic/m-system.xml.xmldocument_0_1.vb)]\n [!code-cpp[Classic WebData XmlDocument.WriteContentTo Example#1](~/add/codesnippet/cpp/m-system.xml.xmldocument_0_1.cpp)]"
  syntax:
    content: public override void WriteContentTo (System.Xml.XmlWriter xw);
    parameters:
    - id: xw
      type: System.Xml.XmlWriter
      description: "<xref uid=&quot;langword_csharp_XmlWriter&quot; name=&quot;XmlWriter&quot; href=&quot;&quot;> </xref>到想要保存。"
  overload: System.Xml.XmlDocument.WriteContentTo*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.WriteTo(System.Xml.XmlWriter)
  id: WriteTo(System.Xml.XmlWriter)
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: WriteTo(XmlWriter)
  nameWithType: XmlDocument.WriteTo(XmlWriter)
  fullName: System.Xml.XmlDocument.WriteTo(XmlWriter)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "将保存<xref uid=&quot;langword_csharp_XmlDocument&quot; name=&quot;XmlDocument&quot; href=&quot;&quot;></xref>节点到指定<xref:System.Xml.XmlWriter>。</xref:System.Xml.XmlWriter>"
  remarks: "此方法是 Microsoft 扩展到文档对象模型 (DOM)。 它在功能上等效于<xref:System.Xml.XmlNode.OuterXml%2A>属性。</xref:System.Xml.XmlNode.OuterXml%2A>       <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=fullName>属性确定写出的编码。</xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=fullName> 如果`Encoding`属性不具有一个值，`XmlDocument`而无需编码属性形式写出。"
  example:
  - "The following example displays the document onscreen.  \n  \n [!code-cpp[Classic WebData XmlDocument.WriteTo Example#1](~/add/codesnippet/cpp/m-system.xml.xmldocument_6_1.cpp)]\n [!code-vb[Classic WebData XmlDocument.WriteTo Example#1](~/add/codesnippet/visualbasic/m-system.xml.xmldocument_6_1.vb)]\n [!code-cs[Classic WebData XmlDocument.WriteTo Example#1](~/add/codesnippet/csharp/m-system.xml.xmldocument_6_1.cs)]"
  syntax:
    content: public override void WriteTo (System.Xml.XmlWriter w);
    parameters:
    - id: w
      type: System.Xml.XmlWriter
      description: "<xref uid=&quot;langword_csharp_XmlWriter&quot; name=&quot;XmlWriter&quot; href=&quot;&quot;> </xref>到想要保存。"
  overload: System.Xml.XmlDocument.WriteTo*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.XmlDocument.XmlResolver
  id: XmlResolver
  parent: System.Xml.XmlDocument
  langs:
  - csharp
  name: XmlResolver
  nameWithType: XmlDocument.XmlResolver
  fullName: System.Xml.XmlDocument.XmlResolver
  type: Property
  assemblies:
  - System.Xml
  namespace: System.Xml
  summary: "集<xref href=&quot;System.Xml.XmlResolver&quot;></xref>以用于解析外部资源。"
  remarks: "`XmlResolver`用于加载 Dtd 或展开实体引用。 使用<xref:System.Xml.XmlResolver.Credentials%2A?displayProperty=fullName>属性，你可以上设置凭据`XmlResolver`存储在一个安全的网络资源的访问资源。</xref:System.Xml.XmlResolver.Credentials%2A?displayProperty=fullName>      -如果不使用加载文档<xref:System.Xml.XmlReader>（即，如果它使用流进行加载，文件，依次类推）`XmlResolver`上`XmlDocument`始终使用。</xref:System.Xml.XmlReader>      -如果文档加载时与<xref:System.Xml.XmlTextReader>上的解析器`XmlTextReader`用于解析 DocumentType 节点中的任何 DTD 引用。</xref:System.Xml.XmlTextReader> 上的解析器`XmlDocument`用于展开的任何实体引用。      -如果文档加载时与<xref:System.Xml.XmlValidatingReader>上的解析器`XmlDocument`从未使用过。</xref:System.Xml.XmlValidatingReader>      -如果文档加载时与扩展的类的`XmlReader`和`XmlReader`无法解析实体 (<xref:System.Xml.XmlReader.CanResolveEntity%2A>返回`false`)，则`XmlResolver`上`XmlDocument`用于解决 DocumentType 节点中的任何引用并展开任何实体引用。</xref:System.Xml.XmlReader.CanResolveEntity%2A>      1> [!NOTE]&1;> 如果`XmlDocument`使用加载<xref:System.Xml.XmlReader>销售额`XmlResolver`设置为，`XmlResolver`上`XmlReader`不缓存`XmlDocument`后<xref:System.Xml.XmlDocument.Load%2A>完成。</xref:System.Xml.XmlDocument.Load%2A> </xref:System.Xml.XmlReader>       在.net Framework 1.1 版中，如果未设置此属性，应用程序的信任级别将确定的默认行为。       `Fully trusted code:`文档是否使用默认<xref:System.Xml.XmlUrlResolver>使用没有用户凭据。</xref:System.Xml.XmlUrlResolver> 如果需要身份验证来访问网络资源，使用`XmlResolver`属性指定`XmlResolver`使用必要的凭据。       `Semi-trusted code:``XmlResolver`属性设置为`null`。 不解析外部资源。       有关详细信息安全和`XmlResolver`属性，请参阅[解析外部资源](~/add/includes/ajax-current-ext-md.md)。       此属性是 Microsoft 扩展到文档对象模型 (DOM)。"
  example:
  - "The following example loads an XML document which includes a reference to a DTD file. The `XmlResolver` property is used to set the credentials necessary to access the network resource.  \n  \n [!code-cpp[XmlDocument.XmlResolver#1](~/add/codesnippet/cpp/p-system.xml.xmldocument_9_1.cpp)]\n [!code-cs[XmlDocument.XmlResolver#1](~/add/codesnippet/csharp/p-system.xml.xmldocument_9_1.cs)]\n [!code-vb[XmlDocument.XmlResolver#1](~/add/codesnippet/visualbasic/p-system.xml.xmldocument_9_1.vb)]  \n  \n The example uses the following data files as input.  \n  \n `book5.xml`  \n  \n [!code-xml[XmlDocument.XmlResolver#2](~/add/codesnippet/xml/p-system.xml.xmldocument_9_2.xml)]  \n  \n `books.dtd`  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public virtual System.Xml.XmlResolver XmlResolver { set; }
    return:
      type: System.Xml.XmlResolver
      description: "The <xref uid=&quot;langword_csharp_XmlResolver&quot; name=&quot;XmlResolver&quot; href=&quot;&quot;></xref> to use.       在.net Framework 1.1 版中，调用方必须受到完全信任才能指定<xref uid=&quot;langword_csharp_XmlResolver&quot; name=&quot;XmlResolver&quot; href=&quot;&quot;> </xref>。"
  overload: System.Xml.XmlDocument.XmlResolver*
  exceptions:
  - type: System.Xml.XmlException
    commentId: T:System.Xml.XmlException
    description: "此属性设置为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>并遇到了外部 DTD 或实体。"
  platform:
  - net462
references:
- uid: System.Xml.XmlNode
  isExternal: false
  name: System.Xml.XmlNode
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Xml.XmlException
  isExternal: true
  name: System.Xml.XmlException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.IO.PathTooLongException
  isExternal: true
  name: System.IO.PathTooLongException
- uid: System.IO.DirectoryNotFoundException
  isExternal: true
  name: System.IO.DirectoryNotFoundException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.Xml.Schema.XmlSchemaValidationException
  parent: System.Xml.Schema
  isExternal: false
  name: XmlSchemaValidationException
  nameWithType: XmlSchemaValidationException
  fullName: System.Xml.Schema.XmlSchemaValidationException
- uid: System.Xml.XmlDocument.#ctor
  parent: System.Xml.XmlDocument
  isExternal: false
  name: XmlDocument()
  nameWithType: XmlDocument.XmlDocument()
  fullName: System.Xml.XmlDocument.XmlDocument()
- uid: System.Xml.XmlDocument.#ctor(System.Xml.XmlImplementation)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: XmlDocument(XmlImplementation)
  nameWithType: XmlDocument.XmlDocument(XmlImplementation)
  fullName: System.Xml.XmlDocument.XmlDocument(XmlImplementation)
- uid: System.Xml.XmlImplementation
  parent: System.Xml
  isExternal: false
  name: XmlImplementation
  nameWithType: XmlImplementation
  fullName: System.Xml.XmlImplementation
- uid: System.Xml.XmlDocument.#ctor(System.Xml.XmlNameTable)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: XmlDocument(XmlNameTable)
  nameWithType: XmlDocument.XmlDocument(XmlNameTable)
  fullName: System.Xml.XmlDocument.XmlDocument(XmlNameTable)
- uid: System.Xml.XmlNameTable
  parent: System.Xml
  isExternal: true
  name: XmlNameTable
  nameWithType: XmlNameTable
  fullName: System.Xml.XmlNameTable
- uid: System.Xml.XmlDocument.BaseURI
  parent: System.Xml.XmlDocument
  isExternal: false
  name: BaseURI
  nameWithType: XmlDocument.BaseURI
  fullName: System.Xml.XmlDocument.BaseURI
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Xml.XmlDocument.CloneNode(System.Boolean)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CloneNode(Boolean)
  nameWithType: XmlDocument.CloneNode(Boolean)
  fullName: System.Xml.XmlDocument.CloneNode(Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Xml.XmlDocument.CreateAttribute(System.String)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateAttribute(String)
  nameWithType: XmlDocument.CreateAttribute(String)
  fullName: System.Xml.XmlDocument.CreateAttribute(String)
- uid: System.Xml.XmlAttribute
  parent: System.Xml
  isExternal: false
  name: XmlAttribute
  nameWithType: XmlAttribute
  fullName: System.Xml.XmlAttribute
- uid: System.Xml.XmlDocument.CreateAttribute(System.String,System.String)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateAttribute(String,String)
  nameWithType: XmlDocument.CreateAttribute(String,String)
  fullName: System.Xml.XmlDocument.CreateAttribute(String,String)
- uid: System.Xml.XmlDocument.CreateAttribute(System.String,System.String,System.String)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateAttribute(String,String,String)
  nameWithType: XmlDocument.CreateAttribute(String,String,String)
  fullName: System.Xml.XmlDocument.CreateAttribute(String,String,String)
- uid: System.Xml.XmlDocument.CreateCDataSection(System.String)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateCDataSection(String)
  nameWithType: XmlDocument.CreateCDataSection(String)
  fullName: System.Xml.XmlDocument.CreateCDataSection(String)
- uid: System.Xml.XmlCDataSection
  parent: System.Xml
  isExternal: false
  name: XmlCDataSection
  nameWithType: XmlCDataSection
  fullName: System.Xml.XmlCDataSection
- uid: System.Xml.XmlDocument.CreateComment(System.String)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateComment(String)
  nameWithType: XmlDocument.CreateComment(String)
  fullName: System.Xml.XmlDocument.CreateComment(String)
- uid: System.Xml.XmlComment
  parent: System.Xml
  isExternal: false
  name: XmlComment
  nameWithType: XmlComment
  fullName: System.Xml.XmlComment
- uid: System.Xml.XmlDocument.CreateDefaultAttribute(System.String,System.String,System.String)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateDefaultAttribute(String,String,String)
  nameWithType: XmlDocument.CreateDefaultAttribute(String,String,String)
  fullName: System.Xml.XmlDocument.CreateDefaultAttribute(String,String,String)
- uid: System.Xml.XmlDocument.CreateDocumentFragment
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateDocumentFragment()
  nameWithType: XmlDocument.CreateDocumentFragment()
  fullName: System.Xml.XmlDocument.CreateDocumentFragment()
- uid: System.Xml.XmlDocumentFragment
  parent: System.Xml
  isExternal: false
  name: XmlDocumentFragment
  nameWithType: XmlDocumentFragment
  fullName: System.Xml.XmlDocumentFragment
- uid: System.Xml.XmlDocument.CreateDocumentType(System.String,System.String,System.String,System.String)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateDocumentType(String,String,String,String)
  nameWithType: XmlDocument.CreateDocumentType(String,String,String,String)
  fullName: System.Xml.XmlDocument.CreateDocumentType(String,String,String,String)
- uid: System.Xml.XmlDocumentType
  parent: System.Xml
  isExternal: false
  name: XmlDocumentType
  nameWithType: XmlDocumentType
  fullName: System.Xml.XmlDocumentType
- uid: System.Xml.XmlDocument.CreateElement(System.String)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateElement(String)
  nameWithType: XmlDocument.CreateElement(String)
  fullName: System.Xml.XmlDocument.CreateElement(String)
- uid: System.Xml.XmlElement
  parent: System.Xml
  isExternal: false
  name: XmlElement
  nameWithType: XmlElement
  fullName: System.Xml.XmlElement
- uid: System.Xml.XmlDocument.CreateElement(System.String,System.String)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateElement(String,String)
  nameWithType: XmlDocument.CreateElement(String,String)
  fullName: System.Xml.XmlDocument.CreateElement(String,String)
- uid: System.Xml.XmlDocument.CreateElement(System.String,System.String,System.String)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateElement(String,String,String)
  nameWithType: XmlDocument.CreateElement(String,String,String)
  fullName: System.Xml.XmlDocument.CreateElement(String,String,String)
- uid: System.Xml.XmlDocument.CreateEntityReference(System.String)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateEntityReference(String)
  nameWithType: XmlDocument.CreateEntityReference(String)
  fullName: System.Xml.XmlDocument.CreateEntityReference(String)
- uid: System.Xml.XmlEntityReference
  parent: System.Xml
  isExternal: false
  name: XmlEntityReference
  nameWithType: XmlEntityReference
  fullName: System.Xml.XmlEntityReference
- uid: System.Xml.XmlDocument.CreateNavigator
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateNavigator()
  nameWithType: XmlDocument.CreateNavigator()
  fullName: System.Xml.XmlDocument.CreateNavigator()
- uid: System.Xml.XPath.XPathNavigator
  parent: System.Xml.XPath
  isExternal: false
  name: XPathNavigator
  nameWithType: XPathNavigator
  fullName: System.Xml.XPath.XPathNavigator
- uid: System.Xml.XmlDocument.CreateNavigator(System.Xml.XmlNode)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateNavigator(XmlNode)
  nameWithType: XmlDocument.CreateNavigator(XmlNode)
  fullName: System.Xml.XmlDocument.CreateNavigator(XmlNode)
- uid: System.Xml.XmlDocument.CreateNode(System.String,System.String,System.String)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateNode(String,String,String)
  nameWithType: XmlDocument.CreateNode(String,String,String)
  fullName: System.Xml.XmlDocument.CreateNode(String,String,String)
- uid: System.Xml.XmlDocument.CreateNode(System.Xml.XmlNodeType,System.String,System.String)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateNode(XmlNodeType,String,String)
  nameWithType: XmlDocument.CreateNode(XmlNodeType,String,String)
  fullName: System.Xml.XmlDocument.CreateNode(XmlNodeType,String,String)
- uid: System.Xml.XmlNodeType
  parent: System.Xml
  isExternal: true
  name: XmlNodeType
  nameWithType: XmlNodeType
  fullName: System.Xml.XmlNodeType
- uid: System.Xml.XmlDocument.CreateNode(System.Xml.XmlNodeType,System.String,System.String,System.String)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateNode(XmlNodeType,String,String,String)
  nameWithType: XmlDocument.CreateNode(XmlNodeType,String,String,String)
  fullName: System.Xml.XmlDocument.CreateNode(XmlNodeType,String,String,String)
- uid: System.Xml.XmlDocument.CreateProcessingInstruction(System.String,System.String)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateProcessingInstruction(String,String)
  nameWithType: XmlDocument.CreateProcessingInstruction(String,String)
  fullName: System.Xml.XmlDocument.CreateProcessingInstruction(String,String)
- uid: System.Xml.XmlProcessingInstruction
  parent: System.Xml
  isExternal: false
  name: XmlProcessingInstruction
  nameWithType: XmlProcessingInstruction
  fullName: System.Xml.XmlProcessingInstruction
- uid: System.Xml.XmlDocument.CreateSignificantWhitespace(System.String)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateSignificantWhitespace(String)
  nameWithType: XmlDocument.CreateSignificantWhitespace(String)
  fullName: System.Xml.XmlDocument.CreateSignificantWhitespace(String)
- uid: System.Xml.XmlSignificantWhitespace
  parent: System.Xml
  isExternal: false
  name: XmlSignificantWhitespace
  nameWithType: XmlSignificantWhitespace
  fullName: System.Xml.XmlSignificantWhitespace
- uid: System.Xml.XmlDocument.CreateTextNode(System.String)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateTextNode(String)
  nameWithType: XmlDocument.CreateTextNode(String)
  fullName: System.Xml.XmlDocument.CreateTextNode(String)
- uid: System.Xml.XmlText
  parent: System.Xml
  isExternal: false
  name: XmlText
  nameWithType: XmlText
  fullName: System.Xml.XmlText
- uid: System.Xml.XmlDocument.CreateWhitespace(System.String)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateWhitespace(String)
  nameWithType: XmlDocument.CreateWhitespace(String)
  fullName: System.Xml.XmlDocument.CreateWhitespace(String)
- uid: System.Xml.XmlWhitespace
  parent: System.Xml
  isExternal: false
  name: XmlWhitespace
  nameWithType: XmlWhitespace
  fullName: System.Xml.XmlWhitespace
- uid: System.Xml.XmlDocument.CreateXmlDeclaration(System.String,System.String,System.String)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateXmlDeclaration(String,String,String)
  nameWithType: XmlDocument.CreateXmlDeclaration(String,String,String)
  fullName: System.Xml.XmlDocument.CreateXmlDeclaration(String,String,String)
- uid: System.Xml.XmlDeclaration
  parent: System.Xml
  isExternal: false
  name: XmlDeclaration
  nameWithType: XmlDeclaration
  fullName: System.Xml.XmlDeclaration
- uid: System.Xml.XmlDocument.DocumentElement
  parent: System.Xml.XmlDocument
  isExternal: false
  name: DocumentElement
  nameWithType: XmlDocument.DocumentElement
  fullName: System.Xml.XmlDocument.DocumentElement
- uid: System.Xml.XmlDocument.DocumentType
  parent: System.Xml.XmlDocument
  isExternal: false
  name: DocumentType
  nameWithType: XmlDocument.DocumentType
  fullName: System.Xml.XmlDocument.DocumentType
- uid: System.Xml.XmlDocument.GetElementById(System.String)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: GetElementById(String)
  nameWithType: XmlDocument.GetElementById(String)
  fullName: System.Xml.XmlDocument.GetElementById(String)
- uid: System.Xml.XmlDocument.GetElementsByTagName(System.String)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: GetElementsByTagName(String)
  nameWithType: XmlDocument.GetElementsByTagName(String)
  fullName: System.Xml.XmlDocument.GetElementsByTagName(String)
- uid: System.Xml.XmlNodeList
  parent: System.Xml
  isExternal: false
  name: XmlNodeList
  nameWithType: XmlNodeList
  fullName: System.Xml.XmlNodeList
- uid: System.Xml.XmlDocument.GetElementsByTagName(System.String,System.String)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: GetElementsByTagName(String,String)
  nameWithType: XmlDocument.GetElementsByTagName(String,String)
  fullName: System.Xml.XmlDocument.GetElementsByTagName(String,String)
- uid: System.Xml.XmlDocument.Implementation
  parent: System.Xml.XmlDocument
  isExternal: false
  name: Implementation
  nameWithType: XmlDocument.Implementation
  fullName: System.Xml.XmlDocument.Implementation
- uid: System.Xml.XmlDocument.ImportNode(System.Xml.XmlNode,System.Boolean)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: ImportNode(XmlNode,Boolean)
  nameWithType: XmlDocument.ImportNode(XmlNode,Boolean)
  fullName: System.Xml.XmlDocument.ImportNode(XmlNode,Boolean)
- uid: System.Xml.XmlDocument.InnerText
  parent: System.Xml.XmlDocument
  isExternal: false
  name: InnerText
  nameWithType: XmlDocument.InnerText
  fullName: System.Xml.XmlDocument.InnerText
- uid: System.Xml.XmlDocument.InnerXml
  parent: System.Xml.XmlDocument
  isExternal: false
  name: InnerXml
  nameWithType: XmlDocument.InnerXml
  fullName: System.Xml.XmlDocument.InnerXml
- uid: System.Xml.XmlDocument.IsReadOnly
  parent: System.Xml.XmlDocument
  isExternal: false
  name: IsReadOnly
  nameWithType: XmlDocument.IsReadOnly
  fullName: System.Xml.XmlDocument.IsReadOnly
- uid: System.Xml.XmlDocument.Load(System.IO.Stream)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: Load(Stream)
  nameWithType: XmlDocument.Load(Stream)
  fullName: System.Xml.XmlDocument.Load(Stream)
- uid: System.IO.Stream
  parent: System.IO
  isExternal: true
  name: Stream
  nameWithType: Stream
  fullName: System.IO.Stream
- uid: System.Xml.XmlDocument.Load(System.IO.TextReader)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: Load(TextReader)
  nameWithType: XmlDocument.Load(TextReader)
  fullName: System.Xml.XmlDocument.Load(TextReader)
- uid: System.IO.TextReader
  parent: System.IO
  isExternal: true
  name: TextReader
  nameWithType: TextReader
  fullName: System.IO.TextReader
- uid: System.Xml.XmlDocument.Load(System.String)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: Load(String)
  nameWithType: XmlDocument.Load(String)
  fullName: System.Xml.XmlDocument.Load(String)
- uid: System.Xml.XmlDocument.Load(System.Xml.XmlReader)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: Load(XmlReader)
  nameWithType: XmlDocument.Load(XmlReader)
  fullName: System.Xml.XmlDocument.Load(XmlReader)
- uid: System.Xml.XmlReader
  parent: System.Xml
  isExternal: true
  name: XmlReader
  nameWithType: XmlReader
  fullName: System.Xml.XmlReader
- uid: System.Xml.XmlDocument.LoadXml(System.String)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: LoadXml(String)
  nameWithType: XmlDocument.LoadXml(String)
  fullName: System.Xml.XmlDocument.LoadXml(String)
- uid: System.Xml.XmlDocument.LocalName
  parent: System.Xml.XmlDocument
  isExternal: false
  name: LocalName
  nameWithType: XmlDocument.LocalName
  fullName: System.Xml.XmlDocument.LocalName
- uid: System.Xml.XmlDocument.Name
  parent: System.Xml.XmlDocument
  isExternal: false
  name: Name
  nameWithType: XmlDocument.Name
  fullName: System.Xml.XmlDocument.Name
- uid: System.Xml.XmlDocument.NameTable
  parent: System.Xml.XmlDocument
  isExternal: false
  name: NameTable
  nameWithType: XmlDocument.NameTable
  fullName: System.Xml.XmlDocument.NameTable
- uid: System.Xml.XmlDocument.NodeChanged
  parent: System.Xml.XmlDocument
  isExternal: false
  name: NodeChanged
  nameWithType: XmlDocument.NodeChanged
  fullName: System.Xml.XmlDocument.NodeChanged
- uid: System.Xml.XmlNodeChangedEventHandler
  parent: System.Xml
  isExternal: false
  name: XmlNodeChangedEventHandler
  nameWithType: XmlNodeChangedEventHandler
  fullName: System.Xml.XmlNodeChangedEventHandler
- uid: System.Xml.XmlDocument.NodeChanging
  parent: System.Xml.XmlDocument
  isExternal: false
  name: NodeChanging
  nameWithType: XmlDocument.NodeChanging
  fullName: System.Xml.XmlDocument.NodeChanging
- uid: System.Xml.XmlDocument.NodeInserted
  parent: System.Xml.XmlDocument
  isExternal: false
  name: NodeInserted
  nameWithType: XmlDocument.NodeInserted
  fullName: System.Xml.XmlDocument.NodeInserted
- uid: System.Xml.XmlDocument.NodeInserting
  parent: System.Xml.XmlDocument
  isExternal: false
  name: NodeInserting
  nameWithType: XmlDocument.NodeInserting
  fullName: System.Xml.XmlDocument.NodeInserting
- uid: System.Xml.XmlDocument.NodeRemoved
  parent: System.Xml.XmlDocument
  isExternal: false
  name: NodeRemoved
  nameWithType: XmlDocument.NodeRemoved
  fullName: System.Xml.XmlDocument.NodeRemoved
- uid: System.Xml.XmlDocument.NodeRemoving
  parent: System.Xml.XmlDocument
  isExternal: false
  name: NodeRemoving
  nameWithType: XmlDocument.NodeRemoving
  fullName: System.Xml.XmlDocument.NodeRemoving
- uid: System.Xml.XmlDocument.NodeType
  parent: System.Xml.XmlDocument
  isExternal: false
  name: NodeType
  nameWithType: XmlDocument.NodeType
  fullName: System.Xml.XmlDocument.NodeType
- uid: System.Xml.XmlDocument.OwnerDocument
  parent: System.Xml.XmlDocument
  isExternal: false
  name: OwnerDocument
  nameWithType: XmlDocument.OwnerDocument
  fullName: System.Xml.XmlDocument.OwnerDocument
- uid: System.Xml.XmlDocument
  parent: System.Xml
  isExternal: false
  name: XmlDocument
  nameWithType: XmlDocument
  fullName: System.Xml.XmlDocument
- uid: System.Xml.XmlDocument.ParentNode
  parent: System.Xml.XmlDocument
  isExternal: false
  name: ParentNode
  nameWithType: XmlDocument.ParentNode
  fullName: System.Xml.XmlDocument.ParentNode
- uid: System.Xml.XmlDocument.PreserveWhitespace
  parent: System.Xml.XmlDocument
  isExternal: false
  name: PreserveWhitespace
  nameWithType: XmlDocument.PreserveWhitespace
  fullName: System.Xml.XmlDocument.PreserveWhitespace
- uid: System.Xml.XmlDocument.ReadNode(System.Xml.XmlReader)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: ReadNode(XmlReader)
  nameWithType: XmlDocument.ReadNode(XmlReader)
  fullName: System.Xml.XmlDocument.ReadNode(XmlReader)
- uid: System.Xml.XmlDocument.Save(System.IO.Stream)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: Save(Stream)
  nameWithType: XmlDocument.Save(Stream)
  fullName: System.Xml.XmlDocument.Save(Stream)
- uid: System.Xml.XmlDocument.Save(System.IO.TextWriter)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: Save(TextWriter)
  nameWithType: XmlDocument.Save(TextWriter)
  fullName: System.Xml.XmlDocument.Save(TextWriter)
- uid: System.IO.TextWriter
  parent: System.IO
  isExternal: true
  name: TextWriter
  nameWithType: TextWriter
  fullName: System.IO.TextWriter
- uid: System.Xml.XmlDocument.Save(System.String)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: Save(String)
  nameWithType: XmlDocument.Save(String)
  fullName: System.Xml.XmlDocument.Save(String)
- uid: System.Xml.XmlDocument.Save(System.Xml.XmlWriter)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: Save(XmlWriter)
  nameWithType: XmlDocument.Save(XmlWriter)
  fullName: System.Xml.XmlDocument.Save(XmlWriter)
- uid: System.Xml.XmlWriter
  parent: System.Xml
  isExternal: true
  name: XmlWriter
  nameWithType: XmlWriter
  fullName: System.Xml.XmlWriter
- uid: System.Xml.XmlDocument.SchemaInfo
  parent: System.Xml.XmlDocument
  isExternal: false
  name: SchemaInfo
  nameWithType: XmlDocument.SchemaInfo
  fullName: System.Xml.XmlDocument.SchemaInfo
- uid: System.Xml.Schema.IXmlSchemaInfo
  parent: System.Xml.Schema
  isExternal: false
  name: IXmlSchemaInfo
  nameWithType: IXmlSchemaInfo
  fullName: System.Xml.Schema.IXmlSchemaInfo
- uid: System.Xml.XmlDocument.Schemas
  parent: System.Xml.XmlDocument
  isExternal: false
  name: Schemas
  nameWithType: XmlDocument.Schemas
  fullName: System.Xml.XmlDocument.Schemas
- uid: System.Xml.Schema.XmlSchemaSet
  parent: System.Xml.Schema
  isExternal: false
  name: XmlSchemaSet
  nameWithType: XmlSchemaSet
  fullName: System.Xml.Schema.XmlSchemaSet
- uid: System.Xml.XmlDocument.Validate(System.Xml.Schema.ValidationEventHandler)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: Validate(ValidationEventHandler)
  nameWithType: XmlDocument.Validate(ValidationEventHandler)
  fullName: System.Xml.XmlDocument.Validate(ValidationEventHandler)
- uid: System.Xml.Schema.ValidationEventHandler
  parent: System.Xml.Schema
  isExternal: false
  name: ValidationEventHandler
  nameWithType: ValidationEventHandler
  fullName: System.Xml.Schema.ValidationEventHandler
- uid: System.Xml.XmlDocument.Validate(System.Xml.Schema.ValidationEventHandler,System.Xml.XmlNode)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: Validate(ValidationEventHandler,XmlNode)
  nameWithType: XmlDocument.Validate(ValidationEventHandler,XmlNode)
  fullName: System.Xml.XmlDocument.Validate(ValidationEventHandler,XmlNode)
- uid: System.Xml.XmlDocument.WriteContentTo(System.Xml.XmlWriter)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: WriteContentTo(XmlWriter)
  nameWithType: XmlDocument.WriteContentTo(XmlWriter)
  fullName: System.Xml.XmlDocument.WriteContentTo(XmlWriter)
- uid: System.Xml.XmlDocument.WriteTo(System.Xml.XmlWriter)
  parent: System.Xml.XmlDocument
  isExternal: false
  name: WriteTo(XmlWriter)
  nameWithType: XmlDocument.WriteTo(XmlWriter)
  fullName: System.Xml.XmlDocument.WriteTo(XmlWriter)
- uid: System.Xml.XmlDocument.XmlResolver
  parent: System.Xml.XmlDocument
  isExternal: false
  name: XmlResolver
  nameWithType: XmlDocument.XmlResolver
  fullName: System.Xml.XmlDocument.XmlResolver
- uid: System.Xml.XmlResolver
  parent: System.Xml
  isExternal: false
  name: XmlResolver
  nameWithType: XmlResolver
  fullName: System.Xml.XmlResolver
- uid: System.Xml.XmlDocument.#ctor*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: XmlDocument
  nameWithType: XmlDocument.XmlDocument
- uid: System.Xml.XmlDocument.BaseURI*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: BaseURI
  nameWithType: XmlDocument.BaseURI
- uid: System.Xml.XmlDocument.CloneNode*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CloneNode
  nameWithType: XmlDocument.CloneNode
- uid: System.Xml.XmlDocument.CreateAttribute*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateAttribute
  nameWithType: XmlDocument.CreateAttribute
- uid: System.Xml.XmlDocument.CreateCDataSection*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateCDataSection
  nameWithType: XmlDocument.CreateCDataSection
- uid: System.Xml.XmlDocument.CreateComment*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateComment
  nameWithType: XmlDocument.CreateComment
- uid: System.Xml.XmlDocument.CreateDefaultAttribute*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateDefaultAttribute
  nameWithType: XmlDocument.CreateDefaultAttribute
- uid: System.Xml.XmlDocument.CreateDocumentFragment*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateDocumentFragment
  nameWithType: XmlDocument.CreateDocumentFragment
- uid: System.Xml.XmlDocument.CreateDocumentType*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateDocumentType
  nameWithType: XmlDocument.CreateDocumentType
- uid: System.Xml.XmlDocument.CreateElement*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateElement
  nameWithType: XmlDocument.CreateElement
- uid: System.Xml.XmlDocument.CreateEntityReference*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateEntityReference
  nameWithType: XmlDocument.CreateEntityReference
- uid: System.Xml.XmlDocument.CreateNavigator*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateNavigator
  nameWithType: XmlDocument.CreateNavigator
- uid: System.Xml.XmlDocument.CreateNode*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateNode
  nameWithType: XmlDocument.CreateNode
- uid: System.Xml.XmlDocument.CreateProcessingInstruction*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateProcessingInstruction
  nameWithType: XmlDocument.CreateProcessingInstruction
- uid: System.Xml.XmlDocument.CreateSignificantWhitespace*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateSignificantWhitespace
  nameWithType: XmlDocument.CreateSignificantWhitespace
- uid: System.Xml.XmlDocument.CreateTextNode*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateTextNode
  nameWithType: XmlDocument.CreateTextNode
- uid: System.Xml.XmlDocument.CreateWhitespace*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateWhitespace
  nameWithType: XmlDocument.CreateWhitespace
- uid: System.Xml.XmlDocument.CreateXmlDeclaration*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: CreateXmlDeclaration
  nameWithType: XmlDocument.CreateXmlDeclaration
- uid: System.Xml.XmlDocument.DocumentElement*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: DocumentElement
  nameWithType: XmlDocument.DocumentElement
- uid: System.Xml.XmlDocument.DocumentType*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: DocumentType
  nameWithType: XmlDocument.DocumentType
- uid: System.Xml.XmlDocument.GetElementById*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: GetElementById
  nameWithType: XmlDocument.GetElementById
- uid: System.Xml.XmlDocument.GetElementsByTagName*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: GetElementsByTagName
  nameWithType: XmlDocument.GetElementsByTagName
- uid: System.Xml.XmlDocument.Implementation*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: Implementation
  nameWithType: XmlDocument.Implementation
- uid: System.Xml.XmlDocument.ImportNode*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: ImportNode
  nameWithType: XmlDocument.ImportNode
- uid: System.Xml.XmlDocument.InnerText*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: InnerText
  nameWithType: XmlDocument.InnerText
- uid: System.Xml.XmlDocument.InnerXml*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: InnerXml
  nameWithType: XmlDocument.InnerXml
- uid: System.Xml.XmlDocument.IsReadOnly*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: IsReadOnly
  nameWithType: XmlDocument.IsReadOnly
- uid: System.Xml.XmlDocument.Load*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: Load
  nameWithType: XmlDocument.Load
- uid: System.Xml.XmlDocument.LoadXml*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: LoadXml
  nameWithType: XmlDocument.LoadXml
- uid: System.Xml.XmlDocument.LocalName*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: LocalName
  nameWithType: XmlDocument.LocalName
- uid: System.Xml.XmlDocument.Name*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: Name
  nameWithType: XmlDocument.Name
- uid: System.Xml.XmlDocument.NameTable*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: NameTable
  nameWithType: XmlDocument.NameTable
- uid: System.Xml.XmlDocument.NodeType*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: NodeType
  nameWithType: XmlDocument.NodeType
- uid: System.Xml.XmlDocument.OwnerDocument*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: OwnerDocument
  nameWithType: XmlDocument.OwnerDocument
- uid: System.Xml.XmlDocument.ParentNode*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: ParentNode
  nameWithType: XmlDocument.ParentNode
- uid: System.Xml.XmlDocument.PreserveWhitespace*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: PreserveWhitespace
  nameWithType: XmlDocument.PreserveWhitespace
- uid: System.Xml.XmlDocument.ReadNode*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: ReadNode
  nameWithType: XmlDocument.ReadNode
- uid: System.Xml.XmlDocument.Save*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: Save
  nameWithType: XmlDocument.Save
- uid: System.Xml.XmlDocument.SchemaInfo*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: SchemaInfo
  nameWithType: XmlDocument.SchemaInfo
- uid: System.Xml.XmlDocument.Schemas*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: Schemas
  nameWithType: XmlDocument.Schemas
- uid: System.Xml.XmlDocument.Validate*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: Validate
  nameWithType: XmlDocument.Validate
- uid: System.Xml.XmlDocument.WriteContentTo*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: WriteContentTo
  nameWithType: XmlDocument.WriteContentTo
- uid: System.Xml.XmlDocument.WriteTo*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: WriteTo
  nameWithType: XmlDocument.WriteTo
- uid: System.Xml.XmlDocument.XmlResolver*
  parent: System.Xml.XmlDocument
  isExternal: false
  name: XmlResolver
  nameWithType: XmlDocument.XmlResolver
