### YamlMime:ManagedReference
items:
- uid: System.Threading.Overlapped
  id: Overlapped
  children:
  - System.Threading.Overlapped.#ctor
  - System.Threading.Overlapped.#ctor(System.Int32,System.Int32,System.Int32,System.IAsyncResult)
  - System.Threading.Overlapped.#ctor(System.Int32,System.Int32,System.IntPtr,System.IAsyncResult)
  - System.Threading.Overlapped.AsyncResult
  - System.Threading.Overlapped.EventHandle
  - System.Threading.Overlapped.EventHandleIntPtr
  - System.Threading.Overlapped.Free(System.Threading.NativeOverlapped*)
  - System.Threading.Overlapped.OffsetHigh
  - System.Threading.Overlapped.OffsetLow
  - System.Threading.Overlapped.Pack(System.Threading.IOCompletionCallback)
  - System.Threading.Overlapped.Pack(System.Threading.IOCompletionCallback,System.Object)
  - System.Threading.Overlapped.Unpack(System.Threading.NativeOverlapped*)
  - System.Threading.Overlapped.UnsafePack(System.Threading.IOCompletionCallback)
  - System.Threading.Overlapped.UnsafePack(System.Threading.IOCompletionCallback,System.Object)
  langs:
  - csharp
  name: Overlapped
  nameWithType: Overlapped
  fullName: System.Threading.Overlapped
  type: Class
  summary: "提供的托管的表示形式 Win32`OVERLAPPED`结构，包括方法从 Overlapped 实例到传输信息<xref href=&quot;System.Threading.NativeOverlapped&quot;></xref>结构。"
  remarks: "<xref:System.Threading.Overlapped.Pack%2A>和<xref:System.Threading.Overlapped.UnsafePack%2A>方法从 Overlapped 对象到传输信息<xref:System.Threading.NativeOverlapped>结构，它可以传递给 Win32 API 函数以用于异步文件 I/O。</xref:System.Threading.NativeOverlapped> </xref:System.Threading.Overlapped.UnsafePack%2A> </xref:System.Threading.Overlapped.Pack%2A> <xref:System.Threading.Overlapped.Unpack%2A>从<xref:System.Threading.NativeOverlapped>结构 Overlapped 类的实例</xref:System.Threading.NativeOverlapped>方法传输信息</xref:System.Threading.Overlapped.Unpack%2A>       对 Overlapped 对象的属性更改会影响其关联<xref:System.Threading.NativeOverlapped>结构，反之亦然。</xref:System.Threading.NativeOverlapped>"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public class Overlapped
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Threading.Overlapped.#ctor
  id: '#ctor'
  parent: System.Threading.Overlapped
  langs:
  - csharp
  name: Overlapped()
  nameWithType: Overlapped.Overlapped()
  fullName: System.Threading.Overlapped.Overlapped()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "初始化一个新的空实例<xref href=&quot;System.Threading.Overlapped&quot;></xref>类。"
  syntax:
    content: public Overlapped ();
    parameters: []
  overload: System.Threading.Overlapped.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Overlapped.#ctor(System.Int32,System.Int32,System.Int32,System.IAsyncResult)
  id: '#ctor(System.Int32,System.Int32,System.Int32,System.IAsyncResult)'
  parent: System.Threading.Overlapped
  langs:
  - csharp
  name: Overlapped(Int32,Int32,Int32,IAsyncResult)
  nameWithType: Overlapped.Overlapped(Int32,Int32,Int32,IAsyncResult)
  fullName: System.Threading.Overlapped.Overlapped(Int32,Int32,Int32,IAsyncResult)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "初始化的新实例<xref href=&quot;System.Threading.Overlapped&quot;></xref>类指定的文件位置，在 I/O 操作已完成，有信号状态的事件和用来返回该操作的结果的接口的 32 位整数句柄。"
  remarks: "使用<xref:System.Threading.WaitHandle.Handle%2A?displayProperty=fullName>属性来获取从<xref:System.Threading.WaitHandle>类</xref:System.Threading.WaitHandle>派生的任何托管的同步事件的句柄</xref:System.Threading.WaitHandle.Handle%2A?displayProperty=fullName>       实现<xref:System.IAsyncResult>提供有关 I/O 操作的状态信息。</xref:System.IAsyncResult> 将其传递给构造函数中`ar`参数，并检索其更高版本与<xref:System.Threading.Overlapped.AsyncResult%2A>属性。</xref:System.Threading.Overlapped.AsyncResult%2A> 如果为指定的回调方法<xref:System.Threading.Overlapped.Pack%2A>或<xref:System.Threading.Overlapped.UnsafePack%2A>方法，可以检索回调你<xref:System.IAsyncResult>通过解压缩<xref:System.Threading.NativeOverlapped>它接收的结构。</xref:System.Threading.NativeOverlapped> </xref:System.IAsyncResult> </xref:System.Threading.Overlapped.UnsafePack%2A> </xref:System.Threading.Overlapped.Pack%2A>"
  syntax:
    content: public Overlapped (int offsetLo, int offsetHi, int hEvent, IAsyncResult ar);
    parameters:
    - id: offsetLo
      type: System.Int32
      description: "开始将传输的文件位置低位字。"
    - id: offsetHi
      type: System.Int32
      description: "开始将传输的文件位置高位字。"
    - id: hEvent
      type: System.Int32
      description: "事件 I/O 操作完成时处于有信号状态的句柄。"
    - id: ar
      type: System.IAsyncResult
      description: "实现的对象<xref:System.IAsyncResult>接口，并提供有关 I/O 操作的状态信息。</xref:System.IAsyncResult>"
  overload: System.Threading.Overlapped.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Overlapped.#ctor(System.Int32,System.Int32,System.IntPtr,System.IAsyncResult)
  id: '#ctor(System.Int32,System.Int32,System.IntPtr,System.IAsyncResult)'
  parent: System.Threading.Overlapped
  langs:
  - csharp
  name: Overlapped(Int32,Int32,IntPtr,IAsyncResult)
  nameWithType: Overlapped.Overlapped(Int32,Int32,IntPtr,IAsyncResult)
  fullName: System.Threading.Overlapped.Overlapped(Int32,Int32,IntPtr,IAsyncResult)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "初始化的新实例<xref href=&quot;System.Threading.Overlapped&quot;></xref>类指定的文件位置，在 I/O 操作已完成，有信号状态的事件和用来返回该操作的结果的接口的句柄。"
  remarks: "若要获取派生自托管的同步对象的句柄<xref:System.Threading.WaitHandle>类，而使用<xref:System.Threading.WaitHandle.SafeWaitHandle%2A?displayProperty=fullName>属性来获取<xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>对象，，然后调用<xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A>方法。</xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> </xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> </xref:System.Threading.WaitHandle.SafeWaitHandle%2A?displayProperty=fullName> </xref:System.Threading.WaitHandle>       实现<xref:System.IAsyncResult>提供有关 I/O 操作的状态信息。</xref:System.IAsyncResult> 将其传递给构造函数中`ar`参数，并检索其更高版本与<xref:System.Threading.Overlapped.AsyncResult%2A>属性。</xref:System.Threading.Overlapped.AsyncResult%2A> 如果为指定的回调方法<xref:System.Threading.Overlapped.Pack%2A>或<xref:System.Threading.Overlapped.UnsafePack%2A>方法，可以检索回调你<xref:System.IAsyncResult>通过解压缩<xref:System.Threading.NativeOverlapped>它接收的结构。</xref:System.Threading.NativeOverlapped> </xref:System.IAsyncResult> </xref:System.Threading.Overlapped.UnsafePack%2A> </xref:System.Threading.Overlapped.Pack%2A>"
  syntax:
    content: public Overlapped (int offsetLo, int offsetHi, IntPtr hEvent, IAsyncResult ar);
    parameters:
    - id: offsetLo
      type: System.Int32
      description: "开始将传输的文件位置低位字。"
    - id: offsetHi
      type: System.Int32
      description: "开始将传输的文件位置高位字。"
    - id: hEvent
      type: System.IntPtr
      description: "事件 I/O 操作完成时处于有信号状态的句柄。"
    - id: ar
      type: System.IAsyncResult
      description: "实现的对象<xref:System.IAsyncResult>接口，并提供有关 I/O 操作的状态信息。</xref:System.IAsyncResult>"
  overload: System.Threading.Overlapped.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Overlapped.AsyncResult
  id: AsyncResult
  parent: System.Threading.Overlapped
  langs:
  - csharp
  name: AsyncResult
  nameWithType: Overlapped.AsyncResult
  fullName: System.Threading.Overlapped.AsyncResult
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "获取或设置提供有关 I/O 操作的状态信息的对象。"
  syntax:
    content: public IAsyncResult AsyncResult { get; set; }
    return:
      type: System.IAsyncResult
      description: "实现的对象<xref:System.IAsyncResult>接口。</xref:System.IAsyncResult>"
  overload: System.Threading.Overlapped.AsyncResult*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Overlapped.EventHandle
  id: EventHandle
  parent: System.Threading.Overlapped
  langs:
  - csharp
  name: EventHandle
  nameWithType: Overlapped.EventHandle
  fullName: System.Threading.Overlapped.EventHandle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "获取或设置一个同步事件 I/O 操作完成时处于有信号状态的 32 位整数句柄。"
  remarks: "无法在 64 位平台上使用此属性。 使用<xref:System.Threading.Overlapped.EventHandleIntPtr%2A>属性改为。</xref:System.Threading.Overlapped.EventHandleIntPtr%2A>       使用<xref:System.Threading.WaitHandle.Handle%2A?displayProperty=fullName>属性来获取从<xref:System.Threading.WaitHandle>类</xref:System.Threading.WaitHandle>派生的任何托管的同步事件的句柄</xref:System.Threading.WaitHandle.Handle%2A?displayProperty=fullName>"
  syntax:
    content: public int EventHandle { get; set; }
    return:
      type: System.Int32
      description: "<xref:System.Int32>值，该值表示同步事件的句柄。</xref:System.Int32>"
  overload: System.Threading.Overlapped.EventHandle*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Overlapped.EventHandleIntPtr
  id: EventHandleIntPtr
  parent: System.Threading.Overlapped
  langs:
  - csharp
  name: EventHandleIntPtr
  nameWithType: Overlapped.EventHandleIntPtr
  fullName: System.Threading.Overlapped.EventHandleIntPtr
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "获取或设置同步事件 I/O 操作完成时处于有信号状态的句柄。"
  remarks: "若要获取派生自托管的同步对象的句柄<xref:System.Threading.WaitHandle>类，而使用<xref:System.Threading.WaitHandle.SafeWaitHandle%2A?displayProperty=fullName>属性来获取<xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>对象，，然后调用<xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A>方法。</xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> </xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> </xref:System.Threading.WaitHandle.SafeWaitHandle%2A?displayProperty=fullName> </xref:System.Threading.WaitHandle>"
  syntax:
    content: public IntPtr EventHandleIntPtr { get; set; }
    return:
      type: System.IntPtr
      description: "<xref:System.IntPtr>表示事件的句柄。</xref:System.IntPtr>"
  overload: System.Threading.Overlapped.EventHandleIntPtr*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Overlapped.Free(System.Threading.NativeOverlapped*)
  id: Free(System.Threading.NativeOverlapped*)
  parent: System.Threading.Overlapped
  langs:
  - csharp
  name: Free(NativeOverlapped*)
  nameWithType: Overlapped.Free(NativeOverlapped*)
  fullName: System.Threading.Overlapped.Free(NativeOverlapped*)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "释放与分配的本机重叠结构关联的非托管的内存<xref:System.Threading.Overlapped.Pack*>方法。</xref:System.Threading.Overlapped.Pack*>"
  remarks: "必须完全调用 Free 方法一次打开每个<xref:System.Threading.NativeOverlapped>指针从接收<xref:System.Threading.Overlapped.Pack%2A>方法。</xref:System.Threading.Overlapped.Pack%2A> </xref:System.Threading.NativeOverlapped> 如果你不调用 Free 方法，你将会泄漏内存。 如果不止一次调用可用的方法时，将损坏内存。"
  syntax:
    content: public static void Free (System.Threading.NativeOverlapped* nativeOverlappedPtr);
    parameters:
    - id: nativeOverlappedPtr
      type: System.Threading.NativeOverlapped*
      description: "指向的指针<xref href=&quot;System.Threading.NativeOverlapped&quot;></xref>结构被释放。"
  overload: System.Threading.Overlapped.Free*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>nativeOverlappedPtr</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.Overlapped.OffsetHigh
  id: OffsetHigh
  parent: System.Threading.Overlapped
  langs:
  - csharp
  name: OffsetHigh
  nameWithType: Overlapped.OffsetHigh
  fullName: System.Threading.Overlapped.OffsetHigh
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "获取或设置开始将传输的文件位置的高序位字。 文件位置是从文件的开始的字节偏移量。"
  syntax:
    content: public int OffsetHigh { get; set; }
    return:
      type: System.Int32
      description: "<xref:System.Int32>值，该值表示文件位置的高位字。</xref:System.Int32>"
  overload: System.Threading.Overlapped.OffsetHigh*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Overlapped.OffsetLow
  id: OffsetLow
  parent: System.Threading.Overlapped
  langs:
  - csharp
  name: OffsetLow
  nameWithType: Overlapped.OffsetLow
  fullName: System.Threading.Overlapped.OffsetLow
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "获取或设置开始将传输的文件位置的低序位字。 文件位置是从文件的开始的字节偏移量。"
  syntax:
    content: public int OffsetLow { get; set; }
    return:
      type: System.Int32
      description: "<xref:System.Int32>值，该值表示文件位置的低位字。</xref:System.Int32>"
  overload: System.Threading.Overlapped.OffsetLow*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Overlapped.Pack(System.Threading.IOCompletionCallback)
  id: Pack(System.Threading.IOCompletionCallback)
  parent: System.Threading.Overlapped
  langs:
  - csharp
  name: Pack(IOCompletionCallback)
  nameWithType: Overlapped.Pack(IOCompletionCallback)
  fullName: System.Threading.Overlapped.Pack(IOCompletionCallback)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "当前实例打包为<xref href=&quot;System.Threading.NativeOverlapped&quot;></xref>结构，并指定要在异步 I/O 操作完成时调用的委托。"
  remarks: "此方法返回的非托管的指针可以传递到重叠的 I/O 操作中的操作系统。 <xref:System.Threading.NativeOverlapped>结构固定的物理内存中，直到<xref:System.Threading.Overlapped.Unpack%2A>称为。</xref:System.Threading.Overlapped.Unpack%2A> </xref:System.Threading.NativeOverlapped>      1> [!IMPORTANT]&1;> 调用方负责，无法固定缓冲区。 如果应用程序域被卸载，但是，固定的缓冲区的句柄销毁该对象并释放缓冲区，使 I/O 操作写入已释放的地址。 为此，最好使用<xref:System.Threading.Overlapped.Pack%28System.Threading.IOCompletionCallback%2CSystem.Object%29>方法重载中，在其中运行时钉住缓冲区。</xref:System.Threading.Overlapped.Pack%28System.Threading.IOCompletionCallback%2CSystem.Object%29>"
  syntax:
    content: public System.Threading.NativeOverlapped* Pack (System.Threading.IOCompletionCallback iocb);
    parameters:
    - id: iocb
      type: System.Threading.IOCompletionCallback
      description: "<xref href=&quot;System.Threading.IOCompletionCallback&quot;> </xref>表示异步 I/O 操作完成时调用的回调方法的委托。"
    return:
      type: System.Threading.NativeOverlapped*
      description: "指向非托管的指针<xref href=&quot;System.Threading.NativeOverlapped&quot;></xref>结构。"
  overload: System.Threading.Overlapped.Pack*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "当前<xref href=&quot;System.Threading.Overlapped&quot;></xref>已打包。"
  platform:
  - net462
- uid: System.Threading.Overlapped.Pack(System.Threading.IOCompletionCallback,System.Object)
  id: Pack(System.Threading.IOCompletionCallback,System.Object)
  parent: System.Threading.Overlapped
  langs:
  - csharp
  name: Pack(IOCompletionCallback,Object)
  nameWithType: Overlapped.Pack(IOCompletionCallback,Object)
  fullName: System.Threading.Overlapped.Pack(IOCompletionCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "当前实例打包为<xref href=&quot;System.Threading.NativeOverlapped&quot;></xref>结构，并指定异步 I/O 操作完成时调用的委托以及作为缓冲区的托管的对象。"
  remarks: "此方法返回的非托管的指针可以传递到重叠的 I/O 操作中的操作系统。 <xref:System.Threading.NativeOverlapped>结构固定的物理内存中，直到<xref:System.Threading.Overlapped.Unpack%2A>称为。</xref:System.Threading.Overlapped.Unpack%2A> </xref:System.Threading.NativeOverlapped>       缓冲区或中指定的缓冲区`userData`必须不同于传递给非托管的操作系统函数执行的异步 I/O。      1> [!NOTE]&1;> 运行时固定的缓冲区或中指定的缓冲区`userData`I/O 操作的持续时间。 如果卸载应用程序域时，运行时将保持固定，直到 I/O 操作完成的内存。"
  syntax:
    content: public System.Threading.NativeOverlapped* Pack (System.Threading.IOCompletionCallback iocb, object userData);
    parameters:
    - id: iocb
      type: System.Threading.IOCompletionCallback
      description: "<xref href=&quot;System.Threading.IOCompletionCallback&quot;> </xref>表示异步 I/O 操作完成时调用的回调方法的委托。"
    - id: userData
      type: System.Object
      description: "一个对象或数组的对象表示该操作的输入或输出缓冲区。 每个对象表示的缓冲区，例如的字节数组。"
    return:
      type: System.Threading.NativeOverlapped*
      description: "指向非托管的指针<xref href=&quot;System.Threading.NativeOverlapped&quot;></xref>结构。"
  overload: System.Threading.Overlapped.Pack*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "当前<xref href=&quot;System.Threading.Overlapped&quot;></xref>已打包。"
  platform:
  - net462
- uid: System.Threading.Overlapped.Unpack(System.Threading.NativeOverlapped*)
  id: Unpack(System.Threading.NativeOverlapped*)
  parent: System.Threading.Overlapped
  langs:
  - csharp
  name: Unpack(NativeOverlapped*)
  nameWithType: Overlapped.Unpack(NativeOverlapped*)
  fullName: System.Threading.Overlapped.Unpack(NativeOverlapped*)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "解包指定的非托管<xref href=&quot;System.Threading.NativeOverlapped&quot;></xref>到托管的结构<xref href=&quot;System.Threading.Overlapped&quot;></xref>对象。"
  remarks: "<xref:System.Threading.NativeOverlapped>结构不释放从物理内存，直到你调用<xref:System.Threading.Overlapped.Free%2A>方法。</xref:System.Threading.Overlapped.Free%2A> </xref:System.Threading.NativeOverlapped>"
  syntax:
    content: public static System.Threading.Overlapped Unpack (System.Threading.NativeOverlapped* nativeOverlappedPtr);
    parameters:
    - id: nativeOverlappedPtr
      type: System.Threading.NativeOverlapped*
      description: "指向非托管的指针<xref href=&quot;System.Threading.NativeOverlapped&quot;></xref>结构。"
    return:
      type: System.Threading.Overlapped
      description: "<xref href=&quot;System.Threading.Overlapped&quot;> </xref>对象包含的信息解压缩本机结构中。"
  overload: System.Threading.Overlapped.Unpack*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>nativeOverlappedPtr</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.Overlapped.UnsafePack(System.Threading.IOCompletionCallback)
  id: UnsafePack(System.Threading.IOCompletionCallback)
  parent: System.Threading.Overlapped
  langs:
  - csharp
  name: UnsafePack(IOCompletionCallback)
  nameWithType: Overlapped.UnsafePack(IOCompletionCallback)
  fullName: System.Threading.Overlapped.UnsafePack(IOCompletionCallback)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "当前实例打包为<xref href=&quot;System.Threading.NativeOverlapped&quot;></xref>结构，它指定要在异步 I/O 操作已完成时调用的委托。 不传播将调用堆栈。"
  remarks: "此方法返回的非托管的指针可以传递到重叠的 I/O 操作中的操作系统。 <xref:System.Threading.NativeOverlapped>结构固定的物理内存中，直到<xref:System.Threading.Overlapped.Unpack%2A>称为。</xref:System.Threading.Overlapped.Unpack%2A> </xref:System.Threading.NativeOverlapped>       调用方负责钉住缓冲区。 如果应用程序域被卸载，但是，固定的缓冲区的句柄销毁该对象并释放缓冲区，使 I/O 操作写入已释放的地址。 为此，最好使用<xref:System.Threading.Overlapped.UnsafePack%28System.Threading.IOCompletionCallback%2CSystem.Object%29>方法重载中，在其中运行时钉住缓冲区。</xref:System.Threading.Overlapped.UnsafePack%28System.Threading.IOCompletionCallback%2CSystem.Object%29>      1> [!CAUTION]&1;> 使用<xref:System.Threading.Overlapped.UnsafePack%2A>方法可能会无意中打开安全漏洞。</xref:System.Threading.Overlapped.UnsafePack%2A> 代码访问安全性将基于堆栈的所有调用方的权限其权限检查。 <xref:System.Threading.Overlapped.UnsafePack%2A>方法将调用堆栈不传播。</xref:System.Threading.Overlapped.UnsafePack%2A> 恶意代码可能能够利用这一点避开权限检查。"
  syntax:
    content: public System.Threading.NativeOverlapped* UnsafePack (System.Threading.IOCompletionCallback iocb);
    parameters:
    - id: iocb
      type: System.Threading.IOCompletionCallback
      description: "<xref href=&quot;System.Threading.IOCompletionCallback&quot;> </xref>表示异步 I/O 操作完成时调用的回调方法的委托。"
    return:
      type: System.Threading.NativeOverlapped*
      description: "指向非托管的指针<xref href=&quot;System.Threading.NativeOverlapped&quot;></xref>结构。"
  overload: System.Threading.Overlapped.UnsafePack*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "当前<xref href=&quot;System.Threading.Overlapped&quot;></xref>已打包。"
  platform:
  - net462
- uid: System.Threading.Overlapped.UnsafePack(System.Threading.IOCompletionCallback,System.Object)
  id: UnsafePack(System.Threading.IOCompletionCallback,System.Object)
  parent: System.Threading.Overlapped
  langs:
  - csharp
  name: UnsafePack(IOCompletionCallback,Object)
  nameWithType: Overlapped.UnsafePack(IOCompletionCallback,Object)
  fullName: System.Threading.Overlapped.UnsafePack(IOCompletionCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "当前实例打包为<xref href=&quot;System.Threading.NativeOverlapped&quot;></xref>结构，并指定要在异步 I/O 操作已完成和托管对象时调用的委托作为缓冲区。 不传播将调用堆栈。"
  remarks: "此方法返回的非托管的指针可以传递到重叠的 I/O 操作中的操作系统。 <xref:System.Threading.NativeOverlapped>结构固定的物理内存中，直到<xref:System.Threading.Overlapped.Unpack%2A>称为。</xref:System.Threading.Overlapped.Unpack%2A> </xref:System.Threading.NativeOverlapped>       缓冲区或中指定的缓冲区`userData`必须不同于传递给非托管的操作系统函数执行的异步 I/O。       运行时固定的缓冲区或中指定的缓冲区`userData`I/O 操作的持续时间。 如果卸载应用程序域时，运行时将保持固定，直到 I/O 操作完成的内存。      1> [!CAUTION]&1;> 使用 UnsafePack 方法可能会无意中打开安全漏洞。 代码访问安全性将基于堆栈的所有调用方的权限其权限检查。 UnsafePack 方法将调用堆栈不传播。 恶意代码可能能够利用这一点避开权限检查。"
  syntax:
    content: public System.Threading.NativeOverlapped* UnsafePack (System.Threading.IOCompletionCallback iocb, object userData);
    parameters:
    - id: iocb
      type: System.Threading.IOCompletionCallback
      description: "<xref href=&quot;System.Threading.IOCompletionCallback&quot;> </xref>表示异步 I/O 操作完成时调用的回调方法的委托。"
    - id: userData
      type: System.Object
      description: "一个对象或数组的对象表示该操作的输入或输出缓冲区。 每个对象表示的缓冲区，例如的字节数组。"
    return:
      type: System.Threading.NativeOverlapped*
      description: "指向非托管的指针<xref href=&quot;System.Threading.NativeOverlapped&quot;></xref>结构。"
  overload: System.Threading.Overlapped.UnsafePack*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "当前<xref href=&quot;System.Threading.Overlapped&quot;></xref>已填满。"
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.Threading.Overlapped.#ctor
  parent: System.Threading.Overlapped
  isExternal: false
  name: Overlapped()
  nameWithType: Overlapped.Overlapped()
  fullName: System.Threading.Overlapped.Overlapped()
- uid: System.Threading.Overlapped.#ctor(System.Int32,System.Int32,System.Int32,System.IAsyncResult)
  parent: System.Threading.Overlapped
  isExternal: false
  name: Overlapped(Int32,Int32,Int32,IAsyncResult)
  nameWithType: Overlapped.Overlapped(Int32,Int32,Int32,IAsyncResult)
  fullName: System.Threading.Overlapped.Overlapped(Int32,Int32,Int32,IAsyncResult)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.Threading.Overlapped.#ctor(System.Int32,System.Int32,System.IntPtr,System.IAsyncResult)
  parent: System.Threading.Overlapped
  isExternal: false
  name: Overlapped(Int32,Int32,IntPtr,IAsyncResult)
  nameWithType: Overlapped.Overlapped(Int32,Int32,IntPtr,IAsyncResult)
  fullName: System.Threading.Overlapped.Overlapped(Int32,Int32,IntPtr,IAsyncResult)
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Threading.Overlapped.AsyncResult
  parent: System.Threading.Overlapped
  isExternal: false
  name: AsyncResult
  nameWithType: Overlapped.AsyncResult
  fullName: System.Threading.Overlapped.AsyncResult
- uid: System.Threading.Overlapped.EventHandle
  parent: System.Threading.Overlapped
  isExternal: false
  name: EventHandle
  nameWithType: Overlapped.EventHandle
  fullName: System.Threading.Overlapped.EventHandle
- uid: System.Threading.Overlapped.EventHandleIntPtr
  parent: System.Threading.Overlapped
  isExternal: false
  name: EventHandleIntPtr
  nameWithType: Overlapped.EventHandleIntPtr
  fullName: System.Threading.Overlapped.EventHandleIntPtr
- uid: System.Threading.Overlapped.Free(System.Threading.NativeOverlapped*)
  parent: System.Threading.Overlapped
  isExternal: false
  name: Free(NativeOverlapped*)
  nameWithType: Overlapped.Free(NativeOverlapped*)
  fullName: System.Threading.Overlapped.Free(NativeOverlapped*)
- uid: System.Threading.Overlapped.OffsetHigh
  parent: System.Threading.Overlapped
  isExternal: false
  name: OffsetHigh
  nameWithType: Overlapped.OffsetHigh
  fullName: System.Threading.Overlapped.OffsetHigh
- uid: System.Threading.Overlapped.OffsetLow
  parent: System.Threading.Overlapped
  isExternal: false
  name: OffsetLow
  nameWithType: Overlapped.OffsetLow
  fullName: System.Threading.Overlapped.OffsetLow
- uid: System.Threading.Overlapped.Pack(System.Threading.IOCompletionCallback)
  parent: System.Threading.Overlapped
  isExternal: false
  name: Pack(IOCompletionCallback)
  nameWithType: Overlapped.Pack(IOCompletionCallback)
  fullName: System.Threading.Overlapped.Pack(IOCompletionCallback)
- uid: System.Threading.IOCompletionCallback
  parent: System.Threading
  isExternal: false
  name: IOCompletionCallback
  nameWithType: IOCompletionCallback
  fullName: System.Threading.IOCompletionCallback
- uid: System.Threading.Overlapped.Pack(System.Threading.IOCompletionCallback,System.Object)
  parent: System.Threading.Overlapped
  isExternal: false
  name: Pack(IOCompletionCallback,Object)
  nameWithType: Overlapped.Pack(IOCompletionCallback,Object)
  fullName: System.Threading.Overlapped.Pack(IOCompletionCallback,Object)
- uid: System.Threading.Overlapped.Unpack(System.Threading.NativeOverlapped*)
  parent: System.Threading.Overlapped
  isExternal: false
  name: Unpack(NativeOverlapped*)
  nameWithType: Overlapped.Unpack(NativeOverlapped*)
  fullName: System.Threading.Overlapped.Unpack(NativeOverlapped*)
- uid: System.Threading.Overlapped
  parent: System.Threading
  isExternal: false
  name: Overlapped
  nameWithType: Overlapped
  fullName: System.Threading.Overlapped
- uid: System.Threading.Overlapped.UnsafePack(System.Threading.IOCompletionCallback)
  parent: System.Threading.Overlapped
  isExternal: false
  name: UnsafePack(IOCompletionCallback)
  nameWithType: Overlapped.UnsafePack(IOCompletionCallback)
  fullName: System.Threading.Overlapped.UnsafePack(IOCompletionCallback)
- uid: System.Threading.Overlapped.UnsafePack(System.Threading.IOCompletionCallback,System.Object)
  parent: System.Threading.Overlapped
  isExternal: false
  name: UnsafePack(IOCompletionCallback,Object)
  nameWithType: Overlapped.UnsafePack(IOCompletionCallback,Object)
  fullName: System.Threading.Overlapped.UnsafePack(IOCompletionCallback,Object)
- uid: System.Threading.Overlapped.#ctor*
  parent: System.Threading.Overlapped
  isExternal: false
  name: Overlapped
  nameWithType: Overlapped.Overlapped
- uid: System.Threading.Overlapped.AsyncResult*
  parent: System.Threading.Overlapped
  isExternal: false
  name: AsyncResult
  nameWithType: Overlapped.AsyncResult
- uid: System.Threading.Overlapped.EventHandle*
  parent: System.Threading.Overlapped
  isExternal: false
  name: EventHandle
  nameWithType: Overlapped.EventHandle
- uid: System.Threading.Overlapped.EventHandleIntPtr*
  parent: System.Threading.Overlapped
  isExternal: false
  name: EventHandleIntPtr
  nameWithType: Overlapped.EventHandleIntPtr
- uid: System.Threading.Overlapped.Free*
  parent: System.Threading.Overlapped
  isExternal: false
  name: Free
  nameWithType: Overlapped.Free
- uid: System.Threading.Overlapped.OffsetHigh*
  parent: System.Threading.Overlapped
  isExternal: false
  name: OffsetHigh
  nameWithType: Overlapped.OffsetHigh
- uid: System.Threading.Overlapped.OffsetLow*
  parent: System.Threading.Overlapped
  isExternal: false
  name: OffsetLow
  nameWithType: Overlapped.OffsetLow
- uid: System.Threading.Overlapped.Pack*
  parent: System.Threading.Overlapped
  isExternal: false
  name: Pack
  nameWithType: Overlapped.Pack
- uid: System.Threading.Overlapped.Unpack*
  parent: System.Threading.Overlapped
  isExternal: false
  name: Unpack
  nameWithType: Overlapped.Unpack
- uid: System.Threading.Overlapped.UnsafePack*
  parent: System.Threading.Overlapped
  isExternal: false
  name: UnsafePack
  nameWithType: Overlapped.UnsafePack
