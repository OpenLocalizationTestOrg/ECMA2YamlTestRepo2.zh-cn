### YamlMime:ManagedReference
items:
- uid: System.Windows.DependencyProperty
  id: DependencyProperty
  children:
  - System.Windows.DependencyProperty.AddOwner(System.Type)
  - System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.DefaultMetadata
  - System.Windows.DependencyProperty.GetHashCode
  - System.Windows.DependencyProperty.GetMetadata(System.Type)
  - System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)
  - System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)
  - System.Windows.DependencyProperty.GlobalIndex
  - System.Windows.DependencyProperty.IsValidType(System.Object)
  - System.Windows.DependencyProperty.IsValidValue(System.Object)
  - System.Windows.DependencyProperty.Name
  - System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyProperty.OwnerType
  - System.Windows.DependencyProperty.PropertyType
  - System.Windows.DependencyProperty.ReadOnly
  - System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)
  - System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)
  - System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.ToString
  - System.Windows.DependencyProperty.UnsetValue
  - System.Windows.DependencyProperty.ValidateValueCallback
  langs:
  - csharp
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
  type: Class
  summary: "表示可如通过方法设置的属性、 样式、 数据绑定、 动画和继承。"
  remarks: "DependencyProperty 支持中的以下功能[!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)]:-该属性可以设置样式。 有关详细信息，请参阅[样式和模板化](~/add/includes/ajax-current-ext-md.md)。      -该属性可以设置数据绑定。 有关数据绑定依赖项属性的详细信息，请参阅[如何︰ 将两个控件属性的绑定](~/add/includes/ajax-current-ext-md.md)。      -该属性可以设置的动态资源引用。 有关详细信息，请参阅[XAML 资源](~/add/includes/ajax-current-ext-md.md)。      -该属性可以继承其值自动从元素树中父元素。 有关详细信息，请参阅[属性值继承](~/add/includes/ajax-current-ext-md.md)。      -该属性可以进行动画处理。 有关详细信息，请参阅[动画概述](~/add/includes/ajax-current-ext-md.md)。      -该属性可以报告时已更改属性的上一个值，并且可强制转换的属性值。 有关详细信息，请参阅[依赖项属性的回调和验证](~/add/includes/ajax-current-ext-md.md)。      -属性报告到的信息[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，例如更改属性值是否应需要布局系统重新编写的元素的视觉对象。      -属性接收中的支持[!INCLUDE[wpfdesigner_current_long](~/add/includes/wpfdesigner-current-long-md.md)]。  例如，可以在中编辑属性**属性**窗口。       若要了解有关依赖项属性的详细信息，请参阅[依赖项属性概述](~/add/includes/ajax-current-ext-md.md)。 如果希望在你自定义的类型，上面的列表中支持的功能上的属性，则应创建一个依赖项属性。  若要了解如何创建自定义的依赖项属性，请参阅[自定义的依赖项属性](~/add/includes/ajax-current-ext-md.md)。       附加的属性是一个属性，使报表信息传递到定义附加的属性的类型的任何对象。 在[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，任何类型，继承自<xref:System.Windows.DependencyObject>可以使用附加的属性而不考虑该类型是否继承自定义属性的类型。</xref:System.Windows.DependencyObject> 附加的属性是一项功能的[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]语言。  在中设置附加的属性[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]，使用*所有者类型*。*propertyName*语法。 附加属性的一个示例是<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName>属性。</xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName> 如果你想要创建一个属性，可以使用对所有<xref:System.Windows.DependencyObject>类型，则你应创建附加的属性。</xref:System.Windows.DependencyObject> 若要了解有关附加属性，包括如何创建它们，请参阅[附加属性概述](~/add/includes/ajax-current-ext-md.md)。      <a name=&quot;xamlAttributeUsage_DependencyProperty&quot;></a># # XAML 属性用法```   <object property=&quot;dependencyPropertyName&quot;/>   - or -   <object property=&quot;ownerType.dependencyPropertyName&quot;/>   - or -   <object property=&quot;attachedPropertyOwnerType.attachedPropertyName&quot;/>   ``` <a name=&quot;xamlValues_DependencyProperty&quot;> </a> # # XAML 值`dependencyPropertyName`一个字符串，指定<xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName>的所需的依赖属性。</xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName>       这可以前面是 XML 命名空间前缀如果属性不在默认 XML 命名空间 (有关详细信息，请参阅[XAML 命名空间和 Namespace 映射为 WPF XAML](~/add/includes/ajax-current-ext-md.md)。)      `ownerType`.`dependencyPropertyName`    一个字符串，指定的依赖项属性，句点 （.），然后<xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName>.</xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName>所有者类型 `ownerType`此外前面是 XML 命名空间前缀。 这种用法是特定于后期绑定样式和模板，其中依赖项属性的所有者必须指定用于分析上下文，因为`TargetType`来说未知。 有关详细信息，请参阅[样式和模板化](../Topic/Styling%20and%20Templating.md)。       `attachedPropertyOwnerType` *.* `attachedPropertyName`一个字符串，指定附加的属性，句点 （.），然后附加的属性名称的所有者。 `attachedPropertyOwnerType`此外前面是 XML 命名空间前缀。"
  syntax:
    content: >-
      [System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]

      [System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))]

      public sealed class DependencyProperty
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.AddOwner(System.Type)
  id: AddOwner(System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: AddOwner(Type)
  nameWithType: DependencyProperty.AddOwner(Type)
  fullName: System.Windows.DependencyProperty.AddOwner(Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "将另一种类型添加为已注册的依赖项属性的所有者。"
  remarks: "此方法使属性系统可以识别在最初未注册该特定的依赖项属性的类型上的依赖项属性。       通常情况下，使用 AddOwner 将依赖项属性添加到已不会公开通过托管的类继承该依赖项属性的类 （类继承将导致要由派生类继承的包装器属性，并且进而已提供对依赖项属性的一般的成员表访问）。 AddOwner 使属性系统可以识别在最初未注册该依赖项属性的类型上的依赖项属性。       此签名不允许用于指定元数据。  当你使用此方法时，元数据自动生成的新<xref:System.Windows.DependencyProperty>和其所有者类型。</xref:System.Windows.DependencyProperty> 自动生成元数据是从所有已定义此属性的基类型合并的元数据的结果。 如果未合并的元数据可用，则会使用属性的默认元数据。 如果通过使用注册属性<xref:System.Windows.DependencyProperty.RegisterAttached%2A>方法，则默认元数据是时，将创建的元数据相同<xref:System.Windows.DependencyProperty.RegisterAttached%2A>曾。</xref:System.Windows.DependencyProperty.RegisterAttached%2A> </xref:System.Windows.DependencyProperty.RegisterAttached%2A> 否则为<xref:System.Windows.PropertyMetadata>对象创建与<xref:System.Windows.PropertyMetadata.DefaultValue%2A>属性设置为该属性类型的默认和所有其他属性<xref:System.Windows.PropertyMetadata>设置为`null`。</xref:System.Windows.PropertyMetadata> </xref:System.Windows.PropertyMetadata.DefaultValue%2A> </xref:System.Windows.PropertyMetadata> 使用<xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>签名，如果你想要为添加到所提供的类型的依赖项属性的版本提供元数据。</xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>       此方法的返回值通常用于声明和通过将存储一个依赖属性标识符公开的依赖属性。 此标识符提供对依赖项属性的访问，如果你想要调用属性系统[!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)]针对依赖项，尤其是当它上是否存在添加的所有者类。 原始所有者和添加的所有者的相同属性名称应该用于指示类似的功能。 应使用<xref:System.Windows.DependencyProperty>返回 AddOwner 方法来定义依赖属性标识符，并还声明值[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]属性包装器，将添加到使用 AddOwner 的类型的依赖项属性。</xref:System.Windows.DependencyProperty>       创建声明内的依赖项属性时使用了上面推荐 AddOwner 方法[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]。 例如，同时<xref:System.Windows.Controls.Border>和<xref:System.Windows.Controls.Control>定义`BorderBrush`具有类似的功能的依赖项属性。</xref:System.Windows.Controls.Control> </xref:System.Windows.Controls.Border> <xref:System.Windows.Controls.Control>定义其`BorderBrush`到通过调用 AddOwner 属性系统的属性基于原始所有者<xref:System.Windows.Controls.Border>和其已注册<xref:System.Windows.Controls.Border.BorderBrushProperty>依赖项属性标识符。</xref:System.Windows.Controls.Border.BorderBrushProperty> </xref:System.Windows.Controls.Border></xref:System.Windows.Controls.Control> AddOwner 返回值然后用于建立新的静态<xref:System.Windows.DependencyProperty>字段 (<xref:System.Windows.Controls.Control.BorderBrushProperty>) 上添加的所有者，该属性的和`BorderBrush`属性包装也被声明。</xref:System.Windows.Controls.Control.BorderBrushProperty> </xref:System.Windows.DependencyProperty>"
  syntax:
    content: public System.Windows.DependencyProperty AddOwner (Type ownerType);
    parameters:
    - id: ownerType
      type: System.Type
      description: "要作为此依赖属性所有者添加的类型。"
    return:
      type: System.Windows.DependencyProperty
      description: "与原始引用<xref href=&quot;System.Windows.DependencyProperty&quot;></xref>标识的依赖项属性的标识符。 应通过将类添加为公开此标识符<xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;></xref>字段。"
  overload: System.Windows.DependencyProperty.AddOwner*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)
  id: AddOwner(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: AddOwner(Type,PropertyMetadata)
  nameWithType: DependencyProperty.AddOwner(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.AddOwner(Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "将另一种类型添加为已注册的依赖项属性的所有者，因为它将在提供的所有者类型上存在的依赖项属性提供依赖属性元数据。"
  remarks: "此方法使属性系统可以识别在最初未注册该特定的依赖项属性的类型上的依赖项属性。       此方法的返回值用于声明和公开这样的依赖项属性中，尤其当它位于添加的所有者类。 通常情况下，应使用原始所有者和添加的所有者的相同属性名称以指示类似的功能。 它是公开的标识符，也作为新的好办法[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]属性包装器，将添加到使用<xref:System.Windows.DependencyProperty.AddOwner%2A>.</xref:System.Windows.DependencyProperty.AddOwner%2A>的类型的依赖项属性       <xref:System.Windows.DependencyProperty.AddOwner%2A>上面推荐的方法创建使用[!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)]内声明[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]。</xref:System.Windows.DependencyProperty.AddOwner%2A> 例如，同时<xref:System.Windows.Controls.Border>和<xref:System.Windows.Controls.Control>定义`BorderBrush`具有类似的功能的依赖项属性。</xref:System.Windows.Controls.Control> </xref:System.Windows.Controls.Border> <xref:System.Windows.Controls.Control>定义其`BorderBrush`到通过调用属性系统属性<xref:System.Windows.DependencyProperty.AddOwner%2A>的原始所有者<xref:System.Windows.Controls.Border>和其已注册<xref:System.Windows.Controls.Border.BorderBrushProperty>依赖项属性标识符。</xref:System.Windows.Controls.Border.BorderBrushProperty> </xref:System.Windows.Controls.Border> </xref:System.Windows.DependencyProperty.AddOwner%2A></xref:System.Windows.Controls.Control> <xref:System.Windows.DependencyProperty.AddOwner%2A>返回值然后用于建立一个静态<xref:System.Windows.DependencyProperty>字段 (<xref:System.Windows.Controls.Control.BorderBrushProperty>) 上添加的所有者，该属性的和`BorderBrush`属性包装也被声明。</xref:System.Windows.Controls.Control.BorderBrushProperty> </xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty.AddOwner%2A>       添加的所有者的依赖属性标识符应使用<xref:System.Windows.DependencyObject.GetValue%2A>.</xref:System.Windows.DependencyObject.GetValue%2A>等操作 但是，涉及类型或已添加，因为仍将使用不同的元数据的所有者的类的实例的特定类型的操作返回预期的结果，即使原始 （不是添加的所有者的） 对如<xref:System.Windows.DependencyObject.GetValue%2A>或<xref:System.Windows.DependencyProperty.GetMetadata%2A>.</xref:System.Windows.DependencyProperty.GetMetadata%2A></xref:System.Windows.DependencyObject.GetValue%2A>方法调用中指定的依赖项属性标识符 元数据的添加所有者 AddOwner 通过调用其自身，不一定是以独占方式添加的所有者类标识符字段引用。 不过，它是公开的标识符，也作为新的好办法，[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]都会添加到类型使用 AddOwner，因为如果不这样做创建之间的差异的依赖项属性的属性包装，[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]和[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]您的属性的表示形式。       提供的元数据与依赖项属性的属性元数据合并，因为它存在于基的所有者。 将保留在原始的基本元数据中未指定任何特征。 仅已专门在新的元数据中更改这些特征将重写的基本元数据的特征。 某些特征，如<xref:System.Windows.PropertyMetadata.DefaultValue%2A>，如果在新的元数据中指定了替换。</xref:System.Windows.PropertyMetadata.DefaultValue%2A> 其他，如<xref:System.Windows.PropertyChangedCallback>，又。</xref:System.Windows.PropertyChangedCallback> 最终，合并行为取决于正在用于重写时，因此此处所述的行为是使用现有的属性元数据类的属性元数据类型[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]依赖项属性。 有关详细信息，请参阅[依赖属性元数据](~/add/includes/ajax-current-ext-md.md)和[Framework 属性元数据](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: ownerType
      type: System.Type
      description: "要作为此依赖属性所有者添加的类型。"
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "限定依赖项属性，因为它存在于所提供的类型的元数据。"
    return:
      type: System.Windows.DependencyProperty
      description: "与原始引用<xref href=&quot;System.Windows.DependencyProperty&quot;></xref>标识的依赖项属性的标识符。 应通过将类添加为公开此标识符<xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;></xref>字段。"
  overload: System.Windows.DependencyProperty.AddOwner*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.DefaultMetadata
  id: DefaultMetadata
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: DefaultMetadata
  nameWithType: DependencyProperty.DefaultMetadata
  fullName: System.Windows.DependencyProperty.DefaultMetadata
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "获取依赖项属性的默认元数据。"
  remarks: "默认元数据是通过显式提供任何替换元数据已其中将适用于该特定对象或派生类型的对象的属性元数据<xref:System.Windows.DependencyProperty.Register%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>调用。</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.Register%2A>       如果原始所有者元数据应用到第一个<xref:System.Windows.DependencyProperty.Register%2A>建立依赖项属性，则为 DefaultMetadata 返回该元数据的调用。</xref:System.Windows.DependencyProperty.Register%2A>       如果没有元数据已应用在原始<xref:System.Windows.DependencyProperty.Register%2A>调用，则默认元数据生成内<xref:System.Windows.DependencyProperty.Register%2A>调用并将此值将作为 DefaultMetadata。</xref:System.Windows.DependencyProperty.Register%2A> </xref:System.Windows.DependencyProperty.Register%2A>       具有与关联的默认元数据的主要用途<xref:System.Windows.DependencyProperty>旨在提供对任何此属性的默认值<xref:System.Windows.DependencyObject>或派生的类型。</xref:System.Windows.DependencyObject> </xref:System.Windows.DependencyProperty>       对于非附加属性，此属性返回的元数据类型不能强制转换为派生类型的<xref:System.Windows.PropertyMetadata>键入，即使该属性最初注册了一个派生的元数据类型。</xref:System.Windows.PropertyMetadata> 如果您需要最初已注册的元数据，包括其原始的可能派生的元数据类型，调用<xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29>，传递原始注册类型作为参数。</xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29>       对于附加属性，此属性返回的元数据的类型将与原始中给定的类型匹配<xref:System.Windows.DependencyProperty.RegisterAttached%2A>注册方法。</xref:System.Windows.DependencyProperty.RegisterAttached%2A>"
  example:
  - "[!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  \n[!code-cs[PropertySystemEsoterics#DPDefaultValue](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]\n[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]"
  syntax:
    content: public System.Windows.PropertyMetadata DefaultMetadata { get; }
    return:
      type: System.Windows.PropertyMetadata
      description: "依赖项属性的默认元数据。"
  overload: System.Windows.DependencyProperty.DefaultMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetHashCode
  id: GetHashCode
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetHashCode()
  nameWithType: DependencyProperty.GetHashCode()
  fullName: System.Windows.DependencyProperty.GetHashCode()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "返回此哈希代码<xref href=&quot;System.Windows.DependencyProperty&quot;> </xref>。"
  remarks: "属性系统使用其自己的唯一标识符<xref:System.Windows.DependencyProperty.GlobalIndex%2A>，并且由 GetHashCode 返回该属性的值。</xref:System.Windows.DependencyProperty.GlobalIndex%2A>"
  syntax:
    content: public override int GetHashCode ();
    parameters: []
    return:
      type: System.Int32
      description: "此哈希代码<xref href=&quot;System.Windows.DependencyProperty&quot;> </xref>。"
  overload: System.Windows.DependencyProperty.GetHashCode*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetMetadata(System.Type)
  id: GetMetadata(System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetMetadata(Type)
  nameWithType: DependencyProperty.GetMetadata(Type)
  fullName: System.Windows.DependencyProperty.GetMetadata(Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "返回此依赖项属性的元数据，因为它存在于指定的现有类型上。"
  remarks: "指定的类型或对象引用以用作类是必需的元数据可能会不同于原始注册原因可能是因为<xref:System.Windows.DependencyProperty.AddOwner%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>alter 依赖项属性的元数据，因为它存在于一种类型的调用。</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A>"
  example:
  - "The following example gets metadata for a dependency property based on its type. The type is obtained by using a `typeof` operator.  \n  \n [!code-cs[PropertySystemEsoterics#GetMetadataType](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/default.xaml.cs#getmetadatatype)]\n [!code-vb[PropertySystemEsoterics#GetMetadataType](~/add/codesnippet/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]"
  syntax:
    content: public System.Windows.PropertyMetadata GetMetadata (Type forType);
    parameters:
    - id: forType
      type: System.Type
      description: "要从中检索依赖属性元数据的特定类型。"
    return:
      type: System.Windows.PropertyMetadata
      description: "属性元数据对象。"
  overload: System.Windows.DependencyProperty.GetMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)
  id: GetMetadata(System.Windows.DependencyObject)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetMetadata(DependencyObject)
  nameWithType: DependencyProperty.GetMetadata(DependencyObject)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObject)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "返回此依赖项属性的元数据，因为它存在于指定的对象实例上。"
  remarks: "指定的类型或对象引用必需的任何给定的依赖项属性的元数据可能会不同于原始注册原因可能是因为<xref:System.Windows.DependencyProperty.AddOwner%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>可以优化的属性元数据，因为它存在于一种类型的调用。</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A>       在请求基于实例的属性元数据时，都实际上只通过实例，以便其类型可在内部计算。 依赖属性元数据不发生改变每个实例;它始终是一致的任何给定的类型属性组合。"
  example:
  - "The following example gets metadata for a dependency property based on a specific <xref:System.Windows.DependencyObject> instance.  \n  \n [!code-cs[PropertySystemEsoterics#GetMetadataDOInstance](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]\n [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/add/codesnippet/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]"
  syntax:
    content: public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);
    parameters:
    - id: dependencyObject
      type: System.Windows.DependencyObject
      description: "检查的类型，以便确定哪些特定类型的版本依赖项属性的元数据应来自依赖对象。"
    return:
      type: System.Windows.PropertyMetadata
      description: "属性元数据对象。"
  overload: System.Windows.DependencyProperty.GetMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)
  id: GetMetadata(System.Windows.DependencyObjectType)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetMetadata(DependencyObjectType)
  nameWithType: DependencyProperty.GetMetadata(DependencyObjectType)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObjectType)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "返回此依赖项属性的元数据，因为它存在于指定的类型。"
  remarks: "指定的类型或对象引用必需的任何给定的依赖项属性的元数据可能会不同于原始注册原因可能是因为<xref:System.Windows.DependencyProperty.AddOwner%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>可以优化的属性元数据，因为它存在于一种类型的调用。</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A>"
  example:
  - "The following example gets metadata for a dependency property based on its <xref:System.Windows.DependencyObjectType>.  \n  \n [!code-cs[PropertySystemEsoterics#GetMetadataDOType](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/default.xaml.cs#getmetadatadotype)]\n [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/add/codesnippet/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]"
  syntax:
    content: public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);
    parameters:
    - id: dependencyObjectType
      type: System.Windows.DependencyObjectType
      description: "记录从其依赖属性元数据所需的依赖项对象类型的特定对象。"
    return:
      type: System.Windows.PropertyMetadata
      description: "属性元数据对象。"
  overload: System.Windows.DependencyProperty.GetMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GlobalIndex
  id: GlobalIndex
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GlobalIndex
  nameWithType: DependencyProperty.GlobalIndex
  fullName: System.Windows.DependencyProperty.GlobalIndex
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "获取唯一标识该依赖项属性的内部生成的值。"
  remarks: "此值不是一个整数， [!INCLUDE[TLA#tla_guid](~/add/includes/ajax-current-ext-md.md)]。 通常情况下，使用此索引值不是必需的并且没有任何索引访问的所有依赖项属性的表。 而是应由其标识符字段引用依赖项属性。       GlobalIndex 内部用于更快地访问 GlobalIndex 用作从零开始的数组索引的数据结构。 类似的用法可能具有的应用程序设计器或工具。"
  syntax:
    content: public int GlobalIndex { get; }
    return:
      type: System.Int32
      description: "唯一的数字标识符。"
  overload: System.Windows.DependencyProperty.GlobalIndex*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.IsValidType(System.Object)
  id: IsValidType(System.Object)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: IsValidType(Object)
  nameWithType: DependencyProperty.IsValidType(Object)
  fullName: System.Windows.DependencyProperty.IsValidType(Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "确定指定的值是否可接受的此依赖项属性的类型，如提供在原始注册的依赖项属性的属性类型进行比照。"
  remarks: "值为`null`是有效类型的引用类型依赖项属性，或为<xref:System.Nullable%601>依赖项属性，并将返回`true`在这些情况下。</xref:System.Nullable%601> 在其中依赖项属性是既不是引用的情况下也不是<xref:System.Nullable%601>类型，将返回 IsValidType`false`为 null 值，而不是引发异常。</xref:System.Nullable%601>"
  example:
  - "The following example uses IsValidType as a check before calling <xref:System.Windows.DependencyObject.SetValue%2A> on the dependency property.  \n  \n [!code-cs[PropertySystemEsoterics#TrySetValue](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#trysetvalue)]\n [!code-vb[PropertySystemEsoterics#TrySetValue](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]"
  syntax:
    content: public bool IsValidType (object value);
    parameters:
    - id: value
      type: System.Object
      description: "要检查的值。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果指定的值是已注册的属性类型或可接受的派生的类型;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.DependencyProperty.IsValidType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.IsValidValue(System.Object)
  id: IsValidValue(System.Object)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: IsValidValue(Object)
  nameWithType: DependencyProperty.IsValidValue(Object)
  fullName: System.Windows.DependencyProperty.IsValidValue(Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "确定是否为类型的属性通过基本类型检查，接受提供的值，可能还要是否允许该类型的值的范围内。"
  remarks: "依赖项属性，可通过指定允许的范围内的该类型的值<xref:System.Windows.ValidateValueCallback>提供在注册依赖属性。</xref:System.Windows.ValidateValueCallback>       此方法调用<xref:System.Windows.DependencyProperty.IsValidType%2A>内部。</xref:System.Windows.DependencyProperty.IsValidType%2A> 涉及的依赖属性是否没有提供<xref:System.Windows.ValidateValueCallback>，则调用此方法是有效地等效于调用<xref:System.Windows.DependencyProperty.IsValidType%2A>.</xref:System.Windows.DependencyProperty.IsValidType%2A> </xref:System.Windows.ValidateValueCallback> 如果具有依赖项属性<xref:System.Windows.ValidateValueCallback>，并且如果<xref:System.Windows.DependencyProperty.IsValidType%2A>将返回`true`，则在回调中实现时将返回的值。</xref:System.Windows.DependencyProperty.IsValidType%2A> </xref:System.Windows.ValidateValueCallback>       空值是有效的值对于引用类型依赖项对象，或者对于<xref:System.Nullable%601>依赖项属性，并将返回`true`在这些情况下。</xref:System.Nullable%601> 在其中依赖项属性是既不是引用的情况下也不是<xref:System.Nullable%601>类型，<xref:System.Windows.DependencyProperty.IsValidType%2A>将返回`false`为 null 值，而不是引发异常。</xref:System.Windows.DependencyProperty.IsValidType%2A> </xref:System.Nullable%601>"
  example:
  - "The following example uses IsValidValue as a check before calling <xref:System.Windows.DependencyObject.SetValue%2A> on the dependency property.  \n  \n [!code-cs[PropertySystemEsoterics#TrySetValueWithValidate](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]\n [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]"
  syntax:
    content: public bool IsValidValue (object value);
    parameters:
    - id: value
      type: System.Object
      description: "要检查的值。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果值是可以接受的并且是正确的类型或派生的类型;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.DependencyProperty.IsValidValue*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Name
  id: Name
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Name
  nameWithType: DependencyProperty.Name
  fullName: System.Windows.DependencyProperty.Name
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "获取依赖项属性的名称。"
  remarks: "此属性获取形式提供的名称`name`期间注册依赖属性的参数。 此名称是不可变的并且不能为`null`或空字符串。 重复名称注册相同的所有者类型上不允许使用，并尝试注册重复的情况下将引发异常。      1> [!IMPORTANT]&1;> 依赖项属性的名称必须遵循的后缀&quot;Property&quot;减去其依赖项属性标识符的名称匹配的约定。 有关详细信息，请参阅[自定义依赖项属性](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example queries various characteristics of a dependency property identifier, including the Name.  \n  \n [!code-cs[PropertySystemEsoterics#DPProps](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpprops)]\n [!code-vb[PropertySystemEsoterics#DPProps](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpprops)]"
  syntax:
    content: public string Name { get; }
    return:
      type: System.String
      description: "属性的名称。"
  overload: System.Windows.DependencyProperty.Name*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  id: OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: OverrideMetadata(Type,PropertyMetadata)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "指定的类型，重写如继承自基类型时存在的依赖项属性的元数据的实例上存在时，请指定此依赖项属性的替换元数据。"
  remarks: "依赖属性元数据应被替代，然后再属性系统将使用依赖项属性。 这相当于使用注册的依赖项属性的类来创建特定实例的时间。 只应提供本身为的类型的静态构造函数内执行调用 OverrideMetadata`forType`参数，此方法，或通过类似实例化。 尝试更改元数据之后有所有者类型的实例, 不会引发异常，但将导致属性系统中的不一致的行为。       使用此方法建立了特定派生的类重写元数据后，重写此相同的派生类上的元数据的后续尝试将引发异常。       提供的元数据与依赖项属性的属性元数据合并，因为它存在于基的所有者。 在原始的基本元数据中未指定任何特征将保持不变;仅已专门在新的元数据中更改这些特征将重写的基本元数据的特征。 如某些特征<xref:System.Windows.PropertyMetadata.DefaultValue%2A>如果新的元数据中指定的替换。</xref:System.Windows.PropertyMetadata.DefaultValue%2A> 其他，如<xref:System.Windows.PropertyChangedCallback>，又。</xref:System.Windows.PropertyChangedCallback> 最终，合并行为取决于正在用于重写时，因此此处所述的行为是使用现有的属性元数据类的属性元数据类型[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]依赖项属性。 有关详细信息，请参阅[依赖属性元数据](~/add/includes/ajax-current-ext-md.md)和[Framework 属性元数据](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: forType
      type: System.Type
      description: "上继承该依赖项属性的类型并将应用所提供的替换元数据。"
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "要应用于重写类型上的依赖项属性的元数据。"
  overload: System.Windows.DependencyProperty.OverrideMetadata*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "尝试重写只读依赖属性的元数据 (无法完成该操作使用此签名)。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "因为它存在于所提供的类型，已建立的依赖项属性的元数据。"
  platform:
  - net462
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  id: OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "当存在指定的类型，重写在最初注册依赖属性时提供的元数据的实例上，提供替换只读依赖属性的元数据。 必须传递<xref href=&quot;System.Windows.DependencyPropertyKey&quot;></xref>只读依赖属性，以避免引发异常。"
  remarks: "此签名提供了一个只读依赖属性标识符的基础实现 (<xref:System.Windows.DependencyPropertyKey>) 方法。</xref:System.Windows.DependencyPropertyKey> 如果重写读写依赖项属性的元数据，使用<xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>。</xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>       依赖属性元数据应被替代，然后再属性系统将使用依赖项属性。 这相当于注册依赖属性的类创建特定对象的时间。 调用<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>仅应在提供本身为的类型的静态构造函数中执行`forType`参数，此方法，或通过类似实例化。</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 尝试更改元数据之后有所有者类型的实例, 不会引发异常，但将导致属性系统中的不一致的行为。       使用此方法建立了特定派生的类重写元数据后，重写此相同的派生类上的元数据的后续尝试将引发异常。       提供的元数据与依赖项属性的属性元数据合并，因为它存在于基的所有者。 在原始的基本元数据中未指定任何特征将保持不变;仅已专门在新的元数据中更改这些特征将重写的基本元数据的特征。 如某些特征<xref:System.Windows.PropertyMetadata.DefaultValue%2A>如果新的元数据中指定的替换。</xref:System.Windows.PropertyMetadata.DefaultValue%2A> 其他，如<xref:System.Windows.PropertyChangedCallback>，又。</xref:System.Windows.PropertyChangedCallback> 合并行为取决于正在使用用于重写的属性元数据类型。 有关详细信息，请参阅[依赖属性元数据](~/add/includes/ajax-current-ext-md.md)和[Framework 属性元数据](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);
    parameters:
    - id: forType
      type: System.Type
      description: "上继承该依赖项属性的类型并将应用所提供的替换元数据。"
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "要应用于重写类型上的依赖项属性的元数据。"
    - id: key
      type: System.Windows.DependencyPropertyKey
      description: "只读依赖属性的访问密钥。"
  overload: System.Windows.DependencyProperty.OverrideMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.OwnerType
  id: OwnerType
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: OwnerType
  nameWithType: DependencyProperty.OwnerType
  fullName: System.Windows.DependencyProperty.OwnerType
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "获取使用属性系统注册依赖属性或者将自己作为属性所有者添加的对象的类型。"
  remarks: "属性注册期间提供此值。 所有者将任一原始注册类型的情况下<xref:System.Windows.DependencyProperty>从生成标识符<xref:System.Windows.DependencyProperty.Register%2A>调用，或者将自己作为所有者的情况下添加的类型<xref:System.Windows.DependencyProperty>从生成标识符<xref:System.Windows.DependencyProperty.AddOwner%2A>调用。</xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty.Register%2A> </xref:System.Windows.DependencyProperty>       针对任何给定所有者类型<xref:System.Windows.DependencyProperty>是不可变，并且不能为`null`中有效的<xref:System.Windows.DependencyProperty>。</xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty>"
  example:
  - "The following example gets the owner type based on a dependency property identifier `dp`, and then gets metadata on the owner type for that same identifier. This operation is actually equivalent to getting <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> on `dp`.  \n  \n [!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]"
  syntax:
    content: public Type OwnerType { get; }
    return:
      type: System.Type
      description: "注册属性或者将自己作为属性所有者添加的对象类型。"
  overload: System.Windows.DependencyProperty.OwnerType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.PropertyType
  id: PropertyType
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: PropertyType
  nameWithType: DependencyProperty.PropertyType
  fullName: System.Windows.DependencyProperty.PropertyType
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "获取用于其值的依赖项属性的类型。"
  remarks: "此属性报告类型的属性的值所声明的原始的注册属性中，通过`propertyType`参数。 类似于<xref:System.Windows.DependencyProperty.Name%2A>，依赖项属性的属性类型注册后不可变。</xref:System.Windows.DependencyProperty.Name%2A>"
  example:
  - "The following example queries various characteristics of a dependency property identifier, including the PropertyType. The type name string of the PropertyType is obtained from the returned <xref:System.Type>.  \n  \n [!code-cs[PropertySystemEsoterics#DPProps](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpprops)]\n [!code-vb[PropertySystemEsoterics#DPProps](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpprops)]"
  syntax:
    content: public Type PropertyType { get; }
    return:
      type: System.Type
      description: "<xref:System.Type>的属性值。</xref:System.Type>"
  overload: System.Windows.DependencyProperty.PropertyType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.ReadOnly
  id: ReadOnly
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: ReadOnly
  nameWithType: DependencyProperty.ReadOnly
  fullName: System.Windows.DependencyProperty.ReadOnly
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "获取一个值，该值指示依赖属性是否标识此<xref href=&quot;System.Windows.DependencyProperty&quot;></xref>实例是一个只读依赖属性。"
  remarks: "在属性系统注册只读依赖属性，应调用<xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>方法而非<xref:System.Windows.DependencyProperty.Register%2A>方法。</xref:System.Windows.DependencyProperty.Register%2A> </xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> 此外可以将附加的属性注册为只读的;请参阅<xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>。</xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>       只读依赖属性可能需要<xref:System.Windows.DependencyPropertyKey>标识符而不是<xref:System.Windows.DependencyProperty>标识符来执行元数据操作，例如重写元数据或将值设置。</xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyPropertyKey> 如果你获得的集合<xref:System.Windows.DependencyProperty>通过调用标识符<xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A>或另一个[!INCLUDE[TLA2#tla_api](~/add/includes/tla2sharptla-api-md.md)]公开标识符，请在尝试调用之前检查的 ReadOnly 值<xref:System.Windows.DependencyObject.SetValue%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>使用该依赖属性标识符作为输入参数，以验证标识符表示的依赖项属性不是只读的。</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyObject.SetValue%2A> </xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> </xref:System.Windows.DependencyProperty> 如果值为 ReadOnly`true`某个依赖项属性，没有获得对的引用无法通过编程方式<xref:System.Windows.DependencyPropertyKey>从元数据或从该依赖属性标识符<xref:System.Windows.DependencyProperty>标识符; 标识符必须可用作静态字段才能调用<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>针对只读依赖属性。</xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> </xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyPropertyKey>       当你创建自定义的依赖项属性，并将其注册为只读的时应定义仅一个 get 访问器为[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]包装属性。 否则，你的类将具有相比对后备依赖项属性的访问权限属性包装令人困惑的对象模型。 有关详细信息，请参阅[自定义依赖项属性](~/add/includes/ajax-current-ext-md.md)或[只读依赖项属性](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example obtains the default metadata and the dependency property identifier properties from various dependency property fields, and uses the information to populate a table to implement a \"metadata browser\".  \n  \n [!code-cs[PropertySystemEsoterics#DPProps](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpprops)]\n [!code-vb[PropertySystemEsoterics#DPProps](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpprops)]"
  syntax:
    content: public bool ReadOnly { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果依赖项属性是只读的;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.DependencyProperty.ReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)
  id: Register(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Register(String,Type,Type)
  nameWithType: DependencyProperty.Register(String,Type,Type)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "使用指定的属性名称、 属性类型和所有者类型注册依赖属性。"
  remarks: "注册依赖属性的详细信息，请参阅<xref:System.Windows.DependencyProperty>。</xref:System.Windows.DependencyProperty>"
  example:
  - >-
    [!code-cs[WPFAquariumSln#Register3Param](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#register3param)]
     [!code-vb[WPFAquariumSln#Register3Param](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#register3param)]
  syntax:
    content: public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);
    parameters:
    - id: name
      type: System.String
      description: "要注册的依赖项属性的名称。 名称必须是唯一的所有者类型的注册命名空间中。"
    - id: propertyType
      type: System.Type
      description: "属性的类型。"
    - id: ownerType
      type: System.Type
      description: "正在注册依赖属性所有者类型。"
    return:
      type: System.Windows.DependencyProperty
      description: "应该用于设置的值的依赖项属性标识符<xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;></xref>字段在您的类。 该标识符然后用于以编程方式设置其值或获取元数据等操作的更高版本，引用该依赖属性。"
  overload: System.Windows.DependencyProperty.Register*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Register(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "使用指定的属性名称、 属性类型、 所有者类型和属性元数据注册依赖属性。"
  remarks: "注册依赖属性的详细信息，请参阅<xref:System.Windows.DependencyProperty>。</xref:System.Windows.DependencyProperty>"
  syntax:
    content: public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: name
      type: System.String
      description: "要注册的依赖项属性的名称。"
    - id: propertyType
      type: System.Type
      description: "属性的类型。"
    - id: ownerType
      type: System.Type
      description: "正在注册依赖属性所有者类型。"
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "依赖项属性的属性元数据。"
    return:
      type: System.Windows.DependencyProperty
      description: "应该用于设置的值的依赖项属性标识符<xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;></xref>字段在您的类。 该标识符然后用于以编程方式设置其值或获取元数据等操作的更高版本，引用该依赖属性。"
  overload: System.Windows.DependencyProperty.Register*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "使用指定的属性名称、 属性类型、 所有者类型、 属性元数据和属性的值验证回叫注册的依赖项属性。"
  remarks: "注册依赖属性的详细信息，请参阅<xref:System.Windows.DependencyProperty>。</xref:System.Windows.DependencyProperty>"
  example:
  - "The following example registers a dependency property, including a validation callback (the callback definition is not shown; for details on the callback definition, see <xref:System.Windows.ValidateValueCallback>).  \n  \n [!code-cs[DPCallbackOverride#CurrentDefinitionWithWrapper](~/add/codesnippet/csharp/DPCallbackOverride/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]\n [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/add/codesnippet/visualbasic/DPCallbackOverride.sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]"
  syntax:
    content: public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "要注册的依赖项属性的名称。"
    - id: propertyType
      type: System.Type
      description: "属性的类型。"
    - id: ownerType
      type: System.Type
      description: "正在注册依赖属性所有者类型。"
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "依赖项属性的属性元数据。"
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "对应执行依赖属性值，除了典型的类型验证之外的任何自定义验证回调的引用。"
    return:
      type: System.Windows.DependencyProperty
      description: "应该用于设置的值的依赖项属性标识符<xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;></xref>字段在您的类。 该标识符然后用于以编程方式设置其值或获取元数据等操作的更高版本，引用该依赖属性。"
  overload: System.Windows.DependencyProperty.Register*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)
  id: RegisterAttached(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttached(String,Type,Type)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "使用指定的属性名称、 属性类型和所有者类型注册附加的属性。"
  remarks: "附加的属性是由定义的属性概念[!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]。 [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]实现附加作为依赖项属性的属性。 因为[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]附加的属性都是依赖项属性，它们可以应用可以用于操作，如 reporting 布局特征的常规属性系统的元数据。 有关详细信息，请参阅[附加属性概述](~/add/includes/ajax-current-ext-md.md)。       注册依赖属性的详细信息，请参阅<xref:System.Windows.DependencyProperty>。</xref:System.Windows.DependencyProperty>"
  example:
  - "The following example registers an attached property on an abstract class using this RegisterAttached signature.  \n  \n [!code-cs[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]\n [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]"
  syntax:
    content: public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);
    parameters:
    - id: name
      type: System.String
      description: "要注册的依赖项属性的名称。"
    - id: propertyType
      type: System.Type
      description: "属性的类型。"
    - id: ownerType
      type: System.Type
      description: "正在注册依赖属性所有者类型。"
    return:
      type: System.Windows.DependencyProperty
      description: "应该用于设置的值的依赖项属性标识符<xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;></xref>字段在您的类。 该标识符然后用于以编程方式设置其值或获取元数据等操作的更高版本，引用该依赖属性。"
  overload: System.Windows.DependencyProperty.RegisterAttached*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttached(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "使用指定的属性名称、 属性类型、 所有者类型和属性元数据注册附加的属性。"
  remarks: "An attached property is a property concept defined by [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] implements attached properties as dependency properties. Because the [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics. For more information, see [Attached Properties Overview](~/add/includes/ajax-current-ext-md.md).  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property with RegisterAttached instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance. You should register value-inheriting dependency properties with RegisterAttached even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use RegisterAttached to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);
    parameters:
    - id: name
      type: System.String
      description: "要注册的依赖项属性的名称。"
    - id: propertyType
      type: System.Type
      description: "属性的类型。"
    - id: ownerType
      type: System.Type
      description: "正在注册依赖属性所有者类型。"
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "依赖项属性的属性元数据。 这可以包括默认值，以及其他特征。"
    return:
      type: System.Windows.DependencyProperty
      description: "应该用于设置的值的依赖项属性标识符<xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;></xref>字段在您的类。 该标识符然后用于以编程方式设置其值或获取元数据等操作的更高版本，引用该依赖属性。"
  overload: System.Windows.DependencyProperty.RegisterAttached*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "使用指定的属性类型、 所有者类型、 属性元数据和属性的值验证回叫注册附加的属性。"
  remarks: "An attached property is a property concept defined by [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] implements attached properties as dependency properties. Because the [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics. For more information, see [Attached Properties Overview](~/add/includes/ajax-current-ext-md.md).  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance. You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example registers an attached property on an abstract class using this RegisterAttached signature. This attached property is an enumeration type property, and the registration adds a validation callback to verify that the provided value is a value of the enumeration.  \n  \n [!code-cs[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]\n [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]"
  syntax:
    content: public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "要注册的依赖项属性的名称。"
    - id: propertyType
      type: System.Type
      description: "属性的类型。"
    - id: ownerType
      type: System.Type
      description: "正在注册依赖属性所有者类型。"
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "依赖项属性的属性元数据。 这可以包括默认值，以及其他特征。"
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "对应执行依赖属性值，除了典型的类型验证之外的任何自定义验证回调的引用。"
    return:
      type: System.Windows.DependencyProperty
      description: "应该用于设置的值的依赖项属性标识符<xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;></xref>字段在您的类。 该标识符然后用于以编程方式设置其值或获取元数据等操作的更高版本，引用该依赖属性。"
  overload: System.Windows.DependencyProperty.RegisterAttached*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "使用指定的属性类型、 所有者类型和属性元数据注册只读附加的属性。"
  remarks: "This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>. Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic. It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName> as a `public static readonly` field on your class.  \n  \n Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]. Without a public setter, an attached property cannot be set in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] syntax.  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property as attached is to support property value inheritance. You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);
    parameters:
    - id: name
      type: System.String
      description: "要注册的依赖项属性的名称。"
    - id: propertyType
      type: System.Type
      description: "属性的类型。"
    - id: ownerType
      type: System.Type
      description: "正在注册依赖属性所有者类型。"
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "依赖项属性的属性元数据。"
    return:
      type: System.Windows.DependencyPropertyKey
      description: "一个用于在您的类，然后使用以供以后参考依赖项属性中设置静态只读字段的值的依赖属性键。"
  overload: System.Windows.DependencyProperty.RegisterAttachedReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "使用指定的属性类型、 所有者类型、 属性元数据和验证回叫注册只读附加的属性。"
  remarks: "This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>. Typically, the keys that represent the type <xref:System.Windows.DependencyProperty>. Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic. It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName> as a `public static readonly` field on your class.  \n  \n Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]. Without a public setter, an attached property cannot be set in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] syntax.  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property as attached instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance. You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "要注册的依赖项属性的名称。"
    - id: propertyType
      type: System.Type
      description: "属性的类型。"
    - id: ownerType
      type: System.Type
      description: "正在注册依赖属性所有者类型。"
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "依赖项属性的属性元数据。"
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "对用户创建应执行依赖属性值，除了典型的类型验证之外的任何自定义验证的回调的引用。"
    return:
      type: System.Windows.DependencyPropertyKey
      description: "一个用于在你的类，该类用来引用依赖项属性中设置静态只读字段的值的依赖属性键。"
  overload: System.Windows.DependencyProperty.RegisterAttachedReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "使用指定的属性类型、 所有者类型和属性元数据注册只读依赖属性。"
  remarks: "此方法返回的类型<xref:System.Windows.DependencyPropertyKey>，而<xref:System.Windows.DependencyProperty.RegisterAttached%2A>返回的类型<xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty.RegisterAttached%2A> </xref:System.Windows.DependencyPropertyKey> 通常，表示只读属性的键不是公共的因为密钥可用于设置依赖项属性值，通过调用<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> 类设计会影响你的要求，但通常建议来限制访问和可见性的任何<xref:System.Windows.DependencyPropertyKey>到仅这些部分的代码所需将该依赖项属性设置为类或应用程序逻辑的一部分。</xref:System.Windows.DependencyPropertyKey> 此外，还建议通过公开的值公开只读依赖属性，一个依赖属性标识符<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>作为`public static readonly`你类字段</xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>       只读依赖属性是相当典型的方案中这两个现有[!INCLUDE[TLA2#tla_api](~/add/includes/tla2sharptla-api-md.md)]和自定义方案，因为其他[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]功能可能需要依赖项属性，即使该属性不是可由调用方。 你可以执行需要依赖项属性，例如使其他属性系统操作只读依赖属性的值将用作基础<xref:System.Windows.Trigger>样式中的依赖属性。</xref:System.Windows.Trigger>       注册依赖属性的详细信息，请参阅<xref:System.Windows.DependencyProperty>。</xref:System.Windows.DependencyProperty>"
  example:
  - "The following example registers an `AquariumSize` dependency property as read-only. The example defines `AquariumSizeKey` as an internal key (so that other classes in the assembly could override metadata) and exposes the dependency property identifier based on that key as `AquariumSizeProperty`. Also, a wrapper is created for `AquariumSize`, with only a get accessor.  \n  \n [!code-cs[WPFAquariumSln#RODP](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#rodp)]\n [!code-vb[WPFAquariumSln#RODP](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#rodp)]"
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: name
      type: System.String
      description: "要注册的依赖项属性的名称。"
    - id: propertyType
      type: System.Type
      description: "属性的类型。"
    - id: ownerType
      type: System.Type
      description: "正在注册依赖属性所有者类型。"
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "依赖项属性的属性元数据。"
    return:
      type: System.Windows.DependencyPropertyKey
      description: "一个用于在你的类，该类用来引用依赖项属性中设置静态只读字段的值的依赖属性键。"
  overload: System.Windows.DependencyProperty.RegisterReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "使用指定的属性类型、 所有者类型、 属性元数据和验证回叫注册只读依赖属性。"
  remarks: "此方法返回的类型<xref:System.Windows.DependencyPropertyKey>，而<xref:System.Windows.DependencyProperty.RegisterAttached%2A>返回的类型<xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty.RegisterAttached%2A> </xref:System.Windows.DependencyPropertyKey> 通常，表示只读属性的键不是公共的因为密钥可用于设置依赖项属性值，通过调用<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> 类设计会影响你的要求，但通常建议来限制访问和可见性的任何<xref:System.Windows.DependencyPropertyKey>到仅这些部分的代码所需将该依赖项属性设置为类或应用程序逻辑的一部分。</xref:System.Windows.DependencyPropertyKey> 此外，还建议通过公开的值公开只读依赖属性，一个依赖属性标识符<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>作为`public static readonly`你类字段</xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>       只读依赖属性是相当典型的方案。 你可以执行需要依赖项属性，例如使其他属性系统操作只读依赖属性的值将用作基础<xref:System.Windows.Trigger>样式中的依赖属性。</xref:System.Windows.Trigger>       注册依赖属性的详细信息，请参阅<xref:System.Windows.DependencyProperty>。</xref:System.Windows.DependencyProperty>       对只读依赖属性的验证可能不太重要。 你为密钥指定的非公共访问级别降低了对任意无效输入的可能性。"
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "要注册的依赖项属性的名称。"
    - id: propertyType
      type: System.Type
      description: "属性的类型。"
    - id: ownerType
      type: System.Type
      description: "正在注册依赖属性所有者类型。"
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "依赖项属性的属性元数据。"
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "对用户创建应执行依赖属性值，除了典型的类型验证之外的任何自定义验证的回调的引用。"
    return:
      type: System.Windows.DependencyPropertyKey
      description: "一个用于在您的类，然后使用以供以后参考依赖项属性中设置静态只读字段的值的依赖属性键。"
  overload: System.Windows.DependencyProperty.RegisterReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.ToString
  id: ToString
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: ToString()
  nameWithType: DependencyProperty.ToString()
  fullName: System.Windows.DependencyProperty.ToString()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "返回的字符串表示形式的依赖属性。"
  remarks: "此实现返回<xref:System.Windows.DependencyProperty.Name%2A>属性值。</xref:System.Windows.DependencyProperty.Name%2A>"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "依赖项属性的字符串表示形式。"
  overload: System.Windows.DependencyProperty.ToString*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.UnsetValue
  id: UnsetValue
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: UnsetValue
  nameWithType: DependencyProperty.UnsetValue
  fullName: System.Windows.DependencyProperty.UnsetValue
  type: Field
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "指定一个静态值，由[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]属性系统而不是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>以指示该属性存在，但不具有其值由属性系统设置。"
  remarks: "UnsetValue 是用于方案的 sentinel 值其中[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]属性系统不能确定请求<xref:System.Windows.DependencyProperty>值。</xref:System.Windows.DependencyProperty> 使用 UnsetValue 而非`null`，这是因为`null`可能是一个有效的属性值，以及有效 （和常用） <xref:System.Windows.PropertyMetadata.DefaultValue%2A>.</xref:System.Windows.PropertyMetadata.DefaultValue%2A>       UnsetValue 永远不会返回超出<xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName>.</xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName> 当调用<xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName>上的依赖项属性<xref:System.Windows.DependencyObject>适用的情况下，以下项之一:-依赖项属性在元数据中建立的默认值而则返回该值。</xref:System.Windows.DependencyObject> </xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName> 此值可能来自于<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.</xref:System.Windows.DependencyProperty.DefaultMetadata%2A>      -一些其他值由属性系统，并且默认值不再适用。 有关详细信息，请参阅[依赖项属性值优先级](~/add/includes/ajax-current-ext-md.md)。       设置<xref:System.Windows.PropertyMetadata.DefaultValue%2A>UnsetValue 的明确不允许。</xref:System.Windows.PropertyMetadata.DefaultValue%2A>       <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=fullName>请求的属性未本地设置时，请返回 UnsetValue。</xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=fullName>       UnsetValue 具有特殊含义时用作一种<xref:System.Windows.CoerceValueCallback>。</xref:System.Windows.CoerceValueCallback>的返回值 有关详细信息，请参阅[依赖项属性的回调和验证](~/add/includes/ajax-current-ext-md.md)。       如果你正在绑定到数据库，请注意，UnsetValue 不等效于<xref:System.DBNull.Value>，如何以类似方式<xref:System.DBNull.Value>不等于 true null。</xref:System.DBNull.Value> </xref:System.DBNull.Value>"
  syntax:
    content: public static readonly object UnsetValue;
    return:
      type: System.Object
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.ValidateValueCallback
  id: ValidateValueCallback
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: ValidateValueCallback
  nameWithType: DependencyProperty.ValidateValueCallback
  fullName: System.Windows.DependencyProperty.ValidateValueCallback
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "获取依赖项属性的值验证回调。"
  remarks: "此属性将包含`null`对于没有注册的验证回调的任何依赖项属性。       验证回调必须在静态的意义上执行操作的值︰ 验证通过应用<xref:System.Windows.ValidateValueCallback>无法确定提供的值是否有效的任何特定的实例。</xref:System.Windows.ValidateValueCallback> 回调仅可以确定是否具有依赖项属性的所有对象应，或不应接受为有效提供的值。 如果你需要执行依赖于知道上一个特定实例，使用其他依赖项属性的值的验证<xref:System.Windows.CoerceValueCallback>相反。</xref:System.Windows.CoerceValueCallback> <xref:System.Windows.CoerceValueCallback>作为一部分的依赖属性元数据，而不是直接在依赖属性标识符内注册。</xref:System.Windows.CoerceValueCallback> 有关详细信息，请参阅[依赖项属性的回调和验证](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public System.Windows.ValidateValueCallback ValidateValueCallback { get; }
    return:
      type: System.Windows.ValidateValueCallback
      description: "此依赖项属性，为提供的值验证回调<code> validateValueCallback </code>在原始注册的依赖项属性的参数。"
  overload: System.Windows.DependencyProperty.ValidateValueCallback*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Windows.DependencyProperty.AddOwner(System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: AddOwner(Type)
  nameWithType: DependencyProperty.AddOwner(Type)
  fullName: System.Windows.DependencyProperty.AddOwner(Type)
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: AddOwner(Type,PropertyMetadata)
  nameWithType: DependencyProperty.AddOwner(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.AddOwner(Type,PropertyMetadata)
- uid: System.Windows.PropertyMetadata
  parent: System.Windows
  isExternal: false
  name: PropertyMetadata
  nameWithType: PropertyMetadata
  fullName: System.Windows.PropertyMetadata
- uid: System.Windows.DependencyProperty.DefaultMetadata
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: DefaultMetadata
  nameWithType: DependencyProperty.DefaultMetadata
  fullName: System.Windows.DependencyProperty.DefaultMetadata
- uid: System.Windows.DependencyProperty.GetHashCode
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetHashCode()
  nameWithType: DependencyProperty.GetHashCode()
  fullName: System.Windows.DependencyProperty.GetHashCode()
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.DependencyProperty.GetMetadata(System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata(Type)
  nameWithType: DependencyProperty.GetMetadata(Type)
  fullName: System.Windows.DependencyProperty.GetMetadata(Type)
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata(DependencyObject)
  nameWithType: DependencyProperty.GetMetadata(DependencyObject)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObject)
- uid: System.Windows.DependencyObject
  parent: System.Windows
  isExternal: false
  name: DependencyObject
  nameWithType: DependencyObject
  fullName: System.Windows.DependencyObject
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata(DependencyObjectType)
  nameWithType: DependencyProperty.GetMetadata(DependencyObjectType)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObjectType)
- uid: System.Windows.DependencyObjectType
  parent: System.Windows
  isExternal: false
  name: DependencyObjectType
  nameWithType: DependencyObjectType
  fullName: System.Windows.DependencyObjectType
- uid: System.Windows.DependencyProperty.GlobalIndex
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GlobalIndex
  nameWithType: DependencyProperty.GlobalIndex
  fullName: System.Windows.DependencyProperty.GlobalIndex
- uid: System.Windows.DependencyProperty.IsValidType(System.Object)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidType(Object)
  nameWithType: DependencyProperty.IsValidType(Object)
  fullName: System.Windows.DependencyProperty.IsValidType(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.DependencyProperty.IsValidValue(System.Object)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidValue(Object)
  nameWithType: DependencyProperty.IsValidValue(Object)
  fullName: System.Windows.DependencyProperty.IsValidValue(Object)
- uid: System.Windows.DependencyProperty.Name
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Name
  nameWithType: DependencyProperty.Name
  fullName: System.Windows.DependencyProperty.Name
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OverrideMetadata(Type,PropertyMetadata)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
- uid: System.Windows.DependencyPropertyKey
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyKey
  nameWithType: DependencyPropertyKey
  fullName: System.Windows.DependencyPropertyKey
- uid: System.Windows.DependencyProperty.OwnerType
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OwnerType
  nameWithType: DependencyProperty.OwnerType
  fullName: System.Windows.DependencyProperty.OwnerType
- uid: System.Windows.DependencyProperty.PropertyType
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: PropertyType
  nameWithType: DependencyProperty.PropertyType
  fullName: System.Windows.DependencyProperty.PropertyType
- uid: System.Windows.DependencyProperty.ReadOnly
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ReadOnly
  nameWithType: DependencyProperty.ReadOnly
  fullName: System.Windows.DependencyProperty.ReadOnly
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register(String,Type,Type)
  nameWithType: DependencyProperty.Register(String,Type,Type)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type)
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.ValidateValueCallback
  parent: System.Windows
  isExternal: false
  name: ValidateValueCallback
  nameWithType: ValidateValueCallback
  fullName: System.Windows.ValidateValueCallback
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached(String,Type,Type)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type)
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.DependencyProperty.ToString
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ToString()
  nameWithType: DependencyProperty.ToString()
  fullName: System.Windows.DependencyProperty.ToString()
- uid: System.Windows.DependencyProperty.UnsetValue
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: UnsetValue
  nameWithType: DependencyProperty.UnsetValue
  fullName: System.Windows.DependencyProperty.UnsetValue
- uid: System.Windows.DependencyProperty.ValidateValueCallback
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ValidateValueCallback
  nameWithType: DependencyProperty.ValidateValueCallback
  fullName: System.Windows.DependencyProperty.ValidateValueCallback
- uid: System.Windows.DependencyProperty.AddOwner*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: AddOwner
  nameWithType: DependencyProperty.AddOwner
- uid: System.Windows.DependencyProperty.DefaultMetadata*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: DefaultMetadata
  nameWithType: DependencyProperty.DefaultMetadata
- uid: System.Windows.DependencyProperty.GetHashCode*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetHashCode
  nameWithType: DependencyProperty.GetHashCode
- uid: System.Windows.DependencyProperty.GetMetadata*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata
  nameWithType: DependencyProperty.GetMetadata
- uid: System.Windows.DependencyProperty.GlobalIndex*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GlobalIndex
  nameWithType: DependencyProperty.GlobalIndex
- uid: System.Windows.DependencyProperty.IsValidType*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidType
  nameWithType: DependencyProperty.IsValidType
- uid: System.Windows.DependencyProperty.IsValidValue*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidValue
  nameWithType: DependencyProperty.IsValidValue
- uid: System.Windows.DependencyProperty.Name*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Name
  nameWithType: DependencyProperty.Name
- uid: System.Windows.DependencyProperty.OverrideMetadata*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OverrideMetadata
  nameWithType: DependencyProperty.OverrideMetadata
- uid: System.Windows.DependencyProperty.OwnerType*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OwnerType
  nameWithType: DependencyProperty.OwnerType
- uid: System.Windows.DependencyProperty.PropertyType*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: PropertyType
  nameWithType: DependencyProperty.PropertyType
- uid: System.Windows.DependencyProperty.ReadOnly*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ReadOnly
  nameWithType: DependencyProperty.ReadOnly
- uid: System.Windows.DependencyProperty.Register*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register
  nameWithType: DependencyProperty.Register
- uid: System.Windows.DependencyProperty.RegisterAttached*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached
  nameWithType: DependencyProperty.RegisterAttached
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttachedReadOnly
  nameWithType: DependencyProperty.RegisterAttachedReadOnly
- uid: System.Windows.DependencyProperty.RegisterReadOnly*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterReadOnly
  nameWithType: DependencyProperty.RegisterReadOnly
- uid: System.Windows.DependencyProperty.ToString*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ToString
  nameWithType: DependencyProperty.ToString
- uid: System.Windows.DependencyProperty.ValidateValueCallback*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ValidateValueCallback
  nameWithType: DependencyProperty.ValidateValueCallback
