### YamlMime:ManagedReference
items:
- uid: System.Diagnostics.Process
  id: Process
  children:
  - System.Diagnostics.Process.#ctor
  - System.Diagnostics.Process.BasePriority
  - System.Diagnostics.Process.BeginErrorReadLine
  - System.Diagnostics.Process.BeginOutputReadLine
  - System.Diagnostics.Process.CancelErrorRead
  - System.Diagnostics.Process.CancelOutputRead
  - System.Diagnostics.Process.Close
  - System.Diagnostics.Process.CloseMainWindow
  - System.Diagnostics.Process.Dispose(System.Boolean)
  - System.Diagnostics.Process.EnableRaisingEvents
  - System.Diagnostics.Process.EnterDebugMode
  - System.Diagnostics.Process.ErrorDataReceived
  - System.Diagnostics.Process.ExitCode
  - System.Diagnostics.Process.Exited
  - System.Diagnostics.Process.ExitTime
  - System.Diagnostics.Process.GetCurrentProcess
  - System.Diagnostics.Process.GetProcessById(System.Int32)
  - System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  - System.Diagnostics.Process.GetProcesses
  - System.Diagnostics.Process.GetProcesses(System.String)
  - System.Diagnostics.Process.GetProcessesByName(System.String)
  - System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  - System.Diagnostics.Process.Handle
  - System.Diagnostics.Process.HandleCount
  - System.Diagnostics.Process.HasExited
  - System.Diagnostics.Process.Id
  - System.Diagnostics.Process.Kill
  - System.Diagnostics.Process.LeaveDebugMode
  - System.Diagnostics.Process.MachineName
  - System.Diagnostics.Process.MainModule
  - System.Diagnostics.Process.MainWindowHandle
  - System.Diagnostics.Process.MainWindowTitle
  - System.Diagnostics.Process.MaxWorkingSet
  - System.Diagnostics.Process.MinWorkingSet
  - System.Diagnostics.Process.Modules
  - System.Diagnostics.Process.NonpagedSystemMemorySize
  - System.Diagnostics.Process.NonpagedSystemMemorySize64
  - System.Diagnostics.Process.OnExited
  - System.Diagnostics.Process.OutputDataReceived
  - System.Diagnostics.Process.PagedMemorySize
  - System.Diagnostics.Process.PagedMemorySize64
  - System.Diagnostics.Process.PagedSystemMemorySize
  - System.Diagnostics.Process.PagedSystemMemorySize64
  - System.Diagnostics.Process.PeakPagedMemorySize
  - System.Diagnostics.Process.PeakPagedMemorySize64
  - System.Diagnostics.Process.PeakVirtualMemorySize
  - System.Diagnostics.Process.PeakVirtualMemorySize64
  - System.Diagnostics.Process.PeakWorkingSet
  - System.Diagnostics.Process.PeakWorkingSet64
  - System.Diagnostics.Process.PriorityBoostEnabled
  - System.Diagnostics.Process.PriorityClass
  - System.Diagnostics.Process.PrivateMemorySize
  - System.Diagnostics.Process.PrivateMemorySize64
  - System.Diagnostics.Process.PrivilegedProcessorTime
  - System.Diagnostics.Process.ProcessName
  - System.Diagnostics.Process.ProcessorAffinity
  - System.Diagnostics.Process.Refresh
  - System.Diagnostics.Process.Responding
  - System.Diagnostics.Process.SafeHandle
  - System.Diagnostics.Process.SessionId
  - System.Diagnostics.Process.StandardError
  - System.Diagnostics.Process.StandardInput
  - System.Diagnostics.Process.StandardOutput
  - System.Diagnostics.Process.Start
  - System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  - System.Diagnostics.Process.Start(System.String)
  - System.Diagnostics.Process.Start(System.String,System.String)
  - System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)
  - System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  - System.Diagnostics.Process.StartInfo
  - System.Diagnostics.Process.StartTime
  - System.Diagnostics.Process.SynchronizingObject
  - System.Diagnostics.Process.Threads
  - System.Diagnostics.Process.ToString
  - System.Diagnostics.Process.TotalProcessorTime
  - System.Diagnostics.Process.UserProcessorTime
  - System.Diagnostics.Process.VirtualMemorySize
  - System.Diagnostics.Process.VirtualMemorySize64
  - System.Diagnostics.Process.WaitForExit
  - System.Diagnostics.Process.WaitForExit(System.Int32)
  - System.Diagnostics.Process.WaitForInputIdle
  - System.Diagnostics.Process.WaitForInputIdle(System.Int32)
  - System.Diagnostics.Process.WorkingSet
  - System.Diagnostics.Process.WorkingSet64
  langs:
  - csharp
  name: Process
  nameWithType: Process
  fullName: System.Diagnostics.Process
  type: Class
  summary: "提供对本地和远程进程的访问，并使你能够启动和停止本地系统进程。       若要浏览此类型的.NET Framework 源代码，请参阅[引用源](http://referencesource.microsoft.com/#System/services/monitoring/system/diagnosticts/Process.cs#f8b2e604d6f1fe04)。"
  remarks: "> [!NOTE]\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#System/services/monitoring/system/diagnosticts/Process.cs#f8b2e604d6f1fe04). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \n  \n A Process component provides access to a process that is running on a computer. A process, in the simplest terms, is a running app. A thread is the basic unit to which the operating system allocates processor time. A thread can execute any part of the code of the process, including parts currently being executed by another thread.  \n  \n The Process component is a useful tool for starting, stopping, controlling, and monitoring apps. You can use the Process component, to obtain a list of the processes that are running, or you can start a new process. A Process component is used to access system processes. After a Process component has been initialized, it can be used to obtain information about the running process. Such information includes the set of threads, the loaded modules (.dll and .exe files), and performance information such as the amount of memory the process is using.  \n  \n This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  \n  \n> [!NOTE]\n>  32-bit processes cannot access the modules of a 64-bit process. If you try to get information about a 64-bit process from a 32-bit process, you will get a <xref:System.ComponentModel.Win32Exception> exception. A 64-bit process, on the other hand, can access the modules of a 32-bit process.  \n  \n The process component obtains information about a group of properties all at once. After the Process component has obtained information about one member of any group, it will cache the values for the other properties in that group and not obtain new information about the other members of the group until you call the <xref:System.Diagnostics.Process.Refresh%2A> method. Therefore, a property value is not guaranteed to be any newer than the last call to the <xref:System.Diagnostics.Process.Refresh%2A> method. The group breakdowns are operating-system dependent.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n A system process is uniquely identified on the system by its process identifier. Like many Windows resources, a process is also identified by its handle, which might not be unique on the computer. A handle is the generic term for an identifier of a resource. The operating system persists the process handle, which is accessed through the <xref:System.Diagnostics.Process.Handle%2A> property of the Process component, even when the process has exited. Thus, you can get the process's administrative information, such as the <xref:System.Diagnostics.Process.ExitCode%2A> (usually either zero for success or a nonzero error code) and the <xref:System.Diagnostics.Process.ExitTime%2A>. Handles are an extremely valuable resource, so leaking handles is more virulent than leaking memory.  \n  \n> [!NOTE]\n>  This class contains a link demand and an inheritance demand at the class level that applies to all members. A <xref:System.Security.SecurityException> is thrown when either the immediate caller or the derived class does not have full-trust permission. For details about security demands, see [Link Demands](~/add/includes/ajax-current-ext-md.md).  \n  \n<a name=\"Core\"></a>   \n## [!INCLUDE[net_core](~/add/includes/net-core-md.md)] Notes  \n In the .NET Framework on the desktop, the Process class by default uses <xref:System.Console> encodings, which are typically code page encodings, for the input, output, and error streams. For example code, on systems whose culture is English (United States), code page 437 is the default encoding for the <xref:System.Console> class. However, [!INCLUDE[net_core](~/add/includes/net-core-md.md)] may make only a limited subset of these encodings available. If this is the case, it uses <xref:System.Text.Encoding.UTF8%2A?displayProperty=fullName> as the default encoding.  \n  \n If a Process object depends on specific code page encodings, you can still make them available by doing the following *before* you call any Process methods:  \n  \n1.  Add a reference to the System.Text.Encoding.CodePages.dll assembly to your project.  \n  \n2.  Retrieve the <xref:System.Text.EncodingProvider> object from the <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=fullName> property.  \n  \n3.  Pass the <xref:System.Text.EncodingProvider> object to the <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=fullName> method to make the additional encodings supported by the encoding provider available.  \n  \n The Process class will then automatically use the default system encoding rather than UTF8, provided that you have registered the encoding provider before calling any Process methods."
  example:
  - "The following example uses an instance of the Process class to start a process.  \n  \n [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/t-system.diagnostics.pro_1_1.cpp)]\n [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/t-system.diagnostics.pro_1_1.vb)]\n [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/t-system.diagnostics.pro_1_1.cs)]  \n  \n The following example uses the Process class itself and a static <xref:System.Diagnostics.Process.Start%2A> method to start a process.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/t-system.diagnostics.pro_1_2.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/t-system.diagnostics.pro_1_2.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/t-system.diagnostics.pro_1_2.cpp)]  \n  \n The following F# example defines a `runProc` function that starts a process, captures all output and error information, and records the number of milliseconds that the process has run.  The `runProc` function has three parameters: the name of application to launch, the arguments to supply to the application, and the starting directory.  \n  \n [!code-fs[System.Diagnostics.Process#1](~/add/codesnippet/fsharp/t-system.diagnostics.pro_1_3.fs)]  \n  \n The code for the `runProc` function was written by [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) and is available under the [Microsoft Public License](http://opensource.org/licenses/ms-pl)."
  syntax:
    content: >-
      [System.ComponentModel.DefaultEvent("Exited")]

      [System.ComponentModel.DefaultProperty("StartInfo")]

      [System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      [System.Diagnostics.MonitoringDescription("ProcessDesc")]

      public class Process : System.ComponentModel.Component
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements: []
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Diagnostics.Process.#ctor
  id: '#ctor'
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Process()
  nameWithType: Process.Process()
  fullName: System.Diagnostics.Process.Process()
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "初始化的新实例<xref href=&quot;System.Diagnostics.Process&quot;></xref>类。"
  remarks: "如果不指定<xref:System.Diagnostics.Process.MachineName%2A>属性，则默认为本地计算机 (&quot;。&quot;)。</xref:System.Diagnostics.Process.MachineName%2A>       你有两个选项可用于将新<xref:System.Diagnostics.Process>组件与计算机上的进程。</xref:System.Diagnostics.Process> 第一个选项是使用构造函数来创建<xref:System.Diagnostics.Process>组件，设置的相应成员<xref:System.Diagnostics.Process.StartInfo%2A>属性并调用<xref:System.Diagnostics.Process.Start%2A>关联<xref:System.Diagnostics.Process>使用新的系统进程。</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A> </xref:System.Diagnostics.Process> 第二个选项是将关联<xref:System.Diagnostics.Process>与正在运行的系统进程，使用<xref:System.Diagnostics.Process.GetProcessById%2A>或之一<xref:System.Diagnostics.Process.GetProcesses%2A>返回值。</xref:System.Diagnostics.Process.GetProcesses%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> </xref:System.Diagnostics.Process>       如果你使用`static`重载<xref:System.Diagnostics.Process.Start%2A>方法来启动一个新的系统进程，该方法创建一个新<xref:System.Diagnostics.Process>组件并将它与进程相关联。</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A>       当<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>属性设置为其默认值， `true`，您可以在类似于使用一种方法启动应用程序和文档`Run`对话框中的 windows`Start`菜单。</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> 当<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>是`false`，你可以开始仅可执行文件。</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>       可以在两种方式之一中启动，可以从命令行调用任何可执行文件︰ 通过设置的相应成员<xref:System.Diagnostics.Process.StartInfo%2A>属性和调用<xref:System.Diagnostics.Process.Start%2A>方法提供任何参数，或通过将传递到适当的参数`static`<xref:System.Diagnostics.Process.Start%2A>成员。</xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A>       你可以创建<xref:System.Diagnostics.Process>组件通过使用构造函数中，一个静态<xref:System.Diagnostics.Process.Start%2A>重载，或任何<xref:System.Diagnostics.Process.GetProcessById%2A>， <xref:System.Diagnostics.Process.GetProcesses%2A>，或<xref:System.Diagnostics.Process.GetProcessesByName%2A>方法。</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcesses%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process> 你这样做之后，必须为关联进程的视图。 这不会自动更新自身，当进程属性更改在内存中的动态视图。 相反，您必须调用<xref:System.Diagnostics.Process.Refresh%2A>以更新组件的<xref:System.Diagnostics.Process>应用程序中的属性信息。</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Refresh%2A>"
  syntax:
    content: public Process ();
    parameters: []
  overload: System.Diagnostics.Process.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.BasePriority
  id: BasePriority
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: BasePriority
  nameWithType: Process.BasePriority
  fullName: System.Diagnostics.Process.BasePriority
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取关联进程的基本优先级。"
  remarks: "进程的 BasePriority 是关联的进程内创建的线程的起始优先级。 你可以查看通过系统监视器的优先级基数计数器的基本优先级有关的信息。       基于的时间应早其他放置过程时，运行时间或其他提升，操作系统可以更改的基本优先级。       BasePriority 属性，允许您查看分配给过程的起始优先级。 但是，因为它是只读的不能使用 BasePriority 设置进程的优先级。 若要更改的优先级，使用<xref:System.Diagnostics.Process.PriorityClass%2A>属性。</xref:System.Diagnostics.Process.PriorityClass%2A> BasePriority 是可查看使用系统监视器，而<xref:System.Diagnostics.Process.PriorityClass%2A>不是。</xref:System.Diagnostics.Process.PriorityClass%2A> 这两个 BasePriority 和<xref:System.Diagnostics.Process.PriorityClass%2A>可以以编程方式查看。</xref:System.Diagnostics.Process.PriorityClass%2A> 下表显示 BasePriority 值之间的关系和<xref:System.Diagnostics.Process.PriorityClass%2A>值。</xref:System.Diagnostics.Process.PriorityClass%2A>      |BasePriority |PriorityClass |  |------------------|-------------------|  |&4; |<xref:System.Diagnostics.ProcessPriorityClass>|  |&8; |<xref:System.Diagnostics.ProcessPriorityClass>|  |&13; |<xref:System.Diagnostics.ProcessPriorityClass>|  |&24; |<xref:System.Diagnostics.ProcessPriorityClass>|</xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_3_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_3_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_3_1.vb)]"
  syntax:
    content: public int BasePriority { get; }
    return:
      type: System.Int32
      description: "基本优先级，从计算<xref:System.Diagnostics.Process.PriorityClass*>关联进程。</xref:System.Diagnostics.Process.PriorityClass*>"
  overload: System.Diagnostics.Process.BasePriority*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me);设置&lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;属性<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>以 Windows 98 和 Windows me 上访问此属性"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "该进程已退出。       -或者-尚未启动进程，因此没有进程 id。"
  platform:
  - net462
- uid: System.Diagnostics.Process.BeginErrorReadLine
  id: BeginErrorReadLine
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: BeginErrorReadLine()
  nameWithType: Process.BeginErrorReadLine()
  fullName: System.Diagnostics.Process.BeginErrorReadLine()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "上开始进行异步读取的操作的重定向<xref:System.Diagnostics.Process.StandardError*>应用程序流。</xref:System.Diagnostics.Process.StandardError*>"
  remarks: "<xref:System.Diagnostics.Process.StandardError%2A>可以读取流，同步或异步。</xref:System.Diagnostics.Process.StandardError%2A> 等方法<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，和<xref:System.IO.StreamReader.ReadToEnd%2A>同步对执行读取的操作的错误输出流的过程。</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> 这些同步读取操作不会完成之前关联<xref:System.Diagnostics.Process>写入其<xref:System.Diagnostics.Process.StandardError%2A>流处理时，或关闭流。</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process>       与此相反，BeginErrorReadLine 开始异步读取操作上<xref:System.Diagnostics.Process.StandardError%2A>流。</xref:System.Diagnostics.Process.StandardError%2A> 此方法启用的指定的事件处理程序输出进行流式处理，并立即返回到调用方，流输出定向到事件处理程序时可以执行其他工作。       按照这些步骤上执行异步读取的操作<xref:System.Diagnostics.Process.StandardError%2A>为<xref:System.Diagnostics.Process>: 1。</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardError%2A>  Set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> to `false`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>      2.  Set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> to `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A>      3.  添加到事件处理程序<xref:System.Diagnostics.Process.ErrorDataReceived>事件。</xref:System.Diagnostics.Process.ErrorDataReceived> 事件处理程序必须与匹配<xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>委托签名。</xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>      4.  启动<xref:System.Diagnostics.Process>。</xref:System.Diagnostics.Process>      5.  调用 BeginErrorReadLine <xref:System.Diagnostics.Process>。</xref:System.Diagnostics.Process> 此调用会启动异步读取的操作的时间为<xref:System.Diagnostics.Process.StandardError%2A>。</xref:System.Diagnostics.Process.StandardError%2A>       调用异步读取的操作开始时，事件处理程序时每次关联<xref:System.Diagnostics.Process>写入到的文本行其<xref:System.Diagnostics.Process.StandardError%2A>流。</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process>       你可以通过调用<xref:System.Diagnostics.Process.CancelErrorRead%2A>.</xref:System.Diagnostics.Process.CancelErrorRead%2A>取消异步读的操作 由调用方或事件处理程序，可以取消读取的操作。 取消之后，你可以调用 BeginErrorReadLine 再次继续异步读取的操作。      1> [!NOTE]&1;> 不能混合使用重定向流上的异步和同步读取的操作。 一次的重定向的流<xref:System.Diagnostics.Process>打开在异步或同步模式下，所有进一步读取该流上的操作必须处于相同的模式。</xref:System.Diagnostics.Process> 例如，不要通过调用遵循 BeginErrorReadLine<xref:System.IO.StreamReader.ReadLine%2A>上<xref:System.Diagnostics.Process.StandardError%2A>流，反之亦然。</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.IO.StreamReader.ReadLine%2A> 但是，你可以读取在不同模式下的两个不同的流。 例如，你可以调用 BeginErrorReadLine，然后调用<xref:System.IO.StreamReader.ReadLine%2A>为<xref:System.Diagnostics.Process.StandardOutput%2A>流。</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.IO.StreamReader.ReadLine%2A>"
  example:
  - "The following example uses the `net view` command to list the available network resources on a remote computer. The user supplies the target computer name as a command-line argument. The user can also supply a file name for error output. The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console. If the user supplies the optional error file, the example writes errors to the file.  \n  \n [!code-cpp[Process_AsyncStreams#2](~/add/codesnippet/cpp/m-system.diagnostics.pro_4_1.cpp)]\n [!code-cs[Process_AsyncStreams#2](~/add/codesnippet/csharp/m-system.diagnostics.pro_4_1.cs)]\n [!code-vb[Process_AsyncStreams#2](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_4_1.vb)]"
  syntax:
    content: public void BeginErrorReadLine ();
    parameters: []
  overload: System.Diagnostics.Process.BeginErrorReadLine*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt; property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n An asynchronous read operation is already in progress on the <xref:System.Diagnostics.Process.StandardError*> stream.  \n  \n \\- or -  \n  \n The <xref:System.Diagnostics.Process.StandardError*> stream has been used by a synchronous read operation."
  platform:
  - net462
- uid: System.Diagnostics.Process.BeginOutputReadLine
  id: BeginOutputReadLine
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: BeginOutputReadLine()
  nameWithType: Process.BeginOutputReadLine()
  fullName: System.Diagnostics.Process.BeginOutputReadLine()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "上开始进行异步读取的操作的重定向<xref:System.Diagnostics.Process.StandardOutput*>应用程序流。</xref:System.Diagnostics.Process.StandardOutput*>"
  remarks: "<xref:System.Diagnostics.Process.StandardOutput%2A>可以读取流，同步或异步。</xref:System.Diagnostics.Process.StandardOutput%2A> 等方法<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，和<xref:System.IO.StreamReader.ReadToEnd%2A>同步对执行读取的操作过程的输出流。</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> 这些同步读取操作不会完成之前关联<xref:System.Diagnostics.Process>写入其<xref:System.Diagnostics.Process.StandardOutput%2A>流处理时，或关闭流。</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       与此相反，BeginOutputReadLine 开始异步读取操作上<xref:System.Diagnostics.Process.StandardOutput%2A>流。</xref:System.Diagnostics.Process.StandardOutput%2A> 此方法将启用流输出指定的事件处理程序并立即返回到调用方，流输出定向到事件处理程序时可以执行其他工作。       按照这些步骤上执行异步读取的操作<xref:System.Diagnostics.Process.StandardOutput%2A>为<xref:System.Diagnostics.Process>: 1。</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardOutput%2A>  Set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> to `false`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>      2.  Set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> to `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A>      3.  添加到事件处理程序<xref:System.Diagnostics.Process.OutputDataReceived>事件。</xref:System.Diagnostics.Process.OutputDataReceived> 事件处理程序必须与匹配<xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>委托签名。</xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>      4.  启动<xref:System.Diagnostics.Process>。</xref:System.Diagnostics.Process>      5.  调用 BeginOutputReadLine <xref:System.Diagnostics.Process>。</xref:System.Diagnostics.Process> 此调用会启动异步读取的操作的时间为<xref:System.Diagnostics.Process.StandardOutput%2A>。</xref:System.Diagnostics.Process.StandardOutput%2A>       调用异步读取的操作开始时，事件处理程序时每次关联<xref:System.Diagnostics.Process>写入到的文本行其<xref:System.Diagnostics.Process.StandardOutput%2A>流。</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       你可以通过调用<xref:System.Diagnostics.Process.CancelOutputRead%2A>.</xref:System.Diagnostics.Process.CancelOutputRead%2A>取消异步读的操作 由调用方或事件处理程序，可以取消读取的操作。 取消之后，你可以调用 BeginOutputReadLine 再次继续异步读取的操作。      1> [!NOTE]&1;> 不能混合使用重定向流上的异步和同步读取的操作。 一次的重定向的流<xref:System.Diagnostics.Process>打开在异步或同步模式下，所有进一步读取该流上的操作必须处于相同的模式。</xref:System.Diagnostics.Process> 例如，不要通过调用遵循 BeginOutputReadLine<xref:System.IO.StreamReader.ReadLine%2A>上<xref:System.Diagnostics.Process.StandardOutput%2A>流，反之亦然。</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.IO.StreamReader.ReadLine%2A> 但是，你可以读取在不同模式下的两个不同的流。 例如，你可以调用 BeginOutputReadLine，然后调用<xref:System.IO.StreamReader.ReadLine%2A>为<xref:System.Diagnostics.Process.StandardError%2A>流。</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.IO.StreamReader.ReadLine%2A>"
  example:
  - "The following example illustrates how to perform asynchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream of the `sort` command. The `sort` command is a console application that reads and sorts text input.  \n  \n The example creates an event delegate for the `SortOutputHandler` event handler and associates it with the <xref:System.Diagnostics.Process.OutputDataReceived> event. The event handler receives text lines from the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, formats the text, and writes the text to the screen.  \n  \n [!code-cpp[Process_AsyncStreams#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_13_1.cpp)]\n [!code-vb[Process_AsyncStreams#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_13_1.vb)]\n [!code-cs[Process_AsyncStreams#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_13_1.cs)]"
  syntax:
    content: public void BeginOutputReadLine ();
    parameters: []
  overload: System.Diagnostics.Process.BeginOutputReadLine*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt; property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n An asynchronous read operation is already in progress on the <xref:System.Diagnostics.Process.StandardOutput*> stream.  \n  \n \\- or -  \n  \n The <xref:System.Diagnostics.Process.StandardOutput*> stream has been used by a synchronous read operation."
  platform:
  - net462
- uid: System.Diagnostics.Process.CancelErrorRead
  id: CancelErrorRead
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: CancelErrorRead()
  nameWithType: Process.CancelErrorRead()
  fullName: System.Diagnostics.Process.CancelErrorRead()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "取消执行的异步读取操作的重定向<xref:System.Diagnostics.Process.StandardError*>的应用程序的流。</xref:System.Diagnostics.Process.StandardError*>"
  remarks: "<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>启动异步读取操作<xref:System.Diagnostics.Process.StandardError%2A>流。</xref:System.Diagnostics.Process.StandardError%2A></xref:System.Diagnostics.Process.BeginErrorReadLine%2A> CancelErrorRead 结束异步读取的操作。       取消之后，您可以通过来继续异步读取的操作调用<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>再次。</xref:System.Diagnostics.Process.BeginErrorReadLine%2A>       所有正在进行时调用 CancelErrorRead，读取操作<xref:System.Diagnostics.Process.StandardError%2A>完成和事件处理程序，则会禁用。</xref:System.Diagnostics.Process.StandardError%2A> 所有进一步重定向到输出<xref:System.Diagnostics.Process.StandardError%2A>保存在缓冲区中。</xref:System.Diagnostics.Process.StandardError%2A> 如果重新启用事件处理程序通过调用<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>，已保存的输出发送到事件处理程序并异步读取的操作恢复。</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 如果你想要继续执行异步读取的操作之前更改事件处理程序，则必须在添加新的事件处理程序之前删除现有的事件处理程序︰ ```   // At this point the DataReceivedEventHandler(ErrorHandler1)    // has executed a CancelErrorRead.      // Remove the prior event handler.   process.ErrorDataReceived -=        new DataReceivedEventHandler(ErrorHandler1);      // Register a new event handler.   process.ErrorDataReceived +=        new DataReceivedEventHandler(ErrorHandler2);      // Call the corresponding BeginErrorReadLine.   process.BeginErrorReadLine();   ```       >  [!NOTE]&1;> 不能混合使用异步和同步读取的操作的重定向<xref:System.Diagnostics.Process.StandardError%2A>流。</xref:System.Diagnostics.Process.StandardError%2A> 一次的重定向的流<xref:System.Diagnostics.Process>打开在异步或同步模式下，所有进一步读取该流上的操作必须处于相同的模式。</xref:System.Diagnostics.Process> 如果您取消异步，则读取上操作<xref:System.Diagnostics.Process.StandardError%2A>，然后需要从流中读取同样，你必须使用<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>继续异步读取的操作。</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> </xref:System.Diagnostics.Process.StandardError%2A> 通过同步读取方法的调用不遵循 CancelErrorRead<xref:System.Diagnostics.Process.StandardError%2A>如<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，或<xref:System.IO.StreamReader.ReadToEnd%2A>。</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> </xref:System.Diagnostics.Process.StandardError%2A>"
  example:
  - "The following example starts the `nmake` command with user supplied arguments. The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file. If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.  \n  \n [!code-cpp[Process_AsyncStreams#3](~/add/codesnippet/cpp/m-system.diagnostics.pro_7_1.cpp)]\n [!code-cs[Process_AsyncStreams#3](~/add/codesnippet/csharp/m-system.diagnostics.pro_7_1.cs)]\n [!code-vb[Process_AsyncStreams#3](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_7_1.vb)]"
  syntax:
    content: public void CancelErrorRead ();
    parameters: []
  overload: System.Diagnostics.Process.CancelErrorRead*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref:System.Diagnostics.Process.StandardError*>没有为异步读取操作启用流。</xref:System.Diagnostics.Process.StandardError*>"
  platform:
  - net462
- uid: System.Diagnostics.Process.CancelOutputRead
  id: CancelOutputRead
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: CancelOutputRead()
  nameWithType: Process.CancelOutputRead()
  fullName: System.Diagnostics.Process.CancelOutputRead()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "取消执行的异步读取操作的重定向<xref:System.Diagnostics.Process.StandardOutput*>的应用程序的流。</xref:System.Diagnostics.Process.StandardOutput*>"
  remarks: "<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>启动异步读取操作<xref:System.Diagnostics.Process.StandardOutput%2A>流。</xref:System.Diagnostics.Process.StandardOutput%2A></xref:System.Diagnostics.Process.BeginOutputReadLine%2A> CancelOutputRead 结束异步读取的操作。       取消之后，您可以通过来继续异步读取的操作调用<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>再次。</xref:System.Diagnostics.Process.BeginOutputReadLine%2A>       所有正在进行时调用 CancelOutputRead，读取操作<xref:System.Diagnostics.Process.StandardOutput%2A>完成和事件处理程序，则会禁用。</xref:System.Diagnostics.Process.StandardOutput%2A> 所有进一步重定向到输出<xref:System.Diagnostics.Process.StandardOutput%2A>保存在缓冲区中。</xref:System.Diagnostics.Process.StandardOutput%2A> 如果重新启用事件处理程序通过调用<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，已保存的输出发送到事件处理程序并异步读取的操作恢复。</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 如果你想要继续执行异步读取的操作之前更改事件处理程序，则必须在添加新的事件处理程序之前删除现有的事件处理程序︰ ```   // At this point the DataReceivedEventHandler(OutputHandler1)    // has executed a CancelOutputRead.      // Remove the prior event handler.   process.OutputDataReceived -=        new DataReceivedEventHandler(OutputHandler1);      // Register a new event handler.   process.OutputDataReceived +=        new DataReceivedEventHandler(OutputHandler2);      // Call the corresponding BeginOutputReadLine.   process.BeginOutputReadLine();   ```       >  [!NOTE]&1;> 不能混合使用异步和同步读取的操作的重定向<xref:System.Diagnostics.Process.StandardOutput%2A>流。</xref:System.Diagnostics.Process.StandardOutput%2A> 一次的重定向的流<xref:System.Diagnostics.Process>打开在异步或同步模式下，所有进一步读取该流上的操作必须处于相同的模式。</xref:System.Diagnostics.Process> 如果您取消异步，则读取上操作<xref:System.Diagnostics.Process.StandardOutput%2A>，然后需要从流中读取同样，你必须使用<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>继续异步读取的操作。</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> </xref:System.Diagnostics.Process.StandardOutput%2A> 通过同步读取方法的调用不遵循 CancelOutputRead<xref:System.Diagnostics.Process.StandardOutput%2A>如<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，或<xref:System.IO.StreamReader.ReadToEnd%2A>。</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> </xref:System.Diagnostics.Process.StandardOutput%2A>"
  example:
  - "The following example starts the `nmake` command with user supplied arguments. The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file. If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.  \n  \n [!code-cpp[Process_AsyncStreams#3](~/add/codesnippet/cpp/m-system.diagnostics.pro_3_1.cpp)]\n [!code-cs[Process_AsyncStreams#3](~/add/codesnippet/csharp/m-system.diagnostics.pro_3_1.cs)]\n [!code-vb[Process_AsyncStreams#3](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_3_1.vb)]"
  syntax:
    content: public void CancelOutputRead ();
    parameters: []
  overload: System.Diagnostics.Process.CancelOutputRead*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref:System.Diagnostics.Process.StandardOutput*>没有为异步读取操作启用流。</xref:System.Diagnostics.Process.StandardOutput*>"
  platform:
  - net462
- uid: System.Diagnostics.Process.Close
  id: Close
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Close()
  nameWithType: Process.Close()
  fullName: System.Diagnostics.Process.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "释放与此组件关联的所有资源。"
  remarks: "Close 方法会导致进程停止等待退出，如果它正在等待、 关闭进程句柄，并清除特定于进程的属性。 关闭不会关闭标准输出、 输入和错误的读取器和编写器，它们将被从外部引用的情况下。      1> [!NOTE]&1;><xref:System.Diagnostics.Process.Dispose%2A>方法调用关闭。</xref:System.Diagnostics.Process.Dispose%2A> 放置<xref:System.Diagnostics.Process>对象在`using`块释放资源而无需调用关闭。</xref:System.Diagnostics.Process>"
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2-second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_0_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_0_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_0_1.vb)]"
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Diagnostics.Process.Close*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.CloseMainWindow
  id: CloseMainWindow
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: CloseMainWindow()
  nameWithType: Process.CloseMainWindow()
  fullName: System.Diagnostics.Process.CloseMainWindow()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "关闭通过向其主窗口发送关闭消息具有用户界面的进程。"
  remarks: "执行过程时，其消息循环将处于等待状态。 消息循环执行每次操作系统的 Windows 消息发送到进程。 调用 CloseMainWindow 接近主窗口中，其格式正确的应用程序，在关闭子窗口，并撤消应用程序的所有正在运行消息循环中发送到的请求。 通过调用 CloseMainWindow 退出该进程的请求不会强制应用程序退出。 应用程序可以请求用户验证之前退出，或它可以拒绝退出。 若要强制应用程序退出，请使用<xref:System.Diagnostics.Process.Kill%2A>方法。</xref:System.Diagnostics.Process.Kill%2A> CloseMainWindow 的行为是用户的相同关闭应用程序的主窗口中使用系统菜单。 因此，通过关闭主窗口退出该进程的请求不会强制应用程序立即退出。       该进程编辑的数据或分配给进程的资源可能会丢失如果调用<xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> <xref:System.Diagnostics.Process.Kill%2A>导致异常的进程终止，并应仅在必要时使用。</xref:System.Diagnostics.Process.Kill%2A> CloseMainWindow 启用进程的有序地终止并关闭所有窗口，以使更为可取的接口的应用程序。 如果 CloseMainWindow 失败，则可以使用<xref:System.Diagnostics.Process.Kill%2A>终止进程。</xref:System.Diagnostics.Process.Kill%2A> <xref:System.Diagnostics.Process.Kill%2A>是终止不具有图形界面的进程的唯一方法。</xref:System.Diagnostics.Process.Kill%2A>       你可以调用<xref:System.Diagnostics.Process.Kill%2A>和 CloseMainWindow 仅的本地计算机运行的进程。</xref:System.Diagnostics.Process.Kill%2A> 在退出的远程计算机上，不会导致进程。 仅可以查看在远程计算机上运行的进程的信息。"
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_18_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_18_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_18_1.vb)]"
  syntax:
    content: public bool CloseMainWindow ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果成功发送了关闭消息;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>如果关联的进程没有主窗口或 （例如，如果当前显示模式对话框） 禁用了主窗口。"
  overload: System.Diagnostics.Process.CloseMainWindow*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me);设置&lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;属性<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>以 Windows 98 和 Windows me 上访问此属性"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "已经退出进程。       -或-没有进程是否与此相关联<xref href=&quot;System.Diagnostics.Process&quot;></xref>对象。"
  platform:
  - net462
- uid: System.Diagnostics.Process.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: Process.Dispose(Boolean)
  fullName: System.Diagnostics.Process.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "释放此进程使用的所有资源。"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要释放托管和非托管资源;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>若要仅释放非托管的资源。"
  overload: System.Diagnostics.Process.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.EnableRaisingEvents
  id: EnableRaisingEvents
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: EnableRaisingEvents
  nameWithType: Process.EnableRaisingEvents
  fullName: System.Diagnostics.Process.EnableRaisingEvents
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置是否<xref href=&quot;System.Diagnostics.Process.Exited&quot;></xref>在进程终止时，应引发事件。"
  remarks: "EnableRaisingEvents 属性指示当操作系统已关闭进程时是否应通知该组件。 在异步处理使用 EnableRaisingEvents 属性以通知应用程序进程已退出。 若要强制应用程序同步等待退出事件 （它中断的应用程序处理，直到退出事件发生为止），请使用<xref:System.Diagnostics.Process.WaitForExit%2A>方法。</xref:System.Diagnostics.Process.WaitForExit%2A>      1> [!NOTE]&1;> 如果你使用的 Visual Studio 并双击<xref:System.Diagnostics.Process>组件在项目中，<xref:System.Diagnostics.Process.Exited>自动生成事件委托和事件处理程序。</xref:System.Diagnostics.Process.Exited> </xref:System.Diagnostics.Process> 其他代码将 EnableRaisingEvents 属性设置为`false`。 必须更改此属性设置为`true`事件处理程序关联的进程退出时要执行的。       关联的进程在后的退出时关闭由操作系统或者通过正常或不正常终止时，操作系统通知到的进程相关联，每个进程组件，组件的 EnableRaisingEvents 值为`true`。 如果组件启动该进程，组件可以访问关联的进程，仍由操作系统存储的管理信息。 此类信息包括<xref:System.Diagnostics.Process.ExitTime%2A>，和<xref:System.Diagnostics.Process.ExitCode%2A>.</xref:System.Diagnostics.Process.ExitCode%2A> </xref:System.Diagnostics.Process.ExitTime%2A>       关联的进程退出后，则<xref:System.Diagnostics.Process.Handle%2A>的组件不再指向现有进程资源。</xref:System.Diagnostics.Process.Handle%2A> 相反，它可以是仅用于访问有关的进程资源的操作系统的信息。 操作系统已注意到有不通过已发布的已退出进程的句柄<xref:System.Diagnostics.Process>组件，因此它会保留<xref:System.Diagnostics.Process.ExitTime%2A>和<xref:System.Diagnostics.Process.Handle%2A>内存中的信息。</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process>       没有监视进程的退出会带来开销。 如果 EnableRaisingEvents `true`、<xref:System.Diagnostics.Process.Exited>在关联的进程终止时，将引发事件。</xref:System.Diagnostics.Process.Exited> 为指定的过程<xref:System.Diagnostics.Process.Exited>在该时间运行的事件。</xref:System.Diagnostics.Process.Exited>       有时，你的应用程序将启动一个进程，但不需要的关闭通知。 例如，你的应用程序可启动记事本以允许用户执行文本编辑，但没有任何进一步利用记事本应用程序。 你可以选择不会通知时在进程退出，因为它不是与你的应用程序继续运行。 设置为 EnableRaisingEvents`false`节省系统资源。"
  example:
  - "The following code example creates a process that prints a file. It sets the EnableRaisingEvents property to cause the process to raise the <xref:System.Diagnostics.Process.Exited> event when it exits. The <xref:System.Diagnostics.Process.Exited> event handler displays process information.  \n  \n [!code-vb[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_38_1.vb)]\n [!code-cs[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_38_1.cs)]"
  syntax:
    content: public bool EnableRaisingEvents { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Diagnostics.Process.Exited&quot;></xref>关联的进程终止时，应引发事件 (通过退出或者调用<xref:System.Diagnostics.Process.Kill*>); 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.Diagnostics.Process.Kill*> 默认值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Diagnostics.Process.EnableRaisingEvents*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.EnterDebugMode
  id: EnterDebugMode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: EnterDebugMode()
  nameWithType: Process.EnterDebugMode()
  fullName: System.Diagnostics.Process.EnterDebugMode()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "放入<xref href=&quot;System.Diagnostics.Process&quot;></xref>处于状态，以便与操作系统进行交互的组件处理以特殊模式运行的启用的本机属性<xref uid=&quot;langword_csharp_SeDebugPrivilege&quot; name=&quot;SeDebugPrivilege&quot; href=&quot;&quot;></xref>当前线程上。"
  remarks: "以特殊模式运行某些操作系统进程。 除非你在组件上调用了 EnterDebugMode，尝试读取的属性或将附加到这些进程不能。 调用<xref:System.Diagnostics.Process.LeaveDebugMode%2A>不再需要对这些特殊模式运行的进程的访问。</xref:System.Diagnostics.Process.LeaveDebugMode%2A>"
  syntax:
    content: public static void EnterDebugMode ();
    parameters: []
  overload: System.Diagnostics.Process.EnterDebugMode*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.ErrorDataReceived
  id: ErrorDataReceived
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ErrorDataReceived
  nameWithType: Process.ErrorDataReceived
  fullName: System.Diagnostics.Process.ErrorDataReceived
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "当应用程序写入其重定向时发生<xref:System.Diagnostics.Process.StandardError*>流。</xref:System.Diagnostics.Process.StandardError*>"
  remarks: "ErrorDataReceived 事件指示关联的进程已写入其重定向<xref:System.Diagnostics.Process.StandardError%2A>流。</xref:System.Diagnostics.Process.StandardError%2A>       在事件仅发生在异步读取操作的时间为<xref:System.Diagnostics.Process.StandardError%2A>。</xref:System.Diagnostics.Process.StandardError%2A>过程 若要开始异步读取的操作，必须重定向<xref:System.Diagnostics.Process.StandardError%2A><xref:System.Diagnostics.Process>，添加到 ErrorDataReceived 事件，事件处理程序，调用<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A></xref:System.Diagnostics.Process>流</xref:System.Diagnostics.Process.StandardError%2A> 此后，ErrorDataReceived 事件信号每次该过程将行写入重定向<xref:System.Diagnostics.Process.StandardError%2A>流，进程退出后才或调用<xref:System.Diagnostics.Process.CancelErrorRead%2A>.</xref:System.Diagnostics.Process.CancelErrorRead%2A> </xref:System.Diagnostics.Process.StandardError%2A>      1> [!NOTE]&1;> 正在处理的异步输出应用程序应调用<xref:System.Diagnostics.Process.WaitForExit%2A>方法，以确保已刷新输出缓冲区。</xref:System.Diagnostics.Process.WaitForExit%2A>"
  example:
  - "The following example uses the `net view` command to list the available network resources on a remote computer. The user supplies the target computer name as a command-line argument. The user can also supply a file name for error output. The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console. If the user supplies the optional error file, the example writes errors to the file.  \n  \n [!code-cpp[Process_AsyncStreams#2](~/add/codesnippet/cpp/e-system.diagnostics.pro_0_1.cpp)]\n [!code-cs[Process_AsyncStreams#2](~/add/codesnippet/csharp/e-system.diagnostics.pro_0_1.cs)]\n [!code-vb[Process_AsyncStreams#2](~/add/codesnippet/visualbasic/e-system.diagnostics.pro_0_1.vb)]"
  syntax:
    content: public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;
    return:
      type: System.Diagnostics.DataReceivedEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.ExitCode
  id: ExitCode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ExitCode
  nameWithType: Process.ExitCode
  fullName: System.Diagnostics.Process.ExitCode
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取关联的进程终止时指定的值。"
  remarks: "ExitCode 用于获取系统过程返回时退出该循环的状态。 您可以使用的退出代码更像一个整数，返回值从`main()`过程。       进程的退出代码值反映该进程的应用程序开发人员实现的特定约定。 如果你使用的退出代码值在你的代码中进行决策，请确保你知道使用应用程序进程的退出代码约定。       开发人员通常指示成功退出的 ExitCode 值为零，并且可以调用的方法可用于确定异常的进程终止原因的非零值，从而指定错误。 不需要遵循这些指导原则，但它们约定。       如果你尝试获取 ExitCode 之前该进程已退出，则尝试将引发异常。 检查<xref:System.Diagnostics.Process.HasExited%2A>属性首先以验证是否已终止关联的进程。</xref:System.Diagnostics.Process.HasExited%2A>      1> [!NOTE]&1;> 当已重标准输出定向到异步事件处理程序中时，有可能，输出处理还未完成时<xref:System.Diagnostics.Process.HasExited%2A>返回`true`。</xref:System.Diagnostics.Process.HasExited%2A> 若要确保已完成异步事件处理，调用的<xref:System.Diagnostics.Process.WaitForExit>重载采用再进行检查<xref:System.Diagnostics.Process.HasExited%2A>.</xref:System.Diagnostics.Process.HasExited%2A>无参数</xref:System.Diagnostics.Process.WaitForExit>       你可以使用<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>方法，使关联的进程退出。</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A>       关联的进程退出时收到通知的两种方式︰ 同步和异步方式。 同步通知依赖于调用<xref:System.Diagnostics.Process.WaitForExit%2A>方法来暂停应用程序处理，直到退出关联的组件。</xref:System.Diagnostics.Process.WaitForExit%2A> 异步通知依赖于<xref:System.Diagnostics.Process.Exited>事件。</xref:System.Diagnostics.Process.Exited> 使用异步通知时<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>必须设置为`true`为<xref:System.Diagnostics.Process>组件可以接收该进程已退出的通知。</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.EnableRaisingEvents%2A>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_6_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_6_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_6_1.vb)]"
  syntax:
    content: public int ExitCode { get; }
    return:
      type: System.Int32
      description: "关联的进程终止时指定的代码。"
  overload: System.Diagnostics.Process.ExitCode*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "进程尚未退出。       -过程<xref:System.Diagnostics.Process.Handle*>无效。</xref:System.Diagnostics.Process.Handle*>"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "正在尝试访问在远程计算机运行的进程的 ExitCode 属性。 此属性是仅适用于本地计算机运行的进程。"
  platform:
  - net462
- uid: System.Diagnostics.Process.Exited
  id: Exited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Exited
  nameWithType: Process.Exited
  fullName: System.Diagnostics.Process.Exited
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "在进程退出时发生。"
  remarks: "Exited 事件指示关联的进程退出。 此事件意味着任一进程终止 （中止） 或已成功关闭。 仅当，可能发生此事件的值<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>属性是`true`。</xref:System.Diagnostics.Process.EnableRaisingEvents%2A>       关联的进程退出时收到通知的两种方式︰ 同步和异步方式。 同步通知意味着调用<xref:System.Diagnostics.Process.WaitForExit%2A>方法进行阻止当前线程，直到在进程退出。</xref:System.Diagnostics.Process.WaitForExit%2A> 异步通知使用 Exited 事件，允许调用线程继续在此期间执行。 在后一种情况下，<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>必须设置为`true`调用应用程序中，若要对 Exited 事件进行接收。</xref:System.Diagnostics.Process.EnableRaisingEvents%2A>       当操作系统关闭进程时，它将通知所有已注册 Exited 事件的处理其他进程。 在此期间，只需退出进程的句柄可以用于访问某些属性如<xref:System.Diagnostics.Process.ExitTime%2A>和<xref:System.Diagnostics.Process.HasExited%2A>操作系统维护，直到它完全释放该句柄。</xref:System.Diagnostics.Process.HasExited%2A> </xref:System.Diagnostics.Process.ExitTime%2A>      1> [!NOTE]&1;> 即使你具有已退出的进程的句柄，不能调用<xref:System.Diagnostics.Process.Start%2A>以重新连接到相同的进程。</xref:System.Diagnostics.Process.Start%2A> 调用<xref:System.Diagnostics.Process.Start%2A>自动释放关联的进程和连接到具有相同的文件但全新<xref:System.Diagnostics.Process.Handle%2A>.</xref:System.Diagnostics.Process.Handle%2A>的进程</xref:System.Diagnostics.Process.Start%2A>       有关使用 Windows 窗体应用程序中的 Exited 事件的详细信息，请参阅<xref:System.Diagnostics.Process.SynchronizingObject%2A>属性。</xref:System.Diagnostics.Process.SynchronizingObject%2A>"
  example:
  - "The following code example creates a process that prints a file. It raises the Exited event when the process exits because the <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property was set when the process was created. The Exited event handler displays process information.  \n  \n [!code-vb[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/visualbasic/e-system.diagnostics.pro_1_1.vb)]\n [!code-cs[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/csharp/e-system.diagnostics.pro_1_1.cs)]"
  syntax:
    content: public event EventHandler Exited;
    return:
      type: System.EventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.ExitTime
  id: ExitTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ExitTime
  nameWithType: Process.ExitTime
  fullName: System.Diagnostics.Process.ExitTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取关联的进程退出的时间。"
  remarks: "如果未终止过程，尝试检索 ExitTime 属性引发异常。 使用<xref:System.Diagnostics.Process.HasExited%2A>之前获取 ExitTime 属性，以确定是否已终止关联的进程。</xref:System.Diagnostics.Process.HasExited%2A>"
  example:
  - "The following code example creates a process that prints a file. The process raises the <xref:System.Diagnostics.Process.Exited> event when it exits, and the event handler displays the ExitTime property and other process information.  \n  \n [!code-vb[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_14_1.vb)]\n [!code-cs[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_14_1.cs)]"
  syntax:
    content: public DateTime ExitTime { get; }
    return:
      type: System.DateTime
      description: "A <xref:System.DateTime>，该值指示关联的进程终止时。</xref:System.DateTime>"
  overload: System.Diagnostics.Process.ExitTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "正在尝试访问在远程计算机运行的进程的 ExitTime 属性。 此属性是仅适用于本地计算机运行的进程。"
  platform:
  - net462
- uid: System.Diagnostics.Process.GetCurrentProcess
  id: GetCurrentProcess
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetCurrentProcess()
  nameWithType: Process.GetCurrentProcess()
  fullName: System.Diagnostics.Process.GetCurrentProcess()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取一个新<xref href=&quot;System.Diagnostics.Process&quot;></xref>组件并将其与当前活动的进程关联。"
  remarks: "使用此方法创建一个新<xref:System.Diagnostics.Process>实例，并将其与本地计算机上的进程资源关联。</xref:System.Diagnostics.Process>       如类似<xref:System.Diagnostics.Process.GetProcessById%2A>， <xref:System.Diagnostics.Process.GetProcessesByName%2A>，和<xref:System.Diagnostics.Process.GetProcesses%2A>方法，GetCurrentProcess 将现有的资源与新关联<xref:System.Diagnostics.Process>组件。</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcesses%2A> </xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_10_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_10_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_10_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process GetCurrentProcess ();
    parameters: []
    return:
      type: System.Diagnostics.Process
      description: "一个新<xref href=&quot;System.Diagnostics.Process&quot;></xref>与运行调用应用程序的进程资源关联的组件。"
  overload: System.Diagnostics.Process.GetCurrentProcess*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessById(System.Int32)
  id: GetProcessById(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessById(Int32)
  nameWithType: Process.GetProcessById(Int32)
  fullName: System.Diagnostics.Process.GetProcessById(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "返回一个新<xref href=&quot;System.Diagnostics.Process&quot;></xref>组件，在本地计算机上给定进程的标识符。"
  remarks: "使用此方法创建一个新<xref:System.Diagnostics.Process>组件并将它与本地计算机上的进程资源关联。</xref:System.Diagnostics.Process> 进程资源必须已经存在的计算机上，因为 GetProcessById 不会创建一个系统资源，但而是将资源与应用程序生成相关联<xref:System.Diagnostics.Process>组件。</xref:System.Diagnostics.Process> 进程<xref:System.Diagnostics.Process.Id%2A>可以检索仅为当前计算机运行的进程。</xref:System.Diagnostics.Process.Id%2A> 在进程终止后，GetProcessById 将引发异常，如果你将其传递一个过期的标识符。       任何特定计算机上进程的标识符是唯一的。 GetProcessById 最多返回一个进程。 如果你想要获取所有运行特定应用程序的进程，使用<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>。</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> 如果运行指定的应用程序的计算机上存在多个进程<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>返回数组，其中包含所有关联的进程。</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> 你可以查询每个标识符反过来这些进程。 可以在中查看进程标识符`Processes`面板的 Windows 任务管理器。 `PID`列显示分配给进程的进程标识符。"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_19_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_19_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_19_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process GetProcessById (int processId);
    parameters:
    - id: processId
      type: System.Int32
      description: "进程资源的系统唯一标识符。"
    return:
      type: System.Diagnostics.Process
      description: "A <xref href=&quot;System.Diagnostics.Process&quot;> </xref>由标识的本地进程资源关联的组件<code> processId </code>参数。"
  overload: System.Diagnostics.Process.GetProcessById*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "指定的进程<code> processId </code>参数未运行。 此标识符可能已过期。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "此对象未启动进程。"
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  id: GetProcessById(System.Int32,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessById(Int32,String)
  nameWithType: Process.GetProcessById(Int32,String)
  fullName: System.Diagnostics.Process.GetProcessById(Int32,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "返回一个新<xref href=&quot;System.Diagnostics.Process&quot;></xref>组件，在网络上给定进程标识符和的计算机的名称。"
  remarks: "使用此方法创建一个新<xref:System.Diagnostics.Process>组件并将其与网络上的远程计算机上的进程资源关联。</xref:System.Diagnostics.Process> 进程资源必须已经存在在指定计算机上，因为 GetProcessById 不会创建一个系统资源，但而是将资源与应用程序生成相关联<xref:System.Diagnostics.Process>组件。</xref:System.Diagnostics.Process> 进程<xref:System.Diagnostics.Process.Id%2A>可以检索仅为当前计算机运行的进程。</xref:System.Diagnostics.Process.Id%2A> 在进程终止后，GetProcessById 将引发异常，如果你将其传递一个过期的标识符。       任何特定计算机上进程的标识符是唯一的。 GetProcessById 最多返回一个进程。 如果你想要获取所有运行特定应用程序的进程，使用<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>。</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> 如果运行指定的应用程序的计算机上存在多个进程<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>返回数组，其中包含所有关联的进程。</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> 你可以查询每个标识符反过来这些进程。 可以在中查看进程标识符`Processes`面板的 Windows 任务管理器。 `PID`列显示分配给进程的进程标识符。       如果不指定`machineName`，则使用本地计算机。 或者，你可以通过设置`machineName`为值&quot;。&quot;或为空字符串 (&quot;&quot;)。"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_8_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_8_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_8_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process GetProcessById (int processId, string machineName);
    parameters:
    - id: processId
      type: System.Int32
      description: "进程资源的系统唯一标识符。"
    - id: machineName
      type: System.String
      description: "网络上计算机的名称。"
    return:
      type: System.Diagnostics.Process
      description: "A <xref href=&quot;System.Diagnostics.Process&quot;> </xref>由标识的远程进程资源关联的组件<code> processId </code>参数。"
  overload: System.Diagnostics.Process.GetProcessById*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "指定的进程<code> processId </code>参数未运行。 此标识符可能已过期。       -或- <code> machineName </code>参数的语法无效。 名称可能包含长度为零 (0)。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>machineName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "此对象未启动进程。"
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcesses
  id: GetProcesses
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcesses()
  nameWithType: Process.GetProcesses()
  fullName: System.Diagnostics.Process.GetProcesses()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "创建一个新<xref href=&quot;System.Diagnostics.Process&quot;></xref>组件的本地计算机上每个进程资源。"
  remarks: "此方法用于创建新的数组<xref:System.Diagnostics.Process>组件并将它们与本地计算机上的所有进程资源关联。</xref:System.Diagnostics.Process> 进程资源必须已经存在的本地计算机上，因为 GetProcesses 不会创建系统资源，但而是将资源与应用程序生成相关联<xref:System.Diagnostics.Process>组件。</xref:System.Diagnostics.Process> 因为操作系统本身正在运行的后台进程，此数组不为空。       如果您不想要检索所有计算机上运行的进程，你可以通过使用来限制它们的数量<xref:System.Diagnostics.Process.GetProcessById%2A>或<xref:System.Diagnostics.Process.GetProcessesByName%2A>方法。</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessById%2A>创建<xref:System.Diagnostics.Process>与由传递给该方法的进程标识符标识系统上的进程关联的组件。</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessesByName%2A>创建的数组<xref:System.Diagnostics.Process>其关联的进程资源共享的可执行文件的组件你传递给方法。</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessesByName%2A>      1> [!NOTE]&1;> 可以在服务主机进程 (svchost.exe) 的同一个实例中加载多个 Windows 服务。 GetProcesses 不会确定这些单个服务; 示例︰为此，请参阅<xref:System.ServiceProcess.ServiceController.GetServices%2A>。</xref:System.ServiceProcess.ServiceController.GetServices%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_15_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_15_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_15_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcesses ();
    parameters: []
    return:
      type: System.Diagnostics.Process[]
      description: "类型的数组<xref href=&quot;System.Diagnostics.Process&quot;> </xref> ，表示本地计算机上运行的所有进程资源。"
  overload: System.Diagnostics.Process.GetProcesses*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcesses(System.String)
  id: GetProcesses(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcesses(String)
  nameWithType: Process.GetProcesses(String)
  fullName: System.Diagnostics.Process.GetProcesses(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "创建一个新<xref href=&quot;System.Diagnostics.Process&quot;></xref>组件为指定的计算机上每个进程资源。"
  remarks: "此方法用于创建新的数组<xref:System.Diagnostics.Process>组件并将其与指定 （通常为远程） 的计算机上的所有进程资源关联。</xref:System.Diagnostics.Process> 进程资源必须已经存在的本地计算机上，因为<xref:System.Diagnostics.Process.GetProcesses%2A>不会创建系统资源，但而是将资源与应用程序生成相关联<xref:System.Diagnostics.Process>组件。</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcesses%2A> 因为操作系统本身正在运行的后台进程，此数组不为空。       如果您不想要检索所有计算机上运行的进程，你可以通过使用来限制它们的数量<xref:System.Diagnostics.Process.GetProcessById%2A>或<xref:System.Diagnostics.Process.GetProcessesByName%2A>方法。</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessById%2A>创建<xref:System.Diagnostics.Process>与由传递给该方法的进程标识符标识系统上的进程关联的组件。</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessesByName%2A>创建的数组<xref:System.Diagnostics.Process>其关联的进程资源共享的可执行文件的组件你传递给方法。</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessesByName%2A>       此重载<xref:System.Diagnostics.Process.GetProcesses%2A>方法通常用于检索在网络上的远程计算机上运行的进程资源的列表，但你可以通过传递指定本地计算机&quot;。&quot;。</xref:System.Diagnostics.Process.GetProcesses%2A>      1> [!NOTE]&1;> 可以在服务主机进程 (svchost.exe) 的同一个实例中加载多个 Windows 服务。 GetProcesses 不会确定这些单个服务; 示例︰为此，请参阅<xref:System.ServiceProcess.ServiceController.GetServices%2A>。</xref:System.ServiceProcess.ServiceController.GetServices%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_11_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_11_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_11_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcesses (string machineName);
    parameters:
    - id: machineName
      type: System.String
      description: "要从其中读取进程列表计算机。"
    return:
      type: System.Diagnostics.Process[]
      description: "类型的数组<xref href=&quot;System.Diagnostics.Process&quot;> </xref> ，表示指定计算机上运行的所有进程资源。"
  overload: System.Diagnostics.Process.GetProcesses*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> machineName </code>参数的语法无效。 它可能具有长度为零 (0)。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>machineName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "操作系统平台不支持在远程计算机上的此操作。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "有访问 API 的用于获取进程信息的性能计数器的问题。 此例外情况是特定于 Windows NT、 Windows 2000 和 Windows XP。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "访问基础系统 API 时出现问题。"
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessesByName(System.String)
  id: GetProcessesByName(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessesByName(String)
  nameWithType: Process.GetProcessesByName(String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "新创建的数组<xref href=&quot;System.Diagnostics.Process&quot;></xref>组件并将它们与本地计算机上所有共享指定的进程名称的进程资源关联。"
  remarks: "此方法用于创建新的数组<xref:System.Diagnostics.Process>组件并将它们与正在本地计算机上的相同可执行文件的所有进程资源关联。</xref:System.Diagnostics.Process> 进程资源必须已经存在的计算机上，因为 GetProcessesByName 不会创建系统资源，但而是将它们与应用程序生成关联<xref:System.Diagnostics.Process>组件。</xref:System.Diagnostics.Process> A`processName`可为指定当前未运行的本地计算机，因此该方法返回的数组可以是空的可执行文件。       进程名称是为了让进程，如 Outlook，不包含扩展名为.exe 或路径的友好名称。 GetProcessesByName 可帮助获取和操作与相同的可执行文件相关联的所有进程。 例如，可以传递作为可执行文件名`processName`参数，以便关闭该可执行文件的所有正在运行的实例。       尽管进程<xref:System.Diagnostics.Process.Id%2A>是唯一的系统上的单个进程资源，本地计算机上的多个进程可以运行指定的应用程序`processName`参数。</xref:System.Diagnostics.Process.Id%2A> 因此，<xref:System.Diagnostics.Process.GetProcessById%2A>最多返回一个进程，但却 GetProcessesByName 返回数组，其中包含所有关联的进程。</xref:System.Diagnostics.Process.GetProcessById%2A> 如果你需要操作使用标准的 API 调用的进程，可以查询每个标识符反过来这些进程。 无法访问进程资源，通过单独的进程名称中，但一旦检索到的数组<xref:System.Diagnostics.Process>已相关联的组件与进程资源，你可以启动、 终止和以其他方式操作的系统资源。</xref:System.Diagnostics.Process>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_6_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_6_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_6_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcessesByName (string processName);
    parameters:
    - id: processName
      type: System.String
      description: "进程的友好名称。"
    return:
      type: System.Diagnostics.Process[]
      description: "类型的数组<xref href=&quot;System.Diagnostics.Process&quot;> </xref> ，表示运行指定的应用程序或文件的进程资源。"
  overload: System.Diagnostics.Process.GetProcessesByName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "有访问 API 的用于获取进程信息的性能计数器的问题。 此例外情况是特定于 Windows NT、 Windows 2000 和 Windows XP。"
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  id: GetProcessesByName(System.String,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessesByName(String,String)
  nameWithType: Process.GetProcessesByName(String,String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "新创建的数组<xref href=&quot;System.Diagnostics.Process&quot;></xref>组件并将它们与远程计算机上所有共享指定的进程名称的进程资源关联。"
  remarks: "此方法用于创建新的数组<xref:System.Diagnostics.Process>组件并将它们与正在运行指定的计算机上的相同可执行文件的所有进程资源关联。</xref:System.Diagnostics.Process> 进程资源必须已经存在的计算机上，因为<xref:System.Diagnostics.Process.GetProcessesByName%2A>不会创建系统资源，但而是将它们与应用程序生成关联<xref:System.Diagnostics.Process>组件。</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcessesByName%2A> A`processName`可为指定当前未运行的本地计算机，因此该方法返回的数组可以是空的可执行文件。       进程名称是为了让进程，如 Outlook，不包含扩展名为.exe 或路径的友好名称。 <xref:System.Diagnostics.Process.GetProcessesByName%2A>可帮助获取和操作与相同的可执行文件相关联的所有进程。</xref:System.Diagnostics.Process.GetProcessesByName%2A> 例如，可以传递作为可执行文件名`processName`参数，以便关闭该可执行文件的所有正在运行的实例。       尽管进程<xref:System.Diagnostics.Process.Id%2A>是唯一的系统上的单个进程资源，本地计算机上的多个进程可以运行指定的应用程序`processName`参数。</xref:System.Diagnostics.Process.Id%2A> 因此， <xref:System.Diagnostics.Process.GetProcessById%2A>，最多返回一个进程但<xref:System.Diagnostics.Process.GetProcessesByName%2A>返回数组，其中包含所有关联的进程。</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> 如果你需要操作使用标准的 API 调用的进程，可以查询每个标识符反过来这些进程。 无法访问进程资源，通过单独的进程名称中，但一旦检索到的数组<xref:System.Diagnostics.Process>已相关联的组件与进程资源，你可以启动、 终止和以其他方式操作的系统资源。</xref:System.Diagnostics.Process>       此重载可用于在本地计算机上以及在远程计算机获取进程。 使用&quot;。&quot;若要指定本地计算机。 存在另一个重载，默认情况下使用本地计算机。       你可以访问仅以查看有关进程的信息，统计信息，如的远程计算机上的进程。 无法关闭，终止 (使用<xref:System.Diagnostics.Process.Kill%2A>)，或在远程计算机上启动进程。</xref:System.Diagnostics.Process.Kill%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_14_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_14_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_14_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);
    parameters:
    - id: processName
      type: System.String
      description: "进程的友好名称。"
    - id: machineName
      type: System.String
      description: "网络上计算机的名称。"
    return:
      type: System.Diagnostics.Process[]
      description: "类型的数组<xref href=&quot;System.Diagnostics.Process&quot;> </xref> ，表示运行指定的应用程序或文件的进程资源。"
  overload: System.Diagnostics.Process.GetProcessesByName*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> machineName </code>参数的语法无效。 它可能具有长度为零 (0)。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>machineName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "操作系统平台不支持在远程计算机上的此操作。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "有访问 API 的用于获取进程信息的性能计数器的问题。 此例外情况是特定于 Windows NT、 Windows 2000 和 Windows XP。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "访问基础系统 API 时出现问题。"
  platform:
  - net462
- uid: System.Diagnostics.Process.Handle
  id: Handle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Handle
  nameWithType: Process.Handle
  fullName: System.Diagnostics.Process.Handle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取关联进程的本机句柄。"
  remarks: "应用程序可以获得到的进程，可以使用作为参数传递给许多进程信息和控制功能的句柄。 你可以使用此句柄初始化<xref:System.Threading.WaitHandle>或调用与平台的本机方法调用。</xref:System.Threading.WaitHandle>       此进程句柄是私有的某个应用程序，换而言之，句柄不能共享的过程。 进程也有过程<xref:System.Diagnostics.Process.Id%2A>，与该句柄，是唯一的因此，在整个系统有效。</xref:System.Diagnostics.Process.Id%2A>       通过调用启动仅进程<xref:System.Diagnostics.Process.Start%2A>设置相应的句柄属性<xref:System.Diagnostics.Process>实例。</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A>"
  syntax:
    content: public IntPtr Handle { get; }
    return:
      type: System.IntPtr
      description: "启动该进程时，操作系统将分配给关联的进程句柄。 系统使用此句柄来跟踪进程特性。"
  overload: System.Diagnostics.Process.Handle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "进程尚未启动或已退出。 无法读取句柄属性，因为没有与此关联的进程<xref href=&quot;System.Diagnostics.Process&quot;></xref>实例。       -或- <xref href=&quot;System.Diagnostics.Process&quot;> </xref>实例已附加到正在运行的进程，但你没有足够的权限来获取具有完全访问权限的句柄。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "正在尝试访问在远程计算机运行的进程的句柄属性。 此属性是仅适用于本地计算机运行的进程。"
  platform:
  - net462
- uid: System.Diagnostics.Process.HandleCount
  id: HandleCount
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: HandleCount
  nameWithType: Process.HandleCount
  fullName: System.Diagnostics.Process.HandleCount
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取由进程打开的句柄数。"
  remarks: "句柄提供使进程可以引用的对象的方法。 进程可以获取指向文件、 资源、 消息队列和许多其他操作系统对象的句柄。 操作系统回收仅当句柄计数为零时，才与进程关联的内存。"
  syntax:
    content: public int HandleCount { get; }
    return:
      type: System.Int32
      description: "进程打开的操作系统句柄数。"
  overload: System.Diagnostics.Process.HandleCount*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me);设置&lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;属性<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>以 Windows 98 和 Windows me 上访问此属性"
  platform:
  - net462
- uid: System.Diagnostics.Process.HasExited
  id: HasExited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: HasExited
  nameWithType: Process.HasExited
  fullName: System.Diagnostics.Process.HasExited
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取一个值，该值指示关联的进程是否已终止。"
  remarks: "值为`true`HasExited 指示关联的进程已终止，正常或异常。 可以请求，也可以强制关联的进程退出通过调用<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> 如果到进程打开的句柄，操作系统将释放的进程内存时进程已退出，但会保留有关过程，如句柄、 退出代码和退出时的管理信息。 若要获取此信息，可以使用<xref:System.Diagnostics.Process.ExitCode%2A>和<xref:System.Diagnostics.Process.ExitTime%2A>属性。</xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process.ExitCode%2A> 这些属性将自动填充此组件已启动的进程。 发布的管理信息时所有<xref:System.Diagnostics.Process>与系统进程关联的组件将销毁，并没有更多的句柄保留至已退出进程。</xref:System.Diagnostics.Process>       独立于你的代码可以终止进程。 如果你在开始使用此组件的过程，系统 HasExited 的值会自动更新，即使独立关联的进程退出。      1> [!NOTE]&1;> 当已重标准输出定向到异步事件处理程序中时，有可能时此属性返回不具有完成输出处理`true`。 若要确保已完成异步事件处理，调用<xref:System.Diagnostics.Process.WaitForExit>在检查 HasExited 之前不接受任何参数的重载。</xref:System.Diagnostics.Process.WaitForExit>"
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_33_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_33_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_33_1.vb)]"
  syntax:
    content: public bool HasExited { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果引用的操作系统进程<xref href=&quot;System.Diagnostics.Process&quot;></xref>组件已终止; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Diagnostics.Process.HasExited*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "没有与对象关联的进程。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "无法检索进程的退出代码。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "正在尝试访问在远程计算机运行的进程的 HasExited 属性。 此属性是仅适用于本地计算机运行的进程。"
  platform:
  - net462
- uid: System.Diagnostics.Process.Id
  id: Id
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Id
  nameWithType: Process.Id
  fullName: System.Diagnostics.Process.Id
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取为关联进程的唯一标识符。"
  remarks: "进程 Id 不是有效如果关联的进程未运行的。 因此，您应确保在尝试检索的 Id 属性之前正在运行的进程。 在进程终止，直到进程标识符唯一地标识在整个系统的过程。       你可以连接到新的本地或远程计算机运行的进程<xref:System.Diagnostics.Process>实例通过将传递到的进程标识符<xref:System.Diagnostics.Process.GetProcessById%2A>方法。</xref:System.Diagnostics.Process.GetProcessById%2A> </xref:System.Diagnostics.Process> <xref:System.Diagnostics.Process.GetProcessById%2A>是`static`方法，创建一个新的组件的新设置的 Id 属性<xref:System.Diagnostics.Process>自动实例。</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessById%2A>       可以由系统重用进程标识符。 仅在关联的进程正在运行时，Id 属性值是唯一的。 进程已终止后，系统可以重复使用不相关的进程的 Id 属性值。       因为该标识符是唯一系统上，你可以将其传递给其他线程作为传递的替代方法<xref:System.Diagnostics.Process>实例。</xref:System.Diagnostics.Process> 此操作可以节省系统资源，又可保证正确标识进程。"
  example:
  - "The following example demonstrates how to obtain the Id for all running instances of an application. The code creates a new instance of Notepad, lists all the instances of Notepad, and then allows the user to enter the Id number to remove a specific instance.  \n  \n [!code-cs[System.Diagnostics.Process.Id#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_36_1.cs)]\n [!code-vb[System.Diagnostics.Process.Id#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_36_1.vb)]"
  syntax:
    content: public int Id { get; }
    return:
      type: System.Int32
      description: "此引用的进程的系统生成的唯一标识符<xref href=&quot;System.Diagnostics.Process&quot;></xref>实例。"
  overload: System.Diagnostics.Process.Id*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "尚未设置进程的 Id 属性。       -或-没有与此关联的进程<xref href=&quot;System.Diagnostics.Process&quot;></xref>对象。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me);设置&lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;属性<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>以 Windows 98 和 Windows me 上访问此属性"
  platform:
  - net462
- uid: System.Diagnostics.Process.Kill
  id: Kill
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Kill()
  nameWithType: Process.Kill()
  fullName: System.Diagnostics.Process.Kill()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "立即停止关联的进程。"
  remarks: "Kill 强制终止的进程，而<xref:System.Diagnostics.Process.CloseMainWindow%2A>只请求在终止。</xref:System.Diagnostics.Process.CloseMainWindow%2A> 具有图形界面的进程执行时，其消息循环将处于等待状态。 消息循环执行每次操作系统的 Windows 消息发送到进程。 调用<xref:System.Diagnostics.Process.CloseMainWindow%2A>将请求发送到接近主窗口中，其格式正确的应用程序，在关闭子窗口，并撤消应用程序的所有正在运行消息循环。</xref:System.Diagnostics.Process.CloseMainWindow%2A> 通过调用退出该进程的请求<xref:System.Diagnostics.Process.CloseMainWindow%2A>不会强制应用程序退出。</xref:System.Diagnostics.Process.CloseMainWindow%2A> 应用程序可以请求用户验证之前退出，或它可以拒绝退出。 若要强制应用程序退出，请使用 Kill 方法。 行为<xref:System.Diagnostics.Process.CloseMainWindow%2A>等同于用户关闭应用程序的主窗口中使用系统菜单。</xref:System.Diagnostics.Process.CloseMainWindow%2A> 因此，通过关闭主窗口退出该进程的请求不会强制应用程序立即退出。      1> [!NOTE]&1;> Kill 方法以异步方式执行。 调用 Kill 方法后，调用<xref:System.Diagnostics.Process.WaitForExit%2A>方法来等待进程退出，或检查<xref:System.Diagnostics.Process.HasExited%2A>属性来确定该进程已退出。</xref:System.Diagnostics.Process.HasExited%2A> </xref:System.Diagnostics.Process.WaitForExit%2A>       如果调用 kill 命令，该进程编辑的数据或分配给进程的资源可能会丢失。 Kill 导致的异常进程终止，并仅在必要时才应使用。 <xref:System.Diagnostics.Process.CloseMainWindow%2A>启用过程的有序终止并关闭所有窗口，以使更为可取的接口的应用程序。</xref:System.Diagnostics.Process.CloseMainWindow%2A> 如果<xref:System.Diagnostics.Process.CloseMainWindow%2A>失败，你可以使用 Kill 终止进程。</xref:System.Diagnostics.Process.CloseMainWindow%2A> Kill 是终止不具有图形界面的进程的唯一方法。       你可以调用 Kill 和<xref:System.Diagnostics.Process.CloseMainWindow%2A>仅的本地计算机运行的进程。</xref:System.Diagnostics.Process.CloseMainWindow%2A> 在退出的远程计算机上，不会导致进程。 仅可以查看在远程计算机上运行的进程的信息。      1> [!NOTE]&1;> 如果对 Kill 方法的调用时当前在终止进程，由<xref:System.ComponentModel.Win32Exception>引发因访问被拒绝。</xref:System.ComponentModel.Win32Exception>"
  syntax:
    content: public void Kill ();
    parameters: []
  overload: System.Diagnostics.Process.Kill*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "无法终止关联的进程。       -或者-在终止进程。       -或者-关联的进程是 Win16 可执行文件。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "你尝试在远程计算机上运行的进程调用 kill 命令。 此方法是仅适用于本地计算机上运行的进程。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "已经退出进程。       -或-没有与此关联的进程<xref href=&quot;System.Diagnostics.Process&quot;></xref>对象。"
  platform:
  - net462
- uid: System.Diagnostics.Process.LeaveDebugMode
  id: LeaveDebugMode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: LeaveDebugMode()
  nameWithType: Process.LeaveDebugMode()
  fullName: System.Diagnostics.Process.LeaveDebugMode()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "采用<xref href=&quot;System.Diagnostics.Process&quot;></xref>组件离开允许它与以特殊模式运行的操作系统进程交互的状态。"
  remarks: "以特殊模式运行某些操作系统进程。 尝试读取的属性或将附加到这些进程不能除非你调用了<xref:System.Diagnostics.Process.EnterDebugMode%2A>组件上。</xref:System.Diagnostics.Process.EnterDebugMode%2A> 当你不再需要对这些特殊模式运行的进程的访问时，请调用 LeaveDebugMode。"
  syntax:
    content: public static void LeaveDebugMode ();
    parameters: []
  overload: System.Diagnostics.Process.LeaveDebugMode*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.MachineName
  id: MachineName
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MachineName
  nameWithType: Process.MachineName
  fullName: System.Diagnostics.Process.MachineName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取关联的进程正在运行的计算机的名称。"
  remarks: "你可以查看统计数据，并在远程计算机上，但是你运行的进程的进程信息不能调用<xref:System.Diagnostics.Process.Start%2A>， <xref:System.Diagnostics.Process.CloseMainWindow%2A>，或<xref:System.Diagnostics.Process.Kill%2A>在远程计算机上。</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> </xref:System.Diagnostics.Process.Start%2A>      1> [!NOTE]&1;> 时关联的进程在本地计算机上执行的此属性返回一个句点 (&quot;。&quot;) 为计算机名称。 应使用<xref:System.Environment.MachineName%2A?displayProperty=fullName>属性获取正确的计算机名称。</xref:System.Environment.MachineName%2A?displayProperty=fullName>"
  example:
  - "To use the following example you must first start at least one instance of Notepad on a remote computer. The example requests the name of the remote computer on which Notepad is running, and then displays the respective <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, and MachineName properties for each instance.  \n  \n [!code-cs[process_GetProcessesByName2_2#2](~/add/codesnippet/csharp/p-system.diagnostics.pro_26_1.cs)]\n [!code-cpp[process_GetProcessesByName2_2#2](~/add/codesnippet/cpp/p-system.diagnostics.pro_26_1.cpp)]\n [!code-vb[process_GetProcessesByName2_2#2](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_26_1.vb)]"
  syntax:
    content: public string MachineName { get; }
    return:
      type: System.String
      description: "关联的进程正在运行的计算机的名称。"
  overload: System.Diagnostics.Process.MachineName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "没有与此关联的进程<xref href=&quot;System.Diagnostics.Process&quot;></xref>对象。"
  platform:
  - net462
- uid: System.Diagnostics.Process.MainModule
  id: MainModule
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MainModule
  nameWithType: Process.MainModule
  fullName: System.Diagnostics.Process.MainModule
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取为关联进程的主模块。"
  remarks: "进程模块表示加载到特定的进程的.dll 或.exe 文件。 MainModule 属性允许你查看有关用于启动进程，包括模块名称、 文件名和模块内存详细信息的可执行文件的信息。"
  syntax:
    content: public System.Diagnostics.ProcessModule MainModule { get; }
    return:
      type: System.Diagnostics.ProcessModule
      description: "<xref href=&quot;System.Diagnostics.ProcessModule&quot;> </xref>用于启动进程。"
  overload: System.Diagnostics.Process.MainModule*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "正在尝试访问在远程计算机运行的进程的 MainModule 属性。 此属性是仅适用于本地计算机运行的进程。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "32 位进程尝试访问的 64 位进程的模块。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me);设置&lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;到<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>以 Windows 98 和 Windows me 上访问此属性"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "进程<xref:System.Diagnostics.Process.Id*>不可用。</xref:System.Diagnostics.Process.Id*>       -或者-该进程已退出。"
  platform:
  - net462
- uid: System.Diagnostics.Process.MainWindowHandle
  id: MainWindowHandle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MainWindowHandle
  nameWithType: Process.MainWindowHandle
  fullName: System.Diagnostics.Process.MainWindowHandle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取关联进程主窗口的窗口句柄。"
  remarks: "主窗口是由当前具有焦点的进程打开的窗口 (<xref:System.Windows.Forms.Form.TopLevel%2A>窗体)。</xref:System.Windows.Forms.Form.TopLevel%2A> 必须使用<xref:System.Diagnostics.Process.Refresh%2A>方法来刷新<xref:System.Diagnostics.Process>对象以获取当前的主窗口句柄，如果它已更改。</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Refresh%2A> 一般情况下，因为缓存的窗口句柄，则使用<xref:System.Diagnostics.Process.Refresh%2A>事先若要确保你将检索当前句柄。</xref:System.Diagnostics.Process.Refresh%2A>       你可以获取 MainWindowHandle 属性仅在本地计算机运行的进程。 MainWindowHandle 属性是用于唯一标识与进程相关联的窗口的值。       一个进程有一个仅当该过程提供一个图形界面与之关联的主窗口。 如果关联的进程没有主窗口，MainWindowHandle 值为零。 值也是对于进程已被隐藏，则为零，即处理，在任务栏中不可见。 这可能会在通知区域中，在任务栏最右侧显示为图标的进程的情况。       如果你刚刚启动了一个进程，并想要使用其主窗口句柄，请考虑使用<xref:System.Diagnostics.Process.WaitForInputIdle%2A>方法以允许该进程完成后从开始，确保已创建了主窗口句柄。</xref:System.Diagnostics.Process.WaitForInputIdle%2A> 否则，将引发异常。"
  syntax:
    content: public IntPtr MainWindowHandle { get; }
    return:
      type: System.IntPtr
      description: "关联进程主窗口的系统生成的窗口句柄。"
  overload: System.Diagnostics.Process.MainWindowHandle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "因为该进程已退出，未定义 MainWindowHandle。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "正在尝试访问在远程计算机运行的进程的 MainWindowHandle 属性。 此属性是仅适用于本地计算机运行的进程。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me);设置&lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;到<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>以 Windows 98 和 Windows me 上访问此属性"
  platform:
  - net462
- uid: System.Diagnostics.Process.MainWindowTitle
  id: MainWindowTitle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MainWindowTitle
  nameWithType: Process.MainWindowTitle
  fullName: System.Diagnostics.Process.MainWindowTitle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取进程的主窗口的标题。"
  remarks: "一个进程有一个仅当该过程提供一个图形界面与之关联的主窗口。 如果关联的进程没有主窗口 (以便<xref:System.Diagnostics.Process.MainWindowHandle%2A>为零)，MainWindowTitle 为空字符串 (&quot;&quot;)。</xref:System.Diagnostics.Process.MainWindowHandle%2A> 如果你刚刚启动了一个进程，并想要使用其主窗口标题，请考虑使用<xref:System.Diagnostics.Process.WaitForInputIdle%2A>方法以允许该进程完成后从开始，确保已创建了主窗口句柄。</xref:System.Diagnostics.Process.WaitForInputIdle%2A> 否则，系统将引发异常。      1> [!NOTE]&1;> 主窗口是当前具有焦点的窗口; 这可能不是进程的主窗口的注意。 必须使用<xref:System.Diagnostics.Process.Refresh%2A>方法来刷新<xref:System.Diagnostics.Process>对象以获取当前的主窗口句柄，如果它已更改。</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Refresh%2A>"
  example:
  - "The following example starts an instance of Notepad and retrieves the caption of the main window of the process.  \n  \n [!code-cpp[process_MainWindowTitle#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_45_1.cpp)]\n [!code-cs[process_MainWindowTitle#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_45_1.cs)]\n [!code-vb[process_MainWindowTitle#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_45_1.vb)]"
  syntax:
    content: public string MainWindowTitle { get; }
    return:
      type: System.String
      description: "进程主窗口标题。"
  overload: System.Diagnostics.Process.MainWindowTitle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "因为该进程已退出，未定义 MainWindowTitle 属性。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "正在尝试访问在远程计算机运行的进程的 MainWindowTitle 属性。 此属性是仅适用于本地计算机运行的进程。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me);设置&lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;到<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>以 Windows 98 和 Windows me 上访问此属性"
  platform:
  - net462
- uid: System.Diagnostics.Process.MaxWorkingSet
  id: MaxWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MaxWorkingSet
  nameWithType: Process.MaxWorkingSet
  fullName: System.Diagnostics.Process.MaxWorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置的最大允许工作集大小，以字节为单位，为关联的进程。"
  remarks: "进程工作集是物理 RAM 内存中的当前可见的进程的内存页的集合。 这些页面为常驻性并且可用于应用程序使用而不会触发页面错误。       工作集包括共享和私有数据。 共享的数据包括包含应用程序的执行，包括页面.dll 文件和 system.dll 文件中的所有说明的页。 随着工作集大小的增加，则会增加内存需求。       进程都有最小和最大工作集大小。 每次创建一个进程资源时，系统都会保留等于最小工作集大小的进程的内存量。 虚拟内存管理器尝试保持至少最小内存量常驻进程处于活动状态，但决不会保留的最大大小超过时。       系统设置的默认工作集大小。 你可以修改使用 MaxWorkingSet 这些大小和<xref:System.Diagnostics.Process.MinWorkingSet%2A>成员。</xref:System.Diagnostics.Process.MinWorkingSet%2A> 但是，设置这些值不保证内存将保留或驻留。      1> [!NOTE]&1;> 时增加进程工作集大小，你需要从系统的其余部分的物理内存。 确保你不会请求是太大，因为这样做会降低系统性能最小值或最大工作集大小。"
  syntax:
    content: public IntPtr MaxWorkingSet { get; set; }
    return:
      type: System.IntPtr
      description: "最大工作进程，以字节为单位的内存中集允许的大小。"
  overload: System.Diagnostics.Process.MaxWorkingSet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "最大工作集大小无效。 它必须大于或等于最小工作集大小。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "从关联的进程资源，无法检索工作集信息。       -或者-进程标识符或进程句柄为零，因为尚未启动进程。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "正在尝试访问在远程计算机运行的进程的 MaxWorkingSet 属性。 此属性是仅适用于本地计算机运行的进程。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "进程<xref:System.Diagnostics.Process.Id*>不可用。</xref:System.Diagnostics.Process.Id*>       -或者-该进程已退出。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。"
  platform:
  - net462
- uid: System.Diagnostics.Process.MinWorkingSet
  id: MinWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MinWorkingSet
  nameWithType: Process.MinWorkingSet
  fullName: System.Diagnostics.Process.MinWorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置的最小允许工作集大小，以字节为单位，为关联的进程。"
  remarks: "进程工作集是物理 RAM 内存中的当前可见的进程的内存页的集合。 这些页面为常驻性并且可用于应用程序使用而不会触发页面错误。       工作集包括共享和私有数据。 共享的数据包括包含应用程序的执行，包括页面.dll 文件和 system.dll 文件中的所有说明的页。 随着工作集大小的增加，则会增加内存需求。       进程都有最小和最大工作集大小。 每次创建一个进程资源时，系统都会保留等于最小工作集大小的进程的内存量。 虚拟内存管理器尝试保持至少最小内存量常驻进程处于活动状态，但决不会保留的最大大小超过时。       系统设置的默认工作集大小。 你可以修改使用这些大小<xref:System.Diagnostics.Process.MaxWorkingSet%2A>和 MinWorkingSet 成员。</xref:System.Diagnostics.Process.MaxWorkingSet%2A> 但是，设置这些值不保证内存将保留或驻留。      1> [!NOTE]&1;> 时增加进程工作集大小，你需要从系统的其余部分的物理内存。 确保你不会请求是太大，因为这样做会降低系统性能最小值或最大工作集大小。"
  syntax:
    content: public IntPtr MinWorkingSet { get; set; }
    return:
      type: System.IntPtr
      description: "最小工作集所需的大小，以进程，以字节为单位的内存。"
  overload: System.Diagnostics.Process.MinWorkingSet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "最小工作集大小无效。 它必须小于或等于最大工作集大小。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "从关联的进程资源，无法检索工作集信息。       -或者-进程标识符或进程句柄为零，因为尚未启动进程。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "正在尝试访问在远程计算机运行的进程的 MinWorkingSet 属性。 此属性是仅适用于本地计算机运行的进程。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "进程<xref:System.Diagnostics.Process.Id*>不可用。</xref:System.Diagnostics.Process.Id*>       -或者-该进程已退出。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。"
  platform:
  - net462
- uid: System.Diagnostics.Process.Modules
  id: Modules
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Modules
  nameWithType: Process.Modules
  fullName: System.Diagnostics.Process.Modules
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取已由关联进程加载的模块。"
  remarks: "进程模块表示加载到特定的进程的.dll 或.exe 文件。 A<xref:System.Diagnostics.ProcessModule>实例，您可以查看有关模块，包括模块名称、 文件名和模块内存详细信息的信息。</xref:System.Diagnostics.ProcessModule>       一个进程可以加载到内存中的多个模块。 例如，加载其他.dll 文件的.exe 文件具有多个模块。       之后启动该进程，此集合为空直到系统加载该进程。 如果进程都有一个主窗口，则可以调用<xref:System.Diagnostics.Process.WaitForInputIdle%2A>之前检索此属性，以确保集合非空时你可以获取的列表。</xref:System.Diagnostics.Process.WaitForInputIdle%2A>"
  syntax:
    content: public System.Diagnostics.ProcessModuleCollection Modules { get; }
    return:
      type: System.Diagnostics.ProcessModuleCollection
      description: "类型的数组<xref href=&quot;System.Diagnostics.ProcessModule&quot;> </xref> ，表示已由关联进程加载的模块。"
  overload: System.Diagnostics.Process.Modules*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "你尝试访问在远程计算机运行的进程的模块属性。 此属性是仅适用于本地计算机运行的进程。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "进程<xref:System.Diagnostics.Process.Id*>不可用。</xref:System.Diagnostics.Process.Id*>"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me);设置&lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;到<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>以 Windows 98 和 Windows me 上访问此属性"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "你尝试访问的系统过程或空闲的进程的模块属性。 这些进程不具有模块。"
  platform:
  - net462
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize
  id: NonpagedSystemMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: NonpagedSystemMemorySize
  nameWithType: Process.NonpagedSystemMemorySize
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取用字节表示，为关联进程分配的非分页的系统内存量。"
  syntax:
    content: public int NonpagedSystemMemorySize { get; }
    return:
      type: System.Int32
      description: "系统已为不能写入虚拟内存分页文件的关联进程分配的内存，以字节为单位，量。"
  overload: System.Diagnostics.Process.NonpagedSystemMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。"
  platform:
  - net462
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize64
  id: NonpagedSystemMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: NonpagedSystemMemorySize64
  nameWithType: Process.NonpagedSystemMemorySize64
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取用字节表示，为关联进程分配的非分页的系统内存量。"
  remarks: "返回此属性的值表示使用的过程中，以字节为单位的非分页的系统内存的当前大小。 系统内存是由操作系统的物理内存，并且分为分页和非页面缓冲池。 非分页的内存分配保留在系统内存，并且不会调出到虚拟内存分页文件。       此属性可以用于监视与 32 位处理器或 64 位处理器的计算机上的内存使用情况。 属性值等于**池非分页字节数**进程的性能计数器。"
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_28_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_28_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_28_1.vb)]"
  syntax:
    content: public long NonpagedSystemMemorySize64 { get; }
    return:
      type: System.Int64
      description: "系统内存，以字节为单位，为不能写入虚拟内存分页文件的关联进程分配的量。"
  overload: System.Diagnostics.Process.NonpagedSystemMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。"
  platform:
  - net462
- uid: System.Diagnostics.Process.OnExited
  id: OnExited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: OnExited()
  nameWithType: Process.OnExited()
  fullName: System.Diagnostics.Process.OnExited()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "引发<xref href=&quot;System.Diagnostics.Process.Exited&quot;></xref>事件。"
  remarks: "OnExited 是引发的 API 方法<xref:System.Diagnostics.Process.Exited>事件。</xref:System.Diagnostics.Process.Exited> 调用 OnExited 原因<xref:System.Diagnostics.Process.Exited>事件发生，是唯一的方法来引发事件使用<xref:System.Diagnostics.Process>组件。</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Exited> 从组件派生类时，主要使用 OnExited。       作为 OnExited 的替代方法，你可以编写事件处理程序。 创建你自己的事件处理程序委托和事件处理方法。      1> [!NOTE]&1;> 如果使用 Visual Studio 环境，一个事件处理程序委托 (AddOnExited) 和一个事件处理方法 (Process1_Exited) 会为您创建在拖动时<xref:System.Diagnostics.Process>组件拖动到窗体并双击该图标。</xref:System.Diagnostics.Process> 创建时要运行代码<xref:System.Diagnostics.Process.Exited>进入 Process1_Exited 过程发生的事件。</xref:System.Diagnostics.Process.Exited> 你不需要创建 OnExited 成员，因为它已为您实现。       引发事件时，将调用事件处理程序，通过委托。 有关概述，请参阅[事件](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example shows how to use the OnExited method in a derived class.  \n  \n [!code-cs[OnExitSample#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_9_1.cs)]\n [!code-vb[OnExitSample#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_9_1.vb)]"
  syntax:
    content: protected void OnExited ();
    parameters: []
  overload: System.Diagnostics.Process.OnExited*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.OutputDataReceived
  id: OutputDataReceived
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: OutputDataReceived
  nameWithType: Process.OutputDataReceived
  fullName: System.Diagnostics.Process.OutputDataReceived
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "每当应用程序将行写入其重定向<xref:System.Diagnostics.Process.StandardOutput*>流。</xref:System.Diagnostics.Process.StandardOutput*>"
  remarks: "OutputDataReceived 事件指示关联<xref:System.Diagnostics.Process>编写一条线路，以换行符，向其重定向终止<xref:System.Diagnostics.Process.StandardOutput%2A>流。</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       该事件在异步读取操作的时间为<xref:System.Diagnostics.Process.StandardOutput%2A>。</xref:System.Diagnostics.Process.StandardOutput%2A>过程已启用 若要开始异步读取的操作，必须重定向<xref:System.Diagnostics.Process.StandardOutput%2A><xref:System.Diagnostics.Process>，添加到 OutputDataReceived 事件，事件处理程序，调用<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A></xref:System.Diagnostics.Process>流</xref:System.Diagnostics.Process.StandardOutput%2A> 此后，OutputDataReceived 事件信号每次该过程将行写入重定向<xref:System.Diagnostics.Process.StandardOutput%2A>流，进程退出后才或调用<xref:System.Diagnostics.Process.CancelOutputRead%2A>.</xref:System.Diagnostics.Process.CancelOutputRead%2A> </xref:System.Diagnostics.Process.StandardOutput%2A>      1> [!NOTE]&1;> 正在处理的异步输出应用程序应调用<xref:System.Diagnostics.Process.WaitForExit%2A>方法，以确保已刷新输出缓冲区。</xref:System.Diagnostics.Process.WaitForExit%2A>"
  example:
  - "The following example illustrates how to perform asynchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream of the `ipconfig` command.  \n  \n The example creates an event delegate for the `OutputHandler` event handler and associates it with the OutputDataReceived event. The event handler receives text lines from the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, formats the text, and saves it in an output string that’s later shown in the example’s console window.  \n  \n [!code-cpp[Process_AsyncStreams#4](~/add/codesnippet/cpp/e-system.diagnostics.pro_2_1.cpp)]\n [!code-cs[Process_AsyncStreams#4](~/add/codesnippet/csharp/e-system.diagnostics.pro_2_1.cs)]\n [!code-vb[Process_AsyncStreams#4](~/add/codesnippet/visualbasic/e-system.diagnostics.pro_2_1.vb)]"
  syntax:
    content: public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;
    return:
      type: System.Diagnostics.DataReceivedEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedMemorySize
  id: PagedMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedMemorySize
  nameWithType: Process.PagedMemorySize
  fullName: System.Diagnostics.Process.PagedMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取用字节表示，为关联进程分配的分页内存量。"
  syntax:
    content: public int PagedMemorySize { get; }
    return:
      type: System.Int32
      description: "以字节为单位，由可写入虚拟内存分页文件的关联进程分配的内存量。"
  overload: System.Diagnostics.Process.PagedMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。"
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedMemorySize64
  id: PagedMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedMemorySize64
  nameWithType: Process.PagedMemorySize64
  fullName: System.Diagnostics.Process.PagedMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取用字节表示，为关联进程分配的分页内存量。"
  remarks: "返回此属性的值表示内存中使用的过程，以字节为单位的虚拟内存分页文件的当前大小。 操作系统使用与物理内存结合使用的虚拟内存分页文件来管理每个进程的虚拟地址空间。 分页的内存不使用时，它可以被传输到磁盘上的虚拟内存分页文件。 若要获取由操作系统使用的进程的内存大小，使用<xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>属性。</xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>       此属性可以用于监视与 32 位处理器或 64 位处理器的计算机上的内存使用情况。 属性值等于**页面文件字节**进程的性能计数器。"
  example:
  - "The following code example starts an instance of the Notepad application, and then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_12_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_12_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_12_1.vb)]"
  syntax:
    content: public long PagedMemorySize64 { get; }
    return:
      type: System.Int64
      description: "以字节为单位，在虚拟内存分页文件中为关联进程分配的内存量。"
  overload: System.Diagnostics.Process.PagedMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。"
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedSystemMemorySize
  id: PagedSystemMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedSystemMemorySize
  nameWithType: Process.PagedSystemMemorySize
  fullName: System.Diagnostics.Process.PagedSystemMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取用字节表示，为关联进程分配的可分页系统内存量。"
  syntax:
    content: public int PagedSystemMemorySize { get; }
    return:
      type: System.Int32
      description: "系统已为可以写入虚拟内存分页文件的关联进程分配的内存，以字节为单位，量。"
  overload: System.Diagnostics.Process.PagedSystemMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。"
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedSystemMemorySize64
  id: PagedSystemMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedSystemMemorySize64
  nameWithType: Process.PagedSystemMemorySize64
  fullName: System.Diagnostics.Process.PagedSystemMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取用字节表示，为关联进程分配的可分页系统内存量。"
  remarks: "返回此属性的值的值表示使用的过程中，以字节为单位的可分页系统内存的当前大小。 系统内存是由操作系统的物理内存，并且分为分页和非页面缓冲池。 分页的内存不使用时，它可以被传输到磁盘上的虚拟内存分页文件。 若要获取的进程使用的应用程序内存的大小，使用<xref:System.Diagnostics.Process.PagedMemorySize64%2A>属性。</xref:System.Diagnostics.Process.PagedMemorySize64%2A>       此属性可以用于监视与 32 位处理器或 64 位处理器的计算机上的内存使用情况。 属性值等于**Pool Paged Bytes**进程的性能计数器。"
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_18_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_18_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_18_1.vb)]"
  syntax:
    content: public long PagedSystemMemorySize64 { get; }
    return:
      type: System.Int64
      description: "系统内存，以字节为单位，为可写入虚拟内存分页文件的关联进程分配的量。"
  overload: System.Diagnostics.Process.PagedSystemMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。"
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakPagedMemorySize
  id: PeakPagedMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakPagedMemorySize
  nameWithType: Process.PeakPagedMemorySize
  fullName: System.Diagnostics.Process.PeakPagedMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取在虚拟内存分页文件中，以字节为单位，由关联进程使用的最大内存量。"
  syntax:
    content: public int PeakPagedMemorySize { get; }
    return:
      type: System.Int32
      description: "最大内存，以字节为单位，由可写入到虚拟内存分页文件的关联进程分配的量。"
  overload: System.Diagnostics.Process.PeakPagedMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。"
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakPagedMemorySize64
  id: PeakPagedMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakPagedMemorySize64
  nameWithType: Process.PeakPagedMemorySize64
  fullName: System.Diagnostics.Process.PeakPagedMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取在虚拟内存分页文件中，以字节为单位，由关联进程使用的最大内存量。"
  remarks: "返回此属性的值的值表示自启动，以字节为单位的进程使用的虚拟内存分页文件中的内存的最大大小。 操作系统使用与物理内存结合使用的虚拟内存分页文件来管理每个进程的虚拟地址空间。 分页的内存不使用时，它可以被传输到磁盘上的虚拟内存分页文件。       此属性可以用于监视与 32 位处理器或 64 位处理器的计算机上的内存使用情况。 属性值等于**页面文件字节峰值**进程的性能计数器。"
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_24_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_24_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_24_1.vb)]"
  syntax:
    content: public long PeakPagedMemorySize64 { get; }
    return:
      type: System.Int64
      description: "最大内存，以字节为单位，自启动以来为关联进程的虚拟内存分页文件中分配量。"
  overload: System.Diagnostics.Process.PeakPagedMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。"
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakVirtualMemorySize
  id: PeakVirtualMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakVirtualMemorySize
  nameWithType: Process.PeakVirtualMemorySize
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取用字节表示，由关联进程使用的最大虚拟内存量。"
  syntax:
    content: public int PeakVirtualMemorySize { get; }
    return:
      type: System.Int32
      description: "最大虚拟内存，以字节为单位，关联的进程请求的量。"
  overload: System.Diagnostics.Process.PeakVirtualMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。"
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakVirtualMemorySize64
  id: PeakVirtualMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakVirtualMemorySize64
  nameWithType: Process.PeakVirtualMemorySize64
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取用字节表示，由关联进程使用的最大虚拟内存量。"
  remarks: "返回此属性的值表示自启动，以字节为单位的进程使用的虚拟内存的最大大小。 操作系统将映射到页加载在物理内存中，或存储在磁盘上的虚拟内存分页文件的页面的每个进程的虚拟地址空间。       此属性可以用于监视与 32 位处理器或 64 位处理器的计算机上的内存使用情况。 属性值等于**虚拟字节峰值**进程的性能计数器。"
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_23_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_23_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_23_1.vb)]"
  syntax:
    content: public long PeakVirtualMemorySize64 { get; }
    return:
      type: System.Int64
      description: "最大虚拟内存，以字节为单位，自启动以来为关联进程分配量。"
  overload: System.Diagnostics.Process.PeakVirtualMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。"
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakWorkingSet
  id: PeakWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakWorkingSet
  nameWithType: Process.PeakWorkingSet
  fullName: System.Diagnostics.Process.PeakWorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取的峰值工作集大小为关联进程中，以字节为单位。"
  remarks: "进程工作集是物理 RAM 内存中的当前可见的进程的内存页的集合。 这些页面为常驻性并且可用于应用程序使用而不会触发页面错误。       工作集包括共享和私有数据。 共享的数据包括那些包含该进程执行，包括进程模块和系统库的所有说明的页。"
  syntax:
    content: public int PeakWorkingSet { get; }
    return:
      type: System.Int32
      description: "最大关联的进程已在一次，以字节为单位所需的物理内存量。"
  overload: System.Diagnostics.Process.PeakWorkingSet*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。"
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakWorkingSet64
  id: PeakWorkingSet64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakWorkingSet64
  nameWithType: Process.PeakWorkingSet64
  fullName: System.Diagnostics.Process.PeakWorkingSet64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取用字节表示，由关联进程使用的最大物理内存量。"
  remarks: "返回此属性的值表示工作集内存进程使用的自启动，以字节为单位的最大的大小。 进程工作集是物理 RAM 内存中的当前可见的进程的内存页的集合。 这些页面为常驻性并且可用于应用程序使用而不会触发页面错误。       工作集包括共享和私有数据。 共享的数据包括那些包含该进程执行，包括从进程模块和系统库的说明的所有说明的页。       此属性可以用于监视与 32 位处理器或 64 位处理器的计算机上的内存使用情况。 属性值等于**工作集峰值**进程的性能计数器。"
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_34_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_34_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_34_1.vb)]"
  syntax:
    content: public long PeakWorkingSet64 { get; }
    return:
      type: System.Int64
      description: "最大物理内存，以字节为单位，自启动以来为关联进程分配量。"
  overload: System.Diagnostics.Process.PeakWorkingSet64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。"
  platform:
  - net462
- uid: System.Diagnostics.Process.PriorityBoostEnabled
  id: PriorityBoostEnabled
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PriorityBoostEnabled
  nameWithType: Process.PriorityBoostEnabled
  fullName: System.Diagnostics.Process.PriorityBoostEnabled
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置一个值，该值是否主窗口拥有焦点时应由操作系统暂时提升关联的进程优先级。"
  remarks: "线程在进程中对其优先级类具有动态优先级枚举值之一的运行时 (<xref:System.Diagnostics.ProcessPriorityClass>， <xref:System.Diagnostics.ProcessPriorityClass>，或<xref:System.Diagnostics.ProcessPriorityClass>)，在它离开等待状态时系统便暂时提升的线程的优先级。</xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> 此操作可防止其他进程中断当前线程的处理。 PriorityBoostEnabled 设置会影响所有现有的线程和进程随后创建的任何线程。 若要还原正常行为，请将 PriorityBoostEnabled 属性设置为`false`。      1> [!NOTE]&1;> 提升过高的优先级会耗尽基本操作系统和网络功能，导致与其他操作系统任务的问题的资源。"
  syntax:
    content: public bool PriorityBoostEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果动态提升进程优先级别时应采取进程离开等待状态;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Diagnostics.Process.PriorityBoostEnabled*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "从关联的进程资源，无法检索优先级提升信息。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。       -或者-进程标识符或进程句柄为零。 （进程尚未启动。）"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "你尝试访问在远程计算机运行的进程的 PriorityBoostEnabled 属性。 此属性是仅适用于本地计算机运行的进程。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "进程<xref:System.Diagnostics.Process.Id*>不可用。</xref:System.Diagnostics.Process.Id*>"
  platform:
  - net462
- uid: System.Diagnostics.Process.PriorityClass
  id: PriorityClass
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PriorityClass
  nameWithType: Process.PriorityClass
  fullName: System.Diagnostics.Process.PriorityClass
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置关联进程的总体优先级类别。"
  remarks: "进程优先级类包含一系列线程优先级级别。 具有不同优先级的正在运行相对于进程的优先级类进程中运行的线程。 Win32 了七个基本优先级级别，每个类使用四个优先级类。 这些进程优先级类将在<xref:System.Diagnostics.ProcessPriorityClass>枚举，这样就可以将进程优先级设置为<xref:System.Diagnostics.ProcessPriorityClass>， <xref:System.Diagnostics.ProcessPriorityClass>， <xref:System.Diagnostics.ProcessPriorityClass>， <xref:System.Diagnostics.ProcessPriorityClass>， <xref:System.Diagnostics.ProcessPriorityClass>，或<xref:System.Diagnostics.ProcessPriorityClass>。</xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> 基于的时间的进程需要其他出于放访问到处理器时，可以由操作系统已更改的运行时间或其他提升，基本优先级别。 此外，你可以设置<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>以暂时提升离开等待状态的线程的优先级。</xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> 当过程返回到等待状态时，将重置优先级。       <xref:System.Diagnostics.Process.BasePriority%2A>属性，可以查看分配给过程的起始优先级。</xref:System.Diagnostics.Process.BasePriority%2A> 但是，因为它是只读的不能使用<xref:System.Diagnostics.Process.BasePriority%2A>属性来设置进程的优先级。</xref:System.Diagnostics.Process.BasePriority%2A> 若要更改的优先级，使用 PriorityClass 属性，用于获取或设置进程的总体优先级类别。       不能使用系统监视器查看优先级类。 下表显示之间的关系<xref:System.Diagnostics.Process.BasePriority%2A>和 PriorityClass 值。</xref:System.Diagnostics.Process.BasePriority%2A>      |BasePriority |PriorityClass |  |------------------|-------------------|  |&4; |<xref:System.Diagnostics.ProcessPriorityClass>|  |&8; |<xref:System.Diagnostics.ProcessPriorityClass>|  |&13; |<xref:System.Diagnostics.ProcessPriorityClass>|  |&24; |<xref:System.Diagnostics.ProcessPriorityClass>|</xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_29_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_29_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_29_1.vb)]"
  syntax:
    content: public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }
    return:
      type: System.Diagnostics.ProcessPriorityClass
      description: "依据的关联进程的优先级类别<xref:System.Diagnostics.Process.BasePriority*>计算进程。</xref:System.Diagnostics.Process.BasePriority*>"
  overload: System.Diagnostics.Process.PriorityClass*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "无法设置或从关联的进程资源中检索进程优先级信息。       -或者-进程标识符或进程句柄为零。 （进程尚未启动。）"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "你尝试访问在远程计算机运行的进程的 PriorityClass 属性。 此属性是仅适用于本地计算机运行的进程。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "进程<xref:System.Diagnostics.Process.Id*>不可用。</xref:System.Diagnostics.Process.Id*>"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "你已设置为 PriorityClass <xref uid=&quot;langword_csharp_AboveNormal&quot; name=&quot;AboveNormal&quot; href=&quot;&quot;> </xref>或<xref uid=&quot;langword_csharp_BelowNormal&quot; name=&quot;BelowNormal&quot; href=&quot;&quot;></xref>使用 Windows 98 或 Windows Millennium Edition (Windows Me) 时。 优先级类的情况下，这些平台不支持这些值。"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "优先级类无法设置，因为它不使用有效的值，因为在中定义<xref href=&quot;System.Diagnostics.ProcessPriorityClass&quot;></xref>枚举。"
  platform:
  - net462
- uid: System.Diagnostics.Process.PrivateMemorySize
  id: PrivateMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PrivateMemorySize
  nameWithType: Process.PrivateMemorySize
  fullName: System.Diagnostics.Process.PrivateMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取用字节表示，为关联进程分配的专用内存量。"
  syntax:
    content: public int PrivateMemorySize { get; }
    return:
      type: System.Int32
      description: "由不能与其他进程共享的关联进程分配的字节数。"
  overload: System.Diagnostics.Process.PrivateMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。"
  platform:
  - net462
- uid: System.Diagnostics.Process.PrivateMemorySize64
  id: PrivateMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PrivateMemorySize64
  nameWithType: Process.PrivateMemorySize64
  fullName: System.Diagnostics.Process.PrivateMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取用字节表示，为关联进程分配的专用内存量。"
  remarks: "返回此属性的值表示的过程，以字节为单位，不能共享与其他进程使用的内存的当前大小。       此属性可以用于监视与 32 位处理器或 64 位处理器的计算机上的内存使用情况。 属性值等于**专用字节**进程的性能计数器。"
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_17_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_17_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_17_1.vb)]"
  syntax:
    content: public long PrivateMemorySize64 { get; }
    return:
      type: System.Int64
      description: "以字节为单位，为不能与其他进程共享的关联进程分配的内存量。"
  overload: System.Diagnostics.Process.PrivateMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。"
  platform:
  - net462
- uid: System.Diagnostics.Process.PrivilegedProcessorTime
  id: PrivilegedProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PrivilegedProcessorTime
  nameWithType: Process.PrivilegedProcessorTime
  fullName: System.Diagnostics.Process.PrivilegedProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取此进程的特权的处理器时间。"
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_37_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_37_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_37_1.vb)]"
  syntax:
    content: public TimeSpan PrivilegedProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "A <xref:System.TimeSpan>，该值指示进程在操作系统内核中运行代码所用的时间量。</xref:System.TimeSpan>"
  overload: System.Diagnostics.Process.PrivilegedProcessorTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "你尝试访问在远程计算机运行的进程的 PrivilegedProcessorTime 属性。 此属性是仅适用于本地计算机运行的进程。"
  platform:
  - net462
- uid: System.Diagnostics.Process.ProcessName
  id: ProcessName
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ProcessName
  nameWithType: Process.ProcessName
  fullName: System.Diagnostics.Process.ProcessName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取该进程的名称。"
  remarks: "ProcessName 属性包含可执行文件名称，例如 Outlook 中，不包含扩展名为.exe 或路径。 它可帮助获取和操作与相同的可执行文件相关联的所有进程。      1> [!NOTE] 1> 上[!INCLUDE[Win2kFamily](~/add/includes/win2kfamily-md.md)]操作系统上，ProcessName 属性可能会被截断至 15 个字符如果无法获取进程模块信息。       你可以调用<xref:System.Diagnostics.Process.GetProcessesByName%2A>，将其传递可执行文件名称，以检索包含指定的计算机上每个正在运行的实例的数组。</xref:System.Diagnostics.Process.GetProcessesByName%2A> 可以使用此数组，例如，若要关闭所有运行的可执行文件的实例。"
  syntax:
    content: public string ProcessName { get; }
    return:
      type: System.String
      description: "系统用以向用户标识该进程的名称。"
  overload: System.Diagnostics.Process.ProcessName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "进程没有标识符，或与关联的进程<xref href=&quot;System.Diagnostics.Process&quot;> </xref>。       -或者-关联的进程已退出。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me);设置&lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;到<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>以 Windows 98 和 Windows me 上访问此属性"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "进程不是此计算机上。"
  platform:
  - net462
- uid: System.Diagnostics.Process.ProcessorAffinity
  id: ProcessorAffinity
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ProcessorAffinity
  nameWithType: Process.ProcessorAffinity
  fullName: System.Diagnostics.Process.ProcessorAffinity
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置在其上的线程在此过程中可以按计划运行的处理器。"
  remarks: "Windows 2000 及更高版本，一个进程中的线程可以迁移处理器间重新加载处理器缓存每个迁移。 在高系统负荷情况下指定在哪个处理器应运行特定线程可以提高性能通过减少处理器缓存都会重新加载的次数。 处理器和线程之间的关联称为处理器关联。       每个处理器表示为一位。 位 0 是一个处理器，位 1 是处理器二，等等。 如果将位设置为值 1，进行线程分配情况下会选择相应的处理器。 当设置为零的 ProcessorAffinity 值时，操作系统的计划算法会设置线程的关联。 当 ProcessorAffinity 值设置为任一非零值时，该值被解释为指定可供选择的处理器的位掩码。       下表显示了选择的八个处理器系统 ProcessorAffinity 值。      |位掩码 |二进制值 |符合条件的处理器 |  |-------------|------------------|-------------------------|  | 从 0x0001 | 00000000 00000001 | 1 |  | 0x0003 | 00000000 00000011 | 1 和 2 |  | 0x0007 | 00000000 00000111 | 1、 2 和 3 |  | 0x0009 | 00000000 00001001 | 1 和 4 |  | 0x007F | 00000000 01111111 | 1、 2、 3、 4、 5、 6 和 7 |"
  syntax:
    content: public IntPtr ProcessorAffinity { get; set; }
    return:
      type: System.IntPtr
      description: "位掩码，表示关联进程中的线程可以在运行的处理器。 默认值取决于计算机上的处理器数。 默认值为 2 <sup>n</sup> -1，其中 n 是处理器数。"
  overload: System.Diagnostics.Process.ProcessorAffinity*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "无法设置或从关联的进程资源中检索 ProcessorAffinity 信息。       -或者-进程标识符或进程句柄为零。 （进程尚未启动。）"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "你尝试访问在远程计算机运行的进程的 ProcessorAffinity 属性。 此属性是仅适用于本地计算机运行的进程。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "进程<xref:System.Diagnostics.Process.Id*>不可用，因而。</xref:System.Diagnostics.Process.Id*>       -或者-该进程已退出。"
  platform:
  - net462
- uid: System.Diagnostics.Process.Refresh
  id: Refresh
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Refresh()
  nameWithType: Process.Refresh()
  fullName: System.Diagnostics.Process.Refresh()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "放弃已缓存到进程组件的关联进程有关的任何信息。"
  remarks: "调用刷新后，有关每个属性的信息的第一个请求将导致进程组件从关联进程中获取新值。       当<xref:System.Diagnostics.Process>组件是关联的进程资源的属性值<xref:System.Diagnostics.Process>立即填充根据关联的进程的状态。</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process> 如果随后更改有关关联的进程的信息，这些更改不会反映在<xref:System.Diagnostics.Process>组件的缓存值。</xref:System.Diagnostics.Process> <xref:System.Diagnostics.Process>组件时的进程资源的快照是对与其关联。</xref:System.Diagnostics.Process> 若要查看为关联进程的当前值，调用刷新方法。"
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_1_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_1_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_1_1.vb)]"
  syntax:
    content: public void Refresh ();
    parameters: []
  overload: System.Diagnostics.Process.Refresh*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.Responding
  id: Responding
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Responding
  nameWithType: Process.Responding
  fullName: System.Diagnostics.Process.Responding
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取一个值，该值指示是否响应进程的用户界面。"
  remarks: "如果进程都有一个用户界面，正在响应属性将联系来确定进程是否正在响应用户输入的用户界面。 如果接口未响应立即，正在响应属性返回`false`。 使用此属性确定关联的进程的界面已停止响应。       如果进程不具有<xref:System.Diagnostics.Process.MainWindowHandle%2A>，此属性返回`true`。</xref:System.Diagnostics.Process.MainWindowHandle%2A>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_39_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_39_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_39_1.vb)]"
  syntax:
    content: public bool Responding { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果关联进程的用户界面当前响应系统，则为否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Diagnostics.Process.Responding*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me);设置&lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;到<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>以 Windows 98 和 Windows me 上访问此属性"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "没有与此关联的进程<xref href=&quot;System.Diagnostics.Process&quot;></xref>对象。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "你尝试访问在远程计算机上运行的进程的正在响应属性。 此属性是仅适用于本地计算机运行的进程。"
  platform:
  - net462
- uid: System.Diagnostics.Process.SafeHandle
  id: SafeHandle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: SafeHandle
  nameWithType: Process.SafeHandle
  fullName: System.Diagnostics.Process.SafeHandle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取此进程的本机句柄。"
  remarks: "此句柄才只有一个调用组件启动该进程。"
  syntax:
    content: public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }
    return:
      type: Microsoft.Win32.SafeHandles.SafeProcessHandle
      description: "此进程的本机句柄。"
  overload: System.Diagnostics.Process.SafeHandle*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.SessionId
  id: SessionId
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: SessionId
  nameWithType: Process.SessionId
  fullName: System.Diagnostics.Process.SessionId
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取为关联进程的终端服务会话标识符。"
  remarks: "SessionId 属性标识在其中应用程序当前正在运行的会话。"
  syntax:
    content: public int SessionId { get; }
    return:
      type: System.Int32
      description: "关联进程的的终端服务会话标识符。"
  overload: System.Diagnostics.Process.SessionId*
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "没有与此进程关联会话。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "没有与此会话标识符关联的进程。       -或者-关联的进程不在此计算机上。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "在 Windows 98 上不支持的 SessionId 属性。"
  platform:
  - net462
- uid: System.Diagnostics.Process.StandardError
  id: StandardError
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StandardError
  nameWithType: Process.StandardError
  fullName: System.Diagnostics.Process.StandardError
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取用于读取应用程序的错误输出流。"
  remarks: "当<xref:System.Diagnostics.Process>将文本写入其标准错误流中，通常在控制台上显示文本。</xref:System.Diagnostics.Process> 通过将 StandardError 流重定向，你可以操作或取消进程的错误输出。 例如，你可以筛选文本、 格式设置不同，或将输出写入控制台和一个指定的日志文件。      1> [!NOTE]&1;> 若要使用 StandardError，必须设置<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>到`false`，并且必须设置<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName>到`true`。</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> 否则，读取 StandardError 流将引发异常。       重定向的 StandardError 流可以同步或异步读取。 等方法<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，和<xref:System.IO.StreamReader.ReadToEnd%2A>同步对执行读取的操作的错误输出流的过程。</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> 这些同步读取操作不会完成之前关联<xref:System.Diagnostics.Process>写入其 StandardError 流，或关闭流。</xref:System.Diagnostics.Process>       与此相反，<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>开始异步读取 StandardError 流上的操作。</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 此方法将启用流输出指定的事件处理程序并立即返回到调用方，流输出定向到事件处理程序时可以执行其他工作。       同步读取的操作引入从 StandardError 流和子进程写入该流中读取的调用方之间的依赖项。 这些依赖关系可能会导致死锁条件。 当调用方读取子进程的重定向流时，它是依赖于子。 调用方上读取操作会一直等到子写入流或关闭流。 子进程在编写时数据不足，无法填充其重定向的流，它是依赖于父。 子进程一直等到下一步的写入操作上的父项从完整的流中读取或关闭流。 当调用方和子进程互相等待来完成操作，并且都可以继续执行，死锁条件的结果。 可以通过评估的调用方和子进程之间的依赖关系来避免死锁。       下面的 C# 代码，例如，演示如何从重定向流中读取并等待子进程退出。      ```   // Start the child process.    Process p = new Process();    // Redirect the error stream of the child process.    p.StartInfo.UseShellExecute = false;    p.StartInfo.RedirectStandardError = true;    p.StartInfo.FileName = &quot;Write500Lines.exe&quot;;    p.Start();    // Do not wait for the child process to exit before    // reading to the end of its redirected error stream.    // p.WaitForExit();    // Read the error stream first and then wait.    string error = p.StandardError.ReadToEnd();    p.WaitForExit();   ```下面的代码示例通过调用来避免死锁条件`p.StandardError.ReadToEnd`之前`p.WaitForExit`。 如果父进程调用会导致死锁条件`p.WaitForExit`之前`p.StandardError.ReadToEnd`和子进程将足够多的文本以填充重定向的流。 父进程将无限期地等待子进程退出。 子进程将无限期地等待父以从完整 StandardError 流中读取。       从标准输出和标准错误流读取所有文本时类似问题。 下面的 C# 代码，例如，执行对这两种流的读取的操作。      ```   // Do not perform a synchronous read to the end of both    // redirected streams.   // string output = p.StandardOutput.ReadToEnd();   // string error = p.StandardError.ReadToEnd();   // p.WaitForExit();   // Use asynchronous read operations on at least one of the streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```下面的代码示例通过执行异步上读取操作来避免死锁条件<xref:System.Diagnostics.Process.StandardOutput%2A>流。</xref:System.Diagnostics.Process.StandardOutput%2A> 死锁条件结果如果父进程调用`p.StandardOutput.ReadToEnd`跟`p.StandardError.ReadToEnd`和子进程将足够多的文本以填充其错误流。 父进程将无限期地等待子进程以关闭其<xref:System.Diagnostics.Process.StandardOutput%2A>流。</xref:System.Diagnostics.Process.StandardOutput%2A> 子进程将无限期地等待父以从完整 StandardError 流中读取。       异步读取的操作可用于避免这些依赖关系和其潜在的死锁。 或者，可以通过创建两个线程并读取在单独线程上的每个流的输出来避免出现死锁条件。      1> [!NOTE]&1;> 不能混合使用重定向流上的异步和同步读取的操作。 一次的重定向的流<xref:System.Diagnostics.Process>打开在异步或同步模式下，所有进一步读取该流上的操作必须处于相同的模式。</xref:System.Diagnostics.Process> 例如，不遵循<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>通过调用<xref:System.IO.StreamReader.ReadLine%2A>StandardError 流上，反之亦然。</xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 但是，你可以读取在不同模式下的两个不同的流。 例如，你可以调用<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，然后调用<xref:System.IO.StreamReader.ReadLine%2A>为 StandardError 的流。</xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A>"
  example:
  - "The following example uses the `net use` command together with a user supplied argument to map a network resource. It then reads the standard error stream of the net command and writes it to console.  \n  \n [!code-cs[Process_StandardError#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_41_1.cs)]\n [!code-cpp[Process_StandardError#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_41_1.cpp)]\n [!code-vb[Process_StandardError#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_41_1.vb)]"
  syntax:
    content: public System.IO.StreamReader StandardError { get; }
    return:
      type: System.IO.StreamReader
      description: "A<xref:System.IO.StreamReader>可以用于读取应用程序的标准错误流。</xref:System.IO.StreamReader>"
  overload: System.Diagnostics.Process.StandardError*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The StandardError stream has not been defined for redirection; ensure &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> and &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The StandardError stream has been opened for asynchronous read operations with <xref:System.Diagnostics.Process.BeginErrorReadLine*>."
  platform:
  - net462
- uid: System.Diagnostics.Process.StandardInput
  id: StandardInput
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StandardInput
  nameWithType: Process.StandardInput
  fullName: System.Diagnostics.Process.StandardInput
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取用于写入应用程序的输入流。"
  remarks: "A<xref:System.Diagnostics.Process>可以从其标准的输入流，通常是键盘读取输入的文本。</xref:System.Diagnostics.Process> 通过将 StandardInput 流重定向，你可以以编程方式指定输入。 例如，而不是使用键盘输入，你可以提供从指定文件的内容的文本或从另一个应用程序的输出。      1> [!NOTE]&1;> 若要使用 StandardInput，必须设置<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>到`false`，并且必须设置<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName>到`true`。</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> 否则，流将写入 StandardInput 引发异常。"
  example:
  - "The following example illustrates how to redirect the StandardInput stream of a process. The example starts the `sort` command with redirected input. It then prompts the user for text, and passes that to the `sort` process by means of the redirected StandardInput stream. The `sort` results are displayed to the user on the console.  \n  \n [!code-cs[Process_StandardInput#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_0_1.cs)]\n [!code-cpp[Process_StandardInput#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_0_1.cpp)]\n [!code-vb[Process_StandardInput#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_0_1.vb)]"
  syntax:
    content: public System.IO.StreamWriter StandardInput { get; }
    return:
      type: System.IO.StreamWriter
      description: "A<xref:System.IO.StreamWriter>可以用于写入应用程序的标准输入的流。</xref:System.IO.StreamWriter>"
  overload: System.Diagnostics.Process.StandardInput*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "因为尚未定义 StandardInput 流&lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName&gt;设置为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.Diagnostics.Process.StandardOutput
  id: StandardOutput
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StandardOutput
  nameWithType: Process.StandardOutput
  fullName: System.Diagnostics.Process.StandardOutput
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取用于读取应用程序文本输出流。"
  remarks: "当<xref:System.Diagnostics.Process>将文本写入其标准的流，通常在控制台上显示文本。</xref:System.Diagnostics.Process> 通过将 StandardOutput 流重定向，你可以操作或取消进程的输出。 例如，你可以筛选文本、 格式设置不同，或将输出写入控制台和一个指定的日志文件。      1> [!NOTE]&1;> 若要使用 StandardOutput，必须设置<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>到`false`，并且必须设置<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName>到`true`。</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> 否则，读取 StandardOutput 流将引发异常。       重定向的 StandardOutput 流可以同步或异步读取。 等方法<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，和<xref:System.IO.StreamReader.ReadToEnd%2A>同步对执行读取的操作过程的输出流。</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> 这些同步读取操作不会完成之前关联<xref:System.Diagnostics.Process>写入其 StandardOutput 流，或关闭流。</xref:System.Diagnostics.Process>       与此相反，<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>开始异步读取 StandardOutput 流上的操作。</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 此方法将启用流输出指定的事件处理程序并立即返回到调用方，流输出定向到事件处理程序时可以执行其他工作。       同步读取的操作引入从 StandardOutput 流和子进程写入该流中读取的调用方之间的依赖项。 这些依赖关系可能会导致死锁条件。 当调用方读取子进程的重定向流时，它是依赖于子。 调用方上读取操作会一直等到子写入流或关闭流。 子进程在编写时数据不足，无法填充其重定向的流，它是依赖于父。 子进程一直等到下一步的写入操作上的父项从完整的流中读取或关闭流。 当调用方和子进程互相等待来完成操作，并且都可以继续执行，死锁条件的结果。 可以通过评估的调用方和子进程之间的依赖关系来避免死锁。       下面的 C# 代码，例如，演示如何从重定向流中读取并等待子进程退出。      ```   Process p = new Process();   p.StartInfo.UseShellExecute = false;   p.StartInfo.RedirectStandardOutput = true;   p.StartInfo.FileName = &quot;Write500Lines.exe&quot;;   p.Start();      // To avoid deadlocks, always read the output stream first and then wait.   string output = p.StandardOutput.ReadToEnd();   p.WaitForExit();   ```下面的代码示例通过调用来避免死锁条件`p.StandardOutput.ReadToEnd`之前`p.WaitForExit`。 如果父进程调用会导致死锁条件`p.WaitForExit`之前`p.StandardOutput.ReadToEnd`和子进程将足够多的文本以填充重定向的流。 父进程将无限期地等待子进程退出。 子进程将无限期地等待父以从完整 StandardOutput 流中读取。       从标准输出和标准错误流读取所有文本时类似问题。 下面的 C# 代码，例如，执行对这两种流的读取的操作。      ```   // To avoid deadlocks, use asynchronous read operations on at least one of the streams.   // Do not perform a synchronous read to the end of both redirected streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```下面的代码示例通过执行对 StandardOutput 流异步读取的操作来避免死锁条件。 死锁条件结果如果父进程调用`p.StandardOutput.ReadToEnd`跟`p.StandardError.ReadToEnd`和子进程将足够多的文本以填充其错误流。 父进程将无限期地等待子进程以关闭其 StandardOutput 流。 子进程将无限期地等待父从完整读取<xref:System.Diagnostics.Process.StandardError%2A>流。</xref:System.Diagnostics.Process.StandardError%2A>       异步读取的操作可用于避免这些依赖关系和其潜在的死锁。 或者，可以通过创建两个线程并读取在单独线程上的每个流的输出来避免出现死锁条件。      1> [!NOTE]&1;> 不能混合使用重定向流上的异步和同步读取的操作。 一次的重定向的流<xref:System.Diagnostics.Process>打开在异步或同步模式下，所有进一步读取该流上的操作必须处于相同的模式。</xref:System.Diagnostics.Process> 例如，不遵循<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>通过调用<xref:System.IO.StreamReader.ReadLine%2A>StandardOutput 流上，反之亦然。</xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 但是，你可以读取在不同模式下的两个不同的流。 例如，你可以调用<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，然后调用<xref:System.IO.StreamReader.ReadLine%2A>为<xref:System.Diagnostics.Process.StandardError%2A>流。</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A>"
  example:
  - "The following example runs the ipconfig.exe command and redirects its standard output to the example’s console window.  \n  \n [!code-vb[Process_StandardOutput#2](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_11_1.vb)]\n [!code-cs[Process_StandardOutput#2](~/add/codesnippet/csharp/p-system.diagnostics.pro_11_1.cs)]\n [!code-cpp[Process_StandardOutput#2](~/add/codesnippet/cpp/p-system.diagnostics.pro_11_1.cpp)]"
  syntax:
    content: public System.IO.StreamReader StandardOutput { get; }
    return:
      type: System.IO.StreamReader
      description: "A<xref:System.IO.StreamReader>可以用于读取应用程序的标准输出流。</xref:System.IO.StreamReader>"
  overload: System.Diagnostics.Process.StandardOutput*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The StandardOutput stream has not been defined for redirection; ensure &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> and &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The StandardOutput stream has been opened for asynchronous read operations with <xref:System.Diagnostics.Process.BeginOutputReadLine*>."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start
  id: Start
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start()
  nameWithType: Process.Start()
  fullName: System.Diagnostics.Process.Start()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "启动 （或重用） 由指定的进程资源<xref:System.Diagnostics.Process.StartInfo*>此属性<xref href=&quot;System.Diagnostics.Process&quot;></xref>组件并将它与该组件关联。</xref:System.Diagnostics.Process.StartInfo*>"
  remarks: "Use this overload to start a process resource and associate it with the current <xref:System.Diagnostics.Process> component. The return value `true` indicates that a new process resource was started. If the process resource specified by the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property is already running on the computer, no additional process resource is started. Instead, the running process resource is reused and `false` is returned.  \n  \n You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.  \n  \n> [!NOTE]\n>  If you are using Visual Studio, this overload of the Start method is the one that you insert into your code after you drag a <xref:System.Diagnostics.Process> component onto the designer. Use the `Properties` window to expand the `StartInfo` category and write the appropriate value into the `FileName` property. Your changes will appear in the form's `InitializeComponent` procedure.  \n  \n This overload of Start is not a `static` method. You must call it from an instance of the <xref:System.Diagnostics.Process> class. Before calling Start, you must first specify <xref:System.Diagnostics.Process.StartInfo%2A> property information for this <xref:System.Diagnostics.Process> instance, because that information is used to determine the process resource to start.  \n  \n The other overloads of the Start method are `static` members. You do not need to create an instance of the <xref:System.Diagnostics.Process> component before you call those overloads of the method. Instead, you can call Start for the <xref:System.Diagnostics.Process> class itself, and a new <xref:System.Diagnostics.Process> component is created if the process was started. Or, `null` is returned if a process was reused. The process resource is automatically associated with the new <xref:System.Diagnostics.Process> component that is returned by the Start method.  \n  \n The <xref:System.Diagnostics.Process.StartInfo%2A> members can be used to duplicate the functionality of the `Run` dialog box of the Windows `Start` menu. Anything that can be typed into a command line can be started by setting the appropriate values in the <xref:System.Diagnostics.Process.StartInfo%2A> property. The only <xref:System.Diagnostics.Process.StartInfo%2A> property that must be set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property. The <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not have to be an executable file. It can be of any file type for which the extension has been associated with an application that is installed on the system. For example, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word.  \n  \n In the command line, you can specify actions to take for certain types of files. For example, you can print documents or edit text files. Specify these actions using the <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property. For other types of files, you can specify command-line arguments when you start the file from the `Run` dialog box. For example, you can pass a URL as an argument if you specify your browser as the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. These arguments can be specified in the <xref:System.Diagnostics.Process.StartInfo%2A> property's <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> member.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use Start to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example uses an instance of the <xref:System.Diagnostics.Process> class to start a process.  \n  \n [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_16_1.cpp)]\n [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_16_1.vb)]\n [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_16_1.cs)]"
  syntax:
    content: public bool Start ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果启动一个进程资源;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>如果没有新的进程资源 （例如，如果重用了现有进程） 已启动。"
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "中指定任何文件名<xref href=&quot;System.Diagnostics.Process&quot;></xref>组件的<> *1>。      -或- &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;的成员<> *1> 属性是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>时&lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName&gt;， &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt;，或&lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt;是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "打开关联的文件时出错。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已释放此进程对象。"
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  id: Start(System.Diagnostics.ProcessStartInfo)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(ProcessStartInfo)
  nameWithType: Process.Start(ProcessStartInfo)
  fullName: System.Diagnostics.Process.Start(ProcessStartInfo)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "启动由包含进程启动信息 （例如，要启动的进程的文件名称） 的参数指定的进程资源和将资源与新关联<xref href=&quot;System.Diagnostics.Process&quot;></xref>组件。"
  remarks: "Use this overload to start a process resource by specifying a <xref:System.Diagnostics.ProcessStartInfo> instance. The overload associates the resource with a new <xref:System.Diagnostics.Process> object.  \n  \n> [!NOTE]\n>  If the address of the executable file to start is a URL, the process is not started and `null` is returned.  \n  \n This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance. Using this overload with a <xref:System.Diagnostics.ProcessStartInfo> parameter is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting its <xref:System.Diagnostics.Process.StartInfo%2A> properties, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.  \n  \n Using a <xref:System.Diagnostics.ProcessStartInfo> instance as the parameter lets you call <xref:System.Diagnostics.Process.Start%2A> with the most control over what is passed into the call to start the process. If you need to pass only a file name or a file name and arguments, it is not necessary to create a new <xref:System.Diagnostics.ProcessStartInfo> instance, although that is an option. The only <xref:System.Diagnostics.Process.StartInfo%2A> property that must be set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property. The <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application that is installed on the system. For example, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word.  \n  \n You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.  \n  \n If the <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> and <xref:System.Diagnostics.ProcessStartInfo.Password%2A> properties of the <xref:System.Diagnostics.Process.StartInfo%2A> instance are set, the unmanaged `CreateProcessWithLogonW` function is called, which starts the process in a new window even if the <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> property value is `true` or the <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> property value is <xref:System.Diagnostics.ProcessWindowStyle>.  \n  \n Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member. Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance. Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the start information for the process resource by using a <xref:System.Diagnostics.ProcessStartInfo> instance.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the `startInfo` parameter, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.  \n  \n For additional examples of other uses of this method, refer to the individual properties of the <xref:System.Diagnostics.ProcessStartInfo> class.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_17_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_17_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_17_1.cpp)]"
  syntax:
    content: public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);
    parameters:
    - id: startInfo
      type: System.Diagnostics.ProcessStartInfo
      description: "<xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref> ，包含用于启动进程，包括文件名和任何命令行自变量的信息。"
    return:
      type: System.Diagnostics.Process
      description: "一个新<xref href=&quot;System.Diagnostics.Process&quot;></xref>的进程资源，与该键相关联或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果未启动进程。 请注意，与已在运行同一进程的实例一起启动的新进程将独立于其他。 此外，启动可能返回非 null 进程其<xref:System.Diagnostics.Process.HasExited*>属性已设置为<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。</xref:System.Diagnostics.Process.HasExited*> 在这种情况下，启动的进程可能已激活现有实例自身，然后退出。"
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "中指定任何文件名<code> startInfo </code>参数的<> *1> 属性。      -or-       The <>*> property of the <code>startInfo</code> parameter is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref> and the <>*>, <>*>, or <>*> property is also <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>.      -或- <> </> *1> 属性<code> startInfo </code>参数是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>和<> *1> 属性不是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>或为空或<> *1> 属性不是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>startInfo</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已释放此进程对象。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "中指定的文件<code> startInfo </code>参数的<xref:System.Diagnostics.ProcessStartInfo.FileName*>找不到属性。</xref:System.Diagnostics.ProcessStartInfo.FileName*>"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "打开关联的文件时出错。       -或者-自变量的长度与进程的完整路径的长度的总和超过了 2080年。 与此异常关联的错误消息可以是以下之一:&quot;传递到系统调用的数据区域是太小&quot;。 或者&quot;访问被拒绝&quot;。"
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String)
  id: Start(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String)
  nameWithType: Process.Start(String)
  fullName: System.Diagnostics.Process.Start(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "通过指定文档或应用程序文件的名称来启动一个进程资源和将资源与新关联<xref href=&quot;System.Diagnostics.Process&quot;></xref>组件。"
  remarks: "Use this overload to start a process resource by specifying its file name. The overload associates the resource with a new <xref:System.Diagnostics.Process> object.  \n  \n> [!NOTE]\n>  If the address of the executable file to start is a URL, the process is not started and `null` is returned.  \n  \n This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance. The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.  \n  \n You can start a ClickOnce application by setting the `fileName` parameter to the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.  \n  \n Starting a process by specifying its file name is similar to typing the information in the `Run` dialog box of the Windows `Start` menu. Therefore, the file name does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application installed on the system. For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word. Similarly, in the same way that the `Run` dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter. For example, you can set the `fileName` parameter to either \"Notepad.exe\" or \"Notepad\".  \n  \n This overload does not allow command-line arguments for the process. If you need to specify one or more command-line arguments for the process, use the <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=fullName> or <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=fullName> overloads.  \n  \n Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member. Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance. Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_2_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_2_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_2_1.cpp)]"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "要在进程中运行的文档或应用程序文件的名称。"
    return:
      type: System.Diagnostics.Process
      description: "一个新<xref href=&quot;System.Diagnostics.Process&quot;></xref>的进程资源，与该键相关联或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果未启动进程。 请注意，与已在运行同一进程的实例一起启动的新进程将独立于其他。 此外，启动可能返回非 null 进程其<xref:System.Diagnostics.Process.HasExited*>属性已设置为<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。</xref:System.Diagnostics.Process.HasExited*> 在这种情况下，启动的进程可能已激活现有实例自身，然后退出。"
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "打开关联的文件时出错。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已释放此进程对象。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "PATH 环境变量具有一个包含引号的字符串。"
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String,System.String)
  id: Start(System.String,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String,String)
  nameWithType: Process.Start(String,String)
  fullName: System.Diagnostics.Process.Start(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "通过指定应用程序的名称和一组命令行自变量，来启动一个进程资源并将资源与新关联<xref href=&quot;System.Diagnostics.Process&quot;></xref>组件。"
  remarks: "Use this overload to start a process resource by specifying its file name and command-line arguments. The overload associates the resource with a new <xref:System.Diagnostics.Process> object.  \n  \n> [!NOTE]\n>  If the address of the executable file to start is a URL, the process is not started and `null` is returned.  \n  \n This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance. The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> and <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> members of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.  \n  \n Starting a process by specifying its file name and arguments is similar to typing the file name and command-line arguments in the `Run` dialog box of the Windows `Start` menu. Therefore, the file name does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application installed on the system. For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word. Similarly, in the same way that the `Run` dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter. For example, you can set the `fileName` parameter to either \"Notepad.exe\" or \"Notepad\". If the `fileName` parameter represents an executable file, the `arguments` parameter might represent a file to act upon, such as the text file in `Notepad.exe myfile.txt`. If the `fileName` parameter represents a command (.cmd) file, the `arguments` parameter must include either a \"`/c`\" or \"`/k`\" argument to specify whether the command window exits or remains after completion.  \n  \n Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member. Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance. Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start and command-line arguments to pass.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property..  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_20_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_20_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_20_1.cpp)]"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName, string arguments);
    parameters:
    - id: fileName
      type: System.String
      description: "在进程中运行的应用程序文件的名称。"
    - id: arguments
      type: System.String
      description: "若要启动进程时传递的命令行参数。"
    return:
      type: System.Diagnostics.Process
      description: "一个新<xref href=&quot;System.Diagnostics.Process&quot;></xref>的进程资源，与该键相关联或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果未启动进程。 请注意，与已在运行同一进程的实例一起启动的新进程将独立于其他。 此外，启动可能返回非 null 进程其<xref:System.Diagnostics.Process.HasExited*>属性已设置为<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。</xref:System.Diagnostics.Process.HasExited*> 在这种情况下，启动的进程可能已激活现有实例自身，然后退出。"
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <code>fileName</code> or <code>arguments</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "打开关联的文件时出错。       -或者-自变量的长度与进程的完整路径的长度的总和超过了 2080年。 与此异常关联的错误消息可以是以下之一:&quot;传递到系统调用的数据区域是太小&quot;。 或者&quot;访问被拒绝&quot;。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已释放此进程对象。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "PATH 环境变量具有一个包含引号的字符串。"
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)
  id: Start(System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String,String,SecureString,String)
  nameWithType: Process.Start(String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,SecureString,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "通过指定应用程序的名称、 用户名、 密码和域来启动一个进程资源和将资源与新关联<xref href=&quot;System.Diagnostics.Process&quot;></xref>组件。"
  remarks: "使用此重载来通过指定其文件名称、 用户名、 密码和域中创建新的进程和其主线程。 然后，新进程指定的凭据 （用户、 域和密码） 的安全上下文中运行指定的可执行文件。      1> [!NOTE]&1;> 时可执行文件位于远程驱动器上，你必须通过使用统一资源标识符 (URI)，不链接的驱动器号来确定网络共享。      1> [!NOTE]&1;> 如果要启动的可执行文件的地址是 URL，则不会启动进程和`null`返回。       此重载使你无需首先创建一个新启动的进程<xref:System.Diagnostics.Process>实例。</xref:System.Diagnostics.Process> 该重载是创建一个新的显式步骤的替代方法<xref:System.Diagnostics.Process>实例，设置<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>， <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>， <xref:System.Diagnostics.ProcessStartInfo.Password%2A>，和<xref:System.Diagnostics.ProcessStartInfo.Domain%2A>属性<xref:System.Diagnostics.Process.StartInfo%2A>属性，再调用<xref:System.Diagnostics.Process.Start%2A>为<xref:System.Diagnostics.Process>实例。</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A> </xref:System.Diagnostics.ProcessStartInfo.Domain%2A> </xref:System.Diagnostics.ProcessStartInfo.Password%2A> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process>       同样，在相同的方式**运行**对话框中可以接受使用或不具有.exe 扩展名的可执行文件名、 扩展名为.exe 中是可选`fileName`参数。 例如，你可以设置`fileName`参数以&quot;Notepad.exe&quot;或&quot;记事本&quot;。 如果`fileName`参数表示一个可执行文件，`arguments`参数可能表示要执行操作，例如文本文件中的文件`Notepad.exe myfile.txt`。      1> [!NOTE]&1;> 的文件名称必须表示中的可执行文件<xref:System.Diagnostics.Process.Start%2A>具有重载`userName`， `password`，和`domain`参数。</xref:System.Diagnostics.Process.Start%2A>       无论何时使用<xref:System.Diagnostics.Process.Start%2A>若要启动进程时，你可能需要将其关闭或冒系统资源。</xref:System.Diagnostics.Process.Start%2A> 关闭进程使用<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> 你可以检查是否已关闭进程通过其<xref:System.Diagnostics.Process.HasExited%2A>属性...</xref:System.Diagnostics.Process.HasExited%2A>"
  example:
  - "The following code example shows the use of this overload to start an executable file and also demonstrates the throwing of a <xref:System.ComponentModel.Win32Exception> when an attempt is made to start an application associated with a nonexecutable file.  \n  \n [!code-cs[System.Diagnostics.Process.Start#1](~/add/codesnippet/csharp/fff1e658-5eee-484b-80e5-_1.cs)]\n [!code-vb[System.Diagnostics.Process.Start#1](~/add/codesnippet/visualbasic/fff1e658-5eee-484b-80e5-_1.vb)]"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);
    parameters:
    - id: fileName
      type: System.String
      description: "在进程中运行的应用程序文件的名称。"
    - id: userName
      type: System.String
      description: "启动进程时要使用的用户名。"
    - id: password
      type: System.Security.SecureString
      description: "A <xref href=&quot;System.Security.SecureString&quot;> </xref>包含启动进程时要使用的密码。"
    - id: domain
      type: System.String
      description: "要启动该进程时使用的域。"
    return:
      type: System.Diagnostics.Process
      description: "一个新<xref href=&quot;System.Diagnostics.Process&quot;></xref>的进程资源，与该键相关联或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果未启动进程。 请注意，与已在运行同一进程的实例一起启动的新进程将独立于其他。 此外，启动可能返回非 null 进程其<xref:System.Diagnostics.Process.HasExited*>属性已设置为<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。</xref:System.Diagnostics.Process.HasExited*> 在这种情况下，启动的进程可能已激活现有实例自身，然后退出。"
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "不指定任何文件名。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "打开关联的文件时出错。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已释放此进程对象。"
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  id: Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String,String,String,SecureString,String)
  nameWithType: Process.Start(String,String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,String,SecureString,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "通过指定应用程序、 一组命令行自变量、 用户名、 密码和域的名称来启动一个进程资源和将资源与新关联<xref href=&quot;System.Diagnostics.Process&quot;></xref>组件。"
  remarks: "使用此重载来通过指定其文件名、 命令行自变量、 用户名、 密码和域中创建新的进程和其主线程。 然后，新进程指定的凭据 （用户、 域和密码） 的安全上下文中运行指定的可执行文件。      1> [!NOTE]&1;> 时可执行文件位于远程驱动器上，你必须通过使用统一资源标识符 (URI)，不链接的驱动器号来确定网络共享。      1> [!NOTE]&1;> 如果要启动的可执行文件的地址是 URL，则不会启动进程和`null`返回。       此重载使你无需首先创建一个新启动的进程<xref:System.Diagnostics.Process>实例。</xref:System.Diagnostics.Process> 该重载是创建一个新的显式步骤的替代方法<xref:System.Diagnostics.Process>实例，设置<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>， <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>， <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>， <xref:System.Diagnostics.ProcessStartInfo.Password%2A>，和<xref:System.Diagnostics.ProcessStartInfo.Domain%2A>属性<xref:System.Diagnostics.Process.StartInfo%2A>属性，再调用<xref:System.Diagnostics.Process.Start%2A>为<xref:System.Diagnostics.Process>实例。</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A> </xref:System.Diagnostics.ProcessStartInfo.Domain%2A> </xref:System.Diagnostics.ProcessStartInfo.Password%2A> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A> </xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process>       同样，在相同的方式**运行**对话框中可以接受使用或不具有.exe 扩展名的可执行文件名、 扩展名为.exe 中是可选`fileName`参数。 例如，你可以设置`fileName`参数以&quot;Notepad.exe&quot;或&quot;记事本&quot;。 如果`fileName`参数表示一个可执行文件，`arguments`参数可能表示要执行操作，例如文本文件中的文件`Notepad.exe myfile.txt`。      1> [!NOTE]&1;> 的文件名称必须表示中的可执行文件<xref:System.Diagnostics.Process.Start%2A>具有重载`userName`， `password`，和`domain`参数。</xref:System.Diagnostics.Process.Start%2A>       无论何时使用<xref:System.Diagnostics.Process.Start%2A>若要启动进程时，你可能需要将其关闭或冒系统资源。</xref:System.Diagnostics.Process.Start%2A> 关闭进程使用<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> 你可以检查是否已关闭进程通过其<xref:System.Diagnostics.Process.HasExited%2A>属性...</xref:System.Diagnostics.Process.HasExited%2A>"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);
    parameters:
    - id: fileName
      type: System.String
      description: "在进程中运行的应用程序文件的名称。"
    - id: arguments
      type: System.String
      description: "若要启动进程时传递的命令行参数。"
    - id: userName
      type: System.String
      description: "启动进程时要使用的用户名。"
    - id: password
      type: System.Security.SecureString
      description: "A <xref href=&quot;System.Security.SecureString&quot;> </xref>包含启动进程时要使用的密码。"
    - id: domain
      type: System.String
      description: "要启动该进程时使用的域。"
    return:
      type: System.Diagnostics.Process
      description: "一个新<xref href=&quot;System.Diagnostics.Process&quot;></xref>的进程资源，与该键相关联或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果未启动进程。 请注意，与已在运行同一进程的实例一起启动的新进程将独立于其他。 此外，启动可能返回非 null 进程其<xref:System.Diagnostics.Process.HasExited*>属性已设置为<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。</xref:System.Diagnostics.Process.HasExited*> 在这种情况下，启动的进程可能已激活现有实例自身，然后退出。"
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "不指定任何文件名。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "打开关联的文件时出错。       -或者-自变量的长度与该关联文件的完整路径的长度的总和超过了 2080年。 与此异常关联的错误消息可以是以下之一:&quot;传递到系统调用的数据区域是太小&quot;。 或者&quot;访问被拒绝&quot;。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已释放此进程对象。"
  platform:
  - net462
- uid: System.Diagnostics.Process.StartInfo
  id: StartInfo
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StartInfo
  nameWithType: Process.StartInfo
  fullName: System.Diagnostics.Process.StartInfo
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置属性以传递给<xref:System.Diagnostics.Process.Start*>方法<xref href=&quot;System.Diagnostics.Process&quot;> </xref>。</xref:System.Diagnostics.Process.Start*>"
  remarks: "StartInfo 表示要用于启动过程的参数集。 当<xref:System.Diagnostics.Process.Start%2A>是调用，StartInfo 用于指定要启动的进程。</xref:System.Diagnostics.Process.Start%2A> 仅将必需的 StartInfo 成员，设置是<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性。</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 通过指定启动进程<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性是类似于键入中的信息**运行**对话框中的 windows**启动**菜单。</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 因此，<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性不需要表示一个可执行文件。</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 它可以是为其扩展已关联与应用程序在系统上安装任何文件类型。 例如<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>可以具有.txt 扩展名，如果你具有使用编辑器 （如记事本） 相关联的文本文件或者如果你已经将提供一个文字处理的工具，如 Microsoft Word 的文本文件，也可能产生.doc。</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 同样，在相同的方式**运行**对话框中可以接受使用或不具有.exe 扩展名的可执行文件名、 扩展名为.exe 中是可选<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>成员。</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 例如，你可以设置<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性设置为&quot;Notepad.exe&quot;或&quot;记事本&quot;。</xref:System.Diagnostics.ProcessStartInfo.FileName%2A>       您可以通过设置启动 ClickOnce 应用程序<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>最初从中安装应用程序的位置 （例如，Web 地址） 的属性。</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 不通过指定其安装的位置在硬盘驱动器上启动 ClickOnce 应用程序。       如果文件名涉及非可执行文件，例如.doc 文件，你可以包括一个谓词指定要对该文件执行的操作。 例如，你可以设置<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>到以.doc 扩展名的文件的&quot;打印&quot;。</xref:System.Diagnostics.ProcessStartInfo.Verb%2A> 中指定的文件名称<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性不需要具有扩展名，如果你手动输入的值<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>属性。</xref:System.Diagnostics.ProcessStartInfo.Verb%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 但是，如果你使用<xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>属性来确定哪些谓词的可用，必须包括扩展名。</xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>       你可以更改在你调用的时间 StartInfo 属性中指定的参数<xref:System.Diagnostics.Process.Start%2A>方法的过程。</xref:System.Diagnostics.Process.Start%2A> 启动过程后，更改 StartInfo 值不会影响或重新启动关联的进程。 如果调用<xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29>方法替换<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=fullName>和<xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=fullName>属性集，则非托管`CreateProcessWithLogonW`调用函数，以启动该过程在新窗口即使<xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A>属性值是`true`或<xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A>属性值为<xref:System.Diagnostics.ProcessWindowStyle>。</xref:System.Diagnostics.ProcessWindowStyle> </xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> </xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> </xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=fullName> </xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29>       如果你未使用<xref:System.Diagnostics.Process.Start%2A>方法来启动一个进程，StartInfo 属性不会反映用于启动进程的参数。</xref:System.Diagnostics.Process.Start%2A> 例如，如果你使用<xref:System.Diagnostics.Process.GetProcesses%2A>获取进程运行的计算机上，每个 StartInfo 属性的数组<xref:System.Diagnostics.Process>不包含的原始文件名或用于启动进程的自变量。</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcesses%2A>       当启动进程时，文件名是填充 （只读） 的文件<xref:System.Diagnostics.Process.MainModule%2A>属性。</xref:System.Diagnostics.Process.MainModule%2A> 如果你想要检索进程启动后与进程相关联的可执行文件，请使用<xref:System.Diagnostics.Process.MainModule%2A>属性。</xref:System.Diagnostics.Process.MainModule%2A> 如果你想要设置的可执行文件<xref:System.Diagnostics.Process>实例为其关联的进程尚未启动，请使用 StartInfo 属性<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>成员。</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process> 因为 StartInfo 属性的成员是自变量传递给<xref:System.Diagnostics.Process.Start%2A>方法的过程中，更改<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性关联的进程启动后将不会重置<xref:System.Diagnostics.Process.MainModule%2A>属性。</xref:System.Diagnostics.Process.MainModule%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process.Start%2A> 这些属性仅用于初始化关联的进程。"
  example:
  - "The following example populates a StartInfo with the file to execute, the action performed on it and whether it should displays a user interface. For additional examples, refer to the reference pages for properties of the <xref:System.Diagnostics.ProcessStartInfo> class.  \n  \n [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_10_1.cpp)]\n [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_10_1.vb)]\n [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_10_1.cs)]"
  syntax:
    content: public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }
    return:
      type: System.Diagnostics.ProcessStartInfo
      description: "<xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref>表示启动进程使用的数据。 这些参数包括的可执行文件或用于启动进程的文档的名称。"
  overload: System.Diagnostics.Process.StartInfo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "用于指定 StartInfo 的值是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.Diagnostics.Process.StartTime
  id: StartTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StartTime
  nameWithType: Process.StartTime
  fullName: System.Diagnostics.Process.StartTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取关联的进程启动的时间。"
  syntax:
    content: public DateTime StartTime { get; }
    return:
      type: System.DateTime
      description: "一个对象，指示进程启动的时间。 如果进程未运行，将引发异常。"
  overload: System.Diagnostics.Process.StartTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "你尝试访问在远程计算机运行的进程的 StartTime 属性。 此属性是仅适用于本地计算机运行的进程。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "该进程已退出。       -或者-尚未启动进程。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "对 Windows 函数的调用中出错。"
  platform:
  - net462
- uid: System.Diagnostics.Process.SynchronizingObject
  id: SynchronizingObject
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: SynchronizingObject
  nameWithType: Process.SynchronizingObject
  fullName: System.Diagnostics.Process.SynchronizingObject
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置用于封送由于进程退出事件而发出的事件处理程序调用的对象。"
  remarks: "当<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>是`null`，方法，用于处理<xref:System.Diagnostics.Process.Exited>事件调用从系统线程池线程上。</xref:System.Diagnostics.Process.Exited> </xref:System.Diagnostics.EventLog.SynchronizingObject%2A> 有关系统线程池的详细信息，请参阅<xref:System.Threading.ThreadPool>。</xref:System.Threading.ThreadPool>       当<xref:System.Diagnostics.Process.Exited>事件由 visual 的 Windows 窗体组件，如处理<xref:System.Windows.Forms.Button>，通过系统线程池访问组件可能不起作用，或者可能会导致异常。</xref:System.Windows.Forms.Button> </xref:System.Diagnostics.Process.Exited> 通过设置 SynchronizingObject 到 Windows 窗体组件时，这会导致处理的方法来避免这<xref:System.Diagnostics.Process.Exited>事件在其创建该组件在同一线程上调用。</xref:System.Diagnostics.Process.Exited>       如果<xref:System.Diagnostics.Process>在内部使用[!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)]在 Windows 窗体设计器中，SynchronizingObject 自动设置为该控件包含<xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process> 例如，如果你将放置<xref:System.Diagnostics.Process>的设计器上`Form1`(其继承自<xref:System.Windows.Forms.Form>) 的 SynchronizingObject 属性<xref:System.Diagnostics.Process>设置为的实例`Form1`: [!code-cpp [Process_SynchronizingObject&#2;](~/add/codesnippet/cpp/p-system.diagnostics.pro_35_1.cpp)][!code-cs[Process_SynchronizingObject&#2;](~/add/codesnippet/csharp/p-system.diagnostics.pro_35_1.cs)][!code-vb[Process_SynchronizingObject&#2;](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_35_1.vb) ]通常情况下，设置此属性时该组件放置在控件或窗体中，因为这些组件绑定到特定线程。    </xref:System.Diagnostics.Process> </xref:System.Windows.Forms.Form> </xref:System.Diagnostics.Process>"
  example:
  - >-
    [!code-vb[Process_SynchronizingObject#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_35_2.vb)]
     [!code-cpp[Process_SynchronizingObject#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_35_2.cpp)]
     [!code-cs[Process_SynchronizingObject#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_35_2.cs)]
  syntax:
    content: public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }
    return:
      type: System.ComponentModel.ISynchronizeInvoke
      description: "<xref href=&quot;System.ComponentModel.ISynchronizeInvoke&quot;> </xref>用于封送的结果发出的事件处理程序调用<xref href=&quot;System.Diagnostics.Process.Exited&quot;></xref>进程上的事件。"
  overload: System.Diagnostics.Process.SynchronizingObject*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.Threads
  id: Threads
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Threads
  nameWithType: Process.Threads
  fullName: System.Diagnostics.Process.Threads
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取在关联进程中运行的线程的集。"
  remarks: "线程在进程中执行代码。 每个进程开始使用单线程，其主线程。 任何线程可以创建其他线程。 在一个进程内的线程都共享进程的地址空间。       使用<xref:System.Diagnostics.ProcessThread>可获取与当前进程关联的所有线程。</xref:System.Diagnostics.ProcessThread> 主线程不一定是位于索引零数组中。"
  syntax:
    content: public System.Diagnostics.ProcessThreadCollection Threads { get; }
    return:
      type: System.Diagnostics.ProcessThreadCollection
      description: "类型的数组<xref href=&quot;System.Diagnostics.ProcessThread&quot;></xref>表示操作系统线程当前在关联进程中运行。"
  overload: System.Diagnostics.Process.Threads*
  exceptions:
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "进程不具有<xref:System.Diagnostics.Process.Id*>，与关联的进程或<xref href=&quot;System.Diagnostics.Process&quot;></xref>实例。</xref:System.Diagnostics.Process.Id*>       -或者-关联的进程已退出。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me);设置&lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;到<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>以 Windows 98 和 Windows me 上访问此属性"
  platform:
  - net462
- uid: System.Diagnostics.Process.ToString
  id: ToString
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ToString()
  nameWithType: Process.ToString()
  fullName: System.Diagnostics.Process.ToString()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "进程的名称格式化为字符串，如果适用与父组件类型，并组合。"
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_12_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_12_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_12_1.vb)]"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "<> </> *1>，与基组件的组合<> *1> 返回值。"
  overload: System.Diagnostics.Process.ToString*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "在 Windows 98 上不支持 ToString。"
  platform:
  - net462
- uid: System.Diagnostics.Process.TotalProcessorTime
  id: TotalProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: TotalProcessorTime
  nameWithType: Process.TotalProcessorTime
  fullName: System.Diagnostics.Process.TotalProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取此进程的总处理器时间。"
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_15_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_15_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_15_1.vb)]"
  syntax:
    content: public TimeSpan TotalProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "A <xref:System.TimeSpan>，该值指示关联的进程使用 CPU，所用的时间量。</xref:System.TimeSpan> 此值是的总和<> *1> 和<> *1>。"
  overload: System.Diagnostics.Process.TotalProcessorTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "你尝试访问在远程计算机运行的进程的 TotalProcessorTime 属性。 此属性是仅适用于本地计算机运行的进程。"
  platform:
  - net462
- uid: System.Diagnostics.Process.UserProcessorTime
  id: UserProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: UserProcessorTime
  nameWithType: Process.UserProcessorTime
  fullName: System.Diagnostics.Process.UserProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取此进程的用户处理器时间。"
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_21_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_21_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_21_1.vb)]"
  syntax:
    content: public TimeSpan UserProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "A <xref:System.TimeSpan>，该值指示关联的进程的过程 （而不是在操作系统内核中） 的应用程序部分内的运行代码所用的时间量。</xref:System.TimeSpan>"
  overload: System.Diagnostics.Process.UserProcessorTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "你尝试访问在远程计算机运行的进程的 UserProcessorTime 属性。 此属性是仅适用于本地计算机运行的进程。"
  platform:
  - net462
- uid: System.Diagnostics.Process.VirtualMemorySize
  id: VirtualMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: VirtualMemorySize
  nameWithType: Process.VirtualMemorySize
  fullName: System.Diagnostics.Process.VirtualMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取用字节表示的进程的虚拟内存大小。"
  syntax:
    content: public int VirtualMemorySize { get; }
    return:
      type: System.Int32
      description: "虚拟内存，以字节为单位，关联的进程请求的量。"
  overload: System.Diagnostics.Process.VirtualMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。"
  platform:
  - net462
- uid: System.Diagnostics.Process.VirtualMemorySize64
  id: VirtualMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: VirtualMemorySize64
  nameWithType: Process.VirtualMemorySize64
  fullName: System.Diagnostics.Process.VirtualMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取用字节表示，为关联进程分配的虚拟内存量。"
  remarks: "返回此属性的值表示使用的过程中，以字节为单位的虚拟内存的当前大小。 操作系统将映射到页加载在物理内存中，或存储在磁盘上的虚拟内存分页文件的页面的每个进程的虚拟地址空间。       此属性可以用于监视与 32 位处理器或 64 位处理器的计算机上的内存使用情况。 属性值等于**虚拟字节**进程的性能计数器。"
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_13_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_13_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_13_1.vb)]"
  syntax:
    content: public long VirtualMemorySize64 { get; }
    return:
      type: System.Int64
      description: "虚拟内存，以字节为单位，为关联进程分配的量。"
  overload: System.Diagnostics.Process.VirtualMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。"
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForExit
  id: WaitForExit
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForExit()
  nameWithType: Process.WaitForExit()
  fullName: System.Diagnostics.Process.WaitForExit()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "指示<xref href=&quot;System.Diagnostics.Process&quot;></xref>组件无限期地等待关联进程退出。"
  remarks: "WaitForExit 使当前线程等待，直到在关联的进程终止。  过程调用的所有其他方法后，应调用它。 若要避免妨碍当前线程，请使用<xref:System.Diagnostics.Process.Exited>事件。</xref:System.Diagnostics.Process.Exited>       此方法指示<xref:System.Diagnostics.Process>组件等待无限进程和事件处理程序退出的时间量。</xref:System.Diagnostics.Process> 这会导致应用程序停止响应。 例如，如果你调用<xref:System.Diagnostics.Process.CloseMainWindow%2A>对于具有用户界面的进程，对操作系统的请求，终止关联的进程可能不会处理如果进程被编写为从来不用输入其消息循环。</xref:System.Diagnostics.Process.CloseMainWindow%2A>      1> [!NOTE] 1> 中[!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)]和早期版本中，WaitForExit 重载会等待<xref:System.Int32.MaxValue>毫秒 （大约 24 天），并不是无限期。</xref:System.Int32.MaxValue> 此外，以前的版本不会等待事件处理程序，以退出如果完整<xref:System.Int32.MaxValue>时间已达到。</xref:System.Int32.MaxValue>       此重载可确保所有处理均已都完成，包括的重定向的标准输出的异步事件处理。 在调用后，应使用此重载<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>重载时标准输出已被重定向到异步事件处理程序。</xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>       当关联的进程退出 （即，当它关闭的情况下通过操作系统通过正常或不正常终止） 时，系统存储过程的管理信息，并返回到调用一样 WaitForExit 的组件。 <xref:System.Diagnostics.Process>组件然后可以访问的信息，其中包括<xref:System.Diagnostics.Process.ExitTime%2A>，通过使用<xref:System.Diagnostics.Process.Handle%2A>已退出进程。</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process>       关联的进程已退出，因为<xref:System.Diagnostics.Process.Handle%2A>组件属性不再指向现有进程资源。</xref:System.Diagnostics.Process.Handle%2A> 相反，句柄仅用于访问有关的进程资源的操作系统的信息。 系统是不通过已发布的已退出进程的句柄感知<xref:System.Diagnostics.Process>组件，因此它会保留<xref:System.Diagnostics.Process.ExitTime%2A>和<xref:System.Diagnostics.Process.Handle%2A>之前的内存中的信息<xref:System.Diagnostics.Process>组件明确释放这些资源。</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process> 为此，任何时候要寻求<xref:System.Diagnostics.Process.Start%2A>的<xref:System.Diagnostics.Process>实例，调用<xref:System.Diagnostics.Process.Close%2A>关联的进程终止时，并且你不再需要它。 有关的任何管理信息</xref:System.Diagnostics.Process.Close%2A></xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.Start%2A> <xref:System.Diagnostics.Process.Close%2A>释放分配给已退出的进程的内存。</xref:System.Diagnostics.Process.Close%2A>"
  example:
  - See the Remarks section of the <xref:System.Diagnostics.Process.StandardError%2A> property reference page.
  syntax:
    content: public void WaitForExit ();
    parameters: []
  overload: System.Diagnostics.Process.WaitForExit*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "无法访问等待设置。"
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "没有进程<> *1> 已设置和<> *1> 从中<xref:System.Diagnostics.Process.Id*>属性可以确定不存在。</xref:System.Diagnostics.Process.Id*>       -或-没有与此关联的进程<xref href=&quot;System.Diagnostics.Process&quot;></xref>对象。       -或者-你尝试在远程计算机上运行的进程调用 WaitForExit。 此方法是仅适用于本地计算机运行的进程。"
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForExit(System.Int32)
  id: WaitForExit(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForExit(Int32)
  nameWithType: Process.WaitForExit(Int32)
  fullName: System.Diagnostics.Process.WaitForExit(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "指示<xref href=&quot;System.Diagnostics.Process&quot;></xref>组件等待指定的关联进程退出的毫秒数。"
  remarks: "WaitForExit 使当前线程等待，直到在关联的进程终止。 过程调用的所有其他方法后，应调用它。 若要避免妨碍当前线程，请使用<xref:System.Diagnostics.Process.Exited>事件。</xref:System.Diagnostics.Process.Exited>       此方法指示<xref:System.Diagnostics.Process>组件等待有限进程退出的时间量。</xref:System.Diagnostics.Process> 如果终止该请求被拒绝，因为，关联的进程不退出的时间间隔结束`false`被返回到调用的过程。 您可以指定一个负号 (<xref:System.Threading.Timeout.Infinite>) 为`milliseconds`，并且 WaitForExit 的行为相同<xref:System.Diagnostics.Process.WaitForExit>重载。</xref:System.Diagnostics.Process.WaitForExit> </xref:System.Threading.Timeout.Infinite> 如果向方法传递 0 （零），它将返回`true`仅当已经退出进程; 否则，它立即返回`false`。      1> [!NOTE] 1> 中[!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)]和早期版本中，如果`milliseconds`是-1，重载会等待 WaitForExit<xref:System.Int32.MaxValue>毫秒 （大约 24 天），并不是无限期。</xref:System.Int32.MaxValue>       当已重标准输出定向到异步事件处理程序中时，有可能，输出处理还未完成此方法返回时。 若要确保已完成异步事件处理，调用<xref:System.Diagnostics.Process.WaitForExit>接收后不接受任何参数的重载`true`从此重载。</xref:System.Diagnostics.Process.WaitForExit> 为了帮助确保<xref:System.Diagnostics.Process.Exited>在 Windows 窗体应用程序中正确处理事件，请将设置<xref:System.Diagnostics.Process.SynchronizingObject%2A>属性。</xref:System.Diagnostics.Process.SynchronizingObject%2A> </xref:System.Diagnostics.Process.Exited>       关联的进程的退出时 （正通过正常或异常终止操作系统关闭） 时，系统存储过程的管理信息并返回到调用一样 WaitForExit 的组件。 <xref:System.Diagnostics.Process>组件然后可以访问的信息，其中包括<xref:System.Diagnostics.Process.ExitTime%2A>，通过使用<xref:System.Diagnostics.Process.Handle%2A>已退出进程。</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process>       关联的进程已退出，因为<xref:System.Diagnostics.Process.Handle%2A>组件属性不再指向现有进程资源。</xref:System.Diagnostics.Process.Handle%2A> 相反，句柄仅用于访问有关的进程资源的操作系统的信息。 系统是不通过已发布的已退出进程的句柄感知<xref:System.Diagnostics.Process>组件，因此它会保留<xref:System.Diagnostics.Process.ExitTime%2A>和<xref:System.Diagnostics.Process.Handle%2A>之前的内存中的信息<xref:System.Diagnostics.Process>组件明确释放这些资源。</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process> 为此，任何时候要寻求<xref:System.Diagnostics.Process.Start%2A>的<xref:System.Diagnostics.Process>实例，调用<xref:System.Diagnostics.Process.Close%2A>关联的进程终止时，并且你不再需要它。 有关的任何管理信息</xref:System.Diagnostics.Process.Close%2A></xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.Start%2A> <xref:System.Diagnostics.Process.Close%2A>释放分配给已退出的进程的内存。</xref:System.Diagnostics.Process.Close%2A>"
  example:
  - See the code example for the <xref:System.Diagnostics.Process.ExitCode%2A> property.
  syntax:
    content: public bool WaitForExit (int milliseconds);
    parameters:
    - id: milliseconds
      type: System.Int32
      description: "时间 （毫秒），等待关联进程退出的量。 最大为对于操作系统而言表示无限大的 32 位整数的最大可能值。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果关联的进程已退出;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Diagnostics.Process.WaitForExit*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "无法访问等待设置。"
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "没有进程<> *1> 已设置和<> *1> 从中<xref:System.Diagnostics.Process.Id*>属性可以确定不存在。</xref:System.Diagnostics.Process.Id*>       -或-没有与此关联的进程<xref href=&quot;System.Diagnostics.Process&quot;></xref>对象。       -或者-你尝试在远程计算机上运行的进程调用 WaitForExit。 此方法是仅适用于本地计算机运行的进程。"
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForInputIdle
  id: WaitForInputIdle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForInputIdle()
  nameWithType: Process.WaitForInputIdle()
  fullName: System.Diagnostics.Process.WaitForInputIdle()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "导致<xref href=&quot;System.Diagnostics.Process&quot;></xref>组件无限期地等待关联进程进入空闲状态。 此重载仅适用于具有用户界面并因此，消息循环的进程。"
  remarks: "使用 WaitForInputIdle 强制应用程序消息循环已返回到空闲状态等待处理。 用户界面的进程执行时，其消息循环将执行每次操作系统的 Windows 消息发送到进程。 然后，该进程返回到消息循环。 说进程时它正在等待消息的消息循环内处于空闲状态。 此状态非常有用，例如，当你的应用程序需要等待启动的进程以完成创建其主窗口之前与该窗口的应用程序通信时。       如果进程不具有消息循环，WaitForInputIdle 引发<xref:System.InvalidOperationException>.</xref:System.InvalidOperationException>       WaitForInputIdle 重载指示<xref:System.Diagnostics.Process>组件无限期地等待进程变为空闲状态消息循环中。</xref:System.Diagnostics.Process> 此指令可能会导致应用程序停止响应。 例如，如果过程始终写入其消息循环立即退出，如下所示的代码片段`while(true)`。"
  syntax:
    content: public bool WaitForInputIdle ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果关联的进程已经达到空闲状态。"
  overload: System.Diagnostics.Process.WaitForInputIdle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "进程不具有图形界面。       -或者-出现未知的错误。 进程无法进入空闲状态。       -或者-已经退出进程。       -或-没有进程是否与此相关联<xref href=&quot;System.Diagnostics.Process&quot;></xref>对象。"
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForInputIdle(System.Int32)
  id: WaitForInputIdle(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForInputIdle(Int32)
  nameWithType: Process.WaitForInputIdle(Int32)
  fullName: System.Diagnostics.Process.WaitForInputIdle(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "导致<xref href=&quot;System.Diagnostics.Process&quot;></xref>组件等待指定的关联进程进入空闲状态的毫秒数。 此重载仅适用于具有用户界面并因此，消息循环的进程。"
  remarks: "使用 WaitForInputIdle 强制应用程序消息循环已返回到空闲状态等待处理。 用户界面的进程执行时，其消息循环将执行每次操作系统的 Windows 消息发送到进程。 然后，该进程返回到消息循环。 说进程时它正在等待消息的消息循环内处于空闲状态。 此状态非常有用，例如，当你的应用程序需要等待启动的进程以完成创建其主窗口之前与该窗口的应用程序通信时。       如果进程不具有消息循环，WaitForInputIdle 引发<xref:System.InvalidOperationException>.</xref:System.InvalidOperationException>       WaitForInputIdle 重载指示<xref:System.Diagnostics.Process>组件等待有限的进程变为空闲状态消息循环中的时间量。</xref:System.Diagnostics.Process> 如果关联的进程不具有进入空闲状态的时间间隔结束循环仍在处理消息，因为`false`被返回到调用的过程。       有关处理事件的详细信息，请参阅[事件](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public bool WaitForInputIdle (int milliseconds);
    parameters:
    - id: milliseconds
      type: System.Int32
      description: "值为 1 到<xref:System.Int32>，它指定的时间，以毫秒为单位，等待关联进程变为空闲状态。</xref:System.Int32> 0 值指定立即返回，而-1 值则指定无限期等待。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果关联的进程已经达到空闲状态;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Diagnostics.Process.WaitForInputIdle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "进程不具有图形界面。       -或者-出现未知的错误。 进程无法进入空闲状态。       -或者-已经退出进程。       -或-没有进程是否与此相关联<xref href=&quot;System.Diagnostics.Process&quot;></xref>对象。"
  platform:
  - net462
- uid: System.Diagnostics.Process.WorkingSet
  id: WorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WorkingSet
  nameWithType: Process.WorkingSet
  fullName: System.Diagnostics.Process.WorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取关联的进程的物理内存使用量，以字节为单位。"
  remarks: "返回此属性的值表示工作集内存使用的过程中，以字节为单位的当前大小。 进程工作集是物理 RAM 内存中的当前可见的进程的内存页的集合。 这些页面为常驻性并且可用于应用程序使用而不会触发页面错误。       工作集包括共享和私有数据。 共享的数据包括那些包含该进程执行，包括进程模块和系统库的所有说明的页。"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process' exit code.  \n  \n [!code-vb[process_sample#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_40_1.vb)]\n [!code-cpp[process_sample#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_40_1.cpp)]\n [!code-cs[process_sample#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_40_1.cs)]"
  syntax:
    content: public int WorkingSet { get; }
    return:
      type: System.Int32
      description: "关联的进程正在使用的物理内存总量，以字节为单位。"
  overload: System.Diagnostics.Process.WorkingSet*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。"
  platform:
  - net462
- uid: System.Diagnostics.Process.WorkingSet64
  id: WorkingSet64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WorkingSet64
  nameWithType: Process.WorkingSet64
  fullName: System.Diagnostics.Process.WorkingSet64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取用字节表示，为关联进程分配的物理内存量。"
  remarks: "返回此属性的值表示工作集内存使用的过程中，以字节为单位的当前大小。 进程工作集是物理 RAM 内存中的当前可见的进程的内存页的集合。 这些页面为常驻性并且可用于应用程序使用而不会触发页面错误。       工作集包括共享和私有数据。 共享的数据包括那些包含该进程执行，包括进程模块和系统库中的说明的所有说明的页。       此属性可以用于监视与 32 位处理器或 64 位处理器的计算机上的内存使用情况。 属性值等于**工作集大小**进程的性能计数器。"
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_32_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_32_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_32_1.vb)]"
  syntax:
    content: public long WorkingSet64 { get; }
    return:
      type: System.Int64
      description: "以字节为单位，为关联进程分配的物理内存量。"
  overload: System.Diagnostics.Process.WorkingSet64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。"
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ComponentModel.Win32Exception
  parent: System.ComponentModel
  isExternal: false
  name: Win32Exception
  nameWithType: Win32Exception
  fullName: System.ComponentModel.Win32Exception
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.Diagnostics.Process.#ctor
  parent: System.Diagnostics.Process
  isExternal: false
  name: Process()
  nameWithType: Process.Process()
  fullName: System.Diagnostics.Process.Process()
- uid: System.Diagnostics.Process.BasePriority
  parent: System.Diagnostics.Process
  isExternal: false
  name: BasePriority
  nameWithType: Process.BasePriority
  fullName: System.Diagnostics.Process.BasePriority
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Diagnostics.Process.BeginErrorReadLine
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginErrorReadLine()
  nameWithType: Process.BeginErrorReadLine()
  fullName: System.Diagnostics.Process.BeginErrorReadLine()
- uid: System.Diagnostics.Process.BeginOutputReadLine
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginOutputReadLine()
  nameWithType: Process.BeginOutputReadLine()
  fullName: System.Diagnostics.Process.BeginOutputReadLine()
- uid: System.Diagnostics.Process.CancelErrorRead
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelErrorRead()
  nameWithType: Process.CancelErrorRead()
  fullName: System.Diagnostics.Process.CancelErrorRead()
- uid: System.Diagnostics.Process.CancelOutputRead
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelOutputRead()
  nameWithType: Process.CancelOutputRead()
  fullName: System.Diagnostics.Process.CancelOutputRead()
- uid: System.Diagnostics.Process.Close
  parent: System.Diagnostics.Process
  isExternal: false
  name: Close()
  nameWithType: Process.Close()
  fullName: System.Diagnostics.Process.Close()
- uid: System.Diagnostics.Process.CloseMainWindow
  parent: System.Diagnostics.Process
  isExternal: false
  name: CloseMainWindow()
  nameWithType: Process.CloseMainWindow()
  fullName: System.Diagnostics.Process.CloseMainWindow()
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Diagnostics.Process.Dispose(System.Boolean)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: Process.Dispose(Boolean)
  fullName: System.Diagnostics.Process.Dispose(Boolean)
- uid: System.Diagnostics.Process.EnableRaisingEvents
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: Process.EnableRaisingEvents
  fullName: System.Diagnostics.Process.EnableRaisingEvents
- uid: System.Diagnostics.Process.EnterDebugMode
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnterDebugMode()
  nameWithType: Process.EnterDebugMode()
  fullName: System.Diagnostics.Process.EnterDebugMode()
- uid: System.Diagnostics.Process.ErrorDataReceived
  parent: System.Diagnostics.Process
  isExternal: false
  name: ErrorDataReceived
  nameWithType: Process.ErrorDataReceived
  fullName: System.Diagnostics.Process.ErrorDataReceived
- uid: System.Diagnostics.DataReceivedEventHandler
  parent: System.Diagnostics
  isExternal: false
  name: DataReceivedEventHandler
  nameWithType: DataReceivedEventHandler
  fullName: System.Diagnostics.DataReceivedEventHandler
- uid: System.Diagnostics.Process.ExitCode
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitCode
  nameWithType: Process.ExitCode
  fullName: System.Diagnostics.Process.ExitCode
- uid: System.Diagnostics.Process.Exited
  parent: System.Diagnostics.Process
  isExternal: false
  name: Exited
  nameWithType: Process.Exited
  fullName: System.Diagnostics.Process.Exited
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Diagnostics.Process.ExitTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitTime
  nameWithType: Process.ExitTime
  fullName: System.Diagnostics.Process.ExitTime
- uid: System.DateTime
  parent: System
  isExternal: true
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: System.Diagnostics.Process.GetCurrentProcess
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetCurrentProcess()
  nameWithType: Process.GetCurrentProcess()
  fullName: System.Diagnostics.Process.GetCurrentProcess()
- uid: System.Diagnostics.Process
  parent: System.Diagnostics
  isExternal: false
  name: Process
  nameWithType: Process
  fullName: System.Diagnostics.Process
- uid: System.Diagnostics.Process.GetProcessById(System.Int32)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessById(Int32)
  nameWithType: Process.GetProcessById(Int32)
  fullName: System.Diagnostics.Process.GetProcessById(Int32)
- uid: System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessById(Int32,String)
  nameWithType: Process.GetProcessById(Int32,String)
  fullName: System.Diagnostics.Process.GetProcessById(Int32,String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Diagnostics.Process.GetProcesses
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcesses()
  nameWithType: Process.GetProcesses()
  fullName: System.Diagnostics.Process.GetProcesses()
- uid: System.Diagnostics.Process[]
  parent: System.Diagnostics
  isExternal: false
  name: Process
  nameWithType: Process
  fullName: System.Diagnostics.Process[]
  spec.csharp:
  - uid: System.Diagnostics.Process
    name: Process
    nameWithType: Process
    fullName: Process[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.Process.GetProcesses(System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcesses(String)
  nameWithType: Process.GetProcesses(String)
  fullName: System.Diagnostics.Process.GetProcesses(String)
- uid: System.Diagnostics.Process.GetProcessesByName(System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessesByName(String)
  nameWithType: Process.GetProcessesByName(String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String)
- uid: System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessesByName(String,String)
  nameWithType: Process.GetProcessesByName(String,String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String,String)
- uid: System.Diagnostics.Process.Handle
  parent: System.Diagnostics.Process
  isExternal: false
  name: Handle
  nameWithType: Process.Handle
  fullName: System.Diagnostics.Process.Handle
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Diagnostics.Process.HandleCount
  parent: System.Diagnostics.Process
  isExternal: false
  name: HandleCount
  nameWithType: Process.HandleCount
  fullName: System.Diagnostics.Process.HandleCount
- uid: System.Diagnostics.Process.HasExited
  parent: System.Diagnostics.Process
  isExternal: false
  name: HasExited
  nameWithType: Process.HasExited
  fullName: System.Diagnostics.Process.HasExited
- uid: System.Diagnostics.Process.Id
  parent: System.Diagnostics.Process
  isExternal: false
  name: Id
  nameWithType: Process.Id
  fullName: System.Diagnostics.Process.Id
- uid: System.Diagnostics.Process.Kill
  parent: System.Diagnostics.Process
  isExternal: false
  name: Kill()
  nameWithType: Process.Kill()
  fullName: System.Diagnostics.Process.Kill()
- uid: System.Diagnostics.Process.LeaveDebugMode
  parent: System.Diagnostics.Process
  isExternal: false
  name: LeaveDebugMode()
  nameWithType: Process.LeaveDebugMode()
  fullName: System.Diagnostics.Process.LeaveDebugMode()
- uid: System.Diagnostics.Process.MachineName
  parent: System.Diagnostics.Process
  isExternal: false
  name: MachineName
  nameWithType: Process.MachineName
  fullName: System.Diagnostics.Process.MachineName
- uid: System.Diagnostics.Process.MainModule
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainModule
  nameWithType: Process.MainModule
  fullName: System.Diagnostics.Process.MainModule
- uid: System.Diagnostics.ProcessModule
  parent: System.Diagnostics
  isExternal: false
  name: ProcessModule
  nameWithType: ProcessModule
  fullName: System.Diagnostics.ProcessModule
- uid: System.Diagnostics.Process.MainWindowHandle
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowHandle
  nameWithType: Process.MainWindowHandle
  fullName: System.Diagnostics.Process.MainWindowHandle
- uid: System.Diagnostics.Process.MainWindowTitle
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowTitle
  nameWithType: Process.MainWindowTitle
  fullName: System.Diagnostics.Process.MainWindowTitle
- uid: System.Diagnostics.Process.MaxWorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: MaxWorkingSet
  nameWithType: Process.MaxWorkingSet
  fullName: System.Diagnostics.Process.MaxWorkingSet
- uid: System.Diagnostics.Process.MinWorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: MinWorkingSet
  nameWithType: Process.MinWorkingSet
  fullName: System.Diagnostics.Process.MinWorkingSet
- uid: System.Diagnostics.Process.Modules
  parent: System.Diagnostics.Process
  isExternal: false
  name: Modules
  nameWithType: Process.Modules
  fullName: System.Diagnostics.Process.Modules
- uid: System.Diagnostics.ProcessModuleCollection
  parent: System.Diagnostics
  isExternal: false
  name: ProcessModuleCollection
  nameWithType: ProcessModuleCollection
  fullName: System.Diagnostics.ProcessModuleCollection
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize
  nameWithType: Process.NonpagedSystemMemorySize
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize64
  nameWithType: Process.NonpagedSystemMemorySize64
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize64
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Diagnostics.Process.OnExited
  parent: System.Diagnostics.Process
  isExternal: false
  name: OnExited()
  nameWithType: Process.OnExited()
  fullName: System.Diagnostics.Process.OnExited()
- uid: System.Diagnostics.Process.OutputDataReceived
  parent: System.Diagnostics.Process
  isExternal: false
  name: OutputDataReceived
  nameWithType: Process.OutputDataReceived
  fullName: System.Diagnostics.Process.OutputDataReceived
- uid: System.Diagnostics.Process.PagedMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize
  nameWithType: Process.PagedMemorySize
  fullName: System.Diagnostics.Process.PagedMemorySize
- uid: System.Diagnostics.Process.PagedMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize64
  nameWithType: Process.PagedMemorySize64
  fullName: System.Diagnostics.Process.PagedMemorySize64
- uid: System.Diagnostics.Process.PagedSystemMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize
  nameWithType: Process.PagedSystemMemorySize
  fullName: System.Diagnostics.Process.PagedSystemMemorySize
- uid: System.Diagnostics.Process.PagedSystemMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize64
  nameWithType: Process.PagedSystemMemorySize64
  fullName: System.Diagnostics.Process.PagedSystemMemorySize64
- uid: System.Diagnostics.Process.PeakPagedMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize
  nameWithType: Process.PeakPagedMemorySize
  fullName: System.Diagnostics.Process.PeakPagedMemorySize
- uid: System.Diagnostics.Process.PeakPagedMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize64
  nameWithType: Process.PeakPagedMemorySize64
  fullName: System.Diagnostics.Process.PeakPagedMemorySize64
- uid: System.Diagnostics.Process.PeakVirtualMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize
  nameWithType: Process.PeakVirtualMemorySize
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize
- uid: System.Diagnostics.Process.PeakVirtualMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize64
  nameWithType: Process.PeakVirtualMemorySize64
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize64
- uid: System.Diagnostics.Process.PeakWorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet
  nameWithType: Process.PeakWorkingSet
  fullName: System.Diagnostics.Process.PeakWorkingSet
- uid: System.Diagnostics.Process.PeakWorkingSet64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet64
  nameWithType: Process.PeakWorkingSet64
  fullName: System.Diagnostics.Process.PeakWorkingSet64
- uid: System.Diagnostics.Process.PriorityBoostEnabled
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityBoostEnabled
  nameWithType: Process.PriorityBoostEnabled
  fullName: System.Diagnostics.Process.PriorityBoostEnabled
- uid: System.Diagnostics.Process.PriorityClass
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityClass
  nameWithType: Process.PriorityClass
  fullName: System.Diagnostics.Process.PriorityClass
- uid: System.Diagnostics.ProcessPriorityClass
  parent: System.Diagnostics
  isExternal: false
  name: ProcessPriorityClass
  nameWithType: ProcessPriorityClass
  fullName: System.Diagnostics.ProcessPriorityClass
- uid: System.Diagnostics.Process.PrivateMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize
  nameWithType: Process.PrivateMemorySize
  fullName: System.Diagnostics.Process.PrivateMemorySize
- uid: System.Diagnostics.Process.PrivateMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize64
  nameWithType: Process.PrivateMemorySize64
  fullName: System.Diagnostics.Process.PrivateMemorySize64
- uid: System.Diagnostics.Process.PrivilegedProcessorTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivilegedProcessorTime
  nameWithType: Process.PrivilegedProcessorTime
  fullName: System.Diagnostics.Process.PrivilegedProcessorTime
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Diagnostics.Process.ProcessName
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessName
  nameWithType: Process.ProcessName
  fullName: System.Diagnostics.Process.ProcessName
- uid: System.Diagnostics.Process.ProcessorAffinity
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessorAffinity
  nameWithType: Process.ProcessorAffinity
  fullName: System.Diagnostics.Process.ProcessorAffinity
- uid: System.Diagnostics.Process.Refresh
  parent: System.Diagnostics.Process
  isExternal: false
  name: Refresh()
  nameWithType: Process.Refresh()
  fullName: System.Diagnostics.Process.Refresh()
- uid: System.Diagnostics.Process.Responding
  parent: System.Diagnostics.Process
  isExternal: false
  name: Responding
  nameWithType: Process.Responding
  fullName: System.Diagnostics.Process.Responding
- uid: System.Diagnostics.Process.SafeHandle
  parent: System.Diagnostics.Process
  isExternal: false
  name: SafeHandle
  nameWithType: Process.SafeHandle
  fullName: System.Diagnostics.Process.SafeHandle
- uid: Microsoft.Win32.SafeHandles.SafeProcessHandle
  parent: Microsoft.Win32.SafeHandles
  isExternal: false
  name: SafeProcessHandle
  nameWithType: SafeProcessHandle
  fullName: Microsoft.Win32.SafeHandles.SafeProcessHandle
- uid: System.Diagnostics.Process.SessionId
  parent: System.Diagnostics.Process
  isExternal: false
  name: SessionId
  nameWithType: Process.SessionId
  fullName: System.Diagnostics.Process.SessionId
- uid: System.Diagnostics.Process.StandardError
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardError
  nameWithType: Process.StandardError
  fullName: System.Diagnostics.Process.StandardError
- uid: System.IO.StreamReader
  parent: System.IO
  isExternal: true
  name: StreamReader
  nameWithType: StreamReader
  fullName: System.IO.StreamReader
- uid: System.Diagnostics.Process.StandardInput
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardInput
  nameWithType: Process.StandardInput
  fullName: System.Diagnostics.Process.StandardInput
- uid: System.IO.StreamWriter
  parent: System.IO
  isExternal: true
  name: StreamWriter
  nameWithType: StreamWriter
  fullName: System.IO.StreamWriter
- uid: System.Diagnostics.Process.StandardOutput
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardOutput
  nameWithType: Process.StandardOutput
  fullName: System.Diagnostics.Process.StandardOutput
- uid: System.Diagnostics.Process.Start
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start()
  nameWithType: Process.Start()
  fullName: System.Diagnostics.Process.Start()
- uid: System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(ProcessStartInfo)
  nameWithType: Process.Start(ProcessStartInfo)
  fullName: System.Diagnostics.Process.Start(ProcessStartInfo)
- uid: System.Diagnostics.ProcessStartInfo
  parent: System.Diagnostics
  isExternal: false
  name: ProcessStartInfo
  nameWithType: ProcessStartInfo
  fullName: System.Diagnostics.ProcessStartInfo
- uid: System.Diagnostics.Process.Start(System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String)
  nameWithType: Process.Start(String)
  fullName: System.Diagnostics.Process.Start(String)
- uid: System.Diagnostics.Process.Start(System.String,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String,String)
  nameWithType: Process.Start(String,String)
  fullName: System.Diagnostics.Process.Start(String,String)
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String,String,SecureString,String)
  nameWithType: Process.Start(String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,SecureString,String)
- uid: System.Security.SecureString
  parent: System.Security
  isExternal: false
  name: SecureString
  nameWithType: SecureString
  fullName: System.Security.SecureString
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String,String,String,SecureString,String)
  nameWithType: Process.Start(String,String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,String,SecureString,String)
- uid: System.Diagnostics.Process.StartInfo
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartInfo
  nameWithType: Process.StartInfo
  fullName: System.Diagnostics.Process.StartInfo
- uid: System.Diagnostics.Process.StartTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartTime
  nameWithType: Process.StartTime
  fullName: System.Diagnostics.Process.StartTime
- uid: System.Diagnostics.Process.SynchronizingObject
  parent: System.Diagnostics.Process
  isExternal: false
  name: SynchronizingObject
  nameWithType: Process.SynchronizingObject
  fullName: System.Diagnostics.Process.SynchronizingObject
- uid: System.ComponentModel.ISynchronizeInvoke
  parent: System.ComponentModel
  isExternal: false
  name: ISynchronizeInvoke
  nameWithType: ISynchronizeInvoke
  fullName: System.ComponentModel.ISynchronizeInvoke
- uid: System.Diagnostics.Process.Threads
  parent: System.Diagnostics.Process
  isExternal: false
  name: Threads
  nameWithType: Process.Threads
  fullName: System.Diagnostics.Process.Threads
- uid: System.Diagnostics.ProcessThreadCollection
  parent: System.Diagnostics
  isExternal: false
  name: ProcessThreadCollection
  nameWithType: ProcessThreadCollection
  fullName: System.Diagnostics.ProcessThreadCollection
- uid: System.Diagnostics.Process.ToString
  parent: System.Diagnostics.Process
  isExternal: false
  name: ToString()
  nameWithType: Process.ToString()
  fullName: System.Diagnostics.Process.ToString()
- uid: System.Diagnostics.Process.TotalProcessorTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: TotalProcessorTime
  nameWithType: Process.TotalProcessorTime
  fullName: System.Diagnostics.Process.TotalProcessorTime
- uid: System.Diagnostics.Process.UserProcessorTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: UserProcessorTime
  nameWithType: Process.UserProcessorTime
  fullName: System.Diagnostics.Process.UserProcessorTime
- uid: System.Diagnostics.Process.VirtualMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize
  nameWithType: Process.VirtualMemorySize
  fullName: System.Diagnostics.Process.VirtualMemorySize
- uid: System.Diagnostics.Process.VirtualMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize64
  nameWithType: Process.VirtualMemorySize64
  fullName: System.Diagnostics.Process.VirtualMemorySize64
- uid: System.Diagnostics.Process.WaitForExit
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForExit()
  nameWithType: Process.WaitForExit()
  fullName: System.Diagnostics.Process.WaitForExit()
- uid: System.Diagnostics.Process.WaitForExit(System.Int32)
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForExit(Int32)
  nameWithType: Process.WaitForExit(Int32)
  fullName: System.Diagnostics.Process.WaitForExit(Int32)
- uid: System.Diagnostics.Process.WaitForInputIdle
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForInputIdle()
  nameWithType: Process.WaitForInputIdle()
  fullName: System.Diagnostics.Process.WaitForInputIdle()
- uid: System.Diagnostics.Process.WaitForInputIdle(System.Int32)
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForInputIdle(Int32)
  nameWithType: Process.WaitForInputIdle(Int32)
  fullName: System.Diagnostics.Process.WaitForInputIdle(Int32)
- uid: System.Diagnostics.Process.WorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet
  nameWithType: Process.WorkingSet
  fullName: System.Diagnostics.Process.WorkingSet
- uid: System.Diagnostics.Process.WorkingSet64
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet64
  nameWithType: Process.WorkingSet64
  fullName: System.Diagnostics.Process.WorkingSet64
- uid: System.Diagnostics.Process.#ctor*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Process
  nameWithType: Process.Process
- uid: System.Diagnostics.Process.BasePriority*
  parent: System.Diagnostics.Process
  isExternal: false
  name: BasePriority
  nameWithType: Process.BasePriority
- uid: System.Diagnostics.Process.BeginErrorReadLine*
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginErrorReadLine
  nameWithType: Process.BeginErrorReadLine
- uid: System.Diagnostics.Process.BeginOutputReadLine*
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginOutputReadLine
  nameWithType: Process.BeginOutputReadLine
- uid: System.Diagnostics.Process.CancelErrorRead*
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelErrorRead
  nameWithType: Process.CancelErrorRead
- uid: System.Diagnostics.Process.CancelOutputRead*
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelOutputRead
  nameWithType: Process.CancelOutputRead
- uid: System.Diagnostics.Process.Close*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Close
  nameWithType: Process.Close
- uid: System.Diagnostics.Process.CloseMainWindow*
  parent: System.Diagnostics.Process
  isExternal: false
  name: CloseMainWindow
  nameWithType: Process.CloseMainWindow
- uid: System.Diagnostics.Process.Dispose*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Dispose
  nameWithType: Process.Dispose
- uid: System.Diagnostics.Process.EnableRaisingEvents*
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: Process.EnableRaisingEvents
- uid: System.Diagnostics.Process.EnterDebugMode*
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnterDebugMode
  nameWithType: Process.EnterDebugMode
- uid: System.Diagnostics.Process.ExitCode*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitCode
  nameWithType: Process.ExitCode
- uid: System.Diagnostics.Process.ExitTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitTime
  nameWithType: Process.ExitTime
- uid: System.Diagnostics.Process.GetCurrentProcess*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetCurrentProcess
  nameWithType: Process.GetCurrentProcess
- uid: System.Diagnostics.Process.GetProcessById*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessById
  nameWithType: Process.GetProcessById
- uid: System.Diagnostics.Process.GetProcesses*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcesses
  nameWithType: Process.GetProcesses
- uid: System.Diagnostics.Process.GetProcessesByName*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessesByName
  nameWithType: Process.GetProcessesByName
- uid: System.Diagnostics.Process.Handle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Handle
  nameWithType: Process.Handle
- uid: System.Diagnostics.Process.HandleCount*
  parent: System.Diagnostics.Process
  isExternal: false
  name: HandleCount
  nameWithType: Process.HandleCount
- uid: System.Diagnostics.Process.HasExited*
  parent: System.Diagnostics.Process
  isExternal: false
  name: HasExited
  nameWithType: Process.HasExited
- uid: System.Diagnostics.Process.Id*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Id
  nameWithType: Process.Id
- uid: System.Diagnostics.Process.Kill*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Kill
  nameWithType: Process.Kill
- uid: System.Diagnostics.Process.LeaveDebugMode*
  parent: System.Diagnostics.Process
  isExternal: false
  name: LeaveDebugMode
  nameWithType: Process.LeaveDebugMode
- uid: System.Diagnostics.Process.MachineName*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MachineName
  nameWithType: Process.MachineName
- uid: System.Diagnostics.Process.MainModule*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainModule
  nameWithType: Process.MainModule
- uid: System.Diagnostics.Process.MainWindowHandle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowHandle
  nameWithType: Process.MainWindowHandle
- uid: System.Diagnostics.Process.MainWindowTitle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowTitle
  nameWithType: Process.MainWindowTitle
- uid: System.Diagnostics.Process.MaxWorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MaxWorkingSet
  nameWithType: Process.MaxWorkingSet
- uid: System.Diagnostics.Process.MinWorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MinWorkingSet
  nameWithType: Process.MinWorkingSet
- uid: System.Diagnostics.Process.Modules*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Modules
  nameWithType: Process.Modules
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize
  nameWithType: Process.NonpagedSystemMemorySize
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize64
  nameWithType: Process.NonpagedSystemMemorySize64
- uid: System.Diagnostics.Process.OnExited*
  parent: System.Diagnostics.Process
  isExternal: false
  name: OnExited
  nameWithType: Process.OnExited
- uid: System.Diagnostics.Process.PagedMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize
  nameWithType: Process.PagedMemorySize
- uid: System.Diagnostics.Process.PagedMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize64
  nameWithType: Process.PagedMemorySize64
- uid: System.Diagnostics.Process.PagedSystemMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize
  nameWithType: Process.PagedSystemMemorySize
- uid: System.Diagnostics.Process.PagedSystemMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize64
  nameWithType: Process.PagedSystemMemorySize64
- uid: System.Diagnostics.Process.PeakPagedMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize
  nameWithType: Process.PeakPagedMemorySize
- uid: System.Diagnostics.Process.PeakPagedMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize64
  nameWithType: Process.PeakPagedMemorySize64
- uid: System.Diagnostics.Process.PeakVirtualMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize
  nameWithType: Process.PeakVirtualMemorySize
- uid: System.Diagnostics.Process.PeakVirtualMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize64
  nameWithType: Process.PeakVirtualMemorySize64
- uid: System.Diagnostics.Process.PeakWorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet
  nameWithType: Process.PeakWorkingSet
- uid: System.Diagnostics.Process.PeakWorkingSet64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet64
  nameWithType: Process.PeakWorkingSet64
- uid: System.Diagnostics.Process.PriorityBoostEnabled*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityBoostEnabled
  nameWithType: Process.PriorityBoostEnabled
- uid: System.Diagnostics.Process.PriorityClass*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityClass
  nameWithType: Process.PriorityClass
- uid: System.Diagnostics.Process.PrivateMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize
  nameWithType: Process.PrivateMemorySize
- uid: System.Diagnostics.Process.PrivateMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize64
  nameWithType: Process.PrivateMemorySize64
- uid: System.Diagnostics.Process.PrivilegedProcessorTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivilegedProcessorTime
  nameWithType: Process.PrivilegedProcessorTime
- uid: System.Diagnostics.Process.ProcessName*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessName
  nameWithType: Process.ProcessName
- uid: System.Diagnostics.Process.ProcessorAffinity*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessorAffinity
  nameWithType: Process.ProcessorAffinity
- uid: System.Diagnostics.Process.Refresh*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Refresh
  nameWithType: Process.Refresh
- uid: System.Diagnostics.Process.Responding*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Responding
  nameWithType: Process.Responding
- uid: System.Diagnostics.Process.SafeHandle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: SafeHandle
  nameWithType: Process.SafeHandle
- uid: System.Diagnostics.Process.SessionId*
  parent: System.Diagnostics.Process
  isExternal: false
  name: SessionId
  nameWithType: Process.SessionId
- uid: System.Diagnostics.Process.StandardError*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardError
  nameWithType: Process.StandardError
- uid: System.Diagnostics.Process.StandardInput*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardInput
  nameWithType: Process.StandardInput
- uid: System.Diagnostics.Process.StandardOutput*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardOutput
  nameWithType: Process.StandardOutput
- uid: System.Diagnostics.Process.Start*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start
  nameWithType: Process.Start
- uid: System.Diagnostics.Process.StartInfo*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartInfo
  nameWithType: Process.StartInfo
- uid: System.Diagnostics.Process.StartTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartTime
  nameWithType: Process.StartTime
- uid: System.Diagnostics.Process.SynchronizingObject*
  parent: System.Diagnostics.Process
  isExternal: false
  name: SynchronizingObject
  nameWithType: Process.SynchronizingObject
- uid: System.Diagnostics.Process.Threads*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Threads
  nameWithType: Process.Threads
- uid: System.Diagnostics.Process.ToString*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ToString
  nameWithType: Process.ToString
- uid: System.Diagnostics.Process.TotalProcessorTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: TotalProcessorTime
  nameWithType: Process.TotalProcessorTime
- uid: System.Diagnostics.Process.UserProcessorTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: UserProcessorTime
  nameWithType: Process.UserProcessorTime
- uid: System.Diagnostics.Process.VirtualMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize
  nameWithType: Process.VirtualMemorySize
- uid: System.Diagnostics.Process.VirtualMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize64
  nameWithType: Process.VirtualMemorySize64
- uid: System.Diagnostics.Process.WaitForExit*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForExit
  nameWithType: Process.WaitForExit
- uid: System.Diagnostics.Process.WaitForInputIdle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForInputIdle
  nameWithType: Process.WaitForInputIdle
- uid: System.Diagnostics.Process.WorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet
  nameWithType: Process.WorkingSet
- uid: System.Diagnostics.Process.WorkingSet64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet64
  nameWithType: Process.WorkingSet64
