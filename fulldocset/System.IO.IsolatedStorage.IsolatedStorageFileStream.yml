### YamlMime:ManagedReference
items:
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream
  id: IsolatedStorageFileStream
  children:
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.IsolatedStorage.IsolatedStorageFile)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.IsolatedStorage.IsolatedStorageFile)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.IO.IsolatedStorage.IsolatedStorageFile)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.IsolatedStorage.IsolatedStorageFile)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.CanRead
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.CanWrite
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose(System.Boolean)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead(System.IAsyncResult)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite(System.IAsyncResult)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush(System.Boolean)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.IsAsync
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.Length
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.Lock(System.Int64,System.Int64)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.Position
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.ReadByte
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.SetLength(System.Int64)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.Unlock(System.Int64,System.Int64)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.WriteByte(System.Byte)
  langs:
  - csharp
  name: IsolatedStorageFileStream
  nameWithType: IsolatedStorageFileStream
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream
  type: Class
  summary: "公开独立存储中的文件。"
  remarks: "此类用于读取、 写入和独立存储中创建文件。       由于此类扩展<xref:System.IO.FileStream>，你可以使用在大多数情况下的 IsolatedStorageFileStream 实例其中<xref:System.IO.FileStream>否则可能会使用，例如，构造<xref:System.IO.StreamReader>或<xref:System.IO.StreamWriter>。</xref:System.IO.StreamWriter> </xref:System.IO.StreamReader> </xref:System.IO.FileStream> </xref:System.IO.FileStream>       此类型实现<xref:System.IDisposable>接口。</xref:System.IDisposable> 完成后使用类型的操作后，你应释放类型直接或间接。 若要直接释放类型，调用其<xref:System.IDisposable.Dispose%2A>中的方法`try` / `catch`块。</xref:System.IDisposable.Dispose%2A> 若要间接释放类型，使用一种语言构造如`using`（在 C# 中) 或`Using`（在 Visual Basic 中)。 有关详细信息，请参阅中的&quot;使用实现 IDisposable 的对象&quot;部分<xref:System.IDisposable>接口主题。</xref:System.IDisposable>      1> [!IMPORTANT]&1;> 独立的存储也无法供[!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)]应用。 请改用中的应用程序数据类`Windows.Storage`中均包括命名空间[!INCLUDE[wrt](~/add/includes/wrt-md.md)]API 来存储本地数据和文件。 有关详细信息，请参阅[应用程序数据](http://go.microsoft.com/fwlink/?LinkId=229175)Windows 开发人员中心中。"
  example:
  - "The following console application demonstrates how you can use <xref:System.IO.IsolatedStorage.IsolatedStorageFile> and IsolatedStorageFileStream to write data to an Isolated Storage file. The user is requested to log in. If the user is a new user, a News URL and a Sports URL are recorded as personal preferences in Isolated Storage. If the user is a returning user, the user's current preferences are displayed. The code examples used throughout this namespace are presented in the context of this sample application. You can use the [Storeadm.exe (Isolated Storage Tool)](~/add/includes/ajax-current-ext-md.md) utility to list and remove the Isolated Storage files that are created with this console application.  \n  \n [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#1](~/add/codesnippet/visualbasic/t-system.io.isolatedstor_2_1.vb)]\n [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#1](~/add/codesnippet/cpp/t-system.io.isolatedstor_2_1.cpp)]\n [!code-cs[System.IO.IsolatedStorage.IsolatedStorage#1](~/add/codesnippet/csharp/t-system.io.isolatedstor_2_1.cs)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public class IsolatedStorageFileStream : System.IO.FileStream
  inheritance:
  - System.IO.Stream
  - System.IO.FileStream
  implements: []
  inheritedMembers:
  - System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  - System.IO.FileStream.GetAccessControl
  - System.IO.FileStream.Name
  - System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  - System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode)
  id: '#ctor(System.String,System.IO.FileMode)'
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: IsolatedStorageFileStream(String,FileMode)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "初始化的新实例<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>给指定的文件的访问的对象<code> path </code>中指定<code> mode </code>。"
  remarks: "使用独立存储区的作用范围由当前正在执行程序集的标识和在其中运行的应用程序域。 此存储将仅的整个生存期内保持打开<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>对象。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> 要指定不同的独立的存储作用域，或要允许要保持打开状态的存储区 (因此多个<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>对象可从它中打开)，使用接受的构造函数的形式<xref:System.IO.IsolatedStorage.IsolatedStorageFile>对象。</xref:System.IO.IsolatedStorage.IsolatedStorageFile> </xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>       `mode`参数指示是否应创建新的文件、 一个现有使用，等等。      1> [!CAUTION]&1;> 当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释和可能会导致引发异常。"
  syntax:
    content: public IsolatedStorageFileStream (string path, System.IO.FileMode mode);
    parameters:
    - id: path
      type: System.String
      description: "独立存储区内文件的相对路径。"
    - id: mode
      type: System.IO.FileMode
      description: "之一<xref href=&quot;System.IO.FileMode&quot;></xref>值。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> path </code>格式有误。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "中的目录<code> path </code>不存在。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "未找到文件和<code> mode </code>设置为<xref href=&quot;System.IO.FileMode&quot;></xref>"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)'
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: IsolatedStorageFileStream(String,FileMode,FileAccess)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "初始化的新实例<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>给指定的文件的访问的类<code> path </code>，在指定<code> mode </code>，与类型的<code> access </code>请求。"
  remarks: "使用独立存储区的作用范围由当前正在执行程序集的标识和在其中运行的应用程序域。 此存储将仅的整个生存期内保持打开<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>对象。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> 要指定不同的独立的存储作用域，或要允许要保持打开状态的存储区 (因此多个<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>对象可从它中打开)，使用接受的构造函数的形式<xref:System.IO.IsolatedStorage.IsolatedStorageFile>对象。</xref:System.IO.IsolatedStorage.IsolatedStorageFile> </xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>       `mode`参数指示是否应创建一个新文件或一个现有使用。 `access`参数包含只读的读/写和只写。      1> [!CAUTION]&1;> 当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能导致异常引发。"
  syntax:
    content: public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);
    parameters:
    - id: path
      type: System.String
      description: "独立存储区内文件的相对路径。"
    - id: mode
      type: System.IO.FileMode
      description: "之一<xref href=&quot;System.IO.FileMode&quot;></xref>值。"
    - id: access
      type: System.IO.FileAccess
      description: "按位组合<xref href=&quot;System.IO.FileAccess&quot;></xref>值。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> path </code>格式有误。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "未找到文件和<code> mode </code>设置为<xref href=&quot;System.IO.FileMode&quot;> </xref>。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.IsolatedStorage.IsolatedStorageFile)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.IsolatedStorage.IsolatedStorageFile)'
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: IsolatedStorageFileStream(String,FileMode,IsolatedStorageFile)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,IsolatedStorageFile)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,IsolatedStorageFile)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "初始化的新实例<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>给指定的文件的访问的类<code> path </code>，在指定<code> mode </code>，和的上下文中<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFile&quot;></xref>指定的<code> isf </code>。"
  remarks: "`mode`参数指示是否应创建新的文件、 一个现有使用，等等。      1> [!CAUTION]&1;> 当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能导致异常引发。"
  example:
  - "The following code example demonstrates the use of this constructor. For the complete context of this example, see the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> overview.  \n  \n [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#11](~/add/codesnippet/visualbasic/ed0ff8fa-778f-4b06-9af8-_1.vb)]\n [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#11](~/add/codesnippet/cpp/ed0ff8fa-778f-4b06-9af8-_1.cpp)]\n [!code-cs[System.IO.IsolatedStorage.IsolatedStorage#11](~/add/codesnippet/csharp/ed0ff8fa-778f-4b06-9af8-_1.cs)]"
  syntax:
    content: public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.IsolatedStorage.IsolatedStorageFile isf);
    parameters:
    - id: path
      type: System.String
      description: "独立存储区内文件的相对路径。"
    - id: mode
      type: System.IO.FileMode
      description: "之一<xref href=&quot;System.IO.FileMode&quot;></xref>值。"
    - id: isf
      type: System.IO.IsolatedStorage.IsolatedStorageFile
      description: "<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFile&quot;> </xref>在其中打开<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;> </xref>。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> path </code>格式有误。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "未找到文件和<code> mode </code>设置为<xref href=&quot;System.IO.FileMode&quot;> </xref>。"
  - type: System.IO.IsolatedStorage.IsolatedStorageException
    commentId: T:System.IO.IsolatedStorage.IsolatedStorageException
    description: "<code>isf</code>没有配额。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)'
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "初始化的新实例<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>给指定的文件的访问的类<code> path </code>，在指定<code> mode </code>，使用指定的文件<code> access </code>，使用的文件共享指定的模式<code> share </code>。"
  remarks: "使用独立存储区的作用范围由当前正在执行程序集的标识和在其中运行的应用程序域。 此存储将仅的整个生存期内保持打开<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>对象。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> 要指定不同的独立的存储作用域，或要允许要保持打开状态的存储区 (因此多个<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>对象可从它中打开)，使用接受的构造函数的形式<xref:System.IO.IsolatedStorage.IsolatedStorageFile>对象。</xref:System.IO.IsolatedStorage.IsolatedStorageFile> </xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>      1> [!CAUTION]&1;> 当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释和可能会导致引发异常。"
  example:
  - "The following code example demonstrates the use of this constructor. For the complete context of this example, see the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> overview.  \n  \n [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#15](~/add/codesnippet/visualbasic/16e66ff6-8db3-485d-ac06-_1.vb)]\n [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#15](~/add/codesnippet/cpp/16e66ff6-8db3-485d-ac06-_1.cpp)]\n [!code-cs[System.IO.IsolatedStorage.IsolatedStorage#15](~/add/codesnippet/csharp/16e66ff6-8db3-485d-ac06-_1.cs)]"
  syntax:
    content: public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
    parameters:
    - id: path
      type: System.String
      description: "独立存储区内文件的相对路径。"
    - id: mode
      type: System.IO.FileMode
      description: "之一<xref href=&quot;System.IO.FileMode&quot;></xref>值。"
    - id: access
      type: System.IO.FileAccess
      description: "按位组合<xref href=&quot;System.IO.FileAccess&quot;></xref>值。"
    - id: share
      type: System.IO.FileShare
      description: "按位组合<xref href=&quot;System.IO.FileShare&quot;></xref>值。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> path </code>格式有误。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "未找到文件和<code> mode </code>设置为<xref href=&quot;System.IO.FileMode&quot;> </xref>。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.IsolatedStorage.IsolatedStorageFile)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.IsolatedStorage.IsolatedStorageFile)'
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: IsolatedStorageFileStream(String,FileMode,FileAccess,IsolatedStorageFile)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,IsolatedStorageFile)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,IsolatedStorageFile)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "初始化的新实例<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>给指定的文件的访问的类<code> path </code>中指定<code> mode </code>，使用指定的文件<code> access </code>，和的上下文中<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFile&quot;></xref>指定的<code> isf </code>。"
  remarks: "`mode`参数指示是否应创建一个新文件或一个现有使用。 `access`参数包含只读的读/写和只写。      1> [!CAUTION]&1;> 当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能导致异常引发。"
  example:
  - "The following code example demonstrates the use of this constructor. For the complete context of this example, see the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> overview.  \n  \n [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#10](~/add/codesnippet/visualbasic/404bef15-453e-4818-ab5f-_1.vb)]\n [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#10](~/add/codesnippet/cpp/404bef15-453e-4818-ab5f-_1.cpp)]\n [!code-cs[System.IO.IsolatedStorage.IsolatedStorage#10](~/add/codesnippet/csharp/404bef15-453e-4818-ab5f-_1.cs)]"
  syntax:
    content: public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.IsolatedStorage.IsolatedStorageFile isf);
    parameters:
    - id: path
      type: System.String
      description: "独立存储区内文件的相对路径。"
    - id: mode
      type: System.IO.FileMode
      description: "之一<xref href=&quot;System.IO.FileMode&quot;></xref>值。"
    - id: access
      type: System.IO.FileAccess
      description: "按位组合<xref href=&quot;System.IO.FileAccess&quot;></xref>值。"
    - id: isf
      type: System.IO.IsolatedStorage.IsolatedStorageFile
      description: "<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFile&quot;> </xref>在其中打开<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;> </xref>。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> path </code>格式有误。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "独立存储区已关闭。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "未找到文件和<code> mode </code>设置为<xref href=&quot;System.IO.FileMode&quot;> </xref>。"
  - type: System.IO.IsolatedStorage.IsolatedStorageException
    commentId: T:System.IO.IsolatedStorage.IsolatedStorageException
    description: "<code>isf</code>没有配额。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)'
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,Int32)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,Int32)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "初始化的新实例<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>给指定的文件的访问的类<code> path </code>，在指定<code> mode </code>，使用指定的文件<code> access </code>，使用的文件共享指定的模式<code> share </code>，与<code> buffersize </code>指定。"
  remarks: "使用独立存储区的作用范围由当前正在执行程序集的标识和在其中运行的应用程序域。 此存储将仅的整个生存期内保持打开<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>对象。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> 要指定不同的独立的存储作用域，或要允许要保持打开状态的存储区 (因此多个<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>对象可从它中打开)，使用接受的构造函数的形式<xref:System.IO.IsolatedStorage.IsolatedStorageFile>对象。</xref:System.IO.IsolatedStorage.IsolatedStorageFile> </xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>       `mode`参数指示是否应创建一个新文件或一个现有使用。 `access`参数包含只读的读/写和只写。      1> [!CAUTION]&1;> 当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能导致异常引发。"
  syntax:
    content: public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);
    parameters:
    - id: path
      type: System.String
      description: "独立存储区内文件的相对路径。"
    - id: mode
      type: System.IO.FileMode
      description: "之一<xref href=&quot;System.IO.FileMode&quot;></xref>值。"
    - id: access
      type: System.IO.FileAccess
      description: "按位组合<xref href=&quot;System.IO.FileAccess&quot;></xref>值。"
    - id: share
      type: System.IO.FileShare
      description: "按位组合<xref href=&quot;System.IO.FileShare&quot;></xref>值。"
    - id: bufferSize
      type: System.Int32
      description: "<xref href=&quot;System.IO.FileStream&quot;> </xref>缓冲区大小。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> path </code>格式有误。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "未找到文件和<code> mode </code>设置为<xref href=&quot;System.IO.FileMode&quot;> </xref>。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.IO.IsolatedStorage.IsolatedStorageFile)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.IO.IsolatedStorage.IsolatedStorageFile)'
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,IsolatedStorageFile)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,IsolatedStorageFile)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,IsolatedStorageFile)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "初始化的新实例<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>给指定的文件的访问的类<code> path </code>，在指定<code> mode </code>，使用指定的文件<code> access </code>，使用的文件共享指定的模式<code> share </code>，和的上下文中<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFile&quot;></xref>指定的<code> isf </code>。"
  remarks: "`mode`参数指示是否应创建一个新文件或一个现有使用。 `access`参数包含只读的读/写和只写。      1> [!CAUTION]&1;> 当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能导致异常引发。"
  example:
  - "The following code example demonstrates the use of this constructor. For the complete context of this example, see the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> overview.  \n  \n [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#11](~/add/codesnippet/visualbasic/d6e9d0e2-c3f3-4d3d-941f-_1.vb)]\n [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#11](~/add/codesnippet/cpp/d6e9d0e2-c3f3-4d3d-941f-_1.cpp)]\n [!code-cs[System.IO.IsolatedStorage.IsolatedStorage#11](~/add/codesnippet/csharp/d6e9d0e2-c3f3-4d3d-941f-_1.cs)]"
  syntax:
    content: public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.IO.IsolatedStorage.IsolatedStorageFile isf);
    parameters:
    - id: path
      type: System.String
      description: "独立存储区内文件的相对路径。"
    - id: mode
      type: System.IO.FileMode
      description: "之一<xref href=&quot;System.IO.FileMode&quot;></xref>值。"
    - id: access
      type: System.IO.FileAccess
      description: "按位组合<xref href=&quot;System.IO.FileAccess&quot;></xref>值。"
    - id: share
      type: System.IO.FileShare
      description: "按位组合<xref href=&quot;System.IO.FileShare&quot;></xref>值。"
    - id: isf
      type: System.IO.IsolatedStorage.IsolatedStorageFile
      description: "<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFile&quot;> </xref>在其中打开<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;> </xref>。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> path </code>格式有误。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "未找到文件和<code> mode </code>设置为<xref href=&quot;System.IO.FileMode&quot;> </xref>。"
  - type: System.IO.IsolatedStorage.IsolatedStorageException
    commentId: T:System.IO.IsolatedStorage.IsolatedStorageException
    description: "<code>isf</code>没有配额。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.IsolatedStorage.IsolatedStorageFile)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.IsolatedStorage.IsolatedStorageFile)'
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,Int32,IsolatedStorageFile)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,Int32,IsolatedStorageFile)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,Int32,IsolatedStorageFile)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "初始化的新实例<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>给指定的文件的访问的类<code> path </code>，在指定<code> mode </code>，使用指定的文件<code> access </code>，使用的文件共享指定的模式<code> share </code>，与<code> buffersize </code>指定，和的上下文中<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFile&quot;></xref>指定的<code> isf </code>。"
  remarks: "`mode`参数指示是否应创建一个新文件或一个现有使用。 `access`参数包含只读的读/写和只写。      1> [!CAUTION]&1;> 当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能导致异常引发。"
  example:
  - "The following code example demonstrates the use of this constructor. For the complete context of this example, see the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> overview.  \n  \n [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#12](~/add/codesnippet/visualbasic/992df1ce-aff0-4ca4-9ce4-_1.vb)]\n [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#12](~/add/codesnippet/cpp/992df1ce-aff0-4ca4-9ce4-_1.cpp)]\n [!code-cs[System.IO.IsolatedStorage.IsolatedStorage#12](~/add/codesnippet/csharp/992df1ce-aff0-4ca4-9ce4-_1.cs)]"
  syntax:
    content: public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.IsolatedStorage.IsolatedStorageFile isf);
    parameters:
    - id: path
      type: System.String
      description: "独立存储区内文件的相对路径。"
    - id: mode
      type: System.IO.FileMode
      description: "之一<xref href=&quot;System.IO.FileMode&quot;></xref>值。"
    - id: access
      type: System.IO.FileAccess
      description: "按位组合<xref href=&quot;System.IO.FileAccess&quot;></xref>值。"
    - id: share
      type: System.IO.FileShare
      description: "按位组合<xref href=&quot;System.IO.FileShare&quot;></xref>值"
    - id: bufferSize
      type: System.Int32
      description: "<xref href=&quot;System.IO.FileStream&quot;> </xref>缓冲区大小。"
    - id: isf
      type: System.IO.IsolatedStorage.IsolatedStorageFile
      description: "<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFile&quot;> </xref>在其中打开<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;> </xref>。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> path </code>格式有误。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "未找到文件和<code> mode </code>设置为<xref href=&quot;System.IO.FileMode&quot;> </xref>。"
  - type: System.IO.IsolatedStorage.IsolatedStorageException
    commentId: T:System.IO.IsolatedStorage.IsolatedStorageException
    description: "<code>isf</code>没有配额。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: IsolatedStorageFileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "开始异步读。"
  remarks: "当不是在 I/O 操作完成时发出的异步读取或写入时，将更新流中的当前位置。       必须调用<xref:System.IO.Stream.EndRead%2A>与此<xref:System.IAsyncResult>若要了解已读取的字节。</xref:System.IAsyncResult> </xref:System.IO.Stream.EndRead%2A>"
  syntax:
    content: public override IAsyncResult BeginRead (byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "要将数据读入的缓冲区。"
    - id: offset
      type: System.Int32
      description: "中的字节偏移量`buffer`从此处开始读取。"
    - id: numBytes
      type: System.Int32
      description: "最大读取的字节数。"
    - id: userCallback
      type: System.AsyncCallback
      description: "完成的异步读取操作时要调用的方法。 此参数是可选的。"
    - id: stateObject
      type: System.Object
      description: "异步读取的状态。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>的对象，表示异步读取时，可能仍处于挂起状态。</xref:System.IAsyncResult> 这<xref:System.IAsyncResult>必须传递到此流的<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead*>方法以确定已读取的字节数。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead*> </xref:System.IAsyncResult> 可以通过调用 BeginRead 的相同代码或在传递给 BeginRead 回调中完成此操作。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "异步读取试图超出文件末尾。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: IsolatedStorageFileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "开始异步写。"
  remarks: "如果<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>对象是可写的在流末尾写入将扩展的流。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>       当不是在 I/O 操作完成时发出的异步读取或写入时，将更新流中的当前位置。       必须调用<xref:System.IO.Stream.EndWrite%2A>与<xref:System.IAsyncResult>对象，此方法返回若要了解编写多少个字节。</xref:System.IAsyncResult> </xref:System.IO.Stream.EndWrite%2A>"
  syntax:
    content: public override IAsyncResult BeginWrite (byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "要将数据写入的缓冲区。"
    - id: offset
      type: System.Int32
      description: "中的字节偏移量`buffer`在此处开始写入。"
    - id: numBytes
      type: System.Int32
      description: "最大写入的字节数。"
    - id: userCallback
      type: System.AsyncCallback
      description: "要异步写入操作完成后调用的方法。 此参数是可选的。"
    - id: stateObject
      type: System.Object
      description: "异步写的状态。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，它表示可能仍处于挂起状态的异步写入。</xref:System.IAsyncResult> 这<xref:System.IAsyncResult>必须传递到此流的<> *1> 方法，以确保写入操作已完成，然后相应地释放资源。</xref:System.IAsyncResult>这可以通过调用的相同代码<> *1> 或传递给<xref:System.IO.Stream.BeginWrite*>.</xref:System.IO.Stream.BeginWrite*>回调"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "异步写试图超出文件末尾。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanRead
  id: CanRead
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: CanRead
  nameWithType: IsolatedStorageFileStream.CanRead
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanRead
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "获取一个布尔值，该值指示是否可以读取该文件。"
  remarks: "使用此属性来确定是否<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>可以读取对象。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>"
  example:
  - "The following code example demonstrates how you could use the CanRead property, as a check to see whether a stream can be read before calling the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A> or <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A> methods. For the complete context of this example, see the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> overview.  \n  \n [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#11](~/add/codesnippet/visualbasic/p-system.io.isolatedstor_1_1.vb)]\n [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#11](~/add/codesnippet/cpp/p-system.io.isolatedstor_1_1.cpp)]\n [!code-cs[System.IO.IsolatedStorage.IsolatedStorage#11](~/add/codesnippet/csharp/p-system.io.isolatedstor_1_1.cs)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>对象可以是读取; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek
  id: CanSeek
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: IsolatedStorageFileStream.CanSeek
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "获取一个布尔值，该值指示查找支持操作。"
  remarks: "使用此属性来确定是否<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>对象支持查找操作。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>"
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>对象支持查找操作; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanWrite
  id: CanWrite
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: IsolatedStorageFileStream.CanWrite
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanWrite
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "获取一个布尔值，该值指示是否可以写入该文件。"
  remarks: "使用此属性来确定是否<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>可以写入对象。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>"
  example:
  - "The following code example demonstrates how you could use the CanWrite property, as a check to see whether a stream can be read before calling the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Write%2A> or <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A> methods. For the complete context of this example, see the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> overview.  \n  \n [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#13](~/add/codesnippet/visualbasic/p-system.io.isolatedstor_3_1.vb)]\n [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#13](~/add/codesnippet/cpp/p-system.io.isolatedstor_3_1.cpp)]\n [!code-cs[System.IO.IsolatedStorage.IsolatedStorage#13](~/add/codesnippet/csharp/p-system.io.isolatedstor_3_1.cs)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>对象可以是写入; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: IsolatedStorageFileStream.Dispose(Boolean)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "释放由非托管的资源<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;> </xref> ，还可以释放托管的资源。"
  remarks: "此方法称为由公共<xref:System.IDisposable.Dispose%2A>方法和<xref:System.Object.Finalize%2A>方法。</xref:System.Object.Finalize%2A> </xref:System.IDisposable.Dispose%2A> <xref:System.IDisposable.Dispose%2A>调用与受保护的 Dispose 方法`disposing`参数设置为 true。</xref:System.IDisposable.Dispose%2A> <xref:System.Object.Finalize%2A>调用与 Dispose`disposing`设置为 false。</xref:System.Object.Finalize%2A>       当`disposing`参数为 true 时，此方法释放由任何托管对象持有的全部资源此<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>引用。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> 此方法调用<xref:System.IDisposable.Dispose%2A>每个引用对象的方法。</xref:System.IDisposable.Dispose%2A>"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要释放托管和非托管资源;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>若要仅释放非托管的资源"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead(System.IAsyncResult)
  id: EndRead(System.IAsyncResult)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: EndRead(IAsyncResult)
  nameWithType: IsolatedStorageFileStream.EndRead(IAsyncResult)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "结束挂起的异步读取的请求。"
  remarks: "必须在上一次调用 EndRead 每个<xref:System.IAsyncResult>对象<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A>，并且调用 EndRead 知道<xref:System.IO.Stream>。</xref:System.IO.Stream>读取的多少字节数的唯一办法</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A></xref:System.IAsyncResult> EndRead 将阻止，直到 I/O 操作已完成。"
  syntax:
    content: public override int EndRead (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "挂起的异步请求。"
    return:
      type: System.Int32
      description: "从流，介于&0; 与请求的字节数之间中读取的字节数。 流仅将返回零在流末尾。 否则，它们将阻止到至少&1; 个字节可用之前。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>asyncResult</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite(System.IAsyncResult)
  id: EndWrite(System.IAsyncResult)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: EndWrite(IAsyncResult)
  nameWithType: IsolatedStorageFileStream.EndWrite(IAsyncResult)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "结束异步写入。"
  remarks: "必须在每个<xref:System.IAsyncResult><xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A>.</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A>从</xref:System.IAsyncResult>上一次调用 EndWrite       EndWrite 将阻止，直到 I/O 操作已完成。"
  syntax:
    content: public override void EndWrite (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "挂起的异步 I/O 请求结束。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>asyncResult</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush
  id: Flush
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: Flush()
  nameWithType: IsolatedStorageFileStream.Flush()
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "清除此流的缓冲区，使得所有缓冲的数据写入到文件。"
  remarks: "因为缓冲区可以用于读取或写入，但不是两个同时刷新执行两个函数。 首先，以前向缓冲区写入任何数据复制到文件并清除缓冲区。 其次，如果<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek%2A>是`true`和以前将数据从文件复制到缓冲区以进行读取，该文件中的当前位置将减少的缓冲区中的未读字节数。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek%2A> 然后清除缓冲区。       使用<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush%28System.Boolean%29>方法重载时你想要确保中间文件缓冲区中的所有缓冲数据写入到磁盘。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush%28System.Boolean%29>"
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush*
  exceptions: []
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush(System.Boolean)
  id: Flush(System.Boolean)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: Flush(Boolean)
  nameWithType: IsolatedStorageFileStream.Flush(Boolean)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "清除此流的缓冲区并使所有缓冲的数据都写入到该文件，并清除所有中间文件缓冲区。"
  remarks: "使用此重载时你想要确保中间文件缓冲区中的所有缓冲数据写入到磁盘。"
  syntax:
    content: public override void Flush (bool flushToDisk);
    parameters:
    - id: flushToDisk
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要刷新所有中间文件缓冲区;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush*
  exceptions: []
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle
  id: Handle
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: Handle
  nameWithType: IsolatedStorageFileStream.Handle
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "获取文件句柄的文件的当前<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>对象所封装。 在不允许访问此属性<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>对象，并引发<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageException&quot;> </xref>。"
  remarks: "有关详细信息，请参阅<xref:System.IO.FileStream.Handle%2A>。</xref:System.IO.FileStream.Handle%2A>"
  example:
  - "The following code example demonstrates the Handle property.  \n  \n [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#4](~/add/codesnippet/visualbasic/p-system.io.isolatedstor_4_1.vb)]\n [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#4](~/add/codesnippet/cpp/p-system.io.isolatedstor_4_1.cpp)]\n [!code-cs[System.IO.IsolatedStorage.IsolatedStorage#4](~/add/codesnippet/csharp/p-system.io.isolatedstor_4_1.cs)]"
  syntax:
    content: public override IntPtr Handle { get; }
    return:
      type: System.IntPtr
      description: "该文件的文件句柄的当前<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>对象所封装。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle*
  exceptions:
  - type: System.IO.IsolatedStorage.IsolatedStorageException
    commentId: T:System.IO.IsolatedStorage.IsolatedStorageException
    description: "句柄属性始终生成此异常。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsAsync
  id: IsAsync
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: IsAsync
  nameWithType: IsolatedStorageFileStream.IsAsync
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsAsync
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "获取一个布尔值，该值指示是否<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>对象异步还是同步打开。"
  remarks: "<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>无法创建对象，与<xref:System.IO.FileStream>.</xref:System.IO.FileStream>不同</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>异步 但是， <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A>， <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A>， <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite%2A>，和<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A>具有一些性能损失同步实例上支持的方法。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A> </xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite%2A> </xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A> </xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A>"
  example:
  - "The following code example demonstrates how you can use the IsAsync property to verify that an <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> is synchronous. For the complete context of this example, see the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> overview.  \n  \n [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#7](~/add/codesnippet/visualbasic/p-system.io.isolatedstor_7_1.vb)]\n [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#7](~/add/codesnippet/cpp/p-system.io.isolatedstor_7_1.cpp)]\n [!code-cs[System.IO.IsolatedStorage.IsolatedStorage#7](~/add/codesnippet/csharp/p-system.io.isolatedstor_7_1.cs)]"
  syntax:
    content: public override bool IsAsync { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>对象支持异步访问; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsAsync*
  exceptions: []
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Length
  id: Length
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: Length
  nameWithType: IsolatedStorageFileStream.Length
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Length
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "获取的长度<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>对象。"
  remarks: "长度表示文件中的当前字节的数。 不受独立的存储配额。"
  example:
  - "The following code example demonstrates the Length property.  \n  \n [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/add/codesnippet/visualbasic/p-system.io.isolatedstor_6_1.vb)]\n [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/add/codesnippet/cpp/p-system.io.isolatedstor_6_1.cpp)]\n [!code-cs[System.IO.IsolatedStorage.IsolatedStorage#14](~/add/codesnippet/csharp/p-system.io.isolatedstor_6_1.cs)]"
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "长度<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>以字节为单位的对象。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.Length*
  exceptions: []
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Lock(System.Int64,System.Int64)
  id: Lock(System.Int64,System.Int64)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: Lock(Int64,Int64)
  nameWithType: IsolatedStorageFileStream.Lock(Int64,Int64)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Lock(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "防止其他进程读取或写入流。"
  remarks: "文件流的范围锁定赋予该区域的文件流的锁定的进程独占访问的线程。"
  syntax:
    content: public override void Lock (long position, long length);
    parameters:
    - id: position
      type: System.Int64
      description: "要锁定的范围的起始位置。 此参数的值必须等于或大于 0 （零）。"
    - id: length
      type: System.Int64
      description: "要锁定的字节数。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.Lock*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>position</code>或<code>length</code>为负。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "文件关闭。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "进程无法访问该文件，因为另一个进程已锁定文件的一部分。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Position
  id: Position
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: Position
  nameWithType: IsolatedStorageFileStream.Position
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Position
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "获取或设置当前的当前位置<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>对象。"
  remarks: "设置此属性时才起作用<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek%2A>属性是`true`。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek%2A>"
  example:
  - "The following code example uses the Position property to write data to a file.  \n  \n [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/add/codesnippet/visualbasic/p-system.io.isolatedstor_0_1.vb)]\n [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/add/codesnippet/cpp/p-system.io.isolatedstor_0_1.cpp)]\n [!code-cs[System.IO.IsolatedStorage.IsolatedStorage#14](~/add/codesnippet/csharp/p-system.io.isolatedstor_0_1.cs)]"
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "此当前位置<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>对象。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.Position*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "不能为负数集位置。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: IsolatedStorageFileStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "从当前缓冲复制字节<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>到一个数组对象。"
  remarks: "`buffer`参数可以为实例<xref:System.Buffer>类或数组的以下类型之一︰ <xref:System.Byte>， <xref:System.SByte>， <xref:System.Char>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.Int64>， <xref:System.UInt16>， <xref:System.UInt32>， <xref:System.UInt64>， <xref:System.Single>，或<xref:System.Double>。</xref:System.Double> </xref:System.Single> </xref:System.UInt64> </xref:System.UInt32> </xref:System.UInt16> </xref:System.Int64> </xref:System.Int32> </xref:System.Int16> </xref:System.Char> </xref:System.SByte> </xref:System.Byte> </xref:System.Buffer> `offset`参数指定了缓冲区中从其开始写入 （缓冲区中的索引） 中的字节的偏移量和`count`参数提供的最大将从此流中读取的字节数。 如果已到达流结尾，则返回的值是实际数字节，则为零。 如果读取的操作成功，是通过读取的字节数高级流的当前位置。 如果发生异常，则流的当前位置不变。       Read 方法将`buffer`作为一个字节，而不考虑其实际类型的块的参数。 同样，`offset`和`count`参数始终以字节为单位指定。 有关`buffer`字节数组以外的参数，这意味着元素索引必须乘以元素大小 （字节） 以形成的正确值`offset`或`count`。       Read 方法将返回零，仅当已到达流结尾。 在所有其他情况下，读取始终至少&1; 个字节从流中读取在返回之前。 如果不会从提供数据<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>对象在读取，调用该方法将一直阻止到至少一个字节的数据可以返回。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>"
  syntax:
    content: public override int Read (byte[] buffer, int offset, int count);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "要读取的缓冲区。"
    - id: offset
      type: System.Int32
      description: "在此处开始写入的缓冲区中的偏移量。"
    - id: count
      type: System.Int32
      description: "最大读取的字节数。"
    return:
      type: System.Int32
      description: "总字节数读入<code> buffer </code>。 这可能小于请求的字节数的如果很多字节当前不可用，或零个如果已到达流结尾。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.Read*
  exceptions: []
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.ReadByte
  id: ReadByte
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: ReadByte()
  nameWithType: IsolatedStorageFileStream.ReadByte()
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.ReadByte()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "读取单个字节从<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>独立存储中的对象。"
  remarks: ''
  example:
  - "The following code example demonstrates how the ReadByte method can be used to read data from an <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> object. For the complete context of this example, see the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> overview.  \n  \n [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/add/codesnippet/visualbasic/m-system.io.isolatedstor_13_1.vb)]\n [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/add/codesnippet/cpp/m-system.io.isolatedstor_13_1.cpp)]\n [!code-cs[System.IO.IsolatedStorage.IsolatedStorage#14](~/add/codesnippet/csharp/m-system.io.isolatedstor_13_1.cs)]"
  syntax:
    content: public override int ReadByte ();
    parameters: []
    return:
      type: System.Int32
      description: "从独立的存储文件中读取的 8 位无符号的整数值。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.ReadByte*
  exceptions: []
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle
  id: SafeFileHandle
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: SafeFileHandle
  nameWithType: IsolatedStorageFileStream.SafeFileHandle
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "获取<xref href=&quot;Microsoft.Win32.SafeHandles.SafeFileHandle&quot;></xref>表示该文件的操作系统文件句柄的对象，当前<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>对象所封装。"
  remarks: "SafeFileHandle 属性不受支持，始终生成<xref:System.IO.IsolatedStorage.IsolatedStorageException>异常。</xref:System.IO.IsolatedStorage.IsolatedStorageException>"
  syntax:
    content: public override Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }
    return:
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "A <xref href=&quot;Microsoft.Win32.SafeHandles.SafeFileHandle&quot;> </xref>表示该文件的操作系统文件句柄的对象，当前<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>对象所封装。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle*
  exceptions:
  - type: System.IO.IsolatedStorage.IsolatedStorageException
    commentId: T:System.IO.IsolatedStorage.IsolatedStorageException
    description: "SafeFileHandle 属性始终生成此异常。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: IsolatedStorageFileStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "设置此当前位置<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>为指定的值的对象。"
  remarks: "某些<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>对象支持流的长度超出定位，其他人在这种情况下将引发异常。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>"
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "新位置<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>对象。"
    - id: origin
      type: System.IO.SeekOrigin
      description: "之一<xref:System.IO.SeekOrigin>值。</xref:System.IO.SeekOrigin>"
    return:
      type: System.Int64
      description: "中的新位置<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>对象。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.Seek*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> origin </code>必须是<xref:System.IO.SeekOrigin>值。</xref:System.IO.SeekOrigin>"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: IsolatedStorageFileStream.SetLength(Int64)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.SetLength(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "设置此长度<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>到指定的对象<code> value </code>。"
  remarks: "如果指定`value`的当前长度少于<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>对象，则流被截断。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> 如果指定`value`大于当前的长度的流，则流被扩展。 如果流已展开，旧和新的长度之间流的内容是不确定的。 若要使用此方法，<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>对象必须支持写入和查找。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>"
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "新长度<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>对象。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.SetLength*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>value</code>为负数。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Unlock(System.Int64,System.Int64)
  id: Unlock(System.Int64,System.Int64)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: Unlock(Int64,Int64)
  nameWithType: IsolatedStorageFileStream.Unlock(Int64,Int64)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Unlock(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "允许其他进程访问以前锁定的文件的全部或部分。"
  syntax:
    content: public override void Unlock (long position, long length);
    parameters:
    - id: position
      type: System.Int64
      description: "解锁范围的起始位置。 此参数的值必须等于或大于 0 （零）。"
    - id: length
      type: System.Int64
      description: "要解锁的字节数。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.Unlock*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>position</code>或<code>length</code>为负。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: IsolatedStorageFileStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "将字节块写入<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>对象使用从字节数组中读取的数据。"
  remarks: "`offset`参数指定了中的字节的偏移量`buffer`从此处开始读取，和`count`参数指定了将写入到这的字节数<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>对象。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> 如果写入操作成功的当前位置<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>对象高级通过写入的字节数。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> 如果发生异常的当前位置<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>对象保持不变。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>"
  syntax:
    content: public override void Write (byte[] buffer, int offset, int count);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "要写入的缓冲区。"
    - id: offset
      type: System.Int32
      description: "从此处开始的缓冲区中的字节偏移量。"
    - id: count
      type: System.Int32
      description: "最大写入的字节数。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.Write*
  exceptions:
  - type: System.IO.IsolatedStorage.IsolatedStorageException
    commentId: T:System.IO.IsolatedStorage.IsolatedStorageException
    description: "写入尝试次数超过的配额<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>对象。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.WriteByte(System.Byte)
  id: WriteByte(System.Byte)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: WriteByte(Byte)
  nameWithType: IsolatedStorageFileStream.WriteByte(Byte)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.WriteByte(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "将单个字节写入<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>对象。"
  remarks: ''
  example:
  - "The following code example demonstrates how the WriteByte method can be used to read data from an <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> object. For the complete context of this example, see the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> overview.  \n  \n [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/add/codesnippet/visualbasic/m-system.io.isolatedstor_8_1.vb)]\n [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/add/codesnippet/cpp/m-system.io.isolatedstor_8_1.cpp)]\n [!code-cs[System.IO.IsolatedStorage.IsolatedStorage#14](~/add/codesnippet/csharp/m-system.io.isolatedstor_8_1.cs)]"
  syntax:
    content: public override void WriteByte (byte value);
    parameters:
    - id: value
      type: System.Byte
      description: "要写入独立的存储文件的字节值。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.WriteByte*
  exceptions:
  - type: System.IO.IsolatedStorage.IsolatedStorageException
    commentId: T:System.IO.IsolatedStorage.IsolatedStorageException
    description: "写入尝试次数超过的配额<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>对象。"
  platform:
  - net462
references:
- uid: System.IO.FileStream
  isExternal: false
  name: System.IO.FileStream
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.IO.DirectoryNotFoundException
  isExternal: true
  name: System.IO.DirectoryNotFoundException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.IsolatedStorage.IsolatedStorageException
  parent: System.IO.IsolatedStorage
  isExternal: false
  name: IsolatedStorageException
  nameWithType: IsolatedStorageException
  fullName: System.IO.IsolatedStorage.IsolatedStorageException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: IsolatedStorageFileStream(String,FileMode)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.FileMode
  parent: System.IO
  isExternal: false
  name: FileMode
  nameWithType: FileMode
  fullName: System.IO.FileMode
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: IsolatedStorageFileStream(String,FileMode,FileAccess)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.IsolatedStorage.IsolatedStorageFile)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: IsolatedStorageFileStream(String,FileMode,IsolatedStorageFile)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,IsolatedStorageFile)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,IsolatedStorageFile)
- uid: System.IO.IsolatedStorage.IsolatedStorageFile
  parent: System.IO.IsolatedStorage
  isExternal: false
  name: IsolatedStorageFile
  nameWithType: IsolatedStorageFile
  fullName: System.IO.IsolatedStorage.IsolatedStorageFile
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare)
- uid: System.IO.FileShare
  parent: System.IO
  isExternal: false
  name: FileShare
  nameWithType: FileShare
  fullName: System.IO.FileShare
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.IsolatedStorage.IsolatedStorageFile)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: IsolatedStorageFileStream(String,FileMode,FileAccess,IsolatedStorageFile)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,IsolatedStorageFile)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,IsolatedStorageFile)
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,Int32)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,Int32)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.IO.IsolatedStorage.IsolatedStorageFile)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,IsolatedStorageFile)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,IsolatedStorageFile)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,IsolatedStorageFile)
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.IsolatedStorage.IsolatedStorageFile)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,Int32,IsolatedStorageFile)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,Int32,IsolatedStorageFile)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,Int32,IsolatedStorageFile)
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: IsolatedStorageFileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: IsolatedStorageFileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanRead
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: CanRead
  nameWithType: IsolatedStorageFileStream.CanRead
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanRead
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: CanSeek
  nameWithType: IsolatedStorageFileStream.CanSeek
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanWrite
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: CanWrite
  nameWithType: IsolatedStorageFileStream.CanWrite
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanWrite
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose(System.Boolean)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: IsolatedStorageFileStream.Dispose(Boolean)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose(Boolean)
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead(System.IAsyncResult)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: EndRead(IAsyncResult)
  nameWithType: IsolatedStorageFileStream.EndRead(IAsyncResult)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead(IAsyncResult)
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite(System.IAsyncResult)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: EndWrite(IAsyncResult)
  nameWithType: IsolatedStorageFileStream.EndWrite(IAsyncResult)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite(IAsyncResult)
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Flush()
  nameWithType: IsolatedStorageFileStream.Flush()
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush()
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush(System.Boolean)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Flush(Boolean)
  nameWithType: IsolatedStorageFileStream.Flush(Boolean)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush(Boolean)
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Handle
  nameWithType: IsolatedStorageFileStream.Handle
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsAsync
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: IsAsync
  nameWithType: IsolatedStorageFileStream.IsAsync
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsAsync
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Length
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Length
  nameWithType: IsolatedStorageFileStream.Length
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Lock(System.Int64,System.Int64)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Lock(Int64,Int64)
  nameWithType: IsolatedStorageFileStream.Lock(Int64,Int64)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Lock(Int64,Int64)
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Position
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Position
  nameWithType: IsolatedStorageFileStream.Position
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Position
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: IsolatedStorageFileStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Read(Byte[],Int32,Int32)
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.ReadByte
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: ReadByte()
  nameWithType: IsolatedStorageFileStream.ReadByte()
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.ReadByte()
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: SafeFileHandle
  nameWithType: IsolatedStorageFileStream.SafeFileHandle
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle
- uid: Microsoft.Win32.SafeHandles.SafeFileHandle
  parent: Microsoft.Win32.SafeHandles
  isExternal: false
  name: SafeFileHandle
  nameWithType: SafeFileHandle
  fullName: Microsoft.Win32.SafeHandles.SafeFileHandle
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: IsolatedStorageFileStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.SetLength(System.Int64)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: IsolatedStorageFileStream.SetLength(Int64)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.SetLength(Int64)
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Unlock(System.Int64,System.Int64)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Unlock(Int64,Int64)
  nameWithType: IsolatedStorageFileStream.Unlock(Int64,Int64)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Unlock(Int64,Int64)
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: IsolatedStorageFileStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Write(Byte[],Int32,Int32)
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.WriteByte(System.Byte)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: WriteByte(Byte)
  nameWithType: IsolatedStorageFileStream.WriteByte(Byte)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.WriteByte(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: IsolatedStorageFileStream
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: BeginRead
  nameWithType: IsolatedStorageFileStream.BeginRead
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: BeginWrite
  nameWithType: IsolatedStorageFileStream.BeginWrite
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanRead*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: CanRead
  nameWithType: IsolatedStorageFileStream.CanRead
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: CanSeek
  nameWithType: IsolatedStorageFileStream.CanSeek
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanWrite*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: CanWrite
  nameWithType: IsolatedStorageFileStream.CanWrite
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Dispose
  nameWithType: IsolatedStorageFileStream.Dispose
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: EndRead
  nameWithType: IsolatedStorageFileStream.EndRead
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: EndWrite
  nameWithType: IsolatedStorageFileStream.EndWrite
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Flush
  nameWithType: IsolatedStorageFileStream.Flush
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Handle
  nameWithType: IsolatedStorageFileStream.Handle
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsAsync*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: IsAsync
  nameWithType: IsolatedStorageFileStream.IsAsync
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Length*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Length
  nameWithType: IsolatedStorageFileStream.Length
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Lock*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Lock
  nameWithType: IsolatedStorageFileStream.Lock
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Position*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Position
  nameWithType: IsolatedStorageFileStream.Position
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Read*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Read
  nameWithType: IsolatedStorageFileStream.Read
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.ReadByte*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: ReadByte
  nameWithType: IsolatedStorageFileStream.ReadByte
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: SafeFileHandle
  nameWithType: IsolatedStorageFileStream.SafeFileHandle
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Seek*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Seek
  nameWithType: IsolatedStorageFileStream.Seek
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.SetLength*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: SetLength
  nameWithType: IsolatedStorageFileStream.SetLength
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Unlock*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Unlock
  nameWithType: IsolatedStorageFileStream.Unlock
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Write*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Write
  nameWithType: IsolatedStorageFileStream.Write
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.WriteByte*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: WriteByte
  nameWithType: IsolatedStorageFileStream.WriteByte
