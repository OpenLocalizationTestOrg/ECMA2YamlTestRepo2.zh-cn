### YamlMime:ManagedReference
items:
- uid: System.Timers.Timer
  id: Timer
  children:
  - System.Timers.Timer.#ctor
  - System.Timers.Timer.#ctor(System.Double)
  - System.Timers.Timer.AutoReset
  - System.Timers.Timer.BeginInit
  - System.Timers.Timer.Close
  - System.Timers.Timer.Dispose(System.Boolean)
  - System.Timers.Timer.Elapsed
  - System.Timers.Timer.Enabled
  - System.Timers.Timer.EndInit
  - System.Timers.Timer.Interval
  - System.Timers.Timer.Site
  - System.Timers.Timer.Start
  - System.Timers.Timer.Stop
  - System.Timers.Timer.SynchronizingObject
  langs:
  - csharp
  name: Timer
  nameWithType: Timer
  fullName: System.Timers.Timer
  type: Class
  summary: "设定的间隔，用于生成重复事件的选项之后生成事件。       若要浏览此类型的.NET Framework 源代码，请参阅[引用源](http://referencesource.microsoft.com/#System/services/timers/system/timers/Timer.cs#897683f27faba082)。"
  remarks: "> [!NOTE]1> 要查看此类型的.NET Framework 源代码，请参阅[引用源](http://referencesource.microsoft.com/#System/services/timers/system/timers/Timer.cs#897683f27faba082)。 你可以浏览源代码联机，请下载离线查看的引用并在调试; 过程中逐步执行源 （包括修补程序和更新）请参阅[说明](http://referencesource.microsoft.com/)。       Timer 组件是一种基于服务器的计时器引发<xref:System.Timers.Timer.Elapsed>千分之几秒数之后应用程序中的事件<xref:System.Timers.Timer.Interval%2A>属性已过。</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed> 你可以配置要引发事件只需一次或重复使用的计时器对象<xref:System.Timers.Timer.AutoReset%2A>属性。</xref:System.Timers.Timer.AutoReset%2A> 通常，计时器对象声明在类级别，使其保持在范围内，只要需要它。 然后可处理其<xref:System.Timers.Timer.Elapsed>事件，以便提供常规处理。</xref:System.Timers.Timer.Elapsed> 例如，假设你有必须保持的关键服务器运行每周 7 天、 每天 24 小时。 你可以创建使用计时器对象以定期检查的服务器，并确保系统处于启动并正在运行的服务。 如果系统未响应，该服务可能会尝试以重新启动服务器，或者通知管理员。      1> [!IMPORTANT]&1;> 计时器类是在仅.NET Framework 中可用。 它不包含在.NET 标准库，并在其他平台，例如，.NET 核心或通用 Windows 平台上不可用。 在这些平台上，以及跨所有.NET 平台的可移植性，应使用<xref:System.Threading.Timer?displayProperty=fullName>类。</xref:System.Threading.Timer?displayProperty=fullName>       此类型实现<xref:System.IDisposable>接口。</xref:System.IDisposable> 完成后使用类型的操作后，你应释放类型直接或间接。 若要直接释放类型，调用其<xref:System.IDisposable.Dispose%2A>中的方法`try` / `catch`块。</xref:System.IDisposable.Dispose%2A> 若要间接释放类型，使用一种语言构造如`using`（在 C# 中) 或`Using`（在 Visual Basic 中)。 有关详细信息，请参阅中的&quot;使用实现 IDisposable 的对象&quot;部分<xref:System.IDisposable>接口主题。</xref:System.IDisposable>       基于服务器的计时器类用于在多线程环境中的工作线程。 服务器的计时器可以在线程之间移动来处理引发<xref:System.Timers.Timer.Elapsed>事件，从而导致比 Windows 计时器在时间上引发事件的更准确。</xref:System.Timers.Timer.Elapsed>       Timer 组件引发<xref:System.Timers.Timer.Elapsed>基于的值 （以毫秒为单位） 的事件<xref:System.Timers.Timer.Interval%2A>属性。</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed> 你可以处理此事件以执行所需的处理。 例如，假设你有一个联机的销售应用程序可连续发布到数据库的销售订单。 编译为传送的说明进行操作的服务进行的订单，而不是单独处理每个订单批处理操作。 你可以使用计时器启动批处理每隔 30 分钟。      1> [!IMPORTANT]&1;> System.Timers.Timer 类具有相同的系统时钟的分辨率。 这意味着，<xref:System.Timers.Timer.Elapsed>事件将在系统时钟的分辨率如果定义的间隔触发<xref:System.Timers.Timer.Interval%2A>属性小于系统时钟的分辨率。</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed> 有关详细信息，请参阅<xref:System.Timers.Timer.Interval%2A>属性。</xref:System.Timers.Timer.Interval%2A>       当<xref:System.Timers.Timer.AutoReset%2A>设置为`false`，计时器对象引发<xref:System.Timers.Timer.Elapsed>事件一次，第一个之后<xref:System.Timers.Timer.Interval%2A>过后。</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.AutoReset%2A> 若要保留引发<xref:System.Timers.Timer.Elapsed>事件定期在定义间隔<xref:System.Timers.Timer.Interval%2A>，将其设置<xref:System.Timers.Timer.AutoReset%2A>到`true`，这是默认值。</xref:System.Timers.Timer.AutoReset%2A> </xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed>       Timer 组件捕获并禁止显示引发的事件处理程序的所有异常<xref:System.Timers.Timer.Elapsed>事件。</xref:System.Timers.Timer.Elapsed> 此行为将发生在.NET framework 的未来版本中的更改。 但请注意，这不为 true 的事件处理程序，以异步方式执行，并包括`await`运算符 （在 C# 中) 或`Await`运算符 （在 Visual Basic 中)。 如下面的示例所示，这些事件处理程序中引发的异常会传播回调用线程。 有关异步方法中引发的异常的详细信息，请参阅[异常处理](~/add/includes/ajax-current-ext-md.md)。       [!code-cs[System.Timers.Timer#3](~/add/codesnippet/csharp/t-system.timers.timer_1.cs)][!code-vb[System.Timers.Timer#3](~/add/codesnippet/visualbasic/t-system.timers.timer_1.vb) ]如果<xref:System.Timers.Timer.SynchronizingObject%2A>属性是`null`、<xref:System.Timers.Timer.Elapsed>上引发事件<xref:System.Threading.ThreadPool>线程。</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.SynchronizingObject%2A>   如果不需要处理<xref:System.Timers.Timer.Elapsed>事件持续时间超过<xref:System.Timers.Timer.Interval%2A>，可能在另一台再次引发此事件<xref:System.Threading.ThreadPool>线程。</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed> 在此情况下，事件处理程序应该是可重入。      1> [!NOTE]&1;> 事件处理方法可能在一个线程上运行另一个线程调用的同时<xref:System.Timers.Timer.Stop%2A>方法或设置<xref:System.Timers.Timer.Enabled%2A>属性`false`。</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Stop%2A> 这可能会导致<xref:System.Timers.Timer.Elapsed>后停止计时器引发事件。</xref:System.Timers.Timer.Elapsed> 代码示例<xref:System.Timers.Timer.Stop%2A>方法演示一种方法，以避免此争用情况。</xref:System.Timers.Timer.Stop%2A>       即使<xref:System.Timers.Timer.SynchronizingObject%2A>不`null`，<xref:System.Timers.Timer.Elapsed>事件可能会发生后<xref:System.Timers.Timer.Dispose%2A>或<xref:System.Timers.Timer.Stop%2A>调用方法后或<xref:System.Timers.Timer.Enabled%2A>属性已设置为`false`，这是因为信号以引发<xref:System.Timers.Timer.Elapsed>事件总是排队等待线程池线程上执行。</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Stop%2A> </xref:System.Timers.Timer.Dispose%2A> </xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.SynchronizingObject%2A> 解决此争用条件设置一个标志，通知的事件处理程序是一种方法<xref:System.Timers.Timer.Elapsed>忽略后续的事件的事件。</xref:System.Timers.Timer.Elapsed>       如果与用户界面元素，如窗体或控件，使用计时器类而无需将计时器在该用户界面元素上的分配的窗体或控件包含计时器设置为<xref:System.Timers.Timer.SynchronizingObject%2A>属性，以便将事件封送到的用户界面线程。</xref:System.Timers.Timer.SynchronizingObject%2A>       实例的计时器的默认属性值的列表，请参阅<xref:System.Timers.Timer.%23ctor%2A>构造函数。</xref:System.Timers.Timer.%23ctor%2A>      1> [!TIP]&1;> 请注意，.NET Framework 类库包括名为的四个类`Timer`，每个的它提供不同的功能: >>-计时器 （本主题）︰ 按固定的间隔触发事件。 类旨在用作基于服务器或多线程环境中; 中的服务组件它没有用户界面，并且不在运行时可见。   1>- <xref:System.Threading.Timer?displayProperty=fullName>︰ 固定时间间隔线程池线程上执行的单个回调方法。</xref:System.Threading.Timer?displayProperty=fullName> 当计时器实例化，并且不能更改定义回调方法。 Timer 类，如同此类被适用于用作基于服务器或多线程环境中; 中的服务组件它没有用户界面，并且不在运行时可见。   1>- <xref:System.Windows.Forms.Timer?displayProperty=fullName>︰ 按固定的间隔触发事件的 Windows 窗体组件。</xref:System.Windows.Forms.Timer?displayProperty=fullName> 组件没有用户界面，并旨在在单线程环境中使用。   1>- <xref:System.Web.UI.Timer?displayProperty=fullName>︰ 在按固定间隔执行异步或同步网页回发的 ASP.NET 组件。</xref:System.Web.UI.Timer?displayProperty=fullName>"
  example:
  - "The following example instantiates a `System.Timers.Timer` object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2,000 milliseconds), sets up an event handler for the  event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cs[System.Timers.Timer#2](~/add/codesnippet/csharp/t-system.timers.timer_2.cs)]\n [!code-vb[System.Timers.Timer#2](~/add/codesnippet/visualbasic/t-system.timers.timer_2.vb)]"
  syntax:
    content: >-
      [System.ComponentModel.DefaultEvent("Elapsed")]

      [System.ComponentModel.DefaultProperty("Interval")]

      public class Timer : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements:
  - System.ComponentModel.ISupportInitialize
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.ToString
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Timers.Timer.#ctor
  id: '#ctor'
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Timer()
  nameWithType: Timer.Timer()
  fullName: System.Timers.Timer.Timer()
  type: Constructor
  assemblies:
  - System
  namespace: System.Timers
  summary: "初始化的新实例<xref href=&quot;System.Timers.Timer&quot;></xref>类，并将所有属性都设置为其初始值。"
  remarks: "下表显示<xref:System.Timers.Timer>.</xref:System.Timers.Timer>实例的初始属性的值      |属性 |初始值 |  |--------------|-------------------|  |<xref:System.Timers.Timer.AutoReset%2A>|`true`|  |<xref:System.Timers.Timer.Enabled%2A>|`false`|  |<xref:System.Timers.Timer.Interval%2A>|&100; 毫秒 |  |<xref:System.Timers.Timer.SynchronizingObject%2A>|空引用 (`Nothing`在 Visual Basic 中)。 |</xref:System.Timers.Timer.SynchronizingObject%2A> </xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.AutoReset%2A>"
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cpp[System.Timers.Timer#1](~/add/codesnippet/cpp/m-system.timers.timer.sh_1_1.cpp)]\n [!code-cs[System.Timers.Timer#1](~/add/codesnippet/csharp/m-system.timers.timer.sh_1_1.cs)]\n [!code-vb[System.Timers.Timer#1](~/add/codesnippet/visualbasic/m-system.timers.timer.sh_1_1.vb)]"
  syntax:
    content: public Timer ();
    parameters: []
  overload: System.Timers.Timer.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.#ctor(System.Double)
  id: '#ctor(System.Double)'
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Timer(Double)
  nameWithType: Timer.Timer(Double)
  fullName: System.Timers.Timer.Timer(Double)
  type: Constructor
  assemblies:
  - System
  namespace: System.Timers
  summary: "初始化的新实例<xref href=&quot;System.Timers.Timer&quot;></xref>类，并设置<xref:System.Timers.Timer.Interval*>属性设置为指定的毫秒数。</xref:System.Timers.Timer.Interval*>"
  remarks: "此构造函数设置<xref:System.Timers.Timer.Interval%2A>属性的新的计时器实例，但不会启用计时器。</xref:System.Timers.Timer.Interval%2A>"
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cs[System.Timers.Timer#3](~/add/codesnippet/csharp/m-system.timers.timer.sh_0_1.cs)]\n [!code-vb[System.Timers.Timer#3](~/add/codesnippet/visualbasic/m-system.timers.timer.sh_0_1.vb)]"
  syntax:
    content: public Timer (double interval);
    parameters:
    - id: interval
      type: System.Double
      description: "以毫秒为单位，两个事件之间的时间。 值必须大于零且小于或等于&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;。"
  overload: System.Timers.Timer.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "值<code> interval </code>参数是否小于或等于零，或者大于&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;。"
  platform:
  - net462
- uid: System.Timers.Timer.AutoReset
  id: AutoReset
  parent: System.Timers.Timer
  langs:
  - csharp
  name: AutoReset
  nameWithType: Timer.AutoReset
  fullName: System.Timers.Timer.AutoReset
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "获取或设置一个布尔值，该值指示是否<xref href=&quot;System.Timers.Timer&quot;></xref>应引发<xref href=&quot;System.Timers.Timer.Elapsed&quot;></xref>仅一次事件 (<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>) 或重复 (<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>)。"
  remarks: "如果<xref:System.Timers.Timer>时已经启用<xref:System.Timers.Timer.Start%2A>方法被调用时，时间间隔重置。</xref:System.Timers.Timer.Start%2A> </xref:System.Timers.Timer> 如果 AutoReset `false`、<xref:System.Timers.Timer.Start%2A>方法必须调用以便再次开始计数。</xref:System.Timers.Timer.Start%2A>       将间隔重置会影响<xref:System.Timers.Timer.Elapsed>引发事件。</xref:System.Timers.Timer.Elapsed> 例如，如果将间隔设置为 5 秒，然后设置<xref:System.Timers.Timer.Enabled%2A>属性`true`，计数开始时间<xref:System.Timers.Timer.Enabled%2A>设置。</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Enabled%2A> 如果为计数时 3 秒、 10 秒重置间隔<xref:System.Timers.Timer.Elapsed>第一次之后的 13 秒引发事件<xref:System.Timers.Timer.Enabled%2A>属性设置为`true`。</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Elapsed>"
  example:
  - "The following example creates a <xref:System.Timers.Timer> whose <xref:System.Timers.Timer.Elapsed> event fires after 1.5 seconds. Its event handler then displays \"Hello World!\" on the console.  \n  \n [!code-vb[Classic Timer.Timer1 Example#1](~/add/codesnippet/visualbasic/p-system.timers.timer.au_1.vb)]\n [!code-cs[Classic Timer.Timer1 Example#1](~/add/codesnippet/csharp/p-system.timers.timer.au_1.cs)]\n [!code-cpp[Classic Timer.Timer1 Example#1](~/add/codesnippet/cpp/p-system.timers.timer.au_1.cpp)]"
  syntax:
    content: public bool AutoReset { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Timers.Timer&quot;></xref>应引发<xref href=&quot;System.Timers.Timer.Elapsed&quot;></xref>事件间隔已过时; 每个时间<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>如果它应引发<xref href=&quot;System.Timers.Timer.Elapsed&quot;></xref>事件仅在首次后的时间间隔过后。 默认值是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。"
  overload: System.Timers.Timer.AutoReset*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.BeginInit
  id: BeginInit
  parent: System.Timers.Timer
  langs:
  - csharp
  name: BeginInit()
  nameWithType: Timer.BeginInit()
  fullName: System.Timers.Timer.BeginInit()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "开始运行时初始化<xref href=&quot;System.Timers.Timer&quot;></xref>用于窗体或由另一个组件使用。"
  remarks: "[!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)]设计环境使用此方法来启动一个组件，窗体或由另一个组件使用的初始化。 <xref:System.Timers.Timer.EndInit%2A>方法初始化已结束。</xref:System.Timers.Timer.EndInit%2A> 使用 BeginInit 和<xref:System.Timers.Timer.EndInit%2A>方法阻止控件完全初始化之前使用。</xref:System.Timers.Timer.EndInit%2A>"
  syntax:
    content: public void BeginInit ();
    parameters: []
  overload: System.Timers.Timer.BeginInit*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Close
  id: Close
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Close()
  nameWithType: Timer.Close()
  fullName: System.Timers.Timer.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "释放使用的资源<xref href=&quot;System.Timers.Timer&quot;> </xref>。"
  remarks: "Close 方法反过来调用`Dispose`方法。"
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Timers.Timer.Close*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: Timer.Dispose(Boolean)
  fullName: System.Timers.Timer.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "释放由当前使用的所有资源<xref href=&quot;System.Timers.Timer&quot;> </xref>。"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要释放托管和非托管资源;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>若要仅释放非托管的资源。"
  overload: System.Timers.Timer.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Elapsed
  id: Elapsed
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Elapsed
  nameWithType: Timer.Elapsed
  fullName: System.Timers.Timer.Elapsed
  type: Event
  assemblies:
  - System
  namespace: System.Timers
  summary: "达到间隔时发生。"
  remarks: "如果引发已用时间事件<xref:System.Timers.Timer.Enabled%2A>属性是`true`由定义的时间间隔 （以毫秒为单位）<xref:System.Timers.Timer.Interval%2A>属性经历。</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Enabled%2A> 如果<xref:System.Timers.Timer.AutoReset%2A>属性是`true`，由定义的时间间隔重复引发该事件<xref:System.Timers.Timer.Interval%2A>属性; 否则，引发该事件仅一次，第一次<xref:System.Timers.Timer.Interval%2A>值经历。</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.AutoReset%2A>       如果<xref:System.Timers.Timer.Interval%2A>后设置<xref:System.Timers.Timer>已启动，会重置计数。</xref:System.Timers.Timer> </xref:System.Timers.Timer.Interval%2A> 例如，如果将间隔设置为 5 秒，然后设置<xref:System.Timers.Timer.Enabled%2A>到`true`，计数开始时间<xref:System.Timers.Timer.Enabled%2A>设置。</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Enabled%2A> 如果将间隔重置为 10 秒计数为 3 秒时，已用时间事件引发第一次之后的 13 秒<xref:System.Timers.Timer.Enabled%2A>已设置为`true`。</xref:System.Timers.Timer.Enabled%2A>       如果<xref:System.Timers.Timer.SynchronizingObject%2A>属性是`null`，已用时间事件引发上<xref:System.Threading.ThreadPool>线程。</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.SynchronizingObject%2A> 如果已用时间事件的处理持续时间比<xref:System.Timers.Timer.Interval%2A>，可能在另一台再次引发此事件<xref:System.Threading.ThreadPool>线程。</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.Interval%2A> 在此情况下，事件处理程序应该是可重入。      1> [!NOTE]&1;> 事件处理方法可能在一个线程上运行另一个线程调用的同时<xref:System.Timers.Timer.Stop%2A>方法或设置<xref:System.Timers.Timer.Enabled%2A>属性`false`。</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Stop%2A> 这可能会导致引发后停止计时器已用时间事件。 代码示例<xref:System.Timers.Timer.Stop%2A>方法演示一种方法，以避免此争用情况。</xref:System.Timers.Timer.Stop%2A>       即使<xref:System.Timers.Timer.SynchronizingObject%2A>不`null`，经过事件可能会发生后<xref:System.Timers.Timer.Dispose%2A>或<xref:System.Timers.Timer.Stop%2A>调用方法后或<xref:System.Timers.Timer.Enabled%2A>属性已设置为`false`，因为引发已用时间事件的信号总是排队等待线程池线程上执行。</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Stop%2A> </xref:System.Timers.Timer.Dispose%2A> </xref:System.Timers.Timer.SynchronizingObject%2A> 若要解决此争用问题的一种方法是将设置一个标志，通知的事件处理程序已用时间事件忽略后续的事件。       <xref:System.Timers.Timer>组件捕获并禁止显示引发的事件处理程序已用时间事件的所有异常。</xref:System.Timers.Timer> 此行为将发生在.NET framework 的未来版本中的更改。"
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its Elapsed event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cpp[System.Timers.Timer#1](~/add/codesnippet/cpp/e-system.timers.timer.el_1.cpp)]\n [!code-cs[System.Timers.Timer#1](~/add/codesnippet/csharp/e-system.timers.timer.el_1.cs)]\n [!code-vb[System.Timers.Timer#1](~/add/codesnippet/visualbasic/e-system.timers.timer.el_1.vb)]"
  syntax:
    content: public event System.Timers.ElapsedEventHandler Elapsed;
    return:
      type: System.Timers.ElapsedEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Enabled
  id: Enabled
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Enabled
  nameWithType: Timer.Enabled
  fullName: System.Timers.Timer.Enabled
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "获取或设置一个值，该值指示是否<xref href=&quot;System.Timers.Timer&quot;></xref>应引发<xref href=&quot;System.Timers.Timer.Elapsed&quot;></xref>事件。"
  remarks: "将 Enabled 设置为`true`等同于调用<xref:System.Timers.Timer.Start%2A>，而到启用设置`false`等同于调用<xref:System.Timers.Timer.Stop%2A>.</xref:System.Timers.Timer.Stop%2A> </xref:System.Timers.Timer.Start%2A>      1> [!NOTE]&1;> 信号以引发<xref:System.Timers.Timer.Elapsed>事件始终上排队以便执行<xref:System.Threading.ThreadPool>线程。</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.Elapsed> 这可能会导致<xref:System.Timers.Timer.Elapsed>后的 Enabled 属性设置为要引发事件`false`。</xref:System.Timers.Timer.Elapsed> 代码示例<xref:System.Timers.Timer.Stop%2A>方法演示一种方法要解决此争用条件。</xref:System.Timers.Timer.Stop%2A>       如果已启用设置为`true`和<xref:System.Timers.Timer.AutoReset%2A>设置为`false`、<xref:System.Timers.Timer>引发<xref:System.Timers.Timer.Elapsed>事件仅后第一次间隔结束。</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer> </xref:System.Timers.Timer.AutoReset%2A>       如果间隔后设置<xref:System.Timers.Timer>已启动，会重置计数。</xref:System.Timers.Timer> 例如，如果将间隔设置为 5 秒，然后将的 Enabled 属性设置为`true`，计数开始设置已启用的时间。 如果为 10 秒计数为 3 秒时重置间隔<xref:System.Timers.Timer.Elapsed>第一次 13 秒后已启用已设置为引发事件`true`。</xref:System.Timers.Timer.Elapsed>      1> [!NOTE]&1;> 某些可视化设计器，如 Microsoft Visual Studio 中的 Enabled 属性设置为`true`插入新<xref:System.Timers.Timer>。</xref:System.Timers.Timer>时"
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2000 milliseconds), sets up an event handler for the  event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cpp[System.Timers.Timer#1](~/add/codesnippet/cpp/p-system.timers.timer.en_1.cpp)]\n [!code-cs[System.Timers.Timer#1](~/add/codesnippet/csharp/p-system.timers.timer.en_1.cs)]\n [!code-vb[System.Timers.Timer#1](~/add/codesnippet/visualbasic/p-system.timers.timer.en_1.vb)]"
  syntax:
    content: public bool Enabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Timers.Timer&quot;></xref>应引发<xref href=&quot;System.Timers.Timer.Elapsed&quot;></xref>事件; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Timers.Timer.Enabled*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "无法设置此属性，因为处理计时器。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<xref:System.Timers.Timer.Interval*>属性设置为一个值大于&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;启用计时器之前。</xref:System.Timers.Timer.Interval*>"
  platform:
  - net462
- uid: System.Timers.Timer.EndInit
  id: EndInit
  parent: System.Timers.Timer
  langs:
  - csharp
  name: EndInit()
  nameWithType: Timer.EndInit()
  fullName: System.Timers.Timer.EndInit()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "结束的运行时初始化<xref href=&quot;System.Timers.Timer&quot;></xref>用于窗体或由另一个组件使用。"
  remarks: "[!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)]设计环境使用此方法来结束用于窗体或由另一个组件使用的组件的初始化。 <xref:System.Timers.Timer.BeginInit%2A>方法开始初始化。</xref:System.Timers.Timer.BeginInit%2A> 使用<xref:System.Timers.Timer.BeginInit%2A>和 EndInit 方法阻止控件完全初始化之前使用。</xref:System.Timers.Timer.BeginInit%2A>"
  syntax:
    content: public void EndInit ();
    parameters: []
  overload: System.Timers.Timer.EndInit*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Interval
  id: Interval
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Interval
  nameWithType: Timer.Interval
  fullName: System.Timers.Timer.Interval
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "获取或设置的间隔，以毫秒为单位，引发<xref href=&quot;System.Timers.Timer.Elapsed&quot;></xref>事件。"
  remarks: "你使用的间隔属性来确定的频率<xref:System.Timers.Timer.Elapsed>激发事件。</xref:System.Timers.Timer.Elapsed> 因为<xref:System.Timers.Timer>类取决于系统时钟，它同时具有相同的系统时钟的分辨率。</xref:System.Timers.Timer> 这意味着，<xref:System.Timers.Timer.Elapsed>事件将激发的时间间隔的间隔属性是否早于系统时钟的分辨率定义的系统时钟的分辨率。</xref:System.Timers.Timer.Elapsed> 下面的示例将 Interval 属性设置为 5 毫秒。 在上运行时[!INCLUDE[win7](~/add/includes/win7-md.md)]系统的系统时钟的分辨率大约 15 毫秒，事件将触发大约每隔 15 毫秒，而不是每隔 5 毫秒。       [!code-cs[System.Timers.Timer.Interval#1](~/add/codesnippet/csharp/p-system.timers.timer.in_1.cs)][!code-vb[System.Timers.Timer.Interval#1](~/add/codesnippet/visualbasic/p-system.timers.timer.in_1.vb) ]可以使用下面的代码以确定当前系统上的系统时钟的分辨率︰ [!code-cs [System.Timers.Timer.Interval#2](~/add/codesnippet/csharp/p-system.timers.timer.in_2.cs)][!code-vb[System.Timers.Timer.Interval#2](~/add/codesnippet/visualbasic/p-system.timers.timer.in_2.vb) ]如果你的应用需要比提供的更大的分辨率<xref:System.Timers.Timer>类或使用高分辨率的多媒体计时器; 请参阅系统时钟[如何︰ 使用高分辨率计时器](http://msdn.microsoft.com/library/aa964692.aspx)。</xref:System.Timers.Timer>           如果间隔后设置<xref:System.Timers.Timer>已启动，会重置计数。</xref:System.Timers.Timer> 例如，如果将间隔设置为 5 秒，然后设置<xref:System.Timers.Timer.Enabled%2A>属性`true`，计数开始时间<xref:System.Timers.Timer.Enabled%2A>设置。</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Enabled%2A> 如果为 10 秒计数为 3 秒时重置间隔<xref:System.Timers.Timer.Elapsed>第一次之后的 13 秒引发事件<xref:System.Timers.Timer.Enabled%2A>已设置为`true`。</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Elapsed>       如果<xref:System.Timers.Timer.Enabled%2A>设置为`true`和<xref:System.Timers.Timer.AutoReset%2A>设置为`false`、<xref:System.Timers.Timer>引发<xref:System.Timers.Timer.Elapsed>事件仅后第一次间隔结束。</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer> </xref:System.Timers.Timer.AutoReset%2A> </xref:System.Timers.Timer.Enabled%2A> <xref:System.Timers.Timer.Enabled%2A>然后将设置为`false`。</xref:System.Timers.Timer.Enabled%2A>      1> [!NOTE]&1;> 如果<xref:System.Timers.Timer.Enabled%2A>和<xref:System.Timers.Timer.AutoReset%2A>都设置为`false`，和计时器以前已启用，设置间隔属性会导致<xref:System.Timers.Timer.Elapsed>事件被引发一次，就像<xref:System.Timers.Timer.Enabled%2A>属性必须设置为`true`。</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.AutoReset%2A> </xref:System.Timers.Timer.Enabled%2A> 若要将间隔设置而不会引发该事件，可以暂时设置<xref:System.Timers.Timer.Enabled%2A>属性`true`、 将间隔属性设置为所需的时间间隔，并立即将<xref:System.Timers.Timer.Enabled%2A>属性改回`false`。</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Enabled%2A>"
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cpp[System.Timers.Timer#1](~/add/codesnippet/cpp/p-system.timers.timer.in_3.cpp)]\n [!code-cs[System.Timers.Timer#1](~/add/codesnippet/csharp/p-system.timers.timer.in_3.cs)]\n [!code-vb[System.Timers.Timer#1](~/add/codesnippet/visualbasic/p-system.timers.timer.in_3.vb)]"
  syntax:
    content: public double Interval { get; set; }
    return:
      type: System.Double
      description: "时间，以毫秒为单位，之间<xref href=&quot;System.Timers.Timer.Elapsed&quot;></xref>事件。 值必须大于零，且小于或等于&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;。 默认值为 100 毫秒。"
  overload: System.Timers.Timer.Interval*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "间隔小于或等于零。       -或-间隔大于&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;，和当前启用计时器。 （如果当前未启用计时器，则不引发异常之前它将变为启用状态。）"
  platform:
  - net462
- uid: System.Timers.Timer.Site
  id: Site
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Site
  nameWithType: Timer.Site
  fullName: System.Timers.Timer.Site
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "获取或设置绑定的站点<xref href=&quot;System.Timers.Timer&quot;></xref>到其容器在设计模式下。"
  remarks: "站点绑定<xref:System.ComponentModel.Component>到<xref:System.ComponentModel.Container>和启用它们之间的通信，以及提供有关要管理其组件的容器的一种方法。</xref:System.ComponentModel.Container> </xref:System.ComponentModel.Component>"
  syntax:
    content: public override System.ComponentModel.ISite Site { get; set; }
    return:
      type: System.ComponentModel.ISite
      description: "<xref href=&quot;System.ComponentModel.ISite&quot;> </xref>接口，表示将绑定的站点<xref href=&quot;System.Timers.Timer&quot;></xref>到其容器的对象。"
  overload: System.Timers.Timer.Site*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Start
  id: Start
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Start()
  nameWithType: Timer.Start()
  fullName: System.Timers.Timer.Start()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "开始引发<xref href=&quot;System.Timers.Timer.Elapsed&quot;></xref>事件通过设置<xref:System.Timers.Timer.Enabled*>到<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。</xref:System.Timers.Timer.Enabled*>"
  remarks: "如果调用 Start 和<xref:System.Timers.Timer.AutoReset%2A>设置为`false`、<xref:System.Timers.Timer>引发<xref:System.Timers.Timer.Elapsed>事件仅后第一次间隔结束。</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer> </xref:System.Timers.Timer.AutoReset%2A> 如果调用 Start 和<xref:System.Timers.Timer.AutoReset%2A>是`true`、<xref:System.Timers.Timer>引发<xref:System.Timers.Timer.Elapsed>事件第一个时间间隔和经过继续在指定的时间间隔引发事件。</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer> </xref:System.Timers.Timer.AutoReset%2A>       你还可以通过设置启动计时<xref:System.Timers.Timer.Enabled%2A>到`true`。</xref:System.Timers.Timer.Enabled%2A>      1> [!NOTE]&1;> 如果<xref:System.Timers.Timer.AutoReset%2A>是`false`，为了再次开始计数，必须调用 Start 方法。</xref:System.Timers.Timer.AutoReset%2A>       对计时器处于启用状态时的启动方法的调用不起作用。"
  syntax:
    content: public void Start ();
    parameters: []
  overload: System.Timers.Timer.Start*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<xref href=&quot;System.Timers.Timer&quot;> </xref>等于或大于使其时间间隔创建&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt; + 1 或被设置为一个时间间隔小于零。"
  platform:
  - net462
- uid: System.Timers.Timer.Stop
  id: Stop
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Stop()
  nameWithType: Timer.Stop()
  fullName: System.Timers.Timer.Stop()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "停止引发<xref href=&quot;System.Timers.Timer.Elapsed&quot;></xref>事件通过设置<xref:System.Timers.Timer.Enabled*>到<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.Timers.Timer.Enabled*>"
  remarks: "您也可以通过设置终止计时<xref:System.Timers.Timer.Enabled%2A>到`false`。</xref:System.Timers.Timer.Enabled%2A>      1> [!NOTE]&1;> 信号以引发<xref:System.Timers.Timer.Elapsed>事件始终上排队以便执行<xref:System.Threading.ThreadPool>线程，因此调用停止方法在另一个线程上运行的同时，事件处理方法可能会运行一个线程。</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.Elapsed> 这可能会导致<xref:System.Timers.Timer.Elapsed>调用停止方法后引发事件。</xref:System.Timers.Timer.Elapsed> 下一节中的代码示例演示一个方法，若要解决此争用条件。"
  example:
  - "The following example instantiates a `System.Timers.Timer` object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2,000 milliseconds), sets up an event handler for the  event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised. When the user presses the Enter key, the application calls the  Stop method before terminating the application.  \n  \n [!code-cs[System.Timers.Timer#2](~/add/codesnippet/csharp/m-system.timers.timer.stop_1.cs)]\n [!code-vb[System.Timers.Timer#2](~/add/codesnippet/visualbasic/m-system.timers.timer.stop_1.vb)]  \n  \n The following code example shows one way to prevent the thread that calls the Stop method from continuing until a currently executing <xref:System.Timers.Timer.Elapsed> event ends, and also to prevent two <xref:System.Timers.Timer.Elapsed> events from executing the event handler at the same time (often referred to as reentrancy).  \n  \n The example executes 100 test runs. Each time the test is run, the timer is started with an interval of 150 milliseconds. The event handler uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method to simulate a task that randomly varies in length from 50 to 200 milliseconds. The test method also starts a control thread that waits for a second and then stops the timer. If an event is being handled when the control thread stops the timer, the control thread must wait until the event is finished before proceeding.  \n  \n The <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29?displayProperty=fullName> method overload is used to avoid reentrancy and to prevent the control thread from continuing until an executing event ends. The event handler uses the <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> method to set a control variable to 1, but only if the value is currently zero. This is an atomic operation. If the return value is zero, the control variable has been set to 1 and the event handler proceeds. If the return value is non-zero, the event is simply discarded to avoid reentrancy. (If it were necessary to execute every event, the <xref:System.Threading.Monitor> class would be a better way to synchronize the events.) When the event handler ends, it sets the control variable back to zero. The example records the total number of events that executed, that were discarded because of reentrancy, and that occurred after the Stop method was called.  \n  \n The control thread uses the <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> method to set the control variable to -1 (minus one), but only if the value is currently zero. If the atomic operation returns non-zero, an event is currently executing. The control thread waits and tries again. The example records the number of times the control thread had to wait for an event to finish.  \n  \n [!code-cs[Timer.Stop#1](~/add/codesnippet/csharp/m-system.timers.timer.stop_2.cs)]\n [!code-vb[Timer.Stop#1](~/add/codesnippet/visualbasic/m-system.timers.timer.stop_2.vb)]"
  syntax:
    content: public void Stop ();
    parameters: []
  overload: System.Timers.Timer.Stop*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.SynchronizingObject
  id: SynchronizingObject
  parent: System.Timers.Timer
  langs:
  - csharp
  name: SynchronizingObject
  nameWithType: Timer.SynchronizingObject
  fullName: System.Timers.Timer.SynchronizingObject
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "获取或设置用于封送时间隔过后，将发出的事件处理程序调用的对象。"
  remarks: "SynchronizingObject 时`null`，处理的方法<xref:System.Timers.Timer.Elapsed>在系统线程池中的线程上调用事件。</xref:System.Timers.Timer.Elapsed> 系统线程池的详细信息，请参阅<xref:System.Threading.ThreadPool>。</xref:System.Threading.ThreadPool>       当<xref:System.Timers.Timer.Elapsed>由可视化的 Windows 窗体组件，如按钮，可能会引发异常或只是结果可能无法通过系统线程池访问组件处理事件。</xref:System.Timers.Timer.Elapsed> 通过设置 SynchronizingObject 到 Windows 窗体组件时，这会导致处理的方法来避免这种效果<xref:System.Timers.Timer.Elapsed>事件创建该组件在同一线程上调用。</xref:System.Timers.Timer.Elapsed>      1> [!NOTE]&1;> 即使 SynchronizingObject 属性不是`null`，<xref:System.Timers.Timer.Elapsed>事件可能会发生后<xref:System.Timers.Timer.Dispose%2A>或<xref:System.Timers.Timer.Stop%2A>调用方法后或<xref:System.Timers.Timer.Enabled%2A>属性已设置为`false`，这是因为信号以引发<xref:System.Timers.Timer.Elapsed>事件总是排队等待线程池线程上执行。</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Stop%2A> </xref:System.Timers.Timer.Dispose%2A> </xref:System.Timers.Timer.Elapsed> 解决此争用条件设置一个标志，通知的事件处理程序是一种方法<xref:System.Timers.Timer.Elapsed>忽略后续的事件的事件。</xref:System.Timers.Timer.Elapsed>       如果<xref:System.Timers.Timer>是在 Windows 窗体设计器中使用在 Visual Studio 内，SynchronizingObject 将自动设置为该控件包含<xref:System.Timers.Timer>.</xref:System.Timers.Timer> </xref:System.Timers.Timer> 例如，如果你将放置<xref:System.Timers.Timer>的设计器上`Form1`(其继承自<xref:System.Windows.Forms.Form>) 的 SynchronizingObject 属性<xref:System.Timers.Timer>设置为的实例`Form1`。</xref:System.Timers.Timer> </xref:System.Windows.Forms.Form> </xref:System.Timers.Timer>"
  example:
  - "The following example is a Windows Forms app that serves as a very simple text file editor. When the text in the text box has not been saved, the app asks the user at one-minute intervals whether he or she wants to save the contents of the text box.  To do this, the <xref:System.Timers.Timer.Interval%2A> property is set to one minute (60,000 milliseconds), and the SynchronizingObject property is set to the <xref:System.Windows.Forms.Form> object.  \n  \n [!code-cs[System.Timers.Timer.SynchronizingObject#1](~/add/codesnippet/csharp/SynchronizingObjectCS1/Form1.cs#1)]\n [!code-vb[System.Timers.Timer.SynchronizingObject#1](~/add/codesnippet/visualbasic/SynchronizingObjectVB1/Form1.vb#1)]  \n  \n The example requires that you add the following controls to the form:  \n  \n-   A <xref:System.Windows.Forms.TextBox> control named `TextBox1` (its default name).  \n  \n-   A <xref:System.Windows.Forms.Button> control named `Button1` (its default name).  \n  \n-   A <xref:System.Windows.Forms.SaveFileDialog> control named `SaveSaveFileDialog1` (its default name) ."
  syntax:
    content: public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }
    return:
      type: System.ComponentModel.ISynchronizeInvoke
      description: "<xref href=&quot;System.ComponentModel.ISynchronizeInvoke&quot;> </xref>表示对象，该对象用于封送时间隔过后，将发出的事件处理程序调用。 默认值是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Timers.Timer.SynchronizingObject*
  exceptions: []
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Timers.Timer.#ctor
  parent: System.Timers.Timer
  isExternal: false
  name: Timer()
  nameWithType: Timer.Timer()
  fullName: System.Timers.Timer.Timer()
- uid: System.Timers.Timer.#ctor(System.Double)
  parent: System.Timers.Timer
  isExternal: false
  name: Timer(Double)
  nameWithType: Timer.Timer(Double)
  fullName: System.Timers.Timer.Timer(Double)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Timers.Timer.AutoReset
  parent: System.Timers.Timer
  isExternal: false
  name: AutoReset
  nameWithType: Timer.AutoReset
  fullName: System.Timers.Timer.AutoReset
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Timers.Timer.BeginInit
  parent: System.Timers.Timer
  isExternal: false
  name: BeginInit()
  nameWithType: Timer.BeginInit()
  fullName: System.Timers.Timer.BeginInit()
- uid: System.Timers.Timer.Close
  parent: System.Timers.Timer
  isExternal: false
  name: Close()
  nameWithType: Timer.Close()
  fullName: System.Timers.Timer.Close()
- uid: System.Timers.Timer.Dispose(System.Boolean)
  parent: System.Timers.Timer
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: Timer.Dispose(Boolean)
  fullName: System.Timers.Timer.Dispose(Boolean)
- uid: System.Timers.Timer.Elapsed
  parent: System.Timers.Timer
  isExternal: false
  name: Elapsed
  nameWithType: Timer.Elapsed
  fullName: System.Timers.Timer.Elapsed
- uid: System.Timers.ElapsedEventHandler
  parent: System.Timers
  isExternal: false
  name: ElapsedEventHandler
  nameWithType: ElapsedEventHandler
  fullName: System.Timers.ElapsedEventHandler
- uid: System.Timers.Timer.Enabled
  parent: System.Timers.Timer
  isExternal: false
  name: Enabled
  nameWithType: Timer.Enabled
  fullName: System.Timers.Timer.Enabled
- uid: System.Timers.Timer.EndInit
  parent: System.Timers.Timer
  isExternal: false
  name: EndInit()
  nameWithType: Timer.EndInit()
  fullName: System.Timers.Timer.EndInit()
- uid: System.Timers.Timer.Interval
  parent: System.Timers.Timer
  isExternal: false
  name: Interval
  nameWithType: Timer.Interval
  fullName: System.Timers.Timer.Interval
- uid: System.Timers.Timer.Site
  parent: System.Timers.Timer
  isExternal: false
  name: Site
  nameWithType: Timer.Site
  fullName: System.Timers.Timer.Site
- uid: System.ComponentModel.ISite
  parent: System.ComponentModel
  isExternal: false
  name: ISite
  nameWithType: ISite
  fullName: System.ComponentModel.ISite
- uid: System.Timers.Timer.Start
  parent: System.Timers.Timer
  isExternal: false
  name: Start()
  nameWithType: Timer.Start()
  fullName: System.Timers.Timer.Start()
- uid: System.Timers.Timer.Stop
  parent: System.Timers.Timer
  isExternal: false
  name: Stop()
  nameWithType: Timer.Stop()
  fullName: System.Timers.Timer.Stop()
- uid: System.Timers.Timer.SynchronizingObject
  parent: System.Timers.Timer
  isExternal: false
  name: SynchronizingObject
  nameWithType: Timer.SynchronizingObject
  fullName: System.Timers.Timer.SynchronizingObject
- uid: System.ComponentModel.ISynchronizeInvoke
  parent: System.ComponentModel
  isExternal: false
  name: ISynchronizeInvoke
  nameWithType: ISynchronizeInvoke
  fullName: System.ComponentModel.ISynchronizeInvoke
- uid: System.Timers.Timer.#ctor*
  parent: System.Timers.Timer
  isExternal: false
  name: Timer
  nameWithType: Timer.Timer
- uid: System.Timers.Timer.AutoReset*
  parent: System.Timers.Timer
  isExternal: false
  name: AutoReset
  nameWithType: Timer.AutoReset
- uid: System.Timers.Timer.BeginInit*
  parent: System.Timers.Timer
  isExternal: false
  name: BeginInit
  nameWithType: Timer.BeginInit
- uid: System.Timers.Timer.Close*
  parent: System.Timers.Timer
  isExternal: false
  name: Close
  nameWithType: Timer.Close
- uid: System.Timers.Timer.Dispose*
  parent: System.Timers.Timer
  isExternal: false
  name: Dispose
  nameWithType: Timer.Dispose
- uid: System.Timers.Timer.Enabled*
  parent: System.Timers.Timer
  isExternal: false
  name: Enabled
  nameWithType: Timer.Enabled
- uid: System.Timers.Timer.EndInit*
  parent: System.Timers.Timer
  isExternal: false
  name: EndInit
  nameWithType: Timer.EndInit
- uid: System.Timers.Timer.Interval*
  parent: System.Timers.Timer
  isExternal: false
  name: Interval
  nameWithType: Timer.Interval
- uid: System.Timers.Timer.Site*
  parent: System.Timers.Timer
  isExternal: false
  name: Site
  nameWithType: Timer.Site
- uid: System.Timers.Timer.Start*
  parent: System.Timers.Timer
  isExternal: false
  name: Start
  nameWithType: Timer.Start
- uid: System.Timers.Timer.Stop*
  parent: System.Timers.Timer
  isExternal: false
  name: Stop
  nameWithType: Timer.Stop
- uid: System.Timers.Timer.SynchronizingObject*
  parent: System.Timers.Timer
  isExternal: false
  name: SynchronizingObject
  nameWithType: Timer.SynchronizingObject
