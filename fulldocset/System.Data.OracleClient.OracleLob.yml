### YamlMime:ManagedReference
items:
- uid: System.Data.OracleClient.OracleLob
  id: OracleLob
  children:
  - System.Data.OracleClient.OracleLob.Append(System.Data.OracleClient.OracleLob)
  - System.Data.OracleClient.OracleLob.BeginBatch
  - System.Data.OracleClient.OracleLob.BeginBatch(System.Data.OracleClient.OracleLobOpenMode)
  - System.Data.OracleClient.OracleLob.CanRead
  - System.Data.OracleClient.OracleLob.CanSeek
  - System.Data.OracleClient.OracleLob.CanWrite
  - System.Data.OracleClient.OracleLob.ChunkSize
  - System.Data.OracleClient.OracleLob.Clone
  - System.Data.OracleClient.OracleLob.Connection
  - System.Data.OracleClient.OracleLob.CopyTo(System.Data.OracleClient.OracleLob)
  - System.Data.OracleClient.OracleLob.CopyTo(System.Data.OracleClient.OracleLob,System.Int64)
  - System.Data.OracleClient.OracleLob.CopyTo(System.Int64,System.Data.OracleClient.OracleLob,System.Int64,System.Int64)
  - System.Data.OracleClient.OracleLob.Dispose(System.Boolean)
  - System.Data.OracleClient.OracleLob.EndBatch
  - System.Data.OracleClient.OracleLob.Erase
  - System.Data.OracleClient.OracleLob.Erase(System.Int64,System.Int64)
  - System.Data.OracleClient.OracleLob.Flush
  - System.Data.OracleClient.OracleLob.IsBatched
  - System.Data.OracleClient.OracleLob.IsNull
  - System.Data.OracleClient.OracleLob.IsTemporary
  - System.Data.OracleClient.OracleLob.Length
  - System.Data.OracleClient.OracleLob.LobType
  - System.Data.OracleClient.OracleLob.Null
  - System.Data.OracleClient.OracleLob.Position
  - System.Data.OracleClient.OracleLob.Read(System.Byte[],System.Int32,System.Int32)
  - System.Data.OracleClient.OracleLob.Seek(System.Int64,System.IO.SeekOrigin)
  - System.Data.OracleClient.OracleLob.SetLength(System.Int64)
  - System.Data.OracleClient.OracleLob.Value
  - System.Data.OracleClient.OracleLob.Write(System.Byte[],System.Int32,System.Int32)
  - System.Data.OracleClient.OracleLob.WriteByte(System.Byte)
  langs:
  - csharp
  name: OracleLob
  nameWithType: OracleLob
  fullName: System.Data.OracleClient.OracleLob
  type: Class
  summary: "表示二进制大型对象 (<xref uid=&quot;langword_csharp_LOB&quot; name=&quot;LOB&quot; href=&quot;&quot;></xref>) 存储在 Oracle 服务器上的数据类型。 此类不能被继承。"
  remarks: "从 oraclelob<xref:System.Data.OracleClient.OracleBFile>在于数据存储的服务器，而不是在操作系统中的物理文件上。</xref:System.Data.OracleClient.OracleBFile> 它还可读写对象，与不同<xref:System.Data.OracleClient.OracleBFile>，这始终是只读的。</xref:System.Data.OracleClient.OracleBFile>       OracleLob 可能是下列其中一<xref:System.Data.OracleClient.OracleType>数据类型。</xref:System.Data.OracleClient.OracleType>      |OracleType 数据类型 |说明 |  |--------------------------|-----------------|  |`Blob`|Oracle`BLOB`包含最大大小为 4 千兆字节 (GB) 的二进制数据的数据类型。 此方法映射到类型<xref:System.Byte><xref:System.Array>。 |  |`Clob`|Oracle`CLOB`包含字符数据，基于默认字符的数据类型设置在服务器上，最大大小为 4 GB。 </xref:System.Array></xref:System.Byte> 此方法映射到<xref:System.String>。 |  |`NClob`|Oracle`NCLOB`基于在具有最大大小为 4 GB 的服务器上的区域字符集包含字符数据的数据类型。</xref:System.String> 此方法映射到<xref:System.String>。 |      .NET 应用程序开发人员可以检索 Oracle`LOB`值到基本.NET 数据类型，例如<xref:System.Array>类型的<xref:System.Byte>和<xref:System.String>，或专用的 OracleLob 数据类型。</xref:System.String> </xref:System.Byte> </xref:System.Array> </xref:System.String> OracleLob 类支持从读取数据并写入 Oracle `LOB` Oracle 数据库中。       以下是将它与基本.NET 数据类型区分开来的主要特征 OracleLob 数据类型:-后检索 Oracle`LOB`值从 Oracle 数据库到 OracleLob 类时，你可以更改`LOB`打开的事务和所做的更改中的数据直接反映到数据库。 如果检索 Oracle`LOB`值到<xref:System.Array>类型的<xref:System.Byte>或<xref:System.String>和更新这些阵列，所做的更改不会反映到数据库。</xref:System.String> </xref:System.Byte> </xref:System.Array>      -如果你使用 OracleLob 类访问的区块`LOB`值，只将该块区传递从 Oracle 数据库到客户端。 当你使用<xref:System.Data.OracleClient.OracleDataReader.GetChars%2A>方法来访问的区块`LOB`值，该值的整个内容传递从 Oracle 数据库到客户端。</xref:System.Data.OracleClient.OracleDataReader.GetChars%2A>       若要获取 OracleLob 对象，请调用<xref:System.Data.OracleClient.OracleDataReader.GetOracleLob%2A>方法。</xref:System.Data.OracleClient.OracleDataReader.GetOracleLob%2A>       您可以构造为使用此格式的 NULL OracleLob:```   OracleLob myLob = OracleLob.Null;   ```此方法主要用于测试是否`LOB`从服务器返回为 NULL，如本示例所示︰```   If(myLob == OracleLob.Null)   ```一个 NULL`LOB`的行为类似于零字节`LOB`在于<xref:System.Data.OracleClient.OracleLob.Read%2A>成功并始终返回零字节。</xref:System.Data.OracleClient.OracleLob.Read%2A>       选择`LOB`包含一个 null 值的列返回<xref:System.Data.OracleClient.OracleLob.Null>.</xref:System.Data.OracleClient.OracleLob.Null>       你必须开始事务，然后才能获取临时`LOB`。 否则为<xref:System.Data.OracleClient.OracleDataReader>以获取更高版本的数据可能会失败。</xref:System.Data.OracleClient.OracleDataReader>       你也可以打开一个临时`LOB`通过调用 DBMS_LOB Oracle 中。CREATETEMPORARY 系统存储过程和绑定`LOB`输出参数。 在客户端，临时`LOB`行为类似基于表的`LOB`。 例如，若要更新临时`LOB`，它必须括在事务中。       下面的 C# 示例演示如何打开一个临时`LOB`。      ```   OracleConnection connection = new OracleConnection(&quot;server=MyServer; integrated security=yes;&quot;);   connection.Open();   OracleTransaction transaction = connection.BeginTransaction();   OracleCommand command = connection.CreateCommand();   command.Transaction = transaction;   command.CommandText = &quot;declare xx blob; begin dbms_lob.createtemporary(xx, false, 0); :tempblob := xx; end;&quot;;   command.Parameters.Add(new OracleParameter(&quot;tempblob&quot;, OracleType.Blob)).Direction = ParameterDirection.Output;   command.ExecuteNonQuery();   OracleLob tempLob = (OracleLob)command.Parameters[0].Value;   byte[] tempbuff = new byte[10000];   tempLob.BeginBatch(OracleLobOpenMode.ReadWrite);   tempLob.Write(tempbuff,0,tempbuff.Length);   tempLob.EndBatch();   command.Parameters.Clear();   command.CommandText = &quot;MyTable.MyProc&quot;;   command.CommandType = CommandType.StoredProcedure;     command.Parameters.Add(new OracleParameter(&quot;ImportDoc&quot;, OracleType.Blob)).Value = tempLob;   command.ExecuteNonQuery();   transaction.Commit();   connection.Close   ```      > [!NOTE]1> 继承<xref:System.IO.Stream.WriteByte%2A>时用于字符数据，方法会失败和<xref:System.InvalidOperationException>引发。</xref:System.InvalidOperationException> </xref:System.IO.Stream.WriteByte%2A> 使用<xref:System.Data.OracleClient.OracleLob.Write%2A>方法相反。</xref:System.Data.OracleClient.OracleLob.Write%2A>   >> 临时`LOB`仅关闭时关闭连接，但进行池和负载情况下，临时`LOB`不会关闭。 这可以通过释放临时解决`LOB`，通过调用`tempLob.Dispose()`。"
  syntax:
    content: 'public sealed class OracleLob : System.IO.Stream, ICloneable, System.Data.SqlTypes.INullable'
  inheritance:
  - System.IO.Stream
  implements:
  - System.Data.SqlTypes.INullable
  - System.ICloneable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Data.OracleClient.OracleLob.Append(System.Data.OracleClient.OracleLob)
  id: Append(System.Data.OracleClient.OracleLob)
  parent: System.Data.OracleClient.OracleLob
  langs:
  - csharp
  name: Append(OracleLob)
  nameWithType: OracleLob.Append(OracleLob)
  fullName: System.Data.OracleClient.OracleLob.Append(OracleLob)
  type: Method
  assemblies:
  - System.Data.OracleClient
  namespace: System.Data.OracleClient
  summary: "将从指定的数据追加<xref uid=&quot;langword_csharp_LOB&quot; name=&quot;LOB&quot; href=&quot;&quot;></xref>到当前<xref uid=&quot;langword_csharp_LOB&quot; name=&quot;LOB&quot; href=&quot;&quot;> </xref>。"
  remarks: "要写入到`LOB`，您必须检索`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 语句，还必须具有开始的本地事务。       来自源的所有数据`LOB`追加到当前末尾`LOB`。 位置都不`LOB`计算也没有在此过程中更改。       基础数据类型必须始终相同。 例如，如果要将追加来自<xref:System.Data.OracleClient.OracleType>，<xref:System.Data.OracleClient.OracleLob>还必须是<xref:System.Data.OracleClient.OracleType>.</xref:System.Data.OracleClient.OracleType></xref:System.Data.OracleClient.OracleLob>目标</xref:System.Data.OracleClient.OracleType>      1> [!NOTE]&1;> 在此版本中，对只读的写入操作`LOB`可能会成功，但不会更新`LOB`服务器上。 在这种情况下，但是的本地副本`LOB`更新。 因此，更高版本上读取操作<xref:System.Data.OracleClient.OracleLob>对象可能会返回写入操作的结果。</xref:System.Data.OracleClient.OracleLob>"
  syntax:
    content: public void Append (System.Data.OracleClient.OracleLob source);
    parameters:
    - id: source
      type: System.Data.OracleClient.OracleLob
      description: "<xref uid=&quot;langword_csharp_LOB&quot; name=&quot;LOB&quot; href=&quot;&quot;> </xref>从中追加数据。"
  overload: System.Data.OracleClient.OracleLob.Append*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "源<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>为 null。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "源<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>为 null，或连接已关闭。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "源<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>对象已关闭或释放。"
  - type: System.Data.OracleClient.OracleException
    commentId: T:System.Data.OracleClient.OracleException
    description: "Oracle 出错。"
  platform:
  - net462
- uid: System.Data.OracleClient.OracleLob.BeginBatch
  id: BeginBatch
  parent: System.Data.OracleClient.OracleLob
  langs:
  - csharp
  name: BeginBatch()
  nameWithType: OracleLob.BeginBatch()
  fullName: System.Data.OracleClient.OracleLob.BeginBatch()
  type: Method
  assemblies:
  - System.Data.OracleClient
  namespace: System.Data.OracleClient
  summary: "避免服务器端触发器执行多个读取的操作时激发。"
  remarks: "打开`LOB`中<xref:System.Data.OracleClient.OracleLobOpenMode>模式; 因此，`LOB`可以只从其中读取，不会写入，直到<xref:System.Data.OracleClient.OracleLob.EndBatch%2A>.</xref:System.Data.OracleClient.OracleLob.EndBatch%2A>相应地调用</xref:System.Data.OracleClient.OracleLobOpenMode> 若要执行批处理写入`LOB`， <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> <xref:System.Data.OracleClient.OracleLobOpenMode>。</xref:System.Data.OracleClient.OracleLobOpenMode></xref:System.Data.OracleClient.OracleLob.BeginBatch%2A>调用       调用不止一次在同一事务中当前的 BeginBatch 引发 Oracle&quot;ORA&22293;: LOB 同一个事务中已经打开了&quot;错误。 此外，如果你获取`LOB`使用另一个<xref:System.Data.OracleClient.OracleDataReader>，且具有不会调用原始调用方<xref:System.Data.OracleClient.OracleLob.EndBatch%2A>生成方法，相同的错误。</xref:System.Data.OracleClient.OracleLob.EndBatch%2A> </xref:System.Data.OracleClient.OracleDataReader> 因此，必须调用该<xref:System.Data.OracleClient.OracleLob.EndBatch%2A>方法在完成使用<xref:System.Data.OracleClient.OracleLob>.</xref:System.Data.OracleClient.OracleLob>时</xref:System.Data.OracleClient.OracleLob.EndBatch%2A>"
  syntax:
    content: public void BeginBatch ();
    parameters: []
  overload: System.Data.OracleClient.OracleLob.BeginBatch*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "连接已关闭。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "关闭或释放该对象。"
  - type: System.Data.OracleClient.OracleException
    commentId: T:System.Data.OracleClient.OracleException
    description: "Oracle 出错。"
  platform:
  - net462
- uid: System.Data.OracleClient.OracleLob.BeginBatch(System.Data.OracleClient.OracleLobOpenMode)
  id: BeginBatch(System.Data.OracleClient.OracleLobOpenMode)
  parent: System.Data.OracleClient.OracleLob
  langs:
  - csharp
  name: BeginBatch(OracleLobOpenMode)
  nameWithType: OracleLob.BeginBatch(OracleLobOpenMode)
  fullName: System.Data.OracleClient.OracleLob.BeginBatch(OracleLobOpenMode)
  type: Method
  assemblies:
  - System.Data.OracleClient
  namespace: System.Data.OracleClient
  summary: "触发时执行多个读和写操作的指定的访问模式以避免服务器端触发器。"
  remarks: "要写入到`LOB`，您必须检索`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 语句，还必须具有开始的本地事务。       调用<xref:System.Data.OracleClient.OracleLob.BeginBatch%2A>不止一次在同一事务中的当前引发 Oracle&quot;ORA&22293;: LOB 同一个事务中已经打开了&quot;错误。</xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> 此外，如果你获取`LOB`使用另一个<xref:System.Data.OracleClient.OracleDataReader>，且具有不会调用原始调用方<xref:System.Data.OracleClient.OracleLob.EndBatch%2A>生成方法，相同的错误。</xref:System.Data.OracleClient.OracleLob.EndBatch%2A> </xref:System.Data.OracleClient.OracleDataReader> 因此，必须调用该<xref:System.Data.OracleClient.OracleLob.EndBatch%2A>方法在完成使用<xref:System.Data.OracleClient.OracleLob>.</xref:System.Data.OracleClient.OracleLob>时</xref:System.Data.OracleClient.OracleLob.EndBatch%2A>"
  syntax:
    content: public void BeginBatch (System.Data.OracleClient.OracleLobOpenMode mode);
    parameters:
    - id: mode
      type: System.Data.OracleClient.OracleLobOpenMode
      description: "模式 (之一<xref href=&quot;System.Data.OracleClient.OracleLobOpenMode&quot;></xref>值) 在其中<xref uid=&quot;langword_csharp_LOB&quot; name=&quot;LOB&quot; href=&quot;&quot;></xref>可以访问此 BeginBatch 调用和相应之间<xref:System.Data.OracleClient.OracleLob.EndBatch*>调用。</xref:System.Data.OracleClient.OracleLob.EndBatch*>"
  overload: System.Data.OracleClient.OracleLob.BeginBatch*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "连接已关闭。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "关闭或释放该对象。"
  - type: System.Data.OracleClient.OracleException
    commentId: T:System.Data.OracleClient.OracleException
    description: "Oracle 出错。"
  platform:
  - net462
- uid: System.Data.OracleClient.OracleLob.CanRead
  id: CanRead
  parent: System.Data.OracleClient.OracleLob
  langs:
  - csharp
  name: CanRead
  nameWithType: OracleLob.CanRead
  fullName: System.Data.OracleClient.OracleLob.CanRead
  type: Property
  assemblies:
  - System.Data.OracleClient
  namespace: System.Data.OracleClient
  summary: "获取一个值，该值指示是否<xref uid=&quot;langword_csharp_LOB&quot; name=&quot;LOB&quot; href=&quot;&quot;></xref>可以读取流。"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref uid=&quot;langword_csharp_LOB&quot; name=&quot;LOB&quot; href=&quot;&quot;></xref>流支持读取，否则<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>如果<xref uid=&quot;langword_csharp_LOB&quot; name=&quot;LOB&quot; href=&quot;&quot;></xref>关闭或释放为止。"
  overload: System.Data.OracleClient.OracleLob.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.Data.OracleClient.OracleLob.CanSeek
  id: CanSeek
  parent: System.Data.OracleClient.OracleLob
  langs:
  - csharp
  name: CanSeek
  nameWithType: OracleLob.CanSeek
  fullName: System.Data.OracleClient.OracleLob.CanSeek
  type: Property
  assemblies:
  - System.Data.OracleClient
  namespace: System.Data.OracleClient
  summary: "获取一个值，该值指示是否向前和向后查找操作可以执行。"
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>如果<xref uid=&quot;langword_csharp_LOB&quot; name=&quot;LOB&quot; href=&quot;&quot;></xref>关闭或断开，否则<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。 Always <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref> for <xref href=&quot;System.Data.OracleClient.OracleLob.Null&quot;></xref>."
  overload: System.Data.OracleClient.OracleLob.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.Data.OracleClient.OracleLob.CanWrite
  id: CanWrite
  parent: System.Data.OracleClient.OracleLob
  langs:
  - csharp
  name: CanWrite
  nameWithType: OracleLob.CanWrite
  fullName: System.Data.OracleClient.OracleLob.CanWrite
  type: Property
  assemblies:
  - System.Data.OracleClient
  namespace: System.Data.OracleClient
  summary: "始终返回 true，而不管是否<xref uid=&quot;langword_csharp_LOB&quot; name=&quot;LOB&quot; href=&quot;&quot;></xref>是否支持写入。"
  remarks: "要写入到`LOB`，您必须检索`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 语句，你必须已启动对本地事务。"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "始终返回<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>，无论的打开或未释放<xref uid=&quot;langword_csharp_LOB&quot; name=&quot;LOB&quot; href=&quot;&quot;></xref>是否，支持写入<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>如果<xref uid=&quot;langword_csharp_LOB&quot; name=&quot;LOB&quot; href=&quot;&quot;></xref>关闭或释放为止。"
  overload: System.Data.OracleClient.OracleLob.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Data.OracleClient.OracleLob.ChunkSize
  id: ChunkSize
  parent: System.Data.OracleClient.OracleLob
  langs:
  - csharp
  name: ChunkSize
  nameWithType: OracleLob.ChunkSize
  fullName: System.Data.OracleClient.OracleLob.ChunkSize
  type: Property
  assemblies:
  - System.Data.OracleClient
  namespace: System.Data.OracleClient
  summary: "获取一个值，该值最小从检索或读/写操作期间向服务器发送的字节数。"
  remarks: "ChunkSize 属性返回的值不是适用于 Oracle 的.NET Framework 数据提供程序的设置。 相反，它是与服务器通信时使用的 Oracle 调用接口 (OCI) 的值。 使用 ChunkSize 来确保客户端区块是相同的大小。 读取或写入在较小区块中不会缓存数据，并导致到服务器，无优化往返行程，因为未收到或发送完整的数据包。"
  syntax:
    content: public int ChunkSize { get; }
    return:
      type: System.Int32
      description: "最小要检索或发送的字节数。"
  overload: System.Data.OracleClient.OracleLob.ChunkSize*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "连接已关闭。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "关闭或释放该对象。"
  - type: System.Data.OracleClient.OracleException
    commentId: T:System.Data.OracleClient.OracleException
    description: "Oracle 出错。"
  platform:
  - net462
- uid: System.Data.OracleClient.OracleLob.Clone
  id: Clone
  parent: System.Data.OracleClient.OracleLob
  langs:
  - csharp
  name: Clone()
  nameWithType: OracleLob.Clone()
  fullName: System.Data.OracleClient.OracleLob.Clone()
  type: Method
  assemblies:
  - System.Data.OracleClient
  namespace: System.Data.OracleClient
  summary: "创建一个新<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>对象引用相同的 Oracle <xref uid=&quot;langword_csharp_LOB&quot; name=&quot;LOB&quot; href=&quot;&quot;> </xref>与原始<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>对象。"
  remarks: "新属性<xref:System.Data.OracleClient.OracleLob>对象最初具有与原始对象相同的值。</xref:System.Data.OracleClient.OracleLob> 但是，克隆完成后，每个在<xref:System.Data.OracleClient.OracleLob>对象是相互独立。</xref:System.Data.OracleClient.OracleLob> 例如，更改的值<xref:System.Data.OracleClient.OracleLob.Position%2A>原始属性<xref:System.Data.OracleClient.OracleLob>不会更改的值<xref:System.Data.OracleClient.OracleLob.Position%2A>的副本。</xref:System.Data.OracleClient.OracleLob.Position%2A> </xref:System.Data.OracleClient.OracleLob> </xref:System.Data.OracleClient.OracleLob.Position%2A>"
  syntax:
    content: public object Clone ();
    parameters: []
    return:
      type: System.Object
      description: "一个新<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>对象引用相同的 Oracle <xref uid=&quot;langword_csharp_LOB&quot; name=&quot;LOB&quot; href=&quot;&quot;> </xref>与原始<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>对象。"
  overload: System.Data.OracleClient.OracleLob.Clone*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "连接已关闭。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "关闭或释放该对象。"
  platform:
  - net462
- uid: System.Data.OracleClient.OracleLob.Connection
  id: Connection
  parent: System.Data.OracleClient.OracleLob
  langs:
  - csharp
  name: Connection
  nameWithType: OracleLob.Connection
  fullName: System.Data.OracleClient.OracleLob.Connection
  type: Property
  assemblies:
  - System.Data.OracleClient
  namespace: System.Data.OracleClient
  summary: "获取<xref href=&quot;System.Data.OracleClient.OracleConnection&quot;></xref>的此实例所使用的<xref href=&quot;System.Data.OracleClient.OracleLob&quot;> </xref>。"
  syntax:
    content: public System.Data.OracleClient.OracleConnection Connection { get; }
    return:
      type: System.Data.OracleClient.OracleConnection
      description: "到数据源的连接。"
  overload: System.Data.OracleClient.OracleLob.Connection*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "关闭或释放该对象。"
  platform:
  - net462
- uid: System.Data.OracleClient.OracleLob.CopyTo(System.Data.OracleClient.OracleLob)
  id: CopyTo(System.Data.OracleClient.OracleLob)
  parent: System.Data.OracleClient.OracleLob
  langs:
  - csharp
  name: CopyTo(OracleLob)
  nameWithType: OracleLob.CopyTo(OracleLob)
  fullName: System.Data.OracleClient.OracleLob.CopyTo(OracleLob)
  type: Method
  assemblies:
  - System.Data.OracleClient
  namespace: System.Data.OracleClient
  summary: "从该副本<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>到目标<xref href=&quot;System.Data.OracleClient.OracleLob&quot;> </xref>。"
  remarks: "基础数据类型必须始终相同。 例如，如果您从中复制<xref:System.Data.OracleClient.OracleType>，<xref:System.Data.OracleClient.OracleLob>还必须是<xref:System.Data.OracleClient.OracleType>.</xref:System.Data.OracleClient.OracleType></xref:System.Data.OracleClient.OracleLob>目标</xref:System.Data.OracleClient.OracleType>       目标偏移量是否超出目标末尾`LOB`、`LOB`扩展到其中复制数据。 末尾之间的空间`LOB`和超出末尾位置的目标偏移量则用零填充`BLOB`数据类型，以空格`CLOB`和`NCLOB`数据类型。       要写入到`LOB`，您必须检索`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 语句，还必须具有开始的本地事务。      1> [!NOTE]&1;> 在此版本中，对只读的写入操作`LOB`可能成功，但不是更新`LOB`服务器上。 在这种情况下，但是的本地副本`LOB`将更新。 因此，更高版本上读取操作<xref:System.Data.OracleClient.OracleLob>对象可能会返回写入操作的结果。</xref:System.Data.OracleClient.OracleLob>   >>`CopyTo`方法并不会清除目标的内容`OracleLob`之前执行复制操作。"
  syntax:
    content: public long CopyTo (System.Data.OracleClient.OracleLob destination);
    parameters:
    - id: destination
      type: System.Data.OracleClient.OracleLob
      description: "目标<xref href=&quot;System.Data.OracleClient.OracleLob&quot;> </xref>。"
    return:
      type: System.Int64
      description: "复制的字节数。 这不包括任何填充的字节。"
  overload: System.Data.OracleClient.OracleLob.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<xref href=&quot;System.Data.OracleClient.OracleLob&quot;> </xref>中指定<code> destination </code>参数为 null。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "该操作不在事务内<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>对象为 null，或连接已关闭。"
  - type: System.Data.OracleClient.OracleException
    commentId: T:System.Data.OracleClient.OracleException
    description: "Oracle 出错。"
  platform:
  - net462
- uid: System.Data.OracleClient.OracleLob.CopyTo(System.Data.OracleClient.OracleLob,System.Int64)
  id: CopyTo(System.Data.OracleClient.OracleLob,System.Int64)
  parent: System.Data.OracleClient.OracleLob
  langs:
  - csharp
  name: CopyTo(OracleLob,Int64)
  nameWithType: OracleLob.CopyTo(OracleLob,Int64)
  fullName: System.Data.OracleClient.OracleLob.CopyTo(OracleLob,Int64)
  type: Method
  assemblies:
  - System.Data.OracleClient
  namespace: System.Data.OracleClient
  summary: "从该副本<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>到目标<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>与指定的数据量。"
  remarks: "基础数据类型必须始终相同。 例如，如果您从中复制<xref:System.Data.OracleClient.OracleType>，<xref:System.Data.OracleClient.OracleLob>还必须是<xref:System.Data.OracleClient.OracleType>.</xref:System.Data.OracleClient.OracleType></xref:System.Data.OracleClient.OracleLob>目标</xref:System.Data.OracleClient.OracleType>       目标偏移量是否超出目标末尾`LOB`、`LOB`扩展到其中复制数据。 末尾之间的空间`LOB`和目标超出末尾位置的偏移量则用零填充`BLOB`数据类型，以空格`CLOB`和`NCLOB`数据类型。       要写入到`LOB`，您必须检索`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 语句，还必须具有开始的本地事务。      1> [!NOTE]&1;> 在此版本中，对只读的写入操作`LOB`可能会成功，但不会更新`LOB`服务器上。 在这种情况下，但是的本地副本`LOB`更新。 因此，更高版本上读取操作<xref:System.Data.OracleClient.OracleLob>对象可能会返回写入操作的结果。</xref:System.Data.OracleClient.OracleLob>   >>`CopyTo`方法并不会清除目标的内容`OracleLob`之前执行复制操作。"
  syntax:
    content: public long CopyTo (System.Data.OracleClient.OracleLob destination, long destinationOffset);
    parameters:
    - id: destination
      type: System.Data.OracleClient.OracleLob
      description: "目标<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>"
    - id: destinationOffset
      type: System.Int64
      description: "要将复制到偏移量。 有关<xref uid=&quot;langword_csharp_CLOB&quot; name=&quot;CLOB&quot; href=&quot;&quot;></xref>和<xref uid=&quot;langword_csharp_NCLOB&quot; name=&quot;NCLOB&quot; href=&quot;&quot;></xref>数据类型，这必须是偶数个字节。"
    return:
      type: System.Int64
      description: "复制的字节数。 这不包括任何填充的字节。"
  overload: System.Data.OracleClient.OracleLob.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<xref href=&quot;System.Data.OracleClient.OracleLob&quot;> </xref>中指定<code> destination </code>参数已满。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "中指定的值<code> destinationOffset </code>参数小于零或大于 4 千兆字节。       -中指定的值<code> destinationOffset </code>参数<xref uid=&quot;langword_csharp_CLOB&quot; name=&quot;CLOB&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_NCLOB&quot; name=&quot;NCLOB&quot; href=&quot;&quot;></xref>数据类型不是偶数。       -或-你必须指定<xref uid=&quot;langword_csharp_CLOB&quot; name=&quot;CLOB&quot; href=&quot;&quot;></xref>和<xref uid=&quot;langword_csharp_NCLOB&quot; name=&quot;NCLOB&quot; href=&quot;&quot;></xref>为偶数的字节的数据类型。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "该操作不在事务内<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>对象为 null，或连接已关闭。"
  - type: System.Data.OracleClient.OracleException
    commentId: T:System.Data.OracleClient.OracleException
    description: "Oracle 出错。"
  platform:
  - net462
- uid: System.Data.OracleClient.OracleLob.CopyTo(System.Int64,System.Data.OracleClient.OracleLob,System.Int64,System.Int64)
  id: CopyTo(System.Int64,System.Data.OracleClient.OracleLob,System.Int64,System.Int64)
  parent: System.Data.OracleClient.OracleLob
  langs:
  - csharp
  name: CopyTo(Int64,OracleLob,Int64,Int64)
  nameWithType: OracleLob.CopyTo(Int64,OracleLob,Int64,Int64)
  fullName: System.Data.OracleClient.OracleLob.CopyTo(Int64,OracleLob,Int64,Int64)
  type: Method
  assemblies:
  - System.Data.OracleClient
  namespace: System.Data.OracleClient
  summary: "从该副本<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>到目标<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>具有指定量的数据，以及源偏移量。"
  remarks: "基础数据类型必须始终相同。 例如，如果您从中复制<xref:System.Data.OracleClient.OracleType>，<xref:System.Data.OracleClient.OracleLob>还必须是<xref:System.Data.OracleClient.OracleType>.</xref:System.Data.OracleClient.OracleType></xref:System.Data.OracleClient.OracleLob>目标</xref:System.Data.OracleClient.OracleType>       目标偏移量是否超出目标末尾`LOB`、`LOB`扩展到其中复制数据。 末尾之间的空间`LOB`和目标超出末尾位置的偏移量则用零填充`BLOB`数据类型，以空格`CLOB`和`NCLOB`数据类型。       要写入到`LOB`，您必须检索`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 语句，还必须具有开始的本地事务。      1> [!NOTE]&1;> 在此版本中，对只读的写入操作`LOB`可能会成功，但不会更新`LOB`服务器上。 在这种情况下，但是的本地副本`LOB`更新。 因此，更高版本上读取操作<xref:System.Data.OracleClient.OracleLob>对象可能会返回写入操作的结果。</xref:System.Data.OracleClient.OracleLob>   >>`CopyTo`方法并不会清除目标的内容`OracleLob`之前执行复制操作。"
  syntax:
    content: public long CopyTo (long sourceOffset, System.Data.OracleClient.OracleLob destination, long destinationOffset, long amount);
    parameters:
    - id: sourceOffset
      type: System.Int64
      description: "要从其中复制偏移量。 有关<xref uid=&quot;langword_csharp_CLOB&quot; name=&quot;CLOB&quot; href=&quot;&quot;></xref>和<xref uid=&quot;langword_csharp_NCLOB&quot; name=&quot;NCLOB&quot; href=&quot;&quot;></xref>数据类型，这必须是偶数。"
    - id: destination
      type: System.Data.OracleClient.OracleLob
      description: "The destination <xref uid=&quot;langword_csharp_OracleLob&quot; name=&quot;OracleLob&quot; href=&quot;&quot;></xref><xref href=&quot;System.Data.OracleClient&quot;></xref>."
    - id: destinationOffset
      type: System.Int64
      description: "要将复制到目标偏移量。 有关<xref uid=&quot;langword_csharp_CLOB&quot; name=&quot;CLOB&quot; href=&quot;&quot;></xref>和<xref uid=&quot;langword_csharp_NCLOB&quot; name=&quot;NCLOB&quot; href=&quot;&quot;></xref>数据类型，这必须是偶数。"
    - id: amount
      type: System.Int64
      description: "数据，以字节为单位，以将复制的数量。 有关<xref uid=&quot;langword_csharp_CLOB&quot; name=&quot;CLOB&quot; href=&quot;&quot;></xref>和<xref uid=&quot;langword_csharp_NCLOB&quot; name=&quot;NCLOB&quot; href=&quot;&quot;></xref>数据类型，这必须是偶数。"
    return:
      type: System.Int64
      description: "复制的字节数。 这不包括任何填充的字节。"
  overload: System.Data.OracleClient.OracleLob.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<xref href=&quot;System.Data.OracleClient.OracleLob&quot;> </xref>中指定<code> destination </code>参数已满。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "中指定的值<code> amount </code>， <code> sourceOffset </code>，或<code> destinationOffset </code>参数小于零或大于 4 千兆字节。       -or-       A value specified in the <code>amount</code>, <code>sourceOffset</code>, or <code>destinationOffset</code> parameter for a <xref uid=&quot;langword_csharp_CLOB&quot; name=&quot;CLOB&quot; href=&quot;&quot;></xref> or <xref uid=&quot;langword_csharp_NCLOB&quot; name=&quot;NCLOB&quot; href=&quot;&quot;></xref> data type is not even."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "该操作不在事务内<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>对象为 null，或连接已关闭。"
  - type: System.Data.OracleClient.OracleException
    commentId: T:System.Data.OracleClient.OracleException
    description: "Oracle 出错。"
  platform:
  - net462
- uid: System.Data.OracleClient.OracleLob.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Data.OracleClient.OracleLob
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: OracleLob.Dispose(Boolean)
  fullName: System.Data.OracleClient.OracleLob.Dispose(Boolean)
  type: Method
  assemblies:
  - System.Data.OracleClient
  namespace: System.Data.OracleClient
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "要添加。"
  overload: System.Data.OracleClient.OracleLob.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Data.OracleClient.OracleLob.EndBatch
  id: EndBatch
  parent: System.Data.OracleClient.OracleLob
  langs:
  - csharp
  name: EndBatch()
  nameWithType: OracleLob.EndBatch()
  fullName: System.Data.OracleClient.OracleLob.EndBatch()
  type: Method
  assemblies:
  - System.Data.OracleClient
  namespace: System.Data.OracleClient
  summary: "允许服务器端触发器继续执行多个写入操作后的激发。"
  remarks: "调用该<xref:System.Data.OracleClient.OracleLob.BeginBatch%2A>方法在开始执行写入操作的时间为<xref:System.Data.OracleClient.OracleLob>。</xref:System.Data.OracleClient.OracleLob>之前</xref:System.Data.OracleClient.OracleLob.BeginBatch%2A>"
  syntax:
    content: public void EndBatch ();
    parameters: []
  overload: System.Data.OracleClient.OracleLob.EndBatch*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "连接已关闭。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "关闭或释放该对象。"
  - type: System.Data.OracleClient.OracleException
    commentId: T:System.Data.OracleClient.OracleException
    description: "Oracle 出错。"
  platform:
  - net462
- uid: System.Data.OracleClient.OracleLob.Erase
  id: Erase
  parent: System.Data.OracleClient.OracleLob
  langs:
  - csharp
  name: Erase()
  nameWithType: OracleLob.Erase()
  fullName: System.Data.OracleClient.OracleLob.Erase()
  type: Method
  assemblies:
  - System.Data.OracleClient
  namespace: System.Data.OracleClient
  summary: "会清除所有数据从此<xref href=&quot;System.Data.OracleClient.OracleLob&quot;> </xref>。"
  remarks: "擦除不截断数据。 `LOB`长度保持不变的`BLOB`数据类型和清除的数据替换为 0x00。 `CLOB`和`NCLOB`数据类型替换为空格。       要写入到`LOB`，您必须检索`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 语句，还必须具有开始的本地事务。      1> [!NOTE]&1;> 在此版本中，对只读的写入操作`LOB`可能会成功，但不会更新`LOB`服务器上。 在这种情况下，但是的本地副本`LOB`更新。 因此，更高版本上读取操作<xref:System.Data.OracleClient.OracleLob>对象可能会返回写入操作的结果。</xref:System.Data.OracleClient.OracleLob>"
  syntax:
    content: public long Erase ();
    parameters: []
    return:
      type: System.Int64
      description: "清除的字节数。"
  overload: System.Data.OracleClient.OracleLob.Erase*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "该操作不在事务内<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>对象为 null，或连接已关闭。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "关闭或释放该对象。"
  - type: System.Data.OracleClient.OracleException
    commentId: T:System.Data.OracleClient.OracleException
    description: "Oracle 出错。"
  platform:
  - net462
- uid: System.Data.OracleClient.OracleLob.Erase(System.Int64,System.Int64)
  id: Erase(System.Int64,System.Int64)
  parent: System.Data.OracleClient.OracleLob
  langs:
  - csharp
  name: Erase(Int64,Int64)
  nameWithType: OracleLob.Erase(Int64,Int64)
  fullName: System.Data.OracleClient.OracleLob.Erase(Int64,Int64)
  type: Method
  assemblies:
  - System.Data.OracleClient
  namespace: System.Data.OracleClient
  summary: "清除指定的数量的数据，这<xref href=&quot;System.Data.OracleClient.OracleLob&quot;> </xref>。"
  remarks: "中的值的总和`offset`和`amount`参数可以是大于<xref:System.Data.OracleClient.OracleLob>.</xref:System.Data.OracleClient.OracleLob>的大小 因此，指定的值比返回大<xref:System.Data.OracleClient.OracleLob.Length%2A>属性成功; 但是<xref:System.Data.OracleClient.OracleLob.Erase%2A>仅清除到<xref:System.Data.OracleClient.OracleLob>.</xref:System.Data.OracleClient.OracleLob>末尾</xref:System.Data.OracleClient.OracleLob.Erase%2A></xref:System.Data.OracleClient.OracleLob.Length%2A> (同样，如果传递给负值`offset`，<xref:System.Data.OracleClient.OracleLob.Erase%2A>将成功，但从的开头开始，才清除<xref:System.Data.OracleClient.OracleLob>。)</xref:System.Data.OracleClient.OracleLob> </xref:System.Data.OracleClient.OracleLob.Erase%2A>此行为是不同的<xref:System.Data.OracleClient.OracleLob.Read%2A>和<xref:System.Data.OracleClient.OracleLob.Write%2A>方法和产品/服务的优势在于能够擦除所有数据值指定`offset`而不对其他往返进行服务器验证的实际大小。</xref:System.Data.OracleClient.OracleLob.Write%2A> </xref:System.Data.OracleClient.OracleLob.Read%2A>       <xref:System.Data.OracleClient.OracleLob.Erase%2A>不会不会截断数据。</xref:System.Data.OracleClient.OracleLob.Erase%2A> `LOB`长度保持不变的`BLOB`数据类型和清除的数据替换为 0x00。 `CLOB`和`NCLOB`数据类型替换为空格。       要写入到`LOB`，您必须检索`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 语句，还必须具有开始的本地事务。      1> [!NOTE]&1;> 在此版本中，对只读的写入操作`LOB`可能会成功，但不会更新`LOB`服务器上。 在这种情况下，但是的本地副本`LOB`更新。 因此，更高版本上读取操作<xref:System.Data.OracleClient.OracleLob>对象可能会返回写入操作的结果。</xref:System.Data.OracleClient.OracleLob>"
  syntax:
    content: public long Erase (long offset, long amount);
    parameters:
    - id: offset
      type: System.Int64
      description: "从要擦除的偏移量。 有关<xref uid=&quot;langword_csharp_CLOB&quot; name=&quot;CLOB&quot; href=&quot;&quot;></xref>和<xref uid=&quot;langword_csharp_NCLOB&quot; name=&quot;NCLOB&quot; href=&quot;&quot;></xref>数据类型，这必须是偶数。"
    - id: amount
      type: System.Int64
      description: "数据，以字节为单位，擦除数量。 有关<xref uid=&quot;langword_csharp_CLOB&quot; name=&quot;CLOB&quot; href=&quot;&quot;></xref>和<xref uid=&quot;langword_csharp_NCLOB&quot; name=&quot;NCLOB&quot; href=&quot;&quot;></xref>数据类型，这必须是偶数。"
    return:
      type: System.Int64
      description: "清除的字节数。"
  overload: System.Data.OracleClient.OracleLob.Erase*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "该操作不在事务内<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>对象为 null，或连接已关闭。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "关闭或释放该对象。"
  - type: System.Data.OracleClient.OracleException
    commentId: T:System.Data.OracleClient.OracleException
    description: "Oracle 出错。"
  platform:
  - net462
- uid: System.Data.OracleClient.OracleLob.Flush
  id: Flush
  parent: System.Data.OracleClient.OracleLob
  langs:
  - csharp
  name: Flush()
  nameWithType: OracleLob.Flush()
  fullName: System.Data.OracleClient.OracleLob.Flush()
  type: Method
  assemblies:
  - System.Data.OracleClient
  namespace: System.Data.OracleClient
  summary: "当前不受支持。"
  remarks: "在此版本中，此方法不起作用。"
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.Data.OracleClient.OracleLob.Flush*
  exceptions: []
  platform:
  - net462
- uid: System.Data.OracleClient.OracleLob.IsBatched
  id: IsBatched
  parent: System.Data.OracleClient.OracleLob
  langs:
  - csharp
  name: IsBatched
  nameWithType: OracleLob.IsBatched
  fullName: System.Data.OracleClient.OracleLob.IsBatched
  type: Property
  assemblies:
  - System.Data.OracleClient
  namespace: System.Data.OracleClient
  summary: "获取一个值，该值指示应用程序调用<xref:System.Data.OracleClient.OracleLob.BeginBatch*>方法。</xref:System.Data.OracleClient.OracleLob.BeginBatch*>"
  remarks: '当使用 Oracle 8.0.5 服务器，Oracle&quot;ORA 00600︰ 内部错误代码&quot;会引发异常。'
  syntax:
    content: public bool IsBatched { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果应用程序调用<xref:System.Data.OracleClient.OracleLob.BeginBatch*>方法，否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.Data.OracleClient.OracleLob.BeginBatch*>"
  overload: System.Data.OracleClient.OracleLob.IsBatched*
  exceptions:
  - type: System.Data.OracleClient.OracleException
    commentId: T:System.Data.OracleClient.OracleException
    description: "Oracle 出错。"
  platform:
  - net462
- uid: System.Data.OracleClient.OracleLob.IsNull
  id: IsNull
  parent: System.Data.OracleClient.OracleLob
  langs:
  - csharp
  name: IsNull
  nameWithType: OracleLob.IsNull
  fullName: System.Data.OracleClient.OracleLob.IsNull
  type: Property
  assemblies:
  - System.Data.OracleClient
  namespace: System.Data.OracleClient
  summary: "获取一个值，该值指示是否<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>是<xref href=&quot;System.Data.OracleClient.OracleBFile.Null&quot;></xref>流。"
  syntax:
    content: public bool IsNull { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>if the <xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref> is a <xref href=&quot;System.Data.OracleClient.OracleBFile.Null&quot;></xref> stream, otherwise <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>."
  overload: System.Data.OracleClient.OracleLob.IsNull*
  exceptions: []
  platform:
  - net462
- uid: System.Data.OracleClient.OracleLob.IsTemporary
  id: IsTemporary
  parent: System.Data.OracleClient.OracleLob
  langs:
  - csharp
  name: IsTemporary
  nameWithType: OracleLob.IsTemporary
  fullName: System.Data.OracleClient.OracleLob.IsTemporary
  type: Property
  assemblies:
  - System.Data.OracleClient
  namespace: System.Data.OracleClient
  summary: "获取一个值，该值指示是否<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>是临时<xref uid=&quot;langword_csharp_LOB&quot; name=&quot;LOB&quot; href=&quot;&quot;> </xref>。"
  remarks: "下面的示例演示如何创建一个临时`LOB`。      ```   OracleConnection connection = new OracleConnection(&quot;server=MyServer; integrated security=yes;&quot;);   connection.Open();   OracleTransaction transaction = connection.BeginTransaction();   OracleCommand command = connection.CreateCommand();   command.Transaction = transaction;   command.CommandText = &quot;declare xx blob; begin dbms_lob.createtemporary(xx, false, 0); :tempblob := xx; end;&quot;;   command.Parameters.Add(new OracleParameter(&quot;tempblob&quot;, OracleType.Blob)).Direction = ParameterDirection.Output;   command.ExecuteNonQuery();   OracleLob tempLob = (OracleLob)command.Parameters[0].Value;   tempLob.BeginBatch(OracleLobOpenMode.ReadWrite);   tempLob.Write(tempbuff,0,tempbuff.Length);   tempLob.EndBatch();   command.Parameters.Clear();   command.CommandText = &quot;MyTable.MyProc&quot;;   command.CommandType = CommandType.StoredProcedure;     command.Parameters.Add(new OracleParameter(&quot;ImportDoc&quot;, OracleType.Blob)).Value = tempLob;   command.ExecuteNonQuery();   transaction.Commit();   connection.Close   ```"
  syntax:
    content: public bool IsTemporary { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>是临时<xref uid=&quot;langword_csharp_LOB&quot; name=&quot;LOB&quot; href=&quot;&quot;> </xref>，否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.OracleClient.OracleLob.IsTemporary*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "连接已关闭。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "关闭或释放该对象。"
  - type: System.Data.OracleClient.OracleException
    commentId: T:System.Data.OracleClient.OracleException
    description: "Oracle 出错。"
  platform:
  - net462
- uid: System.Data.OracleClient.OracleLob.Length
  id: Length
  parent: System.Data.OracleClient.OracleLob
  langs:
  - csharp
  name: Length
  nameWithType: OracleLob.Length
  fullName: System.Data.OracleClient.OracleLob.Length
  type: Property
  assemblies:
  - System.Data.OracleClient
  namespace: System.Data.OracleClient
  summary: "获取一个值，返回的大小<xref href=&quot;System.Data.OracleClient.OracleLob&quot;> </xref>。"
  remarks: "大小<xref:System.Data.OracleClient.OracleLob>始终返回以字节为单位的所有数据。</xref:System.Data.OracleClient.OracleLob>"
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "大小<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>以字节为单位。"
  overload: System.Data.OracleClient.OracleLob.Length*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "连接已关闭。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "关闭或释放该对象。"
  - type: System.Data.OracleClient.OracleException
    commentId: T:System.Data.OracleClient.OracleException
    description: "Oracle 出错。"
  platform:
  - net462
- uid: System.Data.OracleClient.OracleLob.LobType
  id: LobType
  parent: System.Data.OracleClient.OracleLob
  langs:
  - csharp
  name: LobType
  nameWithType: OracleLob.LobType
  fullName: System.Data.OracleClient.OracleLob.LobType
  type: Property
  assemblies:
  - System.Data.OracleClient
  namespace: System.Data.OracleClient
  summary: "获取一个值，返回<xref uid=&quot;langword_csharp_LOB&quot; name=&quot;LOB&quot; href=&quot;&quot;></xref>数据类型。"
  remarks: "<xref:System.Data.OracleClient.OracleLob>可能是下列项之一<xref:System.Data.OracleClient.OracleType>数据类型。</xref:System.Data.OracleClient.OracleType> </xref:System.Data.OracleClient.OracleLob>      |OracleType 数据类型 |说明 |  |--------------------------|-----------------|  |`Blob`|Oracle`BLOB`包含最大大小为 4 千兆字节的二进制数据的数据类型。 此方法映射到类型<xref:System.Byte><xref:System.Array>。 |  |`Clob`|Oracle`CLOB`包含字符数据，基于默认字符的数据类型设置在服务器上，最大大小为 4 千兆字节。 </xref:System.Array></xref:System.Byte> 此方法映射到<xref:System.String>。 |  |`NClob`|Oracle`NCLOB`基于最大大小为 4 千兆字节在服务器上的区域字符集包含字符数据的数据类型。</xref:System.String> 此方法映射到<xref:System.String>。 |</xref:System.String>"
  syntax:
    content: public System.Data.OracleClient.OracleType LobType { get; }
    return:
      type: System.Data.OracleClient.OracleType
      description: "之一<xref href=&quot;System.Data.OracleClient.OracleType&quot;> </xref> <xref uid=&quot;langword_csharp_LOB&quot; name=&quot;LOB&quot; href=&quot;&quot;> </xref>数据类型。"
  overload: System.Data.OracleClient.OracleLob.LobType*
  exceptions: []
  platform:
  - net462
- uid: System.Data.OracleClient.OracleLob.Null
  id: "Null"
  parent: System.Data.OracleClient.OracleLob
  langs:
  - csharp
  name: "Null"
  nameWithType: OracleLob.Null
  fullName: System.Data.OracleClient.OracleLob.Null
  type: Field
  assemblies:
  - System.Data.OracleClient
  namespace: System.Data.OracleClient
  summary: "表示 null <xref href=&quot;System.Data.OracleClient.OracleLob&quot;> </xref>对象。"
  remarks: "可以构造<xref:System.Data.OracleClient.OracleLob>值为 NULL，使用此格式︰```   OracleLob myLob = OracleLOB.Null;   ```此方法主要用于测试是否`LOB`从服务器返回为 NULL，如本示例所示︰```   If(myLob == OracleLob.Null)   ```一个 NULL`LOB`的行为类似于零字节`LOB`在于<xref:System.Data.OracleClient.OracleLob.Read%2A>成功并始终返回零字节。</xref:System.Data.OracleClient.OracleLob.Read%2A> </xref:System.Data.OracleClient.OracleLob>"
  syntax:
    content: public static readonly System.Data.OracleClient.OracleLob Null;
    return:
      type: System.Data.OracleClient.OracleLob
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Data.OracleClient.OracleLob.Position
  id: Position
  parent: System.Data.OracleClient.OracleLob
  langs:
  - csharp
  name: Position
  nameWithType: OracleLob.Position
  fullName: System.Data.OracleClient.OracleLob.Position
  type: Property
  assemblies:
  - System.Data.OracleClient
  namespace: System.Data.OracleClient
  summary: "获取当前读取位置中的<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>流。"
  remarks: "流必须支持查找要获取或设置位置。 使用<xref:System.Data.OracleClient.OracleLob.CanSeek%2A>属性以确定流是否支持查找。</xref:System.Data.OracleClient.OracleLob.CanSeek%2A>       支持查找到流的长度超出任何位置。 查找到的奇数位置`CLOB`和`NCLOB`还支持数据类型。 有关详细信息，请参阅备注部分的<xref:System.Data.OracleClient.OracleLob.Read%2A>属性。</xref:System.Data.OracleClient.OracleLob.Read%2A>       位置属性不会不跟踪的从和 / 或已用完，跳过，流的字节数。"
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "中的当前位置<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>流。"
  overload: System.Data.OracleClient.OracleLob.Position*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "连接已关闭。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "关闭或释放该对象。"
  platform:
  - net462
- uid: System.Data.OracleClient.OracleLob.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.Data.OracleClient.OracleLob
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: OracleLob.Read(Byte[],Int32,Int32)
  fullName: System.Data.OracleClient.OracleLob.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - System.Data.OracleClient
  namespace: System.Data.OracleClient
  summary: "从当前读取的字节序列<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>流以及技术进步读取的字节数的流中的位置。"
  remarks: "Read 方法读取的最多`count`字节从当前流，并且将它们存储在`buffer`开始`offset`。 流中的当前位置高级通过读取; 的字节数但是，如果发生异常，将流中的当前位置保持不变。 读取返回读取的字节数。 仅当位置当前在流末尾，则返回值为零。 读取将一直阻止到至少一个字节的数据可供读取的事件中不会提供数据。如果你尝试从读取读取，则返回 0`LOB`当前位置时末尾`LOB`。 读取可以返回少于所请求的字节，即使尚未达到流结尾。       适用于 Oracle 的.NET Framework 数据提供程序将处理所有`CLOB`和`NCLOB`为 Unicode 数据。 因此，在访问时`CLOB`和`NCLOB`数据类型，你始终处理的字节，其中每个字符是 2 个字节数。 例如，如果包含三个字符的文本字符串保存为`NCLOB`Oracle 服务器的字符集为每个字符，4 个字节，其中你执行上`Read`操作，则指定的字符串的长度为 6 个字节，尽管已存储为在服务器上的 12 个字节。       下面的 C# 示例演示如何读取<xref:System.Data.OracleClient.OracleLob>对象。</xref:System.Data.OracleClient.OracleLob>      ```   public static void ReadLobExample(OracleCommand command)   {      int actual = 0;         //Select some data.      // Table Schema:      //  &quot;CREATE TABLE TableWithLobs (a int, b BLOB, c CLOB, d NCLOB)&quot;;      //  &quot;INSERT INTO TableWithLobs values (1, &quot;AA&quot;, &quot;AAA&quot;, N&quot;AAAA&quot;)&quot;;      command.CommandText = &quot;SELECT * FROM TableWithLobs&quot;;      OracleDataReader reader = command.ExecuteReader();      using(reader)      {         //Obtain the first row of data.         reader.Read();         //Obtain the LOBs (all 3 varieties).         OracleLob BLOB = reader.GetOracleLob(1);         OracleLob CLOB  = reader.GetOracleLob(2);         OracleLob NCLOB = reader.GetOracleLob(3);            //Example - Reading binary data (in chunks).         byte[] buffer = new byte[100];         while((actual = BLOB.Read(buffer, 0, buffer.Length)) >0)            Console.WriteLine(BLOB.LobType + &quot;.Read(&quot; + buffer + &quot;, &quot; + buffer.Length + &quot;) => &quot; + actual);            //Example - Reading CLOB/NCLOB data (in chunks).         //Note: You can read character data as raw Unicode bytes (using OracleLob.Read as in the above example).         //However, because the OracleLob object inherits directly from the.NET stream object,          //all the existing classes that manipluate streams can also be used. For example, the          //.NET StreamReader makes converting the raw bytes into actual characters easier.         StreamReader streamreader = new StreamReader(CLOB, Encoding.Unicode);         char[] cbuffer = new char[100];         while((actual = streamreader.Read(cbuffer, 0, cbuffer.Length)) >0)            Console.WriteLine(CLOB.LobType + &quot;.Read(&quot; + new string(cbuffer, 0, actual) + &quot;, &quot; + cbuffer.Length + &quot;) => &quot; + actual);            //Example - Reading data (all at once).         //You could use StreamReader.ReadToEnd to obtain all the string data,or simply         //call OracleLob.Value to obtain a contiguous allocation of all the data.         Console.WriteLine(NCLOB.LobType + &quot;.Value => &quot; + NCLOB.Value);      }   }   ```您可以构造<xref:System.Data.OracleClient.OracleLob>值为 NULL，使用此格式︰```   OracleLob myLob = OracleLob.Null;   ```此方法主要用于测试是否`LOB`从服务器返回为 NULL，如下面的示例所示。</xref:System.Data.OracleClient.OracleLob>      ```   If(myLob == OracleLob.Null)   ```NULL`LOB`的行为类似于零字节`LOB`，读取成功，并始终返回零字节。"
  syntax:
    content: public override int Read (byte[] buffer, int offset, int count);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "字节数组。 此方法返回时，该缓冲区包含指定的字节数组之间的值`offset`和 (`offset` + `count`) 由从当前源中读取的字节替换。"
    - id: offset
      type: System.Int32
      description: "中的从零开始的字节偏移量`buffer`从此处开始存储读取的数据从当前流。 有关<xref uid=&quot;langword_csharp_CLOB&quot; name=&quot;CLOB&quot; href=&quot;&quot;></xref>和<xref uid=&quot;langword_csharp_NCLOB&quot; name=&quot;NCLOB&quot; href=&quot;&quot;></xref>数据类型，这必须是偶数。"
    - id: count
      type: System.Int32
      description: "最大要从当前流中读取的字节数。 有关<xref uid=&quot;langword_csharp_CLOB&quot; name=&quot;CLOB&quot; href=&quot;&quot;></xref>和<xref uid=&quot;langword_csharp_NCLOB&quot; name=&quot;NCLOB&quot; href=&quot;&quot;></xref>数据类型，这必须是偶数。"
    return:
      type: System.Int32
      description: "读取到缓冲区的字节总数。 这可能小于请求的字节数如果很多字节当前不可用，或为零 (0) 如果已到达流结尾。"
  overload: System.Data.OracleClient.OracleLob.Read*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code> buffer </code>为空引用 (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref>在 Visual Basic 中)。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "中的值<code> offset </code>或<code> count </code>参数不是正数。       -或者-偏移量和计数参数的总和大于缓冲区长度。       -中指定的值<code> amount </code>或<code> offset </code>参数小于零或大于 4 千兆字节。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "该操作不在事务内<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>对象为 null，或连接已关闭。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "关闭或释放该对象。"
  - type: System.Data.OracleClient.OracleException
    commentId: T:System.Data.OracleClient.OracleException
    description: "Oracle 出错。"
  platform:
  - net462
- uid: System.Data.OracleClient.OracleLob.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.Data.OracleClient.OracleLob
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: OracleLob.Seek(Int64,SeekOrigin)
  fullName: System.Data.OracleClient.OracleLob.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - System.Data.OracleClient
  namespace: System.Data.OracleClient
  summary: "对当前设置的位置<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>流。"
  remarks: "如果`offset`为负，新位置必须位于之前指定的位置`origin`按指定的字节数`offset`。 如果`offset`为零，新位置必须是指定的位置`origin`。 如果`offset`为正，新位置必须遵循指定的位置`origin`按指定的字节数`offset`。       支持查找到流的长度超出任何位置。 查找到的奇数位置`CLOB`和`NCLOB`还支持数据类型。 有关详细信息，请参阅备注部分的<xref:System.Data.OracleClient.OracleLob.Read%2A>属性。</xref:System.Data.OracleClient.OracleLob.Read%2A>"
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "相对于原点的字节偏移量。 如果`offset`为负，新位置之前指定的位置`origin`按指定的字节数`offset`。 如果`offset`为零，新的位置是由指定的位置`origin`。 如果`offset`为正，通过指定的位置的新位置之后`origin`按指定的字节数`offset`。"
    - id: origin
      type: System.IO.SeekOrigin
      description: "类型的值<xref:System.IO.SeekOrigin>，该值指示用于获取新位置的参考点。</xref:System.IO.SeekOrigin>"
    return:
      type: System.Int64
      description: "当前流中的新位置。"
  overload: System.Data.OracleClient.OracleLob.Seek*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> origin </code>参数不包含有效的值。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "生成的位置不在值的长度。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Data.OracleClient.OracleLob&quot;> </xref>对象已关闭或释放。"
  - type: System.Data.OracleClient.OracleException
    commentId: T:System.Data.OracleClient.OracleException
    description: "Oracle 出错。"
  platform:
  - net462
- uid: System.Data.OracleClient.OracleLob.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.Data.OracleClient.OracleLob
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: OracleLob.SetLength(Int64)
  fullName: System.Data.OracleClient.OracleLob.SetLength(Int64)
  type: Method
  assemblies:
  - System.Data.OracleClient
  namespace: System.Data.OracleClient
  summary: "设置的长度<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>流到小于的当前长度的值。"
  remarks: "尝试增加的长度<xref:System.Data.OracleClient.OracleLob>流失败，并返回&quot;消息︰ ORA&22926;︰ 指定剪裁长度大于当前 LOB 值的长度&quot;从 Oracle 服务器。</xref:System.Data.OracleClient.OracleLob>       流必须支持写入和查找有关 SetLength 到函数。       适用于 Oracle 的.NET Framework 数据提供程序将处理所有`CLOB`和`NCLOB`为 Unicode 数据。 因此，在访问时`CLOB`和`NCLOB`数据类型，你始终处理的字节，其中每个字符是 2 个字节数。 例如，如果包含三个字符的文本字符串保存为`NCLOB`Oracle 服务器的字符集为每个字符，4 个字节，其中你执行上`SetLength`操作，则指定的字符串的长度为 6 个字节，尽管已存储为在服务器上的 12 个字节。       要写入到`LOB`，您必须检索`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 语句，还必须具有开始的本地事务。      1> [!NOTE]&1;> A 会写入操作的只读`LOB`可能会成功，但不会更新`LOB`服务器上。 在这种情况下，但是的本地副本`LOB`更新。 因此，更高版本上读取操作<xref:System.Data.OracleClient.OracleLob>对象可能会返回写入操作的结果。</xref:System.Data.OracleClient.OracleLob>"
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "所需的当前长度<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>以字节为单位的流。 有关<xref uid=&quot;langword_csharp_CLOB&quot; name=&quot;CLOB&quot; href=&quot;&quot;></xref>和<xref uid=&quot;langword_csharp_NCLOB&quot; name=&quot;NCLOB&quot; href=&quot;&quot;></xref>数据类型，这必须是偶数。"
  overload: System.Data.OracleClient.OracleLob.SetLength*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "中指定的值<code> value </code>参数<xref uid=&quot;langword_csharp_CLOB&quot; name=&quot;CLOB&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_NCLOB&quot; name=&quot;NCLOB&quot; href=&quot;&quot;></xref>数据类型不是偶数。       -中指定的值<code> value </code>参数小于零或大于 4 千兆字节。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "该操作不在事务内<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>对象为 null，或连接已关闭。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "关闭或释放该对象。"
  - type: System.Data.OracleClient.OracleException
    commentId: T:System.Data.OracleClient.OracleException
    description: "Oracle 出错。"
  platform:
  - net462
- uid: System.Data.OracleClient.OracleLob.Value
  id: Value
  parent: System.Data.OracleClient.OracleLob
  langs:
  - csharp
  name: Value
  nameWithType: OracleLob.Value
  fullName: System.Data.OracleClient.OracleLob.Value
  type: Property
  assemblies:
  - System.Data.OracleClient
  namespace: System.Data.OracleClient
  summary: "获取公共语言运行时流值等效的基础值。"
  remarks: "有关<xref:System.Data.OracleClient.OracleType>数据类型值返回整个基础数据类型的连续数组作为`Byte[]`。</xref:System.Data.OracleClient.OracleType> 有关<xref:System.Data.OracleClient.OracleType>和<xref:System.Data.OracleClient.OracleType>数据类型值将返回所有数据作为`String`数据类型。</xref:System.Data.OracleClient.OracleType> </xref:System.Data.OracleClient.OracleType> 对于 null 数据值返回<xref:System.DBNull>.</xref:System.DBNull> 通过比较返回的值，可以区分空数据、 null 数据和数据。      1> [!NOTE]&1;> 使用的优点`LOB`数据类型是可检索大量数据在客户端的小区块中的功能。 但是，当使用值时，你获得的所有数据`LOB`列作为一个连续的区块，这可以显著提高应用程序开销。"
  syntax:
    content: public object Value { get; }
    return:
      type: System.Object
      description: "For <xref href=&quot;System.Data.OracleClient.OracleType&quot;></xref>, an array of type <xref uid=&quot;langword_csharp_Byte[]&quot; name=&quot;Byte[]&quot; href=&quot;&quot;></xref>. For <xref href=&quot;System.Data.OracleClient.OracleType&quot;></xref> and <xref href=&quot;System.Data.OracleClient.OracleType&quot;></xref>, a <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>. 为 null 数据一样， <xref href=&quot;System.DBNull&quot;> </xref>。"
  overload: System.Data.OracleClient.OracleLob.Value*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "关闭或释放该对象。"
  - type: System.Data.OracleClient.OracleException
    commentId: T:System.Data.OracleClient.OracleException
    description: "Oracle 出错。"
  platform:
  - net462
- uid: System.Data.OracleClient.OracleLob.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.Data.OracleClient.OracleLob
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: OracleLob.Write(Byte[],Int32,Int32)
  fullName: System.Data.OracleClient.OracleLob.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - System.Data.OracleClient
  namespace: System.Data.OracleClient
  summary: "将一个字节序列写入当前<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>流处理时，并使此流中的当前位置提升写入的字节数。"
  remarks: "如果写入操作成功，将流内的位置向前移动写入的字节数。 如果发生异常，流中的位置将保持不变。       结尾之外写入`LOB`允许和放大`LOB`通过写入的字节数。       适用于 Oracle 的.NET Framework 数据提供程序将处理所有`CLOB`和`NCLOB`为 Unicode 数据。 因此，在访问时`CLOB`和`NCLOB`数据类型，你始终处理的字节，其中每个字符是 2 个字节数。 例如，如果包含三个字符的文本字符串保存为`NCLOB`Oracle 服务器的字符集为每个字符，4 个字节，其中你执行上`Write`操作，则指定的字符串的长度为 6 个字节，尽管已存储为在服务器上的 12 个字节。       要写入到`LOB`，您必须检索`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 语句，还必须具有开始的本地事务。       下面的 C# 示例演示如何将写入到<xref:System.Data.OracleClient.OracleLob>对象。</xref:System.Data.OracleClient.OracleLob>      ```   public static void WriteLobExample(OracleCommand command)   {      //Note: Updating LOB data requires a transaction.      command.Transaction = command.Connection.BeginTransaction();      //Select some data.      //    Table Schema:      //        &quot;CREATE TABLE tablewithlobs (a int, b BLOB, c BLOB)&quot;;      //        &quot;INSERT INTO tablewithlobs values (1, &quot;AA&quot;, &quot;AAA&quot;)&quot;;      command.CommandText = &quot;SELECT * FROM TableWithLobs FOR UPDATE&quot;;      OracleDataReader reader = command.ExecuteReader();      using(reader)      {         //Obtain the first row of data.         reader.Read();         //Obtain both LOBs.         OracleLob BLOB1    = reader.GetOracleLob(1);         OracleLob BLOB2    = reader.GetOracleLob(2);         //Perform any desired operations on the LOB, (read, position, and so on).         //...         //Example - Writing binary data (directly to the backend).         //To write, you can use any of the stream classes, or write raw binary data using          //the OracleLob write method. Writing character vs. binary is the same;         //however note that character is always in terms of Unicode byte counts         //(for example: even number of bytes - 2 bytes for every Unicode character).         byte[] buffer = new byte[100];         buffer[0] = 0xCC;         buffer[1] = 0xDD;         BLOB1.Write(buffer, 0, 2);         BLOB1.Position = 0;         Console.WriteLine(BLOB1.LobType + &quot;.Write(&quot; + buffer + &quot;, 0, 2) => &quot; + BLOB1.Value);            //Example - Copying data into another LOB.         long actual = BLOB1.CopyTo(BLOB2);         Console.WriteLine(BLOB1.LobType + &quot;.CopyTo(&quot; + BLOB2.Value + &quot;) => &quot; + actual);            //Commit the transaction now that everything succeeded.         //Note: On error, Transaction.Dispose is called (from the using statement)         //and will automatically roll-back the pending transaction.         command.Transaction.Commit();      }   }   ```      > [!NOTE]1> A 会写入操作的只读`LOB`可能会成功，但不会更新`LOB`服务器上。 在这种情况下，但是的本地副本`LOB`更新。 因此，更高版本上读取操作<xref:System.Data.OracleClient.OracleLob>对象可能会返回写入操作的结果。</xref:System.Data.OracleClient.OracleLob>"
  syntax:
    content: public override void Write (byte[] buffer, int offset, int count);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "字节数组。 此方法会复制中指定的字节数`count`从`buffer`写入当前流。"
    - id: offset
      type: System.Int32
      description: "中的从零开始的字节偏移量`buffer`从此处开始将字节复制到当前流。 有关<xref uid=&quot;langword_csharp_CLOB&quot; name=&quot;CLOB&quot; href=&quot;&quot;></xref>和<xref uid=&quot;langword_csharp_NCLOB&quot; name=&quot;NCLOB&quot; href=&quot;&quot;></xref>数据类型，这必须是偶数。"
    - id: count
      type: System.Int32
      description: "要写入当前流的字节数。 有关<xref uid=&quot;langword_csharp_CLOB&quot; name=&quot;CLOB&quot; href=&quot;&quot;></xref>和<xref uid=&quot;langword_csharp_NCLOB&quot; name=&quot;NCLOB&quot; href=&quot;&quot;></xref>数据类型，这必须是偶数。"
  overload: System.Data.OracleClient.OracleLob.Write*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code> buffer </code>参数为空引用 (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref>在 Visual Basic 中)。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "中的值<code> offset </code>或<code> count </code>参数不是正数。       -的总和<code> offset </code>和<code> count </code>参数大于<code> buffer </code>长度。       -中指定的值<code> count </code>或<code> offset </code>参数小于零或大于 4 千兆字节。       -或-你必须指定<xref uid=&quot;langword_csharp_CLOB&quot; name=&quot;CLOB&quot; href=&quot;&quot;></xref>和<xref uid=&quot;langword_csharp_NCLOB&quot; name=&quot;NCLOB&quot; href=&quot;&quot;></xref>为偶数的字节的数据类型。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "该操作不在事务内<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>对象为 null，或连接已关闭。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "关闭或释放该对象。"
  - type: System.Data.OracleClient.OracleException
    commentId: T:System.Data.OracleClient.OracleException
    description: "Oracle 出错。"
  platform:
  - net462
- uid: System.Data.OracleClient.OracleLob.WriteByte(System.Byte)
  id: WriteByte(System.Byte)
  parent: System.Data.OracleClient.OracleLob
  langs:
  - csharp
  name: WriteByte(Byte)
  nameWithType: OracleLob.WriteByte(Byte)
  fullName: System.Data.OracleClient.OracleLob.WriteByte(Byte)
  type: Method
  assemblies:
  - System.Data.OracleClient
  namespace: System.Data.OracleClient
  summary: "将一个字节写入中的当前位置<xref href=&quot;System.Data.OracleClient.OracleLob&quot;></xref>流处理时，并将流中的位置提升一个字节。"
  remarks: "如果写入操作是否成功，将流中的位置向前推进&1; 个字节。 如果发生异常，流中的位置将保持不变。       结尾之外写入`LOB`允许和放大`LOB`1 个字节。       要写入到`LOB`，您必须检索`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 语句，还必须具有开始的本地事务。      1> [!NOTE]&1;> A 会写入操作的只读`LOB`可能会成功，但不会更新`LOB`服务器上。 在这种情况下，但是的本地副本`LOB`更新。 因此，更高版本上读取操作<xref:System.Data.OracleClient.OracleLob>对象可能会返回写入操作的结果。</xref:System.Data.OracleClient.OracleLob>"
  syntax:
    content: public override void WriteByte (byte value);
    parameters:
    - id: value
      type: System.Byte
      description: "要写入到流的字节。"
  overload: System.Data.OracleClient.OracleLob.WriteByte*
  exceptions: []
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.Data.OracleClient.OracleException
  parent: System.Data.OracleClient
  isExternal: false
  name: OracleException
  nameWithType: OracleException
  fullName: System.Data.OracleClient.OracleException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Data.OracleClient.OracleLob.Append(System.Data.OracleClient.OracleLob)
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: Append(OracleLob)
  nameWithType: OracleLob.Append(OracleLob)
  fullName: System.Data.OracleClient.OracleLob.Append(OracleLob)
- uid: System.Data.OracleClient.OracleLob
  parent: System.Data.OracleClient
  isExternal: false
  name: OracleLob
  nameWithType: OracleLob
  fullName: System.Data.OracleClient.OracleLob
- uid: System.Data.OracleClient.OracleLob.BeginBatch
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: BeginBatch()
  nameWithType: OracleLob.BeginBatch()
  fullName: System.Data.OracleClient.OracleLob.BeginBatch()
- uid: System.Data.OracleClient.OracleLob.BeginBatch(System.Data.OracleClient.OracleLobOpenMode)
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: BeginBatch(OracleLobOpenMode)
  nameWithType: OracleLob.BeginBatch(OracleLobOpenMode)
  fullName: System.Data.OracleClient.OracleLob.BeginBatch(OracleLobOpenMode)
- uid: System.Data.OracleClient.OracleLobOpenMode
  parent: System.Data.OracleClient
  isExternal: false
  name: OracleLobOpenMode
  nameWithType: OracleLobOpenMode
  fullName: System.Data.OracleClient.OracleLobOpenMode
- uid: System.Data.OracleClient.OracleLob.CanRead
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: CanRead
  nameWithType: OracleLob.CanRead
  fullName: System.Data.OracleClient.OracleLob.CanRead
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Data.OracleClient.OracleLob.CanSeek
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: CanSeek
  nameWithType: OracleLob.CanSeek
  fullName: System.Data.OracleClient.OracleLob.CanSeek
- uid: System.Data.OracleClient.OracleLob.CanWrite
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: CanWrite
  nameWithType: OracleLob.CanWrite
  fullName: System.Data.OracleClient.OracleLob.CanWrite
- uid: System.Data.OracleClient.OracleLob.ChunkSize
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: ChunkSize
  nameWithType: OracleLob.ChunkSize
  fullName: System.Data.OracleClient.OracleLob.ChunkSize
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Data.OracleClient.OracleLob.Clone
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: Clone()
  nameWithType: OracleLob.Clone()
  fullName: System.Data.OracleClient.OracleLob.Clone()
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Data.OracleClient.OracleLob.Connection
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: Connection
  nameWithType: OracleLob.Connection
  fullName: System.Data.OracleClient.OracleLob.Connection
- uid: System.Data.OracleClient.OracleConnection
  parent: System.Data.OracleClient
  isExternal: false
  name: OracleConnection
  nameWithType: OracleConnection
  fullName: System.Data.OracleClient.OracleConnection
- uid: System.Data.OracleClient.OracleLob.CopyTo(System.Data.OracleClient.OracleLob)
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: CopyTo(OracleLob)
  nameWithType: OracleLob.CopyTo(OracleLob)
  fullName: System.Data.OracleClient.OracleLob.CopyTo(OracleLob)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Data.OracleClient.OracleLob.CopyTo(System.Data.OracleClient.OracleLob,System.Int64)
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: CopyTo(OracleLob,Int64)
  nameWithType: OracleLob.CopyTo(OracleLob,Int64)
  fullName: System.Data.OracleClient.OracleLob.CopyTo(OracleLob,Int64)
- uid: System.Data.OracleClient.OracleLob.CopyTo(System.Int64,System.Data.OracleClient.OracleLob,System.Int64,System.Int64)
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: CopyTo(Int64,OracleLob,Int64,Int64)
  nameWithType: OracleLob.CopyTo(Int64,OracleLob,Int64,Int64)
  fullName: System.Data.OracleClient.OracleLob.CopyTo(Int64,OracleLob,Int64,Int64)
- uid: System.Data.OracleClient.OracleLob.Dispose(System.Boolean)
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: OracleLob.Dispose(Boolean)
  fullName: System.Data.OracleClient.OracleLob.Dispose(Boolean)
- uid: System.Data.OracleClient.OracleLob.EndBatch
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: EndBatch()
  nameWithType: OracleLob.EndBatch()
  fullName: System.Data.OracleClient.OracleLob.EndBatch()
- uid: System.Data.OracleClient.OracleLob.Erase
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: Erase()
  nameWithType: OracleLob.Erase()
  fullName: System.Data.OracleClient.OracleLob.Erase()
- uid: System.Data.OracleClient.OracleLob.Erase(System.Int64,System.Int64)
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: Erase(Int64,Int64)
  nameWithType: OracleLob.Erase(Int64,Int64)
  fullName: System.Data.OracleClient.OracleLob.Erase(Int64,Int64)
- uid: System.Data.OracleClient.OracleLob.Flush
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: Flush()
  nameWithType: OracleLob.Flush()
  fullName: System.Data.OracleClient.OracleLob.Flush()
- uid: System.Data.OracleClient.OracleLob.IsBatched
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: IsBatched
  nameWithType: OracleLob.IsBatched
  fullName: System.Data.OracleClient.OracleLob.IsBatched
- uid: System.Data.OracleClient.OracleLob.IsNull
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: IsNull
  nameWithType: OracleLob.IsNull
  fullName: System.Data.OracleClient.OracleLob.IsNull
- uid: System.Data.OracleClient.OracleLob.IsTemporary
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: IsTemporary
  nameWithType: OracleLob.IsTemporary
  fullName: System.Data.OracleClient.OracleLob.IsTemporary
- uid: System.Data.OracleClient.OracleLob.Length
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: Length
  nameWithType: OracleLob.Length
  fullName: System.Data.OracleClient.OracleLob.Length
- uid: System.Data.OracleClient.OracleLob.LobType
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: LobType
  nameWithType: OracleLob.LobType
  fullName: System.Data.OracleClient.OracleLob.LobType
- uid: System.Data.OracleClient.OracleType
  parent: System.Data.OracleClient
  isExternal: false
  name: OracleType
  nameWithType: OracleType
  fullName: System.Data.OracleClient.OracleType
- uid: System.Data.OracleClient.OracleLob.Null
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: "Null"
  nameWithType: OracleLob.Null
  fullName: System.Data.OracleClient.OracleLob.Null
- uid: System.Data.OracleClient.OracleLob.Position
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: Position
  nameWithType: OracleLob.Position
  fullName: System.Data.OracleClient.OracleLob.Position
- uid: System.Data.OracleClient.OracleLob.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: OracleLob.Read(Byte[],Int32,Int32)
  fullName: System.Data.OracleClient.OracleLob.Read(Byte[],Int32,Int32)
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Data.OracleClient.OracleLob.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: OracleLob.Seek(Int64,SeekOrigin)
  fullName: System.Data.OracleClient.OracleLob.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.Data.OracleClient.OracleLob.SetLength(System.Int64)
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: SetLength(Int64)
  nameWithType: OracleLob.SetLength(Int64)
  fullName: System.Data.OracleClient.OracleLob.SetLength(Int64)
- uid: System.Data.OracleClient.OracleLob.Value
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: Value
  nameWithType: OracleLob.Value
  fullName: System.Data.OracleClient.OracleLob.Value
- uid: System.Data.OracleClient.OracleLob.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: OracleLob.Write(Byte[],Int32,Int32)
  fullName: System.Data.OracleClient.OracleLob.Write(Byte[],Int32,Int32)
- uid: System.Data.OracleClient.OracleLob.WriteByte(System.Byte)
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: WriteByte(Byte)
  nameWithType: OracleLob.WriteByte(Byte)
  fullName: System.Data.OracleClient.OracleLob.WriteByte(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.Data.OracleClient.OracleLob.Append*
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: Append
  nameWithType: OracleLob.Append
- uid: System.Data.OracleClient.OracleLob.BeginBatch*
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: BeginBatch
  nameWithType: OracleLob.BeginBatch
- uid: System.Data.OracleClient.OracleLob.CanRead*
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: CanRead
  nameWithType: OracleLob.CanRead
- uid: System.Data.OracleClient.OracleLob.CanSeek*
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: CanSeek
  nameWithType: OracleLob.CanSeek
- uid: System.Data.OracleClient.OracleLob.CanWrite*
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: CanWrite
  nameWithType: OracleLob.CanWrite
- uid: System.Data.OracleClient.OracleLob.ChunkSize*
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: ChunkSize
  nameWithType: OracleLob.ChunkSize
- uid: System.Data.OracleClient.OracleLob.Clone*
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: Clone
  nameWithType: OracleLob.Clone
- uid: System.Data.OracleClient.OracleLob.Connection*
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: Connection
  nameWithType: OracleLob.Connection
- uid: System.Data.OracleClient.OracleLob.CopyTo*
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: CopyTo
  nameWithType: OracleLob.CopyTo
- uid: System.Data.OracleClient.OracleLob.Dispose*
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: Dispose
  nameWithType: OracleLob.Dispose
- uid: System.Data.OracleClient.OracleLob.EndBatch*
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: EndBatch
  nameWithType: OracleLob.EndBatch
- uid: System.Data.OracleClient.OracleLob.Erase*
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: Erase
  nameWithType: OracleLob.Erase
- uid: System.Data.OracleClient.OracleLob.Flush*
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: Flush
  nameWithType: OracleLob.Flush
- uid: System.Data.OracleClient.OracleLob.IsBatched*
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: IsBatched
  nameWithType: OracleLob.IsBatched
- uid: System.Data.OracleClient.OracleLob.IsNull*
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: IsNull
  nameWithType: OracleLob.IsNull
- uid: System.Data.OracleClient.OracleLob.IsTemporary*
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: IsTemporary
  nameWithType: OracleLob.IsTemporary
- uid: System.Data.OracleClient.OracleLob.Length*
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: Length
  nameWithType: OracleLob.Length
- uid: System.Data.OracleClient.OracleLob.LobType*
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: LobType
  nameWithType: OracleLob.LobType
- uid: System.Data.OracleClient.OracleLob.Position*
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: Position
  nameWithType: OracleLob.Position
- uid: System.Data.OracleClient.OracleLob.Read*
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: Read
  nameWithType: OracleLob.Read
- uid: System.Data.OracleClient.OracleLob.Seek*
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: Seek
  nameWithType: OracleLob.Seek
- uid: System.Data.OracleClient.OracleLob.SetLength*
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: SetLength
  nameWithType: OracleLob.SetLength
- uid: System.Data.OracleClient.OracleLob.Value*
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: Value
  nameWithType: OracleLob.Value
- uid: System.Data.OracleClient.OracleLob.Write*
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: Write
  nameWithType: OracleLob.Write
- uid: System.Data.OracleClient.OracleLob.WriteByte*
  parent: System.Data.OracleClient.OracleLob
  isExternal: false
  name: WriteByte
  nameWithType: OracleLob.WriteByte
