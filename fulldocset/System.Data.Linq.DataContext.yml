### YamlMime:ManagedReference
items:
- uid: System.Data.Linq.DataContext
  id: DataContext
  children:
  - System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection)
  - System.Data.Linq.DataContext.#ctor(System.String)
  - System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection,System.Data.Linq.Mapping.MappingSource)
  - System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)
  - System.Data.Linq.DataContext.ChangeConflicts
  - System.Data.Linq.DataContext.CommandTimeout
  - System.Data.Linq.DataContext.Connection
  - System.Data.Linq.DataContext.CreateDatabase
  - System.Data.Linq.DataContext.CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])
  - System.Data.Linq.DataContext.DatabaseExists
  - System.Data.Linq.DataContext.DeferredLoadingEnabled
  - System.Data.Linq.DataContext.DeleteDatabase
  - System.Data.Linq.DataContext.Dispose
  - System.Data.Linq.DataContext.Dispose(System.Boolean)
  - System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])
  - System.Data.Linq.DataContext.ExecuteDynamicDelete(System.Object)
  - System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)
  - System.Data.Linq.DataContext.ExecuteDynamicUpdate(System.Object)
  - System.Data.Linq.DataContext.ExecuteMethodCall(System.Object,System.Reflection.MethodInfo,System.Object[])
  - System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])
  - System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])
  - System.Data.Linq.DataContext.GetChangeSet
  - System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)
  - System.Data.Linq.DataContext.GetTable(System.Type)
  - System.Data.Linq.DataContext.GetTable``1
  - System.Data.Linq.DataContext.LoadOptions
  - System.Data.Linq.DataContext.Log
  - System.Data.Linq.DataContext.Mapping
  - System.Data.Linq.DataContext.ObjectTrackingEnabled
  - System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Collections.IEnumerable)
  - System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object)
  - System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object[])
  - System.Data.Linq.DataContext.SubmitChanges
  - System.Data.Linq.DataContext.SubmitChanges(System.Data.Linq.ConflictMode)
  - System.Data.Linq.DataContext.Transaction
  - System.Data.Linq.DataContext.Translate(System.Data.Common.DbDataReader)
  - System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)
  - System.Data.Linq.DataContext.Translate``1(System.Data.Common.DbDataReader)
  langs:
  - csharp
  name: DataContext
  nameWithType: DataContext
  fullName: System.Data.Linq.DataContext
  type: Class
  summary: "表示的主入口点[!INCLUDE[vbtecdlinq](~/add/includes/vbtecdlinq-md.md)]framework。"
  remarks: "在 DataContext 是通过数据库连接映射的所有实体的源。 它跟踪对检索到的所有实体所做的更改并保留&quot;标识缓存&quot;表示实体检索不止一次的保证使用同一个对象实例。       一般情况下，DataContext 实例旨在持续一个&quot;的工作单位&quot;应用程序但是定义该术语。 DataContext 是轻量，并且不创建开销很大。 典型[!INCLUDE[vbtecdlinq](~/add/includes/vbtecdlinq-md.md)]应用程序创建 DataContext 实例，在方法范围内或表示一组逻辑的相关的数据库操作的生存期较短类成员。"
  syntax:
    content: 'public class DataContext : IDisposable'
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection)
  id: '#ctor(System.Data.IDbConnection)'
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: DataContext(IDbConnection)
  nameWithType: DataContext.DataContext(IDbConnection)
  fullName: System.Data.Linq.DataContext.DataContext(IDbConnection)
  type: Constructor
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "初始化的新实例<xref href=&quot;System.Data.Linq.DataContext&quot;></xref>类通过引用使用的连接[!INCLUDE[dnprdnshort](~/add/includes/dnprdnshort-md.md)]。"
  remarks: "A<xref:System.Data.Linq.DataContext>打开和关闭数据库连接，根据需要如果您提供关闭的连接或连接字符串。</xref:System.Data.Linq.DataContext> 一般情况下，你应永远不需要调用`Dispose` <xref:System.Data.Linq.DataContext>。</xref:System.Data.Linq.DataContext> 如果你提供的打开连接，<xref:System.Data.Linq.DataContext>不会关闭它。</xref:System.Data.Linq.DataContext> 因此，不要实例化<xref:System.Data.Linq.DataContext>具有打开的连接除非你有理由要这样做。</xref:System.Data.Linq.DataContext> 在<xref:System.Transactions>事务，<xref:System.Data.Linq.DataContext>将不打开或关闭的连接，为了避免出现提升。</xref:System.Data.Linq.DataContext> </xref:System.Transactions>"
  syntax:
    content: public DataContext (System.Data.IDbConnection connection);
    parameters:
    - id: connection
      type: System.Data.IDbConnection
      description: "使用的连接[!INCLUDE[dnprdnshort](~/add/includes/dnprdnshort-md.md)]。"
  overload: System.Data.Linq.DataContext.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.#ctor(System.String)
  id: '#ctor(System.String)'
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: DataContext(String)
  nameWithType: DataContext.DataContext(String)
  fullName: System.Data.Linq.DataContext.DataContext(String)
  type: Constructor
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "初始化的新实例<xref href=&quot;System.Data.Linq.DataContext&quot;></xref>通过引用文件源的类。"
  syntax:
    content: public DataContext (string fileOrServerOrConnection);
    parameters:
    - id: fileOrServerOrConnection
      type: System.String
      description: "此参数可以是任何以下一项︰ SQL Server Express 数据库所在的文件的名称。       数据库为存在的服务器的名称。 在这种情况下提供程序的用户使用的默认数据库。       完整的连接字符串。 [!INCLUDE[vbtecdlinq](~/add/includes/vbtecdlinq-md.md)]只需将字符串传递给提供程序而不进行修改。"
  overload: System.Data.Linq.DataContext.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection,System.Data.Linq.Mapping.MappingSource)
  id: '#ctor(System.Data.IDbConnection,System.Data.Linq.Mapping.MappingSource)'
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: DataContext(IDbConnection,MappingSource)
  nameWithType: DataContext.DataContext(IDbConnection,MappingSource)
  fullName: System.Data.Linq.DataContext.DataContext(IDbConnection,MappingSource)
  type: Constructor
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "初始化的新实例<xref href=&quot;System.Data.Linq.DataContext&quot;></xref>引用连接和映射源类。"
  syntax:
    content: public DataContext (System.Data.IDbConnection connection, System.Data.Linq.Mapping.MappingSource mapping);
    parameters:
    - id: connection
      type: System.Data.IDbConnection
      description: "使用.NET Framework 的连接。"
    - id: mapping
      type: System.Data.Linq.Mapping.MappingSource
      description: "用于映射的源。"
  overload: System.Data.Linq.DataContext.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)
  id: '#ctor(System.String,System.Data.Linq.Mapping.MappingSource)'
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: DataContext(String,MappingSource)
  nameWithType: DataContext.DataContext(String,MappingSource)
  fullName: System.Data.Linq.DataContext.DataContext(String,MappingSource)
  type: Constructor
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "初始化的新实例<xref href=&quot;System.Data.Linq.DataContext&quot;></xref>通过引用文件源和映射源类。"
  syntax:
    content: public DataContext (string fileOrServerOrConnection, System.Data.Linq.Mapping.MappingSource mapping);
    parameters:
    - id: fileOrServerOrConnection
      type: System.String
      description: "此参数可以是任何以下一项︰ SQL Server Express 数据库所在的文件的名称。       数据库为存在的服务器的名称。 在这种情况下提供程序的用户使用的默认数据库。       完整的连接字符串。 [!INCLUDE[vbtecdlinq](~/add/includes/vbtecdlinq-md.md)]只需将字符串传递给提供程序而不进行修改。"
    - id: mapping
      type: System.Data.Linq.Mapping.MappingSource
      description: "用于映射的源。"
  overload: System.Data.Linq.DataContext.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.ChangeConflicts
  id: ChangeConflicts
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: ChangeConflicts
  nameWithType: DataContext.ChangeConflicts
  fullName: System.Data.Linq.DataContext.ChangeConflicts
  type: Property
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "获取导致并发冲突的对象的集合时<xref:System.Data.Linq.DataContext.SubmitChanges*>曾。</xref:System.Data.Linq.DataContext.SubmitChanges*>"
  remarks: "下面的示例演示如何集合可以循环访问，以检索冲突信息。"
  example:
  - >-
    [!code-cs[System.Data.Linq.ObjectChangeConflict#1](~/add/codesnippet/csharp/objconflict/program.cs#1)]
     [!code-vb[System.Data.Linq.ObjectChangeConflict#1](~/add/codesnippet/visualbasic/objconflict/module1.vb#1)]
  syntax:
    content: public System.Data.Linq.ChangeConflictCollection ChangeConflicts { get; }
    return:
      type: System.Data.Linq.ChangeConflictCollection
      description: "导致并发冲突的对象的集合。"
  overload: System.Data.Linq.DataContext.ChangeConflicts*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.CommandTimeout
  id: CommandTimeout
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: CommandTimeout
  nameWithType: DataContext.CommandTimeout
  fullName: System.Data.Linq.DataContext.CommandTimeout
  type: Property
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "获取或设置一个值，会增加在默认超时期限内将否则为超时的查询的超时期限。"
  remarks: "此属性获取或设置用于执行生成的命令的命令超时值 (`IDbCommands`)。 有关详细信息，请参阅<xref:System.Data.IDbCommand.CommandTimeout%2A>。</xref:System.Data.IDbCommand.CommandTimeout%2A>       当此属性未设置，默认值的<xref:System.Data.IDbCommand.CommandTimeout%2A>用于执行查询命令。</xref:System.Data.IDbCommand.CommandTimeout%2A> 此默认值由存储提供程序设置。 请注意，某些访问接口可能引发异常，是否此值设置为非零值。"
  syntax:
    content: public int CommandTimeout { get; set; }
    return:
      type: System.Int32
      description: "一个整数值可提高在默认超时期限内将否则为超时的查询的超时期限。"
  overload: System.Data.Linq.DataContext.CommandTimeout*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.Connection
  id: Connection
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: Connection
  nameWithType: DataContext.Connection
  fullName: System.Data.Linq.DataContext.Connection
  type: Property
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "获取由框架使用的连接。"
  remarks: "可以使用此属性与关系的 ADO.NET 代码进行互操作。       返回的连接将关闭，除非已由用户显式打开。"
  syntax:
    content: public System.Data.Common.DbConnection Connection { get; }
    return:
      type: System.Data.Common.DbConnection
      description: "由框架使用的连接。"
  overload: System.Data.Linq.DataContext.Connection*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.CreateDatabase
  id: CreateDatabase
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: CreateDatabase()
  nameWithType: DataContext.CreateDatabase()
  fullName: System.Data.Linq.DataContext.CreateDatabase()
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "在服务器上创建数据库。"
  remarks: "通过使用以下算法派生的数据库名称:-如果数据库在连接字符串中标识的则使用其名称。      -如果<xref:System.Data.Linq.Mapping.DatabaseAttribute>属性不存在，其<xref:System.Data.Linq.Mapping.DatabaseAttribute.Name%2A>属性用作数据库的名称。</xref:System.Data.Linq.Mapping.DatabaseAttribute.Name%2A> </xref:System.Data.Linq.Mapping.DatabaseAttribute>      -如果没有连接字符串和强类型中的没有数据库标记<xref:System.Data.Linq.DataContext>使用时，具有与同名的数据库<xref:System.Data.Linq.DataContext>继承类已选中。</xref:System.Data.Linq.DataContext> </xref:System.Data.Linq.DataContext>      -如果使用弱类型<xref:System.Data.Linq.DataContext>是使用，将引发异常。</xref:System.Data.Linq.DataContext>      -如果<xref:System.Data.Linq.DataContext>已创建通过使用文件名称，创建与该文件名称对应的数据库。</xref:System.Data.Linq.DataContext>"
  example:
  - "The following code shows how to set up a temporary database and then remove it.  \n  \n [!code-vb[System.Data.Linq.DataContext#1](~/add/codesnippet/visualbasic/DataContext/Module1.vb#1)]\n [!code-cs[System.Data.Linq.DataContext#1](~/add/codesnippet/csharp/DataContext/Program.cs#1)]"
  syntax:
    content: public void CreateDatabase ();
    parameters: []
  overload: System.Data.Linq.DataContext.CreateDatabase*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])
  id: CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: CreateMethodCallQuery(Object,MethodInfo,Object[])
  nameWithType: DataContext.CreateMethodCallQuery(Object,MethodInfo,Object[])
  fullName: System.Data.Linq.DataContext.CreateMethodCallQuery(Object,MethodInfo,Object[])
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  syntax:
    content: protected System.Linq.IQueryable<TResult> CreateMethodCallQuery<TResult> (object instance, System.Reflection.MethodInfo methodInfo, object[] parameters);
    parameters:
    - id: instance
      type: System.Object
      description: "要添加。"
    - id: methodInfo
      type: System.Reflection.MethodInfo
      description: "要添加。"
    - id: parameters
      type: System.Object[]
      description: "要添加。"
    return:
      type: System.Linq.IQueryable{TResult}
      description: "要添加。"
  overload: System.Data.Linq.DataContext.CreateMethodCallQuery<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.DatabaseExists
  id: DatabaseExists
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: DatabaseExists()
  nameWithType: DataContext.DatabaseExists()
  fullName: System.Data.Linq.DataContext.DatabaseExists()
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "确定是否可以打开关联的数据库。"
  remarks: "此方法使用中的连接<xref:System.Data.Linq.DataContext.Connection%2A>尝试打开关联的数据库的属性。</xref:System.Data.Linq.DataContext.Connection%2A>"
  example:
  - "The following example uses this method to determine whether a database already exists.  \n  \n [!code-vb[System.Data.Linq.DataContext#1](~/add/codesnippet/visualbasic/DataContext/Module1.vb#1)]\n [!code-cs[System.Data.Linq.DataContext#1](~/add/codesnippet/csharp/DataContext/Program.cs#1)]"
  syntax:
    content: public bool DatabaseExists ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果可以打开指定的数据库;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.Linq.DataContext.DatabaseExists*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.DeferredLoadingEnabled
  id: DeferredLoadingEnabled
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: DeferredLoadingEnabled
  nameWithType: DataContext.DeferredLoadingEnabled
  fullName: System.Data.Linq.DataContext.DeferredLoadingEnabled
  type: Property
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "获取或设置一个值，该值指示是否延迟加载的一对多关系还是一对一关系的关系。"
  remarks: "返回代码访问这些关系，null 之一时，如果关系是一对一，并且如果它是一个一对多，则返回一个空集合。 仍可通过设置填写关系<xref:System.Data.Linq.DataContext.LoadOptions%2A>属性。</xref:System.Data.Linq.DataContext.LoadOptions%2A>       此属性的主要方案是，可以提取一种对象模型并将它发送 （例如，到 Web 服务）。      1> [!NOTE]&1;> 如果此属性设置为`false`执行查询后，将引发异常。 请参阅**有效模式**下面部分以了解详细信息。      ## 有效的模式已推迟加载需要对象跟踪。 只有以下三种模式有效:- <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A>= `false`。</xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> 忽略和推断 DeferredLoadingEnabled `false`。 此行为对应于一只读<xref:System.Data.Linq.DataContext>。</xref:System.Data.Linq.DataContext>      -   <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> = `true`.</xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> DeferredLoadingEnabled = `false`。 这种情况下对应于<xref:System.Data.Linq.DataContext>，允许用户通过使用来加载对象图<xref:System.Data.Linq.DataLoadOptions.LoadWith%2A>指令，但它不会启用延迟的加载。</xref:System.Data.Linq.DataLoadOptions.LoadWith%2A> </xref:System.Data.Linq.DataContext>      -两者都设置为`true`。 这是默认值。       在执行查询后，不能更改标志。 之后使用，在第一个查询执行的任何更改<xref:System.Data.Linq.DataContext>引发异常。</xref:System.Data.Linq.DataContext>"
  syntax:
    content: public bool DeferredLoadingEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果启用了延迟的加载;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.Linq.DataContext.DeferredLoadingEnabled*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.DeleteDatabase
  id: DeleteDatabase
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: DeleteDatabase()
  nameWithType: DataContext.DeleteDatabase()
  fullName: System.Data.Linq.DataContext.DeleteDatabase()
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "删除关联的数据库。"
  remarks: "此方法使用中的连接<xref:System.Data.Linq.DataContext.Connection%2A>属性来标识要删除的数据库。</xref:System.Data.Linq.DataContext.Connection%2A>"
  example:
  - "The following example shows how to delete a database that has been temporarily created.  \n  \n [!code-vb[System.Data.Linq.DataContext#1](~/add/codesnippet/visualbasic/DataContext/Module1.vb#1)]\n [!code-cs[System.Data.Linq.DataContext#1](~/add/codesnippet/csharp/DataContext/Program.cs#1)]"
  syntax:
    content: public void DeleteDatabase ();
    parameters: []
  overload: System.Data.Linq.DataContext.DeleteDatabase*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.Dispose
  id: Dispose
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: Dispose()
  nameWithType: DataContext.Dispose()
  fullName: System.Data.Linq.DataContext.Dispose()
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "释放当前实例所使用的所有资源<xref href=&quot;System.Data.Linq.DataContext&quot;></xref>类。"
  syntax:
    content: public void Dispose ();
    parameters: []
  overload: System.Data.Linq.DataContext.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: DataContext.Dispose(Boolean)
  fullName: System.Data.Linq.DataContext.Dispose(Boolean)
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "释放由非托管的资源<xref href=&quot;System.Data.Linq.DataContext&quot;></xref>类，还可以释放托管的资源。"
  syntax:
    content: protected virtual void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要释放托管和非托管资源;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>若要仅释放非托管的资源。"
  overload: System.Data.Linq.DataContext.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])
  id: ExecuteCommand(System.String,System.Object[])
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: ExecuteCommand(String,Object[])
  nameWithType: DataContext.ExecuteCommand(String,Object[])
  fullName: System.Data.Linq.DataContext.ExecuteCommand(String,Object[])
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "直接在数据库上执行的 SQL 命令。"
  remarks: "This method is a pass-through mechanism for cases where [!INCLUDE[vbtecdlinq](~/add/includes/vbtecdlinq-md.md)] does not adequately provide for a particular scenario.  \n  \n The syntax for the command is almost the same as the syntax used to create an ADO.NET `DataCommand`. The only difference is in how the parameters are specified. Specifically, you specify parameters by enclosing them in braces ({…}) and enumerate them starting from 0. The parameter is associated with the equally numbered object in the parameters array.  \n  \n `ExecuteQuery` and `ExecuteCommand` allow you to specify a variable number of arguments for parameter substitution. For example, you can specify the parameters when invoking ExecuteQuery\\<TResult>:  \n  \n```  \ndb.ExecuteQuery<Customer>(\"select * from dbo.Customers where City = {0}\", \"London\");  \n```  \n  \n And, another example:  \n  \n```  \ndb.ExecuteCommand(\"UPDATE Products SET QuantityPerUnit = {0} WHERE ProductID = {1}\", \"24 boxes\", 5);  \n```  \n  \n The following example opens a connection and passes a SQL `UPDATE` command to the SQL engine."
  example:
  - >-
    [!code-cs[DLinqCommunicatingWithDatabase#3](~/add/codesnippet/csharp/CommWithDatabase/Program.cs#3)]
     [!code-vb[DLinqCommunicatingWithDatabase#3](~/add/codesnippet/visualbasic/CommWithDatabase/Module1.vb#3)]
  syntax:
    content: public int ExecuteCommand (string command, object[] parameters);
    parameters:
    - id: command
      type: System.String
      description: "要执行 SQL 命令。"
    - id: parameters
      type: System.Object[]
      description: "要传递到该命令的参数数组。 请注意以下行为︰ 如果数组中的对象数小于命令字符串中标识的最高编号，引发异常。       如果数组包含命令字符串中未引用的对象，不引发异常。       如果任一参数为 null，则将它转换为<xref uid=&quot;langword_csharp_DBNull.Value&quot; name=&quot;DBNull.Value&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.Int32
      description: "执行命令修改的行数。"
  overload: System.Data.Linq.DataContext.ExecuteCommand*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.ExecuteDynamicDelete(System.Object)
  id: ExecuteDynamicDelete(System.Object)
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: ExecuteDynamicDelete(Object)
  nameWithType: DataContext.ExecuteDynamicDelete(Object)
  fullName: System.Data.Linq.DataContext.ExecuteDynamicDelete(Object)
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "执行时，在删除重写方法，以向[!INCLUDE[vbtecdlinq](~/add/includes/vbtecdlinq-md.md)]生成并执行动态 SQL 来执行的任务删除操作。"
  remarks: "请参阅<xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>。</xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>"
  syntax:
    content: protected void ExecuteDynamicDelete (object entity);
    parameters:
    - id: entity
      type: System.Object
      description: "要删除实体。"
  overload: System.Data.Linq.DataContext.ExecuteDynamicDelete*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)
  id: ExecuteDynamicInsert(System.Object)
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: ExecuteDynamicInsert(Object)
  nameWithType: DataContext.ExecuteDynamicInsert(Object)
  fullName: System.Data.Linq.DataContext.ExecuteDynamicInsert(Object)
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "内插入替代方法，以对执行[!INCLUDE[vbtecdlinq](~/add/includes/vbtecdlinq-md.md)]生成并执行动态 SQL 来执行的任务插入操作。"
  remarks: "请注意以下事项:-由于该方法具有受保护的修饰符，使用它必须子类化<xref:System.Data.Linq.DataContext>.</xref:System.Data.Linq.DataContext>      的如果在不调用此操作引发异常<xref:System.Data.Linq.DataContext.SubmitChanges%2A>操作。</xref:System.Data.Linq.DataContext.SubmitChanges%2A> 它不可作为独立操作的范围之外调用<xref:System.Data.Linq.DataContext.SubmitChanges%2A>操作。</xref:System.Data.Linq.DataContext.SubmitChanges%2A> <xref:System.Data.Linq.DataContext.SubmitChanges%2A>自身调用重写方法如果它们实现，上述方法旨在用于内部重写方法调用。</xref:System.Data.Linq.DataContext.SubmitChanges%2A>      -它是开发人员可以传递正确的实体中的责任。 该实现可确保传入的实体进行跟踪。 但是，它是开发人员可以维护的顺序，或将两次传递同一实体中的责任。      -它是开发人员可以调用正确的动态 API 的责任。 例如，在`Update`重写方法，仅<xref:System.Data.Linq.DataContext.ExecuteDynamicUpdate%2A>可以调用方法。</xref:System.Data.Linq.DataContext.ExecuteDynamicUpdate%2A> [!INCLUDE[vbtecdlinq](~/add/includes/vbtecdlinq-md.md)]不检测或验证调用的动态方法是否与适用的操作相匹配。 结果是不确定的如果将不适用，则方法调用 (例如，调用<xref:System.Data.Linq.DataContext.ExecuteDynamicDelete%2A>要更新的对象)。</xref:System.Data.Linq.DataContext.ExecuteDynamicDelete%2A>"
  syntax:
    content: protected void ExecuteDynamicInsert (object entity);
    parameters:
    - id: entity
      type: System.Object
      description: "要插入的实体。"
  overload: System.Data.Linq.DataContext.ExecuteDynamicInsert*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.ExecuteDynamicUpdate(System.Object)
  id: ExecuteDynamicUpdate(System.Object)
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: ExecuteDynamicUpdate(Object)
  nameWithType: DataContext.ExecuteDynamicUpdate(Object)
  fullName: System.Data.Linq.DataContext.ExecuteDynamicUpdate(Object)
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "执行时，在更新重写方法，以向[!INCLUDE[vbtecdlinq](~/add/includes/vbtecdlinq-md.md)]生成并执行动态 SQL 来执行更新操作的任务。"
  remarks: "请参阅<xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>。</xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>"
  syntax:
    content: protected void ExecuteDynamicUpdate (object entity);
    parameters:
    - id: entity
      type: System.Object
      description: "要更新实体。"
  overload: System.Data.Linq.DataContext.ExecuteDynamicUpdate*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.ExecuteMethodCall(System.Object,System.Reflection.MethodInfo,System.Object[])
  id: ExecuteMethodCall(System.Object,System.Reflection.MethodInfo,System.Object[])
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: ExecuteMethodCall(Object,MethodInfo,Object[])
  nameWithType: DataContext.ExecuteMethodCall(Object,MethodInfo,Object[])
  fullName: System.Data.Linq.DataContext.ExecuteMethodCall(Object,MethodInfo,Object[])
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "执行数据库存储的过程或标量函数与指定的 CLR 方法关联。"
  remarks: "ExecuteMethodCall 方法使用自动生成的代码中，并且可作为数据库函数的代理。"
  syntax:
    content: protected System.Data.Linq.IExecuteResult ExecuteMethodCall (object instance, System.Reflection.MethodInfo methodInfo, object[] parameters);
    parameters:
    - id: instance
      type: System.Object
      description: "方法调用 （当前对象） 的实例。"
    - id: methodInfo
      type: System.Reflection.MethodInfo
      description: "标识对应于一个数据库方法的 CLR 方法。"
    - id: parameters
      type: System.Object[]
      description: "要传递到该命令的参数数组。"
    return:
      type: System.Data.Linq.IExecuteResult
      description: "执行指定的方法的结果 （返回值和输出参数）。"
  overload: System.Data.Linq.DataContext.ExecuteMethodCall*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])
  id: ExecuteQuery(System.Type,System.String,System.Object[])
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: ExecuteQuery(Type,String,Object[])
  nameWithType: DataContext.ExecuteQuery(Type,String,Object[])
  fullName: System.Data.Linq.DataContext.ExecuteQuery(Type,String,Object[])
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "直接对数据库执行 SQL 查询。"
  syntax:
    content: public System.Collections.IEnumerable ExecuteQuery (Type elementType, string query, object[] parameters);
    parameters:
    - id: elementType
      type: System.Type
      description: "一种&lt;xref:System.Collections.Generic.IEnumerable%601&gt;要返回。       用于匹配的字段对查询结果中的列或属性的对象中的算法的工作方式如下︰ 如果字段或属性映射到特定的列名称，则结果集中应包含该列名称。       如果未映射的字段或属性，则结果集中应具有与同名的字段或属性的列。       通过首先查找区分大小写的匹配项进行比较。 如果未找到此匹配项，后续搜索则会不区分大小写的匹配项。       该查询必须返回所有跟踪的字段和属性 （基于延迟加载除外） 的对象的下列所有条件都都为真时︰`T`将实体显式跟踪<xref href=&quot;System.Data.Linq.DataContext&quot;> </xref>。       <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled*>is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>.</xref:System.Data.Linq.DataContext.ObjectTrackingEnabled*>       实体具有主键。       否则会引发异常。"
    - id: query
      type: System.String
      description: "要执行的 SQL 查询。"
    - id: parameters
      type: System.Object[]
      description: "要传递到该命令的参数数组。 请注意以下行为︰ 如果数组中的对象数小于命令字符串中标识的最高编号，引发异常。       如果数组包含命令字符串中未引用的对象，不引发异常。       如果参数是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，它将转换为<xref uid=&quot;langword_csharp_DBNull.Value&quot; name=&quot;DBNull.Value&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.Collections.IEnumerable
      description: "&lt;Xref:System.Collections.Generic.IEnumerable%601&gt;由查询返回的对象的集合。"
  overload: System.Data.Linq.DataContext.ExecuteQuery*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])
  id: ExecuteQuery``1(System.String,System.Object[])
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: ExecuteQuery(String,Object[])
  nameWithType: DataContext.ExecuteQuery(String,Object[])
  fullName: System.Data.Linq.DataContext.ExecuteQuery(String,Object[])
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  syntax:
    content: public System.Collections.Generic.IEnumerable<TResult> ExecuteQuery<TResult> (string query, object[] parameters);
    parameters:
    - id: query
      type: System.String
      description: "要添加。"
    - id: parameters
      type: System.Object[]
      description: "要添加。"
    return:
      type: System.Collections.Generic.IEnumerable{TResult}
      description: "要添加。"
  overload: System.Data.Linq.DataContext.ExecuteQuery<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.GetChangeSet
  id: GetChangeSet
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: GetChangeSet()
  nameWithType: DataContext.GetChangeSet()
  fullName: System.Data.Linq.DataContext.GetChangeSet()
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "获取已修改的对象跟踪的<xref href=&quot;System.Data.Linq.DataContext&quot;> </xref>。"
  remarks: "请注意以下事项:-GetChangeSet 可能产生副作用，如推理的插入和删除<xref:System.Data.Linq.DataContext.SubmitChanges%2A>.</xref:System.Data.Linq.DataContext.SubmitChanges%2A>时通常执行的操作 例如，以下操作中使用的对象可以创建相应的推断的操作，以下列表中:-<xref:System.Data.Linq.EntitySet%601.Add%2A>到<xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>。</xref:System.Data.Linq.Table%601.InsertOnSubmit%2A> </xref:System.Data.Linq.EntitySet%601.Add%2A>          - <xref:System.Data.Linq.EntityRef%601>null 赋值 (可能是由于<xref:System.Data.Linq.EntitySet%601.Remove%2A>为<xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>。</xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A> </xref:System.Data.Linq.EntitySet%601.Remove%2A> </xref:System.Data.Linq.EntityRef%601>      的不可能根据外键约束排序集。      -数据库生成的值 （例如，主键和外键的值、 时间戳，等） 将不可用。 此类信息需要执行数据库命令，可能是检索信息 （例如，从主键的外键） 的传播。      更改的对象-组是在调用时计算的。 后续调用<xref:System.Data.Linq.DataContext.SubmitChanges%2A>如果进行其他更改可能会产生一组不同。</xref:System.Data.Linq.DataContext.SubmitChanges%2A>       在不进行任何更改后的输出显示如下︰`{Added: 0, Removed: 0, Modified: 0}`"
  example:
  - >-
    [!code-vb[DLinqDebuggingSupport#2](~/add/codesnippet/visualbasic/debuggingsupport/Module1.vb#2)]
     [!code-cs[DLinqDebuggingSupport#2](~/add/codesnippet/csharp/debuggingsupport/Program.cs#2)]
  syntax:
    content: public System.Data.Linq.ChangeSet GetChangeSet ();
    parameters: []
    return:
      type: System.Data.Linq.ChangeSet
      description: "作为三个的只读集合返回的对象集。"
  overload: System.Data.Linq.DataContext.GetChangeSet*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)
  id: GetCommand(System.Linq.IQueryable)
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: GetCommand(IQueryable)
  nameWithType: DataContext.GetCommand(IQueryable)
  fullName: System.Data.Linq.DataContext.GetCommand(IQueryable)
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "获取有关生成的 SQL 命令的信息[!INCLUDE[vbtecdlinq](~/add/includes/vbtecdlinq-md.md)]。"
  remarks: "此方法是仅 getter 并且不会影响<xref:System.Data.Linq.DataContext>状态。</xref:System.Data.Linq.DataContext>       请注意以下事项:-自变量必须为非 null。 否则，会引发空参数异常。      -正常查询期间引发的转换异常[!INCLUDE[vbtecdlinq](~/add/includes/vbtecdlinq-md.md)]查询执行适用于无法转换的查询。      的返回仅第一个查询命令。 具体而言，适用于预先加载的其他命令 (<xref:System.Data.Linq.DataLoadOptions.LoadWith%2A>)，不会包括。</xref:System.Data.Linq.DataLoadOptions.LoadWith%2A>      -<xref:System.Data.Linq.DataContext>不会跟踪用户如何处理该命令。</xref:System.Data.Linq.DataContext> 例如，返回命令的执行结果不会跟踪，并且不会影响<xref:System.Data.Linq.DataContext>状态。</xref:System.Data.Linq.DataContext>"
  example:
  - >-
    [!code-vb[DLinqDebuggingSupport#3](~/add/codesnippet/visualbasic/debuggingsupport/Module1.vb#3)]
     [!code-cs[DLinqDebuggingSupport#3](~/add/codesnippet/csharp/debuggingsupport/Program.cs#3)]
  syntax:
    content: public System.Data.Common.DbCommand GetCommand (System.Linq.IQueryable query);
    parameters:
    - id: query
      type: System.Linq.IQueryable
      description: "其 SQL 命令信息的查询是要检索。"
    return:
      type: System.Data.Common.DbCommand
      description: "请求的命令信息对象。"
  overload: System.Data.Linq.DataContext.GetCommand*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.GetTable(System.Type)
  id: GetTable(System.Type)
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: GetTable(Type)
  nameWithType: DataContext.GetTable(Type)
  fullName: System.Data.Linq.DataContext.GetTable(Type)
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "返回特定类型，其中由定义类型的对象的集合<code> type </code>参数。"
  remarks: "这是<xref:System.Data.Linq.DataContext.GetTable%2A>.</xref:System.Data.Linq.DataContext.GetTable%2A>的弱类型化的版本 请务必具有弱类型的版本，因为它是相对较常见的做法动态构造查询。 它将是强制应用程序使用反射来调用正确的泛型方法很不方便。       如果没有为特定类型的集合，则引发异常。"
  syntax:
    content: public System.Data.Linq.ITable GetTable (Type type);
    parameters:
    - id: type
      type: System.Type
      description: "要返回的对象的类型。"
    return:
      type: System.Data.Linq.ITable
      description: "定义的对象的集合<code> type </code>参数。"
  overload: System.Data.Linq.DataContext.GetTable*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.GetTable``1
  id: GetTable``1
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: GetTable()
  nameWithType: DataContext.GetTable()
  fullName: System.Data.Linq.DataContext.GetTable()
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  syntax:
    content: 'public System.Data.Linq.Table<TEntity> GetTable<TEntity> () where TEntity : class;'
    parameters: []
    return:
      type: System.Data.Linq.Table`1
      description: "要添加。"
  overload: System.Data.Linq.DataContext.GetTable<TEntity>*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.LoadOptions
  id: LoadOptions
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: LoadOptions
  nameWithType: DataContext.LoadOptions
  fullName: System.Data.Linq.DataContext.LoadOptions
  type: Property
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "获取或设置<xref href=&quot;System.Data.Linq.DataLoadOptions&quot;></xref>与此关联<xref href=&quot;System.Data.Linq.DataContext&quot;> </xref>。"
  remarks: "此属性获取或设置用于定义延迟加载成员和相关的集合成员身份的预提取行为的选项。"
  syntax:
    content: public System.Data.Linq.DataLoadOptions LoadOptions { get; set; }
    return:
      type: System.Data.Linq.DataLoadOptions
      description: "预提取加载相关数据的选项。"
  overload: System.Data.Linq.DataContext.LoadOptions*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.Log
  id: Log
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: Log
  nameWithType: DataContext.Log
  fullName: System.Data.Linq.DataContext.Log
  type: Property
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "获取或设置目标编写 SQL 查询或命令。"
  remarks: "将此属性设置为`null`禁用命令日志记录。"
  example:
  - "The following example displays generated SQL in the console window before it displays the results of the query.  \n  \n [!code-vb[System.Data.Linq.DataContext#2](~/add/codesnippet/visualbasic/DataContext/Module1.vb#2)]\n [!code-cs[System.Data.Linq.DataContext#2](~/add/codesnippet/csharp/DataContext/Program.cs#2)]"
  syntax:
    content: public System.IO.TextWriter Log { get; set; }
    return:
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextReader>用于编写命令。</xref:System.IO.TextReader>"
  overload: System.Data.Linq.DataContext.Log*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.Mapping
  id: Mapping
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: Mapping
  nameWithType: DataContext.Mapping
  fullName: System.Data.Linq.DataContext.Mapping
  type: Property
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "获取<xref href=&quot;System.Data.Linq.Mapping.MetaModel&quot;></xref>所基于的映射。"
  syntax:
    content: public System.Data.Linq.Mapping.MetaModel Mapping { get; }
    return:
      type: System.Data.Linq.Mapping.MetaModel
      description: "数据库和域的对象之间的映射。"
  overload: System.Data.Linq.DataContext.Mapping*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.ObjectTrackingEnabled
  id: ObjectTrackingEnabled
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: ObjectTrackingEnabled
  nameWithType: DataContext.ObjectTrackingEnabled
  fullName: System.Data.Linq.DataContext.ObjectTrackingEnabled
  type: Property
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "获取或设置一个值，该值指示是否启用跟踪的对象。"
  remarks: "此属性设置为`false`可提高在检索时的性能，因为存在可减少要跟踪的项目。       引发异常:-如果该属性设置为`false`执行查询后。           有关详细信息，请参阅<xref:System.Data.Linq.DataContext>.</xref:System.Data.Linq.DataContext>中的有效模式部分      -如果该属性设置为`false`和<xref:System.Data.Linq.DataContext.SubmitChanges%2A>称为。</xref:System.Data.Linq.DataContext.SubmitChanges%2A>       如果 ObjectTrackingEnabled `false`，<xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A>被忽略并且视为`false`。</xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> 在这种情况下，<xref:System.Data.Linq.DataContext>是只读的。</xref:System.Data.Linq.DataContext>       如果 ObjectTrackingEnabled `true`，<xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A>是`false`。</xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> 在这种情况下，<xref:System.Data.Linq.DataContext>允许你通过使用加载对象图<xref:System.Data.Linq.DataLoadOptions.LoadWith%2A>指令，但不会启用延迟的加载。</xref:System.Data.Linq.DataLoadOptions.LoadWith%2A> </xref:System.Data.Linq.DataContext>"
  syntax:
    content: public bool ObjectTrackingEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果启用了跟踪的对象;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.Linq.DataContext.ObjectTrackingEnabled*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Collections.IEnumerable)
  id: Refresh(System.Data.Linq.RefreshMode,System.Collections.IEnumerable)
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: Refresh(RefreshMode,IEnumerable)
  nameWithType: DataContext.Refresh(RefreshMode,IEnumerable)
  fullName: System.Data.Linq.DataContext.Refresh(RefreshMode,IEnumerable)
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "刷新的按指定模式的实体对象的集合。"
  syntax:
    content: public void Refresh (System.Data.Linq.RefreshMode mode, System.Collections.IEnumerable entities);
    parameters:
    - id: mode
      type: System.Data.Linq.RefreshMode
      description: "处理一个值，指定如何开放式并发冲突。"
    - id: entities
      type: System.Collections.IEnumerable
      description: "要刷新的实体的集合。"
  overload: System.Data.Linq.DataContext.Refresh*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object)
  id: Refresh(System.Data.Linq.RefreshMode,System.Object)
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: Refresh(RefreshMode,Object)
  nameWithType: DataContext.Refresh(RefreshMode,Object)
  fullName: System.Data.Linq.DataContext.Refresh(RefreshMode,Object)
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "刷新实体对象按指定模式。"
  syntax:
    content: public void Refresh (System.Data.Linq.RefreshMode mode, object entity);
    parameters:
    - id: mode
      type: System.Data.Linq.RefreshMode
      description: "处理一个值，指定如何开放式并发冲突。"
    - id: entity
      type: System.Object
      description: "要刷新的对象。"
  overload: System.Data.Linq.DataContext.Refresh*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object[])
  id: Refresh(System.Data.Linq.RefreshMode,System.Object[])
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: Refresh(RefreshMode,Object[])
  nameWithType: DataContext.Refresh(RefreshMode,Object[])
  fullName: System.Data.Linq.DataContext.Refresh(RefreshMode,Object[])
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "刷新按指定模式的实体对象的数组。"
  syntax:
    content: public void Refresh (System.Data.Linq.RefreshMode mode, object[] entities);
    parameters:
    - id: mode
      type: System.Data.Linq.RefreshMode
      description: "处理一个值，指定如何开放式并发冲突。"
    - id: entities
      type: System.Object[]
      description: "要刷新的实体对象的数组。"
  overload: System.Data.Linq.DataContext.Refresh*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.SubmitChanges
  id: SubmitChanges
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: SubmitChanges()
  nameWithType: DataContext.SubmitChanges()
  fullName: System.Data.Linq.DataContext.SubmitChanges()
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "计算的一套已修改的对象，以插入、 更新或删除，并执行适当的命令来实现对数据库的更改。"
  remarks: "如果存在用于插入、 更新或删除、 重写方法<xref:System.Data.Linq.DataContext.SubmitChanges%2A>执行这些方法，而不是默认值[!INCLUDE[vbtecdlinq](~/add/includes/vbtecdlinq-md.md)]命令。</xref:System.Data.Linq.DataContext.SubmitChanges%2A>"
  syntax:
    content: public void SubmitChanges ();
    parameters: []
  overload: System.Data.Linq.DataContext.SubmitChanges*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.SubmitChanges(System.Data.Linq.ConflictMode)
  id: SubmitChanges(System.Data.Linq.ConflictMode)
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: SubmitChanges(ConflictMode)
  nameWithType: DataContext.SubmitChanges(ConflictMode)
  fullName: System.Data.Linq.DataContext.SubmitChanges(ConflictMode)
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "发送对所做的更改检索到基础数据库中，对象和指定要提交失败时要采取的操作。"
  remarks: "默认失败模式是<xref:System.Data.Linq.ConflictMode>.</xref:System.Data.Linq.ConflictMode>"
  example:
  - >-
    [!code-cs[System.Data.Linq.ConflictModeEnumeration#1](~/add/codesnippet/csharp/cmodesnip/program.cs#1)]
     [!code-vb[System.Data.Linq.ConflictModeEnumeration#1](~/add/codesnippet/visualbasic/snipdump/module1.vb#1)]
  syntax:
    content: public virtual void SubmitChanges (System.Data.Linq.ConflictMode failureMode);
    parameters:
    - id: failureMode
      type: System.Data.Linq.ConflictMode
      description: "要提交失败时要采取的操作。 有效的参数如下所示︰<xref href=&quot;System.Data.Linq.ConflictMode&quot;></xref><xref href=&quot;System.Data.Linq.ConflictMode&quot;></xref>"
  overload: System.Data.Linq.DataContext.SubmitChanges*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.Transaction
  id: Transaction
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: Transaction
  nameWithType: DataContext.Transaction
  fullName: System.Data.Linq.DataContext.Transaction
  type: Property
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "获取或设置的本地事务[!INCLUDE[dnprdnshort](~/add/includes/dnprdnshort-md.md)]要用于访问数据库。"
  remarks: "此属性的主要方案是与关系互操作性[!INCLUDE[vstecado](~/add/includes/vstecado-md.md)]代码。 例如，使用此属性，当你编写你自己`Create` / `Update` / `Delete`方法，以便设置`Transaction`属性 ADO`Command`对象。       请注意以下事项:-如果此属性未显式设置，getter 返回 null。      -如果在中执行代码<xref:System.Transactions.Transaction>上下文中，设置此属性将引发异常。</xref:System.Transactions.Transaction>      -如果此属性是组和一个新<xref:System.Transactions.Transaction>是打开，将引发异常时执行的查询或更新。</xref:System.Transactions.Transaction>"
  syntax:
    content: public System.Data.Common.DbTransaction Transaction { get; set; }
    return:
      type: System.Data.Common.DbTransaction
      description: "使用的事务对象<xref href=&quot;System.Data.Linq.DataContext&quot;></xref>时执行查询和命令。"
  overload: System.Data.Linq.DataContext.Transaction*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.Translate(System.Data.Common.DbDataReader)
  id: Translate(System.Data.Common.DbDataReader)
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: Translate(DbDataReader)
  nameWithType: DataContext.Translate(DbDataReader)
  fullName: System.Data.Linq.DataContext.Translate(DbDataReader)
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "将转换的现有<xref href=&quot;System.Data.Common.DbDataReader&quot;></xref>到对象。"
  syntax:
    content: public System.Data.Linq.IMultipleResults Translate (System.Data.Common.DbDataReader reader);
    parameters:
    - id: reader
      type: System.Data.Common.DbDataReader
      description: "<xref href=&quot;System.Data.IDataReader&quot;> </xref>要转换。"
    return:
      type: System.Data.Linq.IMultipleResults
      description: "返回转换的对象列表。"
  overload: System.Data.Linq.DataContext.Translate*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)
  id: Translate(System.Type,System.Data.Common.DbDataReader)
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: Translate(Type,DbDataReader)
  nameWithType: DataContext.Translate(Type,DbDataReader)
  fullName: System.Data.Linq.DataContext.Translate(Type,DbDataReader)
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "将转换的现有<xref href=&quot;System.Data.Common.DbDataReader&quot;></xref>到对象。"
  syntax:
    content: public System.Collections.IEnumerable Translate (Type elementType, System.Data.Common.DbDataReader reader);
    parameters:
    - id: elementType
      type: System.Type
      description: "一种&lt;xref:System.Collections.Generic.IEnumerable%601&gt;要返回。       相匹配的结果与字段中的列和属性的对象中的算法的工作方式如下︰ 如果字段或属性映射到特定的列名称，则结果集中应包含该列名称。       如果未映射的字段或属性，则结果集中应具有与同名的字段或属性的列。       通过首先查找区分大小写的匹配项进行比较。 如果未找到此匹配项，则会继续搜索不区分大小写的匹配项。       该查询必须返回所有跟踪的字段和属性 （基于延迟加载除外） 的对象的下列所有条件都都为真时︰`T`将实体显式跟踪<xref href=&quot;System.Data.Linq.DataContext&quot;> </xref>。       <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled*>is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>.</xref:System.Data.Linq.DataContext.ObjectTrackingEnabled*>       实体具有主键。       否则会引发异常。"
    - id: reader
      type: System.Data.Common.DbDataReader
      description: "<xref href=&quot;System.Data.IDataReader&quot;> </xref>要转换。"
    return:
      type: System.Collections.IEnumerable
      description: "返回转换的对象列表。"
  overload: System.Data.Linq.DataContext.Translate*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.Translate``1(System.Data.Common.DbDataReader)
  id: Translate``1(System.Data.Common.DbDataReader)
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: Translate(DbDataReader)
  nameWithType: DataContext.Translate(DbDataReader)
  fullName: System.Data.Linq.DataContext.Translate(DbDataReader)
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  syntax:
    content: public System.Collections.Generic.IEnumerable<TResult> Translate<TResult> (System.Data.Common.DbDataReader reader);
    parameters:
    - id: reader
      type: System.Data.Common.DbDataReader
      description: "要添加。"
    return:
      type: System.Collections.Generic.IEnumerable{TResult}
      description: "要添加。"
  overload: System.Data.Linq.DataContext.Translate<TResult>*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: DataContext(IDbConnection)
  nameWithType: DataContext.DataContext(IDbConnection)
  fullName: System.Data.Linq.DataContext.DataContext(IDbConnection)
- uid: System.Data.IDbConnection
  parent: System.Data
  isExternal: false
  name: IDbConnection
  nameWithType: IDbConnection
  fullName: System.Data.IDbConnection
- uid: System.Data.Linq.DataContext.#ctor(System.String)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: DataContext(String)
  nameWithType: DataContext.DataContext(String)
  fullName: System.Data.Linq.DataContext.DataContext(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection,System.Data.Linq.Mapping.MappingSource)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: DataContext(IDbConnection,MappingSource)
  nameWithType: DataContext.DataContext(IDbConnection,MappingSource)
  fullName: System.Data.Linq.DataContext.DataContext(IDbConnection,MappingSource)
- uid: System.Data.Linq.Mapping.MappingSource
  parent: System.Data.Linq.Mapping
  isExternal: false
  name: MappingSource
  nameWithType: MappingSource
  fullName: System.Data.Linq.Mapping.MappingSource
- uid: System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: DataContext(String,MappingSource)
  nameWithType: DataContext.DataContext(String,MappingSource)
  fullName: System.Data.Linq.DataContext.DataContext(String,MappingSource)
- uid: System.Data.Linq.DataContext.ChangeConflicts
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ChangeConflicts
  nameWithType: DataContext.ChangeConflicts
  fullName: System.Data.Linq.DataContext.ChangeConflicts
- uid: System.Data.Linq.ChangeConflictCollection
  parent: System.Data.Linq
  isExternal: false
  name: ChangeConflictCollection
  nameWithType: ChangeConflictCollection
  fullName: System.Data.Linq.ChangeConflictCollection
- uid: System.Data.Linq.DataContext.CommandTimeout
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: CommandTimeout
  nameWithType: DataContext.CommandTimeout
  fullName: System.Data.Linq.DataContext.CommandTimeout
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Data.Linq.DataContext.Connection
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Connection
  nameWithType: DataContext.Connection
  fullName: System.Data.Linq.DataContext.Connection
- uid: System.Data.Common.DbConnection
  parent: System.Data.Common
  isExternal: false
  name: DbConnection
  nameWithType: DbConnection
  fullName: System.Data.Common.DbConnection
- uid: System.Data.Linq.DataContext.CreateDatabase
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: CreateDatabase()
  nameWithType: DataContext.CreateDatabase()
  fullName: System.Data.Linq.DataContext.CreateDatabase()
- uid: System.Data.Linq.DataContext.CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: CreateMethodCallQuery(Object,MethodInfo,Object[])
  nameWithType: DataContext.CreateMethodCallQuery(Object,MethodInfo,Object[])
  fullName: System.Data.Linq.DataContext.CreateMethodCallQuery(Object,MethodInfo,Object[])
- uid: System.Linq.IQueryable{TResult}
  parent: System.Linq
  isExternal: true
  name: IQueryable<TResult>
  nameWithType: IQueryable<TResult>
  fullName: System.Linq.IQueryable<TResult>
  spec.csharp:
  - uid: System.Linq.IQueryable`1
    name: IQueryable
    nameWithType: IQueryable
    fullName: IQueryable<TResult>
  - name: <
    nameWithType: <
    fullName: <
  - uid: TResult
    name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Reflection.MethodInfo
  parent: System.Reflection
  isExternal: true
  name: MethodInfo
  nameWithType: MethodInfo
  fullName: System.Reflection.MethodInfo
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Data.Linq.DataContext.DatabaseExists
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: DatabaseExists()
  nameWithType: DataContext.DatabaseExists()
  fullName: System.Data.Linq.DataContext.DatabaseExists()
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Data.Linq.DataContext.DeferredLoadingEnabled
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: DeferredLoadingEnabled
  nameWithType: DataContext.DeferredLoadingEnabled
  fullName: System.Data.Linq.DataContext.DeferredLoadingEnabled
- uid: System.Data.Linq.DataContext.DeleteDatabase
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: DeleteDatabase()
  nameWithType: DataContext.DeleteDatabase()
  fullName: System.Data.Linq.DataContext.DeleteDatabase()
- uid: System.Data.Linq.DataContext.Dispose
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Dispose()
  nameWithType: DataContext.Dispose()
  fullName: System.Data.Linq.DataContext.Dispose()
- uid: System.Data.Linq.DataContext.Dispose(System.Boolean)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: DataContext.Dispose(Boolean)
  fullName: System.Data.Linq.DataContext.Dispose(Boolean)
- uid: System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ExecuteCommand(String,Object[])
  nameWithType: DataContext.ExecuteCommand(String,Object[])
  fullName: System.Data.Linq.DataContext.ExecuteCommand(String,Object[])
- uid: System.Data.Linq.DataContext.ExecuteDynamicDelete(System.Object)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ExecuteDynamicDelete(Object)
  nameWithType: DataContext.ExecuteDynamicDelete(Object)
  fullName: System.Data.Linq.DataContext.ExecuteDynamicDelete(Object)
- uid: System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ExecuteDynamicInsert(Object)
  nameWithType: DataContext.ExecuteDynamicInsert(Object)
  fullName: System.Data.Linq.DataContext.ExecuteDynamicInsert(Object)
- uid: System.Data.Linq.DataContext.ExecuteDynamicUpdate(System.Object)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ExecuteDynamicUpdate(Object)
  nameWithType: DataContext.ExecuteDynamicUpdate(Object)
  fullName: System.Data.Linq.DataContext.ExecuteDynamicUpdate(Object)
- uid: System.Data.Linq.DataContext.ExecuteMethodCall(System.Object,System.Reflection.MethodInfo,System.Object[])
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ExecuteMethodCall(Object,MethodInfo,Object[])
  nameWithType: DataContext.ExecuteMethodCall(Object,MethodInfo,Object[])
  fullName: System.Data.Linq.DataContext.ExecuteMethodCall(Object,MethodInfo,Object[])
- uid: System.Data.Linq.IExecuteResult
  parent: System.Data.Linq
  isExternal: false
  name: IExecuteResult
  nameWithType: IExecuteResult
  fullName: System.Data.Linq.IExecuteResult
- uid: System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ExecuteQuery(Type,String,Object[])
  nameWithType: DataContext.ExecuteQuery(Type,String,Object[])
  fullName: System.Data.Linq.DataContext.ExecuteQuery(Type,String,Object[])
- uid: System.Collections.IEnumerable
  parent: System.Collections
  isExternal: true
  name: IEnumerable
  nameWithType: IEnumerable
  fullName: System.Collections.IEnumerable
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ExecuteQuery(String,Object[])
  nameWithType: DataContext.ExecuteQuery(String,Object[])
  fullName: System.Data.Linq.DataContext.ExecuteQuery(String,Object[])
- uid: System.Collections.Generic.IEnumerable{TResult}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<TResult>
  nameWithType: IEnumerable<TResult>
  fullName: System.Collections.Generic.IEnumerable<TResult>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<TResult>
  - name: <
    nameWithType: <
    fullName: <
  - uid: TResult
    name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Data.Linq.DataContext.GetChangeSet
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: GetChangeSet()
  nameWithType: DataContext.GetChangeSet()
  fullName: System.Data.Linq.DataContext.GetChangeSet()
- uid: System.Data.Linq.ChangeSet
  parent: System.Data.Linq
  isExternal: false
  name: ChangeSet
  nameWithType: ChangeSet
  fullName: System.Data.Linq.ChangeSet
- uid: System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: GetCommand(IQueryable)
  nameWithType: DataContext.GetCommand(IQueryable)
  fullName: System.Data.Linq.DataContext.GetCommand(IQueryable)
- uid: System.Data.Common.DbCommand
  parent: System.Data.Common
  isExternal: false
  name: DbCommand
  nameWithType: DbCommand
  fullName: System.Data.Common.DbCommand
- uid: System.Linq.IQueryable
  parent: System.Linq
  isExternal: true
  name: IQueryable
  nameWithType: IQueryable
  fullName: System.Linq.IQueryable
- uid: System.Data.Linq.DataContext.GetTable(System.Type)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: GetTable(Type)
  nameWithType: DataContext.GetTable(Type)
  fullName: System.Data.Linq.DataContext.GetTable(Type)
- uid: System.Data.Linq.ITable
  parent: System.Data.Linq
  isExternal: false
  name: ITable
  nameWithType: ITable
  fullName: System.Data.Linq.ITable
- uid: System.Data.Linq.DataContext.GetTable``1
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: GetTable()
  nameWithType: DataContext.GetTable()
  fullName: System.Data.Linq.DataContext.GetTable()
- uid: System.Data.Linq.Table`1
  parent: System.Data.Linq
  isExternal: false
  name: Table<TEntity>
  nameWithType: Table<TEntity>
  fullName: System.Data.Linq.Table<TEntity>
- uid: System.Data.Linq.DataContext.LoadOptions
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: LoadOptions
  nameWithType: DataContext.LoadOptions
  fullName: System.Data.Linq.DataContext.LoadOptions
- uid: System.Data.Linq.DataLoadOptions
  parent: System.Data.Linq
  isExternal: false
  name: DataLoadOptions
  nameWithType: DataLoadOptions
  fullName: System.Data.Linq.DataLoadOptions
- uid: System.Data.Linq.DataContext.Log
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Log
  nameWithType: DataContext.Log
  fullName: System.Data.Linq.DataContext.Log
- uid: System.IO.TextWriter
  parent: System.IO
  isExternal: true
  name: TextWriter
  nameWithType: TextWriter
  fullName: System.IO.TextWriter
- uid: System.Data.Linq.DataContext.Mapping
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Mapping
  nameWithType: DataContext.Mapping
  fullName: System.Data.Linq.DataContext.Mapping
- uid: System.Data.Linq.Mapping.MetaModel
  parent: System.Data.Linq.Mapping
  isExternal: false
  name: MetaModel
  nameWithType: MetaModel
  fullName: System.Data.Linq.Mapping.MetaModel
- uid: System.Data.Linq.DataContext.ObjectTrackingEnabled
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ObjectTrackingEnabled
  nameWithType: DataContext.ObjectTrackingEnabled
  fullName: System.Data.Linq.DataContext.ObjectTrackingEnabled
- uid: System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Collections.IEnumerable)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Refresh(RefreshMode,IEnumerable)
  nameWithType: DataContext.Refresh(RefreshMode,IEnumerable)
  fullName: System.Data.Linq.DataContext.Refresh(RefreshMode,IEnumerable)
- uid: System.Data.Linq.RefreshMode
  parent: System.Data.Linq
  isExternal: false
  name: RefreshMode
  nameWithType: RefreshMode
  fullName: System.Data.Linq.RefreshMode
- uid: System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Refresh(RefreshMode,Object)
  nameWithType: DataContext.Refresh(RefreshMode,Object)
  fullName: System.Data.Linq.DataContext.Refresh(RefreshMode,Object)
- uid: System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object[])
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Refresh(RefreshMode,Object[])
  nameWithType: DataContext.Refresh(RefreshMode,Object[])
  fullName: System.Data.Linq.DataContext.Refresh(RefreshMode,Object[])
- uid: System.Data.Linq.DataContext.SubmitChanges
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: SubmitChanges()
  nameWithType: DataContext.SubmitChanges()
  fullName: System.Data.Linq.DataContext.SubmitChanges()
- uid: System.Data.Linq.DataContext.SubmitChanges(System.Data.Linq.ConflictMode)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: SubmitChanges(ConflictMode)
  nameWithType: DataContext.SubmitChanges(ConflictMode)
  fullName: System.Data.Linq.DataContext.SubmitChanges(ConflictMode)
- uid: System.Data.Linq.ConflictMode
  parent: System.Data.Linq
  isExternal: false
  name: ConflictMode
  nameWithType: ConflictMode
  fullName: System.Data.Linq.ConflictMode
- uid: System.Data.Linq.DataContext.Transaction
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Transaction
  nameWithType: DataContext.Transaction
  fullName: System.Data.Linq.DataContext.Transaction
- uid: System.Data.Common.DbTransaction
  parent: System.Data.Common
  isExternal: false
  name: DbTransaction
  nameWithType: DbTransaction
  fullName: System.Data.Common.DbTransaction
- uid: System.Data.Linq.DataContext.Translate(System.Data.Common.DbDataReader)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Translate(DbDataReader)
  nameWithType: DataContext.Translate(DbDataReader)
  fullName: System.Data.Linq.DataContext.Translate(DbDataReader)
- uid: System.Data.Linq.IMultipleResults
  parent: System.Data.Linq
  isExternal: false
  name: IMultipleResults
  nameWithType: IMultipleResults
  fullName: System.Data.Linq.IMultipleResults
- uid: System.Data.Common.DbDataReader
  parent: System.Data.Common
  isExternal: false
  name: DbDataReader
  nameWithType: DbDataReader
  fullName: System.Data.Common.DbDataReader
- uid: System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Translate(Type,DbDataReader)
  nameWithType: DataContext.Translate(Type,DbDataReader)
  fullName: System.Data.Linq.DataContext.Translate(Type,DbDataReader)
- uid: System.Data.Linq.DataContext.Translate``1(System.Data.Common.DbDataReader)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Translate(DbDataReader)
  nameWithType: DataContext.Translate(DbDataReader)
  fullName: System.Data.Linq.DataContext.Translate(DbDataReader)
- uid: System.Data.Linq.DataContext.#ctor*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: DataContext
  nameWithType: DataContext.DataContext
- uid: System.Data.Linq.DataContext.ChangeConflicts*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ChangeConflicts
  nameWithType: DataContext.ChangeConflicts
- uid: System.Data.Linq.DataContext.CommandTimeout*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: CommandTimeout
  nameWithType: DataContext.CommandTimeout
- uid: System.Data.Linq.DataContext.Connection*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Connection
  nameWithType: DataContext.Connection
- uid: System.Data.Linq.DataContext.CreateDatabase*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: CreateDatabase
  nameWithType: DataContext.CreateDatabase
- uid: System.Data.Linq.DataContext.CreateMethodCallQuery<TResult>*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: CreateMethodCallQuery<TResult>
  nameWithType: DataContext.CreateMethodCallQuery<TResult>
- uid: System.Data.Linq.DataContext.DatabaseExists*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: DatabaseExists
  nameWithType: DataContext.DatabaseExists
- uid: System.Data.Linq.DataContext.DeferredLoadingEnabled*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: DeferredLoadingEnabled
  nameWithType: DataContext.DeferredLoadingEnabled
- uid: System.Data.Linq.DataContext.DeleteDatabase*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: DeleteDatabase
  nameWithType: DataContext.DeleteDatabase
- uid: System.Data.Linq.DataContext.Dispose*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Dispose
  nameWithType: DataContext.Dispose
- uid: System.Data.Linq.DataContext.ExecuteCommand*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ExecuteCommand
  nameWithType: DataContext.ExecuteCommand
- uid: System.Data.Linq.DataContext.ExecuteDynamicDelete*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ExecuteDynamicDelete
  nameWithType: DataContext.ExecuteDynamicDelete
- uid: System.Data.Linq.DataContext.ExecuteDynamicInsert*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ExecuteDynamicInsert
  nameWithType: DataContext.ExecuteDynamicInsert
- uid: System.Data.Linq.DataContext.ExecuteDynamicUpdate*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ExecuteDynamicUpdate
  nameWithType: DataContext.ExecuteDynamicUpdate
- uid: System.Data.Linq.DataContext.ExecuteMethodCall*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ExecuteMethodCall
  nameWithType: DataContext.ExecuteMethodCall
- uid: System.Data.Linq.DataContext.ExecuteQuery*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ExecuteQuery
  nameWithType: DataContext.ExecuteQuery
- uid: System.Data.Linq.DataContext.ExecuteQuery<TResult>*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ExecuteQuery<TResult>
  nameWithType: DataContext.ExecuteQuery<TResult>
- uid: System.Data.Linq.DataContext.GetChangeSet*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: GetChangeSet
  nameWithType: DataContext.GetChangeSet
- uid: System.Data.Linq.DataContext.GetCommand*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: GetCommand
  nameWithType: DataContext.GetCommand
- uid: System.Data.Linq.DataContext.GetTable*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: GetTable
  nameWithType: DataContext.GetTable
- uid: System.Data.Linq.DataContext.GetTable<TEntity>*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: GetTable<TEntity>
  nameWithType: DataContext.GetTable<TEntity>
- uid: System.Data.Linq.DataContext.LoadOptions*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: LoadOptions
  nameWithType: DataContext.LoadOptions
- uid: System.Data.Linq.DataContext.Log*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Log
  nameWithType: DataContext.Log
- uid: System.Data.Linq.DataContext.Mapping*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Mapping
  nameWithType: DataContext.Mapping
- uid: System.Data.Linq.DataContext.ObjectTrackingEnabled*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ObjectTrackingEnabled
  nameWithType: DataContext.ObjectTrackingEnabled
- uid: System.Data.Linq.DataContext.Refresh*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Refresh
  nameWithType: DataContext.Refresh
- uid: System.Data.Linq.DataContext.SubmitChanges*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: SubmitChanges
  nameWithType: DataContext.SubmitChanges
- uid: System.Data.Linq.DataContext.Transaction*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Transaction
  nameWithType: DataContext.Transaction
- uid: System.Data.Linq.DataContext.Translate*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Translate
  nameWithType: DataContext.Translate
- uid: System.Data.Linq.DataContext.Translate<TResult>*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Translate<TResult>
  nameWithType: DataContext.Translate<TResult>
