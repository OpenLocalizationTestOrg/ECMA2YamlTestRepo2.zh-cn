### YamlMime:ManagedReference
items:
- uid: System.Security.AccessControl.RegistrySecurity
  id: RegistrySecurity
  children:
  - System.Security.AccessControl.RegistrySecurity.#ctor
  - System.Security.AccessControl.RegistrySecurity.AccessRightType
  - System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  - System.Security.AccessControl.RegistrySecurity.AccessRuleType
  - System.Security.AccessControl.RegistrySecurity.AddAccessRule(System.Security.AccessControl.RegistryAccessRule)
  - System.Security.AccessControl.RegistrySecurity.AddAuditRule(System.Security.AccessControl.RegistryAuditRule)
  - System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  - System.Security.AccessControl.RegistrySecurity.AuditRuleType
  - System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(System.Security.AccessControl.RegistryAccessRule)
  - System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(System.Security.AccessControl.RegistryAccessRule)
  - System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.RegistryAccessRule)
  - System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(System.Security.AccessControl.RegistryAuditRule)
  - System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(System.Security.AccessControl.RegistryAuditRule)
  - System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.RegistryAuditRule)
  - System.Security.AccessControl.RegistrySecurity.ResetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  - System.Security.AccessControl.RegistrySecurity.SetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  - System.Security.AccessControl.RegistrySecurity.SetAuditRule(System.Security.AccessControl.RegistryAuditRule)
  langs:
  - csharp
  name: RegistrySecurity
  nameWithType: RegistrySecurity
  fullName: System.Security.AccessControl.RegistrySecurity
  type: Class
  summary: "表示注册表项的 Windows 访问控制安全性。 此类不能被继承。"
  remarks: "RegistrySecurity 对象指定注册表项的访问权限，并且还指定如何审核访问尝试。 对注册表项的访问权限表示为规则，由表示每个访问规则<xref:System.Security.AccessControl.RegistryAccessRule>对象。</xref:System.Security.AccessControl.RegistryAccessRule> 每个审核规则由<xref:System.Security.AccessControl.RegistryAuditRule>对象。</xref:System.Security.AccessControl.RegistryAuditRule>       这反映了基础的 Windows 安全系统，其中每个安全对象具有最多有一个自定义访问控制列表 (DACL) 控制访问受保护的对象以及最多有一个系统访问控制列表 (SACL) 指定哪些访问尝试进行审核。 DACL 和 SACL 进行排序的指定访问和审核用户和组的访问控制项 (ACE) 的列表。 A<xref:System.Security.AccessControl.RegistryAccessRule>或<xref:System.Security.AccessControl.RegistryAuditRule>对象可以表示多个 ACE。</xref:System.Security.AccessControl.RegistryAuditRule> </xref:System.Security.AccessControl.RegistryAccessRule>      1> [!NOTE]&1;> Windows 访问控制安全性可以仅应用于注册表项。 它不能应用于单个键/值对存储在注册表项。       RegistrySecurity， <xref:System.Security.AccessControl.RegistryAccessRule>，和<xref:System.Security.AccessControl.RegistryAuditRule>类隐藏 Acl 和 Ace 的实现详细信息。</xref:System.Security.AccessControl.RegistryAuditRule> </xref:System.Security.AccessControl.RegistryAccessRule> 这使你忽略十七不同的 ACE 类型和正确维护继承和访问权限的传播的复杂性。 这些对象还旨在防止以下常见的访问控制错误:-使用 null DACL 创建安全描述符。 对 DACL 的 null 引用允许任何用户将访问规则添加到一个对象，该对象可能创建的拒绝服务攻击。 新的 RegistrySecurity 对象开始时始终具有一个空元素，此操作会拒绝所有用户的所有访问权限的 DACL。      -违反 Ace 的规范顺序。 如果 DACL 中的 ACE 列表不保存在规范顺序，用户可能会无意中被赋予访问受保护的对象。 例如，被拒绝的访问权限必须始终出现在允许的访问权限之前。 RegistrySecurity 对象内部维护正确的顺序。      操作安全描述符标志，它应在资源管理器控件。      -创建 ACE 标志的无效的组合。      -操纵继承的 Ace。 继承和传播由资源管理器，以响应对访问和审核规则所做的更改处理。      -将无意义的 Ace 插入到 Acl。       不支持的.NET 安全对象的唯一功能是应当避免由应用程序开发人员，如下所示的大部分的危险活动:-低级通常由资源管理器执行的任务。      -添加或移除访问控制项的不维护规范排序的方式。       若要修改的注册表项的 Windows 访问控制安全性，请使用<xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName>方法以获取 RegistrySecurity 对象。</xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> 通过添加和删除规则，修改安全对象，然后使用该<xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>方法将重新附加它。</xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>      1> [!IMPORTANT]&1;> RegistrySecurity 对象所做的更改不影响注册表项的访问级别直到你调用<xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>方法以将修改过的安全对象分配给注册表项。</xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>       若要将访问控制安全性复制到另一个注册表项，使用<xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName>方法获取表示第一个注册表项的访问和审核规则 RegistrySecurity 对象，然后使用<xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>方法将这些规则分配给第二个注册表项。</xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName> </xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> 此外可以将这些规则分配到的第二个注册表项<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A?displayProperty=fullName>或<xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A?displayProperty=fullName>采用 RegistrySecurity 对象参数的方法。</xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A?displayProperty=fullName> </xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A?displayProperty=fullName>       以安全描述符定义语言 (SDDL) 中的投资的用户可以使用<xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A>方法以设置的注册表项，访问规则和<xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A>方法来获取表示访问规则的 SDDL 格式的字符串。</xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> </xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> 这不是建议新的开发。"
  example:
  - "This section contains two code examples. The first example shows how compatible rules merge when added and removed, and the second shows how inheritance and propagation flags affect the addition and deletion of rules.  \n  \n Example 1  \n  \n The following code example shows how the <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> method removes rights from a compatible rule, and how the <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> method merges rights with compatible rules.  \n  \n The example creates a RegistrySecurity object and adds a rule that allows the current user <xref:System.Security.AccessControl.RegistryRights?displayProperty=fullName> rights. The example then creates a rule that grants the user <xref:System.Security.AccessControl.RegistryRights?displayProperty=fullName>, with the same inheritance and propagation rights as the first rule, and uses the <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> method to remove this new rule from the RegistrySecurity object. <xref:System.Security.AccessControl.RegistryRights> is a constituent of <xref:System.Security.AccessControl.RegistryRights>, so it is removed from the compatible rule. The rules in the RegistrySecurity object are displayed, showing the remaining constituents of <xref:System.Security.AccessControl.RegistryRights>.  \n  \n The example code then calls the <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> method to merge the <xref:System.Security.AccessControl.RegistryRights> right back into the rule in the RegistrySecurity object.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. The second example in this section attaches a security object, and so do the examples in <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> and <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/add/codesnippet/visualbasic/t-system.security.access_15_1.vb)]\n [!code-cs[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/add/codesnippet/csharp/t-system.security.access_15_1.cs)]  \n  \n Example 2  \n  \n The following code example demonstrates access rules with inheritance and propagation. The example creates a RegistrySecurity object, then creates and adds two rules that have the <xref:System.Security.AccessControl.InheritanceFlags> flag. The first rule has no propagation flags, while the second has <xref:System.Security.AccessControl.PropagationFlags> and <xref:System.Security.AccessControl.PropagationFlags>.  \n  \n The program displays the rules in the RegistrySecurity object, and then uses the RegistrySecurity object to create a subkey. The program creates a child subkey and a grandchild subkey, then displays the security for each subkey. Finally, the program deletes the test keys.  \n  \n [!code-vb[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/add/codesnippet/visualbasic/t-system.security.access_15_2.vb)]\n [!code-cs[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/add/codesnippet/csharp/t-system.security.access_15_2.cs)]"
  syntax:
    content: 'public sealed class RegistrySecurity : System.Security.AccessControl.NativeObjectSecurity'
  inheritance:
  - System.Object
  - System.Security.AccessControl.ObjectSecurity
  - System.Security.AccessControl.CommonObjectSecurity
  - System.Security.AccessControl.NativeObjectSecurity
  implements: []
  inheritedMembers:
  - System.Security.AccessControl.CommonObjectSecurity.AddAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.AddAuditRule(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.GetAccessRules(System.Boolean,System.Boolean,System.Type)
  - System.Security.AccessControl.CommonObjectSecurity.GetAuditRules(System.Boolean,System.Boolean,System.Type)
  - System.Security.AccessControl.CommonObjectSecurity.ModifyAccess(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AccessRule,System.Boolean@)
  - System.Security.AccessControl.CommonObjectSecurity.ModifyAudit(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AuditRule,System.Boolean@)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAccessRuleAll(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAuditRule(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAuditRuleAll(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.ResetAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.SetAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.SetAuditRule(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.Runtime.InteropServices.SafeHandle,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.Runtime.InteropServices.SafeHandle,System.Security.AccessControl.AccessControlSections,System.Object)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.String,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.String,System.Security.AccessControl.AccessControlSections,System.Object)
  - System.Security.AccessControl.ObjectSecurity.AccessRulesModified
  - System.Security.AccessControl.ObjectSecurity.AreAccessRulesCanonical
  - System.Security.AccessControl.ObjectSecurity.AreAccessRulesProtected
  - System.Security.AccessControl.ObjectSecurity.AreAuditRulesCanonical
  - System.Security.AccessControl.ObjectSecurity.AreAuditRulesProtected
  - System.Security.AccessControl.ObjectSecurity.AuditRulesModified
  - System.Security.AccessControl.ObjectSecurity.GetGroup(System.Type)
  - System.Security.AccessControl.ObjectSecurity.GetOwner(System.Type)
  - System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm
  - System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm(System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.GroupModified
  - System.Security.AccessControl.ObjectSecurity.IsContainer
  - System.Security.AccessControl.ObjectSecurity.IsDS
  - System.Security.AccessControl.ObjectSecurity.IsSddlConversionSupported
  - System.Security.AccessControl.ObjectSecurity.ModifyAccessRule(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AccessRule,System.Boolean@)
  - System.Security.AccessControl.ObjectSecurity.ModifyAuditRule(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AuditRule,System.Boolean@)
  - System.Security.AccessControl.ObjectSecurity.OwnerModified
  - System.Security.AccessControl.ObjectSecurity.Persist(System.Boolean,System.String,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.PurgeAccessRules(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.PurgeAuditRules(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.ReadLock
  - System.Security.AccessControl.ObjectSecurity.ReadUnlock
  - System.Security.AccessControl.ObjectSecurity.SetAccessRuleProtection(System.Boolean,System.Boolean)
  - System.Security.AccessControl.ObjectSecurity.SetAuditRuleProtection(System.Boolean,System.Boolean)
  - System.Security.AccessControl.ObjectSecurity.SetGroup(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.SetOwner(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm(System.Byte[])
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm(System.Byte[],System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm(System.String)
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm(System.String,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.WriteLock
  - System.Security.AccessControl.ObjectSecurity.WriteUnlock
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.#ctor
  id: '#ctor'
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RegistrySecurity()
  nameWithType: RegistrySecurity.RegistrySecurity()
  fullName: System.Security.AccessControl.RegistrySecurity.RegistrySecurity()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "初始化的新实例<xref href=&quot;System.Security.AccessControl.RegistrySecurity&quot;></xref>类使用默认值。"
  remarks: "一个新<xref:System.Security.AccessControl.RegistrySecurity>对象开始时始终具有空的自由访问控制列表 (DACL)，此操作会拒绝所有用户的所有访问权限。</xref:System.Security.AccessControl.RegistrySecurity>"
  syntax:
    content: public RegistrySecurity ();
    parameters: []
  overload: System.Security.AccessControl.RegistrySecurity.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AccessRightType
  id: AccessRightType
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AccessRightType
  nameWithType: RegistrySecurity.AccessRightType
  fullName: System.Security.AccessControl.RegistrySecurity.AccessRightType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "获取枚举类型<xref href=&quot;System.Security.AccessControl.RegistrySecurity&quot;></xref>类用于表示的访问权限。"
  remarks: "派生自的类<xref:System.Security.AccessControl.ObjectSecurity>类替代<xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A>属性，并返回它们用于表示的访问权限的类型。</xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> </xref:System.Security.AccessControl.ObjectSecurity> 当使用数组或包含多个类型的安全对象的集合时，使用此属性来确定要用于每个安全对象的正确的枚举类型。"
  syntax:
    content: public override Type AccessRightType { get; }
    return:
      type: System.Type
      description: "A<xref:System.Type>对象，表示<xref href=&quot;System.Security.AccessControl.RegistryRights&quot;></xref>枚举。</xref:System.Type>"
  overload: System.Security.AccessControl.RegistrySecurity.AccessRightType*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  id: AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  nameWithType: RegistrySecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  fullName: System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "创建新的访问控制规则指定的用户，使用指定的访问权限、 访问控制和标志。"
  remarks: "创建访问控制规则的建议的方法是使用<xref:System.Security.AccessControl.RegistryAccessRule>类</xref:System.Security.AccessControl.RegistryAccessRule>的构造函数      1> [!NOTE]&1;> 虽然可以指定的<xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName>标志，没有在此过程中删除点</xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName> 对于访问控制，子项中的名称/值对不是单独的对象。 名称/值对的访问权限由该子项的权限控制。 此外，由于所有子项都是容器 （即，它们可以包含其他子项），它们不受<xref:System.Security.AccessControl.InheritanceFlags>标志。</xref:System.Security.AccessControl.InheritanceFlags> 最后，指定<xref:System.Security.AccessControl.InheritanceFlags>标志不必要地增加复杂性进行维护的规则，因为它干扰兼容的规则的正常组合。</xref:System.Security.AccessControl.InheritanceFlags>"
  syntax:
    content: public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);
    parameters:
    - id: identityReference
      type: System.Security.Principal.IdentityReference
      description: "<xref href=&quot;System.Security.Principal.IdentityReference&quot;> </xref>标识用户或组规则适用于。"
    - id: accessMask
      type: System.Int32
      description: "按位组合<xref href=&quot;System.Security.AccessControl.RegistryRights&quot;></xref>值指定的访问权限以允许或拒绝，强制转换为整数。"
    - id: isInherited
      type: System.Boolean
      description: "一个布尔值，指定是否继承规则。"
    - id: inheritanceFlags
      type: System.Security.AccessControl.InheritanceFlags
      description: "按位组合<xref href=&quot;System.Security.AccessControl.InheritanceFlags&quot;></xref>指定子项如何继承规则的值。"
    - id: propagationFlags
      type: System.Security.AccessControl.PropagationFlags
      description: "按位组合<xref href=&quot;System.Security.AccessControl.PropagationFlags&quot;></xref>修改规则的子项将继承的方式的值。 如果无意义的值`inheritanceFlags`是<xref href=&quot;System.Security.AccessControl.InheritanceFlags&quot;> </xref>。"
    - id: type
      type: System.Security.AccessControl.AccessControlType
      description: "之一<xref href=&quot;System.Security.AccessControl.AccessControlType&quot;></xref>值指定是否允许或拒绝权限。"
    return:
      type: System.Security.AccessControl.AccessRule
      description: "A <xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;> </xref>对象，表示指定的用户指定的权限。"
  overload: System.Security.AccessControl.RegistrySecurity.AccessRuleFactory*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>accessMask</code><code>inheritanceFlags</code>， <code>propagationFlags</code>，或<code>type</code>指定了一个无效值。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>identityReference</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或-<code>accessMask</code>为零。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>identityReference</code>既不属于类型<xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>，也不的类型，如<xref href=&quot;System.Security.Principal.NTAccount&quot;></xref>可以转换为类型<xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>。"
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AccessRuleType
  id: AccessRuleType
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AccessRuleType
  nameWithType: RegistrySecurity.AccessRuleType
  fullName: System.Security.AccessControl.RegistrySecurity.AccessRuleType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "获取的类型<xref href=&quot;System.Security.AccessControl.RegistrySecurity&quot;></xref>类用于表示访问规则。"
  remarks: "派生自的类<xref:System.Security.AccessControl.ObjectSecurity>类替代<xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A>属性，并返回它们用于表示访问规则的类型。</xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> </xref:System.Security.AccessControl.ObjectSecurity> 当使用数组或包含多个类型的安全对象的集合时，使用此属性来确定要使用每个安全对象的正确的访问规则类型。"
  syntax:
    content: public override Type AccessRuleType { get; }
    return:
      type: System.Type
      description: "A<xref:System.Type>对象，表示<xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;></xref>类</xref:System.Type>"
  overload: System.Security.AccessControl.RegistrySecurity.AccessRuleType*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AddAccessRule(System.Security.AccessControl.RegistryAccessRule)
  id: AddAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AddAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.AddAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.AddAccessRule(RegistryAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "新的规则可以与之合并的匹配访问控件的搜索。 如果找不到之后，将添加新规则。"
  remarks: "AddAccessRule 方法搜索与同一用户或组，以及相同的规则<xref:System.Security.AccessControl.AccessControlType>作为`rule`。</xref:System.Security.AccessControl.AccessControlType> 如果找不到之后，`rule`添加。 如果找到匹配规则是中的权限`rule`合并与现有规则。       如果它们具有不同的继承标志，则不能合并规则。 例如，如果用户允许读访问，任何继承标志，并且使用 AddAccessRule 来添加规则提供用户编写使用继承的子项的访问 (<xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName>)，不能合并两个规则。</xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName>       具有不同的规则<xref:System.Security.AccessControl.AccessControlType>值将永远不会合并。</xref:System.Security.AccessControl.AccessControlType>       规则 express 最经济的方法中的权限。 例如，如果用户具有<xref:System.Security.AccessControl.RegistryRights>，<xref:System.Security.AccessControl.RegistryRights>和<xref:System.Security.AccessControl.RegistryRights>权限，而您添加规则允许<xref:System.Security.AccessControl.RegistryRights>权限，用户拥有的所有组成部分<xref:System.Security.AccessControl.RegistryRights>权限。</xref:System.Security.AccessControl.RegistryRights> </xref:System.Security.AccessControl.RegistryRights> </xref:System.Security.AccessControl.RegistryRights> </xref:System.Security.AccessControl.RegistryRights> </xref:System.Security.AccessControl.RegistryRights> 如果你查询用户的权限，你将看到一个规则，其中包含<xref:System.Security.AccessControl.RegistryRights>权限。</xref:System.Security.AccessControl.RegistryRights> 同样，如果你删除<xref:System.Security.AccessControl.RegistryRights>权限外，其他构成<xref:System.Security.AccessControl.RegistryRights>权限将重新出现。</xref:System.Security.AccessControl.RegistryRights> </xref:System.Security.AccessControl.RegistryRights>"
  example:
  - "The following code example creates registry access rules and adds them to a <xref:System.Security.AccessControl.RegistrySecurity> object, showing how rules that allow and deny rights remain separate, while compatible rules of the same kind are merged.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. Examples that attach security objects can be found in <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> and <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>.  \n  \n A code example that demonstrates inheritance and propagation flags can be found in the <xref:System.Security.AccessControl.RegistryAccessRule> class.  \n  \n [!code-cs[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/add/codesnippet/csharp/0595520c-e456-4072-a959-_1.cs)]\n [!code-vb[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/add/codesnippet/visualbasic/0595520c-e456-4072-a959-_1.vb)]"
  syntax:
    content: public void AddAccessRule (System.Security.AccessControl.RegistryAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAccessRule
      description: "要添加的访问控制规则。"
  overload: System.Security.AccessControl.RegistrySecurity.AddAccessRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AddAuditRule(System.Security.AccessControl.RegistryAuditRule)
  id: AddAuditRule(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AddAuditRule(RegistryAuditRule)
  nameWithType: RegistrySecurity.AddAuditRule(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.AddAuditRule(RegistryAuditRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "可以与之合并新规则的审核规则的搜索。 如果找不到之后，将添加新规则。"
  remarks: "AddAuditRule 方法搜索规则具有相同的用户或组作为`rule`。 如果找不到之后，`rule`添加。 如果找到匹配规则是中的标志`rule`合并到现有规则。       如果它们具有不同的继承标志，则不能合并规则。 例如，如果写入某个注册表项的尝试失败审核的特定用户，没有任何继承标志，并 AddAuditRule 用于添加一个规则，指定的失败尝试更改权限，则对于相同的用户，但允许子项继承审核 (<xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName>)，不能合并两个规则。</xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName>"
  syntax:
    content: public void AddAuditRule (System.Security.AccessControl.RegistryAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAuditRule
      description: "要添加的审核规则。 此规则指定的用户确定搜索。"
  overload: System.Security.AccessControl.RegistrySecurity.AddAuditRule*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  id: AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  nameWithType: RegistrySecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  fullName: System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "创建一个新的审核规则，指定该规则适用于审核、 继承和传播的规则，对的访问权限的用户和触发规则的结果。"
  remarks: "创建审核规则的建议的方法是使用<xref:System.Security.AccessControl.RegistryAuditRule>类</xref:System.Security.AccessControl.RegistryAuditRule>的构造函数      1> [!NOTE]&1;> 虽然可以指定的<xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName>标志，没有在此过程中删除点</xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName> 对于审核控制，子项中的名称/值对不是单独的对象。 名称/值对的审核权限由该子项的权限控制。 此外，由于所有子项都是容器 （即，它们可以包含其他子项），它们不受<xref:System.Security.AccessControl.InheritanceFlags>标志。</xref:System.Security.AccessControl.InheritanceFlags> 最后，指定<xref:System.Security.AccessControl.InheritanceFlags>标志不必要地增加复杂性进行维护的规则，因为它干扰兼容的规则的正常组合。</xref:System.Security.AccessControl.InheritanceFlags>"
  syntax:
    content: public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);
    parameters:
    - id: identityReference
      type: System.Security.Principal.IdentityReference
      description: "<xref href=&quot;System.Security.Principal.IdentityReference&quot;> </xref>标识用户或组规则适用于。"
    - id: accessMask
      type: System.Int32
      description: "按位组合<xref href=&quot;System.Security.AccessControl.RegistryRights&quot;></xref>值指定的访问权限审核，强制转换为整数。"
    - id: isInherited
      type: System.Boolean
      description: "一个布尔值，指定是否继承规则。"
    - id: inheritanceFlags
      type: System.Security.AccessControl.InheritanceFlags
      description: "按位组合<xref href=&quot;System.Security.AccessControl.InheritanceFlags&quot;></xref>指定子项如何继承规则的值。"
    - id: propagationFlags
      type: System.Security.AccessControl.PropagationFlags
      description: "按位组合<xref href=&quot;System.Security.AccessControl.PropagationFlags&quot;></xref>修改规则的子项将继承的方式的值。 如果无意义的值`inheritanceFlags`是<xref href=&quot;System.Security.AccessControl.InheritanceFlags&quot;> </xref>。"
    - id: flags
      type: System.Security.AccessControl.AuditFlags
      description: "按位组合<xref href=&quot;System.Security.AccessControl.AuditFlags&quot;></xref>指定是否要审核的成功访问、 失败的访问，或两者的值。"
    return:
      type: System.Security.AccessControl.AuditRule
      description: "A <xref href=&quot;System.Security.AccessControl.RegistryAuditRule&quot;> </xref>对象，表示指定的用户，使用指定的标志指定的审核规则。 该方法的返回类型是基类， <xref href=&quot;System.Security.AccessControl.AuditRule&quot;> </xref>，但返回的值可以安全地强制转换到派生的类。"
  overload: System.Security.AccessControl.RegistrySecurity.AuditRuleFactory*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>accessMask</code><code>inheritanceFlags</code>， <code>propagationFlags</code>，或<code>flags</code>指定了一个无效值。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>identityReference</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或-<code>accessMask</code>为零。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>identityReference</code>既不属于类型<xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>，也不的类型，如<xref href=&quot;System.Security.Principal.NTAccount&quot;></xref>可以转换为类型<xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>。"
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AuditRuleType
  id: AuditRuleType
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AuditRuleType
  nameWithType: RegistrySecurity.AuditRuleType
  fullName: System.Security.AccessControl.RegistrySecurity.AuditRuleType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "获取的类型<xref href=&quot;System.Security.AccessControl.RegistrySecurity&quot;></xref>类用于表示审核规则。"
  remarks: "派生自的类<xref:System.Security.AccessControl.ObjectSecurity>类替代<xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A>属性，并返回它们用于表示审核权限的类型。</xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> </xref:System.Security.AccessControl.ObjectSecurity> 当使用数组或包含多个类型的安全对象的集合时，使用此属性来确定要用于每个安全对象的正确的审核规则类型。"
  syntax:
    content: public override Type AuditRuleType { get; }
    return:
      type: System.Type
      description: "A<xref:System.Type>对象，表示<xref href=&quot;System.Security.AccessControl.RegistryAuditRule&quot;></xref>类</xref:System.Type>"
  overload: System.Security.AccessControl.RegistrySecurity.AuditRuleType*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(System.Security.AccessControl.RegistryAccessRule)
  id: RemoveAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RemoveAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.RemoveAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(RegistryAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "搜索与同一用户的访问控制规则和<xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> （允许或拒绝） 与指定的访问权限的规则，并具有兼容的继承和传播标志; 如果找到此类规则，指定的访问规则中包含的权限会从删除它。"
  remarks: "当前<xref:System.Security.AccessControl.RegistrySecurity>具有相同的用户和相同的规则，将会搜索<xref:System.Security.AccessControl.AccessControlType>值作为`rule`。</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.RegistrySecurity> 如果找到任何此类规则，不执行任何操作，并且该方法返回`false`。 如果找到匹配的规则，它们继承和兼容性标志将检查与中指定的标志的兼容性`rule`。 如果找到任何兼容的规则，不执行任何操作，并且该方法返回`false`。 如果找到具有兼容的标志的规则，则在指定的权限`rule`会从兼容的规则，并且该方法返回`true`。 如果`rule`指定不兼容的规则中包含的权限，根据这些权限不执行任何操作。 如果从兼容的规则中移除所有权限，将整个规则都删除从当前<xref:System.Security.AccessControl.RegistrySecurity>对象。</xref:System.Security.AccessControl.RegistrySecurity>"
  example:
  - "The following code example shows how the RemoveAccessRule method removes rights from a compatible rule, and how the <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> method merges rights with compatible rules.  \n  \n The example creates a <xref:System.Security.AccessControl.RegistrySecurity> object and adds a rule that allows the current user <xref:System.Security.AccessControl.RegistryRights?displayProperty=fullName> rights. The example then creates a rule that grants the user <xref:System.Security.AccessControl.RegistryRights?displayProperty=fullName>, with the same inheritance and propagation rights as the first rule, and uses the RemoveAccessRule method to remove this new rule from the <xref:System.Security.AccessControl.RegistrySecurity> object. <xref:System.Security.AccessControl.RegistryRights> is a constituent of <xref:System.Security.AccessControl.RegistryRights>, so it is removed from the compatible rule. The rules in the <xref:System.Security.AccessControl.RegistrySecurity> object are displayed, showing the remaining constituents of <xref:System.Security.AccessControl.RegistryRights>.  \n  \n The example code then calls the RemoveAccessRule method to merge the <xref:System.Security.AccessControl.RegistryRights> right back into the rule in the <xref:System.Security.AccessControl.RegistrySecurity> object.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. The second example in this section attaches a security object, and so do the examples in <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName><xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/add/codesnippet/visualbasic/797f5ef0-d4da-43dd-bbe9-_1.vb)]\n [!code-cs[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/add/codesnippet/csharp/797f5ef0-d4da-43dd-bbe9-_1.cs)]"
  syntax:
    content: public bool RemoveAccessRule (System.Security.AccessControl.RegistryAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAccessRule
      description: "A <xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;> </xref>指定的用户和<xref href=&quot;System.Security.AccessControl.AccessControlType&quot;></xref>搜索，以及一组继承和传播标志，用于匹配规则，如果找到，则必须是与兼容。 指定的权限删除兼容的规则，如果找到。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果找到兼容的规则;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Security.AccessControl.RegistrySecurity.RemoveAccessRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(System.Security.AccessControl.RegistryAccessRule)
  id: RemoveAccessRuleAll(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RemoveAccessRuleAll(RegistryAccessRule)
  nameWithType: RegistrySecurity.RemoveAccessRuleAll(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(RegistryAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "搜索所有访问控制规则具有相同的用户和<xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> （允许或拒绝） 指定规则且，如果找到，则删除它们。"
  remarks: "当前<xref:System.Security.AccessControl.RegistrySecurity>具有相同的用户和相同的规则，将会搜索<xref:System.Security.AccessControl.AccessControlType>值作为`rule`。</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.RegistrySecurity> 任何权限、 继承标志或由指定的传播标志`rule`时执行此搜索将忽略。 如果不找到任何匹配的规则，不执行任何操作。       例如，如果用户具有允许具有不同的继承和传播标志的各种权限的多个规则，则可以删除所有这些规则通过创建<xref:System.Security.AccessControl.RegistryAccessRule>对象，它指定用户和<xref:System.Security.AccessControl.AccessControlType?displayProperty=fullName>、 与该规则 RemoveAccessRuleAll 方法到任意权限和标志，以及传递。</xref:System.Security.AccessControl.AccessControlType?displayProperty=fullName> </xref:System.Security.AccessControl.RegistryAccessRule>"
  example:
  - "The following code example shows that the RemoveAccessRuleAll method removes all rules that match user and <xref:System.Security.AccessControl.AccessControlType>, ignoring rights and flags.  \n  \n The example creates a <xref:System.Security.AccessControl.RegistrySecurity> object and adds rules that allow and deny various rights for the current user, with different inheritance and propagation flags. The example then creates a new rule that allows the current user to take ownership, and passes that rule to the RemoveAccessRuleAll method to remove the two rules that allow access.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. See the <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> method and the <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName> method.  \n  \n [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll#1](~/add/codesnippet/visualbasic/2ba6e9de-1f41-4d05-af76-_1.vb)]\n [!code-cs[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll#1](~/add/codesnippet/csharp/2ba6e9de-1f41-4d05-af76-_1.cs)]"
  syntax:
    content: public void RemoveAccessRuleAll (System.Security.AccessControl.RegistryAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAccessRule
      description: "A <xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;> </xref>指定的用户和<xref href=&quot;System.Security.AccessControl.AccessControlType&quot;></xref>搜索。 忽略任何权限，继承标志或此规则指定的传播标志。"
  overload: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.RegistryAccessRule)
  id: RemoveAccessRuleSpecific(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RemoveAccessRuleSpecific(RegistryAccessRule)
  nameWithType: RegistrySecurity.RemoveAccessRuleSpecific(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(RegistryAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "搜索完全匹配所指定的访问控制规则的规则和，如果找到，则删除它。"
  remarks: "仅当完全匹配时，才移除规则`rule`中的所有详细信息，包括标志。 具有相同的用户的其他规则和<xref:System.Security.AccessControl.AccessControlType>不会受到影响。</xref:System.Security.AccessControl.AccessControlType>      1> [!IMPORTANT]&1;> 规则表示一个或多个基础访问控制项 (ACE)，和拆分或修改用户的访问安全性规则时，根据需要组合这些条目。 因此，一个规则可能不再存在时它已添加的特定形式，RemoveAccessRuleSpecific 方法不能在这种情况下删除它。"
  example:
  - "The following code example shows that the RemoveAccessRuleSpecific method removes a rule only if it matches exactly.  \n  \n The example creates two rules that allow different rights. The rules have compatible inheritance and propagation flags, so when the second rule is added it merges with the first. The example calls the RemoveAccessRuleSpecific method, specifying the first rule, but because the rules are merged there is no rule that matches. The example then calls the <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> method to the remove the second rule from the merged rule, and finally calls the RemoveAccessRuleSpecific method to remove the first rule.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. See the <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> method and the <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName> method.  \n  \n [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific#1](~/add/codesnippet/visualbasic/9819c0cd-2b26-4472-a333-_1.vb)]\n [!code-cs[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific#1](~/add/codesnippet/csharp/9819c0cd-2b26-4472-a333-_1.cs)]"
  syntax:
    content: public void RemoveAccessRuleSpecific (System.Security.AccessControl.RegistryAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAccessRule
      description: "<xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;> </xref>删除。"
  overload: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(System.Security.AccessControl.RegistryAuditRule)
  id: RemoveAuditRule(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RemoveAuditRule(RegistryAuditRule)
  nameWithType: RegistrySecurity.RemoveAuditRule(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(RegistryAuditRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "搜索与同一用户作为指定的规则，并具有兼容的继承和传播标志; 审核控制规则如果找到兼容的规则，则会从其删除指定的规则中包含的权限。"
  remarks: "当前<xref:System.Security.AccessControl.RegistrySecurity>搜索已为同一用户的审核规则`rule`。</xref:System.Security.AccessControl.RegistrySecurity> 如果找到任何此类规则，不执行任何操作，并且该方法返回`false`。 如果找到匹配的规则，它们继承和兼容性标志将检查与中指定的标志的兼容性`rule`。 如果找到任何兼容的规则，不执行任何操作，并且该方法返回`false`。 如果找到具有兼容的标志的规则，则在指定的权限`rule`会从兼容的规则，并且该方法返回`true`。 如果`rule`指定不兼容的规则中包含的权限，根据这些权限不执行任何操作。 如果从兼容的规则中移除所有权限，将整个规则都删除从当前<xref:System.Security.AccessControl.RegistrySecurity>对象。</xref:System.Security.AccessControl.RegistrySecurity>"
  syntax:
    content: public bool RemoveAuditRule (System.Security.AccessControl.RegistryAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAuditRule
      description: "A <xref href=&quot;System.Security.AccessControl.RegistryAuditRule&quot;> </xref> ，它指定用户来进行搜索和一组继承和传播标志匹配规则，如果找到，则必须是与兼容。 指定的权限删除兼容的规则，如果找到。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果找到兼容的规则;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Security.AccessControl.RegistrySecurity.RemoveAuditRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(System.Security.AccessControl.RegistryAuditRule)
  id: RemoveAuditRuleAll(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RemoveAuditRuleAll(RegistryAuditRule)
  nameWithType: RegistrySecurity.RemoveAuditRuleAll(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(RegistryAuditRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "搜索所有审核规则与同一用户与指定的规则，如果找到，将删除它们。"
  remarks: "当前<xref:System.Security.AccessControl.RegistrySecurity>会为使用相同用户作为的审核规则搜索`rule`。</xref:System.Security.AccessControl.RegistrySecurity> 任何权限、 继承标志或由指定的传播标志`rule`时执行此搜索将忽略。 如果不找到任何匹配的规则，不执行任何操作。"
  syntax:
    content: public void RemoveAuditRuleAll (System.Security.AccessControl.RegistryAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAuditRule
      description: "A <xref href=&quot;System.Security.AccessControl.RegistryAuditRule&quot;> </xref> ，指定要搜索的用户。 忽略任何权限，继承标志或此规则指定的传播标志。"
  overload: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.RegistryAuditRule)
  id: RemoveAuditRuleSpecific(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RemoveAuditRuleSpecific(RegistryAuditRule)
  nameWithType: RegistrySecurity.RemoveAuditRuleSpecific(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(RegistryAuditRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "搜索完全匹配所指定的审核规则的规则和，如果找到，则删除它。"
  remarks: "仅当完全匹配时，才移除规则`rule`中的所有详细信息，包括标志。 不会影响同一用户其他审核规则。      1> [!IMPORTANT]&1;> 规则表示一个或多个基础访问控制项 (ACE)，和拆分或修改用户的审核安全规则时，根据需要组合这些条目。 因此，一个规则可能不再存在时它已添加的特定形式，RemoveAuditRuleSpecific 方法不能在这种情况下删除它。"
  syntax:
    content: public void RemoveAuditRuleSpecific (System.Security.AccessControl.RegistryAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAuditRule
      description: "<xref href=&quot;System.Security.AccessControl.RegistryAuditRule&quot;> </xref>要删除。"
  overload: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.ResetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  id: ResetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: ResetAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.ResetAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.ResetAccessRule(RegistryAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "移除带有相同用户作为指定的规则，而不考虑的所有访问控制规则<xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref>，然后将添加指定的规则。"
  remarks: "如果没有指定的规则，与匹配的用户的访问规则`rule`添加。"
  example:
  - "The following code example shows how the ResetAccessRule method replaces all rules for the matching user with the rule specified for the match.  \n  \n The example creates a <xref:System.Security.AccessControl.RegistrySecurity> object and adds rules that allow and deny various rights for the current user, with different inheritance and propagation flags. The example then creates a new rule that allows the current user only to read the key, and uses the ResetAccessRule method to remove the all rules for the user and replace them with the new rule.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. See the <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> method and the <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName> method.  \n  \n [!code-cs[System.Security.AccessControl.RegistrySecurity.ResetAccessRule#1](~/add/codesnippet/csharp/80c97a6c-33e0-43c8-8894-_1.cs)]\n [!code-vb[System.Security.AccessControl.RegistrySecurity.ResetAccessRule#1](~/add/codesnippet/visualbasic/80c97a6c-33e0-43c8-8894-_1.vb)]"
  syntax:
    content: public void ResetAccessRule (System.Security.AccessControl.RegistryAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAccessRule
      description: "The <xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;></xref> to add. 此规则指定的用户确定要移除之前添加此规则的规则。"
  overload: System.Security.AccessControl.RegistrySecurity.ResetAccessRule*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.SetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  id: SetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: SetAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.SetAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.SetAccessRule(RegistryAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "移除带有相同的用户的所有访问控制规则和<xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> （允许或拒绝） 与指定的规则，然后将添加指定的规则。"
  remarks: "如果指定的规则具有<xref:System.Security.AccessControl.AccessControlType>，此方法的效果是移除所有<xref:System.Security.AccessControl.AccessControlType>对于指定的用户，并将它们替换为指定的规则的规则。</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.AccessControlType> 如果指定的规则具有<xref:System.Security.AccessControl.AccessControlType>，所有<xref:System.Security.AccessControl.AccessControlType>规则指定的用户替换与指定的规则。</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.AccessControlType>       如果没有规则的用户和<xref:System.Security.AccessControl.AccessControlType>匹配指定的规则，`rule`添加。</xref:System.Security.AccessControl.AccessControlType>"
  example:
  - "The following code example shows that the SetAccessRule method removes all rules that match both the user and the <xref:System.Security.AccessControl.AccessControlType> of `rule`, ignoring rights and flags, and replaces them with `rule`.  \n  \n The example creates a <xref:System.Security.AccessControl.RegistrySecurity> object and adds rules that allow and deny various rights for the current user, with different inheritance and propagation flags. The example then creates a new rule that allows the current user only to read the key, and uses the SetAccessRule method to remove the two rules that allow access and to replace them with the new rule. The rule that denies access is not affected.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. See the <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> method and the <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName> method.  \n  \n [!code-vb[System.Security.AccessControl.RegistrySecurity.SetAccessRule#1](~/add/codesnippet/visualbasic/908f14bb-fbc5-4e71-ac82-_1.vb)]\n [!code-cs[System.Security.AccessControl.RegistrySecurity.SetAccessRule#1](~/add/codesnippet/csharp/908f14bb-fbc5-4e71-ac82-_1.cs)]"
  syntax:
    content: public void SetAccessRule (System.Security.AccessControl.RegistryAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAccessRule
      description: "The <xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;></xref> to add. 用户和<xref href=&quot;System.Security.AccessControl.AccessControlType&quot;></xref>此规则确定要移除之前添加此规则的规则。"
  overload: System.Security.AccessControl.RegistrySecurity.SetAccessRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.SetAuditRule(System.Security.AccessControl.RegistryAuditRule)
  id: SetAuditRule(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: SetAuditRule(RegistryAuditRule)
  nameWithType: RegistrySecurity.SetAuditRule(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.SetAuditRule(RegistryAuditRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "移除所有审核规则与同一用户作为指定的规则，而不考虑<xref href=&quot;System.Security.AccessControl.AuditFlags&quot;></xref>值，并将指定的规则。"
  remarks: "如果没有指定的规则，与匹配的用户的审核规则`rule`添加。"
  syntax:
    content: public void SetAuditRule (System.Security.AccessControl.RegistryAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAuditRule
      description: "The <xref href=&quot;System.Security.AccessControl.RegistryAuditRule&quot;></xref> to add. 此规则指定的用户确定要移除之前添加此规则的规则。"
  overload: System.Security.AccessControl.RegistrySecurity.SetAuditRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
references:
- uid: System.Security.AccessControl.NativeObjectSecurity
  isExternal: false
  name: System.Security.AccessControl.NativeObjectSecurity
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Security.AccessControl.RegistrySecurity.#ctor
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RegistrySecurity()
  nameWithType: RegistrySecurity.RegistrySecurity()
  fullName: System.Security.AccessControl.RegistrySecurity.RegistrySecurity()
- uid: System.Security.AccessControl.RegistrySecurity.AccessRightType
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AccessRightType
  nameWithType: RegistrySecurity.AccessRightType
  fullName: System.Security.AccessControl.RegistrySecurity.AccessRightType
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  nameWithType: RegistrySecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  fullName: System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
- uid: System.Security.AccessControl.AccessRule
  parent: System.Security.AccessControl
  isExternal: false
  name: AccessRule
  nameWithType: AccessRule
  fullName: System.Security.AccessControl.AccessRule
- uid: System.Security.Principal.IdentityReference
  parent: System.Security.Principal
  isExternal: false
  name: IdentityReference
  nameWithType: IdentityReference
  fullName: System.Security.Principal.IdentityReference
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Security.AccessControl.InheritanceFlags
  parent: System.Security.AccessControl
  isExternal: false
  name: InheritanceFlags
  nameWithType: InheritanceFlags
  fullName: System.Security.AccessControl.InheritanceFlags
- uid: System.Security.AccessControl.PropagationFlags
  parent: System.Security.AccessControl
  isExternal: false
  name: PropagationFlags
  nameWithType: PropagationFlags
  fullName: System.Security.AccessControl.PropagationFlags
- uid: System.Security.AccessControl.AccessControlType
  parent: System.Security.AccessControl
  isExternal: false
  name: AccessControlType
  nameWithType: AccessControlType
  fullName: System.Security.AccessControl.AccessControlType
- uid: System.Security.AccessControl.RegistrySecurity.AccessRuleType
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AccessRuleType
  nameWithType: RegistrySecurity.AccessRuleType
  fullName: System.Security.AccessControl.RegistrySecurity.AccessRuleType
- uid: System.Security.AccessControl.RegistrySecurity.AddAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AddAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.AddAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.AddAccessRule(RegistryAccessRule)
- uid: System.Security.AccessControl.RegistryAccessRule
  parent: System.Security.AccessControl
  isExternal: false
  name: RegistryAccessRule
  nameWithType: RegistryAccessRule
  fullName: System.Security.AccessControl.RegistryAccessRule
- uid: System.Security.AccessControl.RegistrySecurity.AddAuditRule(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AddAuditRule(RegistryAuditRule)
  nameWithType: RegistrySecurity.AddAuditRule(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.AddAuditRule(RegistryAuditRule)
- uid: System.Security.AccessControl.RegistryAuditRule
  parent: System.Security.AccessControl
  isExternal: false
  name: RegistryAuditRule
  nameWithType: RegistryAuditRule
  fullName: System.Security.AccessControl.RegistryAuditRule
- uid: System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  nameWithType: RegistrySecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  fullName: System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
- uid: System.Security.AccessControl.AuditRule
  parent: System.Security.AccessControl
  isExternal: false
  name: AuditRule
  nameWithType: AuditRule
  fullName: System.Security.AccessControl.AuditRule
- uid: System.Security.AccessControl.AuditFlags
  parent: System.Security.AccessControl
  isExternal: false
  name: AuditFlags
  nameWithType: AuditFlags
  fullName: System.Security.AccessControl.AuditFlags
- uid: System.Security.AccessControl.RegistrySecurity.AuditRuleType
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AuditRuleType
  nameWithType: RegistrySecurity.AuditRuleType
  fullName: System.Security.AccessControl.RegistrySecurity.AuditRuleType
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.RemoveAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(RegistryAccessRule)
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAccessRuleAll(RegistryAccessRule)
  nameWithType: RegistrySecurity.RemoveAccessRuleAll(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(RegistryAccessRule)
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAccessRuleSpecific(RegistryAccessRule)
  nameWithType: RegistrySecurity.RemoveAccessRuleSpecific(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(RegistryAccessRule)
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAuditRule(RegistryAuditRule)
  nameWithType: RegistrySecurity.RemoveAuditRule(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(RegistryAuditRule)
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAuditRuleAll(RegistryAuditRule)
  nameWithType: RegistrySecurity.RemoveAuditRuleAll(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(RegistryAuditRule)
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAuditRuleSpecific(RegistryAuditRule)
  nameWithType: RegistrySecurity.RemoveAuditRuleSpecific(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(RegistryAuditRule)
- uid: System.Security.AccessControl.RegistrySecurity.ResetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: ResetAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.ResetAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.ResetAccessRule(RegistryAccessRule)
- uid: System.Security.AccessControl.RegistrySecurity.SetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: SetAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.SetAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.SetAccessRule(RegistryAccessRule)
- uid: System.Security.AccessControl.RegistrySecurity.SetAuditRule(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: SetAuditRule(RegistryAuditRule)
  nameWithType: RegistrySecurity.SetAuditRule(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.SetAuditRule(RegistryAuditRule)
- uid: System.Security.AccessControl.RegistrySecurity.#ctor*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RegistrySecurity
  nameWithType: RegistrySecurity.RegistrySecurity
- uid: System.Security.AccessControl.RegistrySecurity.AccessRightType*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AccessRightType
  nameWithType: RegistrySecurity.AccessRightType
- uid: System.Security.AccessControl.RegistrySecurity.AccessRuleFactory*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AccessRuleFactory
  nameWithType: RegistrySecurity.AccessRuleFactory
- uid: System.Security.AccessControl.RegistrySecurity.AccessRuleType*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AccessRuleType
  nameWithType: RegistrySecurity.AccessRuleType
- uid: System.Security.AccessControl.RegistrySecurity.AddAccessRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AddAccessRule
  nameWithType: RegistrySecurity.AddAccessRule
- uid: System.Security.AccessControl.RegistrySecurity.AddAuditRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AddAuditRule
  nameWithType: RegistrySecurity.AddAuditRule
- uid: System.Security.AccessControl.RegistrySecurity.AuditRuleFactory*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AuditRuleFactory
  nameWithType: RegistrySecurity.AuditRuleFactory
- uid: System.Security.AccessControl.RegistrySecurity.AuditRuleType*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AuditRuleType
  nameWithType: RegistrySecurity.AuditRuleType
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAccessRule
  nameWithType: RegistrySecurity.RemoveAccessRule
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAccessRuleAll
  nameWithType: RegistrySecurity.RemoveAccessRuleAll
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAccessRuleSpecific
  nameWithType: RegistrySecurity.RemoveAccessRuleSpecific
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAuditRule
  nameWithType: RegistrySecurity.RemoveAuditRule
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAuditRuleAll
  nameWithType: RegistrySecurity.RemoveAuditRuleAll
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAuditRuleSpecific
  nameWithType: RegistrySecurity.RemoveAuditRuleSpecific
- uid: System.Security.AccessControl.RegistrySecurity.ResetAccessRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: ResetAccessRule
  nameWithType: RegistrySecurity.ResetAccessRule
- uid: System.Security.AccessControl.RegistrySecurity.SetAccessRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: SetAccessRule
  nameWithType: RegistrySecurity.SetAccessRule
- uid: System.Security.AccessControl.RegistrySecurity.SetAuditRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: SetAuditRule
  nameWithType: RegistrySecurity.SetAuditRule
