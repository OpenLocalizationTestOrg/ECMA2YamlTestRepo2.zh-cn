### YamlMime:ManagedReference
items:
- uid: Microsoft.VisualBasic.Interaction
  id: Interaction
  children:
  - Microsoft.VisualBasic.Interaction.AppActivate(System.Int32)
  - Microsoft.VisualBasic.Interaction.AppActivate(System.String)
  - Microsoft.VisualBasic.Interaction.Beep
  - Microsoft.VisualBasic.Interaction.CallByName(System.Object,System.String,Microsoft.VisualBasic.CallType,System.Object[])
  - Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])
  - Microsoft.VisualBasic.Interaction.Command
  - Microsoft.VisualBasic.Interaction.CreateObject(System.String,System.String)
  - Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)
  - Microsoft.VisualBasic.Interaction.Environ(System.Int32)
  - Microsoft.VisualBasic.Interaction.Environ(System.String)
  - Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)
  - Microsoft.VisualBasic.Interaction.GetObject(System.String,System.String)
  - Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)
  - Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)
  - Microsoft.VisualBasic.Interaction.InputBox(System.String,System.String,System.String,System.Int32,System.Int32)
  - Microsoft.VisualBasic.Interaction.MsgBox(System.Object,Microsoft.VisualBasic.MsgBoxStyle,System.Object)
  - Microsoft.VisualBasic.Interaction.Partition(System.Int64,System.Int64,System.Int64,System.Int64)
  - Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)
  - Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)
  - Microsoft.VisualBasic.Interaction.Switch(System.Object[])
  langs:
  - csharp
  name: Interaction
  nameWithType: Interaction
  fullName: Microsoft.VisualBasic.Interaction
  type: Class
  summary: "<xref uid=&quot;langword_csharp_Interaction&quot; name=&quot;Interaction&quot; href=&quot;&quot;> </xref>模块包含用于与对象、 应用程序和系统进行交互的过程。"
  remarks: "此模块支持的 Visual Basic 语言关键字和运行其他程序，调用方法或属性，从计算机提示音、 提供命令行字符串、 操作 COM 对象，并控制对话框的运行时库成员。"
  example:
  - "The following example uses the `Shell` function to run an application specified by the user. Specifying <xref:Microsoft.VisualBasic.AppWinStyle?displayProperty=fullName> as the second argument opens the application in normal size and gives it the focus.  \n  \n```  \nDim procID As Integer  \n' Run calculator.  \nprocID = Shell(\"C:\\Windows\\system32\\calc.exe\", AppWinStyle.NormalFocus)  \n' The preceding path is for Windows XP.  \n' The Windows 2000 path is C:\\WINNT\\system32\\calc.exe.  \n```"
  syntax:
    content: >-
      [Microsoft.VisualBasic.CompilerServices.StandardModule]

      public sealed class Interaction
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.Interaction.AppActivate(System.Int32)
  id: AppActivate(System.Int32)
  parent: Microsoft.VisualBasic.Interaction
  langs:
  - csharp
  name: AppActivate(Int32)
  nameWithType: Interaction.AppActivate(Int32)
  fullName: Microsoft.VisualBasic.Interaction.AppActivate(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "激活的应用程序已在运行。"
  remarks: "你使用`AppActivate`将应用程序的活动窗口引入焦点。 不可能具有一个句柄或活动窗口时，对的引用，或甚至知道哪个窗口在给定时刻处于活动状态。 在这种情况下，不能使用<xref:System.Windows.Forms.Control.Focus%2A>方法。</xref:System.Windows.Forms.Control.Focus%2A>       `AppActivate`函数将焦点更改到命名的应用程序或窗口，但不会影响是否它被最大化或最小化。 当用户执行某些操作，以将焦点更改或关闭窗口时，焦点移动的激活的应用程序窗口外。 你可以使用`Shell`函数来启动应用程序和设置窗口样式。       如果你使用`Title`参数，`AppActivate`使用不区分大小写的比较，但要求的标题栏的内容完全匹配。 它首先查找顶级窗口，然后通过子窗口。 如果它找不到匹配项，则会引发<xref:System.ArgumentException>.</xref:System.ArgumentException>       你可以使用`AppActivate`仅与拥有 windows 的过程。 大多数的控制台应用程序都不具有的窗口，这意味着，它们不会出现在列表中处理`AppActivate`搜索。 从一个控制台应用程序运行时，系统将创建一个单独的进程运行该应用程序，并将输出返回到控制台进程。 因此，当你请求的当前进程 ID，你获得此单独的进程的进程 ID，而不是控制台应用程序的进程 id。       在运行时，`AppActivate`函数激活任何运行的应用程序具有匹配标题`Title`或进程 id 相匹配`ProcessId`。 如果没有任何确切匹配项，则会激活任何应用程序，其标题字符串结尾`Title`。 如果没有名为的多个应用程序`Title`、`AppActivate`函数随机选择一个用于激活。      1> [!NOTE]&1;>`AppActivate`函数需要`UIPermission`在<xref:System.Security.Permissions.UIPermissionWindow>级别，这可能会影响在部分信任情况下其执行。</xref:System.Security.Permissions.UIPermissionWindow> 有关详细信息，请参阅<xref:System.Security.Permissions.UIPermission>。</xref:System.Security.Permissions.UIPermission>"
  example:
  - "This example illustrates various uses of the `AppActivate` function to activate an application window. If a Notepad process is not running, the example throws an <xref:System.ArgumentException>. The `Shell` procedure assumes the applications are in the paths specified.  \n  \n [!code-vb[VbVbalrCatRef#11](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._135_1.vb)]"
  syntax:
    content: public static void AppActivate (int ProcessId);
    parameters:
    - id: ProcessId
      type: System.Int32
      description: "<xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;></xref>指定分配给该进程的 Win32 进程 ID 号。 你可以使用返回的 ID <xref:Microsoft.VisualBasic.Interaction.Shell*>，则它不为零。</xref:Microsoft.VisualBasic.Interaction.Shell*>"
  overload: Microsoft.VisualBasic.Interaction.AppActivate*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.Interaction.AppActivate(System.String)
  id: AppActivate(System.String)
  parent: Microsoft.VisualBasic.Interaction
  langs:
  - csharp
  name: AppActivate(String)
  nameWithType: Interaction.AppActivate(String)
  fullName: Microsoft.VisualBasic.Interaction.AppActivate(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "激活的应用程序已在运行。"
  remarks: "你使用`AppActivate`将应用程序的活动窗口引入焦点。 不可能具有一个句柄或活动窗口时，对的引用，或甚至知道哪个窗口在给定时刻处于活动状态。 在这种情况下，不能使用<xref:System.Windows.Forms.Control.Focus%2A>方法。</xref:System.Windows.Forms.Control.Focus%2A>       `AppActivate`函数将焦点更改到命名的应用程序或窗口，但不会影响是否它被最大化或最小化。 当用户执行某些操作，以将焦点更改或关闭窗口时，焦点移动的激活的应用程序窗口外。 你可以使用`Shell`函数来启动应用程序和设置窗口样式。       如果你使用`Title`参数，`AppActivate`使用不区分大小写的比较，但要求的标题栏的内容完全匹配。 它首先查找顶级窗口，然后通过子窗口。 如果它找不到匹配项，则会引发<xref:System.ArgumentException>.</xref:System.ArgumentException>       你可以使用`AppActivate`仅与拥有 windows 的过程。 大多数的控制台应用程序都不具有的窗口，这意味着，它们不会出现在列表中处理`AppActivate`搜索。 从一个控制台应用程序运行时，系统将创建一个单独的进程运行该应用程序，并将输出返回到控制台进程。 因此，当你请求的当前进程 ID，你获得此单独的进程的进程 ID，而不是控制台应用程序的进程 id。       在运行时，`AppActivate`函数激活任何运行的应用程序具有匹配标题`Title`或进程 id 相匹配`ProcessId`。 如果没有任何确切匹配项，则会激活任何应用程序，其标题字符串结尾`Title`。 如果没有名为的多个应用程序`Title`、`AppActivate`函数随机选择一个用于激活。      1> [!NOTE]&1;>`AppActivate`函数需要`UIPermission`在<xref:System.Security.Permissions.UIPermissionWindow>级别，这可能会影响在部分信任情况下其执行。</xref:System.Security.Permissions.UIPermissionWindow> 有关详细信息，请参阅<xref:System.Security.Permissions.UIPermission>。</xref:System.Security.Permissions.UIPermission>"
  example:
  - "This example illustrates various uses of the `AppActivate` function to activate an application window. If a Notepad process is not running, the example throws an <xref:System.ArgumentException>. The `Shell` procedure assumes the applications are in the paths specified.  \n  \n [!code-vb[VbVbalrCatRef#11](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._229_1.vb)]"
  syntax:
    content: public static void AppActivate (string Title);
    parameters:
    - id: Title
      type: System.String
      description: "<xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>在你要激活的应用程序的标题栏中指定标题的表达式。 你可以使用其启动时分配给应用程序的标题。"
  overload: Microsoft.VisualBasic.Interaction.AppActivate*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.Interaction.Beep
  id: Beep
  parent: Microsoft.VisualBasic.Interaction
  langs:
  - csharp
  name: Beep()
  nameWithType: Interaction.Beep()
  fullName: Microsoft.VisualBasic.Interaction.Beep()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "声音通过计算机的扬声器发出音调。"
  remarks: "音调和提示音的持续时间取决于你的硬件和系统软件，因此不同计算机之间。      1> [!NOTE]&1;>`Beep`函数需要`UIPermission`在<xref:System.Security.Permissions.UIPermissionWindow>级别，这可能会影响在部分信任情况下其执行。</xref:System.Security.Permissions.UIPermissionWindow> 有关详细信息，请参阅<xref:System.Security.Permissions.UIPermission>。</xref:System.Security.Permissions.UIPermission>"
  example:
  - "This example uses the `Beep` function to sound a tone through the computer's speaker.  \n  \n [!code-vb[VbVbalrCatRef#59](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._129_1.vb)]"
  syntax:
    content: public static void Beep ();
    parameters: []
  overload: Microsoft.VisualBasic.Interaction.Beep*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.Interaction.CallByName(System.Object,System.String,Microsoft.VisualBasic.CallType,System.Object[])
  id: CallByName(System.Object,System.String,Microsoft.VisualBasic.CallType,System.Object[])
  parent: Microsoft.VisualBasic.Interaction
  langs:
  - csharp
  name: CallByName(Object,String,CallType,Object[])
  nameWithType: Interaction.CallByName(Object,String,CallType,Object[])
  fullName: Microsoft.VisualBasic.Interaction.CallByName(Object,String,CallType,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "在对象上执行的方法或设置或对象上返回一个属性。"
  remarks: "`CallByName`函数用于在运行时获取的属性、 设置属性，或调用方法。"
  example:
  - "In the following example, the first line uses `CallByName` to set the `Text` property of a text box, the second line retrieves the value of the `Text` property, and the third line invokes the `Move` method to move the text box.  \n  \n [!code-vb[VbVbalrFunctions#99](~/add/codesnippet/visualbasic/4d9384f0-535e-442c-920a-_1.vb)]  \n  \n [!code-vb[VbVbalrFunctions#20](~/add/codesnippet/visualbasic/4d9384f0-535e-442c-920a-_2.vb)]  \n  \n The next example uses the `CallByName` function to invoke the `Add` and `Item` methods of a collection object.  \n  \n [!code-vb[VbVbalrFunctions#21](~/add/codesnippet/visualbasic/4d9384f0-535e-442c-920a-_3.vb)]"
  syntax:
    content: public static object CallByName (object ObjectRef, string ProcName, Microsoft.VisualBasic.CallType UseCallType, object[] Args);
    parameters:
    - id: ObjectRef
      type: System.Object
      description: "必需。 <xref uid=&quot;langword_csharp_Object&quot; name=&quot;Object&quot; href=&quot;&quot;></xref>. 指向公开的属性或方法的对象的指针。"
    - id: ProcName
      type: System.String
      description: "必需。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>. 包含的属性或方法的对象的名称的字符串表达式。"
    - id: UseCallType
      type: Microsoft.VisualBasic.CallType
      description: "必需。 类型的枚举成员<xref href=&quot;Microsoft.VisualBasic.CallType&quot;></xref>表示的过程调用的类型。 The value of <xref uid=&quot;langword_csharp_CallType&quot; name=&quot;CallType&quot; href=&quot;&quot;></xref> can be <xref uid=&quot;langword_csharp_Method&quot; name=&quot;Method&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Get&quot; name=&quot;Get&quot; href=&quot;&quot;></xref>, or <xref uid=&quot;langword_csharp_Set&quot; name=&quot;Set&quot; href=&quot;&quot;></xref>."
    - id: Args
      type: System.Object[]
      description: "可选。 <xref uid=&quot;langword_csharp_ParamArray&quot; name=&quot;ParamArray&quot; href=&quot;&quot;></xref>. 包含要传递到的属性或方法调用的自变量的参数数组。"
    return:
      type: System.Object
      description: "在对象上执行的方法或设置或对象上返回一个属性。"
  overload: Microsoft.VisualBasic.Interaction.CallByName*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Invalid <code>UseCallType</code> value; must be <xref uid=&quot;langword_csharp_Method&quot; name=&quot;Method&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Get&quot; name=&quot;Get&quot; href=&quot;&quot;></xref>, or <xref uid=&quot;langword_csharp_Set&quot; name=&quot;Set&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])
  id: Choose(System.Double,System.Object[])
  parent: Microsoft.VisualBasic.Interaction
  langs:
  - csharp
  name: Choose(Double,Object[])
  nameWithType: Interaction.Choose(Double,Object[])
  fullName: Microsoft.VisualBasic.Interaction.Choose(Double,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "选择并从自变量列表中返回一个值。"
  remarks: "`Choose`函数将返回列表中传递的成员`Choice()`、 基于值的`Index`。 选择列表的第一个成员时`Index`为 1。 选择列表的最后一个成员时`Index`是`UBound`(`Choice()`)。 如果`Index`超出这些限制，`Choose`返回`Nothing`。       如果`Index`不是整数，它正在评估之前四舍五入为最接近的整数。       你可以使用`Choose`以查找可能的匹配项的列表中的值。      1> [!NOTE]&1;> 自变量列表中的表达式可以包括函数调用。 作为准备调用的自变量列表的一部分`Choose`，Visual Basic 编译器在每个表达式中调用每个函数。 这意味着您不能依赖于特定函数，如果通过选择不同的表达式不调用`Index`。"
  example:
  - "This example uses the `Choose` function to display a name in response to an index passed into the procedure in the `Ind` parameter.  \n  \n [!code-vb[VbVbalrFunctions#22](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._248_1.vb)]"
  syntax:
    content: public static object Choose (double Index, object[] Choice);
    parameters:
    - id: Index
      type: System.Double
      description: "必需。 <xref uid=&quot;langword_csharp_Double&quot; name=&quot;Double&quot; href=&quot;&quot;></xref>. 传入的结果值介于 1 和的元素数之间的数值表达式`Choice`自变量。"
    - id: Choice
      type: System.Object[]
      description: "必需。 <xref uid=&quot;langword_csharp_Object&quot; name=&quot;Object&quot; href=&quot;&quot;></xref>参数数组。 你可以提供单个变量或表达式计算结果为<xref uid=&quot;langword_csharp_Object&quot; name=&quot;Object&quot; href=&quot;&quot;></xref>数据类型，列表的<xref uid=&quot;langword_csharp_Object&quot; name=&quot;Object&quot; href=&quot;&quot;></xref>变量或表达式分隔用逗号，或指向的一维数组的<xref uid=&quot;langword_csharp_Object&quot; name=&quot;Object&quot; href=&quot;&quot;></xref>元素。"
    return:
      type: System.Object
      description: "选择并从自变量列表中返回一个值。"
  overload: Microsoft.VisualBasic.Interaction.Choose*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.Interaction.Command
  id: Command
  parent: Microsoft.VisualBasic.Interaction
  langs:
  - csharp
  name: Command()
  nameWithType: Interaction.Command()
  fullName: Microsoft.VisualBasic.Interaction.Command()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "返回用来启动 Visual Basic 或可执行程序的命令行的参数部分使用 Visual Basic 开发。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能提供更高的工作效率和性能比<xref uid=&quot;langword_csharp_Command &quot; name=&quot;Command &quot; href=&quot;&quot;></xref>函数。 有关详细信息，请参阅<xref:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs*>。</xref:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs*>"
  remarks: "返回自变量后，你可以搜索常用分隔符，例如空格、 向前或向后斜杠、 连字符或引号引起来，拆分或搜索单个参数的字符串。       为应用程序使用 Visual Basic 开发和编译为.exe 文件，`Command`函数返回出现在命令行，在此窗体应用程序的名称之后的任何自变量︰ `MyApp(cmdlineargs)`。"
  example:
  - "This example uses the `Command` function to return the command-line arguments in an object that contains an array.  \n  \n [!code-vb[VbVbalrCatRef#58](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._185_1.vb)]"
  syntax:
    content: public static string Command ();
    parameters: []
    return:
      type: System.String
      description: "返回用来启动 Visual Basic 或可执行程序的命令行的参数部分使用 Visual Basic 开发。       <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能提供更高的工作效率和性能比<xref uid=&quot;langword_csharp_Command &quot; name=&quot;Command &quot; href=&quot;&quot;></xref>函数。 有关详细信息，请参阅<xref:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs*>。</xref:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs*>"
  overload: Microsoft.VisualBasic.Interaction.Command*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.Interaction.CreateObject(System.String,System.String)
  id: CreateObject(System.String,System.String)
  parent: Microsoft.VisualBasic.Interaction
  langs:
  - csharp
  name: CreateObject(String,String)
  nameWithType: Interaction.CreateObject(String,String)
  fullName: Microsoft.VisualBasic.Interaction.CreateObject(String,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "创建并返回对 COM 对象的引用。 <xref uid=&quot;langword_csharp_CreateObject&quot; name=&quot;CreateObject&quot; href=&quot;&quot;></xref>不能用于在 Visual Basic 中创建的类的实例，除非这些类显式公开为 COM 组件。"
  remarks: "To create an instance of a COM component, assign the object returned by `CreateObject` to an object variable:  \n  \n```vb#  \nSub CreateADODB()  \n   Dim adoApp As Object  \n   adoApp = CreateObject(\"ADODB.Connection\")  \nEnd Sub  \n```  \n  \n The type of object variable you use to store the returned object can affect your application's performance. Declaring an object variable with the `As Object` clause creates a variable that can contain a reference to any type of object. However, access to the object through that variable is *late-bound*, that is, the binding occurs when your program runs. There are many reasons you should avoid late binding, including slower application performance.  \n  \n You can create an object variable that results in early binding—that is, binding when the program is compiled. To do so, add a reference to the type library for your object from the **COM** tab of the **Add Reference** dialog box on the **Project** menu. Then declare the object variable of the specific type of your object. In most cases, it is more efficient to use the `Dim` statement and a primary interop assembly to create objects than it is to use the `CreateObject` function.  \n  \n## Interacting with Unmanaged Code  \n Another issue is that COM objects use unmanaged code — code without the benefit of the common language runtime. There is a fair degree of complexity involved in mixing the managed code of Visual Basic with unmanaged code from COM. When you add a reference to a COM object, Visual Basic searches for a primary interop assembly (PIA) for that library; if it finds one, then it uses it. If it does not find a PIA, then it creates an interoperability assembly that contains local interoperability classes for each class in the COM library. For more information, see [COM Interoperability in .NET Framework Applications](~/add/includes/ajax-current-ext-md.md).  \n  \n You should generally use strongly bound objects and primary interop assemblies whenever possible. The examples below use the `CreateObject` function with Microsoft Office objects for demonstration purposes only. However, these objects are easier to use and more reliable when used with the appropriate primary interop assembly.  \n  \n## Creating an Object on a Remote Computer  \n You can create an object on a remote networked computer by passing the name of the computer to the `ServerName` argument of the `CreateObject` function. That name is the same as the Machine Name portion of a share name: for a share named \"\\\\\\MyServer\\Public,\" `ServerName` is \"MyServer.\"  \n  \n> [!NOTE]\n>  Refer to COM documentation (see Microsoft Developer Network) for additional information on making an application accessible on a remote networked computer. You may need to add a registry key for your application.  \n  \n The following code returns the version number of an instance of Excel running on a remote computer named `MyServer`:  \n  \n```vb#  \nSub CreateRemoteExcelObj()  \n    Dim xlApp As Object  \n    ' Replace string \"\\\\MyServer\" with name of the remote computer.  \n    xlApp = CreateObject(\"Excel.Application\", \"\\\\MyServer\")  \n    MsgBox(xlApp.Version)  \nEnd Sub  \n```  \n  \n If the remote server name is incorrect, or if it is unavailable, a run-time error occurs.  \n  \n> [!NOTE]\n>  Use `CreateObject` when there is no current instance of the object. If an instance of the object is already running, a new instance is started, and an object of the specified type is created. To use the current instance, or to start the application and have it load a file, use the `GetObject` function. If an object has registered itself as a single-instance object, only one instance of the object is created, no matter how many times `CreateObject` is executed.  \n  \n## Creating Framework Objects  \n You can use the `CreateObject` function only to create a COM object. While there is no exact equivalent mechanism for creating a .NET Framework object, the <xref:System.Activator> in the <xref:System> namespace contains methods to create local or remote objects. In particular, the <xref:System.Activator.CreateInstance%2A> method or the <xref:System.Activator.CreateInstanceFrom%2A> method might be useful.  \n  \n> [!IMPORTANT]\n>  The `CreateObject` function requires unmanaged code permission, which might affect its execution in partial-trust situations. For more information, see <xref:System.Security.Permissions.SecurityPermission> and [Code Access Permissions](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)."
  example:
  - "The following example uses the `CreateObject` function to create a Microsoft Excel worksheet and saves the worksheet to a file. To use this example, Excel must be installed on the computer where this program runs. Also, you must add a reference to the type library from the **COM** tab of the **Add Reference** dialog box on the **Project** menu. The name of the type library varies depending on the version of Excel installed on your computer. For example, the type library for Microsoft Excel 2002 is named **Microsoft Excel 10.0 Object Library**.  \n  \n [!code-vb[VbVbalrExcelObject#1](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._59_1.vb)]"
  syntax:
    content: public static object CreateObject (string ProgId, string ServerName = "");
    parameters:
    - id: ProgId
      type: System.String
      description: "必需。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>. 要创建对象的程序 ID。"
    - id: ServerName
      type: System.String
      description: "可选。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>. 将在其中创建对象网络服务器的名称。 如果`ServerName`为空字符串 (&quot;&quot;)，则使用本地计算机。"
    return:
      type: System.Object
      description: "创建并返回对 COM 对象的引用。 <xref uid=&quot;langword_csharp_CreateObject&quot; name=&quot;CreateObject&quot; href=&quot;&quot;></xref>不能用于在 Visual Basic 中创建的类的实例，除非这些类显式公开为 COM 组件。"
  overload: Microsoft.VisualBasic.Interaction.CreateObject*
  exceptions:
  - type: System.Exception
    commentId: T:System.Exception
    description: "服务器不可用"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "不存在指定类型的对象"
  platform:
  - net462
- uid: Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)
  id: DeleteSetting(System.String,System.String,System.String)
  parent: Microsoft.VisualBasic.Interaction
  langs:
  - csharp
  name: DeleteSetting(String,String,String)
  nameWithType: Interaction.DeleteSetting(String,String,String)
  fullName: Microsoft.VisualBasic.Interaction.DeleteSetting(String,String,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "从 Windows 注册表中的应用程序的项中删除节或键设置。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>在比注册表操作方面可为你提供更高的工作效率和性能<xref uid=&quot;langword_csharp_DeleteSetting &quot; name=&quot;DeleteSetting &quot; href=&quot;&quot;></xref>函数。 有关详细信息，请参阅<xref:Microsoft.VisualBasic.Devices.ServerComputer.Registry*>。</xref:Microsoft.VisualBasic.Devices.ServerComputer.Registry*>"
  remarks: "If all arguments are provided, the specified setting is deleted. A run-time error occurs if you attempt to use `DeleteSetting` on a nonexistent section or key setting.  \n  \n `DeleteSetting` requires that a user be logged on since it operates under the `HKEY_LOCAL_USER` registry key, which is not active until a user logs on interactively.  \n  \n Registry settings that are to be accessed from a non-interactive process (such as Mtx.exe) should be stored under either the `HKEY_LOCAL_MACHINE\\Software\\` or the `HKEY_USER\\DEFAULT\\Software` registry keys."
  example:
  - "The following example first uses the `SaveSetting` procedure to make entries in the Windows registry for the `MyApp` application, and then uses the `DeleteSetting` function to remove them. Because no `Key` argument is specified, the whole `Startup` section is deleted, including the section name and all of its keys.  \n  \n [!code-vb[VbVbalrCatRef#45](~/add/codesnippet/visualbasic/e195f0a5-815a-4af5-b672-_1.vb)]"
  syntax:
    content: public static void DeleteSetting (string AppName, string Section = null, string Key = null);
    parameters:
    - id: AppName
      type: System.String
      description: "必需。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>包含应用程序或节或键设置应用到的项目的名称的表达式。"
    - id: Section
      type: System.String
      description: "必需。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>包含要从中删除的项设置的节的名称的表达式。 如果仅`AppName`和`Section`提供所有相关的密钥设置以及删除指定的节。"
    - id: Key
      type: System.String
      description: "可选。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>包含要删除的项设置的名称的表达式。"
  overload: Microsoft.VisualBasic.Interaction.DeleteSetting*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "用户未登录。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.Interaction.Environ(System.Int32)
  id: Environ(System.Int32)
  parent: Microsoft.VisualBasic.Interaction
  langs:
  - csharp
  name: Environ(Int32)
  nameWithType: Interaction.Environ(Int32)
  fullName: Microsoft.VisualBasic.Interaction.Environ(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "返回与操作系统环境变量关联的字符串。"
  remarks: "如果`Expression`包含一个字符串，<xref:Microsoft.VisualBasic.Interaction.Environ%2A>函数返回分配给指定的环境字符串的文本-即，后面等号 （=） 该环境变量的环境字符串表中的文本。</xref:Microsoft.VisualBasic.Interaction.Environ%2A> 如果中的字符串`Expression`找不到在环境字符串表中，一个零长度字符串 (&quot;&quot;) 返回。       如果`Expression`包含一个整数，占用环境字符串表中的数字位置返回的字符串。 在这种情况下，<xref:Microsoft.VisualBasic.Interaction.Environ%2A>返回所有文本，包括环境变量的名称。</xref:Microsoft.VisualBasic.Interaction.Environ%2A> 如果在指定的位置中没有任何环境字符串<xref:Microsoft.VisualBasic.Interaction.Environ%2A>返回一个零长度字符串。</xref:Microsoft.VisualBasic.Interaction.Environ%2A>      1> [!IMPORTANT]&1;><xref:Microsoft.VisualBasic.Interaction.Environ%2A>函数需要环境权限，这可能会影响在部分信任情况下其执行。</xref:Microsoft.VisualBasic.Interaction.Environ%2A> 有关详细信息，请参阅<xref:System.Security.Permissions.SecurityPermission>和[代码访问权限](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)。</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the <xref:Microsoft.VisualBasic.Interaction.Environ%2A> function to supply the entry number and length of the `PATH` statement from the environment-string table.  \n  \n [!code-vb[VbVbalrCatRef#28](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._74_1.vb)]"
  syntax:
    content: public static string Environ (int Expression);
    parameters:
    - id: Expression
      type: System.Int32
      description: "必需。 计算为包含环境变量或对应于环境字符串表中的一个环境字符串的数字顺序的整数值的名称的字符串的表达式。"
    return:
      type: System.String
      description: "返回与操作系统环境变量关联的字符串。"
  overload: Microsoft.VisualBasic.Interaction.Environ*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Expression</code>找不到。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.Interaction.Environ(System.String)
  id: Environ(System.String)
  parent: Microsoft.VisualBasic.Interaction
  langs:
  - csharp
  name: Environ(String)
  nameWithType: Interaction.Environ(String)
  fullName: Microsoft.VisualBasic.Interaction.Environ(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "返回与操作系统环境变量关联的字符串。"
  remarks: "如果`Expression`包含一个字符串，那么函数将返回分配给指定的环境字符串的文本 Environ-即，后面等号 （=） 该环境变量的环境字符串表中的文本。 如果中的字符串`Expression`找不到在环境字符串表中，一个零长度字符串 (&quot;&quot;) 返回。       如果`Expression`包含一个整数，占用环境字符串表中的数字位置返回的字符串。 在这种情况下，那么 Environ 将返回所有文本，包括环境变量的名称。 如果在指定位置中没有任何环境字符串，那么 Environ 将返回一个零长度字符串。      1> [!IMPORTANT]&1;> Environ 函数需要环境权限，这可能会影响在部分信任情况下其执行。 有关详细信息，请参阅<xref:System.Security.Permissions.SecurityPermission>和[代码访问权限](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)。</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the Environ function to supply the entry number and length of the `PATH` statement from the environment-string table.  \n  \n [!code-vb[VbVbalrCatRef#28](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._35_1.vb)]"
  syntax:
    content: public static string Environ (string Expression);
    parameters:
    - id: Expression
      type: System.String
      description: "必需。 计算为包含环境变量或对应于环境字符串表中的一个环境字符串的数字顺序的整数值的名称的字符串的表达式。"
    return:
      type: System.String
      description: "返回与操作系统环境变量关联的字符串。"
  overload: Microsoft.VisualBasic.Interaction.Environ*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Expression</code>找不到。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)
  id: GetAllSettings(System.String,System.String)
  parent: Microsoft.VisualBasic.Interaction
  langs:
  - csharp
  name: GetAllSettings(String,String)
  nameWithType: Interaction.GetAllSettings(String,String)
  fullName: Microsoft.VisualBasic.Interaction.GetAllSettings(String,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "返回的密钥设置及其各自的值列表 (最初创建时<xref uid=&quot;langword_csharp_SaveSetting&quot; name=&quot;SaveSetting&quot; href=&quot;&quot;> </xref>) 从 Windows 注册表中的应用程序的条目。 使用<xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;></xref>在比注册表操作方面可为你提供更高的工作效率和性能<xref uid=&quot;langword_csharp_GetAllSettings&quot; name=&quot;GetAllSettings&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref:Microsoft.VisualBasic.Devices.ServerComputer.Registry*>。</xref:Microsoft.VisualBasic.Devices.ServerComputer.Registry*>"
  remarks: "`GetAllSettings` returns an uninitialized `Object` if either `AppName` or `Section` does not exist.  \n  \n Because it operates under the `HKEY_LOCAL_USER` registry key, which is not active until a user logs on interactively, `GetAllSettings` requires that a user be logged on.  \n  \n Registry settings that are to be accessed from a non-interactive process (such as Mtx.exe) should be stored under either the `HKEY_LOCAL_MACHINE\\Software\\` or the `HKEY_USER\\DEFAULT\\Software` registry keys."
  example:
  - "This example first uses the `SaveSetting` function to make entries in the Windows registry for the application specified as `AppName`, then uses the `GetAllSettings` function to display the settings. Note that application names and `Section` names cannot be retrieved with `GetAllSettings`. Finally, the `DeleteSetting` function removes the application's entries.  \n  \n [!code-vb[VbVbalrCatRef#68](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._40_1.vb)]"
  syntax:
    content: public static string[,] GetAllSettings (string AppName, string Section);
    parameters:
    - id: AppName
      type: System.String
      description: "必需。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>包含应用程序或所请求的密钥设置的项目的名称的表达式。"
    - id: Section
      type: System.String
      description: "必需。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>包含要请求其注册表项设置的节的名称的表达式。 <xref uid=&quot;langword_csharp_GetAllSettings&quot; name=&quot;GetAllSettings&quot; href=&quot;&quot;></xref>返回一个包含字符串的二维数组对象。 这些字符串包含指定的节，加上其对应的值中的所有密钥设置。"
    return:
      type: System.String[,]
      description: "返回的密钥设置及其各自的值列表 (最初创建时<xref uid=&quot;langword_csharp_SaveSetting&quot; name=&quot;SaveSetting&quot; href=&quot;&quot;> </xref>) 从 Windows 注册表中的应用程序的条目。       使用<xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;></xref>在比注册表操作方面可为你提供更高的工作效率和性能<xref uid=&quot;langword_csharp_GetAllSettings&quot; name=&quot;GetAllSettings&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref:Microsoft.VisualBasic.Devices.ServerComputer.Registry*>。</xref:Microsoft.VisualBasic.Devices.ServerComputer.Registry*>"
  overload: Microsoft.VisualBasic.Interaction.GetAllSettings*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "用户未登录。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.Interaction.GetObject(System.String,System.String)
  id: GetObject(System.String,System.String)
  parent: Microsoft.VisualBasic.Interaction
  langs:
  - csharp
  name: GetObject(String,String)
  nameWithType: Interaction.GetObject(String,String)
  fullName: Microsoft.VisualBasic.Interaction.GetObject(String,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "返回对 COM 组件所提供的对象的引用。"
  remarks: "Use the `GetObject` function to load an instance of a COM component from a file. The following example illustrates this.  \n  \n```vb#  \nDim CADObject As Object  \nCADObject = GetObject(\"C:\\CAD\\schema.cad\")  \n```  \n  \n When this code runs, the application associated with the specified `PathName` is started and the object in the specified file is activated.  \n  \n## Default Cases  \n If `PathName` is a zero-length string (`\"\"`), `GetObject` returns a new object instance of the specified class type. If the `PathName` argument is omitted, `GetObject` returns a currently active object of the class type specified in `Class`. If no object of the specified type exists, an error occurs.  \n  \n## Accessing a Subobject  \n Some applications allow you to activate a subobject associated with a file. To do this, add an exclamation point (`!`) to the end of the file name and follow it with a string that identifies the part of the file you want to activate. For information on how to create this string, see the documentation for the application that created the object.  \n  \n For example, in a drawing application you might have multiple layers to a drawing stored in a file. You could use the following code to activate a layer within a drawing called `schema.cad`.  \n  \n```vb#  \nlayerObject = GetObject(\"C:\\CAD\\schema.cad!Layer3\")  \n```  \n  \n## Specifying a Class  \n If you do not specify the object's `Class`, Automation determines the application to start and the object to activate, based on the file name you provide. Some files, however, can support more than one class of object. For example, a drawing might support three different types of objects: an `Application` object, a `Drawing` object, and a `Toolbar` object, all of which are part of the same file. To specify which object in a file you want to activate, use the optional `Class` argument. The following example illustrates this.  \n  \n```vb#  \nDim drawObj As Object  \ndrawObj = GetObject(\"C:\\Drawings\\sample.drw\", \"Figment.Drawing\")  \n```  \n  \n In the preceding example, `Figment` is the name of a drawing application and `Drawing` is one of the object types it supports.  \n  \n## Using the Object  \n Once an object is activated, you refer to it in code using the object variable you declared. In the preceding example, you access properties and methods of the new object using the object variable `drawObj`. The following example illustrates this.  \n  \n```vb#  \ndrawObj.Line(9, 90)  \ndrawObj.InsertText(9, 100, \"Hello, world.\")  \ndrawObj.SaveAs(\"C:\\Drawings\\sample.drw\")  \n```  \n  \n> [!NOTE]\n>  Use the `GetObject` function when there is a current instance of the object or if you want to create the object with a file loaded. If there is no current instance, and you do not want the object started with a file loaded, use the <xref:Microsoft.VisualBasic.Interaction.CreateObject%2A> function.  \n>   \n>  If an object has registered itself as an ActiveX single-instance object, only one instance of the object is created, no matter how many times `CreateObject` is called. With a single-instance object, `GetObject` always returns the same instance when called with the zero-length string (`\"\"`) syntax, and it causes an error if the `PathName` argument is omitted. You cannot use `GetObject` to obtain a reference to a class created with Visual Basic.  \n  \n> [!IMPORTANT]\n>  The `GetObject` function requires unmanaged code permission, which might affect its execution in partial-trust situations. For more information, see <xref:System.Security.Permissions.SecurityPermission> and [Code Access Permissions](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)."
  example:
  - "The following example uses the `GetObject` function to obtain a reference to a specific Microsoft Excel worksheet (`excelObj`). It uses the worksheet's `Application` property to make Excel visible, to close it, and to perform other actions. Using two API calls, the `detectExcel` procedure looks for Excel, and if it is running, enters it in the Running Object table. The first call to `GetObject` causes an error if Excel is not already running, which in this example causes the `excelWasNotRunning` flag to be set to `True`. The second call to `GetObject` specifies a file to open. If Excel is not already running, the second call starts it and returns a reference to the worksheet represented by the specified file, `test.xls`. The file must exist in the specified location; otherwise, Visual Basic throws a <xref:System.IO.FileNotFoundException>. Next, the example code makes both Excel and the window containing the specified worksheet visible.  \n  \n This example requires `Option Strict Off` because it uses late binding, where objects are assigned to variables of type `Object`. You can specify `Option Strict On` and declare objects of specific object types if you add a reference to the Excel type library from the **COM** tab of the **Add Reference** dialog box of the **Project** menu in Visual Studio.  \n  \n [!code-vb[VbVbalrExcelObject#2](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._196_1.vb)]  \n  \n [!code-vb[VbVbalrExcelObject#4](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._196_2.vb)]  \n  \n [!code-vb[VbVbalrExcelObject#5](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._196_3.vb)]  \n  \n When you call the `getExcel` function, a check is made to see if Excel is already running. If it is not, then an instance is created.  \n  \n> [!IMPORTANT]\n>  For simplicity, the preceding example assumes that any window called `XLMAIN` belongs to an instance of Microsoft Excel. If another object, possibly launched by illicit tampering, created a window with that name, it would receive all the messages you intended for Excel. In an application to be used for production, you should include some more rigorous testing to verify that `XLMAIN` really belongs to Excel."
  syntax:
    content: public static object GetObject (string PathName = null, string Class = null);
    parameters:
    - id: PathName
      type: System.String
      description: "可选。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>. 完整路径和包含要检索的对象的文件的名称。 如果`PathName`省略，`Class`是必需的。"
    - id: Class
      type: System.String
      description: "如果存在`PathName`未提供。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>. 表示对象的类的字符串。 `Class`自变量具有以下语法和部件︰ `appname` `.` `objecttype` [1 |&1;] 参数 [1 |&2;] 说明 [2 |&1;] `appname` [2 |&2;] 所需。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>. 提供对象的应用程序名称。       [3 |&1;]`objecttype` [3 |&2;] 所需。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>. 若要创建的类型或类的对象。"
    return:
      type: System.Object
      description: "返回对 COM 组件所提供的对象的引用。"
  overload: Microsoft.VisualBasic.Interaction.GetObject*
  exceptions:
  - type: System.Exception
    commentId: T:System.Exception
    description: "不存在的对象指定的类类型。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "用指定的路径和文件名没有任何对象存在。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)
  id: GetSetting(System.String,System.String,System.String,System.String)
  parent: Microsoft.VisualBasic.Interaction
  langs:
  - csharp
  name: GetSetting(String,String,String,String)
  nameWithType: Interaction.GetSetting(String,String,String,String)
  fullName: Microsoft.VisualBasic.Interaction.GetSetting(String,String,String,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "从 Windows 注册表中的应用程序的条目返回一个项设置值。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>在比注册表操作方面可为你提供更高的工作效率和性能<xref uid=&quot;langword_csharp_GetAllSettings&quot; name=&quot;GetAllSettings&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref:Microsoft.VisualBasic.Devices.ServerComputer.Registry*>。</xref:Microsoft.VisualBasic.Devices.ServerComputer.Registry*>"
  remarks: "If any of the items named in the `GetSetting` arguments do not exist, `GetSetting` returns a value of `Default`.  \n  \n Because it operates under the `HKEY_LOCAL_USER` registry key, which is not active until a user logs on interactively, `GetSetting` requires that a user be logged on.  \n  \n Registry settings that are to be accessed from a non-interactive process (such as Mtx.exe) should be stored under either the `HKEY_LOCAL_MACHINE\\Software\\` or the `HKEY_USER\\DEFAULT\\Software` registry keys.  \n  \n `GetSetting` requires `Read`<xref:System.Security.Permissions.RegistryPermission> ."
  example:
  - "This example first uses the `SaveSetting` function to make entries in the Windows registry for the application specified as `AppName`, and then uses the `GetSetting` function to display one of the settings. Because the `Default` argument is specified, some value is guaranteed to be returned. Notice that `Section` names cannot be retrieved with `GetSetting`. Finally, the `DeleteSetting` function removes all the application's entries.  \n  \n [!code-vb[VbVbalrCatRef#61](~/add/codesnippet/visualbasic/1601a1b5-4317-44fc-9f01-_1.vb)]"
  syntax:
    content: public static string GetSetting (string AppName, string Section, string Key, string Default = "");
    parameters:
    - id: AppName
      type: System.String
      description: "必需。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>包含应用程序或其键设置为请求的项目的名称的表达式。"
    - id: Section
      type: System.String
      description: "必需。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>包含在其中找到的项设置的节的名称的表达式。"
    - id: Key
      type: System.String
      description: "必需。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>包含要返回的密钥设置的名称的表达式。"
    - id: Default
      type: System.String
      description: "可选。 包含要返回如果设置任何值的值表达式`Key`设置。 如果省略，`Default`被假定为零长度字符串 (&quot;&quot;)。"
    return:
      type: System.String
      description: "从 Windows 注册表中的应用程序的条目返回一个项设置值。       <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>在比注册表操作方面可为你提供更高的工作效率和性能<xref uid=&quot;langword_csharp_GetAllSettings&quot; name=&quot;GetAllSettings&quot; href=&quot;&quot;> </xref>。"
  overload: Microsoft.VisualBasic.Interaction.GetSetting*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个自变量不是<xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>表达式或用户未登录。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)
  id: IIf(System.Boolean,System.Object,System.Object)
  parent: Microsoft.VisualBasic.Interaction
  langs:
  - csharp
  name: IIf(Boolean,Object,Object)
  nameWithType: Interaction.IIf(Boolean,Object,Object)
  fullName: Microsoft.VisualBasic.Interaction.IIf(Boolean,Object,Object)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "返回两个对象，具体取决于表达式求值之一。"
  remarks: '`IIf`函数提供了三元存在对应[条件运算符:？:](~/add/includes/ajax-current-ext-md.md) Visual c + +。'
  example:
  - "This example uses the `IIf` function to evaluate the `testMe` parameter of the `checkIt` procedure and returns the word \"Large\" if the amount is greater than 1000; otherwise, it returns the word \"Small\".  \n  \n [!code-vb[VbVbalrFunctions#33](~/add/codesnippet/visualbasic/296aac5d-5997-4225-8ac0-_1.vb)]  \n  \n Note that if `Option Strict` is `On`, you must use the `CStr` keyword to explicitly convert the return from `Object` to `String`."
  syntax:
    content: public static object IIf (bool Expression, object TruePart, object FalsePart);
    parameters:
    - id: Expression
      type: System.Boolean
      description: "必需。 <xref uid=&quot;langword_csharp_Boolean&quot; name=&quot;Boolean&quot; href=&quot;&quot;></xref>. 你想要评估表达式。"
    - id: TruePart
      type: System.Object
      description: "必需。 <xref uid=&quot;langword_csharp_Object&quot; name=&quot;Object&quot; href=&quot;&quot;></xref>. 时返回`Expression`计算结果为<xref uid=&quot;langword_csharp_True&quot; name=&quot;True&quot; href=&quot;&quot;> </xref>。"
    - id: FalsePart
      type: System.Object
      description: "必需。 <xref uid=&quot;langword_csharp_Object&quot; name=&quot;Object&quot; href=&quot;&quot;></xref>. 时返回`Expression`计算结果为<xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.Object
      description: "返回两个对象，具体取决于表达式求值之一。"
  overload: Microsoft.VisualBasic.Interaction.IIf*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.Interaction.InputBox(System.String,System.String,System.String,System.Int32,System.Int32)
  id: InputBox(System.String,System.String,System.String,System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.Interaction
  langs:
  - csharp
  name: InputBox(String,String,String,Int32,Int32)
  nameWithType: Interaction.InputBox(String,String,String,Int32,Int32)
  fullName: Microsoft.VisualBasic.Interaction.InputBox(String,String,String,Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "在对话框中显示一个提示，等待用户输入文本，或单击一个按钮，然后返回包含文本框的内容的字符串。"
  remarks: "如果用户单击**取消**，则返回一个零长度字符串。       若要指定多个第一个参数，必须使用`InputBox`在表达式中的函数。 如果省略任何位置的自变量，你必须保留相应的逗号分隔符。      1> [!NOTE]&1;>`InputBox`函数需要`UIPermission`在<xref:System.Security.Permissions.UIPermissionWindow>级别，这可能会影响在部分信任情况下其执行。</xref:System.Security.Permissions.UIPermissionWindow> 有关详细信息，请参阅和<xref:System.Security.Permissions.UIPermission>.</xref:System.Security.Permissions.UIPermission>"
  example:
  - "This example shows various ways to use the `InputBox` function to prompt the user to enter a value. If the x and y positions are omitted, the dialog box is automatically centered for the respective axes. The variable `MyValue` contains the value entered by the user if the user clicks OK or presses the ENTER key.  \n  \n [!code-vb[VbVbalrCatRef#67](~/add/codesnippet/visualbasic/e8c4ff4e-3901-4354-99c7-_1.vb)]"
  syntax:
    content: public static string InputBox (string Prompt, string Title = "", string DefaultResponse = "", int XPos = -1, int YPos = -1);
    parameters:
    - id: Prompt
      type: System.String
      description: "所需<xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>表达式显示为对话框中的消息。 最大长度`Prompt`大约为 1024年个字符，具体取决于使用的字符的宽度。 如果`Prompt`包含的多个行，你可以单独的行使用回车符 (<xref uid=&quot;langword_csharp_Chr(&quot; name=&quot;Chr(&quot; href=&quot;&quot;></xref>13<xref uid=&quot;langword_csharp_)&quot; name=&quot;)&quot; href=&quot;&quot;></xref>)，以换行符 (<xref uid=&quot;langword_csharp_Chr(&quot; name=&quot;Chr(&quot; href=&quot;&quot;></xref>10<xref uid=&quot;langword_csharp_)&quot; name=&quot;)&quot; href=&quot;&quot;></xref>)，或回车/换行组合 (<xref uid=&quot;langword_csharp_Chr(&quot; name=&quot;Chr(&quot; href=&quot;&quot;></xref>13<xref uid=&quot;langword_csharp_)&quot; name=&quot;)&quot; href=&quot;&quot;> </xref> &amp; <xref uid=&quot;langword_csharp_Chr(&quot; name=&quot;Chr(&quot; href=&quot;&quot;> </xref>10<xref uid=&quot;langword_csharp_)&quot; name=&quot;)&quot; href=&quot;&quot;></xref>) 之间的每一行。"
    - id: Title
      type: System.String
      description: "可选。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>对话框中的标题栏中显示的表达式。 如果省略`Title`，放在标题栏中的应用程序名称。"
    - id: DefaultResponse
      type: System.String
      description: "可选。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>显示在文本框中为默认响应如果提供任何其他输入的表达式。 如果省略`DefaultResponse`，显示的文本框为空。"
    - id: XPos
      type: System.Int32
      description: "可选。 指定以缇为单位，屏幕的对话框中从左边缘的左边缘的距离的数值表达式。 如果省略`XPos`，对话框中的水平居中位置。"
    - id: YPos
      type: System.Int32
      description: "可选。 指定以缇为单位，从屏幕顶部的对话框中的上边缘的距离的数值表达式。 如果省略`YPos`，对话框中定位垂直约三分之一的屏幕的方式。"
    return:
      type: System.String
      description: "在对话框中显示一个提示，等待用户输入文本，或单击一个按钮，然后返回包含文本框的内容的字符串。"
  overload: Microsoft.VisualBasic.Interaction.InputBox*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.Interaction.MsgBox(System.Object,Microsoft.VisualBasic.MsgBoxStyle,System.Object)
  id: MsgBox(System.Object,Microsoft.VisualBasic.MsgBoxStyle,System.Object)
  parent: Microsoft.VisualBasic.Interaction
  langs:
  - csharp
  name: MsgBox(Object,MsgBoxStyle,Object)
  nameWithType: Interaction.MsgBox(Object,MsgBoxStyle,Object)
  fullName: Microsoft.VisualBasic.Interaction.MsgBox(Object,MsgBoxStyle,Object)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "在对话框中显示一条消息，会等待用户单击按钮，然后返回一个整数，指示哪个用户单击的按钮。"
  remarks: "如果省略任何位置的自变量，你必须保留相应的逗号分隔符。       如果对话框显示**取消**按钮，则按 ESC 键具有相同的效果与单击**取消**如果对话框包含**帮助**按钮，在对话框中提供区分上下文的帮助。 但是，直到选择其他按钮之一，被不返回任何值。 在 Windows 窗体应用程序中，选择**帮助**按钮执行<xref:System.Windows.Forms.Control.HelpRequested>窗体的事件。</xref:System.Windows.Forms.Control.HelpRequested>      1> [!NOTE]&1;>`MsgBox`函数需要`UIPermission`在<xref:System.Security.Permissions.UIPermissionWindow>级别，这可能会影响在部分信任情况下其执行。</xref:System.Security.Permissions.UIPermissionWindow> 有关详细信息，请参阅<xref:System.Security.Permissions.UIPermission>。</xref:System.Security.Permissions.UIPermission>       `MsgBoxStyle`下表列出了枚举值。      ||||  |-|-|-|  |成员 |值 |说明 |  |`OKOnly`|0|仅显示确定按钮。 |  |`OKCancel`|1|显示确定和取消按钮。 |  |`AbortRetryIgnore`|2|显示中止、 重试，和忽略按钮。 |  |`YesNoCancel`|3|显示是、 否和取消按钮。 |  |`YesNo`|4|显示是和无按钮。 |  |`RetryCancel`|5|显示重试和取消按钮。 |  |`Critical`|16|显示关键消息图标。 |  |`Question`|32|显示警告查询图标。 |  |`Exclamation`|48|显示警告消息图标。 |  |`Information`|64|显示信息性消息图标。 |  |`DefaultButton1`|0|第一个按钮是默认值。 |  |`DefaultButton2`|256|第二个按钮为默认值。 |  |`DefaultButton3`|512|第三个按钮为默认值。 |  |`ApplicationModal`|0|应用程序是模式。 用户必须响应此消息框才能继续在当前应用程序中的工作。 |  |`SystemModal`|4096|系统为模式。 所有应用程序挂起，直到用户响应消息框。 |  |`MsgBoxSetForeground`|&65536; |指定消息框窗口中作为前台窗口。 |  |`MsgBoxRight`|&52428;8 |文本为右对齐。 |  |`MsgBoxRtlReading`|&10485;76 |指定文本应显示为右到左读取希伯来语和阿拉伯语系统上。 |      第一组值 (0 –&5;) 描述的数量和类型的对话框中显示的按钮。 第二个组 （16、 32、 48、 64） 描述图标样式。 第三个组 （0、 256、 512） 确定哪个按钮为默认值。 第四个组 （0，4096） 确定消息框的模式和第五个组指定消息框窗口为前台窗口时，以及对齐方式和文本的方向。 添加编号，以创建最终值时`Buttons`自变量，每个组中使用只有一个数。"
  example:
  - "This example uses the `MsgBox` function to display a critical-error message in a dialog box with Yes and No buttons. The No button is specified as the default response. This is done by combining the `MsgBox` constant values into one numeric expression. In this case, adding 4 (the Yes/No button combination) and 16 (the **Critical Message** window) and 256 (the second button as default button) gives a total of 276. The value returned by the `MsgBox` function depends on the button chosen by the user: Yes returns a value of 6; No returns a value of 7.  \n  \n [!code-vb[VbVbalrCatRef#20](~/add/codesnippet/visualbasic/b9e37542-f81a-4692-86e1-_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.MsgBoxResult MsgBox (object Prompt, Microsoft.VisualBasic.MsgBoxStyle Buttons = Microsoft.VisualBasic.MsgBoxStyle.ApplicationModal, object Title = null);
    parameters:
    - id: Prompt
      type: System.Object
      description: "必需。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>显示在对话框中作为消息的表达式。 最大长度`Prompt`大约为 1024年个字符，具体取决于使用的字符的宽度。 如果`Prompt`包含的多个行，你可以单独的行使用回车符 (<xref uid=&quot;langword_csharp_Chr(&quot; name=&quot;Chr(&quot; href=&quot;&quot;></xref>13<xref uid=&quot;langword_csharp_)&quot; name=&quot;)&quot; href=&quot;&quot;></xref>)，以换行符 (<xref uid=&quot;langword_csharp_Chr(&quot; name=&quot;Chr(&quot; href=&quot;&quot;></xref>10<xref uid=&quot;langword_csharp_)&quot; name=&quot;)&quot; href=&quot;&quot;></xref>)，或回车符/换行符组合 (<xref uid=&quot;langword_csharp_Chr(&quot; name=&quot;Chr(&quot; href=&quot;&quot;></xref>13<xref uid=&quot;langword_csharp_)&quot; name=&quot;)&quot; href=&quot;&quot;> </xref> &amp; <xref uid=&quot;langword_csharp_Chr(&quot; name=&quot;Chr(&quot; href=&quot;&quot;> </xref>10<xref uid=&quot;langword_csharp_)&quot; name=&quot;)&quot; href=&quot;&quot;></xref>) 之间的每一行。"
    - id: Buttons
      type: Microsoft.VisualBasic.MsgBoxStyle
      description: "可选。 指定要显示，要使用的默认按钮，标识和消息框的样式等的图标样式的数量和类型的按钮的值之和的数值表达式。 如果省略`Buttons`，默认值为&0;。"
    - id: Title
      type: System.Object
      description: "可选。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>对话框中的标题栏中显示的表达式。 如果省略`Title`，放在标题栏中的应用程序名称。"
    return:
      type: Microsoft.VisualBasic.MsgBoxResult
      description: "<table><tbody><tr><td> 常量       </td><td> 值       </td></tr><tr><td>           <xref uid=&quot;langword_csharp_OK&quot; name=&quot;OK&quot; href=&quot;&quot;></xref>         </td><td> 1       </td></tr><tr><td>           <xref uid=&quot;langword_csharp_Cancel&quot; name=&quot;Cancel&quot; href=&quot;&quot;></xref>         </td><td> 2       </td></tr><tr><td>           <xref uid=&quot;langword_csharp_Abort&quot; name=&quot;Abort&quot; href=&quot;&quot;></xref>         </td><td> 3       </td></tr><tr><td>           <xref uid=&quot;langword_csharp_Retry&quot; name=&quot;Retry&quot; href=&quot;&quot;></xref>         </td><td> 4       </td></tr><tr><td>           <xref uid=&quot;langword_csharp_Ignore&quot; name=&quot;Ignore&quot; href=&quot;&quot;></xref>         </td><td> 5       </td></tr><tr><td>           <xref uid=&quot;langword_csharp_Yes&quot; name=&quot;Yes&quot; href=&quot;&quot;></xref>         </td><td> 6       </td></tr><tr><td>           <xref uid=&quot;langword_csharp_No&quot; name=&quot;No&quot; href=&quot;&quot;></xref>         </td><td> 7       </td></tr></tbody></table>"
  overload: Microsoft.VisualBasic.Interaction.MsgBox*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Prompt</code>不是<xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>表达式，或<code>Title</code>无效。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "进程不在用户交互模式中运行。"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "一个或多个参数不是成员的<xref uid=&quot;langword_csharp_MsgBoxResult&quot; name=&quot;MsgBoxResult&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_MsgBoxStyle&quot; name=&quot;MsgBoxStyle&quot; href=&quot;&quot;></xref>枚举。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.Interaction.Partition(System.Int64,System.Int64,System.Int64,System.Int64)
  id: Partition(System.Int64,System.Int64,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.Interaction
  langs:
  - csharp
  name: Partition(Int64,Int64,Int64,Int64)
  nameWithType: Interaction.Partition(Int64,Int64,Int64,Int64)
  fullName: Microsoft.VisualBasic.Interaction.Partition(Int64,Int64,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "返回一个字符串，表示包含大量的计算的范围。"
  remarks: "`Partition`函数计算的一组数值范围，各包含由指定的值的数目`Interval`。 第一个范围开始`Start`，并在最后一个范围结束`Stop`。 `Partition`函数然后确定哪一个范围包含`Number`并返回一个描述该范围内的字符串。 范围表示为字符串中&quot;*较*:*值*&quot;，其中低范围的末尾 (*较*) 与高端分隔 (*值*) 以冒号 （:）。       如有必要，`Partition`函数将插入前的前导空格*较*和*值*，以便它们都具有相同数量的字符的值的字符串表示形式 (`Stop` + 1)。 这可确保︰ 如果你使用的输出`Partition`的多个值具有函数`Number`，将在任何后续排序操作过程正确处理结果的文本。       下表显示使用三组计算的范围某些示例字符串`Start`， `Stop`，和`Interval`。 &quot;第一个范围&quot;和&quot;最后一个范围&quot;列显示在给定的值时可能的最低和最高范围`Start`和`Stop`。 &quot;之前第一个范围&quot;和&quot;之后最后一个范围&quot;列显示返回的值的字符串`Number`小于`Start`和大于`Stop`分别。      ||||||||  |-|-|-|-|-|-|-|  |`Start`|`Stop`|`Interval`|第一个范围之前 |第一个范围 |最后一个范围 |最后一个范围之后 |  | 0 | 99 | 5 |&quot;:-1&quot;|&quot; 0: 4&quot;|&quot;95: 99&quot;|&quot;100:&quot;|  | 20 | 199 | 10 |&quot;: 19&quot;|&quot;20: 29&quot;|&quot;190:199&quot;|&quot;200:&quot;|  | 100 | 1010年 | 20 |&quot;: 99&quot;|&quot;100: 119&quot;|&quot;1000:1010&quot;|&quot;1011:&quot;|      在上表中，第三行显示结果时`Start`和`Stop`定义一组不能由均匀划分的数字`Interval`。 最后一个范围结束`Stop`，使其仅有 11 个字符，即使`Interval`为 20。       如果`Interval`为 1，范围是&quot;`Number`:`Number`&quot;，而不管`Start`和`Stop`自变量。 例如，如果`Number`是 267，`Stop`为 1000，和`Interval`为 1，`Partition`返回&quot;267: 267&quot;。       `Partition`构建数据库查询时，可以很有用。 你可以创建一个选择查询以显示多少订单出现在各种值的范围，例如，使用发票值从 1 到 1000、 1001年到 2000 中，依次类推。"
  example:
  - "The following example sets up a series of ranges for decades from 1950 through 2049. It locates the value of `year` within the appropriate range and returns a `String` value showing the range. If `year` has a value of 1984, for example, `Partition` returns \"1980:1989\".  \n  \n [!code-vb[VbVbalrFunctions#45](~/add/codesnippet/visualbasic/2056d306-036e-4f9b-954c-_1.vb)]"
  syntax:
    content: public static string Partition (long Number, long Start, long Stop, long Interval);
    parameters:
    - id: Number
      type: System.Int64
      description: "必需。 <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;></xref>. 要查找计算范围之一内的整数。"
    - id: Start
      type: System.Int64
      description: "必需。 <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;></xref>. 指示组的计算范围的开头的整数。 `Start`不能小于 0。"
    - id: Stop
      type: System.Int64
      description: "必需。 <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;></xref>. 指示组的计算范围的末尾的整数。 `Stop`不能小于或等于`Start`。"
    - id: Interval
      type: System.Int64
      description: "必需。 <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;></xref>. 之间的整数，指示每个范围的大小计算`Start`和`Stop`。 `Interval`不能小于 1。"
    return:
      type: System.String
      description: "返回一个字符串，表示包含大量的计算的范围。"
  overload: Microsoft.VisualBasic.Interaction.Partition*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Start</code>&lt; 0, <code>Stop</code> &lt;= <code>Start</code>, or <code>Interval</code> &lt; 1."
  platform:
  - net462
- uid: Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)
  id: SaveSetting(System.String,System.String,System.String,System.String)
  parent: Microsoft.VisualBasic.Interaction
  langs:
  - csharp
  name: SaveSetting(String,String,String,String)
  nameWithType: Interaction.SaveSetting(String,String,String,String)
  fullName: Microsoft.VisualBasic.Interaction.SaveSetting(String,String,String,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "保存或在 Windows 注册表中创建应用程序条目。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>在比注册表操作方面可为你提供更高的工作效率和性能<xref uid=&quot;langword_csharp_SaveSetting&quot; name=&quot;SaveSetting&quot; href=&quot;&quot;> </xref>。 有关详细信息，请参阅<xref:Microsoft.VisualBasic.Devices.ServerComputer.Registry*>。</xref:Microsoft.VisualBasic.Devices.ServerComputer.Registry*>"
  remarks: "The `SaveSetting` function adds the key to `HKEY_CURRENT_USER\\Software\\VB and VBA Program Settings`.  \n  \n If the key setting cannot be saved for any reason, an error occurs.  \n  \n `SaveSetting` requires that a user be logged on since it operates under the `HKEY_LOCAL_USER` registry key, which is not active until a user logs on interactively.  \n  \n Registry settings that are to be accessed from a non-interactive process (such as Mtx.exe) should be stored under either the `HKEY_LOCAL_MACHINE\\Software\\` or the `HKEY_USER\\DEFAULT\\Software` registry keys.  \n  \n `SaveSetting` requires `Write` and `Create`<xref:System.Security.Permissions.RegistryPermission> ."
  example:
  - "The following example first uses the `SaveSetting` function to make entries in the Windows registry for the `MyApp` application, and then uses the `DeleteSetting` function to remove them.  \n  \n [!code-vb[VbVbalrCatRef#56](~/add/codesnippet/visualbasic/771356b4-108a-4f31-9d7a-_1.vb)]"
  syntax:
    content: public static void SaveSetting (string AppName, string Section, string Key, string Setting);
    parameters:
    - id: AppName
      type: System.String
      description: "必需。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>包含应用程序或该设置将应用的项目的名称的表达式。"
    - id: Section
      type: System.String
      description: "必需。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>包含在其中保存的项设置的节的名称的表达式。"
    - id: Key
      type: System.String
      description: "必需。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>包含要保存的密钥设置的名称的表达式。"
    - id: Setting
      type: System.String
      description: "必需。 包含的值表达式`Key`设置。"
  overload: Microsoft.VisualBasic.Interaction.SaveSetting*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "无法创建注册表项，或用户未登录。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)
  id: Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)
  parent: Microsoft.VisualBasic.Interaction
  langs:
  - csharp
  name: Shell(String,AppWinStyle,Boolean,Int32)
  nameWithType: Interaction.Shell(String,AppWinStyle,Boolean,Int32)
  fullName: Microsoft.VisualBasic.Interaction.Shell(String,AppWinStyle,Boolean,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "运行可执行程序，并返回一个整数，如果它仍在运行包含该程序的进程 ID。"
  remarks: "The return value of the `Shell` function depends on whether the program named in `PathName` is still executing when `Shell` returns. If you set `Wait` to `True` and the program finishes before the timeout expires, `Shell` returns zero. If the timeout expires, or if you omit `Wait` or set it to `False`, `Shell` returns the process ID of the program. The process ID is a unique number that identifies the running program.  \n  \n## Failure to Start  \n If the `Shell` function cannot start the named program, a <xref:System.IO.FileNotFoundException> error occurs. This can happen, for example, when you attempt to run a 16-bit program, such as `command.com`, from an application using <xref:System.Windows.Forms?displayProperty=fullName>. For a workaround, you can run a 32-bit program that calls the desired 16-bit program. In the case of `command.com`, you can run `cmd.exe` as an alternative.  \n  \n## Waiting for Completion  \n By default, the `Shell` function runs the program asynchronously. This means that a program started with the `Shell` function might not finish executing before the statements following the `Shell` function are executed. If you want to wait for the program to finish before you continue, set `Wait` to `True`.  \n  \n## Determining the Exit Code  \n A process can return an *exit code* when it terminates. However, you cannot use `Shell` to retrieve this exit code, because `Shell` returns zero if it waits for termination, and also because the process runs in a different object from `Shell`.  \n  \n To retrieve the exit code from a process, you must write your own code to initiate the process and wait for termination. The following example shows how to initiate a process, wait for it to terminate, and retrieve its exit code.  \n  \n```vb#  \nDim procID As Integer  \nDim newProc As Diagnostics.Process  \nnewProc = Diagnostics.Process.Start(\"C:\\WINDOWS\\NOTEPAD.EXE\")  \nprocID = newProc.Id  \nnewProc.WaitForExit()  \nDim procEC As Integer = -1  \nIf newProc.HasExited Then  \n    procEC = newProc.ExitCode  \nEnd If  \nMsgBox(\"Process with ID \" & CStr(ProcID) & _  \n    \" terminated with exit code \" & CStr(procEC))  \n```  \n  \n## Protecting the File Specification  \n You should always enclose the entire path and file specification in quotation marks, as the following example shows.  \n  \n```vb#  \nID = Shell(\"\"\"C:\\Program Files\\display.exe\"\" -a -q\", , True, 100000)  \n```  \n  \n Each pair of adjacent double quotation marks (`\" \"`) within the string literal is interpreted as one double quotation character in the string. Therefore, the preceding example presents the following string to the `Shell` function:  \n  \n```  \n\"C:\\Program Files\\display.exe\" -a -q  \n```  \n  \n If you did not have the path enclosed in quotation marks, Windows would look for a file called `Program.exe` in the C:\\ directory, instead of `display.exe` in the C:\\Program Files directory.  \n  \n> [!IMPORTANT]\n>  If you do not enclose the path and file specification in quotation marks, there is a security risk if the file name or a path node contains spaces. In the preceding example, the path node `\\Program Files` includes a space. If the specification were not inside quotation marks and a program named `Program.exe` had been installed in C:\\\\, for example by illicit tampering, Windows would execute it instead of `display.exe`.  \n  \n> [!IMPORTANT]\n>  The `Shell` function requires unmanaged code permission, which might affect its execution in partial-trust situations. For more information, see <xref:System.Security.Permissions.SecurityPermission> and [Code Access Permissions](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)."
  example:
  - "The following example uses the `Shell` function to run an application specified by the user. Specifying <xref:Microsoft.VisualBasic.AppWinStyle?displayProperty=fullName> as the second argument opens the application in normal size and gives it the focus.  \n  \n [!code-vb[VbVbalrFunctions#47](~/add/codesnippet/visualbasic/a0f7fa2d-96c5-4a1d-b721-_1.vb)]"
  syntax:
    content: public static int Shell (string PathName, Microsoft.VisualBasic.AppWinStyle Style = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, bool Wait = false, int Timeout = -1);
    parameters:
    - id: PathName
      type: System.String
      description: "Required. <xref uid=\"langword_csharp_String\" name=\"String\" href=\"\"></xref>. Name of the program to execute, together with any required arguments and command-line switches. `PathName` can also include the drive and the directory path or folder.  \n  \n If you do not know the path to the program, you can use the <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles*> to locate it. For example, you can call `My.Computer.FileSystem.GetFiles(\"C:\\\", True, \"testFile.txt\")`, which returns the full path of every file named `testFile.txt` anywhere on drive C:\\\\."
    - id: Style
      type: Microsoft.VisualBasic.AppWinStyle
      description: "可选。 <xref uid=&quot;langword_csharp_AppWinStyle&quot; name=&quot;AppWinStyle&quot; href=&quot;&quot;></xref>. 从选择的值<xref href=&quot;Microsoft.VisualBasic.AppWinStyle&quot;></xref>指定是用要运行程序窗口的样式。 如果`Style`省略， <xref uid=&quot;langword_csharp_Shell&quot; name=&quot;Shell&quot; href=&quot;&quot;> </xref>使用<xref uid=&quot;langword_csharp_AppWinStyle.MinimizedFocus&quot; name=&quot;AppWinStyle.MinimizedFocus&quot; href=&quot;&quot;> </xref>，以启动该程序，最小化并获得焦点。"
    - id: Wait
      type: System.Boolean
      description: "可选。 <xref uid=&quot;langword_csharp_Boolean&quot; name=&quot;Boolean&quot; href=&quot;&quot;></xref>. 一个值，该值指示是否<xref uid=&quot;langword_csharp_Shell&quot; name=&quot;Shell&quot; href=&quot;&quot;></xref>函数应等待完成程序。 If `Wait` is omitted, <xref uid=&quot;langword_csharp_Shell&quot; name=&quot;Shell&quot; href=&quot;&quot;></xref> uses <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;></xref>."
    - id: Timeout
      type: System.Int32
      description: "可选。 <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;></xref>. 如果完成等待的毫秒数`Wait`是<xref uid=&quot;langword_csharp_True&quot; name=&quot;True&quot; href=&quot;&quot;> </xref>。 如果`Timeout`省略， <xref uid=&quot;langword_csharp_Shell&quot; name=&quot;Shell&quot; href=&quot;&quot;> </xref>使用-1，这意味着无超时和<xref uid=&quot;langword_csharp_Shell&quot; name=&quot;Shell&quot; href=&quot;&quot;></xref>程序完成后才返回值。 因此，如果省略`Timeout`或一组很可能为-1，它的<xref uid=&quot;langword_csharp_Shell&quot; name=&quot;Shell&quot; href=&quot;&quot;></xref>可能永远不会将控制权返回给你的程序。"
    return:
      type: System.Int32
      description: "运行可执行程序，并返回一个整数，如果它仍在运行包含该程序的进程 ID。"
  overload: Microsoft.VisualBasic.Interaction.Shell*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Style</code>不在 0 到 9，（含) 范围内。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<xref uid=&quot;langword_csharp_Shell&quot; name=&quot;Shell&quot; href=&quot;&quot;></xref>找不到<code> PathName </code>文件。"
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "<code>PathName</code>is <xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: Microsoft.VisualBasic.Interaction.Switch(System.Object[])
  id: Switch(System.Object[])
  parent: Microsoft.VisualBasic.Interaction
  langs:
  - csharp
  name: Switch(Object[])
  nameWithType: Interaction.Switch(Object[])
  fullName: Microsoft.VisualBasic.Interaction.Switch(Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "计算的表达式并返回列表<xref uid=&quot;langword_csharp_Object&quot; name=&quot;Object&quot; href=&quot;&quot;></xref>对应的列表中的第一个表达式的值<xref uid=&quot;langword_csharp_True&quot; name=&quot;True&quot; href=&quot;&quot;> </xref>。"
  remarks: "自变量提供给`VarExpr`成对的表达式和值组成。 `Switch`函数的计算结果奇数表达式从低到中的最高索引`VarExpr`，并返回与计算结果为第一个表达式相关联的偶数值`True`。 例如，如果`VarExpr(0)`是`True`，`Switch`返回`VarExpr(1)`，并且如果`VarExpr(0)`是`False`但`VarExpr(2)`是`True`，`Switch`返回`VarExpr(3)`，依次类推。       如果未提供`VarExpr`自变量，`Switch`返回`Nothing`。      1> [!NOTE]&1;> 自变量列表中的表达式可以包括函数调用。 作为准备调用的自变量列表的一部分`Switch`，Visual Basic 编译器在每个表达式中调用每个函数。 这意味着您不能依赖于特定函数参数列表中前面的表达式为时未调用`True`。"
  example:
  - "The following example uses the `Switch` function to return the name of a language that matches the name of a city. It requires that `Option Strict` be `Off`.  \n  \n [!code-vb[VbVbalrFunctions#48](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._108_1.vb)]  \n  \n Because the <xref:System.Diagnostics> namespace also contains a class called <xref:System.Diagnostics.Switch>, a call to the `Switch` function must be qualified with the <xref:Microsoft.VisualBasic> namespace."
  syntax:
    content: public static object Switch (object[] VarExpr);
    parameters:
    - id: VarExpr
      type: System.Object[]
      description: "必需。 <xref uid=&quot;langword_csharp_Object&quot; name=&quot;Object&quot; href=&quot;&quot;></xref>参数数组。 必须具有偶数数目的元素。 你可以提供一份<xref uid=&quot;langword_csharp_Object&quot; name=&quot;Object&quot; href=&quot;&quot;></xref>隔开逗号、 或的一维数组的变量或表达式<xref uid=&quot;langword_csharp_Object&quot; name=&quot;Object&quot; href=&quot;&quot;></xref>元素。"
    return:
      type: System.Object
      description: "计算的表达式并返回列表<xref uid=&quot;langword_csharp_Object&quot; name=&quot;Object&quot; href=&quot;&quot;></xref>对应的列表中的第一个表达式的值<xref uid=&quot;langword_csharp_True&quot; name=&quot;True&quot; href=&quot;&quot;> </xref>。"
  overload: Microsoft.VisualBasic.Interaction.Switch*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "参数个数为奇数。"
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Exception
  isExternal: true
  name: System.Exception
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: Microsoft.VisualBasic.Interaction.AppActivate(System.Int32)
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: AppActivate(Int32)
  nameWithType: Interaction.AppActivate(Int32)
  fullName: Microsoft.VisualBasic.Interaction.AppActivate(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: Microsoft.VisualBasic.Interaction.AppActivate(System.String)
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: AppActivate(String)
  nameWithType: Interaction.AppActivate(String)
  fullName: Microsoft.VisualBasic.Interaction.AppActivate(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: Microsoft.VisualBasic.Interaction.Beep
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: Beep()
  nameWithType: Interaction.Beep()
  fullName: Microsoft.VisualBasic.Interaction.Beep()
- uid: Microsoft.VisualBasic.Interaction.CallByName(System.Object,System.String,Microsoft.VisualBasic.CallType,System.Object[])
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: CallByName(Object,String,CallType,Object[])
  nameWithType: Interaction.CallByName(Object,String,CallType,Object[])
  fullName: Microsoft.VisualBasic.Interaction.CallByName(Object,String,CallType,Object[])
- uid: Microsoft.VisualBasic.CallType
  parent: Microsoft.VisualBasic
  isExternal: false
  name: CallType
  nameWithType: CallType
  fullName: Microsoft.VisualBasic.CallType
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: Choose(Double,Object[])
  nameWithType: Interaction.Choose(Double,Object[])
  fullName: Microsoft.VisualBasic.Interaction.Choose(Double,Object[])
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: Microsoft.VisualBasic.Interaction.Command
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: Command()
  nameWithType: Interaction.Command()
  fullName: Microsoft.VisualBasic.Interaction.Command()
- uid: Microsoft.VisualBasic.Interaction.CreateObject(System.String,System.String)
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: CreateObject(String,String)
  nameWithType: Interaction.CreateObject(String,String)
  fullName: Microsoft.VisualBasic.Interaction.CreateObject(String,String)
- uid: Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: DeleteSetting(String,String,String)
  nameWithType: Interaction.DeleteSetting(String,String,String)
  fullName: Microsoft.VisualBasic.Interaction.DeleteSetting(String,String,String)
- uid: Microsoft.VisualBasic.Interaction.Environ(System.Int32)
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: Environ(Int32)
  nameWithType: Interaction.Environ(Int32)
  fullName: Microsoft.VisualBasic.Interaction.Environ(Int32)
- uid: Microsoft.VisualBasic.Interaction.Environ(System.String)
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: Environ(String)
  nameWithType: Interaction.Environ(String)
  fullName: Microsoft.VisualBasic.Interaction.Environ(String)
- uid: Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: GetAllSettings(String,String)
  nameWithType: Interaction.GetAllSettings(String,String)
  fullName: Microsoft.VisualBasic.Interaction.GetAllSettings(String,String)
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[,]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[,]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: Microsoft.VisualBasic.Interaction.GetObject(System.String,System.String)
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: GetObject(String,String)
  nameWithType: Interaction.GetObject(String,String)
  fullName: Microsoft.VisualBasic.Interaction.GetObject(String,String)
- uid: Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: GetSetting(String,String,String,String)
  nameWithType: Interaction.GetSetting(String,String,String,String)
  fullName: Microsoft.VisualBasic.Interaction.GetSetting(String,String,String,String)
- uid: Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: IIf(Boolean,Object,Object)
  nameWithType: Interaction.IIf(Boolean,Object,Object)
  fullName: Microsoft.VisualBasic.Interaction.IIf(Boolean,Object,Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: Microsoft.VisualBasic.Interaction.InputBox(System.String,System.String,System.String,System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: InputBox(String,String,String,Int32,Int32)
  nameWithType: Interaction.InputBox(String,String,String,Int32,Int32)
  fullName: Microsoft.VisualBasic.Interaction.InputBox(String,String,String,Int32,Int32)
- uid: Microsoft.VisualBasic.Interaction.MsgBox(System.Object,Microsoft.VisualBasic.MsgBoxStyle,System.Object)
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: MsgBox(Object,MsgBoxStyle,Object)
  nameWithType: Interaction.MsgBox(Object,MsgBoxStyle,Object)
  fullName: Microsoft.VisualBasic.Interaction.MsgBox(Object,MsgBoxStyle,Object)
- uid: Microsoft.VisualBasic.MsgBoxResult
  parent: Microsoft.VisualBasic
  isExternal: false
  name: MsgBoxResult
  nameWithType: MsgBoxResult
  fullName: Microsoft.VisualBasic.MsgBoxResult
- uid: Microsoft.VisualBasic.MsgBoxStyle
  parent: Microsoft.VisualBasic
  isExternal: false
  name: MsgBoxStyle
  nameWithType: MsgBoxStyle
  fullName: Microsoft.VisualBasic.MsgBoxStyle
- uid: Microsoft.VisualBasic.Interaction.Partition(System.Int64,System.Int64,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: Partition(Int64,Int64,Int64,Int64)
  nameWithType: Interaction.Partition(Int64,Int64,Int64,Int64)
  fullName: Microsoft.VisualBasic.Interaction.Partition(Int64,Int64,Int64,Int64)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: SaveSetting(String,String,String,String)
  nameWithType: Interaction.SaveSetting(String,String,String,String)
  fullName: Microsoft.VisualBasic.Interaction.SaveSetting(String,String,String,String)
- uid: Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: Shell(String,AppWinStyle,Boolean,Int32)
  nameWithType: Interaction.Shell(String,AppWinStyle,Boolean,Int32)
  fullName: Microsoft.VisualBasic.Interaction.Shell(String,AppWinStyle,Boolean,Int32)
- uid: Microsoft.VisualBasic.AppWinStyle
  parent: Microsoft.VisualBasic
  isExternal: false
  name: AppWinStyle
  nameWithType: AppWinStyle
  fullName: Microsoft.VisualBasic.AppWinStyle
- uid: Microsoft.VisualBasic.Interaction.Switch(System.Object[])
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: Switch(Object[])
  nameWithType: Interaction.Switch(Object[])
  fullName: Microsoft.VisualBasic.Interaction.Switch(Object[])
- uid: Microsoft.VisualBasic.Interaction.AppActivate*
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: AppActivate
  nameWithType: Interaction.AppActivate
- uid: Microsoft.VisualBasic.Interaction.Beep*
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: Beep
  nameWithType: Interaction.Beep
- uid: Microsoft.VisualBasic.Interaction.CallByName*
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: CallByName
  nameWithType: Interaction.CallByName
- uid: Microsoft.VisualBasic.Interaction.Choose*
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: Choose
  nameWithType: Interaction.Choose
- uid: Microsoft.VisualBasic.Interaction.Command*
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: Command
  nameWithType: Interaction.Command
- uid: Microsoft.VisualBasic.Interaction.CreateObject*
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: CreateObject
  nameWithType: Interaction.CreateObject
- uid: Microsoft.VisualBasic.Interaction.DeleteSetting*
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: DeleteSetting
  nameWithType: Interaction.DeleteSetting
- uid: Microsoft.VisualBasic.Interaction.Environ*
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: Environ
  nameWithType: Interaction.Environ
- uid: Microsoft.VisualBasic.Interaction.GetAllSettings*
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: GetAllSettings
  nameWithType: Interaction.GetAllSettings
- uid: Microsoft.VisualBasic.Interaction.GetObject*
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: GetObject
  nameWithType: Interaction.GetObject
- uid: Microsoft.VisualBasic.Interaction.GetSetting*
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: GetSetting
  nameWithType: Interaction.GetSetting
- uid: Microsoft.VisualBasic.Interaction.IIf*
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: IIf
  nameWithType: Interaction.IIf
- uid: Microsoft.VisualBasic.Interaction.InputBox*
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: InputBox
  nameWithType: Interaction.InputBox
- uid: Microsoft.VisualBasic.Interaction.MsgBox*
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: MsgBox
  nameWithType: Interaction.MsgBox
- uid: Microsoft.VisualBasic.Interaction.Partition*
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: Partition
  nameWithType: Interaction.Partition
- uid: Microsoft.VisualBasic.Interaction.SaveSetting*
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: SaveSetting
  nameWithType: Interaction.SaveSetting
- uid: Microsoft.VisualBasic.Interaction.Shell*
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: Shell
  nameWithType: Interaction.Shell
- uid: Microsoft.VisualBasic.Interaction.Switch*
  parent: Microsoft.VisualBasic.Interaction
  isExternal: false
  name: Switch
  nameWithType: Interaction.Switch
