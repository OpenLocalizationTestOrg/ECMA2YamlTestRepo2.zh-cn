### YamlMime:ManagedReference
items:
- uid: System.Xml.Xsl.XslTransform
  id: XslTransform
  children:
  - System.Xml.Xsl.XslTransform.#ctor
  - System.Xml.Xsl.XslTransform.Load(System.String)
  - System.Xml.Xsl.XslTransform.Load(System.Xml.XmlReader)
  - System.Xml.Xsl.XslTransform.Load(System.Xml.XPath.IXPathNavigable)
  - System.Xml.Xsl.XslTransform.Load(System.Xml.XPath.XPathNavigator)
  - System.Xml.Xsl.XslTransform.Load(System.String,System.Xml.XmlResolver)
  - System.Xml.Xsl.XslTransform.Load(System.Xml.XmlReader,System.Xml.XmlResolver)
  - System.Xml.Xsl.XslTransform.Load(System.Xml.XPath.IXPathNavigable,System.Xml.XmlResolver)
  - System.Xml.Xsl.XslTransform.Load(System.Xml.XPath.XPathNavigator,System.Xml.XmlResolver)
  - System.Xml.Xsl.XslTransform.Load(System.Xml.XmlReader,System.Xml.XmlResolver,System.Security.Policy.Evidence)
  - System.Xml.Xsl.XslTransform.Load(System.Xml.XPath.IXPathNavigable,System.Xml.XmlResolver,System.Security.Policy.Evidence)
  - System.Xml.Xsl.XslTransform.Load(System.Xml.XPath.XPathNavigator,System.Xml.XmlResolver,System.Security.Policy.Evidence)
  - System.Xml.Xsl.XslTransform.Transform(System.String,System.String)
  - System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList)
  - System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList)
  - System.Xml.Xsl.XslTransform.Transform(System.String,System.String,System.Xml.XmlResolver)
  - System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList,System.IO.Stream)
  - System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList,System.IO.TextWriter)
  - System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList,System.Xml.XmlResolver)
  - System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList,System.Xml.XmlWriter)
  - System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.IO.Stream)
  - System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.IO.TextWriter)
  - System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.Xml.XmlResolver)
  - System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.Xml.XmlWriter)
  - System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList,System.IO.Stream,System.Xml.XmlResolver)
  - System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList,System.IO.TextWriter,System.Xml.XmlResolver)
  - System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList,System.Xml.XmlWriter,System.Xml.XmlResolver)
  - System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.IO.Stream,System.Xml.XmlResolver)
  - System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.IO.TextWriter,System.Xml.XmlResolver)
  - System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.Xml.XmlWriter,System.Xml.XmlResolver)
  - System.Xml.Xsl.XslTransform.XmlResolver
  langs:
  - csharp
  name: XslTransform
  nameWithType: XslTransform
  fullName: System.Xml.Xsl.XslTransform
  type: Class
  summary: "转换使用可扩展样式表语言转换 (XSLT) 样式表的 XML 数据。"
  remarks: "> [!NOTE]1> XslTransform 类是 Microsoft.NET Framework 2.0 版中过时。 <xref:System.Xml.Xsl.XslCompiledTransform>类是新的 XSLT 处理器。</xref:System.Xml.Xsl.XslCompiledTransform> 有关详细信息，请参阅[使用 XslCompiledTransform 类](~/add/includes/ajax-current-ext-md.md)和[迁移从 XslTransform 类](~/add/includes/ajax-current-ext-md.md)。       XslTransform 支持 XSLT 1.0 语法。 XSLT 样式表必须使用命名空间`http://www.w3.org/1999/XSL/Transform`。       此外可以将其他参数添加到样式表使用<xref:System.Xml.Xsl.XsltArgumentList>类。</xref:System.Xml.Xsl.XsltArgumentList> 此类包含的样式表和扩展对象可以从样式表调用该输入的参数。       若要将 XML 数据转换︰ 1。  创建一个 XslTransform 对象。      2.  使用<xref:System.Xml.Xsl.XslTransform.Load%2A>方法加载样式表转换。</xref:System.Xml.Xsl.XslTransform.Load%2A> 此方法具有好几个重载，并且可以加载样式表使用<xref:System.Xml.XmlReader>， <xref:System.Xml.XPath.XPathNavigator>， <xref:System.Xml.XPath.IXPathNavigable>，或具有文件的位置的 URL。</xref:System.Xml.XPath.IXPathNavigable> </xref:System.Xml.XPath.XPathNavigator> </xref:System.Xml.XmlReader>      3.  使用<xref:System.Xml.Xsl.XslTransform.Transform%2A>方法来转换 XML 数据。</xref:System.Xml.Xsl.XslTransform.Transform%2A> 此方法具有好几个重载，可以处理不同类型的输入和输出。 你还可以指定<xref:System.Xml.Xsl.XsltArgumentList>包含要在转换期间使用作为输入的其他自变量。</xref:System.Xml.Xsl.XsltArgumentList>       **安全注意事项**在创建使用 XslTransform 类的应用程序，你应了解下列项及其含义:-默认情况下启用扩展对象。 如果<xref:System.Xml.Xsl.XsltArgumentList>对象，其中包含扩展对象传递给<xref:System.Xml.Xsl.XslTransform.Transform%2A>方法，使用它们。</xref:System.Xml.Xsl.XslTransform.Transform%2A> </xref:System.Xml.Xsl.XsltArgumentList>      -XSLT 样式表可以包括对其他文件以及嵌入式的脚本块的引用。 恶意用户可以利用此方法为您提供数据或样式表，在执行时将导致您的系统以处理，直到计算机资源不足。      的在混合的信任环境中运行 XSLT 应用可能会引发样式表欺骗。 例如，恶意用户可以加载包含有害的样式表的对象和交给另一个用户，后者会继续调用<xref:System.Xml.Xsl.XslTransform.Transform%2A>方法并执行转换。</xref:System.Xml.Xsl.XslTransform.Transform%2A>       不接受 XslTransform 对象、 XSLT 样式表或来自不可信源的 XML 源数据，可以缓解这些安全问题。       **脚本支持**此类支持嵌入的脚本使用`msxsl:script`元素。       .NET Framework 1.1 版中，在样式表的证据确定哪些权限被授予的嵌入的脚本。      -如果样式表加载从统一资源标识符 (URI) 时，URI 用于创建证据。 该证据包括以及其站点和区域的 URI。      -如果使用另一个源加载样式表，你可以通过传递提供证据<xref:System.Security.Policy.Evidence?displayProperty=fullName>对象传递给<xref:System.Xml.Xsl.XslTransform.Load%2A>方法。</xref:System.Xml.Xsl.XslTransform.Load%2A> </xref:System.Security.Policy.Evidence?displayProperty=fullName> 否则，脚本程序集具有完全信任。       不完全受信任的调用方︰`UnmanagedCode`编译嵌入的脚本所需的权限。 `ControlEvidence`提供所需的权限<xref:System.Security.Policy.Evidence>到<xref:System.Xml.Xsl.XslTransform.Load%2A>方法。</xref:System.Xml.Xsl.XslTransform.Load%2A> </xref:System.Security.Policy.Evidence> A<xref:System.Security.SecurityException>如果调用方没有所需的权限，则引发。</xref:System.Security.SecurityException> 请参阅<xref:System.Security.Permissions.SecurityPermission?displayProperty=fullName>和<xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>有关详细信息。</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.Security.Permissions.SecurityPermission?displayProperty=fullName>       `msxsl:script`元素具有以下要求:-`msxsl:script`元素属于`urn:schemas-microsoft-com:xslt`命名空间。 样式表必须包括命名空间声明`xmlns:msxsl=urn:schemas-microsoft-com:xslt`。      -`msxsl:script`元素可以包含`language`属性，指定要使用的脚本语言。 值`language`特性必须是以下之一︰ C#、 CSharp、 VB、 VisualBasic、 JScript 中或 JavaScript。 因为该语言名称不区分大小写，JavaScript 和 javascript 都有效。 如果`language`属性未指定，则它默认为 JScript。      -`msxsl:script`元素必须包含`implements-prefix`包含表示与脚本块关联的命名空间的前缀的属性。 必须在样式表中定义此命名空间。 样式表可以包括多个脚本块，分为不同的命名空间。 不能具有与在同一命名空间中的多个语言的脚本块。 脚本块可以调用另一个脚本块中定义的函数，提供的脚本块驻留在相同的命名空间内。 根据规则和语法的脚本语言分析脚本块的内容 (由提供`language`属性)。 例如，如果你具有 C# 脚本块，注释就会通过`//`字符。 注释必须为有效的 XML 内容。       `Note`建议你在 CDATA 部分包装脚本块。      ```   <msxsl:script implements-prefix=&quot;xy&quot; language=&quot;C#&quot;>     <![CDATA[     // Add code here.     ]]>   </msxsl:script>   ```可以在声明函数`msxsl:script`元素。 下表显示默认情况下支持的命名空间。      |支持命名空间 |说明 |  |--------------------------|-----------------|  |`System`|系统类。 |  |`System.Collection`|集合类。 |  |`System.Text`|处理类的文本。 |  |`System.Xml`|核心 XML 类。 |  |`System.Xml.Xsl`|XSLT 类。 |  |`System.Xml.XPath`|XML 路径语言 (XPath) 类。 |      提供的自变量和返回值由脚本函数定义必须是下面列出 World Wide Web Consortium (W3C) 类型之一。 下表详细说明了 W3C 类型、 XPath 或 XSLT，之间的映射和相应的.NET Framework 类。      |W3C 类型 |等效的.NET 类 |  |--------------|---------------------------|  |字符串 (XPath) |`System.String`|  |布尔值 (XPath) |`System.Boolean`|  |数 (XPath) |`System.Double`|  |结果树片段 (XSLT) |`System.Xml.XPath.XPathNavigator`|  |节点集 (XPath) |`System.Xml.XPath.XPathNodeIterator`|      如果脚本函数使用下列数值类型之一︰ Int16、 UInt16、 Int32、 UInt32、 Int64、 UInt64、 Single 或 Decimal，这些类型将被强制为 Double，映射为 W3C XPath 类型的数字。       将引发异常时，调用的函数不能将自变量结果转换为所需的类型之一。      1> [!NOTE]  >   `msxsl:script`和`msxsl:node-list`是中的唯一函数`urn:schemas-microsoft-com:xslt`XslTransform 类支持的命名空间。       XslTransform 能够利用作为一种扩展机制的公共语言运行时 (CLR) 代码。 这是通过将类的实例传递给 XslTransform 类并调用其 XSLT 样式表中的公共方法实现的。 使用定义的方法`params`关键字，它允许未指定要传递的参数数量，在此方案中无法正常工作。 请参阅[params](~/add/includes/ajax-current-ext-md.md)有关详细信息。       有关详细信息请参阅[XslTransform 类的 XSLT 转换](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example transforms the specified XML document and outputs the result to the console.  \n  \n [!code-vb[Classic WebData XslTransform Example#1](~/add/codesnippet/visualbasic/t-system.xml.xsl.xsltran_1.vb)]\n [!code-cs[Classic WebData XslTransform Example#1](~/add/codesnippet/csharp/t-system.xml.xsl.xsltran_1.cs)]"
  syntax:
    content: >-
      [System.Obsolete("This class has been deprecated. Please use System.Xml.Xsl.XslCompiledTransform instead. http://go.microsoft.com/fwlink/?linkid=14202")]

      public sealed class XslTransform
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Xml.Xsl.XslTransform.#ctor
  id: '#ctor'
  parent: System.Xml.Xsl.XslTransform
  langs:
  - csharp
  name: XslTransform()
  nameWithType: XslTransform.XslTransform()
  fullName: System.Xml.Xsl.XslTransform.XslTransform()
  type: Constructor
  assemblies:
  - System.Xml
  namespace: System.Xml.Xsl
  summary: "初始化的新实例<xref href=&quot;System.Xml.Xsl.XslTransform&quot;></xref>类。"
  syntax:
    content: public XslTransform ();
    parameters: []
  overload: System.Xml.Xsl.XslTransform.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.Xsl.XslTransform.Load(System.String)
  id: Load(System.String)
  parent: System.Xml.Xsl.XslTransform
  langs:
  - csharp
  name: Load(String)
  nameWithType: XslTransform.Load(String)
  fullName: System.Xml.Xsl.XslTransform.Load(String)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml.Xsl
  summary: "加载指定的 url 的 XSLT 样式表。"
  remarks: "> [!NOTE]1><xref:System.Xml.Xsl.XslTransform>类是.NET Framework 2.0 版中过时。</xref:System.Xml.Xsl.XslTransform> <xref:System.Xml.Xsl.XslCompiledTransform>类是新的 XSLT 处理器。</xref:System.Xml.Xsl.XslCompiledTransform> 有关详细信息，请参阅[使用 XslCompiledTransform 类](~/add/includes/ajax-current-ext-md.md)和[迁移从 XslTransform 类](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Xml.Xsl.XslTransform>支持的 XSLT 1.0 语法。</xref:System.Xml.Xsl.XslTransform> XSLT 样式表必须包括命名空间声明`xmlns:xsl=``http://www.w3.org/1999/XSL/Transform`。       此方法将 XSLT 样式表，包括任何引用中的样式表加载`xsl:include`和`xsl:import`元素。 使用解析外部资源<xref:System.Xml.XmlUrlResolver>使用没有用户凭据。</xref:System.Xml.XmlUrlResolver> 如果样式表都位于需要身份验证的网络资源，请使用采用的重载<xref:System.Xml.XmlResolver>作为其自变量之一并指定<xref:System.Xml.XmlResolver>使用必要的凭据。</xref:System.Xml.XmlResolver> </xref:System.Xml.XmlResolver>       如果样式表包含嵌入的脚本，脚本将编译为程序集。 样式表的 URI 用于创建应用于程序集的证据。 有关问题<xref:System.Xml.Xsl.XslTransform.Load%2A>方法和样式表与嵌入的脚本，请参阅文章 Q316755 http://support.microsoft.com 在 Microsoft 知识库。</xref:System.Xml.Xsl.XslTransform.Load%2A>      1> [!NOTE]&1;> 如果调用方不具有`UnmanagedCode`权限，嵌入的脚本未编译和<xref:System.Security.SecurityException>引发。</xref:System.Security.SecurityException> 请参阅<xref:System.Security.Permissions.SecurityPermission>和<xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>有关详细信息。</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "The following example transforms an XML document into an HTML document. It displays the ISBN, title, and price for each book in a table.  \n  \n [!code-cs[Classic WebData XslTransform.Transform7 Example#1](~/add/codesnippet/csharp/m-system.xml.xsl.xsltran_0_1.cs)]\n [!code-cpp[Classic WebData XslTransform.Transform7 Example#1](~/add/codesnippet/cpp/m-system.xml.xsl.xsltran_0_1.cpp)]\n [!code-vb[Classic WebData XslTransform.Transform7 Example#1](~/add/codesnippet/visualbasic/m-system.xml.xsl.xsltran_0_1.vb)]  \n  \n The sample uses the following two input files.  \n  \n `books.xml`  \n  \n [!code-xml[Classic WebData XslTransform.Transform7 Example#2](~/add/codesnippet/xml/m-system.xml.xsl.xsltran_0_2.xml)]  \n  \n `output.xsl`  \n  \n [!code-xml[Classic WebData XslTransform.Transform7 Example#3](~/add/codesnippet/xml/m-system.xml.xsl.xsltran_0_3.xsl)]"
  syntax:
    content: public void Load (string url);
    parameters:
    - id: url
      type: System.String
      description: "指定要加载的 XSLT 样式表的 URL。"
  overload: System.Xml.Xsl.XslTransform.Load*
  exceptions:
  - type: System.Xml.Xsl.XsltCompileException
    commentId: T:System.Xml.Xsl.XsltCompileException
    description: "加载的资源不是有效的样式表。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "样式表包含嵌入的脚本，并且调用方没有<xref uid=&quot;langword_csharp_UnmanagedCode&quot; name=&quot;UnmanagedCode&quot; href=&quot;&quot;></xref>权限。"
  platform:
  - net462
- uid: System.Xml.Xsl.XslTransform.Load(System.Xml.XmlReader)
  id: Load(System.Xml.XmlReader)
  parent: System.Xml.Xsl.XslTransform
  langs:
  - csharp
  name: Load(XmlReader)
  nameWithType: XslTransform.Load(XmlReader)
  fullName: System.Xml.Xsl.XslTransform.Load(XmlReader)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml.Xsl
  summary: "加载<xref:System.Xml.XmlReader>.</xref:System.Xml.XmlReader>中包含的 XSLT 样式表"
  remarks: "> [!NOTE]1><xref:System.Xml.Xsl.XslTransform>类是.NET Framework 2.0 版中过时。</xref:System.Xml.Xsl.XslTransform> <xref:System.Xml.Xsl.XslCompiledTransform>类是新的 XSLT 处理器。</xref:System.Xml.Xsl.XslCompiledTransform> 有关详细信息，请参阅[使用 XslCompiledTransform 类](~/add/includes/ajax-current-ext-md.md)和[迁移从 XslTransform 类](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Xml.Xsl.XslTransform>支持的 XSLT 1.0 语法。</xref:System.Xml.Xsl.XslTransform> XSLT 样式表必须包括命名空间声明`xmlns:xsl= http://www.w3.org/1999/XSL/Transform`。       此方法将 XSLT 样式表，包括任何引用中的样式表加载`xsl:include`和`xsl:import`元素。 使用解析外部资源<xref:System.Xml.XmlUrlResolver>使用没有用户凭据。</xref:System.Xml.XmlUrlResolver> 如果样式表都位于需要身份验证的网络资源，请使用采用的重载<xref:System.Xml.XmlResolver>作为其自变量之一并指定<xref:System.Xml.XmlResolver>使用必要的凭据。</xref:System.Xml.XmlResolver> </xref:System.Xml.XmlResolver>       从当前节点的加载样式表<xref:System.Xml.XmlReader>通过其所有子级。</xref:System.Xml.XmlReader> 这使您要用作样式表文档的一部分。 后<xref:System.Xml.Xsl.XslTransform.Load%2A>方法返回时，<xref:System.Xml.XmlReader>样式表末尾后定位到下一个节点。</xref:System.Xml.XmlReader> </xref:System.Xml.Xsl.XslTransform.Load%2A> 如果已到达文档结尾，<xref:System.Xml.XmlReader>将位于文件结尾 (EOF)。</xref:System.Xml.XmlReader>       如果样式表包含实体，你应指定<xref:System.Xml.XmlReader>可以解析实体 (<xref:System.Xml.XmlReader.CanResolveEntity%2A?displayProperty=fullName>返回`true`)。</xref:System.Xml.XmlReader.CanResolveEntity%2A?displayProperty=fullName> </xref:System.Xml.XmlReader> 在这种情况下，<xref:System.Xml.XmlValidatingReader>可用。</xref:System.Xml.XmlValidatingReader>       如果样式表包含嵌入的脚本，脚本将编译为程序集。 程序集具有完全信任。 建议的做法是提供证据使用<xref:System.Xml.Xsl.XslTransform.Load%28System.Xml.XmlReader%2CSystem.Xml.XmlResolver%2CSystem.Security.Policy.Evidence%29>方法。</xref:System.Xml.Xsl.XslTransform.Load%28System.Xml.XmlReader%2CSystem.Xml.XmlResolver%2CSystem.Security.Policy.Evidence%29> 有关问题<xref:System.Xml.Xsl.XslTransform.Load%2A>方法和样式表与嵌入的脚本，请参阅文章 Q316755 http://support.microsoft.com 在 Microsoft 知识库。</xref:System.Xml.Xsl.XslTransform.Load%2A>      1> [!NOTE]&1;> 如果调用方不具有`UnmanagedCode`权限，嵌入的脚本未编译和<xref:System.Security.SecurityException>引发。</xref:System.Security.SecurityException> 请参阅<xref:System.Security.Permissions.SecurityPermission>和<xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>有关详细信息。</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "The following example transforms an XML file sorting all the books by title.  \n  \n [!code-cs[XslTransform.Load3#1](~/add/codesnippet/csharp/m-system.xml.xsl.xsltran_1_1.cs)]\n [!code-cpp[XslTransform.Load3#1](~/add/codesnippet/cpp/m-system.xml.xsl.xsltran_1_1.cpp)]\n [!code-vb[XslTransform.Load3#1](~/add/codesnippet/visualbasic/m-system.xml.xsl.xsltran_1_1.vb)]  \n  \n The example uses the following data files as input.  \n  \n `books.xml`  \n  \n [!code-xml[XslTransform.Load3#2](~/add/codesnippet/xml/m-system.xml.xsl.xsltran_1_2.xml)]  \n  \n `titles.xsl`  \n  \n [!code-xml[XslTransform.Load3#3](~/add/codesnippet/xml/m-system.xml.xsl.xsltran_1_3.xsl)]"
  syntax:
    content: public void Load (System.Xml.XmlReader stylesheet);
    parameters:
    - id: stylesheet
      type: System.Xml.XmlReader
      description: "<xref:System.Xml.XmlReader>对象，其中包含的 XSLT 样式表。</xref:System.Xml.XmlReader>"
  overload: System.Xml.Xsl.XslTransform.Load*
  exceptions:
  - type: System.Xml.Xsl.XsltCompileException
    commentId: T:System.Xml.Xsl.XsltCompileException
    description: "当前节点不符合有效的样式表。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "样式表包含嵌入的脚本，并且调用方没有<xref uid=&quot;langword_csharp_UnmanagedCode&quot; name=&quot;UnmanagedCode&quot; href=&quot;&quot;></xref>权限。"
  platform:
  - net462
- uid: System.Xml.Xsl.XslTransform.Load(System.Xml.XPath.IXPathNavigable)
  id: Load(System.Xml.XPath.IXPathNavigable)
  parent: System.Xml.Xsl.XslTransform
  langs:
  - csharp
  name: Load(IXPathNavigable)
  nameWithType: XslTransform.Load(IXPathNavigable)
  fullName: System.Xml.Xsl.XslTransform.Load(IXPathNavigable)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml.Xsl
  summary: "加载 XSL 样式表中包含<xref href=&quot;System.Xml.XPath.IXPathNavigable&quot;> </xref>。"
  remarks: "> [!NOTE]1><xref:System.Xml.Xsl.XslTransform>类是.NET Framework 2.0 版中过时。</xref:System.Xml.Xsl.XslTransform> <xref:System.Xml.Xsl.XslCompiledTransform>类是新的 XSLT 处理器。</xref:System.Xml.Xsl.XslCompiledTransform> 有关详细信息，请参阅[使用 XslCompiledTransform 类](~/add/includes/ajax-current-ext-md.md)和[迁移从 XslTransform 类](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Xml.Xsl.XslTransform>支持的 XSLT 1.0 语法。</xref:System.Xml.Xsl.XslTransform> XSLT 样式表必须包括命名空间声明`xmlns:xsl= http://www.w3.org/1999/XSL/Transform`。       此方法将 XSLT 样式表，包括任何引用中的样式表加载`xsl:include`和`xsl:import`元素。 使用解析外部资源<xref:System.Xml.XmlUrlResolver>使用没有用户凭据。</xref:System.Xml.XmlUrlResolver> 如果样式表都位于需要身份验证的网络资源，请使用采用的重载<xref:System.Xml.XmlResolver>作为其自变量之一并指定<xref:System.Xml.XmlResolver>使用必要的凭据。</xref:System.Xml.XmlResolver> </xref:System.Xml.XmlResolver>       如果样式表包含嵌入的脚本，脚本将编译为程序集。 程序集具有完全信任。 建议的做法是提供证据使用<xref:System.Xml.Xsl.XslTransform.Load%28System.Xml.XPath.IXPathNavigable%2CSystem.Xml.XmlResolver%2CSystem.Security.Policy.Evidence%29>方法。</xref:System.Xml.Xsl.XslTransform.Load%28System.Xml.XPath.IXPathNavigable%2CSystem.Xml.XmlResolver%2CSystem.Security.Policy.Evidence%29> 有关问题<xref:System.Xml.Xsl.XslTransform.Load%2A>方法和样式表与嵌入的脚本，请参阅文章 Q316755 http://support.microsoft.com 在 Microsoft 知识库。</xref:System.Xml.Xsl.XslTransform.Load%2A>      1> [!NOTE]&1;> 如果调用方不具有`UnmanagedCode`权限，嵌入的脚本未编译和<xref:System.Security.SecurityException>引发。</xref:System.Security.SecurityException> 请参阅<xref:System.Security.Permissions.SecurityPermission>和<xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>有关详细信息。</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.Security.Permissions.SecurityPermission>"
  syntax:
    content: public void Load (System.Xml.XPath.IXPathNavigable stylesheet);
    parameters:
    - id: stylesheet
      type: System.Xml.XPath.IXPathNavigable
      description: "一个对象，实现<xref href=&quot;System.Xml.XPath.IXPathNavigable&quot;></xref>接口。 在.NET Framework 中，这可能是<xref href=&quot;System.Xml.XmlNode&quot;> </xref> (通常<xref href=&quot;System.Xml.XmlDocument&quot;> </xref>)，或<xref href=&quot;System.Xml.XPath.XPathDocument&quot;></xref>包含 XSLT 样式表。"
  overload: System.Xml.Xsl.XslTransform.Load*
  exceptions:
  - type: System.Xml.Xsl.XsltCompileException
    commentId: T:System.Xml.Xsl.XsltCompileException
    description: "加载的资源不是有效的样式表。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "样式表包含嵌入的脚本，并且调用方没有<xref uid=&quot;langword_csharp_UnmanagedCode&quot; name=&quot;UnmanagedCode&quot; href=&quot;&quot;></xref>权限。"
  platform:
  - net462
- uid: System.Xml.Xsl.XslTransform.Load(System.Xml.XPath.XPathNavigator)
  id: Load(System.Xml.XPath.XPathNavigator)
  parent: System.Xml.Xsl.XslTransform
  langs:
  - csharp
  name: Load(XPathNavigator)
  nameWithType: XslTransform.Load(XPathNavigator)
  fullName: System.Xml.Xsl.XslTransform.Load(XPathNavigator)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml.Xsl
  summary: "加载 XSL 样式表中包含<xref href=&quot;System.Xml.XPath.XPathNavigator&quot;> </xref>。"
  remarks: "> [!NOTE]1><xref:System.Xml.Xsl.XslTransform>类是.NET Framework 2.0 版中过时。</xref:System.Xml.Xsl.XslTransform> <xref:System.Xml.Xsl.XslCompiledTransform>类是新的 XSLT 处理器。</xref:System.Xml.Xsl.XslCompiledTransform> 有关详细信息，请参阅[使用 XslCompiledTransform 类](~/add/includes/ajax-current-ext-md.md)和[迁移从 XslTransform 类](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Xml.Xsl.XslTransform>支持的 XSLT 1.0 语法。</xref:System.Xml.Xsl.XslTransform> XSLT 样式表必须包括命名空间声明`xmlns:xsl= http://www.w3.org/1999/XSL/Transform`。       此方法将 XSLT 样式表，包括任何引用中的样式表加载`xsl:include`和`xsl:import`元素。 使用解析外部资源<xref:System.Xml.XmlUrlResolver>使用没有用户凭据。</xref:System.Xml.XmlUrlResolver> 如果样式表都位于需要身份验证的网络资源，请使用采用的重载<xref:System.Xml.XmlResolver>作为其自变量之一并指定<xref:System.Xml.XmlResolver>使用必要的凭据。</xref:System.Xml.XmlResolver> </xref:System.Xml.XmlResolver>       从当前的<xref:System.Xml.XPath.XPathNavigator>。</xref:System.Xml.XPath.XPathNavigator>位置加载样式表 若要使用与样式表所加载文档的一部分，导航到样式表的开头相对应的节点。 Load 方法返回后，<xref:System.Xml.XPath.XPathNavigator>位于开头的样式表 (上`xsl:style sheet`节点)。</xref:System.Xml.XPath.XPathNavigator>       如果样式表包含嵌入的脚本，脚本将编译为程序集。 程序集具有完全信任。 建议的做法是提供证据使用<xref:System.Xml.Xsl.XslTransform.Load%28System.Xml.XPath.XPathNavigator%2CSystem.Xml.XmlResolver%2CSystem.Security.Policy.Evidence%29>方法。</xref:System.Xml.Xsl.XslTransform.Load%28System.Xml.XPath.XPathNavigator%2CSystem.Xml.XmlResolver%2CSystem.Security.Policy.Evidence%29> 有关问题<xref:System.Xml.Xsl.XslTransform.Load%2A>方法和样式表与嵌入的脚本，请参阅文章 Q316755 http://support.microsoft.com 在 Microsoft 知识库。</xref:System.Xml.Xsl.XslTransform.Load%2A>      1> [!NOTE]&1;> 如果调用方不具有`UnmanagedCode`权限，嵌入的脚本未编译和<xref:System.Security.SecurityException>引发。</xref:System.Security.SecurityException> 请参阅<xref:System.Security.Permissions.SecurityPermission>和<xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>有关详细信息。</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.Security.Permissions.SecurityPermission>"
  syntax:
    content: public void Load (System.Xml.XPath.XPathNavigator stylesheet);
    parameters:
    - id: stylesheet
      type: System.Xml.XPath.XPathNavigator
      description: "<xref href=&quot;System.Xml.XPath.XPathNavigator&quot;> </xref>对象，其中包含的 XSLT 样式表。"
  overload: System.Xml.Xsl.XslTransform.Load*
  exceptions:
  - type: System.Xml.Xsl.XsltCompileException
    commentId: T:System.Xml.Xsl.XsltCompileException
    description: "当前节点不符合有效的样式表。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "样式表包含嵌入的脚本，并且调用方没有<xref uid=&quot;langword_csharp_UnmanagedCode&quot; name=&quot;UnmanagedCode&quot; href=&quot;&quot;></xref>权限。"
  platform:
  - net462
- uid: System.Xml.Xsl.XslTransform.Load(System.String,System.Xml.XmlResolver)
  id: Load(System.String,System.Xml.XmlResolver)
  parent: System.Xml.Xsl.XslTransform
  langs:
  - csharp
  name: Load(String,XmlResolver)
  nameWithType: XslTransform.Load(String,XmlResolver)
  fullName: System.Xml.Xsl.XslTransform.Load(String,XmlResolver)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml.Xsl
  summary: "加载指定的 url 的 XSLT 样式表。"
  remarks: "> [!NOTE]1><xref:System.Xml.Xsl.XslTransform>类是.NET Framework 2.0 版中过时。</xref:System.Xml.Xsl.XslTransform> <xref:System.Xml.Xsl.XslCompiledTransform>类是新的 XSLT 处理器。</xref:System.Xml.Xsl.XslCompiledTransform> 有关详细信息，请参阅[使用 XslCompiledTransform 类](~/add/includes/ajax-current-ext-md.md)和[迁移从 XslTransform 类](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Xml.Xsl.XslTransform>支持的 XSLT 1.0 语法。</xref:System.Xml.Xsl.XslTransform> XSLT 样式表必须包括命名空间声明`xmlns:xsl= http://www.w3.org/1999/XSL/Transform`。       如果样式表包含嵌入的脚本，脚本将编译为程序集。 样式表的 URI 用于创建应用于程序集的证据。 有关问题<xref:System.Xml.Xsl.XslTransform.Load%2A>方法和样式表与嵌入的脚本，请参阅文章 Q316755 http://support.microsoft.com 在 Microsoft 知识库。</xref:System.Xml.Xsl.XslTransform.Load%2A>      1> [!NOTE]&1;> 如果调用方不具有`UnmanagedCode`权限，嵌入的脚本未编译和<xref:System.Security.SecurityException>引发。</xref:System.Security.SecurityException> 请参阅<xref:System.Security.Permissions.SecurityPermission>和<xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>有关详细信息。</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "The following example transforms an XML document into an HTML document. The example loads an XSLT style sheet which contains an `xsl:include` element referencing another style sheet. An <xref:System.Xml.XmlUrlResolver> is passed to the Load method which sets the credentials necessary to access the network resource for the included style sheet.  \n  \n [!code-vb[XslTransform.Load2#1](~/add/codesnippet/visualbasic/m-system.xml.xsl.xsltran_3_1.vb)]\n [!code-cs[XslTransform.Load2#1](~/add/codesnippet/csharp/m-system.xml.xsl.xsltran_3_1.cs)]  \n  \n The example uses the following data files as input.  \n  \n `books.xml`  \n  \n [!code-xml[XslTransform.Load2#2](~/add/codesnippet/xml/m-system.xml.xsl.xsltran_3_2.xml)]  \n  \n `sort.xsl`  \n  \n [!code-xml[XslTransform.Load2#3](~/add/codesnippet/xml/m-system.xml.xsl.xsltran_3_3.xsl)]  \n  \n `includefile.xsl`  \n  \n [!code-xml[XslTransform.Load2#4](~/add/codesnippet/xml/m-system.xml.xsl.xsltran_3_4.xsl)]"
  syntax:
    content: public void Load (string url, System.Xml.XmlResolver resolver);
    parameters:
    - id: url
      type: System.String
      description: "指定要加载的 XSLT 样式表的 URL。"
    - id: resolver
      type: System.Xml.XmlResolver
      description: "<xref href=&quot;System.Xml.XmlResolver&quot;> </xref>用于加载样式表和中引用的任何样式表`xsl:import`和`xsl:include`元素。       如果这是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，默认<xref href=&quot;System.Xml.XmlUrlResolver&quot;></xref>无用户凭据用于打开样式表。 默认值<xref href=&quot;System.Xml.XmlUrlResolver&quot;></xref>不用于解析在样式表中，任何外部资源，因此`xsl:import`和`xsl:include`元素未得到解决。       <xref href=&quot;System.Xml.XmlResolver&quot;> </xref>负载方法完成后不缓存。"
  overload: System.Xml.Xsl.XslTransform.Load*
  exceptions:
  - type: System.Xml.Xsl.XsltCompileException
    commentId: T:System.Xml.Xsl.XsltCompileException
    description: "加载的资源不是有效的样式表。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "样式表包含嵌入的脚本，并且调用方没有<xref uid=&quot;langword_csharp_UnmanagedCode&quot; name=&quot;UnmanagedCode&quot; href=&quot;&quot;></xref>权限。"
  platform:
  - net462
- uid: System.Xml.Xsl.XslTransform.Load(System.Xml.XmlReader,System.Xml.XmlResolver)
  id: Load(System.Xml.XmlReader,System.Xml.XmlResolver)
  parent: System.Xml.Xsl.XslTransform
  langs:
  - csharp
  name: Load(XmlReader,XmlResolver)
  nameWithType: XslTransform.Load(XmlReader,XmlResolver)
  fullName: System.Xml.Xsl.XslTransform.Load(XmlReader,XmlResolver)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml.Xsl
  summary: "加载<xref:System.Xml.XmlReader>.</xref:System.Xml.XmlReader>中包含的 XSLT 样式表"
  remarks: "> [!NOTE]1><xref:System.Xml.Xsl.XslTransform>类是.NET Framework 2.0 版中过时。</xref:System.Xml.Xsl.XslTransform> <xref:System.Xml.Xsl.XslCompiledTransform>类是新的 XSLT 处理器。</xref:System.Xml.Xsl.XslCompiledTransform> 有关详细信息，请参阅[使用 XslCompiledTransform 类](~/add/includes/ajax-current-ext-md.md)和[迁移从 XslTransform 类](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Xml.Xsl.XslTransform>支持的 XSLT 1.0 语法。</xref:System.Xml.Xsl.XslTransform> XSLT 样式表必须包括命名空间声明`xmlns:xsl= http://www.w3.org/1999/XSL/Transform`。       此方法将 XSLT 样式表，包括任何引用中的样式表加载`xsl:include`和`xsl:import`元素。 从当前节点的加载样式表<xref:System.Xml.XmlReader>通过其所有子级。</xref:System.Xml.XmlReader> 这使您要用作样式表文档的一部分。       Load 方法返回后，则<xref:System.Xml.XmlReader>样式表末尾后定位到下一个节点。</xref:System.Xml.XmlReader> 如果已到达文档结尾，<xref:System.Xml.XmlReader>将位于文件结尾 (EOF)。</xref:System.Xml.XmlReader>       如果样式表包含实体，你应指定<xref:System.Xml.XmlReader>可以解析实体 (<xref:System.Xml.XmlReader.CanResolveEntity%2A?displayProperty=fullName>返回`true`)。</xref:System.Xml.XmlReader.CanResolveEntity%2A?displayProperty=fullName> </xref:System.Xml.XmlReader> 在这种情况下，<xref:System.Xml.XmlValidatingReader>可用。</xref:System.Xml.XmlValidatingReader>       如果样式表包含嵌入的脚本，脚本将编译为程序集。 程序集具有完全信任。 建议的做法是提供证据使用<xref:System.Xml.Xsl.XslTransform.Load%28System.Xml.XmlReader%2CSystem.Xml.XmlResolver%2CSystem.Security.Policy.Evidence%29>方法。</xref:System.Xml.Xsl.XslTransform.Load%28System.Xml.XmlReader%2CSystem.Xml.XmlResolver%2CSystem.Security.Policy.Evidence%29> 有关问题<xref:System.Xml.Xsl.XslTransform.Load%2A>方法和样式表与嵌入的脚本，请参阅文章 Q316755 http://support.microsoft.com 在 Microsoft 知识库。</xref:System.Xml.Xsl.XslTransform.Load%2A>      1> [!NOTE]&1;> 如果调用方不具有`UnmanagedCode`权限，嵌入的脚本未编译和<xref:System.Security.SecurityException>引发。</xref:System.Security.SecurityException> 请参阅<xref:System.Security.Permissions.SecurityPermission>和<xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>有关详细信息。</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.Security.Permissions.SecurityPermission>"
  syntax:
    content: public void Load (System.Xml.XmlReader stylesheet, System.Xml.XmlResolver resolver);
    parameters:
    - id: stylesheet
      type: System.Xml.XmlReader
      description: "<xref:System.Xml.XmlReader>对象，其中包含的 XSLT 样式表。</xref:System.Xml.XmlReader>"
    - id: resolver
      type: System.Xml.XmlResolver
      description: "<xref href=&quot;System.Xml.XmlResolver&quot;> </xref>用于加载引用中的所有样式表`xsl:import`和`xsl:include`元素。 如果这是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，则不解析外部资源。       <xref href=&quot;System.Xml.XmlResolver&quot;> </xref>负载方法完成后不缓存。"
  overload: System.Xml.Xsl.XslTransform.Load*
  exceptions:
  - type: System.Xml.Xsl.XsltCompileException
    commentId: T:System.Xml.Xsl.XsltCompileException
    description: "当前节点不符合有效的样式表。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "样式表包含嵌入的脚本，并且调用方没有<xref uid=&quot;langword_csharp_UnmanagedCode&quot; name=&quot;UnmanagedCode&quot; href=&quot;&quot;></xref>权限。"
  platform:
  - net462
- uid: System.Xml.Xsl.XslTransform.Load(System.Xml.XPath.IXPathNavigable,System.Xml.XmlResolver)
  id: Load(System.Xml.XPath.IXPathNavigable,System.Xml.XmlResolver)
  parent: System.Xml.Xsl.XslTransform
  langs:
  - csharp
  name: Load(IXPathNavigable,XmlResolver)
  nameWithType: XslTransform.Load(IXPathNavigable,XmlResolver)
  fullName: System.Xml.Xsl.XslTransform.Load(IXPathNavigable,XmlResolver)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml.Xsl
  summary: "加载 XSL 样式表中包含<xref href=&quot;System.Xml.XPath.IXPathNavigable&quot;> </xref>。"
  remarks: "> [!NOTE]1><xref:System.Xml.Xsl.XslTransform>类是.NET Framework 2.0 版中过时。</xref:System.Xml.Xsl.XslTransform> <xref:System.Xml.Xsl.XslCompiledTransform>类是新的 XSLT 处理器。</xref:System.Xml.Xsl.XslCompiledTransform> 有关详细信息，请参阅[使用 XslCompiledTransform 类](~/add/includes/ajax-current-ext-md.md)和[迁移从 XslTransform 类](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Xml.Xsl.XslTransform>支持的 XSLT 1.0 语法。</xref:System.Xml.Xsl.XslTransform> XSLT 样式表必须包括命名空间声明`xmlns:xsl= http://www.w3.org/1999/XSL/Transform`。       如果样式表包含嵌入的脚本，脚本将编译为程序集。 程序集具有完全信任。 建议的做法是提供证据使用<xref:System.Xml.Xsl.XslTransform.Load%28System.Xml.XPath.IXPathNavigable%2CSystem.Xml.XmlResolver%2CSystem.Security.Policy.Evidence%29>方法。</xref:System.Xml.Xsl.XslTransform.Load%28System.Xml.XPath.IXPathNavigable%2CSystem.Xml.XmlResolver%2CSystem.Security.Policy.Evidence%29> 有关问题<xref:System.Xml.Xsl.XslTransform.Load%2A>方法和样式表与嵌入的脚本，请参阅文章 Q316755 http://support.microsoft.com 在 Microsoft 知识库。</xref:System.Xml.Xsl.XslTransform.Load%2A>      1> [!NOTE]&1;> 如果调用方不具有`UnmanagedCode`权限，嵌入的脚本未编译和<xref:System.Security.SecurityException>引发。</xref:System.Security.SecurityException> 请参阅<xref:System.Security.Permissions.SecurityPermission>和<xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>有关详细信息。</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.Security.Permissions.SecurityPermission>"
  syntax:
    content: public void Load (System.Xml.XPath.IXPathNavigable stylesheet, System.Xml.XmlResolver resolver);
    parameters:
    - id: stylesheet
      type: System.Xml.XPath.IXPathNavigable
      description: "一个对象，实现<xref href=&quot;System.Xml.XPath.IXPathNavigable&quot;></xref>接口。 在.NET Framework 中，这可能是<xref href=&quot;System.Xml.XmlNode&quot;> </xref> (通常<xref href=&quot;System.Xml.XmlDocument&quot;> </xref>)，或<xref href=&quot;System.Xml.XPath.XPathDocument&quot;></xref>包含 XSLT 样式表。"
    - id: resolver
      type: System.Xml.XmlResolver
      description: "<xref href=&quot;System.Xml.XmlResolver&quot;> </xref>用于加载引用中的所有样式表`xsl:import`和`xsl:include`元素。 如果这是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，则不解析外部资源。       <xref href=&quot;System.Xml.XmlResolver&quot;> </xref>后不缓存<xref:System.Xml.Xsl.XslTransform.Load*>方法完成。</xref:System.Xml.Xsl.XslTransform.Load*>"
  overload: System.Xml.Xsl.XslTransform.Load*
  exceptions:
  - type: System.Xml.Xsl.XsltCompileException
    commentId: T:System.Xml.Xsl.XsltCompileException
    description: "加载的资源不是有效的样式表。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "样式表包含嵌入的脚本，并且调用方没有<xref uid=&quot;langword_csharp_UnmanagedCode&quot; name=&quot;UnmanagedCode&quot; href=&quot;&quot;></xref>权限。"
  platform:
  - net462
- uid: System.Xml.Xsl.XslTransform.Load(System.Xml.XPath.XPathNavigator,System.Xml.XmlResolver)
  id: Load(System.Xml.XPath.XPathNavigator,System.Xml.XmlResolver)
  parent: System.Xml.Xsl.XslTransform
  langs:
  - csharp
  name: Load(XPathNavigator,XmlResolver)
  nameWithType: XslTransform.Load(XPathNavigator,XmlResolver)
  fullName: System.Xml.Xsl.XslTransform.Load(XPathNavigator,XmlResolver)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml.Xsl
  summary: "加载 XSL 样式表中包含<xref href=&quot;System.Xml.XPath.XPathNavigator&quot;> </xref>。"
  remarks: "> [!NOTE]1><xref:System.Xml.Xsl.XslTransform>类是.NET Framework 2.0 版中过时。</xref:System.Xml.Xsl.XslTransform> <xref:System.Xml.Xsl.XslCompiledTransform>类是新的 XSLT 处理器。</xref:System.Xml.Xsl.XslCompiledTransform> 有关详细信息，请参阅[使用 XslCompiledTransform 类](~/add/includes/ajax-current-ext-md.md)和[迁移从 XslTransform 类](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Xml.Xsl.XslTransform>支持的 XSLT 1.0 语法。</xref:System.Xml.Xsl.XslTransform> XSLT 样式表必须包括命名空间声明`xmlns:xsl= http://www.w3.org/1999/XSL/Transform`。       从当前的<xref:System.Xml.XPath.XPathNavigator>。</xref:System.Xml.XPath.XPathNavigator>位置加载样式表 若要使用与样式表加载文档的一部分，导航到样式表的开头相对应的节点。 Load 方法返回后，<xref:System.Xml.XPath.XPathNavigator>位于开头的样式表 (上`xsl:style sheet`节点)。</xref:System.Xml.XPath.XPathNavigator>       如果样式表包含嵌入的脚本，脚本将编译为程序集。 程序集具有完全信任。 建议的做法是提供证据使用<xref:System.Xml.Xsl.XslTransform.Load%28System.Xml.XPath.XPathNavigator%2CSystem.Xml.XmlResolver%2CSystem.Security.Policy.Evidence%29>.</xref:System.Xml.Xsl.XslTransform.Load%28System.Xml.XPath.XPathNavigator%2CSystem.Xml.XmlResolver%2CSystem.Security.Policy.Evidence%29> 有关问题<xref:System.Xml.Xsl.XslTransform.Load%2A>方法和样式表与嵌入的脚本，请参阅文章 Q316755 http://support.microsoft.com 在 Microsoft 知识库。</xref:System.Xml.Xsl.XslTransform.Load%2A>      1> [!NOTE]&1;> 如果调用方不具有`UnmanagedCode`权限，嵌入的脚本未编译和<xref:System.Security.SecurityException>引发。</xref:System.Security.SecurityException> 请参阅<xref:System.Security.Permissions.SecurityPermission>和<xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>有关详细信息。</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.Security.Permissions.SecurityPermission>"
  syntax:
    content: public void Load (System.Xml.XPath.XPathNavigator stylesheet, System.Xml.XmlResolver resolver);
    parameters:
    - id: stylesheet
      type: System.Xml.XPath.XPathNavigator
      description: "<xref href=&quot;System.Xml.XPath.XPathNavigator&quot;> </xref>对象，其中包含的 XSLT 样式表。"
    - id: resolver
      type: System.Xml.XmlResolver
      description: "<xref href=&quot;System.Xml.XmlResolver&quot;> </xref>用于加载引用中的所有样式表`xsl:import`和`xsl:include`元素。 如果这是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，则不解析外部资源。       <xref href=&quot;System.Xml.XmlResolver&quot;> </xref>后不缓存<xref:System.Xml.Xsl.XslTransform.Load*>方法完成。</xref:System.Xml.Xsl.XslTransform.Load*>"
  overload: System.Xml.Xsl.XslTransform.Load*
  exceptions:
  - type: System.Xml.Xsl.XsltCompileException
    commentId: T:System.Xml.Xsl.XsltCompileException
    description: "当前节点不符合有效的样式表。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "样式表包含嵌入的脚本，并且调用方没有<xref uid=&quot;langword_csharp_UnmanagedCode&quot; name=&quot;UnmanagedCode&quot; href=&quot;&quot;></xref>权限。"
  platform:
  - net462
- uid: System.Xml.Xsl.XslTransform.Load(System.Xml.XmlReader,System.Xml.XmlResolver,System.Security.Policy.Evidence)
  id: Load(System.Xml.XmlReader,System.Xml.XmlResolver,System.Security.Policy.Evidence)
  parent: System.Xml.Xsl.XslTransform
  langs:
  - csharp
  name: Load(XmlReader,XmlResolver,Evidence)
  nameWithType: XslTransform.Load(XmlReader,XmlResolver,Evidence)
  fullName: System.Xml.Xsl.XslTransform.Load(XmlReader,XmlResolver,Evidence)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml.Xsl
  summary: "加载<xref:System.Xml.XmlReader>.</xref:System.Xml.XmlReader>中包含的 XSLT 样式表 此方法，可通过指定证据来限制样式表的权限。"
  remarks: "> [!NOTE]1><xref:System.Xml.Xsl.XslTransform>类是.NET Framework 2.0 版中过时。</xref:System.Xml.Xsl.XslTransform> <xref:System.Xml.Xsl.XslCompiledTransform>类是新的 XSLT 处理器。</xref:System.Xml.Xsl.XslCompiledTransform> 有关详细信息，请参阅[使用 XslCompiledTransform 类](~/add/includes/ajax-current-ext-md.md)和[迁移从 XslTransform 类](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Xml.Xsl.XslTransform>支持的 XSLT 1.0 语法。</xref:System.Xml.Xsl.XslTransform> XSLT 样式表必须包括命名空间声明`xmlns:xsl= http://www.w3.org/1999/XSL/Transform`。       此方法将 XSLT 样式表，包括任何引用中的样式表加载`xsl:include`和`xsl:import`元素。 从当前节点的加载样式表<xref:System.Xml.XmlReader>通过其所有子级。</xref:System.Xml.XmlReader> 这使您要用作样式表文档的一部分。       Load 方法返回后，则<xref:System.Xml.XmlReader>样式表末尾后定位到下一个节点。</xref:System.Xml.XmlReader> 如果已到达文档结尾，<xref:System.Xml.XmlReader>将位于文件结尾 (EOF)。</xref:System.Xml.XmlReader>       如果样式表包含实体，你应指定<xref:System.Xml.XmlReader>可以解析实体 (<xref:System.Xml.XmlReader.CanResolveEntity%2A?displayProperty=fullName>返回`true`)。</xref:System.Xml.XmlReader.CanResolveEntity%2A?displayProperty=fullName> </xref:System.Xml.XmlReader> 在这种情况下，<xref:System.Xml.XmlValidatingReader>可用。</xref:System.Xml.XmlValidatingReader>       有关问题<xref:System.Xml.Xsl.XslTransform.Load%2A>方法和样式表与嵌入的脚本，请参阅文章 Q316755 http://support.microsoft.com 在 Microsoft 知识库。</xref:System.Xml.Xsl.XslTransform.Load%2A>       有不同的方法，以便提供的证据。 下表介绍常见的用户方案提供证据的类型。"
  example:
  - "The following example performs an XSLT transformation where `xsltReader` is an <xref:System.Xml.XmlReader> containing a style sheet and `secureURL` is a trusted URL that can be used to create <xref:System.Security.Policy.Evidence>. The <xref:System.Xml.XmlSecureResolver.CreateEvidenceForUrl%2A?displayProperty=fullName> method is used to create <xref:System.Security.Policy.Evidence> which is applied to the style sheet.  \n  \n [!code-vb[XslTransform.Load4#1](~/add/codesnippet/visualbasic/a033551f-1c0f-4994-8153-_1.vb)]\n [!code-cs[XslTransform.Load4#1](~/add/codesnippet/csharp/a033551f-1c0f-4994-8153-_1.cs)]\n [!code-cpp[XslTransform.Load4#1](~/add/codesnippet/cpp/a033551f-1c0f-4994-8153-_1.cpp)]"
  syntax:
    content: public void Load (System.Xml.XmlReader stylesheet, System.Xml.XmlResolver resolver, System.Security.Policy.Evidence evidence);
    parameters:
    - id: stylesheet
      type: System.Xml.XmlReader
      description: "<xref:System.Xml.XmlReader>对象，其中包含要加载的样式表。</xref:System.Xml.XmlReader>"
    - id: resolver
      type: System.Xml.XmlResolver
      description: "<xref href=&quot;System.Xml.XmlResolver&quot;> </xref>用于加载引用中的所有样式表`xsl:import`和`xsl:include`元素。 如果这是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，则不解析外部资源。       <xref href=&quot;System.Xml.XmlResolver&quot;> </xref>后不缓存<xref:System.Xml.Xsl.XslTransform.Load*>方法完成。</xref:System.Xml.Xsl.XslTransform.Load*>"
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "<xref href=&quot;System.Security.Policy.Evidence&quot;> </xref>在 XSLT 样式表中的脚本块生成的程序集上设置。       如果这是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，脚本块并不是处理，XSLT`document()`函数不受支持，并且不允许特权的扩展对象。       调用方必须具有<xref uid=&quot;langword_csharp_ControlEvidence&quot; name=&quot;ControlEvidence&quot; href=&quot;&quot;></xref>权限才能提供用于脚本程序集的证据。 不完全受信任的调用方可以将此参数设置为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Xml.Xsl.XslTransform.Load*
  exceptions:
  - type: System.Xml.Xsl.XsltCompileException
    commentId: T:System.Xml.Xsl.XsltCompileException
    description: "当前节点不符合有效的样式表。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "引用的样式表要求不允许通过提供的证据的功能。       调用方尝试提供证据，而未<xref uid=&quot;langword_csharp_ControlEvidence&quot; name=&quot;ControlEvidence&quot; href=&quot;&quot;></xref>权限。"
  platform:
  - net462
- uid: System.Xml.Xsl.XslTransform.Load(System.Xml.XPath.IXPathNavigable,System.Xml.XmlResolver,System.Security.Policy.Evidence)
  id: Load(System.Xml.XPath.IXPathNavigable,System.Xml.XmlResolver,System.Security.Policy.Evidence)
  parent: System.Xml.Xsl.XslTransform
  langs:
  - csharp
  name: Load(IXPathNavigable,XmlResolver,Evidence)
  nameWithType: XslTransform.Load(IXPathNavigable,XmlResolver,Evidence)
  fullName: System.Xml.Xsl.XslTransform.Load(IXPathNavigable,XmlResolver,Evidence)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml.Xsl
  summary: "加载 XSL 样式表中包含<xref href=&quot;System.Xml.XPath.IXPathNavigable&quot;> </xref>。 此方法，可通过指定证据来限制样式表的权限。"
  remarks: "> [!NOTE]1><xref:System.Xml.Xsl.XslTransform>类是.NET Framework 2.0 版中过时。</xref:System.Xml.Xsl.XslTransform> <xref:System.Xml.Xsl.XslCompiledTransform>类是新的 XSLT 处理器。</xref:System.Xml.Xsl.XslCompiledTransform> 有关详细信息，请参阅[使用 XslCompiledTransform 类](~/add/includes/ajax-current-ext-md.md)和[迁移从 XslTransform 类](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Xml.Xsl.XslTransform>支持的 XSLT 1.0 语法。</xref:System.Xml.Xsl.XslTransform> XSLT 样式表必须包括命名空间声明`xmlns:xsl= http://www.w3.org/1999/XSL/Transform`。       有关问题<xref:System.Xml.Xsl.XslTransform.Load%2A>方法和样式表与嵌入的脚本，请参阅文章 Q316755 http://support.microsoft.com 在 Microsoft 知识库。</xref:System.Xml.Xsl.XslTransform.Load%2A>       有不同的方法，以便提供的证据。 下表介绍常见的用户方案提供证据的类型。"
  syntax:
    content: public void Load (System.Xml.XPath.IXPathNavigable stylesheet, System.Xml.XmlResolver resolver, System.Security.Policy.Evidence evidence);
    parameters:
    - id: stylesheet
      type: System.Xml.XPath.IXPathNavigable
      description: "一个对象，实现<xref href=&quot;System.Xml.XPath.IXPathNavigable&quot;></xref>接口。 在.NET Framework 中，这可能是<xref href=&quot;System.Xml.XmlNode&quot;> </xref> (通常<xref href=&quot;System.Xml.XmlDocument&quot;> </xref>)，或<xref href=&quot;System.Xml.XPath.XPathDocument&quot;></xref>包含 XSLT 样式表。"
    - id: resolver
      type: System.Xml.XmlResolver
      description: "<xref href=&quot;System.Xml.XmlResolver&quot;> </xref>用于加载引用中的所有样式表`xsl:import`和`xsl:include`元素。 如果这是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，则不解析外部资源。       <xref href=&quot;System.Xml.XmlResolver&quot;> </xref>后不缓存<xref:System.Xml.Xsl.XslTransform.Load*>方法完成。</xref:System.Xml.Xsl.XslTransform.Load*>"
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "<xref href=&quot;System.Security.Policy.Evidence&quot;> </xref>在 XSLT 样式表中的脚本块生成的程序集上设置。       如果这是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，脚本块并不是处理，XSLT`document()`函数不受支持，并且不允许特权的扩展对象。       调用方必须具有<xref uid=&quot;langword_csharp_ControlEvidence&quot; name=&quot;ControlEvidence&quot; href=&quot;&quot;></xref>权限才能提供用于脚本程序集的证据。 不完全受信任的调用方可以将此参数设置为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Xml.Xsl.XslTransform.Load*
  exceptions:
  - type: System.Xml.Xsl.XsltCompileException
    commentId: T:System.Xml.Xsl.XsltCompileException
    description: "加载的资源不是有效的样式表。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "引用的样式表要求不允许通过提供的证据的功能。       调用方尝试提供证据，而未<xref uid=&quot;langword_csharp_ControlEvidence&quot; name=&quot;ControlEvidence&quot; href=&quot;&quot;></xref>权限。"
  platform:
  - net462
- uid: System.Xml.Xsl.XslTransform.Load(System.Xml.XPath.XPathNavigator,System.Xml.XmlResolver,System.Security.Policy.Evidence)
  id: Load(System.Xml.XPath.XPathNavigator,System.Xml.XmlResolver,System.Security.Policy.Evidence)
  parent: System.Xml.Xsl.XslTransform
  langs:
  - csharp
  name: Load(XPathNavigator,XmlResolver,Evidence)
  nameWithType: XslTransform.Load(XPathNavigator,XmlResolver,Evidence)
  fullName: System.Xml.Xsl.XslTransform.Load(XPathNavigator,XmlResolver,Evidence)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml.Xsl
  summary: "加载 XSL 样式表中包含<xref href=&quot;System.Xml.XPath.XPathNavigator&quot;> </xref>。 此方法，可通过指定证据来限制样式表的权限。"
  remarks: "> [!NOTE]1><xref:System.Xml.Xsl.XslTransform>类是.NET Framework 2.0 版中过时。</xref:System.Xml.Xsl.XslTransform> <xref:System.Xml.Xsl.XslCompiledTransform>类是新的 XSLT 处理器。</xref:System.Xml.Xsl.XslCompiledTransform> 有关详细信息，请参阅[使用 XslCompiledTransform 类](~/add/includes/ajax-current-ext-md.md)和[迁移从 XslTransform 类](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Xml.Xsl.XslTransform>支持的 XSLT 1.0 语法。</xref:System.Xml.Xsl.XslTransform> XSLT 样式表必须包括命名空间声明`xmlns:xsl= http://www.w3.org/1999/XSL/Transform`。       从当前的<xref:System.Xml.XPath.XPathNavigator>。</xref:System.Xml.XPath.XPathNavigator>位置加载样式表 若要使用与样式表加载文档的一部分，导航到样式表的开头相对应的节点。 Load 方法返回后，<xref:System.Xml.XPath.XPathNavigator>位于开头的样式表 (上`xsl:style sheet`节点)。</xref:System.Xml.XPath.XPathNavigator>       有关问题<xref:System.Xml.Xsl.XslTransform.Load%2A>方法和样式表与嵌入的脚本，请参阅文章 Q316755 http://support.microsoft.com 在 Microsoft 知识库。</xref:System.Xml.Xsl.XslTransform.Load%2A>       有不同的方法，以便提供的证据。 下表介绍常见的用户方案提供证据的类型。"
  example:
  - "The following example performs an XSLT transformation using a style sheet from an outside source. Because the style sheet comes from an untrusted source, the `resolver` and `evidence` parameters are set to `null`.  \n  \n [!code-cs[XslTransform.Load5#1](~/add/codesnippet/csharp/3ff68c6b-cad3-409a-909a-_1.cs)]\n [!code-vb[XslTransform.Load5#1](~/add/codesnippet/visualbasic/3ff68c6b-cad3-409a-909a-_1.vb)]"
  syntax:
    content: public void Load (System.Xml.XPath.XPathNavigator stylesheet, System.Xml.XmlResolver resolver, System.Security.Policy.Evidence evidence);
    parameters:
    - id: stylesheet
      type: System.Xml.XPath.XPathNavigator
      description: "<xref href=&quot;System.Xml.XPath.XPathNavigator&quot;> </xref>对象，其中包含要加载的样式表。"
    - id: resolver
      type: System.Xml.XmlResolver
      description: "<xref href=&quot;System.Xml.XmlResolver&quot;> </xref>用于加载引用中的所有样式表`xsl:import`和`xsl:include`元素。 如果这是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，则不解析外部资源。       <xref href=&quot;System.Xml.XmlResolver&quot;> </xref>后不缓存<xref:System.Xml.Xsl.XslTransform.Load*>方法完成。</xref:System.Xml.Xsl.XslTransform.Load*>"
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "<xref href=&quot;System.Security.Policy.Evidence&quot;> </xref>在 XSLT 样式表中的脚本块生成的程序集上设置。       如果这是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，脚本块并不是处理，XSLT`document()`函数不受支持，并且不允许特权的扩展对象。       调用方必须具有<xref uid=&quot;langword_csharp_ControlEvidence&quot; name=&quot;ControlEvidence&quot; href=&quot;&quot;></xref>权限才能提供用于脚本程序集的证据。 不完全受信任的调用方可以将此参数设置为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Xml.Xsl.XslTransform.Load*
  exceptions:
  - type: System.Xml.Xsl.XsltCompileException
    commentId: T:System.Xml.Xsl.XsltCompileException
    description: "当前节点不符合有效的样式表。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "引用的样式表要求不允许通过提供的证据的功能。       调用方尝试提供证据，而未<xref uid=&quot;langword_csharp_ControlEvidence&quot; name=&quot;ControlEvidence&quot; href=&quot;&quot;></xref>权限。"
  platform:
  - net462
- uid: System.Xml.Xsl.XslTransform.Transform(System.String,System.String)
  id: Transform(System.String,System.String)
  parent: System.Xml.Xsl.XslTransform
  langs:
  - csharp
  name: Transform(String,String)
  nameWithType: XslTransform.Transform(String,String)
  fullName: System.Xml.Xsl.XslTransform.Transform(String,String)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml.Xsl
  summary: "转换输入文件中的 XML 数据并将输出结果发送到输出文件。"
  remarks: "> [!NOTE]1><xref:System.Xml.Xsl.XslTransform>类是.NET Framework 2.0 版中过时。</xref:System.Xml.Xsl.XslTransform> <xref:System.Xml.Xsl.XslCompiledTransform>类是新的 XSLT 处理器。</xref:System.Xml.Xsl.XslCompiledTransform> 有关详细信息，请参阅[使用 XslCompiledTransform 类](~/add/includes/ajax-current-ext-md.md)和[迁移从 XslTransform 类](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Xml.Xsl.XslTransform>支持的 XSLT 1.0 语法。</xref:System.Xml.Xsl.XslTransform> XSLT 样式表必须包括命名空间声明`xmlns:xsl= http://www.w3.org/1999/XSL/Transform`。      1> [!NOTE] 1> 此方法已过时的.NET framework 版本 1.1 中。 设置<xref:System.Xml.Xsl.XslTransform.XmlResolver%2A>属性确定如何 XSLT`document()`函数处于已解决状态。</xref:System.Xml.Xsl.XslTransform.XmlResolver%2A> 建议的做法是使用<xref:System.Xml.Xsl.XslTransform.Transform%2A>该方法使用<xref:System.Xml.XmlResolver>对象作为其自变量之一。</xref:System.Xml.XmlResolver> </xref:System.Xml.Xsl.XslTransform.Transform%2A>"
  example:
  - "The following example transforms the `books.xml` file using the `output.xsl` style sheet and outputs the results to the `books.html` file.  \n  \n [!code-cs[XslTransform.Transform3#1](~/add/codesnippet/csharp/m-system.xml.xsl.xsltran_2_1.cs)]\n [!code-cpp[XslTransform.Transform3#1](~/add/codesnippet/cpp/m-system.xml.xsl.xsltran_2_1.cpp)]\n [!code-vb[XslTransform.Transform3#1](~/add/codesnippet/visualbasic/m-system.xml.xsl.xsltran_2_1.vb)]  \n  \n The sample uses the following two input files:  \n  \n `books.xml`  \n  \n [!code-xml[Classic WebData XslTransform.Transform7 Example#2](~/add/codesnippet/xml/m-system.xml.xsl.xsltran_2_2.xml)]  \n  \n `output.xsl`  \n  \n [!code-xml[Classic WebData XslTransform.Transform7 Example#3](~/add/codesnippet/xml/m-system.xml.xsl.xsltran_2_3.xsl)]"
  syntax:
    content: public void Transform (string inputfile, string outputfile);
    parameters:
    - id: inputfile
      type: System.String
      description: "要转换的源文档的 URL。"
    - id: outputfile
      type: System.String
      description: "输出文件的 URL。"
  overload: System.Xml.Xsl.XslTransform.Transform*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList)
  id: Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList)
  parent: System.Xml.Xsl.XslTransform
  langs:
  - csharp
  name: Transform(IXPathNavigable,XsltArgumentList)
  nameWithType: XslTransform.Transform(IXPathNavigable,XsltArgumentList)
  fullName: System.Xml.Xsl.XslTransform.Transform(IXPathNavigable,XsltArgumentList)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml.Xsl
  summary: "转换中的 XML 数据<xref href=&quot;System.Xml.XPath.IXPathNavigable&quot;></xref>使用指定<code> args </code>并输出到<xref:System.Xml.XmlReader>。</xref:System.Xml.XmlReader>结果"
  remarks: "> [!NOTE]1><xref:System.Xml.Xsl.XslTransform>类是.NET Framework 2.0 版中过时。</xref:System.Xml.Xsl.XslTransform> <xref:System.Xml.Xsl.XslCompiledTransform>类是新的 XSLT 处理器。</xref:System.Xml.Xsl.XslCompiledTransform> 有关详细信息，请参阅[使用 XslCompiledTransform 类](~/add/includes/ajax-current-ext-md.md)和[迁移从 XslTransform 类](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Xml.Xsl.XslTransform>支持的 XSLT 1.0 语法。</xref:System.Xml.Xsl.XslTransform> XSLT 样式表必须包括命名空间声明`xmlns:xsl= http://www.w3.org/1999/XSL/Transform`。      1> [!NOTE]&1;> 此方法现已过时。 设置<xref:System.Xml.Xsl.XslTransform.XmlResolver%2A>属性确定如何 XSLT`document()`函数处于已解决状态。</xref:System.Xml.Xsl.XslTransform.XmlResolver%2A> 建议的做法是使用<xref:System.Xml.Xsl.XslTransform.Transform%2A>该方法使用<xref:System.Xml.XmlResolver>对象作为其自变量之一。</xref:System.Xml.XmlResolver> </xref:System.Xml.Xsl.XslTransform.Transform%2A>       `args`与匹配`xsl:param`样式表中定义的元素。 `xsl:output`当你输出到不支持元素<xref:System.Xml.XmlReader>(`xsl:output`元素将被忽略)。</xref:System.Xml.XmlReader> 请参阅[XslTransform 的输出](~/add/includes/ajax-current-ext-md.md)有关详细信息。       此方法可以进行异步转换的源文档。       转换将应用于整个文档。 换而言之，如果您传入文档根节点以外的一个节点，则这不会阻止转换进程访问已加载文档的所有节点。 若要转换节点片段，必须创建<xref:System.Xml.XmlDocument>包含只是在节点片断并将其传递<xref:System.Xml.XmlDocument>对转换方法。</xref:System.Xml.XmlDocument> </xref:System.Xml.XmlDocument>       下面的示例对一个节点片段执行转换。      ```   XslTransform xslt = new XslTransform();        xslt.Load(&quot;print_root.xsl&quot;);   XmlDocument doc = new XmlDocument();   doc.Load(&quot;library.xml&quot;);   // Create a new document containing just the node fragment.   XmlNode testNode = doc.DocumentElement.FirstChild;    XmlDocument tmpDoc = new XmlDocument();    tmpDoc.LoadXml(testNode.OuterXml);   // Pass the document containing the node fragment    // to the Transform method.   Console.WriteLine(&quot;Passing &quot; + tmpDoc.OuterXml + &quot; to print_root.xsl&quot;);   xslt.Transform(tmpDoc, null, Console.Out);   ```该示例使用`library.xml`和`print_root.xsl`文件作为输入，并输出到控制台如下。      ```   Passing <book genre=&quot;novel&quot; ISBN=&quot;1-861001-57-5&quot;><title>Pride And Prejudice</title></book> to print_root.xsl    Root node is book.   ```       `library.xml`      ```   <library>     <book genre=&quot;novel&quot; ISBN=&quot;1-861001-57-5&quot;>        <title>Pride And Prejudice</title>     </book>     <book genre=&quot;novel&quot; ISBN=&quot;1-81920-21-2&quot;>        <title>Hook</title>     </book>   </library>   ```       `print_root.xsl`      ```   <style sheet version=&quot;1.0&quot; xmlns=&quot;http://www.w3.org/1999/XSL/Transform&quot; >     <output method=&quot;text&quot; />      <template match=&quot;/&quot;>        Root node is  <value-of select=&quot;local-name(//*[position() = 1])&quot; />      </template>   </style sheet>   ```"
  syntax:
    content: public System.Xml.XmlReader Transform (System.Xml.XPath.IXPathNavigable input, System.Xml.Xsl.XsltArgumentList args);
    parameters:
    - id: input
      type: System.Xml.XPath.IXPathNavigable
      description: "一个对象，实现<xref href=&quot;System.Xml.XPath.IXPathNavigable&quot;></xref>接口。 在.NET Framework 中，这可能是<xref href=&quot;System.Xml.XmlNode&quot;> </xref> (通常<xref href=&quot;System.Xml.XmlDocument&quot;> </xref>)，或<xref href=&quot;System.Xml.XPath.XPathDocument&quot;></xref>包含要转换的数据。"
    - id: args
      type: System.Xml.Xsl.XsltArgumentList
      description: "<xref href=&quot;System.Xml.Xsl.XsltArgumentList&quot;> </xref>包含用作转换输入的命名空间限定的自变量。"
    return:
      type: System.Xml.XmlReader
      description: "<xref:System.Xml.XmlReader>包含转换的结果。</xref:System.Xml.XmlReader>"
  overload: System.Xml.Xsl.XslTransform.Transform*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList)
  id: Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList)
  parent: System.Xml.Xsl.XslTransform
  langs:
  - csharp
  name: Transform(XPathNavigator,XsltArgumentList)
  nameWithType: XslTransform.Transform(XPathNavigator,XsltArgumentList)
  fullName: System.Xml.Xsl.XslTransform.Transform(XPathNavigator,XsltArgumentList)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml.Xsl
  summary: "转换中的 XML 数据<xref href=&quot;System.Xml.XPath.XPathNavigator&quot;></xref>使用指定<code> args </code>并输出到<xref:System.Xml.XmlReader>。</xref:System.Xml.XmlReader>结果"
  remarks: "> [!NOTE]1><xref:System.Xml.Xsl.XslTransform>类是.NET Framework 2.0 版中过时。</xref:System.Xml.Xsl.XslTransform> <xref:System.Xml.Xsl.XslCompiledTransform>类是新的 XSLT 处理器。</xref:System.Xml.Xsl.XslCompiledTransform> 有关详细信息，请参阅[使用 XslCompiledTransform 类](~/add/includes/ajax-current-ext-md.md)和[迁移从 XslTransform 类](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Xml.Xsl.XslTransform>支持的 XSLT 1.0 语法。</xref:System.Xml.Xsl.XslTransform> XSLT 样式表必须包括命名空间声明`xmlns:xsl= http://www.w3.org/1999/XSL/Transform`。       `args`与匹配`xsl:param`样式表中定义的元素。 转换选择将应用于整个文档。 换而言之，如果当前节点在文档根节点以外的一个节点树上设置的则这不会阻止转换进程访问已加载文档的所有节点。 在执行转换后，<xref:System.Xml.XPath.XPathNavigator>保留为其原始状态。</xref:System.Xml.XPath.XPathNavigator> 这意味着调用转换方法后，将该节点，这是当前转换过程之前，保持当前节点。       因为<xref:System.Xml.XmlReader>提供只读的输出，`xsl:output`元素将被忽略。</xref:System.Xml.XmlReader> 请参阅[XslTransform 的输出](~/add/includes/ajax-current-ext-md.md)有关详细信息。       此方法可以进行异步转换的源文档。      1> [!NOTE]&1;> 此方法已过时。 设置<xref:System.Xml.Xsl.XslTransform.XmlResolver%2A>属性确定如何 XSLT document （） 函数处于已解决状态。</xref:System.Xml.Xsl.XslTransform.XmlResolver%2A> 建议的做法是使用<xref:System.Xml.Xsl.XslTransform.Transform%2A>该方法使用<xref:System.Xml.XmlResolver>对象作为其自变量之一。</xref:System.Xml.XmlResolver> </xref:System.Xml.Xsl.XslTransform.Transform%2A>"
  syntax:
    content: public System.Xml.XmlReader Transform (System.Xml.XPath.XPathNavigator input, System.Xml.Xsl.XsltArgumentList args);
    parameters:
    - id: input
      type: System.Xml.XPath.XPathNavigator
      description: "<xref href=&quot;System.Xml.XPath.XPathNavigator&quot;> </xref>包含要转换的数据。"
    - id: args
      type: System.Xml.Xsl.XsltArgumentList
      description: "<xref href=&quot;System.Xml.Xsl.XsltArgumentList&quot;> </xref>包含用作转换输入的命名空间限定的自变量。"
    return:
      type: System.Xml.XmlReader
      description: "<xref:System.Xml.XmlReader>包含转换的结果。</xref:System.Xml.XmlReader>"
  overload: System.Xml.Xsl.XslTransform.Transform*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "处理 XSLT 转换时出错。       注意︰ 这是从早期版本的行为发生变化。 <xref href=&quot;System.Xml.Xsl.XsltException&quot;> </xref>如果你使用 Microsoft.NET Framework 版本 1.1 或更早版本，将引发。"
  platform:
  - net462
- uid: System.Xml.Xsl.XslTransform.Transform(System.String,System.String,System.Xml.XmlResolver)
  id: Transform(System.String,System.String,System.Xml.XmlResolver)
  parent: System.Xml.Xsl.XslTransform
  langs:
  - csharp
  name: Transform(String,String,XmlResolver)
  nameWithType: XslTransform.Transform(String,String,XmlResolver)
  fullName: System.Xml.Xsl.XslTransform.Transform(String,String,XmlResolver)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml.Xsl
  summary: "转换输入文件中的 XML 数据并将输出结果发送到输出文件。"
  remarks: "> [!NOTE]1><xref:System.Xml.Xsl.XslTransform>类是.NET Framework 2.0 版中过时。</xref:System.Xml.Xsl.XslTransform> <xref:System.Xml.Xsl.XslCompiledTransform>类是新的 XSLT 处理器。</xref:System.Xml.Xsl.XslCompiledTransform> 有关详细信息，请参阅[使用 XslCompiledTransform 类](~/add/includes/ajax-current-ext-md.md)和[迁移从 XslTransform 类](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Xml.Xsl.XslTransform>支持的 XSLT 1.0 语法。</xref:System.Xml.Xsl.XslTransform> XSLT 样式表必须包括命名空间声明`xmlns:xsl= http://www.w3.org/1999/XSL/Transform`。"
  example:
  - "The following example performs an XSLT transformation and outputs to a file. An <xref:System.Xml.XmlUrlResolver> with default credentials is used resolve an external resources. See <xref:System.Net.CredentialCache.DefaultCredentials%2A> for details.  \n  \n [!code-cs[XslTransform.Transform7#1](~/add/codesnippet/csharp/86f1726f-f5ec-4750-8359-_1.cs)]\n [!code-vb[XslTransform.Transform7#1](~/add/codesnippet/visualbasic/86f1726f-f5ec-4750-8359-_1.vb)]\n [!code-cpp[XslTransform.Transform7#1](~/add/codesnippet/cpp/86f1726f-f5ec-4750-8359-_1.cpp)]"
  syntax:
    content: public void Transform (string inputfile, string outputfile, System.Xml.XmlResolver resolver);
    parameters:
    - id: inputfile
      type: System.String
      description: "要转换的源文档的 URL。"
    - id: outputfile
      type: System.String
      description: "输出文件的 URL。"
    - id: resolver
      type: System.Xml.XmlResolver
      description: "<xref href=&quot;System.Xml.XmlResolver&quot;> </xref>用于解析 XSLT`document()`函数。 如果这是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>、`document()`函数未得到解决。       <xref href=&quot;System.Xml.XmlResolver&quot;> </xref>后不缓存<xref:System.Xml.Xsl.XslTransform.Transform*>方法完成。</xref:System.Xml.Xsl.XslTransform.Transform*>"
  overload: System.Xml.Xsl.XslTransform.Transform*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList,System.IO.Stream)
  id: Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList,System.IO.Stream)
  parent: System.Xml.Xsl.XslTransform
  langs:
  - csharp
  name: Transform(IXPathNavigable,XsltArgumentList,Stream)
  nameWithType: XslTransform.Transform(IXPathNavigable,XsltArgumentList,Stream)
  fullName: System.Xml.Xsl.XslTransform.Transform(IXPathNavigable,XsltArgumentList,Stream)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml.Xsl
  summary: "转换中的 XML 数据<xref href=&quot;System.Xml.XPath.IXPathNavigable&quot;></xref>使用指定<code> args </code>并将结果输出到一种<xref:System.IO.Stream>。</xref:System.IO.Stream>"
  remarks: "> [!NOTE]1><xref:System.Xml.Xsl.XslTransform>类是.NET Framework 2.0 版中过时。</xref:System.Xml.Xsl.XslTransform> <xref:System.Xml.Xsl.XslCompiledTransform>类是新的 XSLT 处理器。</xref:System.Xml.Xsl.XslCompiledTransform> 有关详细信息，请参阅[使用 XslCompiledTransform 类](~/add/includes/ajax-current-ext-md.md)和[迁移从 XslTransform 类](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Xml.Xsl.XslTransform>支持的 XSLT 1.0 语法。</xref:System.Xml.Xsl.XslTransform> XSLT 样式表必须包括命名空间声明`xmlns:xsl= http://www.w3.org/1999/XSL/Transform`。      1> [!NOTE]&1;> 此方法现已过时。 设置<xref:System.Xml.Xsl.XslTransform.XmlResolver%2A>属性确定如何 XSLT`document()`函数处于已解决状态。</xref:System.Xml.Xsl.XslTransform.XmlResolver%2A> 建议的做法是使用<xref:System.Xml.Xsl.XslTransform.Transform%2A>该方法使用<xref:System.Xml.XmlResolver>对象作为其自变量之一。</xref:System.Xml.XmlResolver> </xref:System.Xml.Xsl.XslTransform.Transform%2A>       `args`与匹配`xsl:param`样式表中定义的元素。       转换将应用于整个文档。 换而言之，如果您传入文档根节点以外的一个节点，则这不会阻止转换进程访问已加载文档的所有节点。 若要转换节点片段，必须创建<xref:System.Xml.XmlDocument>包含只是在节点片断并将其传递<xref:System.Xml.XmlDocument>对转换方法。</xref:System.Xml.XmlDocument> </xref:System.Xml.XmlDocument>       下面的示例对一个节点片段执行转换。      ```   XslTransform xslt = new XslTransform();        xslt.Load(&quot;print_root.xsl&quot;);   XmlDocument doc = new XmlDocument();   doc.Load(&quot;library.xml&quot;);   // Create a new document containing just the node fragment.   XmlNode testNode = doc.DocumentElement.FirstChild;    XmlDocument tmpDoc = new XmlDocument();    tmpDoc.LoadXml(testNode.OuterXml);   // Pass the document containing the node fragment    // to the Transform method.   Console.WriteLine(&quot;Passing &quot; + tmpDoc.OuterXml + &quot; to print_root.xsl&quot;);   xslt.Transform(tmpDoc, null, Console.Out);   ```该示例使用`library.xml`和`print_root.xsl`文件作为输入，并输出到控制台如下。      ```   Passing <book genre=&quot;novel&quot; ISBN=&quot;1-861001-57-5&quot;><title>Pride And Prejudice</title></book> to print_root.xsl    Root node is book.   ```       `library.xml`      ```   <library>     <book genre=&quot;novel&quot; ISBN=&quot;1-861001-57-5&quot;>        <title>Pride And Prejudice</title>     </book>     <book genre=&quot;novel&quot; ISBN=&quot;1-81920-21-2&quot;>        <title>Hook</title>     </book>   </library>   ```       `print_root.xsl`      ```   <style sheet version=&quot;1.0&quot; xmlns=&quot;http://www.w3.org/1999/XSL/Transform&quot; >     <output method=&quot;text&quot; />      <template match=&quot;/&quot;>        Root node is  <value-of select=&quot;local-name(//*[position() = 1])&quot; />      </template>   </style sheet>   ```"
  syntax:
    content: public void Transform (System.Xml.XPath.IXPathNavigable input, System.Xml.Xsl.XsltArgumentList args, System.IO.Stream output);
    parameters:
    - id: input
      type: System.Xml.XPath.IXPathNavigable
      description: "一个对象，实现<xref href=&quot;System.Xml.XPath.IXPathNavigable&quot;></xref>接口。 在.NET Framework 中，这可能是<xref href=&quot;System.Xml.XmlNode&quot;> </xref> (通常<xref href=&quot;System.Xml.XmlDocument&quot;> </xref>)，或<xref href=&quot;System.Xml.XPath.XPathDocument&quot;></xref>包含要转换的数据。"
    - id: args
      type: System.Xml.Xsl.XsltArgumentList
      description: "<xref href=&quot;System.Xml.Xsl.XsltArgumentList&quot;> </xref>包含用作转换输入的命名空间限定的自变量。"
    - id: output
      type: System.IO.Stream
      description: "你想要输出流。"
  overload: System.Xml.Xsl.XslTransform.Transform*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "处理 XSLT 转换时出错。       注意︰ 这是从早期版本的行为发生变化。 <xref href=&quot;System.Xml.Xsl.XsltException&quot;> </xref>如果你使用 Microsoft.NET Framework 版本 1.1 或更早版本，将引发。"
  platform:
  - net462
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList,System.IO.TextWriter)
  id: Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList,System.IO.TextWriter)
  parent: System.Xml.Xsl.XslTransform
  langs:
  - csharp
  name: Transform(IXPathNavigable,XsltArgumentList,TextWriter)
  nameWithType: XslTransform.Transform(IXPathNavigable,XsltArgumentList,TextWriter)
  fullName: System.Xml.Xsl.XslTransform.Transform(IXPathNavigable,XsltArgumentList,TextWriter)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml.Xsl
  summary: "转换中的 XML 数据<xref href=&quot;System.Xml.XPath.IXPathNavigable&quot;></xref>使用指定<code> args </code>并将结果输出到一种<xref:System.IO.TextWriter>。</xref:System.IO.TextWriter>"
  remarks: "> [!NOTE]1><xref:System.Xml.Xsl.XslTransform>类是.NET Framework 2.0 版中过时。</xref:System.Xml.Xsl.XslTransform> <xref:System.Xml.Xsl.XslCompiledTransform>类是新的 XSLT 处理器。</xref:System.Xml.Xsl.XslCompiledTransform> 有关详细信息，请参阅[使用 XslCompiledTransform 类](~/add/includes/ajax-current-ext-md.md)和[迁移从 XslTransform 类](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Xml.Xsl.XslTransform>支持的 XSLT 1.0 语法。</xref:System.Xml.Xsl.XslTransform> XSLT 样式表必须包括命名空间声明`xmlns:xsl= http://www.w3.org/1999/XSL/Transform`。      1> [!NOTE]&1;> 此方法现已过时。 设置<xref:System.Xml.Xsl.XslTransform.XmlResolver%2A>属性确定如何 XSLT`document()`函数处于已解决状态。</xref:System.Xml.Xsl.XslTransform.XmlResolver%2A> 建议的做法是使用<xref:System.Xml.Xsl.XslTransform.Transform%2A>该方法使用<xref:System.Xml.XmlResolver>对象作为其自变量之一。</xref:System.Xml.XmlResolver> </xref:System.Xml.Xsl.XslTransform.Transform%2A>       `args`与匹配`xsl:param`样式表中定义的元素。       上的编码属性`xsl:output`输出到一种<xref:System.IO.TextWriter>。</xref:System.IO.TextWriter>时，不支持元素 请参阅[XslTransform 的输出](~/add/includes/ajax-current-ext-md.md)获取在其上的细节`xsl:output`支持属性。       转换将应用于整个文档。 换而言之，如果您传入文档根节点以外的一个节点，则这不会阻止转换进程访问已加载文档的所有节点。 若要转换节点片段，必须创建<xref:System.Xml.XmlDocument>包含只是在节点片段，并将其传递<xref:System.Xml.XmlDocument>对转换方法。</xref:System.Xml.XmlDocument> </xref:System.Xml.XmlDocument>       下面的示例对一个节点片段执行转换。      ```   XslTransform xslt = new XslTransform();        xslt.Load(&quot;print_root.xsl&quot;);   XmlDocument doc = new XmlDocument();   doc.Load(&quot;library.xml&quot;);   // Create a new document containing just the node fragment.   XmlNode testNode = doc.DocumentElement.FirstChild;    XmlDocument tmpDoc = new XmlDocument();    tmpDoc.LoadXml(testNode.OuterXml);   // Pass the document containing the node fragment    // to the Transform method.   Console.WriteLine(&quot;Passing &quot; + tmpDoc.OuterXml + &quot; to print_root.xsl&quot;);   xslt.Transform(tmpDoc, null, Console.Out);   ```该示例使用`library.xml`和`print_root.xsl`文件作为输入，并输出到控制台如下。      ```   Passing <book genre=&quot;novel&quot; ISBN=&quot;1-861001-57-5&quot;><title>Pride And Prejudice</title></book> to print_root.xsl    Root node is book.   ```       `library.xml`      ```   <library>     <book genre=&quot;novel&quot; ISBN=&quot;1-861001-57-5&quot;>        <title>Pride And Prejudice</title>     </book>     <book genre=&quot;novel&quot; ISBN=&quot;1-81920-21-2&quot;>        <title>Hook</title>     </book>   </library>   ```       `print_root.xsl`      ```   <style sheet version=&quot;1.0&quot; xmlns=&quot;http://www.w3.org/1999/XSL/Transform&quot; >     <output method=&quot;text&quot; />      <template match=&quot;/&quot;>        Root node is  <value-of select=&quot;local-name(//*[position() = 1])&quot; />      </template>   </style sheet>   ```"
  syntax:
    content: public void Transform (System.Xml.XPath.IXPathNavigable input, System.Xml.Xsl.XsltArgumentList args, System.IO.TextWriter output);
    parameters:
    - id: input
      type: System.Xml.XPath.IXPathNavigable
      description: "一个对象，实现<xref href=&quot;System.Xml.XPath.IXPathNavigable&quot;></xref>接口。 在.NET Framework 中，这可能是<xref href=&quot;System.Xml.XmlNode&quot;> </xref> (通常<xref href=&quot;System.Xml.XmlDocument&quot;> </xref>)，或<xref href=&quot;System.Xml.XPath.XPathDocument&quot;></xref>包含要转换的数据。"
    - id: args
      type: System.Xml.Xsl.XsltArgumentList
      description: "<xref href=&quot;System.Xml.Xsl.XsltArgumentList&quot;> </xref>包含用作转换输入的命名空间限定的自变量。"
    - id: output
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>要输出到。</xref:System.IO.TextWriter>"
  overload: System.Xml.Xsl.XslTransform.Transform*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "处理 XSLT 转换时出错。       注意︰ 这是从早期版本的行为发生变化。 <xref href=&quot;System.Xml.Xsl.XsltException&quot;> </xref>如果你使用 Microsoft.NET Framework 版本 1.1 或更早版本，将引发。"
  platform:
  - net462
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList,System.Xml.XmlResolver)
  id: Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList,System.Xml.XmlResolver)
  parent: System.Xml.Xsl.XslTransform
  langs:
  - csharp
  name: Transform(IXPathNavigable,XsltArgumentList,XmlResolver)
  nameWithType: XslTransform.Transform(IXPathNavigable,XsltArgumentList,XmlResolver)
  fullName: System.Xml.Xsl.XslTransform.Transform(IXPathNavigable,XsltArgumentList,XmlResolver)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml.Xsl
  summary: "转换中的 XML 数据<xref href=&quot;System.Xml.XPath.IXPathNavigable&quot;></xref>使用指定<code> args </code>并输出到<xref:System.Xml.XmlReader>。</xref:System.Xml.XmlReader>结果"
  remarks: "> [!NOTE]1><xref:System.Xml.Xsl.XslTransform>类是.NET Framework 2.0 版中过时。</xref:System.Xml.Xsl.XslTransform> <xref:System.Xml.Xsl.XslCompiledTransform>类是新的 XSLT 处理器。</xref:System.Xml.Xsl.XslCompiledTransform> 有关详细信息，请参阅[使用 XslCompiledTransform 类](~/add/includes/ajax-current-ext-md.md)和[迁移从 XslTransform 类](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Xml.Xsl.XslTransform>支持的 XSLT 1.0 语法。</xref:System.Xml.Xsl.XslTransform> XSLT 样式表必须包括命名空间声明`xmlns:xsl= http://www.w3.org/1999/XSL/Transform`。       `args`与匹配`xsl:param`样式表中定义的元素。 `xsl:output`当你输出到不支持元素<xref:System.Xml.XmlReader>(`xsl:output`元素将被忽略)。</xref:System.Xml.XmlReader> 请参阅[XslTransform 的输出](~/add/includes/ajax-current-ext-md.md)有关详细信息。       此方法可以进行异步转换的源文档。       转换将应用于整个文档。 换而言之，如果您传入文档根节点以外的一个节点，则这不会阻止转换进程访问已加载文档的所有节点。 若要转换节点片段，必须创建<xref:System.Xml.XmlDocument>包含只是在节点片段，并将其传递<xref:System.Xml.XmlDocument>对转换方法。</xref:System.Xml.XmlDocument> </xref:System.Xml.XmlDocument>       下面的示例对一个节点片段执行转换。      ```   XslTransform xslt = new XslTransform();        xslt.Load(&quot;print_root.xsl&quot;);   XmlDocument doc = new XmlDocument();   doc.Load(&quot;library.xml&quot;);   // Create a new document containing just the node fragment.   XmlNode testNode = doc.DocumentElement.FirstChild;    XmlDocument tmpDoc = new XmlDocument();    tmpDoc.LoadXml(testNode.OuterXml);   // Pass the document containing the node fragment    // to the Transform method.   Console.WriteLine(&quot;Passing &quot; + tmpDoc.OuterXml + &quot; to print_root.xsl&quot;);   xslt.Transform(tmpDoc, null, Console.Out, null);   ```该示例使用`library.xml`和`print_root.xsl`文件作为输入，并输出到控制台如下。      ```   Passing <book genre=&quot;novel&quot; ISBN=&quot;1-861001-57-5&quot;><title>Pride And Prejudice</title></book> to print_root.xsl    Root node is book.   ```       `library.xml`      ```   <library>     <book genre=&quot;novel&quot; ISBN=&quot;1-861001-57-5&quot;>        <title>Pride And Prejudice</title>     </book>     <book genre=&quot;novel&quot; ISBN=&quot;1-81920-21-2&quot;>        <title>Hook</title>     </book>   </library>   ```       `print_root.xsl`      ```   <style sheet version=&quot;1.0&quot; xmlns=&quot;http://www.w3.org/1999/XSL/Transform&quot; >     <output method=&quot;text&quot; />      <template match=&quot;/&quot;>        Root node is  <value-of select=&quot;local-name(//*[position() = 1])&quot; />      </template>   </style sheet>   ```"
  example:
  - "The following example transforms an XML document and outputs the results to an `XmlReader`. An <xref:System.Xml.XmlUrlResolver> with the necessary credentials is used to process any XSLT `document()` functions.  \n  \n [!code-cpp[XslTransform.Transform4#1](~/add/codesnippet/cpp/33389ef1-3a26-4334-acdd-_1.cpp)]\n [!code-cs[XslTransform.Transform4#1](~/add/codesnippet/csharp/33389ef1-3a26-4334-acdd-_1.cs)]\n [!code-vb[XslTransform.Transform4#1](~/add/codesnippet/visualbasic/33389ef1-3a26-4334-acdd-_1.vb)]"
  syntax:
    content: public System.Xml.XmlReader Transform (System.Xml.XPath.IXPathNavigable input, System.Xml.Xsl.XsltArgumentList args, System.Xml.XmlResolver resolver);
    parameters:
    - id: input
      type: System.Xml.XPath.IXPathNavigable
      description: "一个对象，实现<xref href=&quot;System.Xml.XPath.IXPathNavigable&quot;></xref>接口。 在.NET Framework 中，这可能是<xref href=&quot;System.Xml.XmlNode&quot;> </xref> (通常<xref href=&quot;System.Xml.XmlDocument&quot;> </xref>)，或<xref href=&quot;System.Xml.XPath.XPathDocument&quot;></xref>包含要转换的数据。"
    - id: args
      type: System.Xml.Xsl.XsltArgumentList
      description: "<xref href=&quot;System.Xml.Xsl.XsltArgumentList&quot;> </xref>包含用作转换输入的命名空间限定的自变量。"
    - id: resolver
      type: System.Xml.XmlResolver
      description: "<xref href=&quot;System.Xml.XmlResolver&quot;> </xref>用于解析 XSLT`document()`函数。 如果这是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>、`document()`函数未得到解决。       <xref href=&quot;System.Xml.XmlResolver&quot;> </xref>不缓存后转换方法完成。"
    return:
      type: System.Xml.XmlReader
      description: "<xref:System.Xml.XmlReader>包含转换的结果。</xref:System.Xml.XmlReader>"
  overload: System.Xml.Xsl.XslTransform.Transform*
  exceptions: []
  platform:
  - net462
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList,System.Xml.XmlWriter)
  id: Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList,System.Xml.XmlWriter)
  parent: System.Xml.Xsl.XslTransform
  langs:
  - csharp
  name: Transform(IXPathNavigable,XsltArgumentList,XmlWriter)
  nameWithType: XslTransform.Transform(IXPathNavigable,XsltArgumentList,XmlWriter)
  fullName: System.Xml.Xsl.XslTransform.Transform(IXPathNavigable,XsltArgumentList,XmlWriter)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml.Xsl
  summary: "转换中的 XML 数据<xref href=&quot;System.Xml.XPath.IXPathNavigable&quot;></xref>使用指定<code> args </code>并输出到<xref:System.Xml.XmlWriter>。</xref:System.Xml.XmlWriter>结果"
  remarks: "> [!NOTE]1><xref:System.Xml.Xsl.XslTransform>类是.NET Framework 2.0 版中过时。</xref:System.Xml.Xsl.XslTransform> <xref:System.Xml.Xsl.XslCompiledTransform>类是新的 XSLT 处理器。</xref:System.Xml.Xsl.XslCompiledTransform> 有关详细信息，请参阅[使用 XslCompiledTransform 类](~/add/includes/ajax-current-ext-md.md)和[迁移从 XslTransform 类](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Xml.Xsl.XslTransform>支持的 XSLT 1.0 语法。</xref:System.Xml.Xsl.XslTransform> XSLT 样式表必须包括命名空间声明`xmlns:xsl= http://www.w3.org/1999/XSL/Transform`。      1> [!NOTE]&1;> 此方法现已过时。 设置<xref:System.Xml.Xsl.XslTransform.XmlResolver%2A>属性确定如何 XSLT`document()`函数处于已解决状态。</xref:System.Xml.Xsl.XslTransform.XmlResolver%2A> 建议的做法是使用<xref:System.Xml.Xsl.XslTransform.Transform%2A>该方法使用<xref:System.Xml.XmlResolver>对象作为其自变量之一。</xref:System.Xml.XmlResolver> </xref:System.Xml.Xsl.XslTransform.Transform%2A>       `args`与匹配`xsl:param`样式表中定义的元素。 `xsl:output`当你输出到不支持元素<xref:System.Xml.XmlWriter>(`xsl:output`将被忽略)。</xref:System.Xml.XmlWriter> 请参阅[XslTransform 的输出](~/add/includes/ajax-current-ext-md.md)有关详细信息。       转换将应用于整个文档。 换而言之，如果您传入文档根节点以外的一个节点，则这不会阻止转换进程访问已加载文档的所有节点。 若要转换节点片段，必须创建<xref:System.Xml.XmlDocument>包含只是在节点片断并将其传递<xref:System.Xml.XmlDocument>对转换方法。</xref:System.Xml.XmlDocument> </xref:System.Xml.XmlDocument>       下面的示例对一个节点片段执行转换。      ```   XslTransform xslt = new XslTransform();        xslt.Load(&quot;print_root.xsl&quot;);   XmlDocument doc = new XmlDocument();   doc.Load(&quot;library.xml&quot;);   // Create a new document containing just the node fragment.   XmlNode testNode = doc.DocumentElement.FirstChild;    XmlDocument tmpDoc = new XmlDocument();    tmpDoc.LoadXml(testNode.OuterXml);   // Pass the document containing the node fragment    // to the Transform method.   Console.WriteLine(&quot;Passing &quot; + tmpDoc.OuterXml + &quot; to print_root.xsl&quot;);   xslt.Transform(tmpDoc, null, Console.Out);   ```该示例使用`library.xml`和`print_root.xsl`文件作为输入，并输出到控制台如下。      ```   Passing <book genre=&quot;novel&quot; ISBN=&quot;1-861001-57-5&quot;><title>Pride And Prejudice</title></book> to print_root.xsl    Root node is book.   ```       `library.xml`      ```   <library>     <book genre=&quot;novel&quot; ISBN=&quot;1-861001-57-5&quot;>        <title>Pride And Prejudice</title>     </book>     <book genre=&quot;novel&quot; ISBN=&quot;1-81920-21-2&quot;>        <title>Hook</title>     </book>   </library>   ```       `print_root.xsl`      ```   <style sheet version=&quot;1.0&quot; xmlns=&quot;http://www.w3.org/1999/XSL/Transform&quot; >     <output method=&quot;text&quot; />     <template match=&quot;/&quot;>     Root node is  <value-of select=&quot;local-name(//*[position() = 1])&quot; />      </template>   </style sheet>   ```"
  syntax:
    content: public void Transform (System.Xml.XPath.IXPathNavigable input, System.Xml.Xsl.XsltArgumentList args, System.Xml.XmlWriter output);
    parameters:
    - id: input
      type: System.Xml.XPath.IXPathNavigable
      description: "一个对象，实现<xref href=&quot;System.Xml.XPath.IXPathNavigable&quot;></xref>接口。 在.NET Framework 中，这可能是<xref href=&quot;System.Xml.XmlNode&quot;> </xref> (通常<xref href=&quot;System.Xml.XmlDocument&quot;> </xref>)，或<xref href=&quot;System.Xml.XPath.XPathDocument&quot;></xref>包含要转换的数据。"
    - id: args
      type: System.Xml.Xsl.XsltArgumentList
      description: "<xref href=&quot;System.Xml.Xsl.XsltArgumentList&quot;> </xref>包含用作转换输入的命名空间限定的自变量。"
    - id: output
      type: System.Xml.XmlWriter
      description: "<xref:System.Xml.XmlWriter>要输出到。</xref:System.Xml.XmlWriter>"
  overload: System.Xml.Xsl.XslTransform.Transform*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "处理 XSLT 转换时出错。       注意︰ 这是从早期版本的行为发生变化。 <xref href=&quot;System.Xml.Xsl.XsltException&quot;> </xref>如果你使用 Microsoft.NET Framework 版本 1.1 或更早版本，将引发。"
  platform:
  - net462
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.IO.Stream)
  id: Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.IO.Stream)
  parent: System.Xml.Xsl.XslTransform
  langs:
  - csharp
  name: Transform(XPathNavigator,XsltArgumentList,Stream)
  nameWithType: XslTransform.Transform(XPathNavigator,XsltArgumentList,Stream)
  fullName: System.Xml.Xsl.XslTransform.Transform(XPathNavigator,XsltArgumentList,Stream)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml.Xsl
  summary: "转换中的 XML 数据<xref href=&quot;System.Xml.XPath.XPathNavigator&quot;></xref>使用指定<code> args </code>并将结果输出到一种<xref:System.IO.Stream>。</xref:System.IO.Stream>"
  remarks: "> [!NOTE]1><xref:System.Xml.Xsl.XslTransform>类是.NET Framework 2.0 版中过时。</xref:System.Xml.Xsl.XslTransform> <xref:System.Xml.Xsl.XslCompiledTransform>类是新的 XSLT 处理器。</xref:System.Xml.Xsl.XslCompiledTransform> 有关详细信息，请参阅[使用 XslCompiledTransform 类](~/add/includes/ajax-current-ext-md.md)和[迁移从 XslTransform 类](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Xml.Xsl.XslTransform>支持的 XSLT 1.0 语法。</xref:System.Xml.Xsl.XslTransform> XSLT 样式表必须包括命名空间声明`xmlns:xsl= http://www.w3.org/1999/XSL/Transform`。       `args`与匹配`xsl:param`样式表中定义的元素。 转换选择将应用于整个文档。 换而言之，如果当前节点在文档根节点以外的一个节点树上设置的则这不会阻止转换进程访问已加载文档的所有节点。 在执行转换后，<xref:System.Xml.XPath.XPathNavigator>保留为其原始状态。</xref:System.Xml.XPath.XPathNavigator> 这意味着调用转换方法后，将该节点，这是当前转换过程之前，保持当前节点。       请参阅[XslTransform 的输出](~/add/includes/ajax-current-ext-md.md)获取在其上的细节`xsl:output`支持属性。      1> [!NOTE]&1;> 此方法现已过时。 设置<xref:System.Xml.Xsl.XslTransform.XmlResolver%2A>属性确定如何 XSLT`document()`函数处于已解决状态。</xref:System.Xml.Xsl.XslTransform.XmlResolver%2A> 建议的做法是使用<xref:System.Xml.Xsl.XslTransform.Transform%2A>该方法使用<xref:System.Xml.XmlResolver>对象作为其自变量之一。</xref:System.Xml.XmlResolver> </xref:System.Xml.Xsl.XslTransform.Transform%2A>"
  syntax:
    content: public void Transform (System.Xml.XPath.XPathNavigator input, System.Xml.Xsl.XsltArgumentList args, System.IO.Stream output);
    parameters:
    - id: input
      type: System.Xml.XPath.XPathNavigator
      description: "<xref href=&quot;System.Xml.XPath.XPathNavigator&quot;> </xref>包含要转换的数据。"
    - id: args
      type: System.Xml.Xsl.XsltArgumentList
      description: "<xref href=&quot;System.Xml.Xsl.XsltArgumentList&quot;> </xref>包含用作转换输入的命名空间限定的自变量。"
    - id: output
      type: System.IO.Stream
      description: "你想要输出流。"
  overload: System.Xml.Xsl.XslTransform.Transform*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "处理 XSLT 转换时出错。       注意︰ 这是从早期版本的行为发生变化。 <xref href=&quot;System.Xml.Xsl.XsltException&quot;> </xref>如果你使用 Microsoft.NET Framework 版本 1.1 或更早版本，将引发。"
  platform:
  - net462
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.IO.TextWriter)
  id: Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.IO.TextWriter)
  parent: System.Xml.Xsl.XslTransform
  langs:
  - csharp
  name: Transform(XPathNavigator,XsltArgumentList,TextWriter)
  nameWithType: XslTransform.Transform(XPathNavigator,XsltArgumentList,TextWriter)
  fullName: System.Xml.Xsl.XslTransform.Transform(XPathNavigator,XsltArgumentList,TextWriter)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml.Xsl
  summary: "转换中的 XML 数据<xref href=&quot;System.Xml.XPath.XPathNavigator&quot;></xref>使用指定<code> args </code>并将结果输出到一种<xref:System.IO.TextWriter>。</xref:System.IO.TextWriter>"
  remarks: "> [!NOTE]1><xref:System.Xml.Xsl.XslTransform>类是.NET Framework 2.0 版中过时。</xref:System.Xml.Xsl.XslTransform> <xref:System.Xml.Xsl.XslCompiledTransform>类是新的 XSLT 处理器。</xref:System.Xml.Xsl.XslCompiledTransform> 有关详细信息，请参阅[使用 XslCompiledTransform 类](~/add/includes/ajax-current-ext-md.md)和[迁移从 XslTransform 类](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Xml.Xsl.XslTransform>支持的 XSLT 1.0 语法。</xref:System.Xml.Xsl.XslTransform> XSLT 样式表必须包括命名空间声明`xmlns:xsl= http://www.w3.org/1999/XSL/Transform`。       `args`与匹配`xsl:param`样式表中定义的元素。 转换选择将应用于整个文档。 换而言之，如果当前节点在文档根节点以外的一个节点树上设置的则这不会阻止转换进程访问已加载文档的所有节点。 在执行转换后，<xref:System.Xml.XPath.XPathNavigator>保留为其原始状态。</xref:System.Xml.XPath.XPathNavigator> 这意味着调用转换方法后，将该节点，这是当前转换过程之前，保持当前节点。       上的编码属性`xsl:output`输出到一种<xref:System.IO.TextWriter>。</xref:System.IO.TextWriter>时，不支持元素 请参阅[XslTransform 的输出](~/add/includes/ajax-current-ext-md.md)获取在其上的细节`xsl:output`支持属性。      1> [!NOTE]&1;> 此方法现已过时。 设置<xref:System.Xml.Xsl.XslTransform.XmlResolver%2A>属性确定如何 XSLT`document()`函数处于已解决状态。</xref:System.Xml.Xsl.XslTransform.XmlResolver%2A> 建议的做法是使用<xref:System.Xml.Xsl.XslTransform.Transform%2A>该方法使用<xref:System.Xml.XmlResolver>对象作为其自变量之一。</xref:System.Xml.XmlResolver> </xref:System.Xml.Xsl.XslTransform.Transform%2A>"
  syntax:
    content: public void Transform (System.Xml.XPath.XPathNavigator input, System.Xml.Xsl.XsltArgumentList args, System.IO.TextWriter output);
    parameters:
    - id: input
      type: System.Xml.XPath.XPathNavigator
      description: "<xref href=&quot;System.Xml.XPath.XPathNavigator&quot;> </xref>包含要转换的数据。"
    - id: args
      type: System.Xml.Xsl.XsltArgumentList
      description: "<xref href=&quot;System.Xml.Xsl.XsltArgumentList&quot;> </xref>包含用作转换输入的命名空间限定的自变量。"
    - id: output
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>要输出到。</xref:System.IO.TextWriter>"
  overload: System.Xml.Xsl.XslTransform.Transform*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "处理 XSLT 转换时出错。       注意︰ 这是从早期版本的行为发生变化。 <xref href=&quot;System.Xml.Xsl.XsltException&quot;> </xref>如果你使用 Microsoft.NET Framework 版本 1.1 或更早版本，将引发。"
  platform:
  - net462
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.Xml.XmlResolver)
  id: Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.Xml.XmlResolver)
  parent: System.Xml.Xsl.XslTransform
  langs:
  - csharp
  name: Transform(XPathNavigator,XsltArgumentList,XmlResolver)
  nameWithType: XslTransform.Transform(XPathNavigator,XsltArgumentList,XmlResolver)
  fullName: System.Xml.Xsl.XslTransform.Transform(XPathNavigator,XsltArgumentList,XmlResolver)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml.Xsl
  summary: "转换中的 XML 数据<xref href=&quot;System.Xml.XPath.XPathNavigator&quot;></xref>使用指定<code> args </code>并输出到<xref:System.Xml.XmlReader>。</xref:System.Xml.XmlReader>结果"
  remarks: "> [!NOTE]1><xref:System.Xml.Xsl.XslTransform>类是.NET Framework 2.0 版中过时。</xref:System.Xml.Xsl.XslTransform> <xref:System.Xml.Xsl.XslCompiledTransform>类是新的 XSLT 处理器。</xref:System.Xml.Xsl.XslCompiledTransform> 有关详细信息，请参阅[使用 XslCompiledTransform 类](~/add/includes/ajax-current-ext-md.md)和[迁移从 XslTransform 类](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Xml.Xsl.XslTransform>支持的 XSLT 1.0 语法。</xref:System.Xml.Xsl.XslTransform> XSLT 样式表必须包括命名空间声明`xmlns:xsl= http://www.w3.org/1999/XSL/Transform`。       `args`与匹配`xsl:param`样式表中定义的元素。 转换选择将应用于整个文档。 换而言之，如果当前节点在文档根节点以外的一个节点树上设置的则这不会阻止转换进程访问已加载文档的所有节点。 在执行转换后，<xref:System.Xml.XPath.XPathNavigator>保留为其原始状态。</xref:System.Xml.XPath.XPathNavigator> 这意味着调用转换方法后，将该节点，这是当前转换过程之前，保持当前节点。       因为<xref:System.Xml.XmlReader>提供只读的输出，`xsl:output`元素将被忽略。</xref:System.Xml.XmlReader> 请参阅[XslTransform 的输出](~/add/includes/ajax-current-ext-md.md)有关详细信息。       此方法可以进行异步转换的源文档。"
  syntax:
    content: public System.Xml.XmlReader Transform (System.Xml.XPath.XPathNavigator input, System.Xml.Xsl.XsltArgumentList args, System.Xml.XmlResolver resolver);
    parameters:
    - id: input
      type: System.Xml.XPath.XPathNavigator
      description: "<xref href=&quot;System.Xml.XPath.XPathNavigator&quot;> </xref>包含要转换的数据。"
    - id: args
      type: System.Xml.Xsl.XsltArgumentList
      description: "<xref href=&quot;System.Xml.Xsl.XsltArgumentList&quot;> </xref>包含用作转换输入的命名空间限定的自变量。"
    - id: resolver
      type: System.Xml.XmlResolver
      description: "<xref href=&quot;System.Xml.XmlResolver&quot;> </xref>用于解析 XSLT`document()`函数。 如果这是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>、`document()`函数未得到解决。       <xref href=&quot;System.Xml.XmlResolver&quot;> </xref>不缓存后转换方法完成。"
    return:
      type: System.Xml.XmlReader
      description: "<xref:System.Xml.XmlReader>包含转换的结果。</xref:System.Xml.XmlReader>"
  overload: System.Xml.Xsl.XslTransform.Transform*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "处理 XSLT 转换时出错。       注意︰ 这是从早期版本的行为发生变化。 <xref href=&quot;System.Xml.Xsl.XsltException&quot;> </xref>如果你使用 Microsoft.NET Framework 版本 1.1 或更早版本，将引发。"
  platform:
  - net462
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.Xml.XmlWriter)
  id: Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.Xml.XmlWriter)
  parent: System.Xml.Xsl.XslTransform
  langs:
  - csharp
  name: Transform(XPathNavigator,XsltArgumentList,XmlWriter)
  nameWithType: XslTransform.Transform(XPathNavigator,XsltArgumentList,XmlWriter)
  fullName: System.Xml.Xsl.XslTransform.Transform(XPathNavigator,XsltArgumentList,XmlWriter)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml.Xsl
  summary: "转换中的 XML 数据<xref href=&quot;System.Xml.XPath.XPathNavigator&quot;></xref>使用与指定的参数，并将结果输出到<xref:System.Xml.XmlWriter>.</xref:System.Xml.XmlWriter>"
  remarks: "> [!NOTE]1><xref:System.Xml.Xsl.XslTransform>类是.NET Framework 2.0 版中过时。</xref:System.Xml.Xsl.XslTransform> <xref:System.Xml.Xsl.XslCompiledTransform>类是新的 XSLT 处理器。</xref:System.Xml.Xsl.XslCompiledTransform> 有关详细信息，请参阅[使用 XslCompiledTransform 类](~/add/includes/ajax-current-ext-md.md)和[迁移从 XslTransform 类](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Xml.Xsl.XslTransform>支持的 XSLT 1.0 语法。</xref:System.Xml.Xsl.XslTransform> XSLT 样式表必须包括命名空间声明`xmlns:xsl= http://www.w3.org/1999/XSL/Transform`。       `args`与匹配`xsl:param`样式表中定义的元素。 转换选择将应用于整个文档。 换而言之，如果当前节点在文档根节点以外的一个节点树上设置的则这不会阻止转换进程访问已加载文档的所有节点。 在执行转换后，<xref:System.Xml.XPath.XPathNavigator>保留为其原始状态。</xref:System.Xml.XPath.XPathNavigator> 这意味着转换过程之前的当前节点之后调用转换方法       `xsl:output`当你输出到不支持元素<xref:System.Xml.XmlWriter>(`xsl:output`将被忽略)。</xref:System.Xml.XmlWriter> 请参阅[XslTransform 的输出](~/add/includes/ajax-current-ext-md.md)有关详细信息。      1> [!NOTE]&1;> 此方法现已过时。 设置<xref:System.Xml.Xsl.XslTransform.XmlResolver%2A>属性确定如何 XSLT`document()`函数处于已解决状态。</xref:System.Xml.Xsl.XslTransform.XmlResolver%2A> 建议的做法是使用<xref:System.Xml.Xsl.XslTransform.Transform%2A>该方法使用<xref:System.Xml.XmlResolver>对象作为其自变量之一。</xref:System.Xml.XmlResolver> </xref:System.Xml.Xsl.XslTransform.Transform%2A>"
  syntax:
    content: public void Transform (System.Xml.XPath.XPathNavigator input, System.Xml.Xsl.XsltArgumentList args, System.Xml.XmlWriter output);
    parameters:
    - id: input
      type: System.Xml.XPath.XPathNavigator
      description: "<xref href=&quot;System.Xml.XPath.XPathNavigator&quot;> </xref>包含要转换的数据。"
    - id: args
      type: System.Xml.Xsl.XsltArgumentList
      description: "<xref href=&quot;System.Xml.Xsl.XsltArgumentList&quot;> </xref>包含用作转换输入的命名空间限定的自变量。"
    - id: output
      type: System.Xml.XmlWriter
      description: "<xref:System.Xml.XmlWriter>要输出到。</xref:System.Xml.XmlWriter>"
  overload: System.Xml.Xsl.XslTransform.Transform*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "处理 XSLT 转换时出错。       注意︰ 这是从早期版本的行为发生变化。 <xref href=&quot;System.Xml.Xsl.XsltException&quot;> </xref>如果你使用 Microsoft.NET Framework 版本 1.1 或更早版本，将引发。"
  platform:
  - net462
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList,System.IO.Stream,System.Xml.XmlResolver)
  id: Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList,System.IO.Stream,System.Xml.XmlResolver)
  parent: System.Xml.Xsl.XslTransform
  langs:
  - csharp
  name: Transform(IXPathNavigable,XsltArgumentList,Stream,XmlResolver)
  nameWithType: XslTransform.Transform(IXPathNavigable,XsltArgumentList,Stream,XmlResolver)
  fullName: System.Xml.Xsl.XslTransform.Transform(IXPathNavigable,XsltArgumentList,Stream,XmlResolver)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml.Xsl
  summary: "转换中的 XML 数据<xref href=&quot;System.Xml.XPath.IXPathNavigable&quot;></xref>使用指定<code> args </code>并将结果输出到一种<xref:System.IO.Stream>。</xref:System.IO.Stream>"
  remarks: "> [!NOTE]1><xref:System.Xml.Xsl.XslTransform>类是.NET Framework 2.0 版中过时。</xref:System.Xml.Xsl.XslTransform> <xref:System.Xml.Xsl.XslCompiledTransform>类是新的 XSLT 处理器。</xref:System.Xml.Xsl.XslCompiledTransform> 有关详细信息，请参阅[使用 XslCompiledTransform 类](~/add/includes/ajax-current-ext-md.md)和[迁移从 XslTransform 类](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Xml.Xsl.XslTransform>支持的 XSLT 1.0 语法。</xref:System.Xml.Xsl.XslTransform> XSLT 样式表必须包括命名空间声明`xmlns:xsl= http://www.w3.org/1999/XSL/Transform`。       `args`与匹配`xsl:param`样式表中定义的元素。       转换将应用于整个文档。 换而言之，如果您传入文档根节点以外的一个节点，则这不会阻止转换进程访问已加载文档的所有节点。 若要转换节点片段，必须创建<xref:System.Xml.XmlDocument>包含只是在节点片断并将其传递<xref:System.Xml.XmlDocument>对转换方法。</xref:System.Xml.XmlDocument> </xref:System.Xml.XmlDocument>       下面的示例对一个节点片段执行转换。      ```   XslTransform xslt = new XslTransform();        xslt.Load(&quot;print_root.xsl&quot;);   XmlDocument doc = new XmlDocument();   doc.Load(&quot;library.xml&quot;);   // Create a new document containing just the node fragment.   XmlNode testNode = doc.DocumentElement.FirstChild;    XmlDocument tmpDoc = new XmlDocument();    tmpDoc.LoadXml(testNode.OuterXml);   // Pass the document containing the node fragment    // to the Transform method.   Console.WriteLine(&quot;Passing &quot; + tmpDoc.OuterXml + &quot; to print_root.xsl&quot;);   xslt.Transform(tmpDoc, null, Console.Out, null);   ```该示例使用`library.xml`和`print_root.xsl`文件作为输入，并输出到控制台如下。      ```   Passing <book genre=&quot;novel&quot; ISBN=&quot;1-861001-57-5&quot;><title>Pride And Prejudice</title></book> to print_root.xsl    Root node is book.   ```       `library.xml`      ```   <library>     <book genre=&quot;novel&quot; ISBN=&quot;1-861001-57-5&quot;>        <title>Pride And Prejudice</title>     </book>     <book genre=&quot;novel&quot; ISBN=&quot;1-81920-21-2&quot;>        <title>Hook</title>     </book>   </library>   ```       `print_root.xsl`      ```   <style sheet version=&quot;1.0&quot; xmlns=&quot;http://www.w3.org/1999/XSL/Transform&quot; >     <output method=&quot;text&quot; />      <template match=&quot;/&quot;>        Root node is  <value-of select=&quot;local-name(//*[position() = 1])&quot; />      </template>   </style sheet>   ```"
  example:
  - "The following example performs a transformation within an ASP.NET page.  \n  \n [!code-vb[XslTransform.Transform5#1](~/add/codesnippet/visualbasic/0aececb0-8968-432a-8b61-_1.aspx)]\n [!code-cs[XslTransform.Transform5#1](~/add/codesnippet/csharp/0aececb0-8968-432a-8b61-_1.aspx)]"
  syntax:
    content: public void Transform (System.Xml.XPath.IXPathNavigable input, System.Xml.Xsl.XsltArgumentList args, System.IO.Stream output, System.Xml.XmlResolver resolver);
    parameters:
    - id: input
      type: System.Xml.XPath.IXPathNavigable
      description: "一个对象，实现<xref href=&quot;System.Xml.XPath.IXPathNavigable&quot;></xref>接口。 在.NET Framework 中，这可能是<xref href=&quot;System.Xml.XmlNode&quot;> </xref> (通常<xref href=&quot;System.Xml.XmlDocument&quot;> </xref>)，或<xref href=&quot;System.Xml.XPath.XPathDocument&quot;></xref>包含要转换的数据。"
    - id: args
      type: System.Xml.Xsl.XsltArgumentList
      description: "<xref href=&quot;System.Xml.Xsl.XsltArgumentList&quot;> </xref>包含用作转换输入的命名空间限定的自变量。"
    - id: output
      type: System.IO.Stream
      description: "你想要输出流。"
    - id: resolver
      type: System.Xml.XmlResolver
      description: "<xref href=&quot;System.Xml.XmlResolver&quot;> </xref>用于解析 XSLT`document()`函数。 如果这是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>、`document()`函数未得到解决。       <xref href=&quot;System.Xml.XmlResolver&quot;> </xref>后不缓存<xref:System.Xml.Xsl.XslTransform.Transform*>方法完成。</xref:System.Xml.Xsl.XslTransform.Transform*>"
  overload: System.Xml.Xsl.XslTransform.Transform*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "处理 XSLT 转换时出错。       注意︰ 这是从早期版本的行为发生变化。 <xref href=&quot;System.Xml.Xsl.XsltException&quot;> </xref>如果你使用 Microsoft.NET Framework 版本 1.1 或更早版本，将引发。"
  platform:
  - net462
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList,System.IO.TextWriter,System.Xml.XmlResolver)
  id: Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList,System.IO.TextWriter,System.Xml.XmlResolver)
  parent: System.Xml.Xsl.XslTransform
  langs:
  - csharp
  name: Transform(IXPathNavigable,XsltArgumentList,TextWriter,XmlResolver)
  nameWithType: XslTransform.Transform(IXPathNavigable,XsltArgumentList,TextWriter,XmlResolver)
  fullName: System.Xml.Xsl.XslTransform.Transform(IXPathNavigable,XsltArgumentList,TextWriter,XmlResolver)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml.Xsl
  summary: "转换中的 XML 数据<xref href=&quot;System.Xml.XPath.IXPathNavigable&quot;></xref>使用指定<code> args </code>并将结果输出到一种<xref:System.IO.TextWriter>。</xref:System.IO.TextWriter>"
  remarks: "> [!NOTE]1><xref:System.Xml.Xsl.XslTransform>类是.NET Framework 2.0 版中过时。</xref:System.Xml.Xsl.XslTransform> <xref:System.Xml.Xsl.XslCompiledTransform>类是新的 XSLT 处理器。</xref:System.Xml.Xsl.XslCompiledTransform> 有关详细信息，请参阅[使用 XslCompiledTransform 类](~/add/includes/ajax-current-ext-md.md)和[迁移从 XslTransform 类](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Xml.Xsl.XslTransform>支持的 XSLT 1.0 语法。</xref:System.Xml.Xsl.XslTransform> XSLT 样式表必须包括命名空间声明`xmlns:xsl= http://www.w3.org/1999/XSL/Transform`。       `args`与匹配`xsl:param`样式表中定义的元素。       上的编码属性`xsl:output`输出到一种<xref:System.IO.TextWriter>。</xref:System.IO.TextWriter>时，不支持元素 请参阅[XslTransform 的输出](~/add/includes/ajax-current-ext-md.md)获取在其上的细节`xsl:output`支持属性。       转换将应用于整个文档。 换而言之，如果您传入文档根节点以外的一个节点，则这不会阻止转换进程访问已加载文档的所有节点。 若要转换节点片段，必须创建<xref:System.Xml.XmlDocument>包含只是在节点片断并将其传递<xref:System.Xml.XmlDocument>对转换方法。</xref:System.Xml.XmlDocument> </xref:System.Xml.XmlDocument>       下面的示例对一个节点片段执行转换。      ```   XslTransform xslt = new XslTransform();        xslt.Load(&quot;print_root.xsl&quot;);   XmlDocument doc = new XmlDocument();   doc.Load(&quot;library.xml&quot;);   // Create a new document containing just the node fragment.   XmlNode testNode = doc.DocumentElement.FirstChild;    XmlDocument tmpDoc = new XmlDocument();    tmpDoc.LoadXml(testNode.OuterXml);   // Pass the document containing the node fragment    // to the Transform method.   Console.WriteLine(&quot;Passing &quot; + tmpDoc.OuterXml + &quot; to print_root.xsl&quot;);   xslt.Transform(tmpDoc, null, Console.Out, null);   ```该示例使用`library.xml`和`print_root.xsl`文件作为输入，并输出到控制台如下。      ```   Passing <book genre=&quot;novel&quot; ISBN=&quot;1-861001-57-5&quot;><title>Pride And Prejudice</title></book> to print_root.xsl    Root node is book.   ```       `library.xml`      ```   <library>     <book genre=&quot;novel&quot; ISBN=&quot;1-861001-57-5&quot;>        <title>Pride And Prejudice</title>     </book>     <book genre=&quot;novel&quot; ISBN=&quot;1-81920-21-2&quot;>        <title>Hook</title>     </book>   </library>   ```       `print_root.xsl`      ```   <style sheet version=&quot;1.0&quot; xmlns=&quot;http://www.w3.org/1999/XSL/Transform&quot; >     <output method=&quot;text&quot; />      <template match=&quot;/&quot;>        Root node is  <value-of select=&quot;local-name(//*[position() = 1])&quot; />      </template>   </style sheet>   ```"
  example:
  - "The following example transforms an XML file and outputs an HTML string. The <xref:System.IO.StringReader> and <xref:System.IO.StringWriter> classes are used to read and write the strings.  \n  \n [!code-vb[XslTransform.Transform6#1](~/add/codesnippet/visualbasic/f37e0493-6ab0-43d9-9439-_1.vb)]\n [!code-cs[XslTransform.Transform6#1](~/add/codesnippet/csharp/f37e0493-6ab0-43d9-9439-_1.cs)]  \n  \n The example uses the `books.xml` file as input.  \n  \n [!code-xml[XslTransform.Transform6#2](~/add/codesnippet/xml/f37e0493-6ab0-43d9-9439-_2.xml)]"
  syntax:
    content: public void Transform (System.Xml.XPath.IXPathNavigable input, System.Xml.Xsl.XsltArgumentList args, System.IO.TextWriter output, System.Xml.XmlResolver resolver);
    parameters:
    - id: input
      type: System.Xml.XPath.IXPathNavigable
      description: "一个对象，实现<xref href=&quot;System.Xml.XPath.IXPathNavigable&quot;></xref>接口。 在.NET Framework 中，这可能是<xref href=&quot;System.Xml.XmlNode&quot;> </xref> (通常<xref href=&quot;System.Xml.XmlDocument&quot;> </xref>)，或<xref href=&quot;System.Xml.XPath.XPathDocument&quot;></xref>包含要转换的数据。"
    - id: args
      type: System.Xml.Xsl.XsltArgumentList
      description: "<xref href=&quot;System.Xml.Xsl.XsltArgumentList&quot;> </xref>包含用作转换输入的命名空间限定的自变量。"
    - id: output
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>要输出到。</xref:System.IO.TextWriter>"
    - id: resolver
      type: System.Xml.XmlResolver
      description: "<xref href=&quot;System.Xml.XmlResolver&quot;> </xref>用于解析 XSLT`document()`函数。 如果这是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>、`document()`函数未得到解决。       <xref href=&quot;System.Xml.XmlResolver&quot;> </xref>不缓存后转换方法完成。"
  overload: System.Xml.Xsl.XslTransform.Transform*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "处理 XSLT 转换时出错。       注意︰ 这是从早期版本的行为发生变化。 <xref href=&quot;System.Xml.Xsl.XsltException&quot;> </xref>如果你使用 Microsoft.NET Framework 版本 1.1 或更早版本，将引发。"
  platform:
  - net462
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList,System.Xml.XmlWriter,System.Xml.XmlResolver)
  id: Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList,System.Xml.XmlWriter,System.Xml.XmlResolver)
  parent: System.Xml.Xsl.XslTransform
  langs:
  - csharp
  name: Transform(IXPathNavigable,XsltArgumentList,XmlWriter,XmlResolver)
  nameWithType: XslTransform.Transform(IXPathNavigable,XsltArgumentList,XmlWriter,XmlResolver)
  fullName: System.Xml.Xsl.XslTransform.Transform(IXPathNavigable,XsltArgumentList,XmlWriter,XmlResolver)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml.Xsl
  summary: "转换中的 XML 数据<xref href=&quot;System.Xml.XPath.IXPathNavigable&quot;></xref>使用指定<code> args </code>并输出到<xref:System.Xml.XmlWriter>。</xref:System.Xml.XmlWriter>结果"
  remarks: "> [!NOTE]1><xref:System.Xml.Xsl.XslTransform>类是.NET Framework 2.0 版中过时。</xref:System.Xml.Xsl.XslTransform> <xref:System.Xml.Xsl.XslCompiledTransform>类是新的 XSLT 处理器。</xref:System.Xml.Xsl.XslCompiledTransform> 有关详细信息，请参阅[使用 XslCompiledTransform 类](~/add/includes/ajax-current-ext-md.md)和[迁移从 XslTransform 类](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Xml.Xsl.XslTransform>支持的 XSLT 1.0 语法。</xref:System.Xml.Xsl.XslTransform> XSLT 样式表必须包括命名空间声明`xmlns:xsl= http://www.w3.org/1999/XSL/Transform`。       `args`与匹配`xsl:param`样式表中定义的元素。 `xsl:output`当你输出到不支持元素<xref:System.Xml.XmlWriter>(`xsl:output`将被忽略)。</xref:System.Xml.XmlWriter> 请参阅[XslTransform 的输出](~/add/includes/ajax-current-ext-md.md)有关详细信息。       转换将应用于整个文档。 换而言之，如果您传入文档根节点以外的一个节点，则这不会阻止转换进程访问已加载文档的所有节点。 若要转换节点片段，必须创建<xref:System.Xml.XmlDocument>包含只是在节点片断并将其传递<xref:System.Xml.XmlDocument>对转换方法。</xref:System.Xml.XmlDocument> </xref:System.Xml.XmlDocument>       下面的示例对一个节点片段执行转换。      ```   XslTransform xslt = new XslTransform();        xslt.Load(&quot;print_root.xsl&quot;);   XmlDocument doc = new XmlDocument();   doc.Load(&quot;library.xml&quot;);   // Create a new document containing just the node fragment.   XmlNode testNode = doc.DocumentElement.FirstChild;    XmlDocument tmpDoc = new XmlDocument();    tmpDoc.LoadXml(testNode.OuterXml);   // Pass the document containing the node fragment    // to the Transform method.   Console.WriteLine(&quot;Passing &quot; + tmpDoc.OuterXml + &quot; to print_root.xsl&quot;);   xslt.Transform(tmpDoc, null, Console.Out, null);   ```该示例使用`library.xml`和`print_root.xsl`文件作为输入，并输出到控制台如下。      ```   Passing <book genre=&quot;novel&quot; ISBN=&quot;1-861001-57-5&quot;><title>Pride And Prejudice</title></book> to print_root.xsl    Root node is book.   ```       `library.xml`      ```   <library>     <book genre=&quot;novel&quot; ISBN=&quot;1-861001-57-5&quot;>        <title>Pride And Prejudice</title>     </book>     <book genre=&quot;novel&quot; ISBN=&quot;1-81920-21-2&quot;>        <title>Hook</title>     </book>   </library>   ```       `print_root.xsl`      ```   <style sheet version=&quot;1.0&quot; xmlns=&quot;http://www.w3.org/1999/XSL/Transform&quot; >     <output method=&quot;text&quot; />     <template match=&quot;/&quot;>     Root node is  <value-of select=&quot;local-name(//*[position() = 1])&quot; />      </template>   </style sheet>   ```"
  example:
  - "The following example transforms an XML document into an HTML document. It displays the ISBN, title, and price for each book in a table.  \n  \n [!code-cs[Classic WebData XslTransform.Transform7 Example#1](~/add/codesnippet/csharp/e2f436c8-72f8-4045-80f0-_1.cs)]\n [!code-cpp[Classic WebData XslTransform.Transform7 Example#1](~/add/codesnippet/cpp/e2f436c8-72f8-4045-80f0-_1.cpp)]\n [!code-vb[Classic WebData XslTransform.Transform7 Example#1](~/add/codesnippet/visualbasic/e2f436c8-72f8-4045-80f0-_1.vb)]  \n  \n The sample uses the following two input files.  \n  \n `books.xml`  \n  \n [!code-xml[Classic WebData XslTransform.Transform7 Example#2](~/add/codesnippet/xml/e2f436c8-72f8-4045-80f0-_2.xml)]  \n  \n `output.xsl`  \n  \n [!code-xml[Classic WebData XslTransform.Transform7 Example#3](~/add/codesnippet/xml/e2f436c8-72f8-4045-80f0-_3.xsl)]"
  syntax:
    content: public void Transform (System.Xml.XPath.IXPathNavigable input, System.Xml.Xsl.XsltArgumentList args, System.Xml.XmlWriter output, System.Xml.XmlResolver resolver);
    parameters:
    - id: input
      type: System.Xml.XPath.IXPathNavigable
      description: "一个对象，实现<xref href=&quot;System.Xml.XPath.IXPathNavigable&quot;></xref>接口。 在.NET Framework 中，这可能是<xref href=&quot;System.Xml.XmlNode&quot;> </xref> (通常<xref href=&quot;System.Xml.XmlDocument&quot;> </xref>)，或<xref href=&quot;System.Xml.XPath.XPathDocument&quot;></xref>包含要转换的数据。"
    - id: args
      type: System.Xml.Xsl.XsltArgumentList
      description: "<xref href=&quot;System.Xml.Xsl.XsltArgumentList&quot;> </xref>包含用作转换输入的命名空间限定的自变量。"
    - id: output
      type: System.Xml.XmlWriter
      description: "<xref:System.Xml.XmlWriter>要输出到。</xref:System.Xml.XmlWriter>"
    - id: resolver
      type: System.Xml.XmlResolver
      description: "<xref href=&quot;System.Xml.XmlResolver&quot;> </xref>用于解析 XSLT`document()`函数。 如果这是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>、`document()`函数未得到解决。       <xref href=&quot;System.Xml.XmlResolver&quot;> </xref>不缓存后转换方法完成。"
  overload: System.Xml.Xsl.XslTransform.Transform*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "处理 XSLT 转换时出错。       注意︰ 这是从早期版本的行为发生变化。 <xref href=&quot;System.Xml.Xsl.XsltException&quot;> </xref>如果你使用 Microsoft.NET Framework 版本 1.1 或更早版本，将引发。"
  platform:
  - net462
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.IO.Stream,System.Xml.XmlResolver)
  id: Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.IO.Stream,System.Xml.XmlResolver)
  parent: System.Xml.Xsl.XslTransform
  langs:
  - csharp
  name: Transform(XPathNavigator,XsltArgumentList,Stream,XmlResolver)
  nameWithType: XslTransform.Transform(XPathNavigator,XsltArgumentList,Stream,XmlResolver)
  fullName: System.Xml.Xsl.XslTransform.Transform(XPathNavigator,XsltArgumentList,Stream,XmlResolver)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml.Xsl
  summary: "转换中的 XML 数据<xref href=&quot;System.Xml.XPath.XPathNavigator&quot;></xref>使用指定<code> args </code>并将结果输出到一种<xref:System.IO.Stream>。</xref:System.IO.Stream>"
  remarks: "> [!NOTE]1><xref:System.Xml.Xsl.XslTransform>类是.NET Framework 2.0 版中过时。</xref:System.Xml.Xsl.XslTransform> <xref:System.Xml.Xsl.XslCompiledTransform>类是新的 XSLT 处理器。</xref:System.Xml.Xsl.XslCompiledTransform> 有关详细信息，请参阅[使用 XslCompiledTransform 类](~/add/includes/ajax-current-ext-md.md)和[迁移从 XslTransform 类](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Xml.Xsl.XslTransform>支持的 XSLT 1.0 语法。</xref:System.Xml.Xsl.XslTransform> XSLT 样式表必须包括命名空间声明`xmlns:xsl= http://www.w3.org/1999/XSL/Transform`。       `args`与匹配`xsl:param`样式表中定义的元素。 转换选择将应用于整个文档。 换而言之，如果当前节点在文档根节点以外的一个节点树上设置的则这不会阻止转换进程访问已加载文档的所有节点。 在执行转换后，<xref:System.Xml.XPath.XPathNavigator>保留为其原始状态。</xref:System.Xml.XPath.XPathNavigator> 这意味着调用转换方法后，将该节点，这是当前转换过程之前，保持当前节点。       请参阅[XslTransform 的输出](~/add/includes/ajax-current-ext-md.md)获取在其上的细节`xsl:output`支持属性。"
  example:
  - "The following example loads a customer table into an <xref:System.Xml.XmlDataDocument> and performs an XSLT transformation to pull the customer data into an HTML table. The example uses the Microsoft SQL Server 2000 Northwind database.  \n  \n [!code-cs[XmlDataDocument.CreateNavigator#1](~/add/codesnippet/csharp/cf85a737-72d0-4c28-b81d-_1.cs)]\n [!code-vb[XmlDataDocument.CreateNavigator#1](~/add/codesnippet/visualbasic/cf85a737-72d0-4c28-b81d-_1.vb)]  \n  \n The example uses the `customers.xsl` file as input.  \n  \n [!code-xml[XmlDataDocument.CreateNavigator#2](~/add/codesnippet/xml/cf85a737-72d0-4c28-b81d-_2.xsl)]"
  syntax:
    content: public void Transform (System.Xml.XPath.XPathNavigator input, System.Xml.Xsl.XsltArgumentList args, System.IO.Stream output, System.Xml.XmlResolver resolver);
    parameters:
    - id: input
      type: System.Xml.XPath.XPathNavigator
      description: "<xref href=&quot;System.Xml.XPath.XPathNavigator&quot;> </xref>包含要转换的数据。"
    - id: args
      type: System.Xml.Xsl.XsltArgumentList
      description: "<xref href=&quot;System.Xml.Xsl.XsltArgumentList&quot;> </xref>包含用作转换输入的命名空间限定的自变量。"
    - id: output
      type: System.IO.Stream
      description: "你想要输出流。"
    - id: resolver
      type: System.Xml.XmlResolver
      description: "<xref href=&quot;System.Xml.XmlResolver&quot;> </xref>用于解析 XSLT`document()`函数。 如果这是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>、`document()`函数未得到解决。       <xref href=&quot;System.Xml.XmlResolver&quot;> </xref>不缓存后转换方法完成。"
  overload: System.Xml.Xsl.XslTransform.Transform*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "处理 XSLT 转换时出错。       注意︰ 这是从早期版本的行为发生变化。 <xref href=&quot;System.Xml.Xsl.XsltException&quot;> </xref>如果你使用 Microsoft.NET Framework 版本 1.1 或更早版本，将引发。"
  platform:
  - net462
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.IO.TextWriter,System.Xml.XmlResolver)
  id: Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.IO.TextWriter,System.Xml.XmlResolver)
  parent: System.Xml.Xsl.XslTransform
  langs:
  - csharp
  name: Transform(XPathNavigator,XsltArgumentList,TextWriter,XmlResolver)
  nameWithType: XslTransform.Transform(XPathNavigator,XsltArgumentList,TextWriter,XmlResolver)
  fullName: System.Xml.Xsl.XslTransform.Transform(XPathNavigator,XsltArgumentList,TextWriter,XmlResolver)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml.Xsl
  summary: "转换中的 XML 数据<xref href=&quot;System.Xml.XPath.XPathNavigator&quot;></xref>使用指定<code> args </code>并将结果输出到一种<xref:System.IO.TextWriter>。</xref:System.IO.TextWriter>"
  remarks: "> [!NOTE]1><xref:System.Xml.Xsl.XslTransform>类是.NET Framework 2.0 版中过时。</xref:System.Xml.Xsl.XslTransform> <xref:System.Xml.Xsl.XslCompiledTransform>类是新的 XSLT 处理器。</xref:System.Xml.Xsl.XslCompiledTransform> 有关详细信息，请参阅[使用 XslCompiledTransform 类](~/add/includes/ajax-current-ext-md.md)和[迁移从 XslTransform 类](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Xml.Xsl.XslTransform>支持的 XSLT 1.0 语法。</xref:System.Xml.Xsl.XslTransform> XSLT 样式表必须包括命名空间声明`xmlns:xsl= http://www.w3.org/1999/XSL/Transform`。       `args`与匹配`xsl:param`样式表中定义的元素。 转换选择将应用于整个文档。 换而言之，如果当前节点在文档根节点以外的一个节点树上设置的则这不会阻止转换进程访问已加载文档的所有节点。 在执行转换后，<xref:System.Xml.XPath.XPathNavigator>保留为其原始状态。</xref:System.Xml.XPath.XPathNavigator> 这意味着调用转换方法后，将该节点，这是当前转换过程之前，保持当前节点。       上的编码属性`xsl:output`输出到一种<xref:System.IO.TextWriter>。</xref:System.IO.TextWriter>时，不支持元素 请参阅[XslTransform 的输出](~/add/includes/ajax-current-ext-md.md)获取在其上的细节`xsl:output`支持属性。"
  syntax:
    content: public void Transform (System.Xml.XPath.XPathNavigator input, System.Xml.Xsl.XsltArgumentList args, System.IO.TextWriter output, System.Xml.XmlResolver resolver);
    parameters:
    - id: input
      type: System.Xml.XPath.XPathNavigator
      description: "<xref href=&quot;System.Xml.XPath.XPathNavigator&quot;> </xref>包含要转换的数据。"
    - id: args
      type: System.Xml.Xsl.XsltArgumentList
      description: "<xref href=&quot;System.Xml.Xsl.XsltArgumentList&quot;> </xref>包含用作转换输入的命名空间限定的自变量。"
    - id: output
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>要输出到。</xref:System.IO.TextWriter>"
    - id: resolver
      type: System.Xml.XmlResolver
      description: "<xref href=&quot;System.Xml.XmlResolver&quot;> </xref>用于解析 XSLT`document()`函数。 如果这是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>、`document()`函数未得到解决。       <xref href=&quot;System.Xml.XmlResolver&quot;> </xref>不缓存后转换方法完成。"
  overload: System.Xml.Xsl.XslTransform.Transform*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "处理 XSLT 转换时出错。       注意︰ 这是从早期版本的行为发生变化。 <xref href=&quot;System.Xml.Xsl.XsltException&quot;> </xref>如果你使用 Microsoft.NET Framework 版本 1.1 或更早版本，将引发。"
  platform:
  - net462
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.Xml.XmlWriter,System.Xml.XmlResolver)
  id: Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.Xml.XmlWriter,System.Xml.XmlResolver)
  parent: System.Xml.Xsl.XslTransform
  langs:
  - csharp
  name: Transform(XPathNavigator,XsltArgumentList,XmlWriter,XmlResolver)
  nameWithType: XslTransform.Transform(XPathNavigator,XsltArgumentList,XmlWriter,XmlResolver)
  fullName: System.Xml.Xsl.XslTransform.Transform(XPathNavigator,XsltArgumentList,XmlWriter,XmlResolver)
  type: Method
  assemblies:
  - System.Xml
  namespace: System.Xml.Xsl
  summary: "转换中的 XML 数据<xref href=&quot;System.Xml.XPath.XPathNavigator&quot;></xref>使用与指定的参数，并将结果输出到<xref:System.Xml.XmlWriter>.</xref:System.Xml.XmlWriter>"
  remarks: "> [!NOTE]1><xref:System.Xml.Xsl.XslTransform>类是.NET Framework 2.0 版中过时。</xref:System.Xml.Xsl.XslTransform> <xref:System.Xml.Xsl.XslCompiledTransform>类是新的 XSLT 处理器。</xref:System.Xml.Xsl.XslCompiledTransform> 有关详细信息，请参阅[使用 XslCompiledTransform 类](~/add/includes/ajax-current-ext-md.md)和[迁移从 XslTransform 类](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Xml.Xsl.XslTransform>支持的 XSLT 1.0 语法。</xref:System.Xml.Xsl.XslTransform> XSLT 样式表必须包括命名空间声明`xmlns:xsl= http://www.w3.org/1999/XSL/Transform`。       `args`与匹配`xsl:param`样式表中定义的元素。 转换选择将应用于整个文档。 换而言之，如果当前节点在文档根节点以外的一个节点树上设置的则这不会阻止转换进程访问已加载文档的所有节点。 在执行转换后，<xref:System.Xml.XPath.XPathNavigator>保留为其原始状态。</xref:System.Xml.XPath.XPathNavigator> 这意味着转换过程之前的当前节点之后调用转换方法       `xsl:output`当你输出到不支持元素<xref:System.Xml.XmlWriter>(`xsl:output`将被忽略)。</xref:System.Xml.XmlWriter> 请参阅[XslTransform 的输出](~/add/includes/ajax-current-ext-md.md)有关详细信息。"
  example:
  - "The following example loads and edits an XML document before performing an XSLT transform.  \n  \n [!code-vb[XslTransform.Transform2#1](~/add/codesnippet/visualbasic/3e32b237-2708-4620-b957-_1.vb)]\n [!code-cs[XslTransform.Transform2#1](~/add/codesnippet/csharp/3e32b237-2708-4620-b957-_1.cs)]\n [!code-cpp[XslTransform.Transform2#1](~/add/codesnippet/cpp/3e32b237-2708-4620-b957-_1.cpp)]"
  syntax:
    content: public void Transform (System.Xml.XPath.XPathNavigator input, System.Xml.Xsl.XsltArgumentList args, System.Xml.XmlWriter output, System.Xml.XmlResolver resolver);
    parameters:
    - id: input
      type: System.Xml.XPath.XPathNavigator
      description: "<xref href=&quot;System.Xml.XPath.XPathNavigator&quot;> </xref>包含要转换的数据。"
    - id: args
      type: System.Xml.Xsl.XsltArgumentList
      description: "<xref href=&quot;System.Xml.Xsl.XsltArgumentList&quot;> </xref>包含用作转换输入的命名空间限定的自变量。"
    - id: output
      type: System.Xml.XmlWriter
      description: "<xref:System.Xml.XmlWriter>要输出到。</xref:System.Xml.XmlWriter>"
    - id: resolver
      type: System.Xml.XmlResolver
      description: "<xref href=&quot;System.Xml.XmlResolver&quot;> </xref>用于解析 XSLT`document()`函数。 如果这是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>、`document()`函数未得到解决。       <xref href=&quot;System.Xml.XmlResolver&quot;> </xref>不缓存后转换方法完成。"
  overload: System.Xml.Xsl.XslTransform.Transform*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "处理 XSLT 转换时出错。       注意︰ 这是从早期版本的行为发生变化。 <xref href=&quot;System.Xml.Xsl.XsltException&quot;> </xref>如果你使用 Microsoft.NET Framework 版本 1.1 或更早版本，将引发。"
  platform:
  - net462
- uid: System.Xml.Xsl.XslTransform.XmlResolver
  id: XmlResolver
  parent: System.Xml.Xsl.XslTransform
  langs:
  - csharp
  name: XmlResolver
  nameWithType: XslTransform.XmlResolver
  fullName: System.Xml.Xsl.XslTransform.XmlResolver
  type: Property
  assemblies:
  - System.Xml
  namespace: System.Xml.Xsl
  summary: "集<xref href=&quot;System.Xml.XmlResolver&quot;></xref>用于解析外部资源时<xref:System.Xml.Xsl.XslTransform.Transform*>调用方法。</xref:System.Xml.Xsl.XslTransform.Transform*>"
  remarks: "> [!NOTE]1><xref:System.Xml.Xsl.XslTransform>类是.NET Framework 2.0 版中过时。</xref:System.Xml.Xsl.XslTransform> <xref:System.Xml.Xsl.XslCompiledTransform>类是新的 XSLT 处理器。</xref:System.Xml.Xsl.XslCompiledTransform> 有关详细信息，请参阅[使用 XslCompiledTransform 类](~/add/includes/ajax-current-ext-md.md)和[迁移从 XslTransform 类](~/add/includes/ajax-current-ext-md.md)。       在.NET Framework 1.1 版中，应用程序的信任级别确定的默认行为︰`Fully trusted code:`默认<xref:System.Xml.XmlUrlResolver>无用户凭据用于解析`document()`函数。</xref:System.Xml.XmlUrlResolver> 如果需要身份验证来访问外部资源，使用此属性指定<xref:System.Xml.XmlResolver>使用必要的凭据。</xref:System.Xml.XmlResolver>       `Semi-trusted code:`属性设置为`null`，这意味着`document()`函数未得到解决。 因为需要使用完全信任才能指定<xref:System.Xml.XmlResolver>，也不能设置此属性。</xref:System.Xml.XmlResolver>       使用此冲突解决程序时 XSLT`document()`调用函数。 它不用于解析`xsl:import`和`xsl:include`在样式表中引用的元素。 若要指定<xref:System.Xml.XmlResolver>用来解析`xsl:import`和`xsl:include`引用样式表中的元素使用<xref:System.Xml.Xsl.XslTransform.Load%2A>超负荷运转，此方法采用<xref:System.Xml.XmlResolver>作为其自变量之一。</xref:System.Xml.XmlResolver> </xref:System.Xml.Xsl.XslTransform.Load%2A> </xref:System.Xml.XmlResolver>      1> [!NOTE] 1> 此属性是.NET Framework 1.1 版中过时。 指定<xref:System.Xml.XmlResolver>使用<xref:System.Xml.Xsl.XslTransform.Transform%2A>方法是建议的做法。</xref:System.Xml.Xsl.XslTransform.Transform%2A> </xref:System.Xml.XmlResolver> 在这种情况下，<xref:System.Xml.XmlResolver>后不缓存<xref:System.Xml.Xsl.XslTransform.Transform%2A>方法完成。</xref:System.Xml.Xsl.XslTransform.Transform%2A> </xref:System.Xml.XmlResolver>"
  syntax:
    content: public System.Xml.XmlResolver XmlResolver { set; }
    return:
      type: System.Xml.XmlResolver
      description: "<xref href=&quot;System.Xml.XmlResolver&quot;> </xref>要在转换期间使用。 如果设置为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，XSLT`document()`函数未得到解决。"
  overload: System.Xml.Xsl.XslTransform.XmlResolver*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Xml.Xsl.XsltCompileException
  parent: System.Xml.Xsl
  isExternal: false
  name: XsltCompileException
  nameWithType: XsltCompileException
  fullName: System.Xml.Xsl.XsltCompileException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Xml.Xsl.XslTransform.#ctor
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: XslTransform()
  nameWithType: XslTransform.XslTransform()
  fullName: System.Xml.Xsl.XslTransform.XslTransform()
- uid: System.Xml.Xsl.XslTransform.Load(System.String)
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: Load(String)
  nameWithType: XslTransform.Load(String)
  fullName: System.Xml.Xsl.XslTransform.Load(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Xml.Xsl.XslTransform.Load(System.Xml.XmlReader)
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: Load(XmlReader)
  nameWithType: XslTransform.Load(XmlReader)
  fullName: System.Xml.Xsl.XslTransform.Load(XmlReader)
- uid: System.Xml.XmlReader
  parent: System.Xml
  isExternal: true
  name: XmlReader
  nameWithType: XmlReader
  fullName: System.Xml.XmlReader
- uid: System.Xml.Xsl.XslTransform.Load(System.Xml.XPath.IXPathNavigable)
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: Load(IXPathNavigable)
  nameWithType: XslTransform.Load(IXPathNavigable)
  fullName: System.Xml.Xsl.XslTransform.Load(IXPathNavigable)
- uid: System.Xml.XPath.IXPathNavigable
  parent: System.Xml.XPath
  isExternal: false
  name: IXPathNavigable
  nameWithType: IXPathNavigable
  fullName: System.Xml.XPath.IXPathNavigable
- uid: System.Xml.Xsl.XslTransform.Load(System.Xml.XPath.XPathNavigator)
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: Load(XPathNavigator)
  nameWithType: XslTransform.Load(XPathNavigator)
  fullName: System.Xml.Xsl.XslTransform.Load(XPathNavigator)
- uid: System.Xml.XPath.XPathNavigator
  parent: System.Xml.XPath
  isExternal: false
  name: XPathNavigator
  nameWithType: XPathNavigator
  fullName: System.Xml.XPath.XPathNavigator
- uid: System.Xml.Xsl.XslTransform.Load(System.String,System.Xml.XmlResolver)
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: Load(String,XmlResolver)
  nameWithType: XslTransform.Load(String,XmlResolver)
  fullName: System.Xml.Xsl.XslTransform.Load(String,XmlResolver)
- uid: System.Xml.XmlResolver
  parent: System.Xml
  isExternal: false
  name: XmlResolver
  nameWithType: XmlResolver
  fullName: System.Xml.XmlResolver
- uid: System.Xml.Xsl.XslTransform.Load(System.Xml.XmlReader,System.Xml.XmlResolver)
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: Load(XmlReader,XmlResolver)
  nameWithType: XslTransform.Load(XmlReader,XmlResolver)
  fullName: System.Xml.Xsl.XslTransform.Load(XmlReader,XmlResolver)
- uid: System.Xml.Xsl.XslTransform.Load(System.Xml.XPath.IXPathNavigable,System.Xml.XmlResolver)
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: Load(IXPathNavigable,XmlResolver)
  nameWithType: XslTransform.Load(IXPathNavigable,XmlResolver)
  fullName: System.Xml.Xsl.XslTransform.Load(IXPathNavigable,XmlResolver)
- uid: System.Xml.Xsl.XslTransform.Load(System.Xml.XPath.XPathNavigator,System.Xml.XmlResolver)
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: Load(XPathNavigator,XmlResolver)
  nameWithType: XslTransform.Load(XPathNavigator,XmlResolver)
  fullName: System.Xml.Xsl.XslTransform.Load(XPathNavigator,XmlResolver)
- uid: System.Xml.Xsl.XslTransform.Load(System.Xml.XmlReader,System.Xml.XmlResolver,System.Security.Policy.Evidence)
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: Load(XmlReader,XmlResolver,Evidence)
  nameWithType: XslTransform.Load(XmlReader,XmlResolver,Evidence)
  fullName: System.Xml.Xsl.XslTransform.Load(XmlReader,XmlResolver,Evidence)
- uid: System.Security.Policy.Evidence
  parent: System.Security.Policy
  isExternal: false
  name: Evidence
  nameWithType: Evidence
  fullName: System.Security.Policy.Evidence
- uid: System.Xml.Xsl.XslTransform.Load(System.Xml.XPath.IXPathNavigable,System.Xml.XmlResolver,System.Security.Policy.Evidence)
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: Load(IXPathNavigable,XmlResolver,Evidence)
  nameWithType: XslTransform.Load(IXPathNavigable,XmlResolver,Evidence)
  fullName: System.Xml.Xsl.XslTransform.Load(IXPathNavigable,XmlResolver,Evidence)
- uid: System.Xml.Xsl.XslTransform.Load(System.Xml.XPath.XPathNavigator,System.Xml.XmlResolver,System.Security.Policy.Evidence)
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: Load(XPathNavigator,XmlResolver,Evidence)
  nameWithType: XslTransform.Load(XPathNavigator,XmlResolver,Evidence)
  fullName: System.Xml.Xsl.XslTransform.Load(XPathNavigator,XmlResolver,Evidence)
- uid: System.Xml.Xsl.XslTransform.Transform(System.String,System.String)
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: Transform(String,String)
  nameWithType: XslTransform.Transform(String,String)
  fullName: System.Xml.Xsl.XslTransform.Transform(String,String)
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList)
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: Transform(IXPathNavigable,XsltArgumentList)
  nameWithType: XslTransform.Transform(IXPathNavigable,XsltArgumentList)
  fullName: System.Xml.Xsl.XslTransform.Transform(IXPathNavigable,XsltArgumentList)
- uid: System.Xml.Xsl.XsltArgumentList
  parent: System.Xml.Xsl
  isExternal: false
  name: XsltArgumentList
  nameWithType: XsltArgumentList
  fullName: System.Xml.Xsl.XsltArgumentList
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList)
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: Transform(XPathNavigator,XsltArgumentList)
  nameWithType: XslTransform.Transform(XPathNavigator,XsltArgumentList)
  fullName: System.Xml.Xsl.XslTransform.Transform(XPathNavigator,XsltArgumentList)
- uid: System.Xml.Xsl.XslTransform.Transform(System.String,System.String,System.Xml.XmlResolver)
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: Transform(String,String,XmlResolver)
  nameWithType: XslTransform.Transform(String,String,XmlResolver)
  fullName: System.Xml.Xsl.XslTransform.Transform(String,String,XmlResolver)
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList,System.IO.Stream)
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: Transform(IXPathNavigable,XsltArgumentList,Stream)
  nameWithType: XslTransform.Transform(IXPathNavigable,XsltArgumentList,Stream)
  fullName: System.Xml.Xsl.XslTransform.Transform(IXPathNavigable,XsltArgumentList,Stream)
- uid: System.IO.Stream
  parent: System.IO
  isExternal: true
  name: Stream
  nameWithType: Stream
  fullName: System.IO.Stream
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList,System.IO.TextWriter)
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: Transform(IXPathNavigable,XsltArgumentList,TextWriter)
  nameWithType: XslTransform.Transform(IXPathNavigable,XsltArgumentList,TextWriter)
  fullName: System.Xml.Xsl.XslTransform.Transform(IXPathNavigable,XsltArgumentList,TextWriter)
- uid: System.IO.TextWriter
  parent: System.IO
  isExternal: true
  name: TextWriter
  nameWithType: TextWriter
  fullName: System.IO.TextWriter
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList,System.Xml.XmlResolver)
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: Transform(IXPathNavigable,XsltArgumentList,XmlResolver)
  nameWithType: XslTransform.Transform(IXPathNavigable,XsltArgumentList,XmlResolver)
  fullName: System.Xml.Xsl.XslTransform.Transform(IXPathNavigable,XsltArgumentList,XmlResolver)
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList,System.Xml.XmlWriter)
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: Transform(IXPathNavigable,XsltArgumentList,XmlWriter)
  nameWithType: XslTransform.Transform(IXPathNavigable,XsltArgumentList,XmlWriter)
  fullName: System.Xml.Xsl.XslTransform.Transform(IXPathNavigable,XsltArgumentList,XmlWriter)
- uid: System.Xml.XmlWriter
  parent: System.Xml
  isExternal: true
  name: XmlWriter
  nameWithType: XmlWriter
  fullName: System.Xml.XmlWriter
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.IO.Stream)
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: Transform(XPathNavigator,XsltArgumentList,Stream)
  nameWithType: XslTransform.Transform(XPathNavigator,XsltArgumentList,Stream)
  fullName: System.Xml.Xsl.XslTransform.Transform(XPathNavigator,XsltArgumentList,Stream)
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.IO.TextWriter)
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: Transform(XPathNavigator,XsltArgumentList,TextWriter)
  nameWithType: XslTransform.Transform(XPathNavigator,XsltArgumentList,TextWriter)
  fullName: System.Xml.Xsl.XslTransform.Transform(XPathNavigator,XsltArgumentList,TextWriter)
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.Xml.XmlResolver)
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: Transform(XPathNavigator,XsltArgumentList,XmlResolver)
  nameWithType: XslTransform.Transform(XPathNavigator,XsltArgumentList,XmlResolver)
  fullName: System.Xml.Xsl.XslTransform.Transform(XPathNavigator,XsltArgumentList,XmlResolver)
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.Xml.XmlWriter)
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: Transform(XPathNavigator,XsltArgumentList,XmlWriter)
  nameWithType: XslTransform.Transform(XPathNavigator,XsltArgumentList,XmlWriter)
  fullName: System.Xml.Xsl.XslTransform.Transform(XPathNavigator,XsltArgumentList,XmlWriter)
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList,System.IO.Stream,System.Xml.XmlResolver)
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: Transform(IXPathNavigable,XsltArgumentList,Stream,XmlResolver)
  nameWithType: XslTransform.Transform(IXPathNavigable,XsltArgumentList,Stream,XmlResolver)
  fullName: System.Xml.Xsl.XslTransform.Transform(IXPathNavigable,XsltArgumentList,Stream,XmlResolver)
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList,System.IO.TextWriter,System.Xml.XmlResolver)
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: Transform(IXPathNavigable,XsltArgumentList,TextWriter,XmlResolver)
  nameWithType: XslTransform.Transform(IXPathNavigable,XsltArgumentList,TextWriter,XmlResolver)
  fullName: System.Xml.Xsl.XslTransform.Transform(IXPathNavigable,XsltArgumentList,TextWriter,XmlResolver)
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList,System.Xml.XmlWriter,System.Xml.XmlResolver)
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: Transform(IXPathNavigable,XsltArgumentList,XmlWriter,XmlResolver)
  nameWithType: XslTransform.Transform(IXPathNavigable,XsltArgumentList,XmlWriter,XmlResolver)
  fullName: System.Xml.Xsl.XslTransform.Transform(IXPathNavigable,XsltArgumentList,XmlWriter,XmlResolver)
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.IO.Stream,System.Xml.XmlResolver)
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: Transform(XPathNavigator,XsltArgumentList,Stream,XmlResolver)
  nameWithType: XslTransform.Transform(XPathNavigator,XsltArgumentList,Stream,XmlResolver)
  fullName: System.Xml.Xsl.XslTransform.Transform(XPathNavigator,XsltArgumentList,Stream,XmlResolver)
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.IO.TextWriter,System.Xml.XmlResolver)
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: Transform(XPathNavigator,XsltArgumentList,TextWriter,XmlResolver)
  nameWithType: XslTransform.Transform(XPathNavigator,XsltArgumentList,TextWriter,XmlResolver)
  fullName: System.Xml.Xsl.XslTransform.Transform(XPathNavigator,XsltArgumentList,TextWriter,XmlResolver)
- uid: System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.Xml.XmlWriter,System.Xml.XmlResolver)
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: Transform(XPathNavigator,XsltArgumentList,XmlWriter,XmlResolver)
  nameWithType: XslTransform.Transform(XPathNavigator,XsltArgumentList,XmlWriter,XmlResolver)
  fullName: System.Xml.Xsl.XslTransform.Transform(XPathNavigator,XsltArgumentList,XmlWriter,XmlResolver)
- uid: System.Xml.Xsl.XslTransform.XmlResolver
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: XmlResolver
  nameWithType: XslTransform.XmlResolver
  fullName: System.Xml.Xsl.XslTransform.XmlResolver
- uid: System.Xml.Xsl.XslTransform.#ctor*
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: XslTransform
  nameWithType: XslTransform.XslTransform
- uid: System.Xml.Xsl.XslTransform.Load*
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: Load
  nameWithType: XslTransform.Load
- uid: System.Xml.Xsl.XslTransform.Transform*
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: Transform
  nameWithType: XslTransform.Transform
- uid: System.Xml.Xsl.XslTransform.XmlResolver*
  parent: System.Xml.Xsl.XslTransform
  isExternal: false
  name: XmlResolver
  nameWithType: XslTransform.XmlResolver
