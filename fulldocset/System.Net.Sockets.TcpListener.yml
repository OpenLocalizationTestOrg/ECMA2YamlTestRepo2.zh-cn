### YamlMime:ManagedReference
items:
- uid: System.Net.Sockets.TcpListener
  id: TcpListener
  children:
  - System.Net.Sockets.TcpListener.#ctor(System.Int32)
  - System.Net.Sockets.TcpListener.#ctor(System.Net.IPEndPoint)
  - System.Net.Sockets.TcpListener.#ctor(System.Net.IPAddress,System.Int32)
  - System.Net.Sockets.TcpListener.AcceptSocket
  - System.Net.Sockets.TcpListener.AcceptSocketAsync
  - System.Net.Sockets.TcpListener.AcceptTcpClient
  - System.Net.Sockets.TcpListener.AcceptTcpClientAsync
  - System.Net.Sockets.TcpListener.Active
  - System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)
  - System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)
  - System.Net.Sockets.TcpListener.BeginAcceptTcpClient(System.AsyncCallback,System.Object)
  - System.Net.Sockets.TcpListener.Create(System.Int32)
  - System.Net.Sockets.TcpListener.EndAcceptSocket(System.IAsyncResult)
  - System.Net.Sockets.TcpListener.EndAcceptTcpClient(System.IAsyncResult)
  - System.Net.Sockets.TcpListener.ExclusiveAddressUse
  - System.Net.Sockets.TcpListener.LocalEndpoint
  - System.Net.Sockets.TcpListener.Pending
  - System.Net.Sockets.TcpListener.Server
  - System.Net.Sockets.TcpListener.Start
  - System.Net.Sockets.TcpListener.Start(System.Int32)
  - System.Net.Sockets.TcpListener.Stop
  langs:
  - csharp
  name: TcpListener
  nameWithType: TcpListener
  fullName: System.Net.Sockets.TcpListener
  type: Class
  summary: "侦听来自 TCP 网络客户端连接。"
  remarks: "TcpListener 类提供侦听和接受传入连接请求，在阻止同步模式的简单方法。 你可以使用<xref:System.Net.Sockets.TcpClient>或<xref:System.Net.Sockets.Socket>使用 TcpListener 进行连接。</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.TcpClient> 创建 TcpListener 使用<xref:System.Net.IPEndPoint>，本地 IP 地址和端口号或只是端口号。</xref:System.Net.IPEndPoint> 指定<xref:System.Net.IPAddress.Any>本地 IP 地址和本地端口号，如果你想要为您分配这些值的基础服务提供程序为 0。</xref:System.Net.IPAddress.Any> 如果你选择这样做，则可以使用<xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>属性来标识已指定的信息后套接字连接。</xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>       使用<xref:System.Net.Sockets.TcpListener.Start%2A>方法，以开始侦听传入连接请求。</xref:System.Net.Sockets.TcpListener.Start%2A> <xref:System.Net.Sockets.TcpListener.Start%2A>将队列传入连接，直到你调用的<xref:System.Net.Sockets.TcpListener.Stop%2A>方法或它已排队<xref:System.Net.Sockets.SocketOptionName>.</xref:System.Net.Sockets.SocketOptionName> </xref:System.Net.Sockets.TcpListener.Stop%2A></xref:System.Net.Sockets.TcpListener.Start%2A> 可以使用两种<xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>或<xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>请求从传入的连接请求队列的连接。</xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> </xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> 将阻止这两种方法。 如果你想要避免阻止，则可以使用<xref:System.Net.Sockets.TcpListener.Pending%2A>方法首先确定连接请求是否可在队列中。</xref:System.Net.Sockets.TcpListener.Pending%2A>       调用<xref:System.Net.Sockets.TcpListener.Stop%2A>方法来关闭 TcpListener。</xref:System.Net.Sockets.TcpListener.Stop%2A>      1> [!NOTE]&1;><xref:System.Net.Sockets.TcpListener.Stop%2A>方法不会关闭任何已接受的连接。</xref:System.Net.Sockets.TcpListener.Stop%2A> 你负责分别关闭这些连接。"
  example:
  - "The following code example creates a TcpListener.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener#1](~/add/codesnippet/cpp/t-system.net.sockets.tcp_0_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener#1](~/add/codesnippet/csharp/t-system.net.sockets.tcp_0_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener#1](~/add/codesnippet/visualbasic/t-system.net.sockets.tcp_0_1.vb)]  \n  \n See <xref:System.Net.Sockets.TcpClient> for a client example."
  syntax:
    content: public class TcpListener
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: TcpListener(Int32)
  nameWithType: TcpListener.TcpListener(Int32)
  fullName: System.Net.Sockets.TcpListener.TcpListener(Int32)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "初始化的新实例<xref href=&quot;System.Net.Sockets.TcpListener&quot;></xref>在指定端口侦听的类。"
  remarks: "此构造函数已废弃不用。 使用<xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPAddress%2CSystem.Int32%29?displayProperty=fullName>或<xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPEndPoint%29?displayProperty=fullName>构造函数。</xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPEndPoint%29?displayProperty=fullName> </xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPAddress%2CSystem.Int32%29?displayProperty=fullName>       此构造函数，可指定用于侦听传入的连接尝试的端口号。 使用此构造函数，基础服务提供程序将分配的最合适的网络地址。 如果你不关心使用哪个本地端口，则可以指定的端口号 0。 在这种情况下，服务提供商将分配 1024年和 5000 之间可用的端口号。 如果使用此方法时，你可能会发现已使用分配了哪些本地网络地址和端口数量<xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>属性。</xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>       调用<xref:System.Net.Sockets.TcpListener.Start%2A>方法，以开始侦听传入的连接尝试。</xref:System.Net.Sockets.TcpListener.Start%2A>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.TcpListener> using a local port number.  \n  \n [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/add/codesnippet/cpp/m-system.net.sockets.tcp_18_1.cpp)]\n [!code-cs[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/add/codesnippet/csharp/m-system.net.sockets.tcp_18_1.cs)]\n [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_18_1.vb)]"
  syntax:
    content: public TcpListener (int port);
    parameters:
    - id: port
      type: System.Int32
      description: "要传入的连接尝试的侦听端口。"
  overload: System.Net.Sockets.TcpListener.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>port</code>不介于<xref:System.Net.IPEndPoint.MinPort>和<xref:System.Net.IPEndPoint.MaxPort>。"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.#ctor(System.Net.IPEndPoint)
  id: '#ctor(System.Net.IPEndPoint)'
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: TcpListener(IPEndPoint)
  nameWithType: TcpListener.TcpListener(IPEndPoint)
  fullName: System.Net.Sockets.TcpListener.TcpListener(IPEndPoint)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "初始化的新实例<xref href=&quot;System.Net.Sockets.TcpListener&quot;></xref>与指定的本地终结点的类。"
  remarks: "此构造函数允许你指定的本地 IP 地址和端口号用于侦听传入的连接尝试。 使用此构造函数之前，必须创建<xref:System.Net.IPEndPoint>使用所需的本地 IP 地址和端口号。</xref:System.Net.IPEndPoint> 将此传递<xref:System.Net.IPEndPoint>到构造函数、 作为`localEP`参数。</xref:System.Net.IPEndPoint>       如果你不关心哪些本地地址分配，你可以创建<xref:System.Net.IPEndPoint>使用<xref:System.Net.IPAddress.Any?displayProperty=fullName>地址参数，以及基础服务提供程序将分配的最合适的网络地址。</xref:System.Net.IPAddress.Any?displayProperty=fullName> </xref:System.Net.IPEndPoint> 这可能有助于简化你的应用程序，如果你有多个网络接口。 如果你不关心使用哪个本地端口，则可以创建<xref:System.Net.IPEndPoint>使用 0 作为端口号。</xref:System.Net.IPEndPoint> 在这种情况下，服务提供商将分配 1024年和 5000 之间可用的端口号。 如果使用此方法时，你可能会发现已使用分配了哪些本地网络地址和端口数量<xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>属性。</xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>       调用<xref:System.Net.Sockets.TcpListener.Start%2A>方法，以开始侦听传入的连接尝试。</xref:System.Net.Sockets.TcpListener.Start%2A>      1> [!NOTE]&1;> 时你的应用程序中启用网络跟踪，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example creates an instance of the <xref:System.Net.Sockets.TcpListener> class using the local endpoint.  \n  \n [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/add/codesnippet/cpp/m-system.net.sockets.tcp_20_1.cpp)]\n [!code-cs[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/add/codesnippet/csharp/m-system.net.sockets.tcp_20_1.cs)]\n [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_20_1.vb)]"
  syntax:
    content: public TcpListener (System.Net.IPEndPoint localEP);
    parameters:
    - id: localEP
      type: System.Net.IPEndPoint
      description: "<xref:System.Net.IPEndPoint>表示要将侦听器<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>绑定到的本地终结点</xref:System.Net.IPEndPoint>"
  overload: System.Net.Sockets.TcpListener.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>localEP</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.#ctor(System.Net.IPAddress,System.Int32)
  id: '#ctor(System.Net.IPAddress,System.Int32)'
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: TcpListener(IPAddress,Int32)
  nameWithType: TcpListener.TcpListener(IPAddress,Int32)
  fullName: System.Net.Sockets.TcpListener.TcpListener(IPAddress,Int32)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "初始化的新实例<xref href=&quot;System.Net.Sockets.TcpListener&quot;></xref>侦听传入连接的类尝试在指定的本地 IP 地址和端口号。"
  remarks: "此构造函数允许你指定的本地 IP 地址和端口号用于侦听传入的连接尝试。 在调用此构造函数之前你必须首先创建<xref:System.Net.IPAddress>使用所需的本地地址。</xref:System.Net.IPAddress> 将此传递<xref:System.Net.IPAddress>到构造函数、 作为`localaddr`参数。</xref:System.Net.IPAddress> 如果你不关心分配的本地地址，指定<xref:System.Net.IPAddress.Any?displayProperty=fullName>为`localaddr`参数，并且基础服务提供程序将分配的最合适的网络地址。</xref:System.Net.IPAddress.Any?displayProperty=fullName> 这可能有助于简化你的应用程序，如果你有多个网络接口。 如果你不关心使用哪个本地端口，则可以指定的端口号 0。 在这种情况下，服务提供商将分配 1024年和 5000 之间可用的端口号。 如果使用此方法时，你可能会发现已使用分配了哪些本地网络地址和端口数量<xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>属性。</xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>       调用<xref:System.Net.Sockets.TcpListener.Start%2A>方法，以开始侦听传入的连接尝试。</xref:System.Net.Sockets.TcpListener.Start%2A>      1> [!NOTE]&1;> 时你的应用程序中启用网络跟踪，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example creates an instance of the <xref:System.Net.Sockets.TcpListener> class using a local IP address and port number.  \n  \n [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/add/codesnippet/cpp/m-system.net.sockets.tcp_19_1.cpp)]\n [!code-cs[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/add/codesnippet/csharp/m-system.net.sockets.tcp_19_1.cs)]\n [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_19_1.vb)]"
  syntax:
    content: public TcpListener (System.Net.IPAddress localaddr, int port);
    parameters:
    - id: localaddr
      type: System.Net.IPAddress
      description: "<xref:System.Net.IPAddress>表示本地 IP 地址。</xref:System.Net.IPAddress>"
    - id: port
      type: System.Int32
      description: "要传入的连接尝试的侦听端口。"
  overload: System.Net.Sockets.TcpListener.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>localaddr</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>port</code>不介于<xref:System.Net.IPEndPoint.MinPort>和<xref:System.Net.IPEndPoint.MaxPort>。"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.AcceptSocket
  id: AcceptSocket
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: AcceptSocket()
  nameWithType: TcpListener.AcceptSocket()
  fullName: System.Net.Sockets.TcpListener.AcceptSocket()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "接受挂起的连接请求。"
  remarks: "AcceptSocket 是返回一个阻止方法<xref:System.Net.Sockets.Socket>可用于发送和接收数据。</xref:System.Net.Sockets.Socket> 如果你想要避免阻止，使用<xref:System.Net.Sockets.TcpListener.Pending%2A>方法来确定是否可在传入的连接队列连接请求。</xref:System.Net.Sockets.TcpListener.Pending%2A>       <xref:System.Net.Sockets.Socket>返回初始化与远程主机的 IP 地址和端口号。</xref:System.Net.Sockets.Socket> 你可以使用任一<xref:System.Net.Sockets.Socket.Send%2A>和<xref:System.Net.Sockets.Socket.Receive%2A>方法中提供<xref:System.Net.Sockets.Socket>类与远程主机通信。</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket.Receive%2A> </xref:System.Net.Sockets.Socket.Send%2A> 完成之后使用<xref:System.Net.Sockets.Socket>，一定要调用其<xref:System.Net.Sockets.Socket.Close%2A>方法。</xref:System.Net.Sockets.Socket.Close%2A> </xref:System.Net.Sockets.Socket> 如果你的应用程序相对简单，请考虑使用<xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>方法，而不是 AcceptSocket 方法。</xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> <xref:System.Net.Sockets.TcpClient>用于发送和接收数据通过阻止同步模式下的网络提供了简单的方法。</xref:System.Net.Sockets.TcpClient>      1> [!NOTE]&1;> 时你的应用程序中启用网络跟踪，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "In the following code example, the AcceptSocket method is used to return a <xref:System.Net.Sockets.Socket>. This <xref:System.Net.Sockets.Socket> is used to communicate with the newly connected client.  \n  \n [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/add/codesnippet/cpp/m-system.net.sockets.tcp_7_1.cpp)]\n [!code-cs[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/add/codesnippet/csharp/m-system.net.sockets.tcp_7_1.cs)]\n [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_7_1.vb)]"
  syntax:
    content: public System.Net.Sockets.Socket AcceptSocket ();
    parameters: []
    return:
      type: System.Net.Sockets.Socket
      description: "A<xref:System.Net.Sockets.Socket>用于发送和接收数据。</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.TcpListener.AcceptSocket*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "通过调用<xref:System.Net.Sockets.TcpListener.Start*>.</xref:System.Net.Sockets.TcpListener.Start*>尚未启动侦听器"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.AcceptSocketAsync
  id: AcceptSocketAsync
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: AcceptSocketAsync()
  nameWithType: TcpListener.AcceptSocketAsync()
  fullName: System.Net.Sockets.TcpListener.AcceptSocketAsync()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "作为异步操作接受挂起的连接请求。"
  remarks: "不会阻止此操作。 返回<xref:System.Threading.Tasks.Task%601>对象都完成后的套接字连接已被接受。</xref:System.Threading.Tasks.Task%601>       <xref:System.Net.Sockets.Socket>中返回<xref:System.Threading.Tasks.Task%601>初始化与远程主机的 IP 地址和端口号。</xref:System.Threading.Tasks.Task%601> </xref:System.Net.Sockets.Socket> 你可以使用任一<xref:System.Net.Sockets.Socket.Send%2A>和<xref:System.Net.Sockets.Socket.Receive%2A>方法中提供<xref:System.Net.Sockets.Socket>类与远程主机通信。</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket.Receive%2A> </xref:System.Net.Sockets.Socket.Send%2A> 完成之后使用<xref:System.Net.Sockets.Socket>，一定要调用其<xref:System.Net.Sockets.Socket.Close%2A>方法。</xref:System.Net.Sockets.Socket.Close%2A> </xref:System.Net.Sockets.Socket> 如果你的应用程序相对简单，请考虑使用<xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>方法，而不是 AcceptSocketAsync 方法。</xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> <xref:System.Net.Sockets.TcpClient>用于发送和接收数据通过阻止同步模式下的网络提供了简单的方法。</xref:System.Net.Sockets.TcpClient>      1> [!NOTE]&1;> 时你的应用程序中启用网络跟踪，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public System.Threading.Tasks.Task<System.Net.Sockets.Socket> AcceptSocketAsync ();
    parameters: []
    return:
      type: System.Threading.Tasks.Task{System.Net.Sockets.Socket}
      description: "返回&lt;xref:System.Threading.Tasks.Task%601&gt;表示异步操作的任务对象。 &lt;Xref:System.Threading.Tasks.Task%601.Result%2A&gt;任务对象上的属性返回<xref:System.Net.Sockets.Socket>用于发送和接收数据。</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.TcpListener.AcceptSocketAsync*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "通过调用<xref:System.Net.Sockets.TcpListener.Start*>.</xref:System.Net.Sockets.TcpListener.Start*>尚未启动侦听器"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.AcceptTcpClient
  id: AcceptTcpClient
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: AcceptTcpClient()
  nameWithType: TcpListener.AcceptTcpClient()
  fullName: System.Net.Sockets.TcpListener.AcceptTcpClient()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "接受挂起的连接请求。"
  remarks: "AcceptTcpClient 是返回一个阻止方法<xref:System.Net.Sockets.TcpClient>可用于发送和接收数据。</xref:System.Net.Sockets.TcpClient> 使用<xref:System.Net.Sockets.TcpListener.Pending%2A>方法来确定是否连接请求将传入的连接队列中可用，是否你想要避免妨碍。</xref:System.Net.Sockets.TcpListener.Pending%2A>       使用<xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=fullName>方法来获取基础<xref:System.Net.Sockets.NetworkStream>的返回<xref:System.Net.Sockets.TcpClient>。</xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=fullName> <xref:System.Net.Sockets.NetworkStream>将为你提供方法用于发送和接收与远程主机。</xref:System.Net.Sockets.NetworkStream> 当您将通过与<xref:System.Net.Sockets.TcpClient>，一定要调用其<xref:System.Net.Sockets.TcpClient.Close%2A>方法。</xref:System.Net.Sockets.TcpClient.Close%2A> </xref:System.Net.Sockets.TcpClient> 如果你想比<xref:System.Net.Sockets.TcpClient>提供，请考虑使用<xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>.</xref:System.Net.Sockets.TcpListener.AcceptSocket%2A></xref:System.Net.Sockets.TcpClient>更大的灵活性      1> [!NOTE]&1;> 时你的应用程序中启用网络跟踪，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "In the following code example, the AcceptTcpClient method is used to return a <xref:System.Net.Sockets.TcpClient>. This <xref:System.Net.Sockets.TcpClient> is used to communicate with the newly connected client.  \n  \n [!code-cs[Classic TcpListenerExample#1](~/add/codesnippet/csharp/m-system.net.sockets.tcp_15_1.cs)]\n [!code-cpp[Classic TcpListenerExample#1](~/add/codesnippet/cpp/m-system.net.sockets.tcp_15_1.cpp)]\n [!code-vb[Classic TcpListenerExample#1](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_15_1.vb)]"
  syntax:
    content: public System.Net.Sockets.TcpClient AcceptTcpClient ();
    parameters: []
    return:
      type: System.Net.Sockets.TcpClient
      description: "A <xref href=&quot;System.Net.Sockets.TcpClient&quot;> </xref>用于发送和接收数据。"
  overload: System.Net.Sockets.TcpListener.AcceptTcpClient*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "通过调用<xref:System.Net.Sockets.TcpListener.Start*>.</xref:System.Net.Sockets.TcpListener.Start*>尚未启动侦听器"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "使用&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;属性来获取特定的错误代码。 当你已获得此代码时，你可以参考 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.AcceptTcpClientAsync
  id: AcceptTcpClientAsync
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: AcceptTcpClientAsync()
  nameWithType: TcpListener.AcceptTcpClientAsync()
  fullName: System.Net.Sockets.TcpListener.AcceptTcpClientAsync()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "作为异步操作接受挂起的连接请求。"
  remarks: "不会阻止此操作。 返回<xref:System.Threading.Tasks.Task%601>对象都完成后的 TCP 连接已被接受。</xref:System.Threading.Tasks.Task%601>       使用<xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=fullName>方法来获取基础<xref:System.Net.Sockets.NetworkStream>返回<xref:System.Net.Sockets.TcpClient>在<xref:System.Threading.Tasks.Task%601>。</xref:System.Threading.Tasks.Task%601> </xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=fullName> <xref:System.Net.Sockets.NetworkStream>将为你提供方法用于发送和接收与远程主机。</xref:System.Net.Sockets.NetworkStream> 当您将通过与<xref:System.Net.Sockets.TcpClient>，一定要调用其<xref:System.Net.Sockets.TcpClient.Close%2A>方法。</xref:System.Net.Sockets.TcpClient.Close%2A> </xref:System.Net.Sockets.TcpClient> 如果你想比<xref:System.Net.Sockets.TcpClient>提供，请考虑使用<xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>或<xref:System.Net.Sockets.TcpListener.AcceptSocketAsync%2A>.</xref:System.Net.Sockets.TcpListener.AcceptSocketAsync%2A></xref:System.Net.Sockets.TcpListener.AcceptSocket%2A></xref:System.Net.Sockets.TcpClient>更大的灵活性      1> [!NOTE]&1;> 时你的应用程序中启用网络跟踪，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public System.Threading.Tasks.Task<System.Net.Sockets.TcpClient> AcceptTcpClientAsync ();
    parameters: []
    return:
      type: System.Threading.Tasks.Task{System.Net.Sockets.TcpClient}
      description: "返回&lt;xref:System.Threading.Tasks.Task%601&gt;表示异步操作的任务对象。 &lt;Xref:System.Threading.Tasks.Task%601.Result%2A&gt;任务对象上的属性返回<xref href=&quot;System.Net.Sockets.TcpClient&quot;></xref>用于发送和接收数据。"
  overload: System.Net.Sockets.TcpListener.AcceptTcpClientAsync*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "通过调用<xref:System.Net.Sockets.TcpListener.Start*>.</xref:System.Net.Sockets.TcpListener.Start*>尚未启动侦听器"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "使用&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;属性来获取特定的错误代码。 当你已获得此代码时，你可以参考 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.Active
  id: Active
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: Active
  nameWithType: TcpListener.Active
  fullName: System.Net.Sockets.TcpListener.Active
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "获取一个值，该值指示是否<xref href=&quot;System.Net.Sockets.TcpListener&quot;></xref>主动侦听客户端连接。"
  remarks: "类派生自<xref:System.Net.Sockets.TcpListener>可以使用此属性来确定如果<xref:System.Net.Sockets.Socket>程序当前正在侦听传入的连接尝试。</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.TcpListener> <xref:System.Net.Sockets.TcpClient.Active%2A>属性可以用于避免冗余<xref:System.Net.Sockets.TcpListener.Start%2A>尝试。</xref:System.Net.Sockets.TcpListener.Start%2A> </xref:System.Net.Sockets.TcpClient.Active%2A>"
  syntax:
    content: protected bool Active { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Net.Sockets.TcpListener&quot;></xref>主动侦听; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Sockets.TcpListener.Active*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)
  id: AllowNatTraversal(System.Boolean)
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: AllowNatTraversal(Boolean)
  nameWithType: TcpListener.AllowNatTraversal(Boolean)
  fullName: System.Net.Sockets.TcpListener.AllowNatTraversal(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "启用或禁用在网络地址转换 (NAT) 遍历<xref href=&quot;System.Net.Sockets.TcpListener&quot;></xref>实例。"
  remarks: "AllowNatTraversal 方法用于启用或禁用的 NAT 遍历<xref:System.Net.Sockets.TcpListener>实例。</xref:System.Net.Sockets.TcpListener> 可能使用 Teredo、 6to4 或 ISATAP 隧道提供 NAT 遍历。       当`allowed`参数为 false，<xref:System.Net.Sockets.SocketOptionName>关联的套接字上的选项设置为<xref:System.Net.Sockets.IPProtectionLevel>。</xref:System.Net.Sockets.IPProtectionLevel> </xref:System.Net.Sockets.SocketOptionName> 这将显式禁止 NAT 遍历<xref:System.Net.Sockets.TcpListener>实例。</xref:System.Net.Sockets.TcpListener>       当`allowed`参数为 true，<xref:System.Net.Sockets.SocketOptionName>关联的套接字上的选项设置为<xref:System.Net.Sockets.IPProtectionLevel>。</xref:System.Net.Sockets.IPProtectionLevel> </xref:System.Net.Sockets.SocketOptionName> 这可能使 NAT 遍历<xref:System.Net.Sockets.TcpListener>具体取决于系统上实施防火墙规则。</xref:System.Net.Sockets.TcpListener>       必须在调用之前调用的 AllowNatTraversal 方法<xref:System.Net.Sockets.TcpListener.Start%2A>方法，以开始侦听传入的连接请求 （之前不会绑定套接字）。</xref:System.Net.Sockets.TcpListener.Start%2A> 如果 AllowNatTraversal 方法后，会调用<xref:System.Net.Sockets.TcpListener.Start%2A>方法，则<xref:System.InvalidOperationException>将引发。</xref:System.InvalidOperationException> </xref:System.Net.Sockets.TcpListener.Start%2A>       Teredo 地址是 IPv6 地址的前缀为 2001年:: / 32。 Teredo 地址可以返回通过正常的 DNS 名称解析或枚举为分配给了本地接口的 IPv6 地址。"
  syntax:
    content: public void AllowNatTraversal (bool allowed);
    parameters:
    - id: allowed
      type: System.Boolean
      description: "一个布尔值，指定是否启用或禁用 NAT 遍历。"
  overload: System.Net.Sockets.TcpListener.AllowNatTraversal*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "在调用<xref:System.Net.Sockets.TcpListener.Start*>方法</xref:System.Net.Sockets.TcpListener.Start*>之后调用了 AllowNatTraversal 方法"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)
  id: BeginAcceptSocket(System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: BeginAcceptSocket(AsyncCallback,Object)
  nameWithType: TcpListener.BeginAcceptSocket(AsyncCallback,Object)
  fullName: System.Net.Sockets.TcpListener.BeginAcceptSocket(AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "开始一个异步操作以接受传入的连接尝试。"
  remarks: "必须通过调用完成异步 BeginAcceptSocket 操作<xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A>方法。</xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A> 通常情况下，通过调用该方法`callback`委托。       此方法不会阻止该操作完成之前。 若要阻止该操作完成之前，请使用<xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>方法。</xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>       有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/add/includes/ajax-current-ext-md.md)。      1> [!NOTE]&1;> 可以调用<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>属性返回<xref:System.Net.Sockets.Socket>来标识远程主机的网络地址和端口号。</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>      1> [!NOTE] 1> 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>属性来获取特定的错误代码和在 MSDN 库中的 Windows 套接字版本 2 API 错误代码文档是指[http://msdn.microsoft.com/library/](http://msdn.microsoft.com/library/)有关错误的详细说明。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException>      1> [!NOTE]&1;> 时你的应用程序中启用网络跟踪，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example demonstrates the use of the BeginAcceptSocket method to create and connect a socket. The callback delegate calls the <xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A> method to end the asynchronous request.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener1#4](~/add/codesnippet/cpp/1d0c3046-b366-41a2-aab6-_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener1#4](~/add/codesnippet/csharp/1d0c3046-b366-41a2-aab6-_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener1#4](~/add/codesnippet/visualbasic/1d0c3046-b366-41a2-aab6-_1.vb)]"
  syntax:
    content: public IAsyncResult BeginAcceptSocket (AsyncCallback callback, object state);
    parameters:
    - id: callback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>引用操作完成时要调用的方法的委托。</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "一个用户定义的对象，包含接收操作的相关信息。 此对象传递给`callback`时，才完成操作的委托。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>引用异步<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>创建</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.TcpListener.BeginAcceptSocket*
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "尝试访问套接字时出错。 请参阅备注部分以了解更多信息。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref:System.Net.Sockets.Socket>已关闭。</xref:System.Net.Sockets.Socket>"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.BeginAcceptTcpClient(System.AsyncCallback,System.Object)
  id: BeginAcceptTcpClient(System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: BeginAcceptTcpClient(AsyncCallback,Object)
  nameWithType: TcpListener.BeginAcceptTcpClient(AsyncCallback,Object)
  fullName: System.Net.Sockets.TcpListener.BeginAcceptTcpClient(AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "开始一个异步操作以接受传入的连接尝试。"
  remarks: "必须通过调用完成异步 BeginAcceptTcpClient 操作<xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A>方法。</xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A> 通常情况下，通过调用该方法`callback`委托。       此方法不会阻止该操作完成之前。 若要阻止该操作完成之前，请使用<xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>方法。</xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>       有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/add/includes/ajax-current-ext-md.md)。      1> [!NOTE] 1> 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>属性来获取特定的错误代码和在 MSDN 库中的 Windows 套接字版本 2 API 错误代码文档是指[http://msdn.microsoft.com/library/](http://msdn.microsoft.com/library/)有关错误的详细说明。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException>      1> [!NOTE]&1;> 时你的应用程序中启用网络跟踪，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example demonstrates the use of the BeginAcceptTcpClient method to create and connect a socket. The callback delegate calls the <xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A> method to end the asynchronous request.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener1#5](~/add/codesnippet/cpp/5290dfb8-7e8f-4cf6-b64e-_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener1#5](~/add/codesnippet/csharp/5290dfb8-7e8f-4cf6-b64e-_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener1#5](~/add/codesnippet/visualbasic/5290dfb8-7e8f-4cf6-b64e-_1.vb)]"
  syntax:
    content: public IAsyncResult BeginAcceptTcpClient (AsyncCallback callback, object state);
    parameters:
    - id: callback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>引用操作完成时要调用的方法的委托。</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "一个用户定义的对象，包含接收操作的相关信息。 此对象传递给`callback`时，才完成操作的委托。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>引用异步创建<xref href=&quot;System.Net.Sockets.TcpClient&quot;> </xref>。</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.TcpListener.BeginAcceptTcpClient*
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "尝试访问套接字时出错。 请参阅备注部分以了解更多信息。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref:System.Net.Sockets.Socket>已关闭。</xref:System.Net.Sockets.Socket>"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.Create(System.Int32)
  id: Create(System.Int32)
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: Create(Int32)
  nameWithType: TcpListener.Create(Int32)
  fullName: System.Net.Sockets.TcpListener.Create(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "创建一个新<xref href=&quot;System.Net.Sockets.TcpListener&quot;></xref>实例以侦听指定的端口。"
  syntax:
    content: public static System.Net.Sockets.TcpListener Create (int port);
    parameters:
    - id: port
      type: System.Int32
      description: "要传入的连接尝试的侦听端口。"
    return:
      type: System.Net.Sockets.TcpListener
      description: "Returns <xref href=&quot;System.Net.Sockets.TcpListener&quot;></xref>.       一个新<xref href=&quot;System.Net.Sockets.TcpListener&quot;></xref>实例以侦听指定的端口。"
  overload: System.Net.Sockets.TcpListener.Create*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.EndAcceptSocket(System.IAsyncResult)
  id: EndAcceptSocket(System.IAsyncResult)
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: EndAcceptSocket(IAsyncResult)
  nameWithType: TcpListener.EndAcceptSocket(IAsyncResult)
  fullName: System.Net.Sockets.TcpListener.EndAcceptSocket(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "异步接受传入的连接尝试，并创建一个新<xref:System.Net.Sockets.Socket>来处理远程主机通信。</xref:System.Net.Sockets.Socket>"
  remarks: "此方法受到阻止，直到操作完成。 若要以同步方式执行此操作，使用<xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>方法。</xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>      1> [!NOTE]&1;> 可以调用<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>属性返回<xref:System.Net.Sockets.Socket>来标识远程主机的网络地址和端口号。</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>      1> [!NOTE] 1> 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>属性来获取特定的错误代码和在 MSDN 库中的 Windows 套接字版本 2 API 错误代码文档是指[http://msdn.microsoft.com/library/](http://msdn.microsoft.com/library/)有关错误的详细说明。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException>      1> [!NOTE]&1;> 时你的应用程序中启用网络跟踪，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example demonstrates the use of the <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket%2A> method to create and connect a socket. The callback delegate calls the EndAcceptSocket method to end the asynchronous request.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener1#4](~/add/codesnippet/cpp/m-system.net.sockets.tcp_14_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener1#4](~/add/codesnippet/csharp/m-system.net.sockets.tcp_14_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener1#4](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_14_1.vb)]"
  syntax:
    content: public System.Net.Sockets.Socket EndAcceptSocket (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>返回通过调用<xref:System.Net.Sockets.TcpListener.BeginAcceptSocket*>方法。</xref:System.Net.Sockets.TcpListener.BeginAcceptSocket*> </xref:System.IAsyncResult>"
    return:
      type: System.Net.Sockets.Socket
      description: "A <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>       <xref:System.Net.Sockets.Socket>用于发送和接收数据。</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.TcpListener.EndAcceptSocket*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "基础<xref:System.Net.Sockets.Socket>已关闭。</xref:System.Net.Sockets.Socket>"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>asyncResult</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> asyncResult </code>参数不是通过调用<xref:System.Net.Sockets.TcpListener.BeginAcceptSocket*>方法。</xref:System.Net.Sockets.TcpListener.BeginAcceptSocket*>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "EndAcceptSocket 方法之前已调用。"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "尝试访问<xref:System.Net.Sockets.Socket>。</xref:System.Net.Sockets.Socket>时出错 请参阅备注部分以了解更多信息。"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.EndAcceptTcpClient(System.IAsyncResult)
  id: EndAcceptTcpClient(System.IAsyncResult)
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: EndAcceptTcpClient(IAsyncResult)
  nameWithType: TcpListener.EndAcceptTcpClient(IAsyncResult)
  fullName: System.Net.Sockets.TcpListener.EndAcceptTcpClient(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "异步接受传入的连接尝试，并创建一个新<xref href=&quot;System.Net.Sockets.TcpClient&quot;></xref>来处理远程主机通信。"
  remarks: "此方法受到阻止，直到操作完成。 若要以同步方式执行此操作，使用<xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>方法。</xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>      1> [!NOTE]&1;> 可以调用<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>基础套接字的属性 (<xref:System.Net.Sockets.TcpClient.Client%2A>) 来标识远程主机的网络地址和端口号。</xref:System.Net.Sockets.TcpClient.Client%2A> </xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>      1> [!NOTE] 1> 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>属性来获取特定的错误代码和在 MSDN 库中的 Windows 套接字版本 2 API 错误代码文档是指[http://msdn.microsoft.com/library/](http://msdn.microsoft.com/library/)有关错误的详细说明。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException>      1> [!NOTE]&1;> 时你的应用程序中启用网络跟踪，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example demonstrates the use of the <xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient%2A> method to create and connect a socket. The callback delegate calls the EndAcceptTcpClient method to end the asynchronous request.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener1#5](~/add/codesnippet/cpp/m-system.net.sockets.tcp_8_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener1#5](~/add/codesnippet/csharp/m-system.net.sockets.tcp_8_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener1#5](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_8_1.vb)]"
  syntax:
    content: public System.Net.Sockets.TcpClient EndAcceptTcpClient (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>返回通过调用<xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient*>方法。</xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient*> </xref:System.IAsyncResult>"
    return:
      type: System.Net.Sockets.TcpClient
      description: "A <xref href=&quot;System.Net.Sockets.TcpClient&quot;></xref>.       <xref href=&quot;System.Net.Sockets.TcpClient&quot;> </xref>用于发送和接收数据。"
  overload: System.Net.Sockets.TcpListener.EndAcceptTcpClient*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.ExclusiveAddressUse
  id: ExclusiveAddressUse
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: ExclusiveAddressUse
  nameWithType: TcpListener.ExclusiveAddressUse
  fullName: System.Net.Sockets.TcpListener.ExclusiveAddressUse
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "获取或设置<xref:System.Boolean>值，该值指定是否<xref href=&quot;System.Net.Sockets.TcpListener&quot;></xref>允许只有一个基础套接字侦听特定端口</xref:System.Boolean>"
  remarks: "默认情况下，多个侦听器可以侦听特定端口。 但是，只有一个侦听器可以执行网络流量发送到端口的操作。 如果多个侦听器尝试将绑定到特定端口，则采用更具体的 IP 地址处理发送到该端口的网络流量。 你可以使用<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>属性可避免多个侦听器侦听特定端口。</xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>       将之前调用此属性设置<xref:System.Net.Sockets.TcpListener.Start%2A>，或调用<xref:System.Net.Sockets.TcpListener.Stop%2A>方法并将此属性。</xref:System.Net.Sockets.TcpListener.Stop%2A> </xref:System.Net.Sockets.TcpListener.Start%2A>"
  example:
  - "The following code example gets and sets the ExclusiveAddressUse property.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener1#2](~/add/codesnippet/cpp/p-system.net.sockets.tcp_9_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener1#2](~/add/codesnippet/csharp/p-system.net.sockets.tcp_9_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener1#2](~/add/codesnippet/visualbasic/p-system.net.sockets.tcp_9_1.vb)]"
  syntax:
    content: public bool ExclusiveAddressUse { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Net.Sockets.TcpListener&quot;></xref>只允许一个<xref href=&quot;System.Net.Sockets.TcpListener&quot;></xref>以侦听特定端口; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 。 默认值是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>为 Windows Server 2003 和 Windows XP Service Pack 2 及更高版本，和<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>对于所有其他版本。"
  overload: System.Net.Sockets.TcpListener.ExclusiveAddressUse*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Net.Sockets.TcpListener&quot;> </xref>已启动。 调用<xref href=&quot;System.Net.Sockets.TcpListener.Stop&quot;></xref>方法，然后设置<xref:System.Net.Sockets.Socket.ExclusiveAddressUse*>属性。</xref:System.Net.Sockets.Socket.ExclusiveAddressUse*>"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "在尝试访问基础套接字时出错。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "基础<xref:System.Net.Sockets.Socket>已关闭。</xref:System.Net.Sockets.Socket>"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.LocalEndpoint
  id: LocalEndpoint
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: LocalEndpoint
  nameWithType: TcpListener.LocalEndpoint
  fullName: System.Net.Sockets.TcpListener.LocalEndpoint
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "获取基础<xref:System.Net.EndPoint>的当前<xref href=&quot;System.Net.Sockets.TcpListener&quot;> </xref>。</xref:System.Net.EndPoint>"
  remarks: "可以使用 LocalEndpoint 属性来标识用于侦听传入的客户端连接请求，套接字连接后的本地网络接口和端口号。 你必须首先转换此<xref:System.Net.EndPoint>到<xref:System.Net.IPEndPoint>。</xref:System.Net.IPEndPoint> </xref:System.Net.EndPoint> 然后，你可以调用<xref:System.Net.IPEndPoint.Address%2A?displayProperty=fullName>属性来检索本地 IP 地址，与<xref:System.Net.IPEndPoint.Port%2A?displayProperty=fullName>属性来检索本地端口号。</xref:System.Net.IPEndPoint.Port%2A?displayProperty=fullName> </xref:System.Net.IPEndPoint.Address%2A?displayProperty=fullName>"
  example:
  - "The following code example displays the local IP address and port number on which the <xref:System.Net.Sockets.TcpListener> is listening for incoming connection requests.  \n  \n [!code-cpp[TcpListener_Pending_LocalEndPoint#1](~/add/codesnippet/cpp/p-system.net.sockets.tcp_5_1.cpp)]\n [!code-cs[TcpListener_Pending_LocalEndPoint#1](~/add/codesnippet/csharp/p-system.net.sockets.tcp_5_1.cs)]\n [!code-vb[TcpListener_Pending_LocalEndPoint#1](~/add/codesnippet/visualbasic/p-system.net.sockets.tcp_5_1.vb)]"
  syntax:
    content: public System.Net.EndPoint LocalEndpoint { get; }
    return:
      type: System.Net.EndPoint
      description: "<xref:System.Net.EndPoint>到<xref:System.Net.Sockets.Socket>绑定。</xref:System.Net.Sockets.Socket> </xref:System.Net.EndPoint>"
  overload: System.Net.Sockets.TcpListener.LocalEndpoint*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.Pending
  id: Pending
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: Pending()
  nameWithType: TcpListener.Pending()
  fullName: System.Net.Sockets.TcpListener.Pending()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "确定是否存在挂起的连接请求。"
  remarks: "此非阻止方法确定是否有任何挂起的连接请求。 因为<xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>和<xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>方法阻止执行，直到<xref:System.Net.Sockets.TcpListener.Start%2A>方法已排队的传入连接请求，挂起的方法可以用于确定连接之前尝试接受这些条款是否可用。</xref:System.Net.Sockets.TcpListener.Start%2A> </xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> </xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>"
  example:
  - "The following code example checks the Pending method. If a connection request is waiting to be accepted, then a call to the <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> method is made.  \n  \n [!code-cpp[TcpListener_Pending_LocalEndPoint#1](~/add/codesnippet/cpp/m-system.net.sockets.tcp_5_1.cpp)]\n [!code-cs[TcpListener_Pending_LocalEndPoint#1](~/add/codesnippet/csharp/m-system.net.sockets.tcp_5_1.cs)]\n [!code-vb[TcpListener_Pending_LocalEndPoint#1](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_5_1.vb)]"
  syntax:
    content: public bool Pending ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果连接处于挂起状态;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Sockets.TcpListener.Pending*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "通过调用<xref:System.Net.Sockets.TcpListener.Start*>.</xref:System.Net.Sockets.TcpListener.Start*>尚未启动侦听器"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.Server
  id: Server
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: Server
  nameWithType: TcpListener.Server
  fullName: System.Net.Sockets.TcpListener.Server
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "获取基础网络<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.TcpListener>创建<xref:System.Net.Sockets.Socket>侦听传入的客户端连接请求。</xref:System.Net.Sockets.Socket></xref:System.Net.Sockets.TcpListener> <xref:System.Net.Sockets.TcpListener>可以使用此属性来获取此<xref:System.Net.Sockets.Socket>。</xref:System.Net.Sockets.Socket></xref:System.Net.Sockets.TcpListener>从派生的类 使用基础<xref:System.Net.Sockets.Socket>由服务器属性，如果你要求在超出其<xref:System.Net.Sockets.TcpListener>提供。</xref:System.Net.Sockets.TcpListener> </xref:System.Net.Sockets.Socket>      1> [!NOTE]&1;> 的服务器属性只返回<xref:System.Net.Sockets.Socket>用来侦听传入的客户端连接请求。</xref:System.Net.Sockets.Socket> 使用<xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>方法接受挂起的连接请求并获取<xref:System.Net.Sockets.Socket>用于发送和接收数据。</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> 你还可以使用<xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>方法接受挂起的连接请求并获取<xref:System.Net.Sockets.TcpClient>用于发送和接收数据。</xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>"
  example:
  - "The following code example demonstrates the use of the Server property. The underlying <xref:System.Net.Sockets.Socket> is retrieved and the <xref:System.Net.Sockets.SocketOptionName><xref:System.Net.Sockets.Socket> option is configured to time out after 10 seconds if data still remains in the network buffer after the connection is closed.  \n  \n [!code-vb[TcpListenerProtectedMembers1#1](~/add/codesnippet/visualbasic/p-system.net.sockets.tcp_10_1.vb)]\n [!code-cs[TcpListenerProtectedMembers1#1](~/add/codesnippet/csharp/p-system.net.sockets.tcp_10_1.cs)]"
  syntax:
    content: public System.Net.Sockets.Socket Server { get; }
    return:
      type: System.Net.Sockets.Socket
      description: "基础<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.TcpListener.Server*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.Start
  id: Start
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: Start()
  nameWithType: TcpListener.Start()
  fullName: System.Net.Sockets.TcpListener.Start()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "开始侦听传入连接请求。"
  remarks: "Start 方法初始化基础<xref:System.Net.Sockets.Socket>、 将其绑定到的本地终结点，并侦听传入的连接尝试。</xref:System.Net.Sockets.Socket> 如果收到连接请求时，启动方法将对请求进行排队，并继续侦听其他的请求，直到你调用<xref:System.Net.Sockets.TcpListener.Stop%2A>方法。</xref:System.Net.Sockets.TcpListener.Stop%2A> 如果<xref:System.Net.Sockets.TcpListener>接收连接请求它已排入队列的最大连接数后，它会引发<xref:System.Net.Sockets.SocketException>客户端上。</xref:System.Net.Sockets.SocketException> </xref:System.Net.Sockets.TcpListener>       若要从传入的连接队列中删除的连接，使用<xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>方法或<xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>方法。</xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> </xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>方法将从队列删除的连接并返回<xref:System.Net.Sockets.TcpClient>可用于发送和接收数据。</xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>方法将返回<xref:System.Net.Sockets.Socket>可用于执行相同操作。</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> 如果你的应用程序仅需要同步 I/O，使用<xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>。</xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> 对于更多详细行为的控件，使用<xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>。</xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> 连接请求队列中出现一直进行阻止这两种方法。       使用<xref:System.Net.Sockets.TcpListener.Stop%2A>方法来关闭<xref:System.Net.Sockets.TcpListener>并停止侦听。</xref:System.Net.Sockets.TcpListener> </xref:System.Net.Sockets.TcpListener.Stop%2A> 你负责分别关闭所接受的连接。      1> [!NOTE]&1;> 时你的应用程序中启用网络跟踪，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example demonstrates how Start is used to listen for incoming client connection attempts.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener1#3](~/add/codesnippet/cpp/m-system.net.sockets.tcp_6_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener1#3](~/add/codesnippet/csharp/m-system.net.sockets.tcp_6_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener1#3](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_6_1.vb)]"
  syntax:
    content: public void Start ();
    parameters: []
  overload: System.Net.Sockets.TcpListener.Start*
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "使用&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;属性来获取特定的错误代码。 当你已获得此代码时，你可以参考 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.Start(System.Int32)
  id: Start(System.Int32)
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: Start(Int32)
  nameWithType: TcpListener.Start(Int32)
  fullName: System.Net.Sockets.TcpListener.Start(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "开始侦听传入连接请求使用的最大挂起连接数。"
  remarks: "<xref:System.Net.Sockets.TcpListener.Start%2A>方法初始化基础<xref:System.Net.Sockets.Socket>、 将其绑定到的本地终结点，并侦听传入的连接尝试。</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.TcpListener.Start%2A> 如果收到连接请求时，<xref:System.Net.Sockets.TcpListener.Start%2A>将对请求进行排队并继续侦听其他的请求，直到你调用<xref:System.Net.Sockets.TcpListener.Stop%2A>方法。</xref:System.Net.Sockets.TcpListener.Stop%2A> </xref:System.Net.Sockets.TcpListener.Start%2A> 如果<xref:System.Net.Sockets.TcpListener>接收连接请求之后它已排入队列的最大，它将引发的连接数,<xref:System.Net.Sockets.SocketException>客户端上。</xref:System.Net.Sockets.SocketException> </xref:System.Net.Sockets.TcpListener>       若要从传入的连接队列中删除的连接，使用<xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>方法或<xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>方法。</xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> </xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>方法将从队列删除的连接并返回<xref:System.Net.Sockets.TcpClient>可用于发送和接收数据。</xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>方法将返回<xref:System.Net.Sockets.Socket>可用于执行相同操作。</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> 如果你的应用程序仅需要同步 I/O，使用<xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>。</xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> 有关详细行为的控件，请使用<xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>方法。</xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> 连接请求队列中出现一直进行阻止这两种方法。       使用<xref:System.Net.Sockets.TcpListener.Stop%2A>方法来关闭<xref:System.Net.Sockets.TcpListener>并停止侦听。</xref:System.Net.Sockets.TcpListener> </xref:System.Net.Sockets.TcpListener.Stop%2A> 你负责分别关闭所接受的连接。      1> [!NOTE] 1> 使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>属性来获取特定的错误代码和在 MSDN 库中的 Windows 套接字版本 2 API 错误代码文档是指[http://msdn.microsoft.com/library/](http://msdn.microsoft.com/library/)有关错误的详细说明。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>      1> [!NOTE]&1;> 时你的应用程序中启用网络跟踪，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example demonstrates how <xref:System.Net.Sockets.TcpListener.Start%2A> is used to listen for incoming client connection attempts.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener1#3](~/add/codesnippet/cpp/m-system.net.sockets.tcp_17_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener1#3](~/add/codesnippet/csharp/m-system.net.sockets.tcp_17_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener1#3](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_17_1.vb)]"
  syntax:
    content: public void Start (int backlog);
    parameters:
    - id: backlog
      type: System.Int32
      description: "挂起的连接队列的最大长度。"
  overload: System.Net.Sockets.TcpListener.Start*
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "访问套接字时出错。 请参阅备注部分以了解更多信息。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>  backlog </code>参数小于零或超出最大允许的连接数。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "基础<xref:System.Net.Sockets.Socket>为 null。</xref:System.Net.Sockets.Socket>"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.Stop
  id: Stop
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: Stop()
  nameWithType: TcpListener.Stop()
  fullName: System.Net.Sockets.TcpListener.Stop()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "关闭侦听器。"
  remarks: "停止关闭侦听器。 在队列中的任何不可接受的连接请求将会丢失。 远程主机等待连接接受将引发一种<xref:System.Net.Sockets.SocketException>。</xref:System.Net.Sockets.SocketException> 你负责分别关闭所接受的连接。      1> [!NOTE]&1;> 时你的应用程序中启用网络跟踪，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example demonstrates using the Stop method to close the underlying <xref:System.Net.Sockets.Socket>.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener#1](~/add/codesnippet/cpp/m-system.net.sockets.tcp_9_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener#1](~/add/codesnippet/csharp/m-system.net.sockets.tcp_9_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener#1](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_9_1.vb)]"
  syntax:
    content: public void Stop ();
    parameters: []
  overload: System.Net.Sockets.TcpListener.Stop*
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "使用&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;属性来获取特定的错误代码。 当你已获得此代码时，你可以参考 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。"
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Net.Sockets.SocketException
  isExternal: true
  name: System.Net.Sockets.SocketException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Net.Sockets.TcpListener.#ctor(System.Int32)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: TcpListener(Int32)
  nameWithType: TcpListener.TcpListener(Int32)
  fullName: System.Net.Sockets.TcpListener.TcpListener(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Net.Sockets.TcpListener.#ctor(System.Net.IPEndPoint)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: TcpListener(IPEndPoint)
  nameWithType: TcpListener.TcpListener(IPEndPoint)
  fullName: System.Net.Sockets.TcpListener.TcpListener(IPEndPoint)
- uid: System.Net.IPEndPoint
  parent: System.Net
  isExternal: true
  name: IPEndPoint
  nameWithType: IPEndPoint
  fullName: System.Net.IPEndPoint
- uid: System.Net.Sockets.TcpListener.#ctor(System.Net.IPAddress,System.Int32)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: TcpListener(IPAddress,Int32)
  nameWithType: TcpListener.TcpListener(IPAddress,Int32)
  fullName: System.Net.Sockets.TcpListener.TcpListener(IPAddress,Int32)
- uid: System.Net.IPAddress
  parent: System.Net
  isExternal: true
  name: IPAddress
  nameWithType: IPAddress
  fullName: System.Net.IPAddress
- uid: System.Net.Sockets.TcpListener.AcceptSocket
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptSocket()
  nameWithType: TcpListener.AcceptSocket()
  fullName: System.Net.Sockets.TcpListener.AcceptSocket()
- uid: System.Net.Sockets.Socket
  parent: System.Net.Sockets
  isExternal: true
  name: Socket
  nameWithType: Socket
  fullName: System.Net.Sockets.Socket
- uid: System.Net.Sockets.TcpListener.AcceptSocketAsync
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptSocketAsync()
  nameWithType: TcpListener.AcceptSocketAsync()
  fullName: System.Net.Sockets.TcpListener.AcceptSocketAsync()
- uid: System.Threading.Tasks.Task{System.Net.Sockets.Socket}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<Socket>
  nameWithType: Task<Socket>
  fullName: System.Threading.Tasks.Task<System.Net.Sockets.Socket>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Net.Sockets.Socket>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Net.Sockets.Socket
    name: Socket
    nameWithType: Socket
    fullName: Socket
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Net.Sockets.TcpListener.AcceptTcpClient
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptTcpClient()
  nameWithType: TcpListener.AcceptTcpClient()
  fullName: System.Net.Sockets.TcpListener.AcceptTcpClient()
- uid: System.Net.Sockets.TcpClient
  parent: System.Net.Sockets
  isExternal: false
  name: TcpClient
  nameWithType: TcpClient
  fullName: System.Net.Sockets.TcpClient
- uid: System.Net.Sockets.TcpListener.AcceptTcpClientAsync
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptTcpClientAsync()
  nameWithType: TcpListener.AcceptTcpClientAsync()
  fullName: System.Net.Sockets.TcpListener.AcceptTcpClientAsync()
- uid: System.Threading.Tasks.Task{System.Net.Sockets.TcpClient}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<TcpClient>
  nameWithType: Task<TcpClient>
  fullName: System.Threading.Tasks.Task<System.Net.Sockets.TcpClient>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Net.Sockets.TcpClient>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Net.Sockets.TcpClient
    name: TcpClient
    nameWithType: TcpClient
    fullName: TcpClient
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Net.Sockets.TcpListener.Active
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Active
  nameWithType: TcpListener.Active
  fullName: System.Net.Sockets.TcpListener.Active
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AllowNatTraversal(Boolean)
  nameWithType: TcpListener.AllowNatTraversal(Boolean)
  fullName: System.Net.Sockets.TcpListener.AllowNatTraversal(Boolean)
- uid: System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: BeginAcceptSocket(AsyncCallback,Object)
  nameWithType: TcpListener.BeginAcceptSocket(AsyncCallback,Object)
  fullName: System.Net.Sockets.TcpListener.BeginAcceptSocket(AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Net.Sockets.TcpListener.BeginAcceptTcpClient(System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: BeginAcceptTcpClient(AsyncCallback,Object)
  nameWithType: TcpListener.BeginAcceptTcpClient(AsyncCallback,Object)
  fullName: System.Net.Sockets.TcpListener.BeginAcceptTcpClient(AsyncCallback,Object)
- uid: System.Net.Sockets.TcpListener.Create(System.Int32)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Create(Int32)
  nameWithType: TcpListener.Create(Int32)
  fullName: System.Net.Sockets.TcpListener.Create(Int32)
- uid: System.Net.Sockets.TcpListener
  parent: System.Net.Sockets
  isExternal: false
  name: TcpListener
  nameWithType: TcpListener
  fullName: System.Net.Sockets.TcpListener
- uid: System.Net.Sockets.TcpListener.EndAcceptSocket(System.IAsyncResult)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: EndAcceptSocket(IAsyncResult)
  nameWithType: TcpListener.EndAcceptSocket(IAsyncResult)
  fullName: System.Net.Sockets.TcpListener.EndAcceptSocket(IAsyncResult)
- uid: System.Net.Sockets.TcpListener.EndAcceptTcpClient(System.IAsyncResult)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: EndAcceptTcpClient(IAsyncResult)
  nameWithType: TcpListener.EndAcceptTcpClient(IAsyncResult)
  fullName: System.Net.Sockets.TcpListener.EndAcceptTcpClient(IAsyncResult)
- uid: System.Net.Sockets.TcpListener.ExclusiveAddressUse
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: ExclusiveAddressUse
  nameWithType: TcpListener.ExclusiveAddressUse
  fullName: System.Net.Sockets.TcpListener.ExclusiveAddressUse
- uid: System.Net.Sockets.TcpListener.LocalEndpoint
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: LocalEndpoint
  nameWithType: TcpListener.LocalEndpoint
  fullName: System.Net.Sockets.TcpListener.LocalEndpoint
- uid: System.Net.EndPoint
  parent: System.Net
  isExternal: true
  name: EndPoint
  nameWithType: EndPoint
  fullName: System.Net.EndPoint
- uid: System.Net.Sockets.TcpListener.Pending
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Pending()
  nameWithType: TcpListener.Pending()
  fullName: System.Net.Sockets.TcpListener.Pending()
- uid: System.Net.Sockets.TcpListener.Server
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Server
  nameWithType: TcpListener.Server
  fullName: System.Net.Sockets.TcpListener.Server
- uid: System.Net.Sockets.TcpListener.Start
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Start()
  nameWithType: TcpListener.Start()
  fullName: System.Net.Sockets.TcpListener.Start()
- uid: System.Net.Sockets.TcpListener.Start(System.Int32)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Start(Int32)
  nameWithType: TcpListener.Start(Int32)
  fullName: System.Net.Sockets.TcpListener.Start(Int32)
- uid: System.Net.Sockets.TcpListener.Stop
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Stop()
  nameWithType: TcpListener.Stop()
  fullName: System.Net.Sockets.TcpListener.Stop()
- uid: System.Net.Sockets.TcpListener.#ctor*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: TcpListener
  nameWithType: TcpListener.TcpListener
- uid: System.Net.Sockets.TcpListener.AcceptSocket*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptSocket
  nameWithType: TcpListener.AcceptSocket
- uid: System.Net.Sockets.TcpListener.AcceptSocketAsync*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptSocketAsync
  nameWithType: TcpListener.AcceptSocketAsync
- uid: System.Net.Sockets.TcpListener.AcceptTcpClient*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptTcpClient
  nameWithType: TcpListener.AcceptTcpClient
- uid: System.Net.Sockets.TcpListener.AcceptTcpClientAsync*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptTcpClientAsync
  nameWithType: TcpListener.AcceptTcpClientAsync
- uid: System.Net.Sockets.TcpListener.Active*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Active
  nameWithType: TcpListener.Active
- uid: System.Net.Sockets.TcpListener.AllowNatTraversal*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AllowNatTraversal
  nameWithType: TcpListener.AllowNatTraversal
- uid: System.Net.Sockets.TcpListener.BeginAcceptSocket*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: BeginAcceptSocket
  nameWithType: TcpListener.BeginAcceptSocket
- uid: System.Net.Sockets.TcpListener.BeginAcceptTcpClient*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: BeginAcceptTcpClient
  nameWithType: TcpListener.BeginAcceptTcpClient
- uid: System.Net.Sockets.TcpListener.Create*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Create
  nameWithType: TcpListener.Create
- uid: System.Net.Sockets.TcpListener.EndAcceptSocket*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: EndAcceptSocket
  nameWithType: TcpListener.EndAcceptSocket
- uid: System.Net.Sockets.TcpListener.EndAcceptTcpClient*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: EndAcceptTcpClient
  nameWithType: TcpListener.EndAcceptTcpClient
- uid: System.Net.Sockets.TcpListener.ExclusiveAddressUse*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: ExclusiveAddressUse
  nameWithType: TcpListener.ExclusiveAddressUse
- uid: System.Net.Sockets.TcpListener.LocalEndpoint*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: LocalEndpoint
  nameWithType: TcpListener.LocalEndpoint
- uid: System.Net.Sockets.TcpListener.Pending*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Pending
  nameWithType: TcpListener.Pending
- uid: System.Net.Sockets.TcpListener.Server*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Server
  nameWithType: TcpListener.Server
- uid: System.Net.Sockets.TcpListener.Start*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Start
  nameWithType: TcpListener.Start
- uid: System.Net.Sockets.TcpListener.Stop*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Stop
  nameWithType: TcpListener.Stop
