### YamlMime:ManagedReference
items:
- uid: System.Diagnostics.EventLog
  id: EventLog
  children:
  - System.Diagnostics.EventLog.#ctor
  - System.Diagnostics.EventLog.#ctor(System.String)
  - System.Diagnostics.EventLog.#ctor(System.String,System.String)
  - System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)
  - System.Diagnostics.EventLog.BeginInit
  - System.Diagnostics.EventLog.Clear
  - System.Diagnostics.EventLog.Close
  - System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)
  - System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)
  - System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)
  - System.Diagnostics.EventLog.Delete(System.String)
  - System.Diagnostics.EventLog.Delete(System.String,System.String)
  - System.Diagnostics.EventLog.DeleteEventSource(System.String)
  - System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)
  - System.Diagnostics.EventLog.Dispose(System.Boolean)
  - System.Diagnostics.EventLog.EnableRaisingEvents
  - System.Diagnostics.EventLog.EndInit
  - System.Diagnostics.EventLog.Entries
  - System.Diagnostics.EventLog.EntryWritten
  - System.Diagnostics.EventLog.Exists(System.String)
  - System.Diagnostics.EventLog.Exists(System.String,System.String)
  - System.Diagnostics.EventLog.GetEventLogs
  - System.Diagnostics.EventLog.GetEventLogs(System.String)
  - System.Diagnostics.EventLog.Log
  - System.Diagnostics.EventLog.LogDisplayName
  - System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)
  - System.Diagnostics.EventLog.MachineName
  - System.Diagnostics.EventLog.MaximumKilobytes
  - System.Diagnostics.EventLog.MinimumRetentionDays
  - System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  - System.Diagnostics.EventLog.OverflowAction
  - System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)
  - System.Diagnostics.EventLog.Source
  - System.Diagnostics.EventLog.SourceExists(System.String)
  - System.Diagnostics.EventLog.SourceExists(System.String,System.String)
  - System.Diagnostics.EventLog.SynchronizingObject
  - System.Diagnostics.EventLog.WriteEntry(System.String)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  - System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  - System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  - System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  - System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  langs:
  - csharp
  name: EventLog
  nameWithType: EventLog
  fullName: System.Diagnostics.EventLog
  type: Class
  summary: "提供与 Windows 事件日志的交互。"
  remarks: "事件日志，可访问或自定义 Windows 事件日志，记录有关重要的软件或硬件事件的信息。 使用事件日志，您可以从现有日志读取、 将条目写入到日志、 创建或删除事件源，删除日志，并响应日志条目。 创建事件源时，你还可以创建新的日志。      1> [!IMPORTANT]&1;> 此类型实现<xref:System.IDisposable>接口。</xref:System.IDisposable> 完成后使用类型的操作后，你应释放类型直接或间接。 若要直接释放类型，调用其<xref:System.IDisposable.Dispose%2A>中的方法`try` / `catch`块。</xref:System.IDisposable.Dispose%2A> 若要间接释放类型，使用一种语言构造如`using`（在 C# 中) 或`Using`（在 Visual Basic 中)。 有关详细信息，请参阅中的&quot;使用实现 IDisposable 的对象&quot;部分<xref:System.IDisposable>接口主题。</xref:System.IDisposable>       除了提供对个人事件日志和它们的项的访问，EventLog 类使你可以访问的所有事件日志的集合。 你可以使用`static`成员的事件日志以删除日志，获取日志列表、 创建或删除源，或确定是否计算机已包含一个特定的源。       有三个默认事件日志︰ 应用程序、 系统和安全。 安全日志是只读的。 其他应用程序和安装，如 Active Directory 的服务可能具有其他事件日志。       在使用 EventLog 类时，有安全注意事项。 事件日志需要<xref:System.Diagnostics.EventLogPermission>的.NET Framework 2.0 和更高版本中的特定操作或在.NET Framework 1.0 和 1.1 中的完全信任权限。</xref:System.Diagnostics.EventLogPermission> 我们建议，<xref:System.Diagnostics.EventLogPermission>不授予给部分受信任的代码。</xref:System.Diagnostics.EventLogPermission>  你决不要将传递任何事件日志的对象，包括<xref:System.Diagnostics.EventLogEntryCollection>和<xref:System.Diagnostics.EventLogEntry>对象，不太受信任的代码。</xref:System.Diagnostics.EventLogEntry> </xref:System.Diagnostics.EventLogEntryCollection> 例如，创建一个事件日志的对象，写入条目，然后将事件日志到部分受信任的代码的对象可以创建安全问题，因为能够读取和写入事件日志允许代码执行操作，如发布事件日志消息，另一个应用程序的名称。       从 Windows Vista 开始，用户帐户控制 (UAC) 决定用户的凭据。 如果您是内置的 Administrators 组的成员，您分配两个运行时访问令牌︰ 一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色中。 若要运行的代码访问安全日志，首先必须将你的凭据从标准用户提升至管理员。 通过打开应用程序的快捷菜单启动应用程序时可以执行此操作 （如果你使用鼠标，右键单击应用程序图标） 并指示你想要以管理员身份运行。       事件日志可用于创建自定义你可以通过服务器的事件查看器查看的事件日志。 使用<xref:System.Diagnostics.EventLog.RegisterDisplayName%2A>方法以在事件查看器显示你的事件日志的本地化的名称。</xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> 使用<xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>方法来配置你的事件日志的行为，当它达到其最大日志大小。</xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>       若要从事件日志中读取，指定日志名称 (<xref:System.Diagnostics.EventLog.Log%2A>属性) 和服务器计算机名称 (<xref:System.Diagnostics.EventLog.MachineName%2A>属性的事件日志。</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> 如果你未指定服务器的计算机名称，本地计算机，&quot;。&quot;，则假定。 不需要指定事件源 (<xref:System.Diagnostics.EventLog.Source%2A>属性)，因为源是只有需要写入日志。</xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog.Entries%2A>属性自动填充的条目的事件日志的列表。</xref:System.Diagnostics.EventLog.Entries%2A>       若要写入事件日志，请指定或创建事件源 (<xref:System.Diagnostics.EventLog.Source%2A>属性)。</xref:System.Diagnostics.EventLog.Source%2A> 若要创建新的事件源的计算机上，必须具有管理凭据。 事件源将你的应用程序注册的有效项源作为事件日志。 事件源可用于写入一次只有一个日志。 <xref:System.Diagnostics.EventLog.Source%2A>属性可以是任何随机字符串，但该名称必须是不同于计算机上的其他源。</xref:System.Diagnostics.EventLog.Source%2A> 事件源通常是应用程序或另一个标识字符串的名称。 尝试创建重复<xref:System.Diagnostics.EventLog.Source%2A>值引发异常。</xref:System.Diagnostics.EventLog.Source%2A> 但是，单个事件日志可能与多个源。       如果不存在与事件日志实例关联的事件日志的事件源，创建新的事件源。 若要创建的事件源在 Windows Vista 或更高版本或 Windows Server 2003，必须具有管理凭据。       此要求是因为必须搜索所有事件日志，包括安全日志，以确定事件源是否是唯一的。 从 Windows Vista 开始，用户没有权限访问安全事件日志中。因此，<xref:System.Security.SecurityException>引发。</xref:System.Security.SecurityException>      1> [!IMPORTANT]&1;> 创建或删除事件源需要通过使用命名的互斥体的基础代码的同步。 如果具有高特权的应用程序锁定命名互斥体，尝试创建或删除事件源将导致应用程序停止响应，直到该锁被释放。 若要防止此问题，永远不会授予<xref:System.Security.Permissions.SecurityPermissionFlag>到不受信任的代码的权限。</xref:System.Security.Permissions.SecurityPermissionFlag> 此外，<xref:System.Security.Permissions.SecurityPermissionFlag>权限可能允许绕开其他权限和仅应授予高度受信任的代码。</xref:System.Security.Permissions.SecurityPermissionFlag>       应用程序和服务应写入应用程序日志或自定义日志。 设备驱动程序应写入系统日志。 如果未显式设置<xref:System.Diagnostics.EventLog.Log%2A>属性，则事件日志默认为应用程序日志。</xref:System.Diagnostics.EventLog.Log%2A>      1> [!NOTE]&1;> 无需进行任何以防止应用程序编写为任何已注册的源。  如果应用程序被授予<xref:System.Diagnostics.EventLogPermissionAccess>权限，它可以编写任何有效的源的计算机上注册的事件。</xref:System.Diagnostics.EventLogPermissionAccess>       使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>和<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法来写入事件，以便将事件日志。</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.WriteEvent%2A> 必须指定事件源写入事件;你必须创建并在编写与源的第一个条目之前，配置事件源。       在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并且尝试写入新的源的事件写入操作将失败。 你可以使用配置新的源<xref:System.Diagnostics.EventLogInstaller>对象或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 若要创建新的事件源的计算机上，必须具有管理凭据。       每个源可以一次; 写入只有一个事件日志但是，你的应用程序可以使用多个源写入多个事件日志。 例如，你的应用程序可能需要为不同的事件日志或不同的资源文件配置的多个源。 若要更改现有源的配置详细信息，必须删除源，然后使用新的配置创建。 如果其他应用程序或组件使用的现有源，请使用更新的配置，而不是删除现有的源创建新的源。       你可以先使用本地化的资源注册事件源，为你的事件类别和消息字符串。 你的应用程序可以通过使用资源标识符而不指定的实际字符串值编写事件日志条目。 请参阅<xref:System.Diagnostics.EventLogInstaller>和<xref:System.Diagnostics.EventSourceCreationData>有关的资源文件配置您的源的详细信息的类。</xref:System.Diagnostics.EventSourceCreationData> </xref:System.Diagnostics.EventLogInstaller>       如果你的应用程序将直接写入事件日志的字符串值，你不需要设置源的文件属性的资源。 要写入本地化的项还是要直接写入字符串，则必须配置源。 如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用该<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法使用在事件日志的资源标识符来编写条目</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的源 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>       写入事件时，你必须至少指定一个消息字符串或消息字符串的资源标识符。 其他事件属性都是可选的。 可选事件设置示例包括以下:-你可以设置<xref:System.Diagnostics.EventLogEntryType>指定事件查看器显示的项的图标。</xref:System.Diagnostics.EventLogEntryType>      -如果你的应用程序使用类别进行筛选的事件，你可以指定事件的类别标识符。      -如果你想要将其他信息与给定的事件相关联，你可以将二进制数据附加到事件项。      1> [!IMPORTANT]&1;> 事件日志记录占用磁盘空间、 处理器时间和其他系统资源。 请务必仅记录基本信息。 我们建议将事件日志调用放在错误路径中，而不是在主代码路径中，因此它们不会影响性能。       有关的事件日志的实例的初始属性值的列表，请参阅<xref:System.Diagnostics.EventLog.%23ctor%2A>构造函数。</xref:System.Diagnostics.EventLog.%23ctor%2A>"
  example:
  - "The following example creates the event source `MySource` if it doesn't already exist, and writes an entry to the event log `MyNewLog`.  \n  \n> [!NOTE]\n>  Starting with Windows Vista, you must run this application as an administrator.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/t-system.diagnostics.eve_0_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/t-system.diagnostics.eve_0_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/t-system.diagnostics.eve_0_1.vb)]"
  syntax:
    content: >-
      [System.ComponentModel.DefaultEvent("EntryWritten")]

      [System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      [System.Diagnostics.MonitoringDescription("EventLogDesc")]

      public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements:
  - System.ComponentModel.ISupportInitialize
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.ComponentModel.Component.ToString
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor
  id: '#ctor'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog()
  nameWithType: EventLog.EventLog()
  fullName: System.Diagnostics.EventLog.EventLog()
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "初始化的新实例<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>类。 不将实例与任何日志关联。"
  remarks: "之前调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>，指定<xref:System.Diagnostics.EventLog.Source%2A>属性<xref:System.Diagnostics.EventLog>实例。</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> 如果您仅读取<xref:System.Diagnostics.EventLog.Entries%2A>从日志中，您可以另行指定仅<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>属性。</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Entries%2A>      1> [!NOTE]&1;> 如果不指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本地计算机 (&quot;。&quot;) 假定。</xref:System.Diagnostics.EventLog.MachineName%2A>       下表显示<xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog>实例的初始属性的值      |属性 |初始值 |  |--------------|-------------------|  |<xref:System.Diagnostics.EventLog.Source%2A>|空字符串 (&quot;&quot;)。 | |<xref:System.Diagnostics.EventLog.Log%2A>|空字符串 (&quot;&quot;)。 | |<xref:System.Diagnostics.EventLog.MachineName%2A>|本地计算机 (&quot;。&quot;)。 |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A>"
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_9_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_9_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_9_1.vb)]"
  syntax:
    content: public EventLog ();
    parameters: []
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor(System.String)
  id: '#ctor(System.String)'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog(String)
  nameWithType: EventLog.EventLog(String)
  fullName: System.Diagnostics.EventLog.EventLog(String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "初始化的新实例<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>类。 将实例与本地计算机上的日志关联。"
  remarks: "此重载设置<xref:System.Diagnostics.EventLog.Log%2A>属性`logName`参数。</xref:System.Diagnostics.EventLog.Log%2A> 之前调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>，指定<xref:System.Diagnostics.EventLog.Source%2A>属性<xref:System.Diagnostics.EventLog>实例。</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> 如果您仅读取<xref:System.Diagnostics.EventLog.Entries%2A>从日志中，您可以另行指定仅<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>属性。</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Entries%2A>      1> [!NOTE]&1;> 如果不指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本地计算机 (&quot;。&quot;) 假定。</xref:System.Diagnostics.EventLog.MachineName%2A> 此重载构造函数指定<xref:System.Diagnostics.EventLog.Log%2A>属性，但您可以更改此读取操作之前<xref:System.Diagnostics.EventLog.Entries%2A>属性。</xref:System.Diagnostics.EventLog.Entries%2A> </xref:System.Diagnostics.EventLog.Log%2A>       如果你在指定的源<xref:System.Diagnostics.EventLog.Source%2A>属性从其他源的计算机上，后续调用都是唯一<xref:System.Diagnostics.EventLog.WriteEntry%2A>如果不存在具有指定名称，创建一个日志。</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A>       下表显示<xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog>实例的初始属性的值      |属性 |初始值 |  |--------------|-------------------|  |<xref:System.Diagnostics.EventLog.Source%2A>|空字符串 (&quot;&quot;)。 | |<xref:System.Diagnostics.EventLog.Log%2A>|`logName`参数。 |  |<xref:System.Diagnostics.EventLog.MachineName%2A>|本地计算机 (&quot;。&quot;)。 |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A>"
  example:
  - "The following example reads entries in the event log, \"myNewLog\", on the local computer.  \n  \n [!code-cpp[Classic EventLog.EventLog1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_13_1.cpp)]\n [!code-cs[Classic EventLog.EventLog1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_13_1.cs)]\n [!code-vb[Classic EventLog.EventLog1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_13_1.vb)]"
  syntax:
    content: public EventLog (string logName);
    parameters:
    - id: logName
      type: System.String
      description: "本地计算机上的日志的名称。"
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "日志名称为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "日志名称无效。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String)
  id: '#ctor(System.String,System.String)'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog(String,String)
  nameWithType: EventLog.EventLog(String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "初始化的新实例<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>类。 将实例与指定的计算机上的日志关联。"
  remarks: "此重载设置<xref:System.Diagnostics.EventLog.Log%2A>属性`logName`参数和<xref:System.Diagnostics.EventLog.MachineName%2A>属性`machineName`参数。</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> 在调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>中，指定<xref:System.Diagnostics.EventLog.Source%2A>属性的<xref:System.Diagnostics.EventLog>。</xref:System.Diagnostics.EventLog></xref:System.Diagnostics.EventLog.Source%2A></xref:System.Diagnostics.EventLog.WriteEntry%2A>之前 如果您仅读取<xref:System.Diagnostics.EventLog.Entries%2A>从日志中，您可以另行指定仅<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>属性。</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Entries%2A>      1> [!NOTE]&1;> 此重载构造函数指定<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>属性，但您可以更改之前读取或是<xref:System.Diagnostics.EventLog.Entries%2A>属性。</xref:System.Diagnostics.EventLog.Entries%2A> </xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A>       下表显示<xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog>实例的初始属性的值      |属性 |初始值 |  |--------------|-------------------|  |<xref:System.Diagnostics.EventLog.Source%2A>|空字符串 (&quot;&quot;)。 | |<xref:System.Diagnostics.EventLog.Log%2A>|`logName`参数。 |  |<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName`参数。 |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A>"
  example:
  - "The following example reads entries in the event log, \"myNewLog\", on the computer \"myServer\".  \n  \n [!code-cs[Classic EventLog.EventLog2 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_0_1.cs)]\n [!code-cpp[Classic EventLog.EventLog2 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_0_1.cpp)]\n [!code-vb[Classic EventLog.EventLog2 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_0_1.vb)]"
  syntax:
    content: public EventLog (string logName, string machineName);
    parameters:
    - id: logName
      type: System.String
      description: "指定的计算机上的日志的名称。"
    - id: machineName
      type: System.String
      description: "日志所在的计算机。"
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "日志名称为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "日志名称无效。       -或者-计算机名称无效。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)
  id: '#ctor(System.String,System.String,System.String)'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog(String,String,String)
  nameWithType: EventLog.EventLog(String,String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String,String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "初始化的新实例<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>类。 将实例与指定的计算机上的日志关联和创建或分配到指定的源<xref href=&quot;System.Diagnostics.EventLog&quot;> </xref>。"
  remarks: "此构造函数设置<xref:System.Diagnostics.EventLog.Log%2A>属性`logName`参数，<xref:System.Diagnostics.EventLog.MachineName%2A>属性`machineName`参数，与<xref:System.Diagnostics.EventLog.Source%2A>属性`source`参数。</xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> <xref:System.Diagnostics.EventLog.Source%2A>属性是必需的时写入事件日志。</xref:System.Diagnostics.EventLog.Source%2A> 但是，如果你只是从读取事件日志，仅<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>属性都是必需 （只要服务器上的事件日志具有已与它关联的源）。</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> 如果你只是读取从事件日志，可能可以满足另一个重载构造函数。       下表显示<xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog>实例的初始属性的值      |属性 |初始值 |  |--------------|-------------------|  |<xref:System.Diagnostics.EventLog.Source%2A>|`source`参数。 |  |<xref:System.Diagnostics.EventLog.Log%2A>|`logName`参数。 |  |<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName`参数。 |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A>"
  example:
  - "The following example writes an entry to an event log, \"MyNewLog\", on the local computer, using the source \"MySource\".  \n  \n [!code-cs[Classic EventLog.EventLog3 Example#1](~/add/codesnippet/csharp/fd99d44e-2d79-45f8-97e3-_1.cs)]\n [!code-cpp[Classic EventLog.EventLog3 Example#1](~/add/codesnippet/cpp/fd99d44e-2d79-45f8-97e3-_1.cpp)]\n [!code-vb[Classic EventLog.EventLog3 Example#1](~/add/codesnippet/visualbasic/fd99d44e-2d79-45f8-97e3-_1.vb)]"
  syntax:
    content: public EventLog (string logName, string machineName, string source);
    parameters:
    - id: logName
      type: System.String
      description: "指定的计算机上的日志的名称"
    - id: machineName
      type: System.String
      description: "日志所在的计算机。"
    - id: source
      type: System.String
      description: "事件日志条目的源。"
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "日志名称为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "日志名称无效。       -或者-计算机名称无效。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.BeginInit
  id: BeginInit
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: BeginInit()
  nameWithType: EventLog.BeginInit()
  fullName: System.Diagnostics.EventLog.BeginInit()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "开始初始化<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>窗体上使用或由另一个组件。 初始化发生在运行时。"
  remarks: "[!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)]设计环境使用此方法来开始使用窗体或由另一个组件的组件的初始化。 <xref:System.Diagnostics.EventLog.EndInit%2A>方法初始化已结束。</xref:System.Diagnostics.EventLog.EndInit%2A> 使用 BeginInit 和<xref:System.Diagnostics.EventLog.EndInit%2A>方法阻止中完全初始化之前使用的控件。</xref:System.Diagnostics.EventLog.EndInit%2A>"
  syntax:
    content: public void BeginInit ();
    parameters: []
  overload: System.Diagnostics.EventLog.BeginInit*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>已初始化。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Clear
  id: Clear
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Clear()
  nameWithType: EventLog.Clear()
  fullName: System.Diagnostics.EventLog.Clear()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "从事件日志中移除所有项。"
  remarks: "事件日志设置最大大小，它确定它们可以包含的项数。 当事件日志已满时，它将停止记录新的事件信息，或开始覆盖以前的项。 如果事件录制停止后，你可以使用此方法要清除日志中的现有条目，并允许它重新开始记录事件。 你必须具有到日志驻留以清除事件日志条目的计算机的管理员权限。       清除关闭事件日志、 释放事件句柄，检索新读取和写入句柄，并重新打开事件日志。 对方法的调用后收到的事件不会清除与现有的事件中。"
  example:
  - "The following example clears an event log.  \n  \n> [!CAUTION]\n>  Because Application, System, Security, and other non-custom logs can contain crucial information; be sure to specify a custom log before executing this example code. This example deletes the custom log `myNewLog`.  \n  \n [!code-cs[Classic EventLog.Clear Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_11_1.cs)]\n [!code-vb[Classic EventLog.Clear Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_11_1.vb)]\n [!code-cpp[Classic EventLog.Clear Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_11_1.cpp)]"
  syntax:
    content: public void Clear ();
    parameters: []
  overload: System.Diagnostics.EventLog.Clear*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "不成功清除事件日志。       -或者-无法打开日志。 Windows 错误代码不可用。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "没有为指定值<xref:System.Diagnostics.EventLog.Log*>属性。</xref:System.Diagnostics.EventLog.Log*> 请确保日志名称不为空字符串。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "日志不存在。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Close
  id: Close
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Close()
  nameWithType: EventLog.Close()
  fullName: System.Diagnostics.EventLog.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "关闭事件日志并释放读取和写入句柄。"
  remarks: "Close 方法调用的受保护<xref:System.ComponentModel.Component.Dispose%2A>方法。</xref:System.ComponentModel.Component.Dispose%2A> 不需要调用<xref:System.ComponentModel.Component.Dispose%2A>.</xref:System.ComponentModel.Component.Dispose%2A>之前调用关闭"
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Diagnostics.EventLog.Close*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "事件日志的读取句柄或写句柄不成功发布。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)
  id: CreateEventSource(System.Diagnostics.EventSourceCreationData)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: CreateEventSource(EventSourceCreationData)
  nameWithType: EventLog.CreateEventSource(EventSourceCreationData)
  fullName: System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "建立的有效事件源写入本地化的事件消息，为事件源和相应的事件日志中使用指定的配置属性。"
  remarks: "Use this overload to configure a new source for writing entries to an event log on the local computer or a remote computer. It is not necessary to use this method to read from an event log.  \n  \n The CreateEventSource method uses the input `sourceData`<xref:System.Diagnostics.EventSourceCreationData.Source%2A>, <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> and <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> properties to create registry values on the target computer for the new source and its associated event log. A new source name cannot match an existing source name or an existing event log name on the target computer. If the <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> property is not set, the source is registered for the Application event log. If the <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> is not set, the source is registered on the local computer.  \n  \n> [!NOTE]\n>  To create an event source in Windows Vista and later or Windows Server 2003, you must have administrative privileges.  \n>   \n>  The reason for this requirement is that all event logs, including security, must be searched to determine whether the event source is unique. Starting with Windows Vista, users do not have permission to access the security log; therefore, a <xref:System.Security.SecurityException> is thrown.  \n>   \n>  Starting with Windows Vista, User Account Control (UAC) determines the privileges of a user. If you are a member of the Built-in Administrators group, you are assigned two run-time access tokens: a standard user access token and an administrator access token. By default, you are in the standard user role. To execute the code that accesses the security log, you must first elevate your privileges from standard user to administrator. You can do this when you start an application by right-clicking the application icon and indicating that you want to run as an administrator.  \n  \n Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> and <xref:System.Diagnostics.EventLog.WriteEntry%2A> to write events to an event log. You must specify an event source to write events; you must create and configure the event source before writing the first entry with the source.  \n  \n Create the new event source during the installation of your application. This allows time for the operating system to refresh its list of registered event sources and their configuration. If the operating system has not refreshed its list of event sources, and you attempt to write an event with the new source, the write operation will fail. You can configure a new source using an <xref:System.Diagnostics.EventLogInstaller>, or using the <xref:System.Diagnostics.EventLog.CreateEventSource%2A> method. You must have administrative rights on the computer to create a new event source.  \n  \n You can create an event source for an existing event log or a new event log. When you create a new source for a new event log, the system registers the source for that log, but the log is not created until the first entry is written to it.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the <xref:System.Diagnostics.EventLog.Log%2A> property with the \".evt\" file name extension.  \n  \n Each source can only write to only one event log at a time; however, your application can use multiple sources to write to multiple event logs. For example, your application might require multiple sources configured for different event logs or different resource files.  \n  \n You can register the event source with localized resource file(s) for your event category and message strings. Your application can write event log entries using resource identifiers, rather than specifying the actual string. The Event Viewer uses the resource identifier to find and display the corresponding string from the localized resource file based on current language settings. You can register a separate file for event categories, messages and parameter insertion strings, or you can register the same resource file for all three types of strings. Use the <xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A>, <xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A>, <xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A>, and <xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A> properties to configure the source to write localized entries to the event log. If your application writes strings values directly to the event log, you do not need to set these properties.  \n  \n The source must be configured either for writing localized entries or for writing direct strings. If your application writes entries using both resource identifiers and string values, you must register two separate sources. For example, configure one source with resource files, and then use that source in the <xref:System.Diagnostics.EventLog.WriteEvent%2A> method to write entries using resource identifiers to the event log. Then create a different source without resource files, and use that source in the <xref:System.Diagnostics.EventLog.WriteEntry%2A> method to write strings directly to the event log using that source.  \n  \n To change the configuration details of an existing source, you must delete the source and then create it with the new configuration. If other applications or components use the existing source, create a new source with the updated configuration rather than deleting the existing source.  \n  \n> [!NOTE]\n>  If a source is configured for an event log, and you reconfigure it for another event log, you must restart the computer for the changes to take effect."
  example:
  - "The following example determines whether the event source named `SampleApplicationSource` is registered on the local computer. If the event source does not exist, the example sets the message resource file for the source and creates the new event source. Finally, the example sets the localized display name for the event log, using the resource identifier value in `DisplayNameMsgId` and the resource file path in `messageFile`.  \n  \n [!code-cpp[EventLog_WriteEvent#6](~/add/codesnippet/cpp/4fd418fb-73e7-42a9-9ba2-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#6](~/add/codesnippet/visualbasic/4fd418fb-73e7-42a9-9ba2-_1.vb)]\n [!code-cs[EventLog_WriteEvent#6](~/add/codesnippet/csharp/4fd418fb-73e7-42a9-9ba2-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings. Specifically, resource identifier 5001 is defined for the localized name of the event log.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);
    parameters:
    - id: sourceData
      type: System.Diagnostics.EventSourceCreationData
      description: "为事件源及其目标事件日志的配置属性中。"
  overload: System.Diagnostics.EventLog.CreateEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The computer name specified in <code>sourceData</code> is not valid.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The log name specified in <code>sourceData</code> is not valid. Event log names must consist of printable characters and cannot include the characters '*', '?', or '\\\\'.  \n  \n \\- or -  \n  \n The log name specified in <code>sourceData</code> is not valid for user log creation. The Event log names AppEvent, SysEvent, and SecEvent are reserved for system use.  \n  \n \\- or -  \n  \n The log name matches an existing event source name.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> results in a registry key path longer than 254 characters.  \n  \n \\- or -  \n  \n The first 8 characters of the log name specified in <code>sourceData</code> are not unique.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> is already registered.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> matches an existing event log name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "无法打开事件日志的注册表项。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>sourceData</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)
  id: CreateEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: CreateEventSource(String,String)
  nameWithType: EventLog.CreateEventSource(String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "确定指定的源名称为本地计算机上向日志写入项的有效事件源。 此方法还可以在本地计算机上创建一个新的自定义日志。"
  remarks: "Use this overload to create a custom log or to create and register a <xref:System.Diagnostics.EventLog.Source%2A> to an existing log on the local computer.  \n  \n If `logName` is `null` or an empty string (\"\") when you call <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, the log defaults to the Application log. If the log does not exist on the local computer, the system creates a custom log and registers your application as a <xref:System.Diagnostics.EventLog.Source%2A> for that log.  \n  \n> [!NOTE]\n>  To create an event source in Windows Vista and later or Windows Server 2003, you must have administrative privileges.  \n>   \n>  The reason for this requirement is that all event logs, including security, must be searched to determine whether the event source is unique. Starting with Windows Vista, users do not have permission to access the security log; therefore, a <xref:System.Security.SecurityException> is thrown.  \n>   \n>  In Windows Vista and later, User Account Control (UAC) determines the privileges of a user. If you are a member of the Built-in Administrators group, you are assigned two run-time access tokens: a standard user access token and an administrator access token. By default, you are in the standard user role. To execute the code that accesses the security log, you must first elevate your privileges from standard user to administrator. You can do this when you start an application by right-clicking the application icon and indicating that you want to run as an administrator.  \n  \n You only need to create an event source if you are writing to the event log. Before writing an entry to an event log, you must register the event source with the event log as a valid source of events. When you write a log entry, the system uses the <xref:System.Diagnostics.EventLog.Source%2A> to find the appropriate log in which to place your entry. If you are reading the event log, you can either specify the <xref:System.Diagnostics.EventLog.Source%2A>, or a <xref:System.Diagnostics.EventLog.Log%2A> and <xref:System.Diagnostics.EventLog.MachineName%2A>.  \n  \n> [!NOTE]\n>  You are not required to specify the <xref:System.Diagnostics.EventLog.MachineName%2A> if you are connecting to a log on the local computer. If you do not specify the <xref:System.Diagnostics.EventLog.MachineName%2A> when reading from a log, the local computer (\".\") is assumed.  \n  \n Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> and <xref:System.Diagnostics.EventLog.WriteEntry%2A> to write events to an event log. You must specify an event source to write events; you must create and configure the event source before writing the first entry with the source.  \n  \n Create the new event source during the installation of your application. This allows time for the operating system to refresh its list of registered event sources and their configuration. If the operating system has not refreshed its list of event sources, and you attempt to write an event with the new source, the write operation will fail. You can configure a new source using an <xref:System.Diagnostics.EventLogInstaller>, or using the <xref:System.Diagnostics.EventLog.CreateEventSource%2A> method. You must have administrative rights on the computer to create a new event source.  \n  \n You can create an event source for an existing event log or a new event log. When you create a new source for a new event log, the system registers the source for that log, but the log is not created until the first entry is written to it.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the <xref:System.Diagnostics.EventLog.Log%2A> property with the \".evt\" file name extension.  \n  \n The source must be unique on the local computer; a new source name cannot match an existing source name or an existing event log name. Each source can write to only one event log at a time; however, your application can use multiple sources to write to multiple event logs. For example, your application might require multiple sources configured for different event logs or different resource files.  \n  \n The source must be configured either for writing localized entries or for writing direct strings. If your application writes entries using both resource identifiers and string values, you must register two separate sources. For example, configure one source with resource files, and then use that source in the <xref:System.Diagnostics.EventLog.WriteEvent%2A> method to write entries using resource identifiers to the event log. Then create a different source without resource files, and use that source in the <xref:System.Diagnostics.EventLog.WriteEntry%2A> method to write strings directly to the event log using that source.  \n  \n To change the configuration details of an existing source, you must delete the source and then create it with the new configuration. If other applications or components use the existing source, create a new source with the updated configuration rather than deleting the existing source.  \n  \n> [!NOTE]\n>  If a source has already been mapped to a log and you remap it to a new log, you must restart the computer for the changes to take effect."
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_15_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_15_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_15_1.vb)]"
  syntax:
    content: public static void CreateEventSource (string source, string logName);
    parameters:
    - id: source
      type: System.String
      description: "依据应用程序注册本地计算机的源名称。"
    - id: logName
      type: System.String
      description: "源的项写入到日志的名称。 可能的值包括应用程序、 系统或自定义的事件日志。"
  overload: System.Diagnostics.EventLog.CreateEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>source</code> is an empty string (\"\") or <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>logName</code> is not a valid event log name. Event log names must consist of printable characters, and cannot include the characters '*', '?', or '\\\\'.  \n  \n \\- or -  \n  \n <code>logName</code> is not valid for user log creation. The event log names AppEvent, SysEvent, and SecEvent are reserved for system use.  \n  \n \\- or -  \n  \n The log name matches an existing event source name.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters.  \n  \n \\- or -  \n  \n The first 8 characters of <code>logName</code> match the first 8 characters of an existing event log name.  \n  \n \\- or -  \n  \n The source cannot be registered because it already exists on the local computer.  \n  \n \\- or -  \n  \n The source name matches an existing event log name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "无法在本地计算机上打开事件日志的注册表项。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)
  id: CreateEventSource(System.String,System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: CreateEventSource(String,String,String)
  nameWithType: EventLog.CreateEventSource(String,String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "建立指定的源名称作为指定的计算机上向日志写入项的有效事件源。 此方法还可以用于指定计算机上创建一个新的自定义日志。"
  remarks: "Use this overload to create a custom log or to create and register a <xref:System.Diagnostics.EventLog.Source%2A> to an existing log on the specified computer.  \n  \n If `logName` is `null` or an empty string (\"\") when you call <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, the log defaults to the Application log. If the log does not exist on the specified computer, the system creates a custom log and registers your application as a <xref:System.Diagnostics.EventLog.Source%2A> for that log.  \n  \n You only need to create an event source if you are writing to the event log. Before writing an entry to an event log, you must register the event source with the event log as a valid source of events. When you write a log entry, the system uses the <xref:System.Diagnostics.EventLog.Source%2A> to find the appropriate log in which to place your entry. If you are reading the event log, you can either specify the <xref:System.Diagnostics.EventLog.Source%2A>, or a <xref:System.Diagnostics.EventLog.Log%2A> and <xref:System.Diagnostics.EventLog.MachineName%2A>.  \n  \n> [!NOTE]\n>  To create an event source in Windows Vista and later or Windows Server 2003, you must have administrative privileges.  \n>   \n>  The reason for this requirement is that all event logs, including security, must be searched to determine whether the event source is unique. In Windows Vista and later, users do not have permission to access the security log; therefore, a <xref:System.Security.SecurityException> is thrown.  \n>   \n>  In Windows Vista and later, User Account Control (UAC) determines the privileges of a user. If you are a member of the Built-in Administrators group, you are assigned two run-time access tokens: a standard user access token and an administrator access token. By default, you are in the standard user role. To execute the code that accesses the security log, you must first elevate your privileges from standard user to administrator. You can do this when you start an application by right-clicking the application icon and indicating that you want to run as an administrator.  \n  \n Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> and <xref:System.Diagnostics.EventLog.WriteEntry%2A> to write events to an event log. You must specify an event source to write events; you must create and configure the event source before writing the first entry with the source.  \n  \n Create the new event source during the installation of your application. This allows time for the operating system to refresh its list of registered event sources and their configuration. If the operating system has not refreshed its list of event sources, and you attempt to write an event with the new source, the write operation will fail. You can configure a new source using an <xref:System.Diagnostics.EventLogInstaller>, or using the <xref:System.Diagnostics.EventLog.CreateEventSource%2A> method. You must have administrative rights on the computer to create a new event source.  \n  \n You can create an event source for an existing event log or a new event log. When you create a new source for a new event log, the system registers the source for that log, but the log is not created until the first entry is written to it.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the <xref:System.Diagnostics.EventLog.Log%2A> property with the \".evt\" file name extension.  \n  \n The source must be unique on the local computer; a new source name cannot match an existing source name or an existing event log name. Each source can write to only one event log at a time; however, your application can use multiple sources to write to multiple event logs. For example, your application might require multiple sources configured for different event logs or different resource files.  \n  \n The source must be configured either for writing localized entries or for writing direct strings. If your application writes entries using both resource identifiers and string values, you must register two separate sources. For example, configure one source with resource files, and then use that source in the <xref:System.Diagnostics.EventLog.WriteEvent%2A> method to write entries using resource identifiers to the event log. Then create a different source without resource files, and use that source in the <xref:System.Diagnostics.EventLog.WriteEntry%2A> method to write strings directly to the event log using that source.  \n  \n To change the configuration details of an existing source, you must delete the source and then create it with the new configuration. If other applications or components use the existing source, create a new source with the updated configuration rather than deleting the existing source.  \n  \n> [!NOTE]\n>  If a source has already been mapped to a log and you remap it to a new log, you must restart the computer for the changes to take effect."
  example:
  - "The following example creates the source `MySource` on the computer `MyServer`, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/cpp/86732307-05e6-4c1a-b98e-_1.cpp)]\n [!code-cs[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/csharp/86732307-05e6-4c1a-b98e-_1.cs)]\n [!code-vb[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/visualbasic/86732307-05e6-4c1a-b98e-_1.vb)]"
  syntax:
    content: public static void CreateEventSource (string source, string logName, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "依据应用程序注册指定的计算机的源。"
    - id: logName
      type: System.String
      description: "源的项写入到日志的名称。 可能的值包括应用程序、 系统或自定义的事件日志。 如果不指定一个值，`logName`默认为应用程序。"
    - id: machineName
      type: System.String
      description: "要注册，此事件源的计算机的名称或&quot;。&quot;本地计算机。"
  overload: System.Diagnostics.EventLog.CreateEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>machineName</code> is not a valid computer name.  \n  \n \\- or -  \n  \n <code>source</code> is an empty string (\"\") or <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>logName</code> is not a valid event log name. Event log names must consist of printable characters, and cannot include the characters '*', '?', or '\\\\'.  \n  \n \\- or -  \n  \n <code>logName</code> is not valid for user log creation. The event log names AppEvent, SysEvent, and SecEvent are reserved for system use.  \n  \n \\- or -  \n  \n The log name matches an existing event source name.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters.  \n  \n \\- or -  \n  \n The first 8 characters of <code>logName</code> match the first 8 characters of an existing event log name on the specified computer.  \n  \n \\- or -  \n  \n The source cannot be registered because it already exists on the specified computer.  \n  \n \\- or -  \n  \n The source name matches an existing event source name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "无法在指定的计算机上打开事件日志的注册表项。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Delete(System.String)
  id: Delete(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Delete(String)
  nameWithType: EventLog.Delete(String)
  fullName: System.Diagnostics.EventLog.Delete(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "从本地计算机上移除事件日志。"
  remarks: "当你想要删除的日志位于本地计算机上，请使用此方法。 你可以删除的计算机上，任何日志，前提是您具有适当的注册表权限。       删除操作会移除指定的日志`logName`来自本地计算机。 如果你想要删除仅注册到日志的源，调用<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 如果你只想要删除的日志条目，调用<xref:System.Diagnostics.EventLog.Clear%2A>.</xref:System.Diagnostics.EventLog.Clear%2A> 删除和<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>是`static`方法，以便它们可以调用在该类本身。</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 不需要创建的新实例<xref:System.Diagnostics.EventLog>调用任何一种方法。</xref:System.Diagnostics.EventLog>       Delete 方法会依次删除存储日志的内容的文件。 然后，访问注册表，并删除为该日志注册的所有事件源。 如果重新创建在以后的日志时，你应该它们是否要重用再次注册事件源。 如果不注册事件源和其他用户的事件源编写无需指定日志名称，将在应用程序事件日志中创建事件源。 因此，应用程序以前曾经将条目写入到删除并重新创建的日志将写入到应用程序日志相反，因为它现在包含事件源。      1> [!NOTE]&1;> 重新创建事件日志可以是一个复杂的过程。 避免删除任何系统创建事件日志，如应用程序日志。       删除通过删除调用日志将自动删除已注册到该日志的源。 这会使其他应用程序使用该日志不起作用。"
  example:
  - "The following example deletes a log from the local computer. The example determines the log from its source.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_12_1.cpp)]\n [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_12_1.vb)]\n [!code-cs[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_12_1.cs)]"
  syntax:
    content: public static void Delete (string logName);
    parameters:
    - id: logName
      type: System.String
      description: '要删除的日志的名称。 可能的值包括︰ 应用程序、 安全、 系统和在计算机上的任何自定义事件日志。'
  overload: System.Diagnostics.EventLog.Delete*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>logName</code>为空字符串 (&quot;&quot;) 或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The registry key for the event log could not be opened on the local computer.  \n  \n \\- or -  \n  \n The log does not exist on the local computer."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "不成功清除事件日志。       -或者-无法打开日志。 Windows 错误代码不可用。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Delete(System.String,System.String)
  id: Delete(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Delete(String,String)
  nameWithType: EventLog.Delete(String,String)
  fullName: System.Diagnostics.EventLog.Delete(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "从指定的计算机上移除事件日志。"
  remarks: "当你想要删除的日志位于远程计算机上，请使用此方法。 你可以删除的计算机上，任何日志，前提是您具有适当的注册表权限。       <xref:System.Diagnostics.EventLog.Delete%2A>删除指定的日志`logName`从指定的计算机`machineName`。</xref:System.Diagnostics.EventLog.Delete%2A> 如果你想要删除仅注册到日志的源，调用<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 如果你只想要删除的日志条目，调用<xref:System.Diagnostics.EventLog.Clear%2A>.</xref:System.Diagnostics.EventLog.Clear%2A> <xref:System.Diagnostics.EventLog.Delete%2A>和<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>是`static`方法，以便它们可以调用在该类本身。</xref:System.Diagnostics.EventLog.DeleteEventSource%2A></xref:System.Diagnostics.EventLog.Delete%2A> 不需要创建的实例<xref:System.Diagnostics.EventLog>调用任何一种方法。</xref:System.Diagnostics.EventLog>       此方法首先删除存储日志的内容的文件。 然后，访问注册表，并删除为该日志注册的所有事件源。 如果重新创建在以后的日志时，你应该它们是否要重用再次注册事件源。 如果不注册事件源和其他用户的事件源编写无需指定日志名称，将在应用程序事件日志中创建事件源。 因此，应用程序以前曾经将条目写入到删除并重新创建的日志将写入到应用程序日志相反，因为它现在包含事件源。      1> [!NOTE]&1;> 重新创建事件日志可以是一个复杂的过程。 避免删除任何系统创建事件日志，如应用程序日志。       删除通过调用<xref:System.Diagnostics.EventLog.Delete%2A>会自动删除的源注册到该日志。</xref:System.Diagnostics.EventLog.Delete%2A>日志 这会使其他应用程序使用该日志不起作用。"
  example:
  - "The following example deletes a log from the specified computer. The example determines the log from its source.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cs[Classic EventLog.Delete1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_17_1.cs)]\n [!code-cpp[Classic EventLog.Delete1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_17_1.cpp)]\n [!code-vb[Classic EventLog.Delete1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_17_1.vb)]"
  syntax:
    content: public static void Delete (string logName, string machineName);
    parameters:
    - id: logName
      type: System.String
      description: '要删除的日志的名称。 可能的值包括︰ 应用程序、 安全、 系统和指定的计算机上的任何自定义事件日志。'
    - id: machineName
      type: System.String
      description: "要删除日志，计算机的名称或&quot;。&quot;本地计算机。"
  overload: System.Diagnostics.EventLog.Delete*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>logName</code> is an empty string (\"\") or <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>machineName</code> is not a valid computer name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The registry key for the event log could not be opened on the specified computer.  \n  \n \\- or -  \n  \n The log does not exist on the specified computer."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "不成功清除事件日志。       -或者-无法打开日志。 Windows 错误代码不可用。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String)
  id: DeleteEventSource(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: DeleteEventSource(String)
  nameWithType: EventLog.DeleteEventSource(String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "从本地计算机的事件日志中移除的事件源注册。"
  remarks: "此方法用于删除的注册<xref:System.Diagnostics.EventLog.Source%2A>来自本地计算机。</xref:System.Diagnostics.EventLog.Source%2A> DeleteEventSource 访问本地计算机上的注册表，并删除的应用程序作为有效的事件源注册。       如果你不再需要它来写入该日志条目，则可以删除你的组件作为有效的事件源。 例如，如果你需要将你的组件从一个日志更改为另一个可能会执行此操作。 因为源一次只能注册到一个日志，更改日志，您必须删除当前的注册。       DeleteEventSource 删除中仅注册到日志的源。 如果你想要移除日志本身，调用<xref:System.Diagnostics.EventLog.Delete%2A>.</xref:System.Diagnostics.EventLog.Delete%2A> 如果你只想要删除的日志条目，调用<xref:System.Diagnostics.EventLog.Clear%2A>.</xref:System.Diagnostics.EventLog.Clear%2A> <xref:System.Diagnostics.EventLog.Delete%2A>并且 DeleteEventSource`static`方法，以便它们可以调用类本身上。</xref:System.Diagnostics.EventLog.Delete%2A> 不需要创建的实例<xref:System.Diagnostics.EventLog>调用任何一种方法。</xref:System.Diagnostics.EventLog>       删除通过调用<xref:System.Diagnostics.EventLog.Delete%2A>会自动删除的源注册到该日志。</xref:System.Diagnostics.EventLog.Delete%2A>日志 这会使其他应用程序使用该日志不起作用。      1> [!NOTE]&1;> 如果源已映射到某个日志和重新映射到新的日志，你必须重新启动计算机才能使更改生效。"
  example:
  - "The following example deletes a source from the local computer. The example determines the log from its source, and then deletes the log.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_8_1.cpp)]\n [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_8_1.vb)]\n [!code-cs[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_8_1.cs)]"
  syntax:
    content: public static void DeleteEventSource (string source);
    parameters:
    - id: source
      type: System.String
      description: "在事件日志系统中注册该应用程序的名称。"
  overload: System.Diagnostics.EventLog.DeleteEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> parameter does not exist in the registry of the local computer.  \n  \n \\- or -  \n  \n You do not have write access on the registry key for the event log."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)
  id: DeleteEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: DeleteEventSource(String,String)
  nameWithType: EventLog.DeleteEventSource(String,String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "从指定的计算机中删除应用程序的事件源注册。"
  remarks: "此重载用于删除的注册<xref:System.Diagnostics.EventLog.Source%2A>从远程计算机。</xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>访问指定的计算机上的注册表`machineName`并删除应用程序作为有效的事件源的注册。</xref:System.Diagnostics.EventLog.DeleteEventSource%2A>       如果你不再需要它来写入该日志条目，则可以删除你的组件作为有效的事件源。 例如，如果你需要将你的组件从一个日志更改为另一个可能会执行此操作。 因为源一次只能注册到一个日志，更改日志，您必须删除当前的注册。       <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>删除中仅注册到日志的源。</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 如果你想要移除日志本身，调用<xref:System.Diagnostics.EventLog.Delete%2A>.</xref:System.Diagnostics.EventLog.Delete%2A> 如果你只想要删除的日志条目，调用<xref:System.Diagnostics.EventLog.Clear%2A>.</xref:System.Diagnostics.EventLog.Clear%2A> <xref:System.Diagnostics.EventLog.Delete%2A>和<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>是`static`方法，以便它们可以调用在该类本身。</xref:System.Diagnostics.EventLog.DeleteEventSource%2A></xref:System.Diagnostics.EventLog.Delete%2A> 不需要创建的实例<xref:System.Diagnostics.EventLog>调用任何一种方法。</xref:System.Diagnostics.EventLog>       删除通过调用<xref:System.Diagnostics.EventLog.Delete%2A>会自动删除的源注册到该日志。</xref:System.Diagnostics.EventLog.Delete%2A>日志 这会使其他应用程序使用该日志不起作用。      1> [!NOTE]&1;> 如果源已映射到某个日志和重新映射到新的日志，你必须重新启动计算机才能使更改生效。"
  example:
  - "The following example deletes a source from the specified computer. The example determines the log from its source, and then deletes the log.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cs[Classic EventLog.Delete1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_6_1.cs)]\n [!code-cpp[Classic EventLog.Delete1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_6_1.cpp)]\n [!code-vb[Classic EventLog.Delete1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_6_1.vb)]"
  syntax:
    content: public static void DeleteEventSource (string source, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "在事件日志系统中注册该应用程序的名称。"
    - id: machineName
      type: System.String
      description: "要删除，从注册的计算机的名称或&quot;。&quot;本地计算机。"
  overload: System.Diagnostics.EventLog.DeleteEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>machineName</code> parameter is invalid.  \n  \n \\- or -  \n  \n The <code>source</code> parameter does not exist in the registry of the specified computer.  \n  \n \\- or -  \n  \n You do not have write access on the registry key for the event log."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>source</code>无法删除，因为在注册表中，父注册表项<code>source</code>不包含具有相同名称的子项。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: EventLog.Dispose(Boolean)
  fullName: System.Diagnostics.EventLog.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "释放由非托管的资源<xref href=&quot;System.Diagnostics.EventLog&quot;> </xref>，，还可以释放托管的资源。"
  remarks: "由公共调用此方法`Dispose()`方法和<xref:System.Object.Finalize%2A>方法。</xref:System.Object.Finalize%2A> `Dispose()`调用受保护`Dispose(Boolean)`方法替换`disposing`参数设置为`true`。 <xref:System.Object.Finalize%2A>调用`Dispose`与`disposing`设置为`false`。</xref:System.Object.Finalize%2A>       当`disposing`参数为 true 时，此方法释放由任何托管对象持有的全部资源此<xref:System.Diagnostics.EventLog>引用。</xref:System.Diagnostics.EventLog> 此方法调用`Dispose()`每个引用对象的方法。"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要释放托管和非托管资源;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>若要仅释放非托管的资源。"
  overload: System.Diagnostics.EventLog.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.EnableRaisingEvents
  id: EnableRaisingEvents
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EnableRaisingEvents
  nameWithType: EventLog.EnableRaisingEvents
  fullName: System.Diagnostics.EventLog.EnableRaisingEvents
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置一个值，该值指示是否<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>接收<xref href=&quot;System.Diagnostics.EventLog.EntryWritten&quot;></xref>事件通知。"
  remarks: "EnableRaisingEvents 属性确定是否<xref:System.Diagnostics.EventLog>引发事件时条目写入日志。</xref:System.Diagnostics.EventLog> 当该属性是`true`，接收组件<xref:System.Diagnostics.EventLog.EntryWritten>事件将收到通知任何时间在指定的日志中写入一项<xref:System.Diagnostics.EventLog.Log%2A>属性。</xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.EntryWritten> 如果 EnableRaisingEvents `false`，会引发任何事件。      1> [!NOTE]&1;> 仅在本地计算机上写入项时，可以接收事件通知。 无法接收在远程计算机上写入项的通知。"
  example:
  - "The following example handles an <xref:System.Diagnostics.EventLog.EntryWritten> event.  \n  \n [!code-cs[Classic EventLog.EnableRaisingEvents Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_32_1.cs)]\n [!code-vb[Classic EventLog.EnableRaisingEvents Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_32_1.vb)]\n [!code-cpp[Classic EventLog.EnableRaisingEvents Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_32_1.cpp)]"
  syntax:
    content: public bool EnableRaisingEvents { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>条目写入日志; 否则为时接收通知<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Diagnostics.EventLog.EnableRaisingEvents*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "事件日志位于远程计算机上。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.EndInit
  id: EndInit
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EndInit()
  nameWithType: EventLog.EndInit()
  fullName: System.Diagnostics.EventLog.EndInit()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "初始化已结束<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>使用窗体或由另一个组件。 初始化发生在运行时。"
  remarks: "[!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)]设计环境使用此方法来结束使用窗体或由另一个组件的组件的初始化。 <xref:System.Diagnostics.EventLog.BeginInit%2A>方法开始初始化。</xref:System.Diagnostics.EventLog.BeginInit%2A> 使用<xref:System.Diagnostics.EventLog.BeginInit%2A>和 EndInit 方法阻止控件完全初始化之前使用。</xref:System.Diagnostics.EventLog.BeginInit%2A>"
  syntax:
    content: public void EndInit ();
    parameters: []
  overload: System.Diagnostics.EventLog.EndInit*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Entries
  id: Entries
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Entries
  nameWithType: EventLog.Entries
  fullName: System.Diagnostics.EventLog.Entries
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取事件日志的内容。"
  remarks: "从事件日志中读取时，请使用的项成员。       因为该属性是只读的无法修改一个条目，或写入使用条目的日志。 相反，指定<xref:System.Diagnostics.EventLog.Source%2A>并调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>编写新的日志条目。</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A> 可以使用条目来计算事件日志中的项数，还可以查看每个<xref:System.Diagnostics.EventLogEntry>集合中。</xref:System.Diagnostics.EventLogEntry> 使用索引<xref:System.Diagnostics.EventLogEntryCollection.Item%2A>成员，如检索有关特定条目，信息<xref:System.Diagnostics.EventLogEntry.Message%2A>， <xref:System.Diagnostics.EventLogEntry.Category%2A>， <xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>，或<xref:System.Diagnostics.EventLogEntry.EntryType%2A>。</xref:System.Diagnostics.EventLogEntry.EntryType%2A> </xref:System.Diagnostics.EventLogEntry.TimeWritten%2A> </xref:System.Diagnostics.EventLogEntry.Category%2A> </xref:System.Diagnostics.EventLogEntry.Message%2A> </xref:System.Diagnostics.EventLogEntryCollection.Item%2A>       不需要指定<xref:System.Diagnostics.EventLog.Source%2A>仅从日志读取</xref:System.Diagnostics.EventLog.Source%2A> 你可以仅指定<xref:System.Diagnostics.EventLog.Log%2A>名称和<xref:System.Diagnostics.EventLog.MachineName%2A>（服务器计算机名称） 属性<xref:System.Diagnostics.EventLog>实例。</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> 在任一情况下，项成员自动填充的条目的事件日志的列表。 此列表以读取各个项中，可以选择适当的索引的项。       读取和写入日志项之间的一个重要区别在于不需要显式调用读取的方法。 后<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>指定，自动填充项属性。</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> 如果更改<xref:System.Diagnostics.EventLog.Log%2A>或<xref:System.Diagnostics.EventLog.MachineName%2A>属性，属性重新填充读取它。 下一次的条目</xref:System.Diagnostics.EventLog.MachineName%2A></xref:System.Diagnostics.EventLog.Log%2A>的值      1> [!NOTE]&1;> 不要求你指定<xref:System.Diagnostics.EventLog.MachineName%2A>如果你要连接到日志。</xref:System.Diagnostics.EventLog.MachineName%2A> 如果不指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本地计算机，&quot;。&quot;，则假定。</xref:System.Diagnostics.EventLog.MachineName%2A>"
  example:
  - "The following example reads entries in the event log, \"MyNewLog\", on the local computer.  \n  \n [!code-cs[Classic EventLog.Entries Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_23_1.cs)]\n [!code-cpp[Classic EventLog.Entries Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_23_1.cpp)]\n [!code-vb[Classic EventLog.Entries Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_23_1.vb)]"
  syntax:
    content: public System.Diagnostics.EventLogEntryCollection Entries { get; }
    return:
      type: System.Diagnostics.EventLogEntryCollection
      description: "<xref href=&quot;System.Diagnostics.EventLogEntryCollection&quot;> </xref>保存事件日志中的条目。 每个项均与实例相关联<xref href=&quot;System.Diagnostics.EventLogEntry&quot;></xref>类。"
  overload: System.Diagnostics.EventLog.Entries*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.EntryWritten
  id: EntryWritten
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EntryWritten
  nameWithType: EventLog.EntryWritten
  fullName: System.Diagnostics.EventLog.EntryWritten
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "在本地计算机上向事件日志写入一个条目时发生。"
  remarks: "若要获取事件通知，必须设置<xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A>到`true`。</xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> 只有在本地计算机上写入项时，只能接收事件通知。 无法接收在远程计算机上写入项的通知。       当你创建一个 EntryWritten 委托时，需要标识将处理该事件的方法。 若要将事件与事件处理程序关联，添加到事件的委托的一个实例。 每当发生该事件时，直到移除了该委托，都会调用事件处理程序。 有关与委托一起处理事件的详细信息，请参阅[事件](~/add/includes/ajax-current-ext-md.md)。       系统响应<xref:System.Diagnostics.EventLog.WriteEntry%2A>仅当最后一个写入事件发生至少为六秒以前。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 这意味着将仅收到一个&6; 秒间隔内的 EntryWritten 事件通知，即使多个事件日志更改发生该事件。 如果插入到的调用之间的足够长的休眠时间间隔 （大约为 10 秒钟） <xref:System.Diagnostics.EventLog.WriteEntry%2A>，你不太可能丢失事件。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 但是，如果更频繁地发生写入事件，你可能无法收到事件通知，直到下一个间隔。 通常情况下，丢失的事件通知将不丢失，而延迟。"
  example:
  - "The following example handles an entry written event.  \n  \n [!code-cs[Classic EventLog.EntryWritten Example#1](~/add/codesnippet/csharp/e-system.diagnostics.eve_1.cs)]\n [!code-cpp[Classic EventLog.EntryWritten Example#1](~/add/codesnippet/cpp/e-system.diagnostics.eve_1.cpp)]\n [!code-vb[Classic EventLog.EntryWritten Example#1](~/add/codesnippet/visualbasic/e-system.diagnostics.eve_1.vb)]"
  syntax:
    content: public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;
    return:
      type: System.Diagnostics.EntryWrittenEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Exists(System.String)
  id: Exists(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Exists(String)
  nameWithType: EventLog.Exists(String)
  fullName: System.Diagnostics.EventLog.Exists(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "确定本地计算机上是否存在日志。"
  remarks: "此方法用于确定本地计算机上是否存在日志。 如果你想要确定本地计算机上是否存在的源，，使用<xref:System.Diagnostics.EventLog.SourceExists%2A>。</xref:System.Diagnostics.EventLog.SourceExists%2A>       因为此方法访问注册表，你必须在本地计算机，则具有相应的注册表权限否则，查询将返回`false`。       因为你无法在同一台计算机上为新的日志的现有的日志名称，使用此方法之前创建新的日志以确定是否指定`logName`本地计算机上已存在。 `logName`参数不区分大小写。       存在是`static`方法，使其可以调用类本身上。 不需要创建的实例<xref:System.Diagnostics.EventLog>调用 Exists。</xref:System.Diagnostics.EventLog>"
  example:
  - >-
    [!code-cpp[EventLog_Exists_1#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_4_1.cpp)]
     [!code-vb[EventLog_Exists_1#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_4_1.vb)]
     [!code-cs[EventLog_Exists_1#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_4_1.cs)]
  syntax:
    content: public static bool Exists (string logName);
    parameters:
    - id: logName
      type: System.String
      description: '要搜索的日志的名称。 可能的值包括︰ 应用程序、 安全、 系统、 其他特定于应用程序日志 （如日志与 Active Directory 关联） 或在计算机上的任何自定义日志。'
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果日志存在于本地计算机，则上否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Diagnostics.EventLog.Exists*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "LogName 是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>或值为空。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Exists(System.String,System.String)
  id: Exists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Exists(String,String)
  nameWithType: EventLog.Exists(String,String)
  fullName: System.Diagnostics.EventLog.Exists(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "确定该日志是否存在指定的计算机上。"
  remarks: "使用此方法以确定远程计算机上是否存在日志。 如果你想要确定远程计算机上是否存在的源，，使用<xref:System.Diagnostics.EventLog.SourceExists%2A>。</xref:System.Diagnostics.EventLog.SourceExists%2A>       因为此方法访问注册表，你必须指定计算机上具有相应的注册表权限否则，查询将返回`false`。       由于你无法在同一台计算机上为新的日志的现有的日志名称，使用此方法在创建新日志之前确定如果一个具有指定`logName`按指定的服务器上已存在`machineName`参数。 `logName`和`machineName`参数不区分大小写。       <xref:System.Diagnostics.EventLog.Exists%2A>是`static`方法，使其可以调用类本身上。</xref:System.Diagnostics.EventLog.Exists%2A> 不需要创建的新实例<xref:System.Diagnostics.EventLog>来调用<xref:System.Diagnostics.EventLog.Exists%2A>.</xref:System.Diagnostics.EventLog.Exists%2A> </xref:System.Diagnostics.EventLog>"
  syntax:
    content: public static bool Exists (string logName, string machineName);
    parameters:
    - id: logName
      type: System.String
      description: '要搜索日志。 可能的值包括︰ 应用程序、 安全、 系统、 其他特定于应用程序日志 （如日志与 Active Directory 关联） 或在计算机上的任何自定义日志。'
    - id: machineName
      type: System.String
      description: "要搜索的日志，在其计算机的名称或&quot;。&quot;本地计算机。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果该日志存在指定的计算机; 上否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Diagnostics.EventLog.Exists*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> machineName </code>参数是无效的格式。 请确保你具有用于在其要搜索的计算机的正确的语法。       -或- <code> logName </code>是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>或值为空。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.GetEventLogs
  id: GetEventLogs
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: GetEventLogs()
  nameWithType: EventLog.GetEventLogs()
  fullName: System.Diagnostics.EventLog.GetEventLogs()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "搜索本地计算机上的所有事件日志并创建的数组<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>包含列表的对象。"
  remarks: "数组<xref:System.Diagnostics.EventLog>进行到 GetEventLogs 调用时，对象是本地计算机上的所有事件日志的快照。</xref:System.Diagnostics.EventLog> 这不是动态集合，因此它不反映的删除或创建的实时日志。 你应验证数组中的日志存在之前读取或写入到它。 数组通常包含至少三个日志︰ 应用程序、 系统和安全。 如果你在本地计算机上创建自定义日志，则它们将显示以及数组中。       若要检索事件日志的列表，你必须具有相应的注册表权限。 这些权限是与调用<xref:System.Diagnostics.EventLog.Exists%2A>和<xref:System.Diagnostics.EventLog.SourceExists%2A>。</xref:System.Diagnostics.EventLog.SourceExists%2A></xref:System.Diagnostics.EventLog.Exists%2A>所需的相同"
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_10_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/m-system.diagnostics.eve_10_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/m-system.diagnostics.eve_10_1.cs)]"
  syntax:
    content: public static System.Diagnostics.EventLog[] GetEventLogs ();
    parameters: []
    return:
      type: System.Diagnostics.EventLog[]
      description: "类型的数组<xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> ，表示本地计算机上的日志。"
  overload: System.Diagnostics.EventLog.GetEventLogs*
  exceptions:
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "你没有读取访问注册表。       -或者-计算机上没有任何事件日志服务。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.GetEventLogs(System.String)
  id: GetEventLogs(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: GetEventLogs(String)
  nameWithType: EventLog.GetEventLogs(String)
  fullName: System.Diagnostics.EventLog.GetEventLogs(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "在给定计算机上的所有事件日志中都搜索和创建的数组<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>包含列表的对象。"
  remarks: "数组<xref:System.Diagnostics.EventLog>对象是指定的计算机上的所有事件日志的快照`machineName`参数时对调用<xref:System.Diagnostics.EventLog.GetEventLogs%2A>进行。</xref:System.Diagnostics.EventLog.GetEventLogs%2A> </xref:System.Diagnostics.EventLog> 这不是动态集合，因此它不反映的删除或创建的实时日志。 你应验证数组中的日志存在之前读取或写入到它。 数组通常包含至少三个日志︰ 应用程序、 系统和安全。 如果指定的计算机上创建自定义日志，则它们将显示以及数组中。       <xref:System.Diagnostics.EventLog.GetEventLogs%2A>是`static`方法，使其可以调用上<xref:System.Diagnostics.EventLog>类本身。</xref:System.Diagnostics.EventLog></xref:System.Diagnostics.EventLog.GetEventLogs%2A> 不需要创建的实例<xref:System.Diagnostics.EventLog>要使其对方法的调用对象。</xref:System.Diagnostics.EventLog>       若要检索事件日志的列表，你必须具有相应的注册表权限。 这些权限是与调用<xref:System.Diagnostics.EventLog.Exists%2A>和<xref:System.Diagnostics.EventLog.SourceExists%2A>。</xref:System.Diagnostics.EventLog.SourceExists%2A></xref:System.Diagnostics.EventLog.Exists%2A>所需的相同"
  example:
  - "The following example gets a list of logs on the computer \"myServer\". It then outputs the name of each log.  \n  \n [!code-cpp[Classic EventLog.GetEventLogs1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_18_1.cpp)]\n [!code-cs[Classic EventLog.GetEventLogs1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_18_1.cs)]\n [!code-vb[Classic EventLog.GetEventLogs1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_18_1.vb)]"
  syntax:
    content: public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);
    parameters:
    - id: machineName
      type: System.String
      description: "要搜索事件日志在其计算机。"
    return:
      type: System.Diagnostics.EventLog[]
      description: "类型的数组<xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> ，表示给定计算机上的日志。"
  overload: System.Diagnostics.EventLog.GetEventLogs*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> machineName </code>参数是无效的计算机名称。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "你没有读取访问注册表。       -或者-计算机上没有任何事件日志服务。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Log
  id: Log
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Log
  nameWithType: EventLog.Log
  fullName: System.Diagnostics.EventLog.Log
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置要读取或写入的日志的名称。"
  remarks: "Three log files exist by default on the server: Application, System, and Security. Applications and services use the Application log file. Device drivers use the System log file. The system generates success and failure audit events in the Security log when auditing is turned on. If you have other applications installed, like Active Directory on Windows servers, there might be other default log files. In addition, you can create custom log files on a local or remote computer. Custom logs help organize your entries in a more detailed way than is allowed when your components write events to the default Application log.  \n  \n> [!NOTE]\n>  Log names are limited to eight characters. According to the system, MyLogSample1 and MyLogSample2 are the same log.  \n  \n If you write to an event log, it is not enough to specify the Log property. You must associate a <xref:System.Diagnostics.EventLog.Source%2A> property with your event log resource to connect it to a particular log. It is not necessary to specify a <xref:System.Diagnostics.EventLog.Source%2A> when only reading from a log, but an event source must be associated with the event log resource in the server's registry. You can specify only the Log name and <xref:System.Diagnostics.EventLog.MachineName%2A> (server computer name) to read from it.  \n  \n> [!NOTE]\n>  You are not required to specify the <xref:System.Diagnostics.EventLog.MachineName%2A> if you are connecting to a log. If you do not specify the <xref:System.Diagnostics.EventLog.MachineName%2A>, the local computer (\".\") is assumed.  \n  \n If the <xref:System.Diagnostics.EventLog.Source%2A> property has not been specified, a call to Log returns an empty string if Log has not been explicitly set (by setting the Log property, or through the constructor). If the <xref:System.Diagnostics.EventLog.Source%2A> has been specified, Log returns the name of the log to which that source was registered.  \n  \n A source can only be registered to one log at a time. If the <xref:System.Diagnostics.EventLog.Source%2A> property was set for an instance of <xref:System.Diagnostics.EventLog>, you cannot change the Log property for that <xref:System.Diagnostics.EventLog> without changing the value of <xref:System.Diagnostics.EventLog.Source%2A> or calling <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> first. If you change the Log property after the <xref:System.Diagnostics.EventLog.Source%2A> property has been set, writing a log entry throws an exception.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the Log property with the \".evt\" file name extension.  \n  \n You cannot create a new log using the Log property alone (without specifying a source for the log). You can call <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, passing in a new log name as a parameter, and then call <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. However, the intent is usually either to create (and write entries to) new application-specific logs, or to read from existing logs.  \n  \n If the Log value changes, the event log is closed and all event handles are released.  \n  \n> [!CAUTION]\n>  If you set the Log property to the name of a log that does not exist, the system attaches the <xref:System.Diagnostics.EventLog> to the Application log, but does not warn you that it is using a log other than the one you specified."
  example:
  - "The following example reads entries in the event log, \"NewEventLog\", on the local computer.  \n  \n [!code-cpp[Classic EventLog.Log Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_17_1.cpp)]\n [!code-cs[Classic EventLog.Log Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_17_1.cs)]\n [!code-vb[Classic EventLog.Log Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_17_1.vb)]"
  syntax:
    content: public string Log { get; set; }
    return:
      type: System.String
      description: "日志的名称。 这可以是应用程序、 系统、 安全性或自定义日志名称。 默认值为空字符串 (&quot;&quot;)。"
  overload: System.Diagnostics.EventLog.Log*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.LogDisplayName
  id: LogDisplayName
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: LogDisplayName
  nameWithType: EventLog.LogDisplayName
  fullName: System.Diagnostics.EventLog.LogDisplayName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取事件日志的友好名称。"
  remarks: "> [!NOTE]1> 在 Windows Vista 或更高版本，则用户没有访问安全日志的权限。 如果你正在运行 Windows Vista 或更高版本以用户身份，你将收到<xref:System.Security.SecurityException>当您尝试访问安全日志中事件的显示名称</xref:System.Security.SecurityException>   >> 在 Windows Vista 或更高版本，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，您分配两个运行时访问令牌︰ 一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色中。 若要执行的代码访问安全日志，首先必须将你的特权从标准用户提升至管理员。 通过右键单击应用程序图标并指示需以管理员身份运行启动应用程序时，你可以执行此操作。"
  example:
  - "The following example enumerates the event logs defined on the local computer and displays the LogDisplayName for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_29_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_29_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_29_1.cs)]"
  syntax:
    content: public string LogDisplayName { get; }
    return:
      type: System.String
      description: "表示系统的事件查看器中的事件日志的名称。"
  overload: System.Diagnostics.EventLog.LogDisplayName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "指定<xref:System.Diagnostics.EventLog.Log*>此计算机的注册表中不存在。</xref:System.Diagnostics.EventLog.Log*>"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)
  id: LogNameFromSourceName(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: LogNameFromSourceName(String,String)
  nameWithType: EventLog.LogNameFromSourceName(String,String)
  fullName: System.Diagnostics.EventLog.LogNameFromSourceName(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取指定的源注册到日志的名称。"
  remarks: "事件源指示什么来记录事件。 通常很的应用程序，名称或名称的子组件的应用程序，如果应用程序非常大。 应用程序和服务应写入应用程序日志或自定义日志。 设备驱动程序应写入系统日志。       在你创建新的源，可以仅写入一个日志一次，系统将你的应用程序的事件日志注册为有效项源。 <xref:System.Diagnostics.EventLog.Source%2A>属性可以是任意字符串，但名称不能由计算机上的其他源。</xref:System.Diagnostics.EventLog.Source%2A> 尝试创建重复的<xref:System.Diagnostics.EventLog.Source%2A>值引发异常。</xref:System.Diagnostics.EventLog.Source%2A> 但是，单个事件日志可以有许多不同的源向其写入。"
  example:
  - "The following example deletes a source from the local computer. The example determines the log from its source, and then deletes the log.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_2_1.cpp)]\n [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_2_1.vb)]\n [!code-cs[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_2_1.cs)]"
  syntax:
    content: public static string LogNameFromSourceName (string source, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "事件源的名称。"
    - id: machineName
      type: System.String
      description: "在其中进行查找，计算机的名称或&quot;。&quot;本地计算机。"
    return:
      type: System.String
      description: "在注册表中指定的源关联的日志的名称。"
  overload: System.Diagnostics.EventLog.LogNameFromSourceName*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.MachineName
  id: MachineName
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: MachineName
  nameWithType: EventLog.MachineName
  fullName: System.Diagnostics.EventLog.MachineName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置要读取或写入事件在其计算机的名称。"
  remarks: "如果写入事件日志时，你必须将关联<xref:System.Diagnostics.EventLog.Source%2A>与你的事件日志对象以将其连接到特定的日志。</xref:System.Diagnostics.EventLog.Source%2A> 不需要指定<xref:System.Diagnostics.EventLog.Source%2A>属性时仅从日志中读取</xref:System.Diagnostics.EventLog.Source%2A> 你可以仅指定<xref:System.Diagnostics.EventLog.Log%2A>名称和 MachineName （服务器计算机名称）。</xref:System.Diagnostics.EventLog.Log%2A>      1> [!NOTE]&1;> 你不需要指定计算机名，如果要连接到日志。 如果不指定 MachineName，本地计算机 (&quot;。&quot;) 假定。       一个源一次仅注册到一个日志。 如果<xref:System.Diagnostics.EventLog.Source%2A>属性已设置的实例<xref:System.Diagnostics.EventLog>，无法为此更改的 MachineName 属性<xref:System.Diagnostics.EventLog>而无需更改的值<xref:System.Diagnostics.EventLog.Source%2A>或调用<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>第一个。</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> </xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> 如果更改 MachineName 属性中，<xref:System.Diagnostics.EventLog>关闭所有句柄并重新附加到的日志和新的计算机上的源。</xref:System.Diagnostics.EventLog>       MachineName 值不能为空字符串。 如果显式设置，则默认为本地计算机 (&quot;。&quot;)。"
  example:
  - "The following example reads entries in the event log, \"NewEventLog\", on a specified computer.  \n  \n [!code-cs[Classic EventLog.MachineName Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_6_1.cs)]\n [!code-vb[Classic EventLog.MachineName Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_6_1.vb)]\n [!code-cpp[Classic EventLog.MachineName Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_6_1.cpp)]"
  syntax:
    content: public string MachineName { get; set; }
    return:
      type: System.String
      description: "事件日志所在的服务器的名称。 默认值为本地计算机 (&quot;。&quot;)。"
  overload: System.Diagnostics.EventLog.MachineName*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "计算机名称无效。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.MaximumKilobytes
  id: MaximumKilobytes
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: MaximumKilobytes
  nameWithType: EventLog.MaximumKilobytes
  fullName: System.Diagnostics.EventLog.MaximumKilobytes
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置最大事件日志大小以千字节为单位。"
  remarks: "MaximumKilobytes 属性表示的事件日志文件的大小限制。 当在事件日志达到配置的大小限制<xref:System.Diagnostics.EventLog.OverflowAction%2A>值确定是否将丢弃新条目，或是否新条目覆盖旧条目。</xref:System.Diagnostics.EventLog.OverflowAction%2A>      1> [!NOTE]&1;> 此属性表示此实例所表示的事件日志的配置设置。 当事件日志达到其最大大小时，此属性指定操作系统如何处理为事件日志已注册的所有事件源都写入新条目。"
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_15_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_15_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_15_1.cs)]"
  syntax:
    content: public long MaximumKilobytes { get; set; }
    return:
      type: System.Int64
      description: "最大事件日志大小，以千字节为单位。 默认值为 512，表示的最大文件大小为 512 千字节为单位。"
  overload: System.Diagnostics.EventLog.MaximumKilobytes*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "指定的值小于 64，或大于 4194240 或不 64 的偶数倍。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <xref:System.Diagnostics.EventLog.Log*> value is not a valid log name.  \n  \n \\- or -  \n  \n The registry key for the event log could not be opened on the target computer."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.MinimumRetentionDays
  id: MinimumRetentionDays
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: MinimumRetentionDays
  nameWithType: EventLog.MinimumRetentionDays
  fullName: System.Diagnostics.EventLog.MinimumRetentionDays
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取要在事件日志中保留项的天数。"
  remarks: "MinimumRetentionDays 属性用于检查事件日志的当前设置。 使用<xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>更改必须保留在事件日志中的每个条目最少天数。</xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>       MinimumRetentionDays 值取决于事件日志的已配置的溢出行为。 如果<xref:System.Diagnostics.OverflowAction>事件日志的属性设置为<xref:System.Diagnostics.OverflowAction>，则 MinimumRetentionDays 值为 0。</xref:System.Diagnostics.OverflowAction> </xref:System.Diagnostics.OverflowAction> 如果<xref:System.Diagnostics.OverflowAction>事件日志的属性设置为<xref:System.Diagnostics.OverflowAction>，然后 MinimumRetentionDays 值为-1。</xref:System.Diagnostics.OverflowAction> </xref:System.Diagnostics.OverflowAction> 如果<xref:System.Diagnostics.OverflowAction>事件日志的属性设置为<xref:System.Diagnostics.OverflowAction>，则 MinimumRetentionDays 值大于零，并表示的事件日志已满时保留事件日志条目的天数。</xref:System.Diagnostics.OverflowAction> </xref:System.Diagnostics.OverflowAction>       溢出行为仅会在事件日志达到其容量限制时发生。 当<xref:System.Diagnostics.EventLog>具有其<xref:System.Diagnostics.EventLog.OverflowAction%2A>设置为<xref:System.Diagnostics.OverflowAction>，和在事件日志达到其最大大小，则新条目如果它们可以将其保留时间超出 MinimumRetentionDays 期间的条目只能写入。</xref:System.Diagnostics.OverflowAction> </xref:System.Diagnostics.EventLog.OverflowAction%2A> </xref:System.Diagnostics.EventLog> 事件项保留最短期限适合定期存档事件日志时的不同而不同。 否则，则可能在事件日志达到其限制时丢失新条目。 若要避免丢失新的事件信息，请设置基于对您的存档计划为特定的事件日志的事件的最小保留天数。"
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_12_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_12_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_12_1.cs)]"
  syntax:
    content: public int MinimumRetentionDays { get; }
    return:
      type: System.Int32
      description: "事件日志中的条目保留天数。 默认值为 7。"
  overload: System.Diagnostics.EventLog.MinimumRetentionDays*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  id: ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: ModifyOverflowPolicy(OverflowAction,Int32)
  nameWithType: EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
  fullName: System.Diagnostics.EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "更改已配置的行为的事件日志达到其最大文件大小时写入新条目。"
  remarks: "事件日志的溢出行为指定要写入到日志已达到其最大文件大小新条目时，会发生什么情况。      1> [!NOTE]&1;> 溢出行为仅在事件日志达到其最大文件大小时时，才起作用。 溢出行为不会影响到可以容纳其他事件日志条目的日志写入新的条目。       ModifyOverflowPolicy 方法配置事件日志的溢出行为。 <xref:System.Diagnostics.EventLog>实例。</xref:System.Diagnostics.EventLog> 为指定的事件日志中调用此方法后<xref:System.Diagnostics.EventLog.Log%2A>属性，<xref:System.Diagnostics.EventLog.OverflowAction%2A>和<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>属性值反映新配置的溢出行为。</xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> </xref:System.Diagnostics.EventLog.OverflowAction%2A> </xref:System.Diagnostics.EventLog.Log%2A>      1> [!NOTE]&1;> 此属性表示此实例所表示的事件日志的配置设置。 当事件日志达到其最大大小时，此属性指定操作系统如何处理为事件日志已注册的所有事件源都写入新条目。       设置`action`参数<xref:System.Diagnostics.OverflowAction>以指示新条目覆盖最旧条目时<xref:System.Diagnostics.EventLog>达到其最大大小。</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.OverflowAction> 如果`action`参数设置为<xref:System.Diagnostics.OverflowAction>、`retentionDays`参数值将被忽略。</xref:System.Diagnostics.OverflowAction>       设置`action`参数<xref:System.Diagnostics.OverflowAction>以指示每个新条目将覆盖旧条目时<xref:System.Diagnostics.EventLog>达到其最大大小。</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.OverflowAction> 指定在日志中使用的事件必须保留的天数`retentionDays`参数。 保持期内写入的事件不会覆盖通过新的条目。       设置`action`参数<xref:System.Diagnostics.OverflowAction>丢弃新事件时已达到最大日志大小。</xref:System.Diagnostics.OverflowAction> 如果`action`参数设置为<xref:System.Diagnostics.OverflowAction>、`retentionDays`参数值将被忽略。</xref:System.Diagnostics.OverflowAction>      1> [!CAUTION]&1;> 将溢出策略设置为<xref:System.Diagnostics.OverflowAction>指定当事件日志已满而丢弃新条目。</xref:System.Diagnostics.OverflowAction> 如果你使用此设置，请确保定期存档和清除避免达到其最大大小限制事件日志。"
  example:
  - "The following example displays the configured overflow policy for a specified event log, and allows the user to select a new overflow policy setting for the event log.  \n  \n [!code-vb[EventLogProperties#3](~/add/codesnippet/visualbasic/0b0fc273-a638-4af9-ae99-_1.vb)]\n [!code-cpp[EventLogProperties#3](~/add/codesnippet/cpp/0b0fc273-a638-4af9-ae99-_1.cpp)]\n [!code-cs[EventLogProperties#3](~/add/codesnippet/csharp/0b0fc273-a638-4af9-ae99-_1.cs)]"
  syntax:
    content: public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);
    parameters:
    - id: action
      type: System.Diagnostics.OverflowAction
      description: "向事件日志写入新项溢出行为。"
    - id: retentionDays
      type: System.Int32
      description: "保留每个事件日志条目最少天数。 仅当使用此参数`action`设置为<xref href=&quot;System.Diagnostics.OverflowAction&quot;> </xref>。"
  overload: System.Diagnostics.EventLog.ModifyOverflowPolicy*
  exceptions:
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>action</code>不是有效<xref:System.Diagnostics.EventLog.OverflowAction*>值。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>retentionDays</code>小于 1，或大于 365。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <xref:System.Diagnostics.EventLog.Log*> value is not a valid log name.  \n  \n \\- or -  \n  \n The registry key for the event log could not be opened on the target computer."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.OverflowAction
  id: OverflowAction
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: OverflowAction
  nameWithType: EventLog.OverflowAction
  fullName: System.Diagnostics.EventLog.OverflowAction
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取事件日志达到其最大日志文件大小时存储新项的已配置的行为。"
  remarks: "事件日志大小增大新事件写入到它们。 每个事件日志的配置的最大大小限制;<xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>属性定义的最大事件日志文件大小所允许的千字节数。</xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>       使用 OverflowAction 属性值来检查其最大大小在事件日志的已配置的溢出行为。 使用<xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>方法来更改事件日志的溢出行为</xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>      1> [!NOTE]&1;> 溢出行为仅在事件日志达到其最大文件大小时时，才起作用。 溢出行为不会影响到可以容纳其他事件日志条目的日志写入新的条目。"
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_28_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_28_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_28_1.cs)]"
  syntax:
    content: public System.Diagnostics.OverflowAction OverflowAction { get; }
    return:
      type: System.Diagnostics.OverflowAction
      description: "<xref href=&quot;System.Diagnostics.OverflowAction&quot;> </xref>值，该值指定事件日志达到其最大日志大小时存储新项的已配置的行为。 默认值是<xref href=&quot;System.Diagnostics.OverflowAction&quot;> </xref>。"
  overload: System.Diagnostics.EventLog.OverflowAction*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)
  id: RegisterDisplayName(System.String,System.Int64)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: RegisterDisplayName(String,Int64)
  nameWithType: EventLog.RegisterDisplayName(String,Int64)
  fullName: System.Diagnostics.EventLog.RegisterDisplayName(String,Int64)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "指定事件日志中，server 事件查看器中显示的本地化的名称。"
  remarks: "使用 RegisterDisplayName 来注册和自定义事件日志事件查看器中显示的本地化的名称。       指定的资源标识符必须对应于在资源文件中定义的本地化字符串。 事件查看器显示使用本地化的字符串和当前区域性设置的自定义事件日志名称。 例如，你可以定义多个资源文件中的不同区域性的本地化的事件日志名称。 事件查看器显示当前用户的区域性设置相对应的本地化的字符串。       如果事件查看器无法从资源文件中，加载本地化的字符串，或者如果没有显示名称已注册的事件日志，事件查看器显示<xref:System.Diagnostics.EventLog.Log%2A>.</xref:System.Diagnostics.EventLog.Log%2A>中定义的事件日志名称      1> [!NOTE]&1;> 不需要注册预定义的事件日志的显示名称。 操作系统注册应用程序、 系统和安全事件日志的本地化的显示名称。"
  example:
  - "The following example determines whether the event source named `SampleApplicationSource` is registered on the local computer. If the event source does not exist, the example sets the message resource file for the source and creates the new event source. Finally, the example sets the localized display name for the event log, using the resource identifier value in `DisplayNameMsgId` and the resource file path in `messageFile`.  \n  \n [!code-cpp[EventLog_WriteEvent#6](~/add/codesnippet/cpp/m-system.diagnostics.eve_1_1.cpp)]\n [!code-vb[EventLog_WriteEvent#6](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_1_1.vb)]\n [!code-cs[EventLog_WriteEvent#6](~/add/codesnippet/csharp/m-system.diagnostics.eve_1_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings. Specifically, resource identifier 5001 is defined for the localized name of the event log.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public void RegisterDisplayName (string resourceFile, long resourceId);
    parameters:
    - id: resourceFile
      type: System.String
      description: "本地化的资源文件的完全指定的路径。"
    - id: resourceId
      type: System.Int64
      description: "索引中的资源文件的本地化的字符串资源标识符。"
  overload: System.Diagnostics.EventLog.RegisterDisplayName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <xref:System.Diagnostics.EventLog.Log*> value is not a valid log name.  \n  \n \\- or -  \n  \n The registry key for the event log could not be opened on the target computer."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>resourceFile </code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Source
  id: Source
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Source
  nameWithType: EventLog.Source
  fullName: System.Diagnostics.EventLog.Source
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置要注册并在写入到事件日志时使用的源名称。"
  remarks: "事件源指示什么来记录事件。 通常很的应用程序，名称或名称的子组件的应用程序，如果应用程序非常大。 应用程序和服务应写入应用程序日志或自定义日志。 设备驱动程序应写入系统日志。       只需指定事件源，如果要写入事件日志。 然后再写入事件日志条目，你必须将注册事件源的事件日志有效的事件源。 当你编写日志条目时，系统将使用源属性来查找适当的日志要在其中放置你的条目。 如果您正在读取事件日志，你可以指定源，或<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>。</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A>      1> [!NOTE]&1;> 不要求你指定<xref:System.Diagnostics.EventLog.MachineName%2A>如果您连接到本地计算机上的日志。</xref:System.Diagnostics.EventLog.MachineName%2A> 如果不指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本地计算机 (&quot;。&quot;) 假定。</xref:System.Diagnostics.EventLog.MachineName%2A>       使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>，<xref:System.Diagnostics.EventLog.WriteEntry%2A>来编写事件，以便将事件日志。</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.WriteEvent%2A> 必须指定事件源写入事件;你必须创建并在编写与源的第一个条目之前，配置事件源。       在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 若要创建新的事件源的计算机上，必须具有管理权限。       你可以创建现有的事件日志或新的事件日志的事件源。 在创建新的源的新的事件日志时，系统将为该日志，此源注册，但之前向其中写入的第一个条目，将不会创建日志。       必须是唯一的本地计算机; 上的源新的源名称不能与现有源名称或现有的事件日志名称匹配。 每个源可以一次; 写入只有一个事件日志但是，你的应用程序可以使用多个源写入多个事件日志。 例如，你的应用程序可能需要为不同的事件日志或不同的资源文件配置的多个源。       如果你更改源值中，<xref:System.Diagnostics.EventLog>到它注册已关闭并释放所有事件句柄。</xref:System.Diagnostics.EventLog>       要写入本地化的项还是要直接写入字符串，则必须配置源。 如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用该<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法使用在事件日志的资源标识符来编写条目</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的源 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>       若要更改现有源的配置详细信息，必须删除源，然后使用新的配置创建。 如果其他应用程序或组件使用的现有源，请使用更新的配置，而无需删除现有的源创建新的源。      1> [!NOTE]&1;> 如果源已映射到某个日志和重新映射到新的日志，你必须重新启动计算机才能使更改生效。"
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.Source Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_18_1.cs)]\n [!code-vb[Classic EventLog.Source Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_18_1.vb)]\n [!code-cpp[Classic EventLog.Source Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_18_1.cpp)]"
  syntax:
    content: public string Source { get; set; }
    return:
      type: System.String
      description: "事件日志中注册为项源的名称。 默认值为空字符串 (&quot;&quot;)。"
  overload: System.Diagnostics.EventLog.Source*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "源名称导致注册表项路径的长度超过 254 个字符。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.SourceExists(System.String)
  id: SourceExists(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: SourceExists(String)
  nameWithType: EventLog.SourceExists(String)
  fullName: System.Diagnostics.EventLog.SourceExists(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "确定是否已在本地计算机上注册事件源。"
  remarks: "此方法用于确定本地计算机上是否存在事件源。 如果你想要确定本地计算机上是否存在日志，，使用<xref:System.Diagnostics.EventLog.Exists%2A>。</xref:System.Diagnostics.EventLog.Exists%2A>       因为此方法访问注册表，你必须在本地计算机，则具有相应的注册表权限否则为<xref:System.Security.SecurityException>将引发。</xref:System.Security.SecurityException>      1> [!NOTE] 1> 若要搜索的事件源在 Windows Vista 或更高版本或 Windows Server 2003，你必须具有管理特权。   >> 此要求的原因是所有的事件日志，包括安全性，必须进行搜索以确定事件源是否唯一。 从 Windows Vista 开始，用户没有权限访问安全事件日志中。因此，<xref:System.Security.SecurityException>引发。</xref:System.Security.SecurityException>   >> 从 Windows Vista 中，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，您分配两个运行时访问令牌︰ 一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色中。 若要执行访问性能计数器的代码，首先必须将你的特权从标准用户提升至管理员。 通过右键单击应用程序图标并指示需以管理员身份运行启动应用程序时，你可以执行此操作。      1> [!NOTE]&1;> 执行时使用的服务<xref:System.ServiceProcess.ServiceAccount>帐户没有执行此方法所需的特权。</xref:System.ServiceProcess.ServiceAccount> 解决方法是检查中是否存在事件源<xref:System.ServiceProcess.ServiceInstaller>，并且如果它不存在，在安装程序中创建源。</xref:System.ServiceProcess.ServiceInstaller>       因为你无法为新的源的同一台计算机上的现有源名称，使用此方法尝试之前调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>以确保源指定的名称与`source`本地计算机上尚不存在。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> `source`参数不区分大小写。"
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.Source Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_14_1.cs)]\n [!code-vb[Classic EventLog.Source Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_14_1.vb)]\n [!code-cpp[Classic EventLog.Source Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_14_1.cpp)]"
  syntax:
    content: public static bool SourceExists (string source);
    parameters:
    - id: source
      type: System.String
      description: "事件源的名称。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果在本地计算机; 上注册事件源，否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Diagnostics.EventLog.SourceExists*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<code>source</code>未找到，但无法搜索事件日志的部分或全部。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.SourceExists(System.String,System.String)
  id: SourceExists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: SourceExists(String,String)
  nameWithType: EventLog.SourceExists(String,String)
  fullName: System.Diagnostics.EventLog.SourceExists(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "确定是否在指定计算机上注册事件源。"
  remarks: "此方法用于确定指定的计算机上是否存在事件源`machineName`参数。 如果你想要确定日志是否存在指定的计算机上，，使用<xref:System.Diagnostics.EventLog.Exists%2A>。</xref:System.Diagnostics.EventLog.Exists%2A>       因为此方法访问注册表，你必须在给定的服务器中; 上具有相应的注册表权限否则为<xref:System.Security.SecurityException>将引发。</xref:System.Security.SecurityException>      1> [!NOTE] 1> 若要搜索的事件源在 Windows Vista 或更高版本或 Windows Server 2003，你必须具有管理特权。   >> 此要求的原因是所有的事件日志，包括安全性，必须进行搜索以确定事件源是否唯一。 从 Windows Vista 开始，用户没有权限访问安全事件日志中。因此，<xref:System.Security.SecurityException>引发。</xref:System.Security.SecurityException>   >> 从 Windows Vista 中，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，您分配两个运行时访问令牌︰ 一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色中。 若要执行访问性能计数器的代码，首先必须将你的特权从标准用户提升至管理员。 通过右键单击应用程序图标并指示需以管理员身份运行启动应用程序时，你可以执行此操作。      1> [!NOTE]&1;> 执行时使用的服务<xref:System.ServiceProcess.ServiceAccount>帐户没有执行此方法所需的特权。</xref:System.ServiceProcess.ServiceAccount> 解决方法是检查中是否存在事件源<xref:System.ServiceProcess.ServiceInstaller>，并且如果它不存在，在安装程序中创建源。</xref:System.ServiceProcess.ServiceInstaller>       因为你无法为新的源的同一台计算机上的现有源名称，使用此方法尝试之前调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>以确保源指定的名称与`source`计算机上尚不存在。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> `source`和`machineName`参数不区分大小写。       <xref:System.Diagnostics.EventLog.SourceExists%2A>是`static`方法，使其可以调用类本身上。</xref:System.Diagnostics.EventLog.SourceExists%2A> 不需要创建一<xref:System.Diagnostics.EventLog>，然后调用<xref:System.Diagnostics.EventLog.SourceExists%2A>.</xref:System.Diagnostics.EventLog.SourceExists%2A></xref:System.Diagnostics.EventLog>实例"
  example:
  - "The following example creates the source `MySource` on the computer `MyServer`, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_16_1.cpp)]\n [!code-cs[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_16_1.cs)]\n [!code-vb[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_16_1.vb)]"
  syntax:
    content: public static bool SourceExists (string source, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "事件源的名称。"
    - id: machineName
      type: System.String
      description: "名称的计算机上查找，或&quot;。&quot;本地计算机。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果给定的计算机; 上注册事件源，否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Diagnostics.EventLog.SourceExists*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>machineName</code>是无效的计算机名称。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<code>source</code>未找到，但无法搜索事件日志的部分或全部。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.SynchronizingObject
  id: SynchronizingObject
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: SynchronizingObject
  nameWithType: EventLog.SynchronizingObject
  fullName: System.Diagnostics.EventLog.SynchronizingObject
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "获取或设置用于封送的结果发出的事件处理程序调用的对象<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>项写入事件。"
  remarks: "SynchronizingObject 时`null`，方法处理<xref:System.Diagnostics.EventLog.EntryWritten>事件调用从系统线程池线程上。</xref:System.Diagnostics.EventLog.EntryWritten> 系统线程池的详细信息，请参阅<xref:System.Threading.ThreadPool>。</xref:System.Threading.ThreadPool>       当<xref:System.Diagnostics.EventLog.EntryWritten>事件由 visual Windows 窗体组件，如按钮，通过系统线程池访问组件可能无法工作，或可能导致的异常处理。</xref:System.Diagnostics.EventLog.EntryWritten> 通过设置 SynchronizingObject 到 Windows 窗体组件时，这会导致处理的方法来避免这<xref:System.Diagnostics.EventLog.EntryWritten>事件在其创建该组件在同一线程上调用。</xref:System.Diagnostics.EventLog.EntryWritten>       如果<xref:System.Diagnostics.EventLog>在内部使用[!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)]在 Windows 窗体设计器中，SynchronizingObject 自动设置为包含<xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog>控件</xref:System.Diagnostics.EventLog> 例如，如果你将放置<xref:System.Diagnostics.EventLog>form1 设计器上 (其继承自<xref:System.Windows.Forms.Form>) 的 SynchronizingObject 属性<xref:System.Diagnostics.EventLog>被设置为 form1 的实例。</xref:System.Diagnostics.EventLog> </xref:System.Windows.Forms.Form> </xref:System.Diagnostics.EventLog>"
  syntax:
    content: public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }
    return:
      type: System.ComponentModel.ISynchronizeInvoke
      description: "<xref href=&quot;System.ComponentModel.ISynchronizeInvoke&quot;> </xref>用于封送引发的事件处理程序调用<xref href=&quot;System.Diagnostics.EventLog.EntryWritten&quot;></xref>事件日志上的事件。"
  overload: System.Diagnostics.EventLog.SynchronizingObject*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String)
  id: WriteEntry(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String)
  nameWithType: EventLog.WriteEntry(String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "将写入事件日志信息类型项，以给定的消息的文本。"
  remarks: "使用此方法与此关联的事件日志中写入信息项<xref:System.Diagnostics.EventLog>实例。</xref:System.Diagnostics.EventLog> 如果你想要指定任何其他<xref:System.Diagnostics.EventLogEntryType>，请使用<xref:System.Diagnostics.EventLog.WriteEntry%2A>.</xref:System.Diagnostics.EventLog.WriteEntry%2A>的不同重载</xref:System.Diagnostics.EventLogEntryType>      1> [!NOTE]&1;>`message`字符串不能包含 %*n*，其中*n*是整数值 (例如，%1)，因为事件查看器会将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址只能包含此字符序列，因为无法记录事件消息包含 IPv6 地址。       必须设置的<xref:System.Diagnostics.EventLog.Source%2A>属性在<xref:System.Diagnostics.EventLog>组件，才能使用你可以将条目写入日志。</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> 你必须创建并在编写与源的第一个条目之前，配置事件源。       在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 若要创建新的事件源的计算机上，必须具有管理权限。       如果在指定的源<xref:System.Diagnostics.EventLog.Source%2A>此属性<xref:System.Diagnostics.EventLog>写入你的组件，在计算机上未注册实例<xref:System.Diagnostics.EventLog.WriteEntry%2A>调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>并注册该源。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      1> [!NOTE]&1;> 如果不指定<xref:System.Diagnostics.EventLog.MachineName%2A>为你<xref:System.Diagnostics.EventLog>实例然后才能调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>或<xref:System.Diagnostics.EventLog.WriteEntry%2A>，本地计算机 (&quot;。&quot;) 假定。</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       如果系统需要<xref:System.Diagnostics.EventLog.Source%2A>通过调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>和<xref:System.Diagnostics.EventLog.Log%2A>未在你的<xref:System.Diagnostics.EventLog>情况下，日志将默认为在应用程序日志</xref:System.Diagnostics.EventLog>上设置属性</xref:System.Diagnostics.EventLog.Log%2A>的</xref:System.Diagnostics.EventLog.WriteEntry%2A></xref:System.Diagnostics.EventLog.Source%2A>注册      1> [!NOTE]&1;> 许多上面列出的异常都由过程注册<xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>的过程中引发的错误       要写入本地化的项还是要直接写入字符串，则必须配置源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法直接写入事件日志将写入给定的字符串; 它不使用可本地化的消息资源文件。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来写入事件时使用本地化的消息资源文件。</xref:System.Diagnostics.EventLog.WriteEvent%2A>       如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用该<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法使用在事件日志的资源标识符来编写条目</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的源 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>      1> [!NOTE]&1;> 到远程计算机中写入条目，如果消息 （文本字符串） 的值可能不是你所预期如果远程计算机未在运行.NET Framework。      1> [!NOTE]&1;> 如果`message`参数包含 NUL 字符，则在 NUL 字符处终止事件日志的消息中。"
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_7_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_7_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_7_1.vb)]"
  syntax:
    content: public void WriteEntry (string message);
    parameters:
    - id: message
      type: System.String
      description: "要写入事件日志的字符串。"
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "无法打开事件日志的注册表项。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "操作系统报告错误时向事件日志中写入事件项。 Windows 错误代码不可用。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "将错误、 警告、 信息、 成功审核或失败审核项与给定的消息文本一起写入事件日志。"
  remarks: "使用此方法写入的指定<xref:System.Diagnostics.EventLogEntryType>事件日志</xref:System.Diagnostics.EventLogEntryType>条目 `type`指示由一个图标和事件查看器日志中的类型列中的文本。      1> [!NOTE]&1;>`message`字符串不能包含 %*n*，其中*n*是整数值 (例如，%1)，因为事件查看器会将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址只能包含此字符序列，因为无法记录事件消息包含 IPv6 地址。       必须设置的<xref:System.Diagnostics.EventLog.Source%2A>属性在<xref:System.Diagnostics.EventLog>组件，才能使用你可以将条目写入日志。</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> 你必须创建并在编写与源的第一个条目之前，配置事件源。       在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 若要创建新的事件源的计算机上，必须具有管理权限。       如果在指定的源<xref:System.Diagnostics.EventLog.Source%2A>此属性<xref:System.Diagnostics.EventLog>写入你的组件，在计算机上未注册实例<xref:System.Diagnostics.EventLog.WriteEntry%2A>调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>并注册该源。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      1> [!NOTE]&1;> 如果不指定<xref:System.Diagnostics.EventLog.MachineName%2A>为你<xref:System.Diagnostics.EventLog>实例然后才能调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>或<xref:System.Diagnostics.EventLog.WriteEntry%2A>，本地计算机 (&quot;。&quot;) 假定。</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       如果系统需要<xref:System.Diagnostics.EventLog.Source%2A>通过调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>和<xref:System.Diagnostics.EventLog.Log%2A>未在你的<xref:System.Diagnostics.EventLog>情况下，日志将默认为在应用程序日志</xref:System.Diagnostics.EventLog>上设置属性</xref:System.Diagnostics.EventLog.Log%2A>的</xref:System.Diagnostics.EventLog.WriteEntry%2A></xref:System.Diagnostics.EventLog.Source%2A>注册      1> [!NOTE]&1;> 上面列出的许多异常由错误生成的注册<xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>过程中发生       要写入本地化的项还是要直接写入字符串，则必须配置源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法直接写入事件日志将写入给定的字符串; 它不使用可本地化的消息资源文件。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来写入事件时使用本地化的消息资源文件。</xref:System.Diagnostics.EventLog.WriteEvent%2A>       如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用该<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法使用在事件日志的资源标识符来编写条目</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的源 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>      1> [!NOTE]&1;> 到远程计算机中写入条目，如果消息 （文本字符串） 的值可能不是你所预期如果远程计算机未在运行.NET Framework。      1> [!NOTE]&1;> 如果`message`参数包含 NUL 字符，则在 NUL 字符处终止事件日志的消息中。"
  example:
  - "The following example writes a warning entry to an event log, \"MyNewLog\", on the local computer.  \n  \n [!code-cpp[Classic EventLog.WriteEntry2 Example#1](~/add/codesnippet/cpp/19aeba79-224e-4604-90d9-_1.cpp)]\n [!code-cs[Classic EventLog.WriteEntry2 Example#1](~/add/codesnippet/csharp/19aeba79-224e-4604-90d9-_1.cs)]\n [!code-vb[Classic EventLog.WriteEntry2 Example#1](~/add/codesnippet/visualbasic/19aeba79-224e-4604-90d9-_1.vb)]"
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);
    parameters:
    - id: message
      type: System.String
      description: "要写入事件日志的字符串。"
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "之一<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;></xref>值。"
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>不是有效<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "无法打开事件日志的注册表项。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "操作系统报告错误时向事件日志中写入事件项。 Windows 错误代码不可用。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String)
  id: WriteEntry(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String)
  nameWithType: EventLog.WriteEntry(String,String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "将信息类型项与给定的消息文本一起写入事件日志中，使用指定的注册的事件源。"
  remarks: "使用此方法要使用已注册为相应的日志的事件源的源的事件日志中写入信息项。 如果你想要指定任何其他<xref:System.Diagnostics.EventLogEntryType>，请使用<xref:System.Diagnostics.EventLog.WriteEntry%2A>.</xref:System.Diagnostics.EventLog.WriteEntry%2A>的不同重载</xref:System.Diagnostics.EventLogEntryType>       你必须创建并在编写与源的第一个条目之前，配置事件源。 在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 若要创建新的事件源的计算机上，必须具有管理权限。       要写入本地化的项还是要直接写入字符串，则必须配置源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法直接写入事件日志将写入给定的字符串; 它不使用可本地化的消息资源文件。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来写入事件时使用本地化的消息资源文件。</xref:System.Diagnostics.EventLog.WriteEvent%2A>       如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用该<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法使用在事件日志的资源标识符来编写条目</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的源 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>      1> [!NOTE]&1;> 如果`message`参数包含 NUL 字符，则在 NUL 字符处终止事件日志的消息中。   >>`message`字符串不能包含 %*n*，其中*n*是整数值 (例如，%1)，因为事件查看器会将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址只能包含此字符序列，因为无法记录事件消息包含 IPv6 地址。"
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cpp[Classic EventLog.WriteEntry1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_3_1.cpp)]\n [!code-cs[Classic EventLog.WriteEntry1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_3_1.cs)]\n [!code-vb[Classic EventLog.WriteEntry1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_3_1.vb)]"
  syntax:
    content: public static void WriteEntry (string source, string message);
    parameters:
    - id: source
      type: System.String
      description: "依据应用程序注册指定的计算机的源。"
    - id: message
      type: System.String
      description: "要写入事件日志的字符串。"
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "无法打开事件日志的注册表项。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "操作系统报告错误时向事件日志中写入事件项。 Windows 错误代码不可用。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "具有给定的消息文本和应用程序定义的事件标识符的项写入事件日志。"
  remarks: "使用此方法写入与应用程序定义条目`eventID`到事件日志。 `eventID`与源一起唯一地标识事件。 每个应用程序可以定义其自己的编号的事件以及它们映射到其中的描述字符串。 事件查看器显示这些字符串值，以帮助用户了解发生的问题和建议采取的操作。      1> [!NOTE]&1;>`message`字符串不能包含 %*n*，其中*n*是整数值 (例如，%1)，因为事件查看器会将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址只能包含此字符序列，因为无法记录事件消息包含 IPv6 地址。       除了事件标识符中，你可以指定<xref:System.Diagnostics.EventLogEntryType>事件写入事件日志。</xref:System.Diagnostics.EventLogEntryType> `type`指示由一个图标和事件查看器日志中的类型列中的文本。 此参数指示事件类型是否是错误、 警告、 信息、 成功审核或失败审核。       必须设置的<xref:System.Diagnostics.EventLog.Source%2A>属性在<xref:System.Diagnostics.EventLog>组件，才能使用你可以将条目写入日志。</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> 你必须创建并在编写与源的第一个条目之前，配置事件源。       在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 若要创建新的事件源的计算机上，必须具有管理权限。       如果在指定的源<xref:System.Diagnostics.EventLog.Source%2A>此属性<xref:System.Diagnostics.EventLog>写入你的组件，在计算机上未注册实例<xref:System.Diagnostics.EventLog.WriteEntry%2A>调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>并注册该源。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      1> [!NOTE]&1;> 如果不指定<xref:System.Diagnostics.EventLog.MachineName%2A>为你<xref:System.Diagnostics.EventLog>实例然后才能调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>或<xref:System.Diagnostics.EventLog.WriteEntry%2A>，本地计算机 (&quot;。&quot;) 假定。</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       如果系统需要<xref:System.Diagnostics.EventLog.Source%2A>通过调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>和<xref:System.Diagnostics.EventLog.Log%2A>未在你的<xref:System.Diagnostics.EventLog>情况下，日志将默认为在应用程序日志</xref:System.Diagnostics.EventLog>上设置属性</xref:System.Diagnostics.EventLog.Log%2A>的</xref:System.Diagnostics.EventLog.WriteEntry%2A></xref:System.Diagnostics.EventLog.Source%2A>注册      1> [!NOTE]&1;> 上面列出的许多异常由错误生成的注册<xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>过程中发生       要写入本地化的项还是要直接写入字符串，则必须配置源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法直接写入事件日志将写入给定的字符串; 它不使用可本地化的消息资源文件。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来写入事件时使用本地化的消息资源文件。</xref:System.Diagnostics.EventLog.WriteEvent%2A>       如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用该<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法使用在事件日志的资源标识符来编写条目</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的源 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>      1> [!NOTE]&1;> 到远程计算机中写入条目，如果消息 （文本字符串） 的值可能不是你所预期如果远程计算机未在运行.NET Framework。      1> [!NOTE]&1;> 如果`message`参数包含 NUL 字符，则在 NUL 字符处终止事件日志的消息中。"
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#3](~/add/codesnippet/cpp/597042ed-6d84-4ccf-a867-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#3](~/add/codesnippet/csharp/597042ed-6d84-4ccf-a867-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#3](~/add/codesnippet/visualbasic/597042ed-6d84-4ccf-a867-_1.vb)]
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);
    parameters:
    - id: message
      type: System.String
      description: "要写入事件日志的字符串。"
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "之一<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;></xref>值。"
    - id: eventID
      type: System.Int32
      description: "事件的应用程序特定标识符。"
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "无法打开事件日志的注册表项。"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>不是有效<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "操作系统报告错误时向事件日志中写入事件项。 Windows 错误代码不可用。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "错误、 警告、 信息、 成功审核或失败审核项与给定的消息文本一起写入事件日志中，使用指定的注册的事件源。"
  remarks: "使用此方法写入<xref:System.Diagnostics.EventLogEntryType>到事件日志中，已注册为相应的日志事件源将源使用</xref:System.Diagnostics.EventLogEntryType>指定的条目 `type`指示由一个图标和事件查看器日志中的类型列中的文本。      1> [!NOTE]&1;>`message`字符串不能包含 %*n*，其中*n*是整数值 (例如，%1)，因为事件查看器会将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址只能包含此字符序列，因为无法记录事件消息包含 IPv6 地址。       你必须创建并在编写与源的第一个条目之前，配置事件源。 在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 若要创建新的事件源的计算机上，必须具有管理权限。       要写入本地化的项还是要直接写入字符串，则必须配置源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法直接写入事件日志将写入给定的字符串; 它不使用可本地化的消息资源文件。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来写入事件时使用本地化的消息资源文件。</xref:System.Diagnostics.EventLog.WriteEvent%2A>       如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用该<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法使用在事件日志的资源标识符来编写条目</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的源 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>      1> [!NOTE]&1;> 如果`message`参数包含 NUL 字符，则在 NUL 字符处终止事件日志的消息中。"
  example:
  - "The following example writes a warning entry to an event log, \"MyNewLog\", on the local computer.  \n  \n [!code-cs[Classic EventLog.WriteEntry3 Example#1](~/add/codesnippet/csharp/c03f903c-8fbd-441f-afe0-_1.cs)]\n [!code-vb[Classic EventLog.WriteEntry3 Example#1](~/add/codesnippet/visualbasic/c03f903c-8fbd-441f-afe0-_1.vb)]\n [!code-cpp[Classic EventLog.WriteEntry3 Example#1](~/add/codesnippet/cpp/c03f903c-8fbd-441f-afe0-_1.cpp)]"
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);
    parameters:
    - id: source
      type: System.String
      description: "依据应用程序注册指定的计算机的源。"
    - id: message
      type: System.String
      description: "要写入事件日志的字符串。"
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "之一<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;></xref>值。"
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "无法打开事件日志的注册表项。"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>不是有效<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "操作系统报告错误时向事件日志中写入事件项。 Windows 错误代码不可用。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "具有给定的消息文本、 应用程序定义的事件标识符和应用程序定义的类别的项写入事件日志。"
  remarks: "使用此方法写入与应用程序定义条目`category`到事件日志。 事件查看器将使用到按事件源写入筛选器事件类别。 事件查看器可将类别显示为数字值，或者它可以作为资源标识符使用类别，以显示本地化的类别字符串。      1> [!NOTE]&1;>`category`参数应是正数值。 负类别值显示为正补数在事件查看器。 例如，– 10 显示为 65526，为 65535 为-1。      1> [!NOTE]&1;>`message`字符串不能包含 %*n*，其中*n*是整数值 (例如，%1)，因为事件查看器会将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址只能包含此字符序列，因为无法记录事件消息包含 IPv6 地址。       若要在事件查看器中显示本地化的类别字符串，必须使用事件源使用类别资源文件，配置和设置`category`类别资源文件中的资源标识符。 如果事件源没有配置的类别资源文件，或指定`category`没有索引在类别资源文件中，一个字符串，则事件查看器将显示该条目的数字类别值。 配置类别资源文件，以及数量的类别字符串在资源文件中，使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventSourceCreationData>类。</xref:System.Diagnostics.EventSourceCreationData> </xref:System.Diagnostics.EventLogInstaller>       除了类别，你可以指定要写入事件日志事件的事件标识符。 事件标识符以及事件源，唯一标识的事件。 每个应用程序可以定义其自己的编号的事件以及它们映射到其中的描述字符串。 事件查看器显示这些字符串值，以帮助用户了解发生的问题和建议采取的操作。       最后，你可以指定<xref:System.Diagnostics.EventLogEntryType>事件写入事件日志。</xref:System.Diagnostics.EventLogEntryType> `type`指示由一个图标和事件查看器日志中的类型列中的文本。 此参数指示事件类型是否是错误、 警告、 信息、 成功审核或失败审核。       必须设置的<xref:System.Diagnostics.EventLog.Source%2A>属性在<xref:System.Diagnostics.EventLog>组件，才能使用你可以将条目写入日志。</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> 你必须创建并在编写与源的第一个条目之前，配置事件源。       在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 若要创建新的事件源的计算机上，必须具有管理权限。       如果在指定的源<xref:System.Diagnostics.EventLog.Source%2A>此属性<xref:System.Diagnostics.EventLog>写入你的组件，在计算机上未注册实例<xref:System.Diagnostics.EventLog.WriteEntry%2A>调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>并注册该源。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      1> [!NOTE]&1;> 如果不指定<xref:System.Diagnostics.EventLog.MachineName%2A>为你<xref:System.Diagnostics.EventLog>实例然后才能调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>或<xref:System.Diagnostics.EventLog.WriteEntry%2A>，本地计算机 (&quot;。&quot;) 假定。</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       如果系统需要<xref:System.Diagnostics.EventLog.Source%2A>通过调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>和<xref:System.Diagnostics.EventLog.Log%2A>未在你的<xref:System.Diagnostics.EventLog>情况下，日志将默认为在应用程序日志</xref:System.Diagnostics.EventLog>上设置属性</xref:System.Diagnostics.EventLog.Log%2A>的</xref:System.Diagnostics.EventLog.WriteEntry%2A></xref:System.Diagnostics.EventLog.Source%2A>注册      1> [!NOTE]&1;> 上面列出的许多异常由错误生成的注册<xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>过程中发生       要写入本地化的项还是要直接写入字符串，则必须配置源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法直接写入事件日志将写入给定的字符串; 它不使用可本地化的消息资源文件。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来写入事件时使用本地化的消息资源文件。</xref:System.Diagnostics.EventLog.WriteEvent%2A>       如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用该<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法使用在事件日志的资源标识符来编写条目</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的源 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>      1> [!NOTE]&1;> 到远程计算机中写入条目，如果消息 （文本字符串） 的值可能不是你所预期如果远程计算机未在运行.NET Framework。      1> [!NOTE]&1;> 如果`message`参数包含 NUL 字符，则在 NUL 字符处终止事件日志的消息中。"
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#3](~/add/codesnippet/cpp/b3db94bc-a96c-4168-a8f0-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#3](~/add/codesnippet/csharp/b3db94bc-a96c-4168-a8f0-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#3](~/add/codesnippet/visualbasic/b3db94bc-a96c-4168-a8f0-_1.vb)]
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);
    parameters:
    - id: message
      type: System.String
      description: "要写入事件日志的字符串。"
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "之一<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;></xref>值。"
    - id: eventID
      type: System.Int32
      description: "事件的应用程序特定标识符。"
    - id: category
      type: System.Int16
      description: "与消息关联的应用程序特定子类别。"
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "无法打开事件日志的注册表项。"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>不是有效<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "操作系统报告错误时向事件日志中写入事件项。 Windows 错误代码不可用。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "具有给定的消息文本和应用程序定义的事件标识符的项写入事件日志中，使用指定的注册的事件源。"
  remarks: "使用此方法写入与应用程序定义条目`eventID`到事件日志中，将源使用已注册为相应的日志的事件源。 `eventID`，以及源，唯一标识事件。 每个应用程序可以定义其自己的编号的事件以及它们映射到其中的描述字符串。 事件查看器将这些字符串向用户以帮助用户了解发生的问题并建议采取的操作。      1> [!NOTE]&1;>`message`字符串不能包含 %*n*，其中*n*是整数值 (例如，%1)，因为事件查看器会将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址只能包含此字符序列，因为无法记录事件消息包含 IPv6 地址。       除了事件标识符，此重载<xref:System.Diagnostics.EventLog.WriteEntry%2A>允许你指定<xref:System.Diagnostics.EventLogEntryType>事件写入事件日志。</xref:System.Diagnostics.EventLogEntryType> </xref:System.Diagnostics.EventLog.WriteEntry%2A> `type`指示由一个图标和事件查看器日志中的类型列中的文本。 此参数指示事件类型是否是错误、 警告、 信息、 成功审核或失败审核。       你必须创建并在编写与源的第一个条目之前，配置事件源。 在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 若要创建新的事件源的计算机上，必须具有管理权限。       要写入本地化的项还是要直接写入字符串，则必须配置源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法直接写入事件日志将写入给定的字符串; 它不使用可本地化的消息资源文件。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来写入事件时使用本地化的消息资源文件。</xref:System.Diagnostics.EventLog.WriteEvent%2A>       如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用该<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法使用在事件日志的资源标识符来编写条目</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的源 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>      1> [!NOTE]&1;> 如果`message`参数包含 NUL 字符，则在 NUL 字符处终止事件日志的消息中。"
  example:
  - >-
    [!code-cs[EventLog_WriteEntry_4#1](~/add/codesnippet/csharp/2d8498b8-a54d-48c9-9ee7-_1.cs)]
     [!code-cpp[EventLog_WriteEntry_4#1](~/add/codesnippet/cpp/2d8498b8-a54d-48c9-9ee7-_1.cpp)]
     [!code-vb[EventLog_WriteEntry_4#1](~/add/codesnippet/visualbasic/2d8498b8-a54d-48c9-9ee7-_1.vb)]
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);
    parameters:
    - id: source
      type: System.String
      description: "依据应用程序注册指定的计算机的源。"
    - id: message
      type: System.String
      description: "要写入事件日志的字符串。"
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "之一<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;></xref>值。"
    - id: eventID
      type: System.Int32
      description: "事件的应用程序特定标识符。"
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "无法打开事件日志的注册表项。"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>不是有效<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "操作系统报告错误时向事件日志中写入事件项。 Windows 错误代码不可用。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "具有给定的消息文本、 应用程序定义的事件标识符和应用程序定义的类别的项写入事件日志，并向消息追加二进制数据。"
  remarks: "使用此重载将应用程序定义特定于事件的数据写入事件日志。 事件查看器不解释该数据。它仅在组合的十六进制转义序列和文本格式显示原始数据。 特定于事件的数据应谨慎使用，包括它仅当你确信它将会对某人调试问题很有用。 特定于事件的数据还可用于存储应用程序可以处理独立于事件查看器的信息。 例如，你无法专门为事件，编写一个查看器或编写扫描日志文件，并创建报告，包括来自特定事件的数据的信息的程序。       除了二进制数据，还可以指定应用程序定义的类别和应用程序定义的事件标识符。 事件查看器将使用到按事件源写入筛选器事件类别。 事件查看器可将类别显示为数字值，或者它可以作为资源标识符使用类别，以显示本地化的类别字符串。      1> [!NOTE]&1;>`message`字符串不能包含 %*n*，其中*n*是整数值 (例如，%1)，因为事件查看器会将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址只能包含此字符序列，因为无法记录事件消息包含 IPv6 地址。      1> [!NOTE]&1;>`category`参数应是正数值。 负类别值显示为正补数在事件查看器。 例如，– 10 显示为 65526，为 65535 为-1。       若要在事件查看器中显示本地化的类别字符串，必须使用事件源使用类别资源文件，配置和设置`category`类别资源文件中的资源标识符。 如果事件源没有配置的类别资源文件，或指定`category`没有索引在类别资源文件中，一个字符串，则事件查看器将显示该条目的数字类别值。 配置类别资源文件，以及数量的类别字符串在资源文件中，使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventSourceCreationData>类。</xref:System.Diagnostics.EventSourceCreationData> </xref:System.Diagnostics.EventLogInstaller>       事件标识符以及事件源，唯一标识的事件。 每个应用程序可以定义其自己的编号的事件以及它们映射到其中的描述字符串。 事件查看器显示这些字符串值，以帮助用户了解发生的问题和建议采取的操作。       最后，你可以指定<xref:System.Diagnostics.EventLogEntryType>事件写入事件日志。</xref:System.Diagnostics.EventLogEntryType> `type`指示由一个图标和事件查看器日志中的类型列中的文本。 此参数指示事件类型是否是错误、 警告、 信息、 成功审核或失败审核。       必须设置的<xref:System.Diagnostics.EventLog.Source%2A>属性在<xref:System.Diagnostics.EventLog>组件，才能使用你可以将条目写入日志。</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> 你必须创建并在编写与源的第一个条目之前，配置事件源。       在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 若要创建新的事件源的计算机上，必须具有管理权限。       如果在指定的源<xref:System.Diagnostics.EventLog.Source%2A>此属性<xref:System.Diagnostics.EventLog>写入你的组件，在计算机上未注册实例<xref:System.Diagnostics.EventLog.WriteEntry%2A>调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>并注册该源。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      1> [!NOTE]&1;> 如果不指定<xref:System.Diagnostics.EventLog.MachineName%2A>为你<xref:System.Diagnostics.EventLog>实例然后才能调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>或<xref:System.Diagnostics.EventLog.WriteEntry%2A>，本地计算机 (&quot;。&quot;) 假定。</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       如果系统需要<xref:System.Diagnostics.EventLog.Source%2A>通过调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>和<xref:System.Diagnostics.EventLog.Log%2A>未在你的<xref:System.Diagnostics.EventLog>情况下，日志将默认为在应用程序日志</xref:System.Diagnostics.EventLog>上设置属性</xref:System.Diagnostics.EventLog.Log%2A>的</xref:System.Diagnostics.EventLog.WriteEntry%2A></xref:System.Diagnostics.EventLog.Source%2A>注册      1> [!NOTE]&1;> 上面列出的许多异常由错误生成的注册<xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>过程中发生       要写入本地化的项还是要直接写入字符串，则必须配置源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法直接写入事件日志将写入给定的字符串; 它不使用可本地化的消息资源文件。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来写入事件时使用本地化的消息资源文件。</xref:System.Diagnostics.EventLog.WriteEvent%2A>       如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用该<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法使用在事件日志的资源标识符来编写条目</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的源 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>      1> [!NOTE]&1;> 到远程计算机中写入条目，如果消息 （文本字符串） 的值可能不是你所预期如果远程计算机未在运行.NET Framework。      1> [!NOTE]&1;> 如果`message`参数包含 NUL 字符，则在 NUL 字符处终止事件日志的消息中。"
  example:
  - >-
    [!code-cs[EventLog_WriteEntry_5#1](~/add/codesnippet/csharp/1c6518b6-dc55-4c74-9028-_1.cs)]
     [!code-vb[EventLog_WriteEntry_5#1](~/add/codesnippet/visualbasic/1c6518b6-dc55-4c74-9028-_1.vb)]
     [!code-cpp[EventLog_WriteEntry_5#1](~/add/codesnippet/cpp/1c6518b6-dc55-4c74-9028-_1.cpp)]
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);
    parameters:
    - id: message
      type: System.String
      description: "要写入事件日志的字符串。"
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "之一<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;></xref>值。"
    - id: eventID
      type: System.Int32
      description: "事件的应用程序特定标识符。"
    - id: category
      type: System.Int16
      description: "与消息关联的应用程序特定子类别。"
    - id: rawData
      type: System.Byte[]
      description: "包含与此项关联的二进制数据的字节数组。"
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "无法打开事件日志的注册表项。"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>不是有效<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "操作系统报告错误时向事件日志中写入事件项。 Windows 错误代码不可用。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "具有给定的消息文本、 应用程序定义的事件标识符和应用程序定义的类别的项写入事件日志中，使用指定的注册的事件源。 <code> category </code>可由事件查看器日志中筛选事件。"
  remarks: "使用此方法写入与应用程序定义条目`category`到事件日志中，使用已注册为相应的日志的事件源的源。 事件查看器将使用到按事件源写入筛选器事件类别。 事件查看器可将类别显示为数字值，或者它可以作为资源标识符使用类别，以显示本地化的类别字符串。      1> [!NOTE]&1;>`category`参数应是正数值。 负类别值显示为正补数在事件查看器。 例如，– 10 显示为 65526，为 65535 为-1。       若要在事件查看器中显示本地化的类别字符串，必须使用事件源使用类别资源文件，配置和设置`category`类别资源文件中的资源标识符。 如果事件源没有配置的类别资源文件，或指定`category`没有索引在类别资源文件中，一个字符串，则事件查看器将显示该条目的数字类别值。 配置类别资源文件，以及数量的类别字符串在资源文件中，使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventSourceCreationData>类。</xref:System.Diagnostics.EventSourceCreationData> </xref:System.Diagnostics.EventLogInstaller>       除了类别，你可以指定要写入事件日志事件的事件标识符。 事件标识符以及事件源，唯一标识的事件。 每个应用程序可以定义其自己的编号的事件以及它们映射到其中的描述字符串。 事件查看器显示这些字符串值，以帮助用户了解发生的问题和建议采取的操作。       最后，你可以指定<xref:System.Diagnostics.EventLogEntryType>事件写入事件日志。</xref:System.Diagnostics.EventLogEntryType> `type`指示由一个图标和事件查看器日志中的类型列中的文本。 此参数指示事件类型是否是错误、 警告、 信息、 成功审核或失败审核。       你必须创建并在编写与源的第一个条目之前，配置事件源。 在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 若要创建新的事件源的计算机上，必须具有管理权限。       要写入本地化的项还是要直接写入字符串，则必须配置源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法直接写入事件日志将写入给定的字符串; 它不使用可本地化的消息资源文件。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来写入事件时使用本地化的消息资源文件。</xref:System.Diagnostics.EventLog.WriteEvent%2A>       如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用该<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法使用在事件日志的资源标识符来编写条目</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的源 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>      1> [!NOTE]&1;> 如果`message`参数包含 NUL 字符，则在 NUL 字符处终止事件日志的消息中。   >>`message`字符串不能包含 %*n*，其中*n*是整数值 (例如，%1)，因为事件查看器会将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址只能包含此字符序列，因为无法记录事件消息包含 IPv6 地址。"
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#1](~/add/codesnippet/cpp/189fd615-c100-4e72-9c0b-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#1](~/add/codesnippet/csharp/189fd615-c100-4e72-9c0b-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#1](~/add/codesnippet/visualbasic/189fd615-c100-4e72-9c0b-_1.vb)]
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);
    parameters:
    - id: source
      type: System.String
      description: "依据应用程序注册指定的计算机的源。"
    - id: message
      type: System.String
      description: "要写入事件日志的字符串。"
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "之一<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;></xref>值。"
    - id: eventID
      type: System.Int32
      description: "事件的应用程序特定标识符。"
    - id: category
      type: System.Int16
      description: "与消息关联的应用程序特定子类别。"
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "无法打开事件日志的注册表项。"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>不是有效<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "操作系统报告错误时向事件日志中写入事件项。 Windows 错误代码不可用。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "具有给定的消息文本、 应用程序定义的事件标识符和应用程序定义的类别的项写入事件日志 （使用指定的注册的事件源），并向消息追加二进制数据。"
  remarks: "使用此方法将应用程序定义特定于事件的数据写入事件日志中，使用已注册为相应的日志的事件源的源。 事件查看器不解释该数据。它仅在组合的十六进制转义序列和文本格式显示原始数据。 应谨慎; 使用特定于事件的数据仅当你确信它将会很有用，则将其包含。 特定于事件的数据还可用于存储应用程序可以处理独立于事件查看器的信息。 例如，你无法专门为事件，编写一个查看器或编写扫描日志文件，并创建报告，包括来自特定事件的数据的信息的程序。       除了二进制数据，还可以指定应用程序定义的类别和应用程序定义的事件标识符。 事件查看器将使用到按事件源写入筛选器事件类别。 事件查看器可将类别显示为数字值，或者它可以作为资源标识符使用类别，以显示本地化的类别字符串。      1> [!NOTE]&1;>`category`参数应是正数值。 负类别值显示为正补数在事件查看器。 例如，– 10 将显示为 65526，为 65535 为-1。       若要在事件查看器中显示本地化的类别字符串，必须使用事件源使用类别资源文件，配置和设置`category`类别资源文件中的资源标识符。 如果事件源没有配置的类别资源文件，或指定`category`没有索引在类别资源文件中，一个字符串，则事件查看器将显示该条目的数字类别值。 配置类别资源文件，以及数量的类别字符串在资源文件中，使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventSourceCreationData>类。</xref:System.Diagnostics.EventSourceCreationData> </xref:System.Diagnostics.EventLogInstaller>       事件标识符，以及事件源，唯一标识的事件。 每个应用程序可以定义其自己的编号的事件以及它们映射到其中的描述字符串。 事件查看器显示这些字符串值，以帮助用户了解发生的问题和建议采取的操作。       最后，你可以指定<xref:System.Diagnostics.EventLogEntryType>事件写入事件日志。</xref:System.Diagnostics.EventLogEntryType> `type`指示由一个图标和事件查看器日志中的类型列中的文本。 此参数指示事件类型是否是错误、 警告、 信息、 成功审核或失败审核。       你必须创建并在编写与源的第一个条目之前，配置事件源。 在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 若要创建新的事件源的计算机上，必须具有管理权限。       要写入本地化的项还是要直接写入字符串，则必须配置源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法直接写入事件日志将写入给定的字符串; 它不使用可本地化的消息资源文件。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来写入事件时使用本地化的消息资源文件。</xref:System.Diagnostics.EventLog.WriteEvent%2A>       如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用该<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法使用在事件日志的资源标识符来编写条目</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的源 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>      1> [!NOTE]&1;> 如果`message`参数包含 NUL 字符，则在 NUL 字符处终止事件日志的消息中。   >>`message`字符串不能包含 %*n*，其中*n*是整数值 (例如，%1)，因为事件查看器会将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址只能包含此字符序列，因为无法记录事件消息包含 IPv6 地址。"
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#2](~/add/codesnippet/cpp/0b90a83a-dcc8-46e6-a8db-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#2](~/add/codesnippet/csharp/0b90a83a-dcc8-46e6-a8db-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#2](~/add/codesnippet/visualbasic/0b90a83a-dcc8-46e6-a8db-_1.vb)]
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);
    parameters:
    - id: source
      type: System.String
      description: "依据应用程序注册指定的计算机的源。"
    - id: message
      type: System.String
      description: "要写入事件日志的字符串。"
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "之一<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;></xref>值。"
    - id: eventID
      type: System.Int32
      description: "事件的应用程序特定标识符。"
    - id: category
      type: System.Int16
      description: "与消息关联的应用程序特定子类别。"
    - id: rawData
      type: System.Byte[]
      description: "包含与此项关联的二进制数据的字节数组。"
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>不是有效<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "无法打开事件日志的注册表项。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "操作系统报告错误时向事件日志中写入事件项。 Windows 错误代码不可用。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  id: WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "向事件日志写入本地化的项。"
  remarks: "使用此方法写入事件日志写入本地化的项。 使用资源标识符，而不是字符串值中指定的事件属性。 事件查看器使用的资源标识符来显示<xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>的本地化的资源文件中的相应字符串 需要在编写使用资源标识符的事件前，必须将源注册相应的资源文件。       输入`instance`实例指定的事件消息和属性。 设置<xref:System.Diagnostics.EventInstance.InstanceId%2A>的`instance`源消息资源文件中定义的消息的输入。</xref:System.Diagnostics.EventInstance.InstanceId%2A> 你可以选择性地设置<xref:System.Diagnostics.EventInstance.CategoryId%2A>和<xref:System.Diagnostics.EventInstance.EntryType%2A>的`instance`输入事件项的类别和事件类型定义。</xref:System.Diagnostics.EventInstance.EntryType%2A> </xref:System.Diagnostics.EventInstance.CategoryId%2A> 你还可以指定要插入本地化的消息文本的独立于语言的字符串的数组。 设置`values`到`null`如果事件消息不包含替换字符串的格式设置占位符。       必须设置<xref:System.Diagnostics.EventLog.Source%2A>在<xref:System.Diagnostics.EventLog>之前使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>.</xref:System.Diagnostics.EventLog.WriteEvent%2A>组件</xref:System.Diagnostics.EventLog>的属性</xref:System.Diagnostics.EventLog.Source%2A> 指定的源必须配置用于本地化的项写入事件日志中。源至少必须具有一个用于定义消息资源文件。       你必须创建并在编写与源的第一个条目之前，配置事件源。 在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 若要创建新的事件源的计算机上，必须具有管理权限。       要写入本地化的项还是要直接写入字符串，则必须配置源。 使用<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法如果你的应用程序写入字符串值直接向事件日志。</xref:System.Diagnostics.EventLog.WriteEntry%2A>       如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用该<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法使用在事件日志的资源标识符来编写条目</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的源 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>      1> [!NOTE]&1;> 到远程计算机的值如果写入条目`message`字符串可能不是你所预期如果远程计算机未在运行.NET Framework。 此外，`message`字符串不能包含 %*n*，其中*n*是整数值 (例如，%1)，因为事件查看器会将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址只能包含此字符序列，因为无法记录事件消息包含 IPv6 地址。"
  example:
  - "The following example writes two audit entries to the event log `myNewLog`. The example creates a new event source and a new event log if they do not exist on the local computer. The event message text is specified using a resource identifier in a resource file.  \n  \n [!code-cpp[EventLog_WriteEvent#7](~/add/codesnippet/cpp/6a714dbf-bcbc-4f5a-a8b4-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#7](~/add/codesnippet/visualbasic/6a714dbf-bcbc-4f5a-a8b4-_1.vb)]\n [!code-cs[EventLog_WriteEvent#7](~/add/codesnippet/csharp/6a714dbf-bcbc-4f5a-a8b4-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public void WriteEvent (System.Diagnostics.EventInstance instance, object[] values);
    parameters:
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "<xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref>表示本地化的事件日志项的实例。"
    - id: values
      type: System.Object[]
      description: "要合并到事件日志条目的消息文本的字符串数组。"
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "无法打开事件日志的注册表项。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "操作系统报告错误时向事件日志中写入事件项。 Windows 错误代码不可用。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  id: WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Byte[],Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "将一个具有给定的事件数据、 消息替换字符串和关联的二进制数据的事件日志项。"
  remarks: "使用此方法要使用其他特定于事件的数据的本地化的项写入事件日志。 使用资源标识符，而不是字符串值中指定的事件属性。 事件查看器使用的资源标识符来显示<xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>的本地化的资源文件中的相应字符串 需要在编写使用资源标识符的事件前，必须将源注册相应的资源文件。       输入`instance`实例指定的事件消息和属性。 设置<xref:System.Diagnostics.EventInstance.InstanceId%2A>的`instance`源消息资源文件中定义的消息的输入。</xref:System.Diagnostics.EventInstance.InstanceId%2A> 你可以选择性地设置<xref:System.Diagnostics.EventInstance.CategoryId%2A>和<xref:System.Diagnostics.EventInstance.EntryType%2A>的`instance`输入事件项的类别和事件类型定义。</xref:System.Diagnostics.EventInstance.EntryType%2A> </xref:System.Diagnostics.EventInstance.CategoryId%2A> 你还可以指定要插入本地化的消息文本的独立于语言的字符串的数组。 设置`values`到`null`如果事件消息不包含替换字符串的格式设置占位符。       指定与事件时为事件提供更多详细信息所需的二进制数据。 例如，使用`data`参数，以包括有关特定错误的信息。 事件查看器不解释关联的事件数据中;它采用组合的十六进制转义序列和文本格式显示的数据。 应谨慎; 使用特定于事件的数据仅当你确信它将会很有用，则将其包含。 特定于事件的数据还可用于存储应用程序可以处理独立于事件查看器的信息。 例如，你无法专门为事件，编写一个查看器或编写扫描事件日志，并创建报告，包括来自特定事件的数据的信息的程序。       必须设置<xref:System.Diagnostics.EventLog.Source%2A>在<xref:System.Diagnostics.EventLog>之前使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>.</xref:System.Diagnostics.EventLog.WriteEvent%2A>组件之前组件</xref:System.Diagnostics.EventLog>的属性</xref:System.Diagnostics.EventLog.Source%2A> 指定的源必须配置用于本地化的项写入事件日志中。源至少必须具有一个用于定义消息资源文件。       你必须创建并在编写与源的第一个条目之前，配置事件源。 在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 若要创建新的事件源的计算机上，必须具有管理权限。      1> [!NOTE]&1;> 如果不指定<xref:System.Diagnostics.EventLog.MachineName%2A>为你<xref:System.Diagnostics.EventLog>实例然后才能调用<xref:System.Diagnostics.EventLog.WriteEvent%2A>，本地计算机 (&quot;。&quot;) 假定。</xref:System.Diagnostics.EventLog.WriteEvent%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       要写入本地化的项还是要直接写入字符串，则必须配置源。 使用<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法如果你的应用程序写入字符串值直接向事件日志。</xref:System.Diagnostics.EventLog.WriteEntry%2A>       如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用该<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法使用在事件日志的资源标识符来编写条目</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的源 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>      1> [!NOTE]&1;> 到远程计算机的值如果写入条目`message`字符串可能不是你所预期如果远程计算机未在运行.NET Framework。 此外，`message`字符串不能包含 %*n*，其中*n*是整数值 (例如，%1)，因为事件查看器会将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址只能包含此字符序列，因为无法记录事件消息包含 IPv6 地址。"
  example:
  - "The following example writes two audit entries to the event log `myNewLog`. The example creates a new event source and a new event log if they do not exist on the local computer. The event message text is specified using a resource identifier in a resource file.  \n  \n [!code-cpp[EventLog_WriteEvent#7](~/add/codesnippet/cpp/9c997f17-0108-4c5c-b894-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#7](~/add/codesnippet/visualbasic/9c997f17-0108-4c5c-b894-_1.vb)]\n [!code-cs[EventLog_WriteEvent#7](~/add/codesnippet/csharp/9c997f17-0108-4c5c-b894-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, object[] values);
    parameters:
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "<xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref>表示本地化的事件日志项的实例。"
    - id: data
      type: System.Byte[]
      description: "包含与此项关联的二进制数据的字节数组。"
    - id: values
      type: System.Object[]
      description: "要合并到事件日志条目的消息文本的字符串数组。"
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "无法打开事件日志的注册表项。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "操作系统报告错误时向事件日志中写入事件项。 Windows 错误代码不可用。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  id: WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(String,EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "写入包含给定事件的事件日志项数据和消息替换字符串，使用指定的注册的事件源。"
  remarks: "使用此方法使用已注册为相应的日志的事件源的源的事件日志写入本地化的项。 使用资源标识符，而不是字符串值中指定的事件属性。 事件查看器使用的资源标识符来显示源的本地化的资源文件中的相应字符串。 需要在编写使用资源标识符的事件前，必须将源注册相应的资源文件。       输入`instance`实例指定的事件消息和属性。 设置<xref:System.Diagnostics.EventInstance.InstanceId%2A>的`instance`源消息资源文件中定义的消息的输入。</xref:System.Diagnostics.EventInstance.InstanceId%2A> 你可以选择性地设置<xref:System.Diagnostics.EventInstance.CategoryId%2A>和<xref:System.Diagnostics.EventInstance.EntryType%2A>的`instance`输入事件项的类别和事件类型定义。</xref:System.Diagnostics.EventInstance.EntryType%2A> </xref:System.Diagnostics.EventInstance.CategoryId%2A> 你还可以指定要插入本地化的消息文本的独立于语言的字符串的数组。 设置`values`到`null`如果事件消息不包含替换字符串的格式设置占位符。       指定的源必须使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>.</xref:System.Diagnostics.EventLog.WriteEvent%2A>之前注册为事件日志 指定的源必须配置用于本地化的项写入事件日志中。源至少必须具有一个用于定义消息资源文件。       你必须创建并在编写与源的第一个条目之前，配置事件源。 在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 若要创建新的事件源的计算机上，必须具有管理权限。       要写入本地化的项还是要直接写入字符串，则必须配置源。 使用<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法如果你的应用程序写入字符串值直接向事件日志。</xref:System.Diagnostics.EventLog.WriteEntry%2A>       如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用该<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法使用在事件日志的资源标识符来编写条目</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的源 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>"
  example:
  - "The following example writes an informational event entry and a warning event entry to an existing event log. The event message text is specified using a resource identifier in a resource file. The example assumes the corresponding resource file has been registered for the source.  \n  \n [!code-cpp[EventLog_WriteEvent#8](~/add/codesnippet/cpp/a57d89b3-94d2-4b9a-803c-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#8](~/add/codesnippet/visualbasic/a57d89b3-94d2-4b9a-803c-_1.vb)]\n [!code-cs[EventLog_WriteEvent#8](~/add/codesnippet/csharp/a57d89b3-94d2-4b9a-803c-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, object[] values);
    parameters:
    - id: source
      type: System.String
      description: "指定的计算机上的应用程序注册事件源的名称。"
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "<xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref>表示本地化的事件日志项的实例。"
    - id: values
      type: System.Object[]
      description: "要合并到事件日志条目的消息文本的字符串数组。"
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "无法打开事件日志的注册表项。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "操作系统报告错误时向事件日志中写入事件项。 Windows 错误代码不可用。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  id: WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(String,EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "写入事件日志条目与给定的事件数据，消息替换字符串和关联的二进制数据，并使用指定已注册事件源。"
  remarks: "使用此方法更多特定于事件的数据的本地化的项写入事件日志中，使用已注册为相应的日志的事件源的源。 使用资源标识符，而不是字符串值中指定的事件属性。 事件查看器使用的资源标识符来显示源的本地化的资源文件中的相应字符串。 需要在编写使用资源标识符的事件前，必须将源注册相应的资源文件。       输入`instance`实例指定的事件消息和属性。 设置<xref:System.Diagnostics.EventInstance.InstanceId%2A>的`instance`源消息资源文件中定义的消息的输入。</xref:System.Diagnostics.EventInstance.InstanceId%2A> 你可以选择性地设置<xref:System.Diagnostics.EventInstance.CategoryId%2A>和<xref:System.Diagnostics.EventInstance.EntryType%2A>的`instance`输入事件项的类别和事件类型定义。</xref:System.Diagnostics.EventInstance.EntryType%2A> </xref:System.Diagnostics.EventInstance.CategoryId%2A> 你还可以指定要插入本地化的消息文本的独立于语言的字符串的数组。 设置`values`到`null`如果事件消息不包含替换字符串的格式设置占位符。       指定与事件时为事件提供更多详细信息所需的二进制数据。 例如，使用`data`参数，以包括有关特定错误的信息。 事件查看器不解释关联的事件数据中;它采用组合的十六进制转义序列和文本格式显示的数据。 应谨慎; 使用特定于事件的数据仅当你确信它将会很有用，则将其包含。 特定于事件的数据还可用于存储应用程序可以处理独立于事件查看器的信息。 例如，你无法专门为事件，编写一个查看器或编写扫描事件日志，并创建报告，包括来自特定事件的数据的信息的程序。       指定的源必须使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>.</xref:System.Diagnostics.EventLog.WriteEvent%2A>之前注册为事件日志 指定的源必须配置用于本地化的项写入事件日志中。源至少必须具有一个用于定义消息资源文件。       你必须创建并在编写与源的第一个条目之前，配置事件源。 在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 若要创建新的事件源的计算机上，必须具有管理权限。       要写入本地化的项还是要直接写入字符串，则必须配置源。 使用<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法如果你的应用程序写入字符串值直接向事件日志。</xref:System.Diagnostics.EventLog.WriteEntry%2A>       如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用该<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法使用在事件日志的资源标识符来编写条目</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的源 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>"
  example:
  - "The following example writes an informational event entry and a warning event entry to an existing event log. The event message text is specified using a resource identifier in a resource file. The example assumes the corresponding resource file has been registered for the source.  \n  \n [!code-cpp[EventLog_WriteEvent#8](~/add/codesnippet/cpp/d4971002-e0d1-493b-96f8-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#8](~/add/codesnippet/visualbasic/d4971002-e0d1-493b-96f8-_1.vb)]\n [!code-cs[EventLog_WriteEvent#8](~/add/codesnippet/csharp/d4971002-e0d1-493b-96f8-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, object[] values);
    parameters:
    - id: source
      type: System.String
      description: "指定的计算机上的应用程序注册事件源的名称。"
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "<xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref>表示本地化的事件日志项的实例。"
    - id: data
      type: System.Byte[]
      description: "包含与此项关联的二进制数据的字节数组。"
    - id: values
      type: System.Object[]
      description: "要合并到事件日志条目的消息文本的字符串数组。"
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "无法打开事件日志的注册表项。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "操作系统报告错误时向事件日志中写入事件项。 Windows 错误代码不可用。"
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ComponentModel.Win32Exception
  parent: System.ComponentModel
  isExternal: false
  name: Win32Exception
  nameWithType: Win32Exception
  fullName: System.ComponentModel.Win32Exception
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.Diagnostics.EventLog.#ctor
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog()
  nameWithType: EventLog.EventLog()
  fullName: System.Diagnostics.EventLog.EventLog()
- uid: System.Diagnostics.EventLog.#ctor(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog(String)
  nameWithType: EventLog.EventLog(String)
  fullName: System.Diagnostics.EventLog.EventLog(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog(String,String)
  nameWithType: EventLog.EventLog(String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String)
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog(String,String,String)
  nameWithType: EventLog.EventLog(String,String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String,String)
- uid: System.Diagnostics.EventLog.BeginInit
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: BeginInit()
  nameWithType: EventLog.BeginInit()
  fullName: System.Diagnostics.EventLog.BeginInit()
- uid: System.Diagnostics.EventLog.Clear
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Clear()
  nameWithType: EventLog.Clear()
  fullName: System.Diagnostics.EventLog.Clear()
- uid: System.Diagnostics.EventLog.Close
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Close()
  nameWithType: EventLog.Close()
  fullName: System.Diagnostics.EventLog.Close()
- uid: System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource(EventSourceCreationData)
  nameWithType: EventLog.CreateEventSource(EventSourceCreationData)
  fullName: System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData)
- uid: System.Diagnostics.EventSourceCreationData
  parent: System.Diagnostics
  isExternal: false
  name: EventSourceCreationData
  nameWithType: EventSourceCreationData
  fullName: System.Diagnostics.EventSourceCreationData
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource(String,String)
  nameWithType: EventLog.CreateEventSource(String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String)
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource(String,String,String)
  nameWithType: EventLog.CreateEventSource(String,String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String,String)
- uid: System.Diagnostics.EventLog.Delete(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Delete(String)
  nameWithType: EventLog.Delete(String)
  fullName: System.Diagnostics.EventLog.Delete(String)
- uid: System.Diagnostics.EventLog.Delete(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Delete(String,String)
  nameWithType: EventLog.Delete(String,String)
  fullName: System.Diagnostics.EventLog.Delete(String,String)
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: DeleteEventSource(String)
  nameWithType: EventLog.DeleteEventSource(String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String)
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: DeleteEventSource(String,String)
  nameWithType: EventLog.DeleteEventSource(String,String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String,String)
- uid: System.Diagnostics.EventLog.Dispose(System.Boolean)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: EventLog.Dispose(Boolean)
  fullName: System.Diagnostics.EventLog.Dispose(Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Diagnostics.EventLog.EnableRaisingEvents
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: EventLog.EnableRaisingEvents
  fullName: System.Diagnostics.EventLog.EnableRaisingEvents
- uid: System.Diagnostics.EventLog.EndInit
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EndInit()
  nameWithType: EventLog.EndInit()
  fullName: System.Diagnostics.EventLog.EndInit()
- uid: System.Diagnostics.EventLog.Entries
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Entries
  nameWithType: EventLog.Entries
  fullName: System.Diagnostics.EventLog.Entries
- uid: System.Diagnostics.EventLogEntryCollection
  parent: System.Diagnostics
  isExternal: false
  name: EventLogEntryCollection
  nameWithType: EventLogEntryCollection
  fullName: System.Diagnostics.EventLogEntryCollection
- uid: System.Diagnostics.EventLog.EntryWritten
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EntryWritten
  nameWithType: EventLog.EntryWritten
  fullName: System.Diagnostics.EventLog.EntryWritten
- uid: System.Diagnostics.EntryWrittenEventHandler
  parent: System.Diagnostics
  isExternal: false
  name: EntryWrittenEventHandler
  nameWithType: EntryWrittenEventHandler
  fullName: System.Diagnostics.EntryWrittenEventHandler
- uid: System.Diagnostics.EventLog.Exists(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Exists(String)
  nameWithType: EventLog.Exists(String)
  fullName: System.Diagnostics.EventLog.Exists(String)
- uid: System.Diagnostics.EventLog.Exists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Exists(String,String)
  nameWithType: EventLog.Exists(String,String)
  fullName: System.Diagnostics.EventLog.Exists(String,String)
- uid: System.Diagnostics.EventLog.GetEventLogs
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: GetEventLogs()
  nameWithType: EventLog.GetEventLogs()
  fullName: System.Diagnostics.EventLog.GetEventLogs()
- uid: System.Diagnostics.EventLog[]
  parent: System.Diagnostics
  isExternal: false
  name: EventLog
  nameWithType: EventLog
  fullName: System.Diagnostics.EventLog[]
  spec.csharp:
  - uid: System.Diagnostics.EventLog
    name: EventLog
    nameWithType: EventLog
    fullName: EventLog[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.EventLog.GetEventLogs(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: GetEventLogs(String)
  nameWithType: EventLog.GetEventLogs(String)
  fullName: System.Diagnostics.EventLog.GetEventLogs(String)
- uid: System.Diagnostics.EventLog.Log
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Log
  nameWithType: EventLog.Log
  fullName: System.Diagnostics.EventLog.Log
- uid: System.Diagnostics.EventLog.LogDisplayName
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogDisplayName
  nameWithType: EventLog.LogDisplayName
  fullName: System.Diagnostics.EventLog.LogDisplayName
- uid: System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogNameFromSourceName(String,String)
  nameWithType: EventLog.LogNameFromSourceName(String,String)
  fullName: System.Diagnostics.EventLog.LogNameFromSourceName(String,String)
- uid: System.Diagnostics.EventLog.MachineName
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MachineName
  nameWithType: EventLog.MachineName
  fullName: System.Diagnostics.EventLog.MachineName
- uid: System.Diagnostics.EventLog.MaximumKilobytes
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MaximumKilobytes
  nameWithType: EventLog.MaximumKilobytes
  fullName: System.Diagnostics.EventLog.MaximumKilobytes
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Diagnostics.EventLog.MinimumRetentionDays
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MinimumRetentionDays
  nameWithType: EventLog.MinimumRetentionDays
  fullName: System.Diagnostics.EventLog.MinimumRetentionDays
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: ModifyOverflowPolicy(OverflowAction,Int32)
  nameWithType: EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
  fullName: System.Diagnostics.EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
- uid: System.Diagnostics.OverflowAction
  parent: System.Diagnostics
  isExternal: false
  name: OverflowAction
  nameWithType: OverflowAction
  fullName: System.Diagnostics.OverflowAction
- uid: System.Diagnostics.EventLog.OverflowAction
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: OverflowAction
  nameWithType: EventLog.OverflowAction
  fullName: System.Diagnostics.EventLog.OverflowAction
- uid: System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: RegisterDisplayName(String,Int64)
  nameWithType: EventLog.RegisterDisplayName(String,Int64)
  fullName: System.Diagnostics.EventLog.RegisterDisplayName(String,Int64)
- uid: System.Diagnostics.EventLog.Source
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Source
  nameWithType: EventLog.Source
  fullName: System.Diagnostics.EventLog.Source
- uid: System.Diagnostics.EventLog.SourceExists(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SourceExists(String)
  nameWithType: EventLog.SourceExists(String)
  fullName: System.Diagnostics.EventLog.SourceExists(String)
- uid: System.Diagnostics.EventLog.SourceExists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SourceExists(String,String)
  nameWithType: EventLog.SourceExists(String,String)
  fullName: System.Diagnostics.EventLog.SourceExists(String,String)
- uid: System.Diagnostics.EventLog.SynchronizingObject
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SynchronizingObject
  nameWithType: EventLog.SynchronizingObject
  fullName: System.Diagnostics.EventLog.SynchronizingObject
- uid: System.ComponentModel.ISynchronizeInvoke
  parent: System.ComponentModel
  isExternal: false
  name: ISynchronizeInvoke
  nameWithType: ISynchronizeInvoke
  fullName: System.ComponentModel.ISynchronizeInvoke
- uid: System.Diagnostics.EventLog.WriteEntry(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String)
  nameWithType: EventLog.WriteEntry(String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType)
- uid: System.Diagnostics.EventLogEntryType
  parent: System.Diagnostics
  isExternal: false
  name: EventLogEntryType
  nameWithType: EventLogEntryType
  fullName: System.Diagnostics.EventLogEntryType
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String)
  nameWithType: EventLog.WriteEntry(String,String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Object[])
- uid: System.Diagnostics.EventInstance
  parent: System.Diagnostics
  isExternal: false
  name: EventInstance
  nameWithType: EventInstance
  fullName: System.Diagnostics.EventInstance
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Byte[],Object[])
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(String,EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Object[])
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(String,EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
- uid: System.Diagnostics.EventLog.#ctor*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog
  nameWithType: EventLog.EventLog
- uid: System.Diagnostics.EventLog.BeginInit*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: BeginInit
  nameWithType: EventLog.BeginInit
- uid: System.Diagnostics.EventLog.Clear*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Clear
  nameWithType: EventLog.Clear
- uid: System.Diagnostics.EventLog.Close*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Close
  nameWithType: EventLog.Close
- uid: System.Diagnostics.EventLog.CreateEventSource*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource
  nameWithType: EventLog.CreateEventSource
- uid: System.Diagnostics.EventLog.Delete*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Delete
  nameWithType: EventLog.Delete
- uid: System.Diagnostics.EventLog.DeleteEventSource*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: DeleteEventSource
  nameWithType: EventLog.DeleteEventSource
- uid: System.Diagnostics.EventLog.Dispose*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Dispose
  nameWithType: EventLog.Dispose
- uid: System.Diagnostics.EventLog.EnableRaisingEvents*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: EventLog.EnableRaisingEvents
- uid: System.Diagnostics.EventLog.EndInit*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EndInit
  nameWithType: EventLog.EndInit
- uid: System.Diagnostics.EventLog.Entries*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Entries
  nameWithType: EventLog.Entries
- uid: System.Diagnostics.EventLog.Exists*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Exists
  nameWithType: EventLog.Exists
- uid: System.Diagnostics.EventLog.GetEventLogs*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: GetEventLogs
  nameWithType: EventLog.GetEventLogs
- uid: System.Diagnostics.EventLog.Log*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Log
  nameWithType: EventLog.Log
- uid: System.Diagnostics.EventLog.LogDisplayName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogDisplayName
  nameWithType: EventLog.LogDisplayName
- uid: System.Diagnostics.EventLog.LogNameFromSourceName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogNameFromSourceName
  nameWithType: EventLog.LogNameFromSourceName
- uid: System.Diagnostics.EventLog.MachineName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MachineName
  nameWithType: EventLog.MachineName
- uid: System.Diagnostics.EventLog.MaximumKilobytes*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MaximumKilobytes
  nameWithType: EventLog.MaximumKilobytes
- uid: System.Diagnostics.EventLog.MinimumRetentionDays*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MinimumRetentionDays
  nameWithType: EventLog.MinimumRetentionDays
- uid: System.Diagnostics.EventLog.ModifyOverflowPolicy*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: ModifyOverflowPolicy
  nameWithType: EventLog.ModifyOverflowPolicy
- uid: System.Diagnostics.EventLog.OverflowAction*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: OverflowAction
  nameWithType: EventLog.OverflowAction
- uid: System.Diagnostics.EventLog.RegisterDisplayName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: RegisterDisplayName
  nameWithType: EventLog.RegisterDisplayName
- uid: System.Diagnostics.EventLog.Source*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Source
  nameWithType: EventLog.Source
- uid: System.Diagnostics.EventLog.SourceExists*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SourceExists
  nameWithType: EventLog.SourceExists
- uid: System.Diagnostics.EventLog.SynchronizingObject*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SynchronizingObject
  nameWithType: EventLog.SynchronizingObject
- uid: System.Diagnostics.EventLog.WriteEntry*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry
  nameWithType: EventLog.WriteEntry
- uid: System.Diagnostics.EventLog.WriteEvent*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent
  nameWithType: EventLog.WriteEvent
