### YamlMime:ManagedReference
items:
- uid: System.IO.Log.IRecordSequence
  id: IRecordSequence
  children:
  - System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.IRecordSequence.BaseSequenceNumber
  - System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.CreateReservationCollection
  - System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.Flush
  - System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.LastSequenceNumber
  - System.IO.Log.IRecordSequence.MaximumRecordLength
  - System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  - System.IO.Log.IRecordSequence.ReadRestartAreas
  - System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.IRecordSequence.ReservedBytes
  - System.IO.Log.IRecordSequence.RestartSequenceNumber
  - System.IO.Log.IRecordSequence.RetryAppend
  - System.IO.Log.IRecordSequence.TailPinned
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  langs:
  - csharp
  name: IRecordSequence
  nameWithType: IRecordSequence
  fullName: System.IO.Log.IRecordSequence
  type: Interface
  summary: "提供一系列记录的泛型接口。"
  remarks: "IRecordSequence 接口提供面向记录的流的抽象接口。 IRecordSequence 实例可用于读取和写入日志记录。       IRecordSequence 接口提供了以下功能，-追加日志记录使用<xref:System.IO.Log.IRecordSequence.Append%2A>方法。</xref:System.IO.Log.IRecordSequence.Append%2A>      -读取追加的记录使用<xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>方法。</xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>      -写入特殊的重新开始记录 using<xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>方法。</xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>      -读取重新开始记录从最近写入重新开始记录使用<xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>      -将将记录刷新到持久存储区使用<xref:System.IO.Log.IRecordSequence.Flush%2A>方法。</xref:System.IO.Log.IRecordSequence.Flush%2A>      -为保留空间追加的记录。      的通过前调日志基数的日志可用空间。      接收<xref:System.IO.Log.IRecordSequence.TailPinned>事件通知，移动日志以释放空间基数。</xref:System.IO.Log.IRecordSequence.TailPinned>       日志记录被追加到 IRecordSequence 实例，并且每条日志记录提供唯一的序列号。 序列号严格递增给定的记录序列中。 日志记录包含为中的 IRecordSequence 实例提供的不透明数据<xref:System.Collections.IList>的字节数组段。</xref:System.Collections.IList>       IRecordSequence 接口还公开的几个基本属性，它提供了有关日志边界的信息。      -<xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>属性包含记录序列中第一条有效记录的序列号。</xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>      -<xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>属性包含一个可以保证较大的序列号的最后一个序列号大于追加记录。</xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>      -<xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A>属性包含最后一个写入的重新开始区域的序列号。</xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A>      -<xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A>属性包含可以追加到，或者从此序列中读取的最大记录的大小。</xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A>      -<xref:System.IO.Log.IRecordSequence.ReservedBytes%2A>属性包含此记录序列中做出的所有保留的总大小。</xref:System.IO.Log.IRecordSequence.ReservedBytes%2A>      -如果<xref:System.IO.Log.IRecordSequence.RetryAppend%2A>属性设置为`true`，和<xref:System.IO.Log.IRecordSequence.Append%2A>操作失败，因为序列中没有空间，记录序列将尝试释放空间，然后重试追加操作。</xref:System.IO.Log.IRecordSequence.Append%2A> </xref:System.IO.Log.IRecordSequence.RetryAppend%2A>"
  syntax:
    content: 'public interface IRecordSequence : IDisposable'
  implements:
  - System.IDisposable
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  id: AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "前移日志的基序列号。"
  remarks: "当你使用<xref:System.IO.Log.LogRecordSequence>实例并尝试前移序列号以释放日志中的空间，新的基序列号必须位于不同的日志范围中，以便将前一个范围标记为空。</xref:System.IO.Log.LogRecordSequence> 不支持部分释放范围。"
  syntax:
    content: public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "新的记录序列的基序列号。"
  overload: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSequenceNumber</code>是无效的。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSequenceNumber</code>处于非活动状态在日志中。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "修改序列时发生 I/O 错误。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列已满。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写时写入日志记录写入<xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>。"
  remarks: "中包含的数据`data`参数将连接成单个字节数组，以便以记录形式追加。 但是，数据将重新拆分为数组段中读取记录时不进行任何设置。       通常情况下，此方法完成之前记录已写入。 若要确保记录已写入，请指定<xref:System.IO.Log.RecordAppendOptions>标志使用`recordAppendOptions`参数或调用<xref:System.IO.Log.IRecordSequence.Flush%2A>方法。</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "用户指定顺序的下一个记录序列号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "上一步顺序的下一个记录序列号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> ，它指定应如何写入数据。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加的日志记录的序列号。"
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "追加记录时发生 I/O 错误。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列无法获得足够的可用空间来容纳新记录。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写，追加日志记录写入<xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>。"
  remarks: "中包含的数据`data`参数将连接成单个字节数组，以便以记录形式追加。 但是，数据将重新拆分为数组段中读取记录时不进行任何设置。       通常情况下，此方法完成之前记录已写入。 若要确保记录已写入，请指定<xref:System.IO.Log.RecordAppendOptions>标志使用`recordAppendOptions`参数或调用<xref:System.IO.Log.IRecordSequence.Flush%2A>方法。</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "用户指定顺序的下一个记录序列号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "上一步顺序的下一个记录序列号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> ，它指定应如何写入数据。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加的日志记录的序列号。"
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "追加记录时发生 I/O 错误。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列无法获得足够的可用空间来容纳新记录。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写，追加日志记录写入<xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>，使用序列中先前保留的空间。"
  remarks: "中包含的数据`data`参数将连接成单个字节数组，以便以记录形式追加。 但是，数据将重新拆分为数组段中读取记录时不进行任何设置。       追加的记录将占用先前已保留，使用指定的保留的空间`reservations`参数。 如果追加成功，它将占用能容纳数据，并将从集合中移除保留区域最小保留区域。       通常情况下，此方法完成之前记录已写入。 若要确保记录已写入，请指定<xref:System.IO.Log.RecordAppendOptions>标志使用`recordAppendOptions`参数或调用<xref:System.IO.Log.IRecordSequence.Flush%2A>方法。</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "用户指定顺序的下一个记录序列号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "上一步顺序的下一个记录序列号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> ，它指定应如何写入数据。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> ，它包含应当用于此记录的保留。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加的日志记录的序列号。"
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "追加记录时发生 I/O 错误。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列无法获得足够的可用空间来容纳新记录。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写，追加日志记录写入<xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>，使用序列中先前保留的空间。"
  remarks: "中包含的数据`data`参数将连接成单个字节数组，以便以记录形式追加。 但是，数据将重新拆分为数组段中读取记录时不进行任何设置。       追加的记录将占用先前已保留，使用指定的保留的空间`reservations`参数。 如果追加成功，它将占用能容纳数据，并将从集合中移除保留区域最小保留区域。       通常情况下，此方法完成之前记录已写入。 若要确保记录已写入，请指定<xref:System.IO.Log.RecordAppendOptions>标志使用`recordAppendOptions`参数或调用<xref:System.IO.Log.IRecordSequence.Flush%2A>方法。</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "用户指定顺序的下一个记录序列号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "上一步顺序的下一个记录序列号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> ，它指定应如何写入数据。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> ，它包含应当用于此记录的保留。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加的日志记录的序列号。"
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "追加记录时发生 I/O 错误。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列无法获得足够的可用空间来容纳新记录。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BaseSequenceNumber
  id: BaseSequenceNumber
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BaseSequenceNumber
  nameWithType: IRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.IRecordSequence.BaseSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写，获取在当前的第一条有效记录的序列号<xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>。"
  remarks: "有效序列号是大于或等于 BaseSequenceNumber，并且小于<xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.</xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>       此属性的值可以更改通过调用<xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A>或<xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>方法。</xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> </xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "中有效记录对应的最低序列号<xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>。"
  overload: System.IO.Log.IRecordSequence.BaseSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "在序列已释放的之后，已访问属性。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写，开始异步追加操作。"
  remarks: "应传递<xref:System.IAsyncResult>到此方法返回<xref:System.IO.Log.IRecordSequence.EndAppend%2A>方法，以确保追加操作已完成并能够适当释放资源。</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> 如果在异步追加过程中发生错误，直到不引发异常<xref:System.IO.Log.IRecordSequence.EndAppend%2A>方法调用与<xref:System.IAsyncResult>此方法返回。</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       中包含的数据`data`参数将连接成单个字节数组，以便以记录形式追加。 但是，数据将重新拆分为数组段中读取记录时不进行任何设置。       通常情况下，此方法完成之前记录已写入。 若要确保记录已写入，请指定<xref:System.IO.Log.RecordAppendOptions>标志使用`recordAppendOptions`参数或调用<xref:System.IO.Log.IRecordSequence.Flush%2A>方法。</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "用户指定顺序的下一个记录序列号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "上一步顺序的下一个记录序列号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> ，它指定应如何写入数据。"
    - id: callback
      type: System.AsyncCallback
      description: "可选的异步回调，以在追加完成时调用。"
    - id: state
      type: System.Object
      description: "用户提供的对象，用于区分此特定异步追加请求与其他请求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>表示异步追加，可能仍处于挂起状态。</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "追加记录时发生 I/O 错误。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列无法获得足够的可用空间来容纳新记录。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写，开始异步追加操作，使用序列中先前保留的空间。"
  remarks: "应传递<xref:System.IAsyncResult>到此方法返回<xref:System.IO.Log.IRecordSequence.EndAppend%2A>方法，以确保追加操作已完成并能够适当释放资源。</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> 如果在异步追加过程中发生错误，直到不引发异常<xref:System.IO.Log.IRecordSequence.EndAppend%2A>方法调用与<xref:System.IAsyncResult>此方法返回。</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       中包含的数据`data`参数将连接成单个字节数组，以便以记录形式追加。 但是，数据将重新拆分为数组段中读取记录时不进行任何设置。       通常情况下，此方法完成之前记录已写入。 若要确保记录已写入，请指定<xref:System.IO.Log.RecordAppendOptions>标志使用`recordAppendOptions`参数或调用<xref:System.IO.Log.IRecordSequence.Flush%2A>方法。</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "用户指定顺序的下一个记录序列号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "上一步顺序的下一个记录序列号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> ，它指定应如何写入数据。"
    - id: callback
      type: System.AsyncCallback
      description: "可选的异步回调，以在追加完成时调用。"
    - id: state
      type: System.Object
      description: "用户提供的对象，用于区分此特定异步追加请求与其他请求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>表示异步追加，可能仍处于挂起状态。</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "追加记录时发生 I/O 错误。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列无法获得足够的可用空间来容纳新记录。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写，开始异步追加操作使用序列中先前保留的空间。"
  remarks: "应传递<xref:System.IAsyncResult>到此方法返回<xref:System.IO.Log.IRecordSequence.EndAppend%2A>方法，以确保追加操作已完成并能够适当释放资源。</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> 如果在异步追加过程中发生错误，直到不引发异常<xref:System.IO.Log.IRecordSequence.EndAppend%2A>方法调用与<xref:System.IAsyncResult>此方法返回。</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       中包含的数据`data`参数将连接成单个字节数组，以便以记录形式追加。 但是，数据将重新拆分为数组段中读取记录时不进行任何设置。       追加的记录将占用先前已保留，使用指定的保留的空间`reservations`参数。 如果追加成功，它将占用能容纳数据，并将从集合中移除保留区域最小保留区域。       通常情况下，此方法完成之前记录已写入。 若要确保记录已写入，请指定<xref:System.IO.Log.RecordAppendOptions>标志使用`recordAppendOptions`参数或调用<xref:System.IO.Log.IRecordSequence.Flush%2A>方法。</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "用户指定顺序的下一个记录序列号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "上一步顺序的下一个记录序列号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> ，它指定应如何写入数据。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> ，它包含应当用于此记录的保留。"
    - id: callback
      type: System.AsyncCallback
      description: "可选的异步回调，以在追加完成时调用。"
    - id: state
      type: System.Object
      description: "用户提供的对象，用于区分此特定异步追加请求与其他请求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>表示异步追加，可能仍处于挂起状态。</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "追加记录时发生 I/O 错误。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列无法获得足够的可用空间来容纳新记录。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写，开始异步追加操作，使用序列中先前保留的空间。"
  remarks: "应传递<xref:System.IAsyncResult>到此方法返回<xref:System.IO.Log.IRecordSequence.EndAppend%2A>方法，以确保追加操作已完成并能够适当释放资源。</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> 如果在异步追加过程中发生错误，直到不引发异常<xref:System.IO.Log.IRecordSequence.EndAppend%2A>方法调用与<xref:System.IAsyncResult>此方法返回。</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       中包含的数据`data`参数将连接成单个字节数组，以便以记录形式追加。 但是，数据将重新拆分为数组段中读取记录时不进行任何设置。       追加的记录将占用先前已保留，使用指定的保留的空间`reservations`参数。 如果追加成功，它将占用能容纳数据，并将从集合中移除保留区域最小保留区域。       通常情况下，此方法完成之前记录已写入。 若要确保记录已写入，请指定<xref:System.IO.Log.RecordAppendOptions>标志使用`recordAppendOptions`参数或调用<xref:System.IO.Log.IRecordSequence.Flush%2A>方法。</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousUndoRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "用户指定顺序的下一个记录序列号。"
    - id: previousUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "上一步顺序的下一个记录序列号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> ，它指定应如何写入数据。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> ，它包含应当用于此记录的保留。"
    - id: callback
      type: System.AsyncCallback
      description: "可选的异步回调，以在追加完成时调用。"
    - id: state
      type: System.Object
      description: "用户提供的对象，用于区分此特定异步追加请求与其他请求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>表示异步追加，可能仍处于挂起状态。</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "追加记录时发生 I/O 错误。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列无法获得足够的可用空间来容纳新记录。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  id: BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写，开始异步刷新操作，使用序列中先前保留的空间。"
  remarks: "应传递<xref:System.IAsyncResult>返回在当前方法<xref:System.IO.Log.IRecordSequence.EndFlush%2A>方法，以确保刷新完成并适当释放资源。</xref:System.IO.Log.IRecordSequence.EndFlush%2A> </xref:System.IAsyncResult> 如果异步刷新过程中发生错误，直到不引发异常<xref:System.IO.Log.IRecordSequence.EndFlush%2A>方法调用与<xref:System.IAsyncResult>此方法返回。</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndFlush%2A>       调用此方法可以确保所有记录已追加到<xref:System.IO.Log.IRecordSequence>持久写入。</xref:System.IO.Log.IRecordSequence>       如果记录序列已经释放，或者如果传递了无效自变量，将立即引发异常，此操作内。 异步刷新请求，例如，I/O 请求过程中的磁盘故障过程中发生的错误将导致在时引发异常<xref:System.IO.Log.IRecordSequence.EndFlush%2A>调用方法。</xref:System.IO.Log.IRecordSequence.EndFlush%2A>"
  syntax:
    content: public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "必须写入的最新记录的序列号。 如果此<xref href=&quot;System.IO.Log.SequenceNumber&quot;></xref>无效，则必须写入所有记录。"
    - id: callback
      type: System.AsyncCallback
      description: "可选的异步回调，在刷新完成时调用。"
    - id: state
      type: System.Object
      description: "一个用户提供的对象，它将此特定异步刷新请求与其他请求区别开来。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，表示异步刷新操作，可能仍处于挂起状态。</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "刷新数据时出现 I/O 错误。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "在中重写派生的类中，开始异步保留和追加操作。"
  remarks: "应传递<xref:System.IAsyncResult>到此方法返回<xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>方法，以确保追加操作已完成并能够适当释放资源。</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> 如果在异步追加过程中发生错误，直到不引发异常<xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>方法调用与<xref:System.IAsyncResult>此方法返回。</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>       中包含的数据`data`参数将连接成单个字节数组，以便以记录形式追加。 但是，数据将重新拆分为数组段中读取记录时不进行任何设置。       指定的保留添加到所提供的保留集合在原子操作中使用记录追加操作。 如果追加失败，不保留任何空间。       通常情况下，此方法可以完成之前记录已写入。 若要确保记录已写入，请指定<xref:System.IO.Log.RecordAppendOptions>标志使用`recordAppendOptions`参数或调用<xref:System.IO.Log.IRecordSequence.Flush%2A>方法。</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       如果记录序列已经释放，或者如果传递了无效自变量，将立即引发异常，此操作内。 例如，I/O 请求过程中的磁盘故障异步追加请求过程中发生的错误将导致在时引发异常<xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>调用方法。</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "用户指定顺序的下一个记录序列号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "上一步顺序的下一个记录序列号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> ，它指定应如何写入数据。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "要在其中生成保留的保留集合。"
    - id: reservations
      type: System.Int64[]
      description: "要生成，以字节为单位的保留。"
    - id: callback
      type: System.AsyncCallback
      description: "可选的异步回调，以在追加完成时调用。"
    - id: state
      type: System.Object
      description: "用户提供的对象，用于区分此特定异步追加请求与其他请求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，表示此异步操作，可能仍处于挂起状态。</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "追加记录时发生 I/O 错误。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列无法获得足够的可用空间来容纳新记录，或生成保留。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "在中重写派生的类中，开始异步保留和追加操作。"
  remarks: "应传递<xref:System.IAsyncResult>到此方法返回<xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>方法，以确保追加操作已完成并能够适当释放资源。</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> 如果在异步追加过程中发生错误，直到不引发异常<xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>方法调用与<xref:System.IAsyncResult>此方法返回。</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>       中包含的数据`data`参数将连接成单个字节数组，以便以记录形式追加。 但是，数据将重新拆分为数组段中读取记录时不进行任何设置。       指定的保留添加到所提供的保留集合在原子操作中使用记录追加操作。 如果追加失败，不保留任何空间。       通常情况下，此方法可以完成之前记录已写入。 若要确保记录已写入，请指定<xref:System.IO.Log.RecordAppendOptions>标志使用`recordAppendOptions`参数或调用<xref:System.IO.Log.IRecordSequence.Flush%2A>方法。</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       如果记录序列已经释放，或者如果传递了无效自变量，将立即引发异常，此操作内。 例如，I/O 请求过程中的磁盘故障异步追加请求过程中发生的错误将导致在时引发异常<xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>调用方法。</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "用户指定顺序的下一个记录序列号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "上一步顺序的下一个记录序列号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> ，它指定应如何写入数据。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "要在其中生成保留的保留集合。"
    - id: reservations
      type: System.Int64[]
      description: "要生成，以字节为单位的保留。"
    - id: callback
      type: System.AsyncCallback
      description: "可选的异步回调，以在追加完成时调用。"
    - id: state
      type: System.Object
      description: "用户提供的对象，用于区分此特定异步追加请求与其他请求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，表示此异步操作，可能仍处于挂起状态。</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "追加记录时发生 I/O 错误。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列无法获得足够的可用空间来容纳新记录，或生成保留。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写，开始异步重新开始区域写入操作，使用序列中先前保留的空间。"
  remarks: "应传递<xref:System.IAsyncResult>到此方法返回<xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>方法，以确保重新开始区域写入操作完成并能够适当释放资源。</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> 如果在异步重新开始区域写入操作期间发生错误，直到不引发异常<xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>方法调用与<xref:System.IAsyncResult>此方法返回。</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>       中包含的数据`data`参数将连接成单个字节数组，以便以记录形式追加。 但是，数据将重新拆分为数组段中读取记录时不进行任何设置。       该操作成功完成时，基序列号已更新。 其所有日志记录序列号小于新的基序列号都不可访问。       如果<xref:System.IO.Log.ReservationCollection>指定，写入的重新开始区域将占用先前已保留，使用集合中包含的保留的空间。</xref:System.IO.Log.ReservationCollection> 如果该方法成功，它将占用的最小的保留，可以容纳的数据，而该保留将从集合中移除。       如果记录序列已经释放，或者如果传递了无效自变量，将立即引发异常，此操作内。 例如，I/O 请求过程中的磁盘故障异步追加请求过程中发生的错误将导致在时引发异常<xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>调用方法。</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "新的基序列号。 指定的序列号必须大于或等于当前基序列号。"
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> ，它包含应当用于此重新开始区域的保留。"
    - id: callback
      type: System.AsyncCallback
      description: "可选的异步回调，以重新开始区域写入完成时调用。"
    - id: state
      type: System.Object
      description: "一个用户提供的对象，它将此特定异步重新开始区域写入请求与其他请求区别开来。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，表示的异步重新开始区域写入操作，可能仍处于挂起状态。</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginWriteRestartArea*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写，开始异步重新开始区域写入操作，使用序列中先前保留的空间。"
  remarks: "应传递<xref:System.IAsyncResult>到此方法返回<xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>方法，以确保重新开始区域写入操作已完成并能够适当释放资源。</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> 如果在异步重新开始区域写入操作期间发生错误，直到不引发异常<xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>方法调用与<xref:System.IAsyncResult>此方法返回。</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>       中包含的数据`data`参数将连接成单个字节数组，以便以记录形式追加。 但是，数据将重新拆分为数组段中读取记录时不进行任何设置。       该操作成功完成时，基序列号已更新。 其所有日志记录序列号小于新的基序列号都不可访问。       如果<xref:System.IO.Log.ReservationCollection>指定，写入的重新开始区域将占用先前已保留，使用集合中包含的保留的空间。</xref:System.IO.Log.ReservationCollection> 如果该方法成功，它将占用的最小的保留，可以容纳的数据，而该保留将从集合中移除。       如果记录序列已经释放，或者如果传递了无效自变量，将立即引发异常，此操作内。 例如，I/O 请求过程中的磁盘故障异步追加请求过程中发生的错误将导致在时引发异常<xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>调用方法。</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "新的基序列号。 指定的序列号必须大于或等于当前基序列号。"
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> ，它包含应当用于此重新开始区域的保留。"
    - id: callback
      type: System.AsyncCallback
      description: "可选的异步回调，以重新开始区域写入完成时调用。"
    - id: state
      type: System.Object
      description: "一个用户提供的对象，它将此特定异步重新开始区域写入请求与其他请求区别开来。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，表示的异步重新开始区域写入操作，可能仍处于挂起状态。</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "写入重新开始区域时出现 I/O 错误。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列无法获得足够的可用空间来容纳新记录。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.CreateReservationCollection
  id: CreateReservationCollection
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: CreateReservationCollection()
  nameWithType: IRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.IRecordSequence.CreateReservationCollection()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写，创建一个新<xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>。"
  syntax:
    content: public System.IO.Log.ReservationCollection CreateReservationCollection ();
    parameters: []
    return:
      type: System.IO.Log.ReservationCollection
      description: "新创建<xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>。"
  overload: System.IO.Log.IRecordSequence.CreateReservationCollection*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)
  id: EndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写，结束异步追加操作。"
  remarks: "此方法阻止，直到 I/O 操作已完成。 调用 EndAppend 时，异步写入请求，例如，I/O 请求过程的磁盘故障过程中发生的错误变得可见。       必须在上一次调用此方法每个<xref:System.IAsyncResult>返回<xref:System.IO.Log.IRecordSequence.BeginAppend%2A>方法。</xref:System.IO.Log.IRecordSequence.BeginAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "对未完成的异步 I/O 请求的引用。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加的日志记录的序列号。"
  overload: System.IO.Log.IRecordSequence.EndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)
  id: EndFlush(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndFlush(IAsyncResult)
  nameWithType: IRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndFlush(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写，结束异步刷新操作。"
  remarks: "此方法阻止，直到 I/O 操作已完成。 调用 EndFlush 时，异步刷新请求，例如，I/O 请求过程的磁盘故障过程中发生的错误变得可见。       必须在上一次调用此方法每个<xref:System.IAsyncResult>返回<xref:System.IO.Log.IRecordSequence.BeginFlush%2A>方法。</xref:System.IO.Log.IRecordSequence.BeginFlush%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "对未完成的异步 I/O 请求的引用。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "写入的最后一个记录序列号。"
  overload: System.IO.Log.IRecordSequence.EndFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  id: EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndReserveAndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写，结束异步保留和追加操作。"
  remarks: "此方法阻止，直到 I/O 操作已完成。 调用 EndReserveAndAppend 时，异步写入请求，例如，I/O 请求过程的磁盘故障过程中发生的错误变得可见。       必须在上一次调用此方法每个<xref:System.IAsyncResult>返回<xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A>方法。</xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "对未完成的异步 I/O 请求的引用。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加的日志记录的序列号。"
  overload: System.IO.Log.IRecordSequence.EndReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  id: EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: IRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndWriteRestartArea(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写，结束异步重新开始区域写入操作。"
  remarks: "此方法阻止，直到 I/O 操作已完成。 调用 EndWriteRestartArea 时，异步写入请求，例如，I/O 请求过程的磁盘故障过程中发生的错误变得可见。       必须在上一次调用此方法每个<xref:System.IAsyncResult>返回<xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A>方法。</xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "对未完成的异步 I/O 请求的引用。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "写入的日志记录的序列号。"
  overload: System.IO.Log.IRecordSequence.EndWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Flush
  id: Flush
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Flush()
  nameWithType: IRecordSequence.Flush()
  fullName: System.IO.Log.IRecordSequence.Flush()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写，确保所有追加的记录都已写入。"
  remarks: "调用此方法可以确保所有记录已追加到<xref:System.IO.Log.IRecordSequence>都已持久写入。</xref:System.IO.Log.IRecordSequence>"
  syntax:
    content: public System.IO.Log.SequenceNumber Flush ();
    parameters: []
    return:
      type: System.IO.Log.SequenceNumber
      description: "写入的最后一个记录序列号。"
  overload: System.IO.Log.IRecordSequence.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "刷新数据时出现 I/O 错误。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)
  id: Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Flush(SequenceNumber)
  nameWithType: IRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.Flush(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写，可确保所有追加的记录，直到并包括指定的序列号的记录都已持久写入。"
  remarks: "调用此方法可以确保与序列的所有记录最多和不高于指定的序列号都已持久写入。"
  syntax:
    content: public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "必须写入的最新记录的序列号。 如果此<xref href=&quot;System.IO.Log.SequenceNumber&quot;></xref>无效，则必须写入所有记录。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "写入的最后一个记录序列号。"
  overload: System.IO.Log.IRecordSequence.Flush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "刷新数据时出现 I/O 错误。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.LastSequenceNumber
  id: LastSequenceNumber
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: LastSequenceNumber
  nameWithType: IRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.IRecordSequence.LastSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写，获取的序列号比追加的最新记录大。"
  remarks: "此属性包含一个可以保证较大的序列号的最后一个序列号大于追加记录。 有效序列号是大于或等于<xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>，并且小于 LastSequenceNumber。</xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>      1> [!NOTE]&1;> 时使用的<xref:System.IO.Log.LogRecordSequence>实例，<xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>值可能会变得过期之前记录刷新到日志。</xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A> </xref:System.IO.Log.LogRecordSequence> 请参阅<xref:System.IO.Log.IRecordSequence.Flush%2A>和<xref:System.IO.Log.RecordAppendOptions>有关刷新记录...</xref:System.IO.Log.RecordAppendOptions> </xref:System.IO.Log.IRecordSequence.Flush%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber LastSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "序列号比追加的最新记录大。"
  overload: System.IO.Log.IRecordSequence.LastSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "在序列已释放的之后，已访问属性。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.MaximumRecordLength
  id: MaximumRecordLength
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: MaximumRecordLength
  nameWithType: IRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.IRecordSequence.MaximumRecordLength
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写，获取可以追加到序列或者从此此序列，以字节为单位中读取的最大记录的大小。"
  syntax:
    content: public long MaximumRecordLength { get; }
    return:
      type: System.Int64
      description: "可以追加到或者读取此序列中，以字节为单位的最大记录大小。"
  overload: System.IO.Log.IRecordSequence.MaximumRecordLength*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "在序列已释放的之后，已访问属性。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  id: ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写，返回序列中记录的可枚举集合。"
  remarks: "当在派生类中重写，返回序列中记录的可枚举集合。 所枚举记录的顺序取决于值`logRecordEnum`参数。"
  example:
  - "This sample demonstrates the use of the ReadLogRecords method.  \n  \n```c#  \nusing System;  \n using System.IO;  \n using System.IO.Log;  \n  \n class ReadRecordsSample  \n {  \n     static SequenceNumber AppendRecord(IRecordSequence sequence,  \n                                        string message,  \n                                        SequenceNumber user,  \n                                        SequenceNumber previous)  \n     {  \n         MemoryStream data = new MemoryStream();  \n         BinaryWriter writer = new BinaryWriter(data);  \n         writer.Write(message);  \n  \n         ArraySegment<byte>[] segments;  \n         segments = new ArraySegment<byte>[1];  \n         segments[0] = new ArraySegment(data.GetBuffer(),  \n                                        0,  \n                                        Data.Length);  \n  \n         return sequence.Append(segments,  \n                                user,  \n                                previous,  \n                                WriteFlags.None);  \n     }  \n  \n     public static void Main(string[] args)  \n     {  \n         IRecordSequence sequence;  \n         sequence = new FileIRecordSequence(args[0]);  \n  \n         SequenceNumber a, b, c, d;  \n  \n         a = AppendRecord(sequence,  \n                          \"This is record A\",  \n                          SequenceNumber.Invalid,  \n                          SequenceNumber.Invalid);  \n         Console.WriteLine(\"Record A has sequence number System.IO.Log\", a);  \n  \n         b = AppendRecord(sequence,  \n                          \"This is record B\",  \n                          a,  \n                          a);  \n         Console.WriteLine(\"Record B has sequence number System.IO.Log\", b);  \n  \n         c = AppendRecord(sequence,  \n                          \"This is record C\",  \n                          a,  \n                          a);  \n         Console.WriteLine(\"Record C has sequence number System.IO.Log\", c);  \n  \n         d = AppendRecord(sequence,  \n                          \"This is record D\",  \n                          b,  \n                          c);  \n         Console.WriteLine(\"Record D has sequence number System.IO.Log\", d);  \n  \n         foreach(LogRecord record in  \n                 sequence.ReadLogRecords(a, ReadDirection.Forward))  \n         {  \n             BinaryReader reader = new BinaryReader(record.Data);  \n             Console.WriteLine(\"System.IO.Log: T:System.IO.Log.IRecordSequence\",  \n                               record.SequenceNumber,  \n                               reader.ReadString());  \n         }  \n  \n         foreach(LogRecord record in  \n                 sequence.ReadLogRecords(d, ReadDirection.User))  \n         {  \n             BinaryReader reader = new BinaryReader(record.Data);  \n             Console.WriteLine(\"System.IO.Log: T:System.IO.Log.IRecordSequence\",  \n                               record.SequenceNumber,  \n                               reader.ReadString());  \n         }  \n  \n         foreach(LogRecord record in  \n                 sequence.ReadLogRecords(d, ReadDirection.Previous))  \n         {  \n             BinaryReader reader = new BinaryReader(record.Data);  \n             Console.WriteLine(\"System.IO.Log: T:System.IO.Log.IRecordSequence\",  \n                               record.SequenceNumber,  \n                               reader.ReadString());  \n         }  \n     }  \n       }  \n```"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);
    parameters:
    - id: start
      type: System.IO.Log.SequenceNumber
      description: "读取操作开始处的第一个记录序列号。"
    - id: logRecordEnum
      type: System.IO.Log.LogRecordEnumeratorType
      description: "一个有效<xref href=&quot;System.IO.Log.LogRecordEnumeratorType&quot;></xref>值，该值指定使用方式 （即，向前或向后） 中的记录应读取从<xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>。"
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "序列中记录的可枚举集合。"
  overload: System.IO.Log.IRecordSequence.ReadLogRecords*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "读取记录时出现 I/O 错误。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReadRestartAreas
  id: ReadRestartAreas
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReadRestartAreas()
  nameWithType: IRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.IRecordSequence.ReadRestartAreas()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写，返回序列中重新开始区域的可枚举集合。"
  remarks: "重新开始区域将枚举在反向序列号的顺序，即从最高序列号到最低序列号。 仅重新开始区域的最后一个序列号之间的序列号和基序列号枚举。      1> [!NOTE]&1;> 如果日志范围包含<xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>变得损坏，则此方法会引发<xref:System.IO.IOException>并显示错误消息&quot;由于意外的 I/O 异常，无法执行请求。</xref:System.IO.IOException> </xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> 返回以下错误代码: &quot;80070026&quot;&quot;。"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadRestartAreas ();
    parameters: []
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "序列中重新开始区域的可枚举集合。"
  overload: System.IO.Log.IRecordSequence.ReadRestartAreas*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "读取记录时出现 I/O 错误。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写，自动生成一个保留，并向序列中追加一条记录。"
  remarks: "中包含的数据`data`参数将连接成单个字节数组，以便以记录形式追加。 但是，数据将重新拆分为数组段中读取记录时不进行任何设置。       指定的保留添加到所提供的保留集合在原子操作中使用记录追加操作。 如果追加失败，不保留任何空间。       通常情况下，此方法可以完成之前记录已写入。 若要确保记录已写入，请指定<xref:System.IO.Log.RecordAppendOptions>标志使用`recordAppendOptions`参数或调用<xref:System.IO.Log.IRecordSequence.Flush%2A>方法。</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "用户指定顺序的下一个记录序列号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "上一步顺序的下一个记录序列号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> ，它指定应如何写入数据。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> ，其中包含要在其中生成保留的集合。"
    - id: reservations
      type: System.Int64[]
      description: "要生成，以字节为单位的保留。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加的日志记录的序列号。"
  overload: System.IO.Log.IRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "追加记录时发生 I/O 错误。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列无法获得足够的可用空间来容纳新记录，或生成保留。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写，自动生成一个保留，并向序列中追加一条记录。"
  remarks: "中包含的数据`data`参数将连接成单个字节数组，以便以记录形式追加。 但是，数据将重新拆分为数组段中读取记录时不进行任何设置。       指定的保留添加到所提供的保留集合在原子操作中使用记录追加操作。 如果追加失败，不保留任何空间。       通常情况下，此方法可以完成之前记录已写入。 若要确保记录已写入，请指定<xref:System.IO.Log.RecordAppendOptions>标志使用`recordAppendOptions`参数或调用<xref:System.IO.Log.IRecordSequence.Flush%2A>方法。</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "用户指定顺序的下一个记录序列号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "上一步顺序的下一个记录序列号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> ，它指定应如何写入数据。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "要在其中生成保留的保留集合。"
    - id: reservations
      type: System.Int64[]
      description: "要生成，以字节为单位的保留。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加的日志记录的序列号。"
  overload: System.IO.Log.IRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "追加记录时发生 I/O 错误。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列无法获得足够的可用空间来容纳新记录，或生成保留。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReservedBytes
  id: ReservedBytes
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReservedBytes
  nameWithType: IRecordSequence.ReservedBytes
  fullName: System.IO.Log.IRecordSequence.ReservedBytes
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写，获取已保留的字节总数。"
  syntax:
    content: public long ReservedBytes { get; }
    return:
      type: System.Int64
      description: "此记录序列中做出的所有保留的总大小。"
  overload: System.IO.Log.IRecordSequence.ReservedBytes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "在序列已释放的之后，已访问属性。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.RestartSequenceNumber
  id: RestartSequenceNumber
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: RestartSequenceNumber
  nameWithType: IRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.IRecordSequence.RestartSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写，获取最近写入的重新开始区域的序列号。"
  remarks: "重新开始区域用于临时存储包含客户端的最后一个检查点操作的信息。 需要恢复时，你可以分析重新开始区域，以最后一个检查点操作中检索所有数据。 此数据将初始化事务表、 脏页表和打开文件表，以便它们可以用于恢复过程。"
  syntax:
    content: public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "最近写入的序列号重新开始区域。"
  overload: System.IO.Log.IRecordSequence.RestartSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "在序列已释放的之后，已访问属性。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.RetryAppend
  id: RetryAppend
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: RetryAppend
  nameWithType: IRecordSequence.RetryAppend
  fullName: System.IO.Log.IRecordSequence.RetryAppend
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "获取或设置一个值，该值指示是否将追加如果日志已满时自动重试。"
  remarks: "如果此属性的值是`true`，和<xref:System.IO.Log.IRecordSequence.Append%2A>调用因为序列中没有足够的空间而失败，则记录序列将尝试释放空间，然后重试追加。</xref:System.IO.Log.IRecordSequence.Append%2A>"
  syntax:
    content: public bool RetryAppend { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果追加如果日志已满，则为将自动重试否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.Log.IRecordSequence.RetryAppend*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "在序列已释放的之后，已访问属性。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.TailPinned
  id: TailPinned
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: TailPinned
  nameWithType: IRecordSequence.TailPinned
  fullName: System.IO.Log.IRecordSequence.TailPinned
  type: Event
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当记录序列确定必须前移尾数据时发生。"
  remarks: "你可以时激发此事件记录序列空间不足。 此事件激发时，尾数据的序列 （即基序列号） 将前移以释放空间。"
  syntax:
    content: public event EventHandler<System.IO.Log.TailPinnedEventArgs> TailPinned;
    return:
      type: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  id: WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写时写入重新开始区域写入<xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>。"
  remarks: "重新开始区域用于临时存储包含客户端的最后一个检查点操作的信息。 公用日志文件系统 (CLFS) 维护两个重新开始区域，以确保至少一个有效区域总是可用。 需要恢复时，CLFS 最后一个检查点操作中读取其重新开始区域和所有数据。 此数据将初始化事务表、 脏页表和打开文件表，以便它们可以用于恢复过程。       可以使用读取重新开始区域<xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       字节数组段中的数据将连接成单个字节数组，以便以记录形式追加。 数据将重新拆分为数组段读取重新开始区域时不进行任何设置。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "重新开始区域写入的序列号。"
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "写入重新开始区域时出现 I/O 错误。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列无法获得足够的可用空间以包含新的重新开始区域。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写时写入重新开始区域写入<xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>。"
  remarks: "重新开始区域用于临时存储包含客户端的最后一个检查点操作的信息。 需要恢复时，你可以分析重新开始区域，以最后一个检查点操作中检索所有数据。 此数据将初始化事务表、 脏页表和打开文件表，以便它们可以用于恢复过程。 可以使用读取重新开始区域<xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       字节数组段中的数据将连接成单个字节数组，以便以记录形式追加。 数据将重新拆分为数组段读取重新开始区域时不进行任何设置。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "重新开始区域写入的序列号。"
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "写入重新开始区域时出现 I/O 错误。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列无法获得足够的可用空间以包含新的重新开始区域。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写时写入重新开始区域写入<xref href=&quot;System.IO.Log.IRecordSequence&quot;></xref>并更新基序列号"
  remarks: "重新开始区域用于临时存储包含客户端的最后一个检查点操作的信息。 需要恢复时，你可以分析重新开始区域，以最后一个检查点操作中检索所有数据。 此数据将初始化事务表、 脏页表和打开文件表，以便它们可以用于恢复过程。 可以使用读取重新开始区域<xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       重新开始区域写入时，字节数组段中的数据将连接成单个字节数组，以便以记录形式追加。 数据将重新拆分为数组段读取重新开始区域时不进行任何设置。       此方法成功完成时，基序列号已更新。 其所有日志记录序列号小于新的基序列号都不可访问。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "新的基序列号。 指定的序列号必须大于或等于当前基序列号。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "重新开始区域写入的序列号。"
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "写入重新开始区域时出现 I/O 错误。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列无法获得足够的可用空间以包含新的重新开始区域。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写时写入重新开始区域写入<xref href=&quot;System.IO.Log.IRecordSequence&quot;></xref>并更新基序列号。"
  remarks: "重新开始区域用于临时存储包含客户端的最后一个检查点操作的信息。 需要恢复时，你可以分析重新开始区域，以最后一个检查点操作中检索所有数据。 此数据将初始化事务表、 脏页表和打开文件表，以便它们可以用于恢复过程。 可以使用读取重新开始区域<xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       重新开始区域写入时，字节数组段中的数据将连接成单个字节数组，以便以记录形式追加。 数据将重新拆分为数组段读取重新开始区域时不进行任何设置。       此方法成功完成时，基序列号已更新。 其所有日志记录序列号小于新的基序列号都不可访问。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "新的基序列号。 指定的序列号必须大于或等于当前基序列号。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "重新开始区域写入的序列号。"
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "写入重新开始区域时出现 I/O 错误。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列无法获得足够的可用空间以包含新的重新开始区域。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写时写入重新开始区域写入<xref href=&quot;System.IO.Log.IRecordSequence&quot;></xref>使用的保留，并更新基序列号"
  remarks: "重新开始区域用于临时存储包含客户端的最后一个检查点操作的信息。 需要恢复时，你可以分析重新开始区域，以最后一个检查点操作中检索所有数据。 此数据将初始化事务表、 脏页表和打开文件表，以便它们可以用于恢复过程。 可以使用读取重新开始区域<xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       重新开始区域写入时，字节数组段中的数据将连接成单个字节数组，以便以记录形式追加。 数据将重新拆分为数组段读取重新开始区域时不进行任何设置。       如果指定了保留，写入的重新开始区域将占用先前已保留，使用集合中包含的保留的空间。 如果该方法成功，它将占用能容纳数据，并保留将从集合中移除的最小保留。       此方法成功完成时，基序列号已更新。 其所有日志记录序列号小于新的基序列号都不可访问。       如果记录序列已经释放，或者如果传递了无效自变量，将立即引发异常，此操作内。 例如，I/O 请求过程中的磁盘故障异步追加请求过程中发生的错误将导致在时引发异常<xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>调用方法。</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "新的基序列号。 指定的序列号必须大于或等于当前基序列号。"
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> ，它包含应当用于此重新开始区域的保留。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "重新开始区域写入的序列号。"
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "写入重新开始区域时出现 I/O 错误。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列无法获得足够的可用空间以包含新的重新开始区域。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "当在派生类中重写时写入重新开始区域写入<xref href=&quot;System.IO.Log.IRecordSequence&quot;></xref>使用的保留，并更新基序列号。"
  remarks: "重新开始区域用于临时存储包含客户端的最后一个检查点操作的信息。 需要恢复时，你可以分析重新开始区域，以最后一个检查点操作中检索所有数据。 此数据将初始化事务表、 脏页表和打开文件表，以便它们可以用于恢复过程。 可以使用读取重新开始区域<xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       重新开始区域写入时，字节数组段中的数据将连接成单个字节数组，以便以记录形式追加。 数据将重新拆分为数组段读取重新开始区域时不进行任何设置。       如果指定了保留，写入的重新开始区域将占用先前已保留，使用集合中包含的保留的空间。 如果该方法成功，它将占用能容纳数据，并保留将从集合中移除的最小保留。       此方法成功完成时，基序列号已更新。 其所有日志记录序列号小于新的基序列号都不可访问。       如果记录序列已经释放，或者如果传递了无效自变量，将立即引发异常，此操作内。 例如，I/O 请求过程中的磁盘故障异步追加请求过程中发生的错误将导致在时引发异常<xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>调用方法。</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "将连接在一起并以记录形式追加的字节数组段的列表。"
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "新的基序列号。 指定的序列号必须大于或等于当前基序列号。"
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> ，它包含应当用于此重新开始区域的保留。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "重新开始区域写入的序列号。"
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一个或多个参数无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "写入重新开始区域时出现 I/O 错误。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "记录序列无法获得足够的可用空间以包含新的重新开始区域。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "该方法是序列已释放之后调用的。"
  platform:
  - net462
references:
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IO.Log.SequenceFullException
  parent: System.IO.Log
  isExternal: false
  name: SequenceFullException
  nameWithType: SequenceFullException
  fullName: System.IO.Log.SequenceFullException
- uid: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
- uid: System.IO.Log.SequenceNumber
  parent: System.IO.Log
  isExternal: false
  name: SequenceNumber
  nameWithType: SequenceNumber
  fullName: System.IO.Log.SequenceNumber
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.ArraySegment{System.Byte}
  parent: System
  isExternal: true
  name: ArraySegment<Byte>
  nameWithType: ArraySegment<Byte>
  fullName: System.ArraySegment<System.Byte>
  spec.csharp:
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.RecordAppendOptions
  parent: System.IO.Log
  isExternal: false
  name: RecordAppendOptions
  nameWithType: RecordAppendOptions
  fullName: System.IO.Log.RecordAppendOptions
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
  parent: System.Collections.Generic
  isExternal: true
  name: IList<ArraySegment<Byte>>
  nameWithType: IList<ArraySegment<Byte>>
  fullName: System.Collections.Generic.IList<System.ArraySegment<System.Byte>>
  spec.csharp:
  - uid: System.Collections.Generic.IList`1
    name: IList
    nameWithType: IList
    fullName: IList<System.ArraySegment<System.Byte>>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.ReservationCollection
  parent: System.IO.Log
  isExternal: false
  name: ReservationCollection
  nameWithType: ReservationCollection
  fullName: System.IO.Log.ReservationCollection
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.IRecordSequence.BaseSequenceNumber
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: IRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.IRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.Int64[]
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64[]
  spec.csharp:
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: Int64[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.CreateReservationCollection
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: CreateReservationCollection()
  nameWithType: IRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.IRecordSequence.CreateReservationCollection()
- uid: System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndAppend(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndFlush(IAsyncResult)
  nameWithType: IRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndFlush(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndReserveAndAppend(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: IRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndWriteRestartArea(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.Flush
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Flush()
  nameWithType: IRecordSequence.Flush()
  fullName: System.IO.Log.IRecordSequence.Flush()
- uid: System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Flush(SequenceNumber)
  nameWithType: IRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.Flush(SequenceNumber)
- uid: System.IO.Log.IRecordSequence.LastSequenceNumber
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: IRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.IRecordSequence.LastSequenceNumber
- uid: System.IO.Log.IRecordSequence.MaximumRecordLength
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: IRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.IRecordSequence.MaximumRecordLength
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
- uid: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<LogRecord>
  nameWithType: IEnumerable<LogRecord>
  fullName: System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.IO.Log.LogRecord>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.LogRecord
    name: LogRecord
    nameWithType: LogRecord
    fullName: LogRecord
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordEnumeratorType
  parent: System.IO.Log
  isExternal: false
  name: LogRecordEnumeratorType
  nameWithType: LogRecordEnumeratorType
  fullName: System.IO.Log.LogRecordEnumeratorType
- uid: System.IO.Log.IRecordSequence.ReadRestartAreas
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadRestartAreas()
  nameWithType: IRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.IRecordSequence.ReadRestartAreas()
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.IRecordSequence.ReservedBytes
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: IRecordSequence.ReservedBytes
  fullName: System.IO.Log.IRecordSequence.ReservedBytes
- uid: System.IO.Log.IRecordSequence.RestartSequenceNumber
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: IRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.IRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.IRecordSequence.RetryAppend
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: IRecordSequence.RetryAppend
  fullName: System.IO.Log.IRecordSequence.RetryAppend
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.Log.IRecordSequence.TailPinned
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: TailPinned
  nameWithType: IRecordSequence.TailPinned
  fullName: System.IO.Log.IRecordSequence.TailPinned
- uid: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<TailPinnedEventArgs>
  nameWithType: EventHandler<TailPinnedEventArgs>
  fullName: System.EventHandler<System.IO.Log.TailPinnedEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.IO.Log.TailPinnedEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.TailPinnedEventArgs
    name: TailPinnedEventArgs
    nameWithType: TailPinnedEventArgs
    fullName: TailPinnedEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber
  nameWithType: IRecordSequence.AdvanceBaseSequenceNumber
- uid: System.IO.Log.IRecordSequence.Append*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append
  nameWithType: IRecordSequence.Append
- uid: System.IO.Log.IRecordSequence.BaseSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: IRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.IRecordSequence.BeginAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend
  nameWithType: IRecordSequence.BeginAppend
- uid: System.IO.Log.IRecordSequence.BeginFlush*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginFlush
  nameWithType: IRecordSequence.BeginFlush
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginReserveAndAppend
  nameWithType: IRecordSequence.BeginReserveAndAppend
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginWriteRestartArea
  nameWithType: IRecordSequence.BeginWriteRestartArea
- uid: System.IO.Log.IRecordSequence.CreateReservationCollection*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: CreateReservationCollection
  nameWithType: IRecordSequence.CreateReservationCollection
- uid: System.IO.Log.IRecordSequence.EndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndAppend
  nameWithType: IRecordSequence.EndAppend
- uid: System.IO.Log.IRecordSequence.EndFlush*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndFlush
  nameWithType: IRecordSequence.EndFlush
- uid: System.IO.Log.IRecordSequence.EndReserveAndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndReserveAndAppend
  nameWithType: IRecordSequence.EndReserveAndAppend
- uid: System.IO.Log.IRecordSequence.EndWriteRestartArea*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndWriteRestartArea
  nameWithType: IRecordSequence.EndWriteRestartArea
- uid: System.IO.Log.IRecordSequence.Flush*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Flush
  nameWithType: IRecordSequence.Flush
- uid: System.IO.Log.IRecordSequence.LastSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: IRecordSequence.LastSequenceNumber
- uid: System.IO.Log.IRecordSequence.MaximumRecordLength*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: IRecordSequence.MaximumRecordLength
- uid: System.IO.Log.IRecordSequence.ReadLogRecords*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadLogRecords
  nameWithType: IRecordSequence.ReadLogRecords
- uid: System.IO.Log.IRecordSequence.ReadRestartAreas*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadRestartAreas
  nameWithType: IRecordSequence.ReadRestartAreas
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReserveAndAppend
  nameWithType: IRecordSequence.ReserveAndAppend
- uid: System.IO.Log.IRecordSequence.ReservedBytes*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: IRecordSequence.ReservedBytes
- uid: System.IO.Log.IRecordSequence.RestartSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: IRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.IRecordSequence.RetryAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: IRecordSequence.RetryAppend
- uid: System.IO.Log.IRecordSequence.WriteRestartArea*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea
  nameWithType: IRecordSequence.WriteRestartArea
