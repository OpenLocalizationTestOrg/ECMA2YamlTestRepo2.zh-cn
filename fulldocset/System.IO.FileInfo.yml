### YamlMime:ManagedReference
items:
- uid: System.IO.FileInfo
  id: FileInfo
  children:
  - System.IO.FileInfo.#ctor(System.String)
  - System.IO.FileInfo.AppendText
  - System.IO.FileInfo.CopyTo(System.String)
  - System.IO.FileInfo.CopyTo(System.String,System.Boolean)
  - System.IO.FileInfo.Create
  - System.IO.FileInfo.CreateText
  - System.IO.FileInfo.Decrypt
  - System.IO.FileInfo.Delete
  - System.IO.FileInfo.Directory
  - System.IO.FileInfo.DirectoryName
  - System.IO.FileInfo.Encrypt
  - System.IO.FileInfo.Exists
  - System.IO.FileInfo.GetAccessControl
  - System.IO.FileInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)
  - System.IO.FileInfo.IsReadOnly
  - System.IO.FileInfo.Length
  - System.IO.FileInfo.MoveTo(System.String)
  - System.IO.FileInfo.Name
  - System.IO.FileInfo.Open(System.IO.FileMode)
  - System.IO.FileInfo.Open(System.IO.FileMode,System.IO.FileAccess)
  - System.IO.FileInfo.Open(System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  - System.IO.FileInfo.OpenRead
  - System.IO.FileInfo.OpenText
  - System.IO.FileInfo.OpenWrite
  - System.IO.FileInfo.Replace(System.String,System.String)
  - System.IO.FileInfo.Replace(System.String,System.String,System.Boolean)
  - System.IO.FileInfo.SetAccessControl(System.Security.AccessControl.FileSecurity)
  - System.IO.FileInfo.ToString
  langs:
  - csharp
  name: FileInfo
  nameWithType: FileInfo
  fullName: System.IO.FileInfo
  type: Class
  summary: "提供属性和实例方法，用于创建、 复制、 删除、 移动和打开的文件，并协助创建<xref href=&quot;System.IO.FileStream&quot;></xref>对象。 此类不能被继承。       若要浏览此类型的.NET Framework 源代码，请参阅[引用源](http://referencesource.microsoft.com/#mscorlib/system/io/fileinfo.cs#4ee673c1a4ecad41)。"
  remarks: "> [!NOTE]\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/io/fileinfo.cs#4ee673c1a4ecad41). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \n  \n Use the FileInfo class for typical operations such as copying, moving, renaming, creating, opening, deleting, and appending to files.  \n  \n If you are performing multiple operations on the same file, it can be more efficient to use FileInfo instance methods instead of the corresponding static methods of the <xref:System.IO.File> class, because a security check will not always be necessary.  \n  \n Many of the FileInfo methods return other I/O types when you create or open files. You can use these other types to further manipulate a file. For more information, see specific FileInfo members such as <xref:System.IO.FileInfo.Open%2A>, <xref:System.IO.FileInfo.OpenRead%2A>, <xref:System.IO.FileInfo.OpenText%2A>, <xref:System.IO.FileInfo.CreateText%2A>, or <xref:System.IO.FileInfo.Create%2A>.  \n  \n By default, full read/write access to new files is granted to all users.  \n  \n The following table describes the enumerations that are used to customize the behavior of various FileInfo methods.  \n  \n|Enumeration|Description|  \n|-----------------|-----------------|  \n|<xref:System.IO.FileAccess>|Specifies read and write access to a file.|  \n|<xref:System.IO.FileShare>|Specifies the level of access permitted for a file that is already in use.|  \n|<xref:System.IO.FileMode>|Specifies whether the contents of an existing file are preserved or overwritten, and whether requests to create an existing file cause an exception.|  \n  \n> [!NOTE]\n>  In members that accept a path as an input string, that path must be well-formed or an exception is raised. For example, if a path is fully qualified but begins with a space, the path is not trimmed in methods of the class. Therefore, the path is malformed and an exception is raised. Similarly, a path or a combination of paths cannot be fully qualified twice. For example, \"c:\\temp c:\\windows\" also raises an exception in most cases. Ensure that your paths are well-formed when using methods that accept a path string.  \n  \n In members that accept a path, the path can refer to a file or just a directory. The specified path can also refer to a relative path or a Universal Naming Convention (UNC) path for a server and share name. For example, all the following are acceptable paths:  \n  \n-   \"c:\\\\\\MyDir\\\\\\MyFile.txt\" in C#, or \"c:\\MyDir\\MyFile.txt\" in Visual Basic.  \n  \n-   \"c:\\\\\\MyDir\" in C#, or \"c:\\MyDir\" in Visual Basic.  \n  \n-   \"MyDir\\\\\\MySubdir\" in C#, or \"MyDir\\MySubDir\" in Visual Basic.  \n  \n-   \"\\\\\\\\\\\\\\MyServer\\\\\\MyShare\" in C#, or \"\\\\\\MyServer\\MyShare\" in Visual Basic.  \n  \n The FileInfo class provides the following properties that enable you to retrieve information about a file. For an example of how to use each property, see the property pages.  \n  \n-   The <xref:System.IO.FileInfo.Directory%2A> property retrieves an object that represents the parent directory of a file.  \n  \n-   The <xref:System.IO.FileInfo.DirectoryName%2A> property retrieves the full path of the parent directory of a file.  \n  \n-   The <xref:System.IO.FileInfo.Exists%2A> property checks for the presence of a file before operating on it.  \n  \n-   The <xref:System.IO.FileInfo.IsReadOnly%2A> property retrieves or sets a value that specifies whether a file can be modified.  \n  \n-   The <xref:System.IO.FileInfo.Length%2A> retrieves the size of a file.  \n  \n-   The <xref:System.IO.FileInfo.Name%2A> retrieves the name of a file."
  example:
  - "The following example demonstrates some of the main members of the `FileInfo` class.  \n  \n When the properties are first retrieved, FileInfo calls the <xref:System.IO.FileSystemInfo.Refresh%2A> method and caches information about the file. On subsequent calls, you must call <xref:System.IO.FileSystemInfo.Refresh%2A> to get the latest copy of the information.  \n  \n [!code-cs[FInfo Class#1](~/add/codesnippet/csharp/t-system.io.fileinfo_1.cs)]\n [!code-cpp[FInfo Class#1](~/add/codesnippet/cpp/t-system.io.fileinfo_1.cpp)]\n [!code-vb[FInfo Class#1](~/add/codesnippet/visualbasic/t-system.io.fileinfo_1.vb)]  \n  \n This example produces output similar to the following.  \n  \n```  \nHello  \nAnd  \nWelcome  \nC:\\Users\\userName\\AppData\\Local\\Temp\\tmp70AB.tmp was copied to C:\\Users\\userName\\AppData\\Local\\Temp\\tmp70CB.tmp.  \nC:\\Users\\userName\\AppData\\Local\\Temp\\tmp70CB.tmp was successfully deleted.  \n```"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class FileInfo : System.IO.FileSystemInfo
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.IO.FileSystemInfo
  implements: []
  inheritedMembers:
  - System.IO.FileSystemInfo.Attributes
  - System.IO.FileSystemInfo.CreationTime
  - System.IO.FileSystemInfo.CreationTimeUtc
  - System.IO.FileSystemInfo.Extension
  - System.IO.FileSystemInfo.FullName
  - System.IO.FileSystemInfo.FullPath
  - System.IO.FileSystemInfo.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.IO.FileSystemInfo.LastAccessTime
  - System.IO.FileSystemInfo.LastAccessTimeUtc
  - System.IO.FileSystemInfo.LastWriteTime
  - System.IO.FileSystemInfo.LastWriteTimeUtc
  - System.IO.FileSystemInfo.OriginalPath
  - System.IO.FileSystemInfo.Refresh
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.IO.FileInfo.#ctor(System.String)
  id: '#ctor(System.String)'
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: FileInfo(String)
  nameWithType: FileInfo.FileInfo(String)
  fullName: System.IO.FileInfo.FileInfo(String)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新实例<xref href=&quot;System.IO.FileInfo&quot;></xref>类，该类作为文件路径的包装。"
  remarks: "您可以指定完全限定或相对文件名，但安全检查获取完全限定的名称。"
  example:
  - "The following example uses this constructor to create two files, which are then written to, read from, copied, and deleted.  \n  \n [!code-cpp[finfo ctor#1](~/add/codesnippet/cpp/m-system.io.fileinfo.sha_1.cpp)]\n [!code-cs[finfo ctor#1](~/add/codesnippet/csharp/m-system.io.fileinfo.sha_1.cs)]\n [!code-vb[finfo ctor#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.sha_1.vb)]  \n  \n The following example opens an existing file or creates a file, appends text to the file, and displays the results.  \n  \n [!code-cpp[fileinfomain#1](~/add/codesnippet/cpp/m-system.io.fileinfo.sha_2.cpp)]\n [!code-cs[fileinfomain#1](~/add/codesnippet/csharp/m-system.io.fileinfo.sha_2.cs)]\n [!code-vb[fileinfomain#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.sha_2.vb)]"
  syntax:
    content: public FileInfo (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "新的文件的完全限定的名或相对文件名。 不要结尾的路径以目录分隔符字符。"
  overload: System.IO.FileInfo.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>fileName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "文件名称为空，仅包含空格，或包含无效字符。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "访问<code> fileName </code>被拒绝。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>fileName</code>包含在字符串中间一个冒号 （:）。"
  platform:
  - net462
- uid: System.IO.FileInfo.AppendText
  id: AppendText
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: AppendText()
  nameWithType: FileInfo.AppendText()
  fullName: System.IO.FileInfo.AppendText()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "创建<xref:System.IO.StreamWriter>，它将文本追加到文件的此实例所表示<xref href=&quot;System.IO.FileInfo&quot;> </xref>。</xref:System.IO.StreamWriter>"
  remarks: ''
  example:
  - "The following example appends text to a file and reads from the file.  \n  \n [!code-vb[finfo appendtext#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.app_1.vb)]\n [!code-cpp[finfo appendtext#1](~/add/codesnippet/cpp/m-system.io.fileinfo.app_1.cpp)]\n [!code-cs[finfo appendtext#1](~/add/codesnippet/csharp/m-system.io.fileinfo.app_1.cs)]  \n  \n The following example demonstrates appending text to the end of a file and also displays the result of the append operation to the console. The first time this routine is called, the file is created if it does not exist. After that, the specified text is appended to the file.  \n  \n [!code-vb[fileinfoappendtext#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.app_2.vb)]\n [!code-cpp[fileinfoappendtext#1](~/add/codesnippet/cpp/m-system.io.fileinfo.app_2.cpp)]\n [!code-cs[fileinfoappendtext#1](~/add/codesnippet/csharp/m-system.io.fileinfo.app_2.cs)]"
  syntax:
    content: public System.IO.StreamWriter AppendText ();
    parameters: []
    return:
      type: System.IO.StreamWriter
      description: "A new <xref uid=&quot;langword_csharp_StreamWriter&quot; name=&quot;StreamWriter&quot; href=&quot;&quot;></xref>."
  overload: System.IO.FileInfo.AppendText*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileInfo.CopyTo(System.String)
  id: CopyTo(System.String)
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: CopyTo(String)
  nameWithType: FileInfo.CopyTo(String)
  fullName: System.IO.FileInfo.CopyTo(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "将现有文件复制到新文件，不允许覆盖现有文件。"
  remarks: "使用<xref:System.IO.FileInfo.CopyTo%2A>方法，以便允许覆盖现有文件。</xref:System.IO.FileInfo.CopyTo%2A>      1> [!CAUTION]&1;> 只要有可能，避免使用此方法使用短文件名 （如 XXXXXX~1.XXX)。 如果两个文件都有等效项短文件名，则此方法可能失败并引发异常和/或导致意外行为"
  example:
  - "The following example demonstrates both overloads of the `CopyTo` method.  \n  \n [!code-cpp[finfo copyto2#1](~/add/codesnippet/cpp/m-system.io.fileinfo.cop_1_1.cpp)]\n [!code-cs[finfo copyto2#1](~/add/codesnippet/csharp/m-system.io.fileinfo.cop_1_1.cs)]\n [!code-vb[finfo copyto2#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.cop_1_1.vb)]  \n  \n The following example demonstrates copying one file to another file, throwing an exception if the destination file already exists.  \n  \n [!code-cpp[FileInfoCopyTo1#1](~/add/codesnippet/cpp/m-system.io.fileinfo.cop_1_2.cpp)]\n [!code-cs[FileInfoCopyTo1#1](~/add/codesnippet/csharp/m-system.io.fileinfo.cop_1_2.cs)]\n [!code-vb[FileInfoCopyTo1#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.cop_1_2.vb)]"
  syntax:
    content: public System.IO.FileInfo CopyTo (string destFileName);
    parameters:
    - id: destFileName
      type: System.String
      description: "要将复制到新文件的名称。"
    return:
      type: System.IO.FileInfo
      description: "带有完全限定路径的新文件。"
  overload: System.IO.FileInfo.CopyTo*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>destFileName</code>为空，仅包含空格，或包含无效字符。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "发生错误，或目标文件已存在。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>destFileName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "在中，传入一个目录路径或文件将被移至其他驱动器。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "中指定的目录<code> destFileName </code>不存在。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>destFileName</code>包含冒号 （:） 字符串内的，但未指定该卷。"
  platform:
  - net462
- uid: System.IO.FileInfo.CopyTo(System.String,System.Boolean)
  id: CopyTo(System.String,System.Boolean)
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: CopyTo(String,Boolean)
  nameWithType: FileInfo.CopyTo(String,Boolean)
  fullName: System.IO.FileInfo.CopyTo(String,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "将现有文件复制到新文件，允许覆盖现有文件。"
  remarks: "使用此方法允许或阻止覆盖现有文件。 使用<xref:System.IO.FileInfo.CopyTo%2A>方法，以防止覆盖现有文件的默认情况下。</xref:System.IO.FileInfo.CopyTo%2A>      1> [!CAUTION]&1;> 只要有可能，避免使用此方法使用短文件名 （如 XXXXXX~1.XXX)。 如果两个文件都有等效项短文件名，则此方法可能失败并引发异常和/或导致意外行为"
  example:
  - "The following example demonstrates both overloads of the `CopyTo` method.  \n  \n [!code-cpp[finfo copyto2#1](~/add/codesnippet/cpp/m-system.io.fileinfo.cop_0_1.cpp)]\n [!code-cs[finfo copyto2#1](~/add/codesnippet/csharp/m-system.io.fileinfo.cop_0_1.cs)]\n [!code-vb[finfo copyto2#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.cop_0_1.vb)]  \n  \n The following example demonstrates copying one file to another file, specifying whether to overwrite a file that already exists.  \n  \n [!code-cs[fileinfocopyto#1](~/add/codesnippet/csharp/m-system.io.fileinfo.cop_0_2.cs)]\n [!code-cpp[fileinfocopyto#1](~/add/codesnippet/cpp/m-system.io.fileinfo.cop_0_2.cpp)]\n [!code-vb[fileinfocopyto#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.cop_0_2.vb)]"
  syntax:
    content: public System.IO.FileInfo CopyTo (string destFileName, bool overwrite);
    parameters:
    - id: destFileName
      type: System.String
      description: "要将复制到新文件的名称。"
    - id: overwrite
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要允许覆盖; 现有文件否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.IO.FileInfo
      description: "一个新的文件或覆盖现有文件如果<code> overwrite </code>是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。 如果该文件存在和<code> overwrite </code>是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>、<xref:System.IO.IOException>引发。</xref:System.IO.IOException>"
  overload: System.IO.FileInfo.CopyTo*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>destFileName</code>为空，仅包含空格，或包含无效字符。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "发生错误，或目标文件已存在和<code> overwrite </code>是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>destFileName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "中指定的目录<code> destFileName </code>不存在。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "在中，传入一个目录路径或文件将被移至其他驱动器。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>destFileName</code>包含在字符串中间一个冒号 （:）。"
  platform:
  - net462
- uid: System.IO.FileInfo.Create
  id: Create
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: Create()
  nameWithType: FileInfo.Create()
  fullName: System.IO.FileInfo.Create()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "创建一个文件。"
  remarks: "默认情况下，对新文件的完全读/写访问权限授予所有用户。       此方法是<xref:System.IO.File.Create%2A?displayProperty=fullName>.</xref:System.IO.File.Create%2A?displayProperty=fullName>提供的功能的包装器"
  example:
  - "The following example creates a reference to a file, and then creates the file on disk using `FileInfo.Create()`.  \n  \n [!code-cpp[fileinfodelete#1](~/add/codesnippet/cpp/m-system.io.fileinfo.cre_0_1.cpp)]\n [!code-vb[fileinfodelete#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.cre_0_1.vb)]\n [!code-cs[fileinfodelete#1](~/add/codesnippet/csharp/m-system.io.fileinfo.cre_0_1.cs)]  \n  \n The following example creates a file, adds some text to it, and reads from the file.  \n  \n [!code-vb[finfo create#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.cre_0_2.vb)]\n [!code-cs[finfo create#1](~/add/codesnippet/csharp/m-system.io.fileinfo.cre_0_2.cs)]\n [!code-cpp[finfo create#1](~/add/codesnippet/cpp/m-system.io.fileinfo.cre_0_2.cpp)]"
  syntax:
    content: public System.IO.FileStream Create ();
    parameters: []
    return:
      type: System.IO.FileStream
      description: "新的文件。"
  overload: System.IO.FileInfo.Create*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileInfo.CreateText
  id: CreateText
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: CreateText()
  nameWithType: FileInfo.CreateText()
  fullName: System.IO.FileInfo.CreateText()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "创建<xref:System.IO.StreamWriter>写入新文本文件。</xref:System.IO.StreamWriter>"
  remarks: "默认情况下，对新文件的完全读/写访问权限授予所有用户。"
  example:
  - "The following example demonstrates the `CreateText` method.  \n  \n [!code-cpp[finfo createtext#1](~/add/codesnippet/cpp/m-system.io.fileinfo.cre_1_1.cpp)]\n [!code-vb[finfo createtext#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.cre_1_1.vb)]\n [!code-cs[finfo createtext#1](~/add/codesnippet/csharp/m-system.io.fileinfo.cre_1_1.cs)]"
  syntax:
    content: public System.IO.StreamWriter CreateText ();
    parameters: []
    return:
      type: System.IO.StreamWriter
      description: "A new <xref uid=&quot;langword_csharp_StreamWriter&quot; name=&quot;StreamWriter&quot; href=&quot;&quot;></xref>."
  overload: System.IO.FileInfo.CreateText*
  exceptions:
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "文件名称是一个目录。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "磁盘是只读的。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  platform:
  - net462
- uid: System.IO.FileInfo.Decrypt
  id: Decrypt
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: Decrypt()
  nameWithType: FileInfo.Decrypt()
  fullName: System.IO.FileInfo.Decrypt()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "解密由当前帐户使用加密的文件<xref:System.IO.FileInfo.Encrypt*>方法。</xref:System.IO.FileInfo.Encrypt*>"
  remarks: "解密方法允许你使用加密文件进行解密<xref:System.IO.FileInfo.Encrypt%2A>方法。</xref:System.IO.FileInfo.Encrypt%2A>  解密方法可以解密使用当前用户帐户加密的文件。       同时<xref:System.IO.FileInfo.Encrypt%2A>方法和解密方法使用安装在计算机和调用方法的过程的文件加密密钥的加密服务提供程序 (CSP)。</xref:System.IO.FileInfo.Encrypt%2A>       当前的文件系统必须格式化为 NTFS 和当前的操作系统必须是 Microsoft Windows NT 或更高版本。"
  example:
  - "The following code example uses the <xref:System.IO.FileInfo.Encrypt%2A> method and the Decrypt method to encrypt and then decrypt a file.  \n  \n [!code-cpp[IO.FileInfo.Encrypt-Decrypt#1](~/add/codesnippet/cpp/m-system.io.fileinfo.dec_1.cpp)]\n [!code-cs[IO.FileInfo.Encrypt-Decrypt#1](~/add/codesnippet/csharp/m-system.io.fileinfo.dec_1.cs)]\n [!code-vb[IO.FileInfo.Encrypt-Decrypt#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.dec_1.vb)]"
  syntax:
    content: public void Decrypt ();
    parameters: []
  overload: System.IO.FileInfo.Decrypt*
  exceptions:
  - type: System.IO.DriveNotFoundException
    commentId: T:System.IO.DriveNotFoundException
    description: "指定了无效的驱动器。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "当前所描述的文件<xref href=&quot;System.IO.FileInfo&quot;></xref>找不到对象。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "打开文件时发生 I/O 错误。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "文件系统不是 NTFS。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "当前操作系统不是 Microsoft Windows NT 或更高版本。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "当前所描述的文件<xref href=&quot;System.IO.FileInfo&quot;></xref>对象是只读的。       -或者-当前平台上不支持此操作。       -或者-调用方没有所要求的权限。"
  platform:
  - net462
- uid: System.IO.FileInfo.Delete
  id: Delete
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: Delete()
  nameWithType: FileInfo.Delete()
  fullName: System.IO.FileInfo.Delete()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "永久删除的文件。"
  remarks: "如果文件不存在，则此方法没有任何影响。"
  example:
  - "The following example demonstrates the `Delete` method.  \n  \n [!code-cpp[finfo delete#1](~/add/codesnippet/cpp/m-system.io.fileinfo.del_1.cpp)]\n [!code-cs[finfo delete#1](~/add/codesnippet/csharp/m-system.io.fileinfo.del_1.cs)]\n [!code-vb[finfo delete#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.del_1.vb)]  \n  \n The following example creates, closes, and deletes a file.  \n  \n [!code-cpp[fileinfodelete#1](~/add/codesnippet/cpp/m-system.io.fileinfo.del_2.cpp)]\n [!code-vb[fileinfodelete#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.del_2.vb)]\n [!code-cs[fileinfodelete#1](~/add/codesnippet/csharp/m-system.io.fileinfo.del_2.cs)]"
  syntax:
    content: public override void Delete ();
    parameters: []
  overload: System.IO.FileInfo.Delete*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "目标文件已打开或运行 Microsoft Windows NT 的计算机上的内存映射。       -或-该文件，打开句柄并且操作系统是 Windows XP 或更早版本。 枚举目录和文件，则可能会导致此开放句柄。 有关详细信息，请参阅[如何︰ 枚举目录和文件](~/add/includes/ajax-current-ext-md.md)。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "路径是目录。"
  platform:
  - net462
- uid: System.IO.FileInfo.Directory
  id: Directory
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: Directory
  nameWithType: FileInfo.Directory
  fullName: System.IO.FileInfo.Directory
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "获取父目录的实例。"
  remarks: "若要获取字符串形式的父目录，请使用<xref:System.IO.FileInfo.DirectoryName%2A>属性。</xref:System.IO.FileInfo.DirectoryName%2A>"
  example:
  - "The following example opens or creates a file, determines its full path, and determines and displays the full contents of the directory.  \n  \n [!code-cs[fileinfodirectory#1](~/add/codesnippet/csharp/p-system.io.fileinfo.dir_0_1.cs)]\n [!code-vb[fileinfodirectory#1](~/add/codesnippet/visualbasic/p-system.io.fileinfo.dir_0_1.vb)]\n [!code-cpp[fileinfodirectory#1](~/add/codesnippet/cpp/p-system.io.fileinfo.dir_0_1.cpp)]"
  syntax:
    content: public System.IO.DirectoryInfo Directory { get; }
    return:
      type: System.IO.DirectoryInfo
      description: "A <xref href=&quot;System.IO.DirectoryInfo&quot;> </xref>对象，表示此文件的父目录。"
  overload: System.IO.FileInfo.Directory*
  exceptions:
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路径无效，例如位于未映射的驱动器上。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  platform:
  - net462
- uid: System.IO.FileInfo.DirectoryName
  id: DirectoryName
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: DirectoryName
  nameWithType: FileInfo.DirectoryName
  fullName: System.IO.FileInfo.DirectoryName
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "获取表示目录的完整路径的字符串。"
  remarks: "若要获取形式的父目录<xref:System.IO.DirectoryInfo>对象，请使用<xref:System.IO.FileInfo.Directory%2A>属性。</xref:System.IO.FileInfo.Directory%2A> </xref:System.IO.DirectoryInfo>       当第一次调用，<xref:System.IO.FileInfo>调用<xref:System.IO.FileSystemInfo.Refresh%2A>和缓存文件的信息。</xref:System.IO.FileSystemInfo.Refresh%2A> </xref:System.IO.FileInfo> 在后续调用中，必须调用<xref:System.IO.FileSystemInfo.Refresh%2A>以获取信息的最新副本。</xref:System.IO.FileSystemInfo.Refresh%2A>"
  example:
  - "The following example retrieves the full path of the specified file.  \n  \n [!code-cs[System.IO.FileInfo members#3](~/add/codesnippet/csharp/p-system.io.fileinfo.dir_1_1.cs)]\n [!code-cpp[System.IO.FileInfo members#3](~/add/codesnippet/cpp/p-system.io.fileinfo.dir_1_1.cpp)]\n [!code-vb[System.IO.FileInfo members#3](~/add/codesnippet/visualbasic/p-system.io.fileinfo.dir_1_1.vb)]"
  syntax:
    content: public string DirectoryName { get; }
    return:
      type: System.String
      description: "表示目录的完整路径的字符串。"
  overload: System.IO.FileInfo.DirectoryName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>传入的目录名称。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "完全限定的路径为 260 或更多个字符。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  platform:
  - net462
- uid: System.IO.FileInfo.Encrypt
  id: Encrypt
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: Encrypt()
  nameWithType: FileInfo.Encrypt()
  fullName: System.IO.FileInfo.Encrypt()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "将某个文件加密，使得只有用于加密该文件的帐户可以对其进行解密。"
  remarks: "加密方法允许你的文件进行加密，使得仅用来调用此方法的帐户可以对其进行解密。  使用<xref:System.IO.FileInfo.Decrypt%2A>方法以解密加密的加密方法的文件。</xref:System.IO.FileInfo.Decrypt%2A>       这两种加密方法和<xref:System.IO.FileInfo.Decrypt%2A>方法使用安装在计算机和调用方法的过程的文件加密密钥的加密服务提供程序 (CSP)。</xref:System.IO.FileInfo.Decrypt%2A>       当前的文件系统必须格式化为 NTFS 和当前的操作系统必须是 Microsoft Windows NT 或更高版本。"
  example:
  - "The following code example uses the Encrypt method and the <xref:System.IO.FileInfo.Decrypt%2A> method to encrypt a file and then decrypt it.  \n  \n [!code-cpp[IO.FileInfo.Encrypt-Decrypt#1](~/add/codesnippet/cpp/m-system.io.fileinfo.enc_1.cpp)]\n [!code-cs[IO.FileInfo.Encrypt-Decrypt#1](~/add/codesnippet/csharp/m-system.io.fileinfo.enc_1.cs)]\n [!code-vb[IO.FileInfo.Encrypt-Decrypt#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.enc_1.vb)]"
  syntax:
    content: public void Encrypt ();
    parameters: []
  overload: System.IO.FileInfo.Encrypt*
  exceptions:
  - type: System.IO.DriveNotFoundException
    commentId: T:System.IO.DriveNotFoundException
    description: "指定了无效的驱动器。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "当前所描述的文件<xref href=&quot;System.IO.FileInfo&quot;></xref>找不到对象。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "打开文件时发生 I/O 错误。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "文件系统不是 NTFS。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "当前操作系统不是 Microsoft Windows NT 或更高版本。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "当前所描述的文件<xref href=&quot;System.IO.FileInfo&quot;></xref>对象是只读的。       -或者-当前平台上不支持此操作。       -或者-调用方没有所要求的权限。"
  platform:
  - net462
- uid: System.IO.FileInfo.Exists
  id: Exists
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: Exists
  nameWithType: FileInfo.Exists
  fullName: System.IO.FileInfo.Exists
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "获取一个值，该值指示文件是否存在。"
  remarks: "当第一次调用，<xref:System.IO.FileInfo>调用<xref:System.IO.FileSystemInfo.Refresh%2A>和缓存文件的信息。</xref:System.IO.FileSystemInfo.Refresh%2A> </xref:System.IO.FileInfo> 在后续调用中，必须调用<xref:System.IO.FileSystemInfo.Refresh%2A>以获取信息的最新副本。</xref:System.IO.FileSystemInfo.Refresh%2A>       Exists 属性返回`false`如果在尝试确定指定的文件是否存在任何错误时发生。 在引发异常，例如传递具有无效的字符或太多字符，磁盘失效或缺失的文件名的情况下可能发生这或如果调用方没有权限读取此文件。"
  example:
  - "The following code example uses the Exists property ensure a file exists before opening it.  You can use this technique to throw a custom exception when the file is not found.  \n  \n [!code-cpp[IO.FileInfo.Exists#1](~/add/codesnippet/cpp/p-system.io.fileinfo.exi_1.cpp)]\n [!code-cs[IO.FileInfo.Exists#1](~/add/codesnippet/csharp/p-system.io.fileinfo.exi_1.cs)]\n [!code-vb[IO.FileInfo.Exists#1](~/add/codesnippet/visualbasic/p-system.io.fileinfo.exi_1.vb)]"
  syntax:
    content: public override bool Exists { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果该文件存在;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>如果文件不存在或该文件是一个目录。"
  overload: System.IO.FileInfo.Exists*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileInfo.GetAccessControl
  id: GetAccessControl
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: GetAccessControl()
  nameWithType: FileInfo.GetAccessControl()
  fullName: System.IO.FileInfo.GetAccessControl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "获取<xref href=&quot;System.Security.AccessControl.FileSecurity&quot;></xref>对象，它封装由当前所描述的文件的访问控制列表 (ACL) 项<xref href=&quot;System.IO.FileInfo&quot;></xref>对象。"
  remarks: "GetAccessControl 方法用于检索当前文件的访问控制列表 (ACL) 项。       ACL 描述个人和/或组具有或没有执行到给定的文件上的特定操作的权限。 有关详细信息，请参阅[如何︰ 添加或移除访问控制列表项](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example uses the GetAccessControl method and the <xref:System.IO.FileInfo.SetAccessControl%2A> method to add and then remove an access control list (ACL) entry from a file.  You must supply a valid user or group account to run this example.  \n  \n [!code-cpp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/add/codesnippet/cpp/m-system.io.fileinfo.get_1.cpp)]\n [!code-vb[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.get_1.vb)]\n [!code-cs[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/add/codesnippet/csharp/m-system.io.fileinfo.get_1.cs)]"
  syntax:
    content: public System.Security.AccessControl.FileSecurity GetAccessControl ();
    parameters: []
    return:
      type: System.Security.AccessControl.FileSecurity
      description: "A <xref href=&quot;System.Security.AccessControl.FileSecurity&quot;> </xref>对象封装当前文件的访问控制规则。"
  overload: System.IO.FileInfo.GetAccessControl*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "打开文件时发生 I/O 错误。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "当前操作系统不是 Microsoft Windows 2000 或更高版本。"
  - type: System.Security.AccessControl.PrivilegeNotHeldException
    commentId: T:System.Security.AccessControl.PrivilegeNotHeldException
    description: "当前的系统帐户没有管理权限。"
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "找不到该文件。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "当前平台上不支持此操作。       -或者-调用方没有所要求的权限。"
  platform:
  - net462
- uid: System.IO.FileInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)
  id: GetAccessControl(System.Security.AccessControl.AccessControlSections)
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: GetAccessControl(AccessControlSections)
  nameWithType: FileInfo.GetAccessControl(AccessControlSections)
  fullName: System.IO.FileInfo.GetAccessControl(AccessControlSections)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "获取<xref href=&quot;System.Security.AccessControl.FileSecurity&quot;></xref>封装由当前所描述的文件的访问控制列表 (ACL) 项的指定的类型的对象<xref href=&quot;System.IO.FileInfo&quot;></xref>对象。"
  remarks: "GetAccessControl 方法用于检索当前文件的访问控制列表 (ACL) 项。       ACL 描述个人和/或组具有或没有执行到给定的文件上的特定操作的权限。 有关详细信息，请参阅[如何︰ 添加或移除访问控制列表项](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public System.Security.AccessControl.FileSecurity GetAccessControl (System.Security.AccessControl.AccessControlSections includeSections);
    parameters:
    - id: includeSections
      type: System.Security.AccessControl.AccessControlSections
      description: "之一<xref href=&quot;System.Security.AccessControl.AccessControlSections&quot;></xref>值，该值指定组的访问控制项来检索。"
    return:
      type: System.Security.AccessControl.FileSecurity
      description: "A <xref href=&quot;System.Security.AccessControl.FileSecurity&quot;> </xref>对象封装当前文件的访问控制规则。"
  overload: System.IO.FileInfo.GetAccessControl*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "打开文件时发生 I/O 错误。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "当前操作系统不是 Microsoft Windows 2000 或更高版本。"
  - type: System.Security.AccessControl.PrivilegeNotHeldException
    commentId: T:System.Security.AccessControl.PrivilegeNotHeldException
    description: "当前的系统帐户没有管理权限。"
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "找不到该文件。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "当前平台上不支持此操作。       -或者-调用方没有所要求的权限。"
  platform:
  - net462
- uid: System.IO.FileInfo.IsReadOnly
  id: IsReadOnly
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: IsReadOnly
  nameWithType: FileInfo.IsReadOnly
  fullName: System.IO.FileInfo.IsReadOnly
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "获取或设置一个值，确定当前文件为只读。"
  remarks: "IsReadOnly 属性用于快速确定或更改是否当前文件为只读。       当第一次调用，<xref:System.IO.FileInfo>调用<xref:System.IO.FileSystemInfo.Refresh%2A>和缓存文件的信息。</xref:System.IO.FileSystemInfo.Refresh%2A> </xref:System.IO.FileInfo> 在后续调用中，必须调用<xref:System.IO.FileSystemInfo.Refresh%2A>以获取信息的最新副本。</xref:System.IO.FileSystemInfo.Refresh%2A>"
  example:
  - "The following example uses the IsReadOnly property to mark a file as read only and then mark it as read-write.  \n  \n [!code-cs[IO.FileInfo.IsReadOnly#1](~/add/codesnippet/csharp/p-system.io.fileinfo.isr_1.cs)]\n [!code-vb[IO.FileInfo.IsReadOnly#1](~/add/codesnippet/visualbasic/p-system.io.fileinfo.isr_1.vb)]\n [!code-cpp[IO.FileInfo.IsReadOnly#1](~/add/codesnippet/cpp/p-system.io.fileinfo.isr_1.cpp)]"
  syntax:
    content: public bool IsReadOnly { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果当前文件为只读模式;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.FileInfo.IsReadOnly*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "当前所描述的文件<xref href=&quot;System.IO.FileInfo&quot;></xref>找不到对象。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "打开文件时发生 I/O 错误。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "当前平台上不支持此操作。       -或者-调用方没有所要求的权限。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "用户没有写入权限，但尝试将此属性设置为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.IO.FileInfo.Length
  id: Length
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: Length
  nameWithType: FileInfo.Length
  fullName: System.IO.FileInfo.Length
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "获取用字节表示，当前文件的大小。"
  remarks: "Length 属性的值会预先缓存，如果当前实例的<xref:System.IO.FileInfo>从以下任一返回了对象<xref:System.IO.DirectoryInfo>方法:- <xref:System.IO.DirectoryInfo.GetDirectories%2A>- <xref:System.IO.DirectoryInfo.GetFiles%2A>- <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>- <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>- <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>-<xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>若要获取最新值，请调用<xref:System.IO.FileSystemInfo.Refresh%2A>方法。</xref:System.IO.FileSystemInfo.Refresh%2A> </xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> </xref:System.IO.DirectoryInfo.EnumerateFiles%2A> </xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> </xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A> </xref:System.IO.DirectoryInfo.GetFiles%2A> </xref:System.IO.DirectoryInfo.GetDirectories%2A> </xref:System.IO.DirectoryInfo> </xref:System.IO.FileInfo>"
  example:
  - "The following example displays the size of the specified files.  \n  \n [!code-cpp[FileLength#1](~/add/codesnippet/cpp/p-system.io.fileinfo.len_1.cpp)]\n [!code-cs[FileLength#1](~/add/codesnippet/csharp/p-system.io.fileinfo.len_1.cs)]\n [!code-vb[FileLength#1](~/add/codesnippet/visualbasic/p-system.io.fileinfo.len_1.vb)]"
  syntax:
    content: public long Length { get; }
    return:
      type: System.Int64
      description: "以字节为单位的当前文件的大小。"
  overload: System.IO.FileInfo.Length*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<xref:System.IO.FileSystemInfo.Refresh*>无法更新文件或目录的状态。</xref:System.IO.FileSystemInfo.Refresh*>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "该文件不存在。       -或- <xref uid=&quot;langword_csharp_Length&quot; name=&quot;Length&quot; href=&quot;&quot;> </xref>针对某个目录调用属性。"
  platform:
  - net462
- uid: System.IO.FileInfo.MoveTo(System.String)
  id: MoveTo(System.String)
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: MoveTo(String)
  nameWithType: FileInfo.MoveTo(String)
  fullName: System.IO.FileInfo.MoveTo(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "将指定的文件移到新位置，提供要指定新文件名的选项。"
  remarks: "此方法适用于整个磁盘卷。 例如，文件 c:\\MyFile.txt 可以移到 d:\\public，重命名 NewFile.txt。"
  example:
  - "The following example demonstrates moving a file to a different location and renaming the file.  \n  \n [!code-cs[IO.FileInfo.MoveTo#1](~/add/codesnippet/csharp/m-system.io.fileinfo.mov_1.cs)]\n [!code-vb[IO.FileInfo.MoveTo#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.mov_1.vb)]"
  syntax:
    content: public void MoveTo (string destFileName);
    parameters:
    - id: destFileName
      type: System.String
      description: "要将移动路径的文件，可以指定不同的文件名称。"
  overload: System.IO.FileInfo.MoveTo*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "将发生了 I/O 错误，如目标文件已存在或者目标设备尚未准备就绪。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>destFileName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>destFileName</code>为空，仅包含空格，或包含无效字符。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code>destFileName</code>为只读或是目录。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到该文件。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路径无效，例如位于未映射的驱动器上。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>destFileName</code>包含在字符串中间一个冒号 （:）。"
  platform:
  - net462
- uid: System.IO.FileInfo.Name
  id: Name
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: Name
  nameWithType: FileInfo.Name
  fullName: System.IO.FileInfo.Name
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "获取文件的名称。"
  remarks: "当第一次调用，<xref:System.IO.FileInfo>调用<xref:System.IO.FileSystemInfo.Refresh%2A>和缓存文件的信息。</xref:System.IO.FileSystemInfo.Refresh%2A> </xref:System.IO.FileInfo> 在后续调用中，必须调用<xref:System.IO.FileSystemInfo.Refresh%2A>以获取信息的最新副本。</xref:System.IO.FileSystemInfo.Refresh%2A>       文件的名称包括文件扩展名。"
  example:
  - "The following example uses the `Name` property to display the names of files in the current directory.  \n  \n [!code-cs[fileinfoname#1](~/add/codesnippet/csharp/p-system.io.fileinfo.name_1.cs)]\n [!code-cpp[fileinfoname#1](~/add/codesnippet/cpp/p-system.io.fileinfo.name_1.cpp)]\n [!code-vb[fileinfoname#1](~/add/codesnippet/visualbasic/p-system.io.fileinfo.name_1.vb)]"
  syntax:
    content: public override string Name { get; }
    return:
      type: System.String
      description: "文件的名称。"
  overload: System.IO.FileInfo.Name*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileInfo.Open(System.IO.FileMode)
  id: Open(System.IO.FileMode)
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: Open(FileMode)
  nameWithType: FileInfo.Open(FileMode)
  fullName: System.IO.FileInfo.Open(FileMode)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "在指定的模式打开文件。"
  remarks: ''
  example:
  - "The following example opens a file, adds some information to the file, and reads the file.  \n  \n [!code-cs[finfo open1#1](~/add/codesnippet/csharp/m-system.io.fileinfo.ope_0_1.cs)]\n [!code-cpp[finfo open1#1](~/add/codesnippet/cpp/m-system.io.fileinfo.ope_0_1.cpp)]\n [!code-vb[finfo open1#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.ope_0_1.vb)]"
  syntax:
    content: public System.IO.FileStream Open (System.IO.FileMode mode);
    parameters:
    - id: mode
      type: System.IO.FileMode
      description: "A <xref href=&quot;System.IO.FileMode&quot;> </xref>常数，它指定模式 (例如， <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref>或<xref uid=&quot;langword_csharp_Append&quot; name=&quot;Append&quot; href=&quot;&quot;> </xref>) 在其中打开该文件。"
    return:
      type: System.IO.FileStream
      description: "打开在指定模式下的具有读/写访问权限，且不共享的文件。"
  overload: System.IO.FileInfo.Open*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到该文件。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "该文件为只读或是目录。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路径无效，例如位于未映射的驱动器上。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件已打开。"
  platform:
  - net462
- uid: System.IO.FileInfo.Open(System.IO.FileMode,System.IO.FileAccess)
  id: Open(System.IO.FileMode,System.IO.FileAccess)
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: Open(FileMode,FileAccess)
  nameWithType: FileInfo.Open(FileMode,FileAccess)
  fullName: System.IO.FileInfo.Open(FileMode,FileAccess)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "用读、 写或读/写访问的指定模式中打开文件。"
  remarks: ''
  example:
  - "The following example opens a file as read-only and reads from the file.  \n  \n [!code-vb[finfo open2#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.ope_2_1.vb)]\n [!code-cpp[finfo open2#1](~/add/codesnippet/cpp/m-system.io.fileinfo.ope_2_1.cpp)]\n [!code-cs[finfo open2#1](~/add/codesnippet/csharp/m-system.io.fileinfo.ope_2_1.cs)]"
  syntax:
    content: public System.IO.FileStream Open (System.IO.FileMode mode, System.IO.FileAccess access);
    parameters:
    - id: mode
      type: System.IO.FileMode
      description: "A <xref href=&quot;System.IO.FileMode&quot;> </xref>常数，它指定模式 (例如， <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref>或<xref uid=&quot;langword_csharp_Append&quot; name=&quot;Append&quot; href=&quot;&quot;> </xref>) 在其中打开该文件。"
    - id: access
      type: System.IO.FileAccess
      description: "A <xref href=&quot;System.IO.FileAccess&quot;> </xref>常数，它指定是否打开具有文件<xref uid=&quot;langword_csharp_Read&quot; name=&quot;Read&quot; href=&quot;&quot;> </xref>， <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref>，或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>文件访问。"
    return:
      type: System.IO.FileStream
      description: "A <xref href=&quot;System.IO.FileStream&quot;> </xref>打开的指定的模式和访问权限，且不共享的对象。"
  overload: System.IO.FileInfo.Open*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到该文件。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code>path</code>为只读或是目录。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路径无效，例如位于未映射的驱动器上。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件已打开。"
  platform:
  - net462
- uid: System.IO.FileInfo.Open(System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  id: Open(System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: Open(FileMode,FileAccess,FileShare)
  nameWithType: FileInfo.Open(FileMode,FileAccess,FileShare)
  fullName: System.IO.FileInfo.Open(FileMode,FileAccess,FileShare)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "在具有读取、 写入或读/写访问权限和指定的共享选项指定的模式打开文件。"
  remarks: ''
  example:
  - "The following example demonstrates opening a file for reading and writing, but disallowing access to other users or processes.  \n  \n [!code-cpp[fileinfoopen#1](~/add/codesnippet/cpp/8bd38f9d-a8ac-4cea-8fda-_1.cpp)]\n [!code-cs[fileinfoopen#1](~/add/codesnippet/csharp/8bd38f9d-a8ac-4cea-8fda-_1.cs)]\n [!code-vb[fileinfoopen#1](~/add/codesnippet/visualbasic/8bd38f9d-a8ac-4cea-8fda-_1.vb)]"
  syntax:
    content: public System.IO.FileStream Open (System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
    parameters:
    - id: mode
      type: System.IO.FileMode
      description: "A <xref href=&quot;System.IO.FileMode&quot;> </xref>常数，它指定模式 (例如， <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref>或<xref uid=&quot;langword_csharp_Append&quot; name=&quot;Append&quot; href=&quot;&quot;> </xref>) 在其中打开该文件。"
    - id: access
      type: System.IO.FileAccess
      description: "A <xref href=&quot;System.IO.FileAccess&quot;> </xref>常数，它指定是否打开具有文件<xref uid=&quot;langword_csharp_Read&quot; name=&quot;Read&quot; href=&quot;&quot;> </xref>， <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref>，或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>文件访问。"
    - id: share
      type: System.IO.FileShare
      description: "A <xref href=&quot;System.IO.FileShare&quot;> </xref>常数，它指定的一种访问其他<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对此文件拥有的对象。"
    return:
      type: System.IO.FileStream
      description: "A <xref href=&quot;System.IO.FileStream&quot;> </xref>对象使用指定的模式、 访问权限，打开和共享选项。"
  overload: System.IO.FileInfo.Open*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到该文件。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code>path</code>为只读或是目录。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路径无效，例如位于未映射的驱动器上。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件已打开。"
  platform:
  - net462
- uid: System.IO.FileInfo.OpenRead
  id: OpenRead
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: OpenRead()
  nameWithType: FileInfo.OpenRead()
  fullName: System.IO.FileInfo.OpenRead()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "创建一个只读- <xref href=&quot;System.IO.FileStream&quot;> </xref>。"
  remarks: "此方法返回只读的<xref:System.IO.FileStream><xref:System.IO.FileShare>模式设置为<xref:System.IO.FileShare>。</xref:System.IO.FileShare></xref:System.IO.FileShare>对象</xref:System.IO.FileStream>"
  example:
  - "The following example opens a file as read-only and reads from it.  \n  \n [!code-vb[finfo openread#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.ope_4_1.vb)]\n [!code-cs[finfo openread#1](~/add/codesnippet/csharp/m-system.io.fileinfo.ope_4_1.cs)]\n [!code-cpp[finfo openread#1](~/add/codesnippet/cpp/m-system.io.fileinfo.ope_4_1.cpp)]"
  syntax:
    content: public System.IO.FileStream OpenRead ();
    parameters: []
    return:
      type: System.IO.FileStream
      description: "一个新只读<xref href=&quot;System.IO.FileStream&quot;></xref>对象。"
  overload: System.IO.FileInfo.OpenRead*
  exceptions:
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code>path</code>为只读或是目录。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路径无效，例如位于未映射的驱动器上。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "文件已打开。"
  platform:
  - net462
- uid: System.IO.FileInfo.OpenText
  id: OpenText
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: OpenText()
  nameWithType: FileInfo.OpenText()
  fullName: System.IO.FileInfo.OpenText()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "创建<xref:System.IO.StreamReader>使用的从现有文本文件中读取的 UTF8 编码。</xref:System.IO.StreamReader>"
  remarks: ''
  example:
  - "The following example reads text from a file.  \n  \n [!code-cpp[finfo opentext#1](~/add/codesnippet/cpp/m-system.io.fileinfo.ope_1_1.cpp)]\n [!code-cs[finfo opentext#1](~/add/codesnippet/csharp/m-system.io.fileinfo.ope_1_1.cs)]\n [!code-vb[finfo opentext#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.ope_1_1.vb)]"
  syntax:
    content: public System.IO.StreamReader OpenText ();
    parameters: []
    return:
      type: System.IO.StreamReader
      description: "一个新<xref uid=&quot;langword_csharp_StreamReader&quot; name=&quot;StreamReader&quot; href=&quot;&quot;></xref>使用 UTF8 编码。"
  overload: System.IO.FileInfo.OpenText*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到该文件。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code>path</code>为只读或是目录。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路径无效，例如位于未映射的驱动器上。"
  platform:
  - net462
- uid: System.IO.FileInfo.OpenWrite
  id: OpenWrite
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: OpenWrite()
  nameWithType: FileInfo.OpenWrite()
  fullName: System.IO.FileInfo.OpenWrite()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "创建一个只写的<xref href=&quot;System.IO.FileStream&quot;> </xref>。"
  remarks: "如果一个已存在的文件路径，或创建一个新文件，如果不存在，则 OpenWrite 方法打开文件。 对于现有的文件，它不会不新将文本追加到现有的文本。 相反，它将用新的字符覆盖现有的字符。 如果使用较短字符串 （如&quot;第二次运行&quot;） （例如&quot;This is OpenWrite 方法的测试)&quot;覆盖较长的字符串，则文件将包含多种字符串 (&quot;第二个 runtest OpenWrite 方法的&quot;)。"
  example:
  - "The following example opens a file for writing and then reads from the file.  \n  \n [!code-cs[finfo openwrite#1](~/add/codesnippet/csharp/m-system.io.fileinfo.ope_3_1.cs)]\n [!code-vb[finfo openwrite#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.ope_3_1.vb)]\n [!code-cpp[finfo openwrite#1](~/add/codesnippet/cpp/m-system.io.fileinfo.ope_3_1.cpp)]"
  syntax:
    content: public System.IO.FileStream OpenWrite ();
    parameters: []
    return:
      type: System.IO.FileStream
      description: "只写非共享<xref href=&quot;System.IO.FileStream&quot;></xref>新的或现有文件的对象。"
  overload: System.IO.FileInfo.OpenWrite*
  exceptions:
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "创建的实例时指定的路径<xref href=&quot;System.IO.FileInfo&quot;></xref>对象为只读或是目录。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "创建的实例时指定的路径<xref href=&quot;System.IO.FileInfo&quot;></xref>对象无效，例如位于未映射的驱动器上。"
  platform:
  - net462
- uid: System.IO.FileInfo.Replace(System.String,System.String)
  id: Replace(System.String,System.String)
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: Replace(String,String)
  nameWithType: FileInfo.Replace(String,String)
  fullName: System.IO.FileInfo.Replace(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "当前所描述的文件替换指定文件的内容<xref href=&quot;System.IO.FileInfo&quot;></xref>对象，删除原始文件，并创建被替换文件的备份。"
  remarks: "Replace 方法将指定文件的内容替换当前所描述的文件的内容<xref:System.IO.FileInfo>对象。</xref:System.IO.FileInfo>  它还将创建被替换文件的备份。  最后，它返回一个新<xref:System.IO.FileInfo>对象，描述被覆盖的文件。</xref:System.IO.FileInfo>      1> [!CAUTION] 1> 该方法可用于在 Windows 2000 环境中，如果`destFileName`是只读的并且不会引发异常。 使用<xref:System.IO.FileInfo.IsReadOnly%2A>属性检查目标文件是否为只读，然后再尝试替换它。</xref:System.IO.FileInfo.IsReadOnly%2A>       传递`null`到`destBackupFileName`参数，如果你不想要创建被替换文件的备份。"
  example:
  - "The following example uses the <xref:System.IO.File.Replace%2A> method to replace a file with another file and create a backup of the replaced file.  \n  \n [!code-cs[IO.FileInfo.Replace#1](~/add/codesnippet/csharp/m-system.io.fileinfo.rep_0_1.cs)]\n [!code-vb[IO.FileInfo.Replace#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.rep_0_1.vb)]\n [!code-cpp[IO.FileInfo.Replace#1](~/add/codesnippet/cpp/m-system.io.fileinfo.rep_0_1.cpp)]"
  syntax:
    content: public System.IO.FileInfo Replace (string destinationFileName, string destinationBackupFileName);
    parameters:
    - id: destinationFileName
      type: System.String
      description: "要替换当前文件的文件的名称。"
    - id: destinationBackupFileName
      type: System.String
      description: "用来创建所描述的文件的备份文件的名称`destFileName`参数。"
    return:
      type: System.IO.FileInfo
      description: "A <xref href=&quot;System.IO.FileInfo&quot;> </xref>对象，封装有关所描述的文件信息<code> destFileName </code>参数。"
  overload: System.IO.FileInfo.Replace*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "描述的路径<code> destFileName </code>参数不是合法的窗体。       -描述的路径<code> destBackupFileName </code>参数不是合法的窗体。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>destFileName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "当前所描述的文件<xref href=&quot;System.IO.FileInfo&quot;></xref>找不到对象。       -所描述的文件<code> destinationFileName </code>找不到参数。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "当前操作系统不是 Microsoft Windows NT 或更高版本。"
  platform:
  - net462
- uid: System.IO.FileInfo.Replace(System.String,System.String,System.Boolean)
  id: Replace(System.String,System.String,System.Boolean)
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: Replace(String,String,Boolean)
  nameWithType: FileInfo.Replace(String,String,Boolean)
  fullName: System.IO.FileInfo.Replace(String,String,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "当前所描述的文件替换指定文件的内容<xref href=&quot;System.IO.FileInfo&quot;></xref>对象，删除原始文件，并创建被替换文件的备份。  此外指定是否忽略合并错误。"
  remarks: "Replace 方法将指定文件的内容替换当前所描述的文件的内容<xref:System.IO.FileInfo>对象。</xref:System.IO.FileInfo>  它还将创建被替换文件的备份。  最后，它返回一个新<xref:System.IO.FileInfo>对象，描述被覆盖的文件。</xref:System.IO.FileInfo>      1> [!CAUTION] 1> 该方法可用于在 Windows 2000 环境中，如果`destFileName`是只读的并且不会引发异常。 使用<xref:System.IO.FileInfo.IsReadOnly%2A>属性检查目标文件是否为只读，然后再尝试替换它。</xref:System.IO.FileInfo.IsReadOnly%2A>       传递`null`到`destBackupFileName`参数，如果你不想要创建被替换文件的备份。"
  example:
  - "The following example uses the <xref:System.IO.File.Replace%2A> method to replace a file with another file and create a backup of the replaced file.  \n  \n [!code-cs[IO.FileInfo.Replace#1](~/add/codesnippet/csharp/m-system.io.fileinfo.rep_1_1.cs)]\n [!code-vb[IO.FileInfo.Replace#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.rep_1_1.vb)]\n [!code-cpp[IO.FileInfo.Replace#1](~/add/codesnippet/cpp/m-system.io.fileinfo.rep_1_1.cpp)]"
  syntax:
    content: public System.IO.FileInfo Replace (string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);
    parameters:
    - id: destinationFileName
      type: System.String
      description: "要替换当前文件的文件的名称。"
    - id: destinationBackupFileName
      type: System.String
      description: "用来创建所描述的文件的备份文件的名称`destFileName`参数。"
    - id: ignoreMetadataErrors
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要忽略从被替换文件到替换文件中; 的合并错误 （如特性和 Acl）否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.IO.FileInfo
      description: "A <xref href=&quot;System.IO.FileInfo&quot;> </xref>对象，封装有关所描述的文件信息<code> destFileName </code>参数。"
  overload: System.IO.FileInfo.Replace*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "描述的路径<code> destFileName </code>参数不是合法的窗体。       -描述的路径<code> destBackupFileName </code>参数不是合法的窗体。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>destFileName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "当前所描述的文件<xref href=&quot;System.IO.FileInfo&quot;></xref>找不到对象。       -所描述的文件<code> destinationFileName </code>找不到参数。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "当前操作系统不是 Microsoft Windows NT 或更高版本。"
  platform:
  - net462
- uid: System.IO.FileInfo.SetAccessControl(System.Security.AccessControl.FileSecurity)
  id: SetAccessControl(System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: SetAccessControl(FileSecurity)
  nameWithType: FileInfo.SetAccessControl(FileSecurity)
  fullName: System.IO.FileInfo.SetAccessControl(FileSecurity)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "将访问控制列表 (ACL) 项所描述应用<xref href=&quot;System.Security.AccessControl.FileSecurity&quot;></xref>对象当前所描述的文件<xref href=&quot;System.IO.FileInfo&quot;></xref>对象。"
  remarks: "SetAccessControl 方法适用于表示非继承的 ACL 列表的当前文件的访问控制列表 (ACL) 项。       无论何时需要添加或删除文件的 ACL 条目，请使用 SetAccessControl 方法。      1> [!CAUTION]&1;> 为 ACL 指定`fileSecurity`参数替换现有文件 ACL。 若要添加的新用户的权限，请使用<xref:System.IO.Directory.GetAccessControl%2A>方法来获取现有的 ACL，对其进行修改，然后使用 SetAccessControl 以将其应用回文件。</xref:System.IO.Directory.GetAccessControl%2A>       ACL 描述个人和/或组具有或没有执行到给定的文件上的特定操作的权限。 有关详细信息，请参阅[如何︰ 添加或移除访问控制列表项](~/add/includes/ajax-current-ext-md.md)。       SetAccessControl 方法仍然仅存在<xref:System.Security.AccessControl.FileSecurity>对象创建后已修改的对象。</xref:System.Security.AccessControl.FileSecurity>  如果<xref:System.Security.AccessControl.FileSecurity>尚未修改对象，它不会保留到文件。</xref:System.Security.AccessControl.FileSecurity>  因此，不能检索<xref:System.Security.AccessControl.FileSecurity>对象从一个文件，并重新对同一对象应用到另一个文件。</xref:System.Security.AccessControl.FileSecurity>       若要将 ACL 信息从一个文件复制到另一个︰ 1。  使用<xref:System.IO.FileInfo.GetAccessControl%2A>方法来检索<xref:System.Security.AccessControl.FileSecurity>源文件中的对象。</xref:System.Security.AccessControl.FileSecurity> </xref:System.IO.FileInfo.GetAccessControl%2A>      2.  创建一个新<xref:System.Security.AccessControl.FileSecurity>目标文件的对象。</xref:System.Security.AccessControl.FileSecurity>      3.  使用<xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A>或<xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A>方法的源<xref:System.Security.AccessControl.FileSecurity>要检索 ACL 信息对象。</xref:System.Security.AccessControl.FileSecurity> </xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> </xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A>      4.  使用<xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A>或<xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A>方法的信息复制到目标的步骤 3 中检索<xref:System.Security.AccessControl.FileSecurity>对象。</xref:System.Security.AccessControl.FileSecurity> </xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> </xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A>      5.  设置目标<xref:System.Security.AccessControl.FileSecurity>目标文件使用 SetAccessControl 方法的对象。</xref:System.Security.AccessControl.FileSecurity>"
  example:
  - "The following code example uses the <xref:System.IO.FileInfo.GetAccessControl%2A> method and the SetAccessControl method to add and then remove an ACL entry from a file.  You must supply a valid user or group account to run this example.  \n  \n [!code-cpp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/add/codesnippet/cpp/c24a4717-31ac-4834-901c-_1.cpp)]\n [!code-vb[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/add/codesnippet/visualbasic/c24a4717-31ac-4834-901c-_1.vb)]\n [!code-cs[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/add/codesnippet/csharp/c24a4717-31ac-4834-901c-_1.cs)]"
  syntax:
    content: public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "A <xref href=&quot;System.Security.AccessControl.FileSecurity&quot;> </xref>描述要应用于当前文件的访问控制列表 (ACL) 项的对象。"
  overload: System.IO.FileInfo.SetAccessControl*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>fileSecurity</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "无法找到或修改该文件。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "当前进程不具有打开该文件的权限。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "当前操作系统不是 Microsoft Windows 2000 或更高版本。"
  platform:
  - net462
- uid: System.IO.FileInfo.ToString
  id: ToString
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: ToString()
  nameWithType: FileInfo.ToString()
  fullName: System.IO.FileInfo.ToString()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "字符串形式返回的路径。"
  remarks: "ToString 方法返回的字符串表示传递给构造函数的路径。  当你创建<xref:System.IO.FileInfo>对象使用构造函数，该 ToString 方法将返回完全限定路径。</xref:System.IO.FileInfo>  但是，也会返回 ToString 方法的字符串不表示的完全限定的路径的情况。  例如，当创建<xref:System.IO.FileInfo>对象使用的<xref:System.IO.DirectoryInfo.GetFiles%2A>方法，ToString 方法不表示完全限定路径。</xref:System.IO.DirectoryInfo.GetFiles%2A> </xref:System.IO.FileInfo>"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "一个表示该路径的字符串。"
  overload: System.IO.FileInfo.ToString*
  exceptions: []
  platform:
  - net462
references:
- uid: System.IO.FileSystemInfo
  isExternal: false
  name: System.IO.FileSystemInfo
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.IO.PathTooLongException
  isExternal: true
  name: System.IO.PathTooLongException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.IO.DirectoryNotFoundException
  isExternal: true
  name: System.IO.DirectoryNotFoundException
- uid: System.IO.DriveNotFoundException
  parent: System.IO
  isExternal: false
  name: DriveNotFoundException
  nameWithType: DriveNotFoundException
  fullName: System.IO.DriveNotFoundException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.Security.AccessControl.PrivilegeNotHeldException
  parent: System.Security.AccessControl
  isExternal: false
  name: PrivilegeNotHeldException
  nameWithType: PrivilegeNotHeldException
  fullName: System.Security.AccessControl.PrivilegeNotHeldException
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.IO.FileInfo.#ctor(System.String)
  parent: System.IO.FileInfo
  isExternal: false
  name: FileInfo(String)
  nameWithType: FileInfo.FileInfo(String)
  fullName: System.IO.FileInfo.FileInfo(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.FileInfo.AppendText
  parent: System.IO.FileInfo
  isExternal: false
  name: AppendText()
  nameWithType: FileInfo.AppendText()
  fullName: System.IO.FileInfo.AppendText()
- uid: System.IO.StreamWriter
  parent: System.IO
  isExternal: true
  name: StreamWriter
  nameWithType: StreamWriter
  fullName: System.IO.StreamWriter
- uid: System.IO.FileInfo.CopyTo(System.String)
  parent: System.IO.FileInfo
  isExternal: false
  name: CopyTo(String)
  nameWithType: FileInfo.CopyTo(String)
  fullName: System.IO.FileInfo.CopyTo(String)
- uid: System.IO.FileInfo
  parent: System.IO
  isExternal: false
  name: FileInfo
  nameWithType: FileInfo
  fullName: System.IO.FileInfo
- uid: System.IO.FileInfo.CopyTo(System.String,System.Boolean)
  parent: System.IO.FileInfo
  isExternal: false
  name: CopyTo(String,Boolean)
  nameWithType: FileInfo.CopyTo(String,Boolean)
  fullName: System.IO.FileInfo.CopyTo(String,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.FileInfo.Create
  parent: System.IO.FileInfo
  isExternal: false
  name: Create()
  nameWithType: FileInfo.Create()
  fullName: System.IO.FileInfo.Create()
- uid: System.IO.FileStream
  parent: System.IO
  isExternal: false
  name: FileStream
  nameWithType: FileStream
  fullName: System.IO.FileStream
- uid: System.IO.FileInfo.CreateText
  parent: System.IO.FileInfo
  isExternal: false
  name: CreateText()
  nameWithType: FileInfo.CreateText()
  fullName: System.IO.FileInfo.CreateText()
- uid: System.IO.FileInfo.Decrypt
  parent: System.IO.FileInfo
  isExternal: false
  name: Decrypt()
  nameWithType: FileInfo.Decrypt()
  fullName: System.IO.FileInfo.Decrypt()
- uid: System.IO.FileInfo.Delete
  parent: System.IO.FileInfo
  isExternal: false
  name: Delete()
  nameWithType: FileInfo.Delete()
  fullName: System.IO.FileInfo.Delete()
- uid: System.IO.FileInfo.Directory
  parent: System.IO.FileInfo
  isExternal: false
  name: Directory
  nameWithType: FileInfo.Directory
  fullName: System.IO.FileInfo.Directory
- uid: System.IO.DirectoryInfo
  parent: System.IO
  isExternal: false
  name: DirectoryInfo
  nameWithType: DirectoryInfo
  fullName: System.IO.DirectoryInfo
- uid: System.IO.FileInfo.DirectoryName
  parent: System.IO.FileInfo
  isExternal: false
  name: DirectoryName
  nameWithType: FileInfo.DirectoryName
  fullName: System.IO.FileInfo.DirectoryName
- uid: System.IO.FileInfo.Encrypt
  parent: System.IO.FileInfo
  isExternal: false
  name: Encrypt()
  nameWithType: FileInfo.Encrypt()
  fullName: System.IO.FileInfo.Encrypt()
- uid: System.IO.FileInfo.Exists
  parent: System.IO.FileInfo
  isExternal: false
  name: Exists
  nameWithType: FileInfo.Exists
  fullName: System.IO.FileInfo.Exists
- uid: System.IO.FileInfo.GetAccessControl
  parent: System.IO.FileInfo
  isExternal: false
  name: GetAccessControl()
  nameWithType: FileInfo.GetAccessControl()
  fullName: System.IO.FileInfo.GetAccessControl()
- uid: System.Security.AccessControl.FileSecurity
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSecurity
  nameWithType: FileSecurity
  fullName: System.Security.AccessControl.FileSecurity
- uid: System.IO.FileInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)
  parent: System.IO.FileInfo
  isExternal: false
  name: GetAccessControl(AccessControlSections)
  nameWithType: FileInfo.GetAccessControl(AccessControlSections)
  fullName: System.IO.FileInfo.GetAccessControl(AccessControlSections)
- uid: System.Security.AccessControl.AccessControlSections
  parent: System.Security.AccessControl
  isExternal: false
  name: AccessControlSections
  nameWithType: AccessControlSections
  fullName: System.Security.AccessControl.AccessControlSections
- uid: System.IO.FileInfo.IsReadOnly
  parent: System.IO.FileInfo
  isExternal: false
  name: IsReadOnly
  nameWithType: FileInfo.IsReadOnly
  fullName: System.IO.FileInfo.IsReadOnly
- uid: System.IO.FileInfo.Length
  parent: System.IO.FileInfo
  isExternal: false
  name: Length
  nameWithType: FileInfo.Length
  fullName: System.IO.FileInfo.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.FileInfo.MoveTo(System.String)
  parent: System.IO.FileInfo
  isExternal: false
  name: MoveTo(String)
  nameWithType: FileInfo.MoveTo(String)
  fullName: System.IO.FileInfo.MoveTo(String)
- uid: System.IO.FileInfo.Name
  parent: System.IO.FileInfo
  isExternal: false
  name: Name
  nameWithType: FileInfo.Name
  fullName: System.IO.FileInfo.Name
- uid: System.IO.FileInfo.Open(System.IO.FileMode)
  parent: System.IO.FileInfo
  isExternal: false
  name: Open(FileMode)
  nameWithType: FileInfo.Open(FileMode)
  fullName: System.IO.FileInfo.Open(FileMode)
- uid: System.IO.FileMode
  parent: System.IO
  isExternal: false
  name: FileMode
  nameWithType: FileMode
  fullName: System.IO.FileMode
- uid: System.IO.FileInfo.Open(System.IO.FileMode,System.IO.FileAccess)
  parent: System.IO.FileInfo
  isExternal: false
  name: Open(FileMode,FileAccess)
  nameWithType: FileInfo.Open(FileMode,FileAccess)
  fullName: System.IO.FileInfo.Open(FileMode,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.FileInfo.Open(System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  parent: System.IO.FileInfo
  isExternal: false
  name: Open(FileMode,FileAccess,FileShare)
  nameWithType: FileInfo.Open(FileMode,FileAccess,FileShare)
  fullName: System.IO.FileInfo.Open(FileMode,FileAccess,FileShare)
- uid: System.IO.FileShare
  parent: System.IO
  isExternal: false
  name: FileShare
  nameWithType: FileShare
  fullName: System.IO.FileShare
- uid: System.IO.FileInfo.OpenRead
  parent: System.IO.FileInfo
  isExternal: false
  name: OpenRead()
  nameWithType: FileInfo.OpenRead()
  fullName: System.IO.FileInfo.OpenRead()
- uid: System.IO.FileInfo.OpenText
  parent: System.IO.FileInfo
  isExternal: false
  name: OpenText()
  nameWithType: FileInfo.OpenText()
  fullName: System.IO.FileInfo.OpenText()
- uid: System.IO.StreamReader
  parent: System.IO
  isExternal: true
  name: StreamReader
  nameWithType: StreamReader
  fullName: System.IO.StreamReader
- uid: System.IO.FileInfo.OpenWrite
  parent: System.IO.FileInfo
  isExternal: false
  name: OpenWrite()
  nameWithType: FileInfo.OpenWrite()
  fullName: System.IO.FileInfo.OpenWrite()
- uid: System.IO.FileInfo.Replace(System.String,System.String)
  parent: System.IO.FileInfo
  isExternal: false
  name: Replace(String,String)
  nameWithType: FileInfo.Replace(String,String)
  fullName: System.IO.FileInfo.Replace(String,String)
- uid: System.IO.FileInfo.Replace(System.String,System.String,System.Boolean)
  parent: System.IO.FileInfo
  isExternal: false
  name: Replace(String,String,Boolean)
  nameWithType: FileInfo.Replace(String,String,Boolean)
  fullName: System.IO.FileInfo.Replace(String,String,Boolean)
- uid: System.IO.FileInfo.SetAccessControl(System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileInfo
  isExternal: false
  name: SetAccessControl(FileSecurity)
  nameWithType: FileInfo.SetAccessControl(FileSecurity)
  fullName: System.IO.FileInfo.SetAccessControl(FileSecurity)
- uid: System.IO.FileInfo.ToString
  parent: System.IO.FileInfo
  isExternal: false
  name: ToString()
  nameWithType: FileInfo.ToString()
  fullName: System.IO.FileInfo.ToString()
- uid: System.IO.FileInfo.#ctor*
  parent: System.IO.FileInfo
  isExternal: false
  name: FileInfo
  nameWithType: FileInfo.FileInfo
- uid: System.IO.FileInfo.AppendText*
  parent: System.IO.FileInfo
  isExternal: false
  name: AppendText
  nameWithType: FileInfo.AppendText
- uid: System.IO.FileInfo.CopyTo*
  parent: System.IO.FileInfo
  isExternal: false
  name: CopyTo
  nameWithType: FileInfo.CopyTo
- uid: System.IO.FileInfo.Create*
  parent: System.IO.FileInfo
  isExternal: false
  name: Create
  nameWithType: FileInfo.Create
- uid: System.IO.FileInfo.CreateText*
  parent: System.IO.FileInfo
  isExternal: false
  name: CreateText
  nameWithType: FileInfo.CreateText
- uid: System.IO.FileInfo.Decrypt*
  parent: System.IO.FileInfo
  isExternal: false
  name: Decrypt
  nameWithType: FileInfo.Decrypt
- uid: System.IO.FileInfo.Delete*
  parent: System.IO.FileInfo
  isExternal: false
  name: Delete
  nameWithType: FileInfo.Delete
- uid: System.IO.FileInfo.Directory*
  parent: System.IO.FileInfo
  isExternal: false
  name: Directory
  nameWithType: FileInfo.Directory
- uid: System.IO.FileInfo.DirectoryName*
  parent: System.IO.FileInfo
  isExternal: false
  name: DirectoryName
  nameWithType: FileInfo.DirectoryName
- uid: System.IO.FileInfo.Encrypt*
  parent: System.IO.FileInfo
  isExternal: false
  name: Encrypt
  nameWithType: FileInfo.Encrypt
- uid: System.IO.FileInfo.Exists*
  parent: System.IO.FileInfo
  isExternal: false
  name: Exists
  nameWithType: FileInfo.Exists
- uid: System.IO.FileInfo.GetAccessControl*
  parent: System.IO.FileInfo
  isExternal: false
  name: GetAccessControl
  nameWithType: FileInfo.GetAccessControl
- uid: System.IO.FileInfo.IsReadOnly*
  parent: System.IO.FileInfo
  isExternal: false
  name: IsReadOnly
  nameWithType: FileInfo.IsReadOnly
- uid: System.IO.FileInfo.Length*
  parent: System.IO.FileInfo
  isExternal: false
  name: Length
  nameWithType: FileInfo.Length
- uid: System.IO.FileInfo.MoveTo*
  parent: System.IO.FileInfo
  isExternal: false
  name: MoveTo
  nameWithType: FileInfo.MoveTo
- uid: System.IO.FileInfo.Name*
  parent: System.IO.FileInfo
  isExternal: false
  name: Name
  nameWithType: FileInfo.Name
- uid: System.IO.FileInfo.Open*
  parent: System.IO.FileInfo
  isExternal: false
  name: Open
  nameWithType: FileInfo.Open
- uid: System.IO.FileInfo.OpenRead*
  parent: System.IO.FileInfo
  isExternal: false
  name: OpenRead
  nameWithType: FileInfo.OpenRead
- uid: System.IO.FileInfo.OpenText*
  parent: System.IO.FileInfo
  isExternal: false
  name: OpenText
  nameWithType: FileInfo.OpenText
- uid: System.IO.FileInfo.OpenWrite*
  parent: System.IO.FileInfo
  isExternal: false
  name: OpenWrite
  nameWithType: FileInfo.OpenWrite
- uid: System.IO.FileInfo.Replace*
  parent: System.IO.FileInfo
  isExternal: false
  name: Replace
  nameWithType: FileInfo.Replace
- uid: System.IO.FileInfo.SetAccessControl*
  parent: System.IO.FileInfo
  isExternal: false
  name: SetAccessControl
  nameWithType: FileInfo.SetAccessControl
- uid: System.IO.FileInfo.ToString*
  parent: System.IO.FileInfo
  isExternal: false
  name: ToString
  nameWithType: FileInfo.ToString
