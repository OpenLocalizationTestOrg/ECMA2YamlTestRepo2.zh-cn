### YamlMime:ManagedReference
items:
- uid: System.Reflection.TypeDelegator
  id: TypeDelegator
  children:
  - System.Reflection.TypeDelegator.#ctor
  - System.Reflection.TypeDelegator.#ctor(System.Type)
  - System.Reflection.TypeDelegator.Assembly
  - System.Reflection.TypeDelegator.AssemblyQualifiedName
  - System.Reflection.TypeDelegator.BaseType
  - System.Reflection.TypeDelegator.FullName
  - System.Reflection.TypeDelegator.GetAttributeFlagsImpl
  - System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  - System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetCustomAttributes(System.Boolean)
  - System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)
  - System.Reflection.TypeDelegator.GetElementType
  - System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetEvents
  - System.Reflection.TypeDelegator.GetEvents(System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)
  - System.Reflection.TypeDelegator.GetInterfaceMap(System.Type)
  - System.Reflection.TypeDelegator.GetInterfaces
  - System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  - System.Reflection.TypeDelegator.GetMethods(System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetNestedTypes(System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetProperties(System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])
  - System.Reflection.TypeDelegator.GUID
  - System.Reflection.TypeDelegator.HasElementTypeImpl
  - System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])
  - System.Reflection.TypeDelegator.IsArrayImpl
  - System.Reflection.TypeDelegator.IsAssignableFrom(System.Reflection.TypeInfo)
  - System.Reflection.TypeDelegator.IsByRefImpl
  - System.Reflection.TypeDelegator.IsCOMObjectImpl
  - System.Reflection.TypeDelegator.IsConstructedGenericType
  - System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)
  - System.Reflection.TypeDelegator.IsPointerImpl
  - System.Reflection.TypeDelegator.IsPrimitiveImpl
  - System.Reflection.TypeDelegator.IsValueTypeImpl
  - System.Reflection.TypeDelegator.MetadataToken
  - System.Reflection.TypeDelegator.Module
  - System.Reflection.TypeDelegator.Name
  - System.Reflection.TypeDelegator.Namespace
  - System.Reflection.TypeDelegator.TypeHandle
  - System.Reflection.TypeDelegator.typeImpl
  - System.Reflection.TypeDelegator.UnderlyingSystemType
  langs:
  - csharp
  name: TypeDelegator
  nameWithType: TypeDelegator
  fullName: System.Reflection.TypeDelegator
  type: Class
  summary: "包装&lt;xref:System.Type?displayProperty=fullName&gt;到的对象和委托方法<xref uid=&quot;langword_csharp_Type&quot; name=&quot;Type&quot; href=&quot;&quot;> </xref>。"
  remarks: "从此类型派生，重写你必须提供自定义项中，这些成员加上所需的程序和由 TypeDelegator 尚未实现的任意成员。       TypeDelegator 派生<xref:System.Type?displayProperty=fullName>并实现大部分的属性和方法的<xref:System.Type>.</xref:System.Type></xref:System.Type?displayProperty=fullName>自 对于每个成员，它实现，TypeDelegator 自动委托给内部的相应成员<xref:System.Type>对象，后者将作为构造函数的自变量提供。</xref:System.Type> 此内部<xref:System.Type>对象被公开到派生类`protected`<xref:System.Reflection.TypeDelegator.typeImpl>字段。</xref:System.Reflection.TypeDelegator.typeImpl> </xref:System.Type>      1> [!NOTE]&1;> TypeDelegator 某些成员具有实现，即使只需从<xref:System.Type>.</xref:System.Type>继承这些成员本身也是如此 在这些情况下，提供了该实现通过被重写`protected`具有以&quot;以 Impl&quot;结尾的名称的方法。 例如，实现的所有重载<xref:System.Reflection.TypeDelegator.GetMethod%2A>提供方法通过重写<xref:System.Reflection.TypeDelegator.GetMethodImpl%2A>方法。</xref:System.Reflection.TypeDelegator.GetMethodImpl%2A> </xref:System.Reflection.TypeDelegator.GetMethod%2A> 实现继承属性，如<xref:System.Type.IsPublic%2A>和<xref:System.Type.IsNestedAssembly%2A>提供通过重写<xref:System.Reflection.TypeDelegator.GetAttributeFlagsImpl%2A>方法。</xref:System.Reflection.TypeDelegator.GetAttributeFlagsImpl%2A> </xref:System.Type.IsNestedAssembly%2A> </xref:System.Type.IsPublic%2A>       派生类可以提供的公共构造函数的<xref:System.Type>对象作为其参数并只需将该对象传递到<xref:System.Reflection.TypeDelegator.%23ctor%28System.Type%29>构造函数，也可以设置内部<xref:System.Type>以某种其他方式的对象。</xref:System.Type> </xref:System.Reflection.TypeDelegator.%23ctor%28System.Type%29> </xref:System.Type>       如果派生类使用 TypeDelegator 未实现的成员，它必须重写该成员，并提供一个实现。 最简单的实现是在内部调用的对应成员<xref:System.Type>由公开对象<xref:System.Reflection.TypeDelegator.typeImpl>字段，但你可以提供你的应用程序要求任何实现。</xref:System.Reflection.TypeDelegator.typeImpl> </xref:System.Type> 不需要重写这些成员，如果它们不由你的应用程序或库函数你应用程序的调用 (例如，通过<xref:System.CodeDom.CodeTypeReference.%23ctor%28System.Type%29?displayProperty=fullName>构造函数)。</xref:System.CodeDom.CodeTypeReference.%23ctor%28System.Type%29?displayProperty=fullName>       以下虚拟方法 (`Overridable`在 Visual Basic 中的方法) 的<xref:System.Type>不由 TypeDelegator 实现: <xref:System.Type.MakeGenericType%2A> <xref:System.Type.GetGenericTypeDefinition%2A> <xref:System.Type.GetGenericArguments%2A> <xref:System.Type.GetGenericParameterConstraints%2A> <xref:System.Type.MakeArrayType%2A> <xref:System.Type.MakeByRefType%2A> <xref:System.Type.MakePointerType%2A> <xref:System.Type.GetEnumNames%2A> <xref:System.Type.GetEnumValues%2A> <xref:System.Type.GetEnumUnderlyingType%2A> <xref:System.Type.GetTypeCodeImpl%2A> <xref:System.Type.IsEnumDefined%2A>、 <xref:System.Type.IsEquivalentTo%2A>.</xref:System.Type.IsEquivalentTo%2A> </xref:System.Type.IsEnumDefined%2A> </xref:System.Type.GetTypeCodeImpl%2A> </xref:System.Type.GetEnumUnderlyingType%2A> </xref:System.Type.GetEnumValues%2A> </xref:System.Type.GetEnumNames%2A> </xref:System.Type.MakePointerType%2A> </xref:System.Type.MakeByRefType%2A> </xref:System.Type.MakeArrayType%2A> </xref:System.Type.GetGenericParameterConstraints%2A> </xref:System.Type.GetGenericArguments%2A> </xref:System.Type.GetGenericTypeDefinition%2A> </xref:System.Type.MakeGenericType%2A> </xref:System.Type>       以下虚拟属性 (`Overridable`属性在 Visual Basic 中的) 的<xref:System.Type>不由 TypeDelegator 实现: <xref:System.Type.IsGenericType%2A> <xref:System.Type.IsGenericTypeDefinition%2A> <xref:System.Type.IsGenericParameter%2A> <xref:System.Type.ContainsGenericParameters%2A> <xref:System.Type.DeclaringMethod%2A> <xref:System.Type.GenericParameterAttributes%2A> <xref:System.Type.GenericParameterPosition%2A> <xref:System.Type.IsSecurityCritical%2A> <xref:System.Type.IsSecuritySafeCritical%2A>、 <xref:System.Type.IsSecurityTransparent%2A>.</xref:System.Type.IsSecurityTransparent%2A> </xref:System.Type.IsSecuritySafeCritical%2A> </xref:System.Type.IsSecurityCritical%2A> </xref:System.Type.GenericParameterPosition%2A> </xref:System.Type.GenericParameterAttributes%2A> </xref:System.Type.DeclaringMethod%2A> </xref:System.Type.ContainsGenericParameters%2A> </xref:System.Type.IsGenericParameter%2A> </xref:System.Type.IsGenericTypeDefinition%2A> </xref:System.Type.IsGenericType%2A> </xref:System.Type>"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public class TypeDelegator : System.Reflection.TypeInfo
  inheritance:
  - System.Reflection.TypeInfo
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.#ctor
  id: '#ctor'
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: TypeDelegator()
  nameWithType: TypeDelegator.TypeDelegator()
  fullName: System.Reflection.TypeDelegator.TypeDelegator()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "初始化的新实例<xref href=&quot;System.Reflection.TypeDelegator&quot;></xref>使用默认属性的类。"
  syntax:
    content: protected TypeDelegator ();
    parameters: []
  overload: System.Reflection.TypeDelegator.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.#ctor(System.Type)
  id: '#ctor(System.Type)'
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: TypeDelegator(Type)
  nameWithType: TypeDelegator.TypeDelegator(Type)
  fullName: System.Reflection.TypeDelegator.TypeDelegator(Type)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "初始化的新实例<xref href=&quot;System.Reflection.TypeDelegator&quot;></xref>指定封装实例的类。"
  remarks: "此构造函数调用从一个类来生成基于委托`Type`为定义该方法的类的对象。"
  syntax:
    content: public TypeDelegator (Type delegatingType);
    parameters:
    - id: delegatingType
      type: System.Type
      description: "类的实例<xref:System.Type>封装对对象的方法的调用。</xref:System.Type>"
  overload: System.Reflection.TypeDelegator.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>delegatingType</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.Assembly
  id: Assembly
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: Assembly
  nameWithType: TypeDelegator.Assembly
  fullName: System.Reflection.TypeDelegator.Assembly
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "获取实现的类型的程序集。"
  remarks: "程序集是公共语言运行时中的部署单元。 程序集建立解析请求的命名空间，并确定哪些资源向外部公开，这是可从程序集内访问。 公共语言运行时可以确定，并找到任何正在运行的对象的程序集。"
  syntax:
    content: public override System.Reflection.Assembly Assembly { get; }
    return:
      type: System.Reflection.Assembly
      description: "&lt;Xref:System.Reflection.Assembly?displayProperty=fullName&gt;表示实现的类型的程序集的对象。"
  overload: System.Reflection.TypeDelegator.Assembly*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.AssemblyQualifiedName
  id: AssemblyQualifiedName
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: AssemblyQualifiedName
  nameWithType: TypeDelegator.AssemblyQualifiedName
  fullName: System.Reflection.TypeDelegator.AssemblyQualifiedName
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "获取程序集的完全限定的名称。"
  syntax:
    content: public override string AssemblyQualifiedName { get; }
    return:
      type: System.String
      description: "A <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref>包含程序集的完全限定的名称。"
  overload: System.Reflection.TypeDelegator.AssemblyQualifiedName*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.BaseType
  id: BaseType
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: BaseType
  nameWithType: TypeDelegator.BaseType
  fullName: System.Reflection.TypeDelegator.BaseType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "获取当前类型的基类型。"
  remarks: "基类型是此类型直接从中继承的类型。 由于<xref:System.Object>类类型是所有其他类型的最终基类，它是不具有基类型的唯一类型。</xref:System.Object> 在这种情况下，`null`作为的基类型返回`Object`类型。"
  syntax:
    content: public override Type BaseType { get; }
    return:
      type: System.Type
      description: "类型的基类型。"
  overload: System.Reflection.TypeDelegator.BaseType*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.FullName
  id: FullName
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: FullName
  nameWithType: TypeDelegator.FullName
  fullName: System.Reflection.TypeDelegator.FullName
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "获取实现的类型的完全限定的名称。"
  remarks: "包含当前的完全限定的名称的字符串`TypeDelegator`。"
  syntax:
    content: public override string FullName { get; }
    return:
      type: System.String
      description: "A <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref>包含该类型的完全限定的名称。"
  overload: System.Reflection.TypeDelegator.FullName*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetAttributeFlagsImpl
  id: GetAttributeFlagsImpl
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetAttributeFlagsImpl()
  nameWithType: TypeDelegator.GetAttributeFlagsImpl()
  fullName: System.Reflection.TypeDelegator.GetAttributeFlagsImpl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "获取分配给属性<xref uid=&quot;langword_csharp_TypeDelegator&quot; name=&quot;TypeDelegator&quot; href=&quot;&quot;> </xref>。"
  remarks: "此方法可以用于确定如果`TypeDelegator`是抽象、 公共的等等。"
  syntax:
    content: protected override System.Reflection.TypeAttributes GetAttributeFlagsImpl ();
    parameters: []
    return:
      type: System.Reflection.TypeAttributes
      description: "A <xref uid=&quot;langword_csharp_TypeAttributes&quot; name=&quot;TypeAttributes&quot; href=&quot;&quot;> </xref>表示实现属性标志的对象。"
  overload: System.Reflection.TypeDelegator.GetAttributeFlagsImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  id: GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetConstructorImpl(BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  nameWithType: TypeDelegator.GetConstructorImpl(BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  fullName: System.Reflection.TypeDelegator.GetConstructorImpl(BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "获取的构造函数来实现<xref uid=&quot;langword_csharp_TypeDelegator&quot; name=&quot;TypeDelegator&quot; href=&quot;&quot;> </xref>。"
  remarks: "`callConvention`参数指示的入口点的调用约定。 如果指定不调用约定，则默认<xref:System.Reflection.CallingConventions>值`Standard`使用。</xref:System.Reflection.CallingConventions>"
  syntax:
    content: protected override System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "影响执行搜索的方式的位掩码。 值是从零个或多个位标志的组合<xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>。"
    - id: binder
      type: System.Reflection.Binder
      description: "启用绑定、 强制自变量的对象类型、 成员的调用，以及检索<xref uid=&quot;langword_csharp_MemberInfo&quot; name=&quot;MemberInfo&quot; href=&quot;&quot;></xref>对象使用反射。 如果`binder`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，则使用默认联编程序。"
    - id: callConvention
      type: System.Reflection.CallingConventions
      description: "调用约定。"
    - id: types
      type: System.Type[]
      description: "类型的数组<xref uid=&quot;langword_csharp_Type&quot; name=&quot;Type&quot; href=&quot;&quot;></xref>包含的参数数量、 顺序和类型列表。 类型不能为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>; 使用适当<xref uid=&quot;langword_csharp_GetMethod&quot; name=&quot;GetMethod&quot; href=&quot;&quot;></xref>方法或搜索不带参数的方法的空数组。"
    - id: modifiers
      type: System.Reflection.ParameterModifier[]
      description: "类型的数组<xref uid=&quot;langword_csharp_ParameterModifier&quot; name=&quot;ParameterModifier&quot; href=&quot;&quot;></xref>具有相同的长度，作为`types`数组，其元素表示要获取的方法的参数与关联的属性。"
    return:
      type: System.Reflection.ConstructorInfo
      description: "A <xref uid=&quot;langword_csharp_ConstructorInfo&quot; name=&quot;ConstructorInfo&quot; href=&quot;&quot;> </xref>符合指定的条件，该方法的对象或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果找不到匹配项。"
  overload: System.Reflection.TypeDelegator.GetConstructorImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)
  id: GetConstructors(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetConstructors(BindingFlags)
  nameWithType: TypeDelegator.GetConstructors(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetConstructors(BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "返回的数组<xref:System.Reflection.ConstructorInfo>表示由当前的类型定义的构造函数的对象<xref href=&quot;System.Reflection.TypeDelegator&quot;> </xref>。</xref:System.Reflection.ConstructorInfo>"
  remarks: "类初始值设定项是仅可通过提供`GetMember`， `GetMembers`， `FindMembers`，和`GetConstructors`。"
  syntax:
    content: public override System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "影响执行搜索的方式的位掩码。 值是从零个或多个位标志的组合<xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>。"
    return:
      type: System.Reflection.ConstructorInfo[]
      description: "类型的数组<xref uid=&quot;langword_csharp_ConstructorInfo&quot; name=&quot;ConstructorInfo&quot; href=&quot;&quot;></xref>包含为此类定义的指定构造函数。 如果未不定义任何构造函数，则返回一个空数组。 根据指定的参数的值，将返回仅公共构造函数或公共和非公共构造函数。"
  overload: System.Reflection.TypeDelegator.GetConstructors*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetCustomAttributes(System.Boolean)
  id: GetCustomAttributes(System.Boolean)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetCustomAttributes(Boolean)
  nameWithType: TypeDelegator.GetCustomAttributes(Boolean)
  fullName: System.Reflection.TypeDelegator.GetCustomAttributes(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "返回为此类型，指定是否搜索此类型的继承链定义的所有自定义属性。"
  syntax:
    content: public override object[] GetCustomAttributes (bool inherit);
    parameters:
    - id: inherit
      type: System.Boolean
      description: "指定是否搜索此类型的继承链以查找属性。"
    return:
      type: System.Object[]
      description: "包含为此类型定义的所有自定义属性的对象的数组。"
  overload: System.Reflection.TypeDelegator.GetCustomAttributes*
  exceptions:
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "无法加载自定义属性类型。"
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)
  id: GetCustomAttributes(System.Type,System.Boolean)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetCustomAttributes(Type,Boolean)
  nameWithType: TypeDelegator.GetCustomAttributes(Type,Boolean)
  fullName: System.Reflection.TypeDelegator.GetCustomAttributes(Type,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "返回包含由类型标识的自定义特性的数组。"
  syntax:
    content: public override object[] GetCustomAttributes (Type attributeType, bool inherit);
    parameters:
    - id: attributeType
      type: System.Type
      description: "包含由类型标识的自定义特性的数组。"
    - id: inherit
      type: System.Boolean
      description: "指定是否搜索此类型的继承链以查找属性。"
    return:
      type: System.Object[]
      description: "包含匹配的自定义特性定义在这种类型的对象的数组<code> attributeType </code>参数，指定是否搜索此类型的继承链，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果在此类型上定义了自定义特性。"
  overload: System.Reflection.TypeDelegator.GetCustomAttributes*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>attributeType</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "无法加载自定义属性类型。"
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetElementType
  id: GetElementType
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetElementType()
  nameWithType: TypeDelegator.GetElementType()
  fullName: System.Reflection.TypeDelegator.GetElementType()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "返回<xref:System.Type>包含或引用由当前数组、 指针或引用传递的对象。</xref:System.Type>"
  syntax:
    content: public override Type GetElementType ();
    parameters: []
    return:
      type: System.Type
      description: "<xref:System.Type>包含或当前数组中，所引用的对象的指针或<xref uid=&quot;langword_csharp_ByRef&quot; name=&quot;ByRef&quot; href=&quot;&quot;> </xref>，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果当前<xref:System.Type>不是数组的指针或<xref uid=&quot;langword_csharp_ByRef&quot; name=&quot;ByRef&quot; href=&quot;&quot;> </xref>。</xref:System.Type> </xref:System.Type>"
  overload: System.Reflection.TypeDelegator.GetElementType*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)
  id: GetEvent(System.String,System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetEvent(String,BindingFlags)
  nameWithType: TypeDelegator.GetEvent(String,BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetEvent(String,BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "返回指定的事件。"
  remarks: "如果`bindingAttr`是<xref:System.Reflection.BindingFlags>。`IgnoreCase`、 用例`name`参数将被忽略。</xref:System.Reflection.BindingFlags>"
  syntax:
    content: public override System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: name
      type: System.String
      description: "要获取的事件的名称。"
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "影响执行搜索的方式的位掩码。 值是从零个或多个位标志的组合<xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>。"
    return:
      type: System.Reflection.EventInfo
      description: "<xref:System.Reflection.EventInfo>对象，表示事件声明或继承的具有指定名称的此类型。</xref:System.Reflection.EventInfo> 此方法返回<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果不找到任何此类事件。"
  overload: System.Reflection.TypeDelegator.GetEvent*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>name</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetEvents
  id: GetEvents
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetEvents()
  nameWithType: TypeDelegator.GetEvents()
  fullName: System.Reflection.TypeDelegator.GetEvents()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "返回的数组<xref:System.Reflection.EventInfo>对象表示的所有公共事件声明或继承的当前<xref uid=&quot;langword_csharp_TypeDelegator&quot; name=&quot;TypeDelegator&quot; href=&quot;&quot;> </xref>。</xref:System.Reflection.EventInfo>"
  syntax:
    content: public override System.Reflection.EventInfo[] GetEvents ();
    parameters: []
    return:
      type: System.Reflection.EventInfo[]
      description: "返回类型的数组<xref uid=&quot;langword_csharp_EventInfo&quot; name=&quot;EventInfo&quot; href=&quot;&quot;></xref>包含的所有事件声明或继承的当前类型。 如果不有任何事件，则返回一个空数组。"
  overload: System.Reflection.TypeDelegator.GetEvents*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetEvents(System.Reflection.BindingFlags)
  id: GetEvents(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetEvents(BindingFlags)
  nameWithType: TypeDelegator.GetEvents(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetEvents(BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "返回在指定的事件<code> bindingAttr </code> ，所声明或继承的当前<xref uid=&quot;langword_csharp_TypeDelegator&quot; name=&quot;TypeDelegator&quot; href=&quot;&quot;> </xref>。"
  syntax:
    content: public override System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "影响执行搜索的方式的位掩码。 值是从零个或多个位标志的组合<xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>。"
    return:
      type: System.Reflection.EventInfo[]
      description: "类型的数组<xref uid=&quot;langword_csharp_EventInfo&quot; name=&quot;EventInfo&quot; href=&quot;&quot;></xref>包含发生的事件中指定<code> bindingAttr </code>。 如果不有任何事件，则返回一个空数组。"
  overload: System.Reflection.TypeDelegator.GetEvents*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)
  id: GetField(System.String,System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetField(String,BindingFlags)
  nameWithType: TypeDelegator.GetField(String,BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetField(String,BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "返回<xref:System.Reflection.FieldInfo>表示具有指定名称的字段的对象。</xref:System.Reflection.FieldInfo>"
  remarks: "使用`bindingAttr` <xref:System.Reflection.BindingFlags>。NonPublic 返回所有的公共和非公共字段。</xref:System.Reflection.BindingFlags> 使用`BindingFlags.IgnoreCase`若要忽略的字段，这种情况，如搜索不区分大小写，默认情况下。"
  syntax:
    content: public override System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: name
      type: System.String
      description: "要查找的字段的名称。"
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "影响执行搜索的方式的位掩码。 值是从零个或多个位标志的组合<xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>。"
    return:
      type: System.Reflection.FieldInfo
      description: "A <xref uid=&quot;langword_csharp_FieldInfo&quot; name=&quot;FieldInfo&quot; href=&quot;&quot;> </xref>对象表示的字段声明或继承的这<xref uid=&quot;langword_csharp_TypeDelegator&quot; name=&quot;TypeDelegator&quot; href=&quot;&quot;></xref>具有指定名称。 返回<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果不找到任何此类字段。"
  overload: System.Reflection.TypeDelegator.GetField*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>name</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)
  id: GetFields(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetFields(BindingFlags)
  nameWithType: TypeDelegator.GetFields(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetFields(BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "返回的数组<xref:System.Reflection.FieldInfo>对象包装由当前的类型表示的数据字段定义<xref href=&quot;System.Reflection.TypeDelegator&quot;> </xref>。</xref:System.Reflection.FieldInfo>"
  remarks: "GetFields 方法不返回字段按特定的顺序，如按字母顺序排列或声明顺序排列。 因为该顺序可能会变化，你的代码必须不依赖于字段的返回顺序。       使用`bindingAttr` <xref:System.Reflection.BindingFlags>。NonPublic 返回所有的公共和非公共字段。</xref:System.Reflection.BindingFlags>"
  syntax:
    content: public override System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "影响执行搜索的方式的位掩码。 值是从零个或多个位标志的组合<xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>。"
    return:
      type: System.Reflection.FieldInfo[]
      description: "类型的数组<xref uid=&quot;langword_csharp_FieldInfo&quot; name=&quot;FieldInfo&quot; href=&quot;&quot;></xref>的包含字段声明或继承的当前<xref uid=&quot;langword_csharp_TypeDelegator&quot; name=&quot;TypeDelegator&quot; href=&quot;&quot;> </xref>。 如果没有匹配的字段，则返回空数组。"
  overload: System.Reflection.TypeDelegator.GetFields*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)
  id: GetInterface(System.String,System.Boolean)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetInterface(String,Boolean)
  nameWithType: TypeDelegator.GetInterface(String,Boolean)
  fullName: System.Reflection.TypeDelegator.GetInterface(String,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "返回由包装由当前的类型实现的指定的接口<xref href=&quot;System.Reflection.TypeDelegator&quot;> </xref>。"
  syntax:
    content: public override Type GetInterface (string name, bool ignoreCase);
    parameters:
    - id: name
      type: System.String
      description: "由当前类实现的接口的完全限定的名称。"
    - id: ignoreCase
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果大小写，则忽略;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.Type
      description: "A <xref uid=&quot;langword_csharp_Type&quot; name=&quot;Type&quot; href=&quot;&quot;> </xref>表示由当前类中实现 （直接或间接），具有匹配的指定的名称的完全限定名的接口的对象。 如果没有与名称匹配的接口是找到为 null 则返回。"
  overload: System.Reflection.TypeDelegator.GetInterface*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>name</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetInterfaceMap(System.Type)
  id: GetInterfaceMap(System.Type)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetInterfaceMap(Type)
  nameWithType: TypeDelegator.GetInterfaceMap(Type)
  fullName: System.Reflection.TypeDelegator.GetInterfaceMap(Type)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "返回指定的接口类型的接口映射。"
  remarks: "接口映射表示接口到实现该接口的类上的实际方法的映射方式。"
  syntax:
    content: public override System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);
    parameters:
    - id: interfaceType
      type: System.Type
      description: "<xref:System.Type>要检索的映射的接口。</xref:System.Type>"
    return:
      type: System.Reflection.InterfaceMapping
      description: "<xref:System.Reflection.InterfaceMapping>对象表示的接口映射<code> interfaceType </code>。</xref:System.Reflection.InterfaceMapping>"
  overload: System.Reflection.TypeDelegator.GetInterfaceMap*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetInterfaces
  id: GetInterfaces
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetInterfaces()
  nameWithType: TypeDelegator.GetInterfaces()
  fullName: System.Reflection.TypeDelegator.GetInterfaces()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "返回在当前类及其基类上实现的所有接口。"
  syntax:
    content: public override Type[] GetInterfaces ();
    parameters: []
    return:
      type: System.Type[]
      description: "类型的数组<xref uid=&quot;langword_csharp_Type&quot; name=&quot;Type&quot; href=&quot;&quot;></xref>包含在当前类及其基类上实现的所有接口。 如果未定义任何内容，则返回一个空数组。"
  overload: System.Reflection.TypeDelegator.GetInterfaces*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)
  id: GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetMember(String,MemberTypes,BindingFlags)
  nameWithType: TypeDelegator.GetMember(String,MemberTypes,BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetMember(String,MemberTypes,BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "返回由指定的成员 （属性、 方法、 构造函数、 字段、 事件和嵌套的类型） 给定<code> name </code>， <code> type </code>，和<code> bindingAttr </code>。"
  remarks: "If `bindingAttr` is <xref:System.Reflection.BindingFlags>.非公开的所有成员将被都视为。</xref:System.Reflection.BindingFlags> 如果没有匹配项，则返回一个空数组。"
  syntax:
    content: public override System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: name
      type: System.String
      description: "要获取的成员的名称。"
    - id: type
      type: System.Reflection.MemberTypes
      description: "影响执行搜索的方式的位掩码。 值是从零个或多个位标志的组合<xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>。"
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "要获取成员的类型。"
    return:
      type: System.Reflection.MemberInfo[]
      description: "类型的数组<xref uid=&quot;langword_csharp_MemberInfo&quot; name=&quot;MemberInfo&quot; href=&quot;&quot;></xref>包含当前类和其基类的符合指定的条件的所有成员。"
  overload: System.Reflection.TypeDelegator.GetMember*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>name</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)
  id: GetMembers(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetMembers(BindingFlags)
  nameWithType: TypeDelegator.GetMembers(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetMembers(BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "返回由指定成员<code> bindingAttr </code>。"
  remarks: "If `bindingAttr` is <xref:System.Reflection.BindingFlags>.非公开的所有成员将被都视为。</xref:System.Reflection.BindingFlags> 如果没有匹配项，则返回一个空数组。"
  syntax:
    content: public override System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "影响执行搜索的方式的位掩码。 值是从零个或多个位标志的组合<xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>。"
    return:
      type: System.Reflection.MemberInfo[]
      description: "类型的数组<xref uid=&quot;langword_csharp_MemberInfo&quot; name=&quot;MemberInfo&quot; href=&quot;&quot;></xref>包含当前类和满足其基本类的所有成员<code> bindingAttr </code>筛选器。"
  overload: System.Reflection.TypeDelegator.GetMembers*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  id: GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetMethodImpl(String,BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  nameWithType: TypeDelegator.GetMethodImpl(String,BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  fullName: System.Reflection.TypeDelegator.GetMethodImpl(String,BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "搜索其参数与指定的参数类型及修饰符，使用指定的绑定约束和指定的调用约定匹配的指定方法。"
  remarks: "`callConvention`参数指示的入口点的调用约定。 如果没有<xref:System.Reflection.CallingConventions>指定，则默认`CallingConventions`值`Standard`使用。</xref:System.Reflection.CallingConventions>"
  syntax:
    content: protected override System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);
    parameters:
    - id: name
      type: System.String
      description: "方法名。"
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "影响执行搜索的方式的位掩码。 值是从零个或多个位标志的组合<xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>。"
    - id: binder
      type: System.Reflection.Binder
      description: "启用绑定、 强制自变量的对象类型、 成员的调用，以及检索<xref uid=&quot;langword_csharp_MemberInfo&quot; name=&quot;MemberInfo&quot; href=&quot;&quot;></xref>对象使用反射。 如果`binder`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，则使用默认联编程序。"
    - id: callConvention
      type: System.Reflection.CallingConventions
      description: "调用约定。"
    - id: types
      type: System.Type[]
      description: "类型的数组<xref uid=&quot;langword_csharp_Type&quot; name=&quot;Type&quot; href=&quot;&quot;></xref>包含的参数数量、 顺序和类型列表。 类型不能为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>; 使用适当<xref uid=&quot;langword_csharp_GetMethod&quot; name=&quot;GetMethod&quot; href=&quot;&quot;></xref>方法或搜索不带参数的方法的空数组。"
    - id: modifiers
      type: System.Reflection.ParameterModifier[]
      description: "类型的数组<xref uid=&quot;langword_csharp_ParameterModifier&quot; name=&quot;ParameterModifier&quot; href=&quot;&quot;></xref>具有相同的长度，作为`types`数组，其元素表示要获取的方法的参数与关联的属性。"
    return:
      type: System.Reflection.MethodInfo
      description: "A <xref uid=&quot;langword_csharp_MethodInfoInfo&quot; name=&quot;MethodInfoInfo&quot; href=&quot;&quot;> </xref>符合指定的条件，该实现方法的对象或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果找不到匹配项。"
  overload: System.Reflection.TypeDelegator.GetMethodImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetMethods(System.Reflection.BindingFlags)
  id: GetMethods(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetMethods(BindingFlags)
  nameWithType: TypeDelegator.GetMethods(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetMethods(BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "返回的数组<xref:System.Reflection.MethodInfo>对象表示由当前包装类型的指定的方法<xref href=&quot;System.Reflection.TypeDelegator&quot;> </xref>。</xref:System.Reflection.MethodInfo>"
  syntax:
    content: public override System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "影响执行搜索的方式的位掩码。 值是从零个或多个位标志的组合<xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>。"
    return:
      type: System.Reflection.MethodInfo[]
      description: "数组<xref uid=&quot;langword_csharp_MethodInfo&quot; name=&quot;MethodInfo&quot; href=&quot;&quot;></xref>表示在此定义的方法的对象<xref uid=&quot;langword_csharp_TypeDelegator&quot; name=&quot;TypeDelegator&quot; href=&quot;&quot;> </xref>。"
  overload: System.Reflection.TypeDelegator.GetMethods*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)
  id: GetNestedType(System.String,System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetNestedType(String,BindingFlags)
  nameWithType: TypeDelegator.GetNestedType(String,BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetNestedType(String,BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "返回指定的嵌套的类型<code> name </code>并在<code> bindingAttr </code> ，所声明或继承的表示由当前的类型<xref href=&quot;System.Reflection.TypeDelegator&quot;> </xref>。"
  syntax:
    content: public override Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: name
      type: System.String
      description: "嵌套的类型的名称。"
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "影响执行搜索的方式的位掩码。 值是从零个或多个位标志的组合<xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>。"
    return:
      type: System.Type
      description: "A <xref uid=&quot;langword_csharp_Type&quot; name=&quot;Type&quot; href=&quot;&quot;> </xref>表示的嵌套的类型的对象。"
  overload: System.Reflection.TypeDelegator.GetNestedType*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>name</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetNestedTypes(System.Reflection.BindingFlags)
  id: GetNestedTypes(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetNestedTypes(BindingFlags)
  nameWithType: TypeDelegator.GetNestedTypes(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetNestedTypes(BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "返回在指定的嵌套的类型<code> bindingAttr </code> ，所声明或继承的包装由当前的类型<xref href=&quot;System.Reflection.TypeDelegator&quot;> </xref>。"
  syntax:
    content: public override Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "影响执行搜索的方式的位掩码。 值是从零个或多个位标志的组合<xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>。"
    return:
      type: System.Type[]
      description: "类型的数组<xref uid=&quot;langword_csharp_Type&quot; name=&quot;Type&quot; href=&quot;&quot;></xref>包含嵌套的类型。"
  overload: System.Reflection.TypeDelegator.GetNestedTypes*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetProperties(System.Reflection.BindingFlags)
  id: GetProperties(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetProperties(BindingFlags)
  nameWithType: TypeDelegator.GetProperties(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetProperties(BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "返回的数组<xref:System.Reflection.PropertyInfo>对象表示由当前包装类型的属性<xref href=&quot;System.Reflection.TypeDelegator&quot;> </xref>。</xref:System.Reflection.PropertyInfo>"
  syntax:
    content: public override System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "影响执行搜索的方式的位掩码。 值是从零个或多个位标志的组合<xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>。"
    return:
      type: System.Reflection.PropertyInfo[]
      description: "数组<xref uid=&quot;langword_csharp_PropertyInfo&quot; name=&quot;PropertyInfo&quot; href=&quot;&quot;></xref>表示定义此属性的对象<xref uid=&quot;langword_csharp_TypeDelegator&quot; name=&quot;TypeDelegator&quot; href=&quot;&quot;> </xref>。"
  overload: System.Reflection.TypeDelegator.GetProperties*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])
  id: GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetPropertyImpl(String,BindingFlags,Binder,Type,Type[],ParameterModifier[])
  nameWithType: TypeDelegator.GetPropertyImpl(String,BindingFlags,Binder,Type,Type[],ParameterModifier[])
  fullName: System.Reflection.TypeDelegator.GetPropertyImpl(String,BindingFlags,Binder,Type,Type[],ParameterModifier[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "当在派生类中重写，搜索其参数与指定的自变量类型及修饰符，使用指定的绑定约束匹配的指定属性。"
  syntax:
    content: protected override System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);
    parameters:
    - id: name
      type: System.String
      description: "要获取的属性。"
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "影响执行搜索的方式的位掩码。 值是从零个或多个位标志的组合<xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>。"
    - id: binder
      type: System.Reflection.Binder
      description: "启用绑定、 强制自变量的对象类型、 成员的调用，以及检索<xref uid=&quot;langword_csharp_MemberInfo&quot; name=&quot;MemberInfo&quot; href=&quot;&quot;></xref>通过反射的对象。 如果`binder`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，则使用默认联编程序。 See <xref href=&quot;System.Reflection.Binder&quot;></xref>."
    - id: returnType
      type: System.Type
      description: "属性的返回类型。"
    - id: types
      type: System.Type[]
      description: "参数类型列表。 表示列表的个数、 顺序和类型的参数。 类型不能为空，则使用适当<xref uid=&quot;langword_csharp_GetMethod&quot; name=&quot;GetMethod&quot; href=&quot;&quot;></xref>方法或搜索不带参数的方法的空数组。"
    - id: modifiers
      type: System.Reflection.ParameterModifier[]
      description: "与具有表示要获取的方法的参数与关联的属性的元素类型的长度相同的数组。"
    return:
      type: System.Reflection.PropertyInfo
      description: "A<xref:System.Reflection.PropertyInfo>对象与指定的条件匹配的属性或如果找不到匹配项，则为 null。</xref:System.Reflection.PropertyInfo>"
  overload: System.Reflection.TypeDelegator.GetPropertyImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GUID
  id: GUID
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GUID
  nameWithType: TypeDelegator.GUID
  fullName: System.Reflection.TypeDelegator.GUID
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "获取实现的类型的 GUID （全局唯一标识符）。"
  remarks: "GUID （全局唯一标识符） 是用于标识类或接口的 128 位唯一标识字符串。 它是主要适用于 Microsoft.NET Framework 和 COM 之间的互操作性"
  syntax:
    content: public override Guid GUID { get; }
    return:
      type: System.Guid
      description: "一个 GUID。"
  overload: System.Reflection.TypeDelegator.GUID*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.HasElementTypeImpl
  id: HasElementTypeImpl
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: HasElementTypeImpl()
  nameWithType: TypeDelegator.HasElementTypeImpl()
  fullName: System.Reflection.TypeDelegator.HasElementTypeImpl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "获取一个值，该值指示是否当前<xref:System.Type>包含还是引用另一类型; 即，无论当前<xref:System.Type>是数组、 指针或 ByRef。</xref:System.Type> </xref:System.Type>"
  syntax:
    content: protected override bool HasElementTypeImpl ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref:System.Type>是数组、 指针或 ByRef; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.Type>"
  overload: System.Reflection.TypeDelegator.HasElementTypeImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])
  id: InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: InvokeMember(String,BindingFlags,Binder,Object,Object[],ParameterModifier[],CultureInfo,String[])
  nameWithType: TypeDelegator.InvokeMember(String,BindingFlags,Binder,Object,Object[],ParameterModifier[],CultureInfo,String[])
  fullName: System.Reflection.TypeDelegator.InvokeMember(String,BindingFlags,Binder,Object,Object[],ParameterModifier[],CultureInfo,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "调用指定的成员。 要调用的方法必须是可访问，并且提供与指定的自变量列表中，指定的活页夹和调用特性的约束下最具体的匹配。"
  remarks: "将调用一个方法，如果这两个符合以下条件:-数值方法声明中的参数等于指定的参数列表中的参数的数目 （除非成员上定义了默认自变量）。      的可以由联编程序参数的类型转换每个参数的类型。       联编程序将查找所有匹配的方法。 这些方法找到基于请求的绑定类型 (`BindingFlags.MethodInvoke`， `BindingFlags.GetProperties`，依次类推)。 按名称、 数量的参数和一组绑定器中定义的搜索修饰符进行筛选的方法集。       选择方法后，将调用它。 此时，检查可访问性。 搜索可能基于与该方法关联的可访问性属性来控制搜索哪些方法集。 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName>方法负责选择要调用的方法。</xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName> 默认的联编程序选择最精确的匹配。      1> [!NOTE]&1;> 访问限制在完全受信任的代码将被忽略。 即私有构造函数、 方法、 字段和属性可以访问和使用反射，只要完全受信任代码调用。       目前，`InvokeMember`对 Microsoft.NET Framework 反射语义执行，其中每种类型的对象。       如果按名称指定的成员是一个数组和`BindingFlags.GetField`上设置标志`invokeAttr`、`args`数组指定其值是要返回的元素。 例如，以下调用通过`Type`对象`t`返回的字符串数组 MyArray，这是调用对象的成员的第一个元素的值︰`String ret = (String) t.InvokeMember (&quot;MyArray&quot;, BindingFlags.GetField, null, this, new Variant[]{0});`可以使用`InvokeMember`设置成员数组的一个或多个元素。 所有元素都设置为相同的值。 `args`数组必须进行格式设置，如下所示︰```   {index1,       index2,, value}   ```例如，若要设置 MyArray 的第一个成员上一示例中，语法是，如下所示︰```   t.InvokeMember (&quot;MyArray&quot;, BindingFlags.SetField, null, this, new       Variant[]{0,&quot;Updated&quot;});   ```"
  syntax:
    content: public override object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);
    parameters:
    - id: name
      type: System.String
      description: "要调用的成员的名称。 这可能是构造函数、 方法、 属性或字段。 如果是空字符串 (&quot;&quot;) 传递时，默认值调用成员。"
    - id: invokeAttr
      type: System.Reflection.BindingFlags
      description: '调用属性。 This must be one of the following <xref href=&quot;System.Reflection.BindingFlags&quot;></xref> : <xref uid=&quot;langword_csharp_InvokeMethod&quot; name=&quot;InvokeMethod&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_CreateInstance&quot; name=&quot;CreateInstance&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Static&quot; name=&quot;Static&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_GetField&quot; name=&quot;GetField&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_SetField&quot; name=&quot;SetField&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_GetProperty&quot; name=&quot;GetProperty&quot; href=&quot;&quot;></xref>, or <xref uid=&quot;langword_csharp_SetProperty&quot; name=&quot;SetProperty&quot; href=&quot;&quot;></xref>. 必须指定合适的调用属性。 要调用静态成员是否<xref uid=&quot;langword_csharp_Static&quot; name=&quot;Static&quot; href=&quot;&quot;></xref>必须设置标志。'
    - id: binder
      type: System.Reflection.Binder
      description: "启用绑定、 强制自变量的对象类型、 成员的调用，以及检索<xref uid=&quot;langword_csharp_MemberInfo&quot; name=&quot;MemberInfo&quot; href=&quot;&quot;></xref>通过反射的对象。 如果`binder`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，则使用默认联编程序。 See <xref href=&quot;System.Reflection.Binder&quot;></xref>."
    - id: target
      type: System.Object
      description: "对其调用指定的成员的对象。"
    - id: args
      type: System.Object[]
      description: "类型的数组<xref uid=&quot;langword_csharp_Object&quot; name=&quot;Object&quot; href=&quot;&quot;> </xref> ，其中包含要调用的数量、 顺序和成员的参数的类型。 如果`args`包含未初始化<xref uid=&quot;langword_csharp_Object&quot; name=&quot;Object&quot; href=&quot;&quot;> </xref>，它将被视为空，具有默认的联编程序，可以将它扩展为 0、 0.0 或字符串。"
    - id: modifiers
      type: System.Reflection.ParameterModifier[]
      description: "类型的数组<xref uid=&quot;langword_csharp_ParameterModifer&quot; name=&quot;ParameterModifer&quot; href=&quot;&quot;> </xref> ，它是与长度相同`args`，其元素表示与要调用的成员的自变量关联的属性。 一个参数具有与之关联的成员签名中的属性。 ByRef，对于使用<xref uid=&quot;langword_csharp_ParameterModifer.ByRef&quot; name=&quot;ParameterModifer.ByRef&quot; href=&quot;&quot;> </xref>，并为 none、 使用<xref uid=&quot;langword_csharp_ParameterModifer.None&quot; name=&quot;ParameterModifer.None&quot; href=&quot;&quot;> </xref>。 默认的联编程序的未精确匹配这些。 这样的特性<xref uid=&quot;langword_csharp_In&quot; name=&quot;In&quot; href=&quot;&quot;></xref>和<xref uid=&quot;langword_csharp_InOut&quot; name=&quot;InOut&quot; href=&quot;&quot;></xref>不使用在绑定中，并且可以使用查看<xref uid=&quot;langword_csharp_ParameterInfo&quot; name=&quot;ParameterInfo&quot; href=&quot;&quot;> </xref>。"
    - id: culture
      type: System.Globalization.CultureInfo
      description: "实例<xref uid=&quot;langword_csharp_CultureInfo&quot; name=&quot;CultureInfo&quot; href=&quot;&quot;></xref>用于控制类型强制。 这很有必要，例如，将表示到 1000年的 string 转换<xref uid=&quot;langword_csharp_Double&quot; name=&quot;Double&quot; href=&quot;&quot;></xref>值，因为不同的区域性以不同方式表示 1000年。 如果`culture`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>、 <xref uid=&quot;langword_csharp_CultureInfo&quot; name=&quot;CultureInfo&quot; href=&quot;&quot;> </xref>当前线程的<xref uid=&quot;langword_csharp_CultureInfo&quot; name=&quot;CultureInfo&quot; href=&quot;&quot;></xref>使用。"
    - id: namedParameters
      type: System.String[]
      description: "类型的数组<xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>包含参数名称相匹配，从元素零，开始使用`args`数组。 数组中必须没有漏洞。 If `args`. <xref uid=&quot;langword_csharp_Length&quot; name=&quot;Length&quot; href=&quot;&quot;></xref>大于`namedParameters`。 <xref uid=&quot;langword_csharp_Length&quot; name=&quot;Length&quot; href=&quot;&quot;></xref>按顺序填充剩余的参数。"
    return:
      type: System.Object
      description: "<xref uid=&quot;langword_csharp_Object&quot; name=&quot;Object&quot; href=&quot;&quot;> </xref>表示被调用成员的返回值。"
  overload: System.Reflection.TypeDelegator.InvokeMember*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.IsArrayImpl
  id: IsArrayImpl
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: IsArrayImpl()
  nameWithType: TypeDelegator.IsArrayImpl()
  fullName: System.Reflection.TypeDelegator.IsArrayImpl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "返回一个值，该值指示是否<xref:System.Type>是数组。</xref:System.Type>"
  syntax:
    content: protected override bool IsArrayImpl ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref:System.Type>是一个数组; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.Type>"
  overload: System.Reflection.TypeDelegator.IsArrayImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.IsAssignableFrom(System.Reflection.TypeInfo)
  id: IsAssignableFrom(System.Reflection.TypeInfo)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: IsAssignableFrom(TypeInfo)
  nameWithType: TypeDelegator.IsAssignableFrom(TypeInfo)
  fullName: System.Reflection.TypeDelegator.IsAssignableFrom(TypeInfo)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "返回一个值，该值指示指定的类型是否可以分配给此类型。"
  syntax:
    content: public override bool IsAssignableFrom (System.Reflection.TypeInfo typeInfo);
    parameters:
    - id: typeInfo
      type: System.Reflection.TypeInfo
      description: "要检查的类型。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果指定的类型可以分配给此类型;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Reflection.TypeDelegator.IsAssignableFrom*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.IsByRefImpl
  id: IsByRefImpl
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: IsByRefImpl()
  nameWithType: TypeDelegator.IsByRefImpl()
  fullName: System.Reflection.TypeDelegator.IsByRefImpl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "返回一个值，该值指示是否<xref:System.Type>按引用传递。</xref:System.Type>"
  syntax:
    content: protected override bool IsByRefImpl ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref:System.Type>传递通过引用; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.Type>"
  overload: System.Reflection.TypeDelegator.IsByRefImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.IsCOMObjectImpl
  id: IsCOMObjectImpl
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: IsCOMObjectImpl()
  nameWithType: TypeDelegator.IsCOMObjectImpl()
  fullName: System.Reflection.TypeDelegator.IsCOMObjectImpl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "返回一个值，该值指示是否<xref:System.Type>为 COM 对象。</xref:System.Type>"
  syntax:
    content: protected override bool IsCOMObjectImpl ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref:System.Type>为 COM 对象; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.Type>"
  overload: System.Reflection.TypeDelegator.IsCOMObjectImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.IsConstructedGenericType
  id: IsConstructedGenericType
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: IsConstructedGenericType
  nameWithType: TypeDelegator.IsConstructedGenericType
  fullName: System.Reflection.TypeDelegator.IsConstructedGenericType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "获取一个值，该值指示此对象是否表示构造的泛型类型。"
  syntax:
    content: public override bool IsConstructedGenericType { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果此对象表示构造的泛型类型;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Reflection.TypeDelegator.IsConstructedGenericType*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)
  id: IsDefined(System.Type,System.Boolean)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: IsDefined(Type,Boolean)
  nameWithType: TypeDelegator.IsDefined(Type,Boolean)
  fullName: System.Reflection.TypeDelegator.IsDefined(Type,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "该值指示是否标识的自定义特性<code> attributeType </code>定义。"
  syntax:
    content: public override bool IsDefined (Type attributeType, bool inherit);
    parameters:
    - id: attributeType
      type: System.Type
      description: "指定是否搜索此类型的继承链以查找属性。"
    - id: inherit
      type: System.Boolean
      description: "包含由类型标识的自定义特性的数组。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果由标识的自定义特性<code> attributeType </code>定义; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Reflection.TypeDelegator.IsDefined*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>attributeType</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Reflection.ReflectionTypeLoadException
    commentId: T:System.Reflection.ReflectionTypeLoadException
    description: "无法加载自定义属性类型。"
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.IsPointerImpl
  id: IsPointerImpl
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: IsPointerImpl()
  nameWithType: TypeDelegator.IsPointerImpl()
  fullName: System.Reflection.TypeDelegator.IsPointerImpl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "返回一个值，该值指示是否<xref:System.Type>是指针。</xref:System.Type>"
  syntax:
    content: protected override bool IsPointerImpl ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref:System.Type>为指针; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.Type>"
  overload: System.Reflection.TypeDelegator.IsPointerImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.IsPrimitiveImpl
  id: IsPrimitiveImpl
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: IsPrimitiveImpl()
  nameWithType: TypeDelegator.IsPrimitiveImpl()
  fullName: System.Reflection.TypeDelegator.IsPrimitiveImpl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "返回一个值，该值指示是否<xref:System.Type>为基元类型之一。</xref:System.Type>"
  syntax:
    content: protected override bool IsPrimitiveImpl ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref:System.Type>为基元类型之一; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.Type>"
  overload: System.Reflection.TypeDelegator.IsPrimitiveImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.IsValueTypeImpl
  id: IsValueTypeImpl
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: IsValueTypeImpl()
  nameWithType: TypeDelegator.IsValueTypeImpl()
  fullName: System.Reflection.TypeDelegator.IsValueTypeImpl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "返回一个值，该值指示类型是否是值类型;也就是说，不类或接口。"
  syntax:
    content: protected override bool IsValueTypeImpl ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果类型为值类型;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Reflection.TypeDelegator.IsValueTypeImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.MetadataToken
  id: MetadataToken
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: MetadataToken
  nameWithType: TypeDelegator.MetadataToken
  fullName: System.Reflection.TypeDelegator.MetadataToken
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "获取一个值，标识此元数据中的实体。"
  remarks: "使用此属性获取的令牌可以传递到非托管的反射 API。 有关详细信息，请参阅[非托管的反射 API](http://msdn.microsoft.com/en-us/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)。"
  syntax:
    content: public override int MetadataToken { get; }
    return:
      type: System.Int32
      description: "一个值，该值与该模块，结合使用唯一标识此元数据中的实体。"
  overload: System.Reflection.TypeDelegator.MetadataToken*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.Module
  id: Module
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: Module
  nameWithType: TypeDelegator.Module
  fullName: System.Reflection.TypeDelegator.Module
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "获取包含实现的类型的模块。"
  remarks: "模块是一个可加载的单元可以包含类型声明和实现。 模块包含足够的信息来启用公共语言运行时在模块加载时找到所有实现位。"
  syntax:
    content: public override System.Reflection.Module Module { get; }
    return:
      type: System.Reflection.Module
      description: "A<xref:System.Reflection.Module>表示实现的类型的模块的对象。</xref:System.Reflection.Module>"
  overload: System.Reflection.TypeDelegator.Module*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.Name
  id: Name
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: Name
  nameWithType: TypeDelegator.Name
  fullName: System.Reflection.TypeDelegator.Name
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "获取具有删除的路径实现的类型的名称。"
  remarks: "包含当前的名称的字符串`TypeDelegator`。 返回只是简单名称，不是完全限定名称。 若要获取的名称和路径，请使用<xref:System.Reflection.TypeDelegator.FullName%2A>。</xref:System.Reflection.TypeDelegator.FullName%2A>"
  syntax:
    content: public override string Name { get; }
    return:
      type: System.String
      description: "A <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref>包含该类型的非限定名称。"
  overload: System.Reflection.TypeDelegator.Name*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.Namespace
  id: Namespace
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: Namespace
  nameWithType: TypeDelegator.Namespace
  fullName: System.Reflection.TypeDelegator.Namespace
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "获取实现的类型的命名空间。"
  remarks: "此属性获取包含当前的命名空间的字符串`TypeDelegator`。 例如，如果`TypeDelegator`是<xref:System.Reflection.TypeFilter>，返回的命名空间是<xref:System.Reflection>.</xref:System.Reflection> </xref:System.Reflection.TypeFilter>"
  syntax:
    content: public override string Namespace { get; }
    return:
      type: System.String
      description: "A <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref>包含该类型的命名空间。"
  overload: System.Reflection.TypeDelegator.Namespace*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.TypeHandle
  id: TypeHandle
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: TypeHandle
  nameWithType: TypeDelegator.TypeHandle
  fullName: System.Reflection.TypeDelegator.TypeHandle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "获取的内部元数据表示形式实现的类型的句柄。"
  remarks: "类型句柄是与每个类型相关联的唯一整数值。 在运行时句柄是唯一的。"
  syntax:
    content: public override RuntimeTypeHandle TypeHandle { get; }
    return:
      type: System.RuntimeTypeHandle
      description: "A <xref uid=&quot;langword_csharp_RuntimeTypeHandle&quot; name=&quot;RuntimeTypeHandle&quot; href=&quot;&quot;></xref> object."
  overload: System.Reflection.TypeDelegator.TypeHandle*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.typeImpl
  id: typeImpl
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: typeImpl
  nameWithType: TypeDelegator.typeImpl
  fullName: System.Reflection.TypeDelegator.typeImpl
  type: Field
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "值，该值指示类型信息。"
  syntax:
    content: protected Type typeImpl;
    return:
      type: System.Type
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.UnderlyingSystemType
  id: UnderlyingSystemType
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: UnderlyingSystemType
  nameWithType: TypeDelegator.UnderlyingSystemType
  fullName: System.Reflection.TypeDelegator.UnderlyingSystemType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "获取基础<xref:System.Type>表示实现的类型。</xref:System.Type>"
  syntax:
    content: public override Type UnderlyingSystemType { get; }
    return:
      type: System.Type
      description: "基础类型。"
  overload: System.Reflection.TypeDelegator.UnderlyingSystemType*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Reflection.TypeInfo
  isExternal: false
  name: System.Reflection.TypeInfo
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.TypeLoadException
  isExternal: true
  name: System.TypeLoadException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Reflection.ReflectionTypeLoadException
  isExternal: true
  name: System.Reflection.ReflectionTypeLoadException
- uid: System.Reflection.TypeDelegator.#ctor
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: TypeDelegator()
  nameWithType: TypeDelegator.TypeDelegator()
  fullName: System.Reflection.TypeDelegator.TypeDelegator()
- uid: System.Reflection.TypeDelegator.#ctor(System.Type)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: TypeDelegator(Type)
  nameWithType: TypeDelegator.TypeDelegator(Type)
  fullName: System.Reflection.TypeDelegator.TypeDelegator(Type)
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Reflection.TypeDelegator.Assembly
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: Assembly
  nameWithType: TypeDelegator.Assembly
  fullName: System.Reflection.TypeDelegator.Assembly
- uid: System.Reflection.Assembly
  parent: System.Reflection
  isExternal: true
  name: Assembly
  nameWithType: Assembly
  fullName: System.Reflection.Assembly
- uid: System.Reflection.TypeDelegator.AssemblyQualifiedName
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: AssemblyQualifiedName
  nameWithType: TypeDelegator.AssemblyQualifiedName
  fullName: System.Reflection.TypeDelegator.AssemblyQualifiedName
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Reflection.TypeDelegator.BaseType
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: BaseType
  nameWithType: TypeDelegator.BaseType
  fullName: System.Reflection.TypeDelegator.BaseType
- uid: System.Reflection.TypeDelegator.FullName
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: FullName
  nameWithType: TypeDelegator.FullName
  fullName: System.Reflection.TypeDelegator.FullName
- uid: System.Reflection.TypeDelegator.GetAttributeFlagsImpl
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetAttributeFlagsImpl()
  nameWithType: TypeDelegator.GetAttributeFlagsImpl()
  fullName: System.Reflection.TypeDelegator.GetAttributeFlagsImpl()
- uid: System.Reflection.TypeAttributes
  parent: System.Reflection
  isExternal: true
  name: TypeAttributes
  nameWithType: TypeAttributes
  fullName: System.Reflection.TypeAttributes
- uid: System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetConstructorImpl(BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  nameWithType: TypeDelegator.GetConstructorImpl(BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  fullName: System.Reflection.TypeDelegator.GetConstructorImpl(BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
- uid: System.Reflection.ConstructorInfo
  parent: System.Reflection
  isExternal: true
  name: ConstructorInfo
  nameWithType: ConstructorInfo
  fullName: System.Reflection.ConstructorInfo
- uid: System.Reflection.BindingFlags
  parent: System.Reflection
  isExternal: false
  name: BindingFlags
  nameWithType: BindingFlags
  fullName: System.Reflection.BindingFlags
- uid: System.Reflection.Binder
  parent: System.Reflection
  isExternal: false
  name: Binder
  nameWithType: Binder
  fullName: System.Reflection.Binder
- uid: System.Reflection.CallingConventions
  parent: System.Reflection
  isExternal: true
  name: CallingConventions
  nameWithType: CallingConventions
  fullName: System.Reflection.CallingConventions
- uid: System.Type[]
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type[]
  spec.csharp:
  - uid: System.Type
    name: Type
    nameWithType: Type
    fullName: Type[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.ParameterModifier[]
  parent: System.Reflection
  isExternal: false
  name: ParameterModifier
  nameWithType: ParameterModifier
  fullName: System.Reflection.ParameterModifier[]
  spec.csharp:
  - uid: System.Reflection.ParameterModifier
    name: ParameterModifier
    nameWithType: ParameterModifier
    fullName: ParameterModifier[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetConstructors(BindingFlags)
  nameWithType: TypeDelegator.GetConstructors(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetConstructors(BindingFlags)
- uid: System.Reflection.ConstructorInfo[]
  parent: System.Reflection
  isExternal: true
  name: ConstructorInfo
  nameWithType: ConstructorInfo
  fullName: System.Reflection.ConstructorInfo[]
  spec.csharp:
  - uid: System.Reflection.ConstructorInfo
    name: ConstructorInfo
    nameWithType: ConstructorInfo
    fullName: ConstructorInfo[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.TypeDelegator.GetCustomAttributes(System.Boolean)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetCustomAttributes(Boolean)
  nameWithType: TypeDelegator.GetCustomAttributes(Boolean)
  fullName: System.Reflection.TypeDelegator.GetCustomAttributes(Boolean)
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetCustomAttributes(Type,Boolean)
  nameWithType: TypeDelegator.GetCustomAttributes(Type,Boolean)
  fullName: System.Reflection.TypeDelegator.GetCustomAttributes(Type,Boolean)
- uid: System.Reflection.TypeDelegator.GetElementType
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetElementType()
  nameWithType: TypeDelegator.GetElementType()
  fullName: System.Reflection.TypeDelegator.GetElementType()
- uid: System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetEvent(String,BindingFlags)
  nameWithType: TypeDelegator.GetEvent(String,BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetEvent(String,BindingFlags)
- uid: System.Reflection.EventInfo
  parent: System.Reflection
  isExternal: true
  name: EventInfo
  nameWithType: EventInfo
  fullName: System.Reflection.EventInfo
- uid: System.Reflection.TypeDelegator.GetEvents
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetEvents()
  nameWithType: TypeDelegator.GetEvents()
  fullName: System.Reflection.TypeDelegator.GetEvents()
- uid: System.Reflection.EventInfo[]
  parent: System.Reflection
  isExternal: true
  name: EventInfo
  nameWithType: EventInfo
  fullName: System.Reflection.EventInfo[]
  spec.csharp:
  - uid: System.Reflection.EventInfo
    name: EventInfo
    nameWithType: EventInfo
    fullName: EventInfo[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.TypeDelegator.GetEvents(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetEvents(BindingFlags)
  nameWithType: TypeDelegator.GetEvents(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetEvents(BindingFlags)
- uid: System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetField(String,BindingFlags)
  nameWithType: TypeDelegator.GetField(String,BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetField(String,BindingFlags)
- uid: System.Reflection.FieldInfo
  parent: System.Reflection
  isExternal: true
  name: FieldInfo
  nameWithType: FieldInfo
  fullName: System.Reflection.FieldInfo
- uid: System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetFields(BindingFlags)
  nameWithType: TypeDelegator.GetFields(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetFields(BindingFlags)
- uid: System.Reflection.FieldInfo[]
  parent: System.Reflection
  isExternal: true
  name: FieldInfo
  nameWithType: FieldInfo
  fullName: System.Reflection.FieldInfo[]
  spec.csharp:
  - uid: System.Reflection.FieldInfo
    name: FieldInfo
    nameWithType: FieldInfo
    fullName: FieldInfo[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetInterface(String,Boolean)
  nameWithType: TypeDelegator.GetInterface(String,Boolean)
  fullName: System.Reflection.TypeDelegator.GetInterface(String,Boolean)
- uid: System.Reflection.TypeDelegator.GetInterfaceMap(System.Type)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetInterfaceMap(Type)
  nameWithType: TypeDelegator.GetInterfaceMap(Type)
  fullName: System.Reflection.TypeDelegator.GetInterfaceMap(Type)
- uid: System.Reflection.InterfaceMapping
  parent: System.Reflection
  isExternal: true
  name: InterfaceMapping
  nameWithType: InterfaceMapping
  fullName: System.Reflection.InterfaceMapping
- uid: System.Reflection.TypeDelegator.GetInterfaces
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetInterfaces()
  nameWithType: TypeDelegator.GetInterfaces()
  fullName: System.Reflection.TypeDelegator.GetInterfaces()
- uid: System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetMember(String,MemberTypes,BindingFlags)
  nameWithType: TypeDelegator.GetMember(String,MemberTypes,BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetMember(String,MemberTypes,BindingFlags)
- uid: System.Reflection.MemberInfo[]
  parent: System.Reflection
  isExternal: true
  name: MemberInfo
  nameWithType: MemberInfo
  fullName: System.Reflection.MemberInfo[]
  spec.csharp:
  - uid: System.Reflection.MemberInfo
    name: MemberInfo
    nameWithType: MemberInfo
    fullName: MemberInfo[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.MemberTypes
  parent: System.Reflection
  isExternal: false
  name: MemberTypes
  nameWithType: MemberTypes
  fullName: System.Reflection.MemberTypes
- uid: System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetMembers(BindingFlags)
  nameWithType: TypeDelegator.GetMembers(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetMembers(BindingFlags)
- uid: System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetMethodImpl(String,BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  nameWithType: TypeDelegator.GetMethodImpl(String,BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  fullName: System.Reflection.TypeDelegator.GetMethodImpl(String,BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
- uid: System.Reflection.MethodInfo
  parent: System.Reflection
  isExternal: true
  name: MethodInfo
  nameWithType: MethodInfo
  fullName: System.Reflection.MethodInfo
- uid: System.Reflection.TypeDelegator.GetMethods(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetMethods(BindingFlags)
  nameWithType: TypeDelegator.GetMethods(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetMethods(BindingFlags)
- uid: System.Reflection.MethodInfo[]
  parent: System.Reflection
  isExternal: true
  name: MethodInfo
  nameWithType: MethodInfo
  fullName: System.Reflection.MethodInfo[]
  spec.csharp:
  - uid: System.Reflection.MethodInfo
    name: MethodInfo
    nameWithType: MethodInfo
    fullName: MethodInfo[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetNestedType(String,BindingFlags)
  nameWithType: TypeDelegator.GetNestedType(String,BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetNestedType(String,BindingFlags)
- uid: System.Reflection.TypeDelegator.GetNestedTypes(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetNestedTypes(BindingFlags)
  nameWithType: TypeDelegator.GetNestedTypes(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetNestedTypes(BindingFlags)
- uid: System.Reflection.TypeDelegator.GetProperties(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetProperties(BindingFlags)
  nameWithType: TypeDelegator.GetProperties(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetProperties(BindingFlags)
- uid: System.Reflection.PropertyInfo[]
  parent: System.Reflection
  isExternal: true
  name: PropertyInfo
  nameWithType: PropertyInfo
  fullName: System.Reflection.PropertyInfo[]
  spec.csharp:
  - uid: System.Reflection.PropertyInfo
    name: PropertyInfo
    nameWithType: PropertyInfo
    fullName: PropertyInfo[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetPropertyImpl(String,BindingFlags,Binder,Type,Type[],ParameterModifier[])
  nameWithType: TypeDelegator.GetPropertyImpl(String,BindingFlags,Binder,Type,Type[],ParameterModifier[])
  fullName: System.Reflection.TypeDelegator.GetPropertyImpl(String,BindingFlags,Binder,Type,Type[],ParameterModifier[])
- uid: System.Reflection.PropertyInfo
  parent: System.Reflection
  isExternal: true
  name: PropertyInfo
  nameWithType: PropertyInfo
  fullName: System.Reflection.PropertyInfo
- uid: System.Reflection.TypeDelegator.GUID
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GUID
  nameWithType: TypeDelegator.GUID
  fullName: System.Reflection.TypeDelegator.GUID
- uid: System.Guid
  parent: System
  isExternal: true
  name: Guid
  nameWithType: Guid
  fullName: System.Guid
- uid: System.Reflection.TypeDelegator.HasElementTypeImpl
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: HasElementTypeImpl()
  nameWithType: TypeDelegator.HasElementTypeImpl()
  fullName: System.Reflection.TypeDelegator.HasElementTypeImpl()
- uid: System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: InvokeMember(String,BindingFlags,Binder,Object,Object[],ParameterModifier[],CultureInfo,String[])
  nameWithType: TypeDelegator.InvokeMember(String,BindingFlags,Binder,Object,Object[],ParameterModifier[],CultureInfo,String[])
  fullName: System.Reflection.TypeDelegator.InvokeMember(String,BindingFlags,Binder,Object,Object[],ParameterModifier[],CultureInfo,String[])
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: true
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.TypeDelegator.IsArrayImpl
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsArrayImpl()
  nameWithType: TypeDelegator.IsArrayImpl()
  fullName: System.Reflection.TypeDelegator.IsArrayImpl()
- uid: System.Reflection.TypeDelegator.IsAssignableFrom(System.Reflection.TypeInfo)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsAssignableFrom(TypeInfo)
  nameWithType: TypeDelegator.IsAssignableFrom(TypeInfo)
  fullName: System.Reflection.TypeDelegator.IsAssignableFrom(TypeInfo)
- uid: System.Reflection.TypeDelegator.IsByRefImpl
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsByRefImpl()
  nameWithType: TypeDelegator.IsByRefImpl()
  fullName: System.Reflection.TypeDelegator.IsByRefImpl()
- uid: System.Reflection.TypeDelegator.IsCOMObjectImpl
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsCOMObjectImpl()
  nameWithType: TypeDelegator.IsCOMObjectImpl()
  fullName: System.Reflection.TypeDelegator.IsCOMObjectImpl()
- uid: System.Reflection.TypeDelegator.IsConstructedGenericType
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsConstructedGenericType
  nameWithType: TypeDelegator.IsConstructedGenericType
  fullName: System.Reflection.TypeDelegator.IsConstructedGenericType
- uid: System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsDefined(Type,Boolean)
  nameWithType: TypeDelegator.IsDefined(Type,Boolean)
  fullName: System.Reflection.TypeDelegator.IsDefined(Type,Boolean)
- uid: System.Reflection.TypeDelegator.IsPointerImpl
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsPointerImpl()
  nameWithType: TypeDelegator.IsPointerImpl()
  fullName: System.Reflection.TypeDelegator.IsPointerImpl()
- uid: System.Reflection.TypeDelegator.IsPrimitiveImpl
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsPrimitiveImpl()
  nameWithType: TypeDelegator.IsPrimitiveImpl()
  fullName: System.Reflection.TypeDelegator.IsPrimitiveImpl()
- uid: System.Reflection.TypeDelegator.IsValueTypeImpl
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsValueTypeImpl()
  nameWithType: TypeDelegator.IsValueTypeImpl()
  fullName: System.Reflection.TypeDelegator.IsValueTypeImpl()
- uid: System.Reflection.TypeDelegator.MetadataToken
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: MetadataToken
  nameWithType: TypeDelegator.MetadataToken
  fullName: System.Reflection.TypeDelegator.MetadataToken
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Reflection.TypeDelegator.Module
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: Module
  nameWithType: TypeDelegator.Module
  fullName: System.Reflection.TypeDelegator.Module
- uid: System.Reflection.Module
  parent: System.Reflection
  isExternal: true
  name: Module
  nameWithType: Module
  fullName: System.Reflection.Module
- uid: System.Reflection.TypeDelegator.Name
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: Name
  nameWithType: TypeDelegator.Name
  fullName: System.Reflection.TypeDelegator.Name
- uid: System.Reflection.TypeDelegator.Namespace
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: Namespace
  nameWithType: TypeDelegator.Namespace
  fullName: System.Reflection.TypeDelegator.Namespace
- uid: System.Reflection.TypeDelegator.TypeHandle
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: TypeHandle
  nameWithType: TypeDelegator.TypeHandle
  fullName: System.Reflection.TypeDelegator.TypeHandle
- uid: System.RuntimeTypeHandle
  parent: System
  isExternal: true
  name: RuntimeTypeHandle
  nameWithType: RuntimeTypeHandle
  fullName: System.RuntimeTypeHandle
- uid: System.Reflection.TypeDelegator.typeImpl
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: typeImpl
  nameWithType: TypeDelegator.typeImpl
  fullName: System.Reflection.TypeDelegator.typeImpl
- uid: System.Reflection.TypeDelegator.UnderlyingSystemType
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: UnderlyingSystemType
  nameWithType: TypeDelegator.UnderlyingSystemType
  fullName: System.Reflection.TypeDelegator.UnderlyingSystemType
- uid: System.Reflection.TypeDelegator.#ctor*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: TypeDelegator
  nameWithType: TypeDelegator.TypeDelegator
- uid: System.Reflection.TypeDelegator.Assembly*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: Assembly
  nameWithType: TypeDelegator.Assembly
- uid: System.Reflection.TypeDelegator.AssemblyQualifiedName*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: AssemblyQualifiedName
  nameWithType: TypeDelegator.AssemblyQualifiedName
- uid: System.Reflection.TypeDelegator.BaseType*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: BaseType
  nameWithType: TypeDelegator.BaseType
- uid: System.Reflection.TypeDelegator.FullName*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: FullName
  nameWithType: TypeDelegator.FullName
- uid: System.Reflection.TypeDelegator.GetAttributeFlagsImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetAttributeFlagsImpl
  nameWithType: TypeDelegator.GetAttributeFlagsImpl
- uid: System.Reflection.TypeDelegator.GetConstructorImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetConstructorImpl
  nameWithType: TypeDelegator.GetConstructorImpl
- uid: System.Reflection.TypeDelegator.GetConstructors*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetConstructors
  nameWithType: TypeDelegator.GetConstructors
- uid: System.Reflection.TypeDelegator.GetCustomAttributes*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetCustomAttributes
  nameWithType: TypeDelegator.GetCustomAttributes
- uid: System.Reflection.TypeDelegator.GetElementType*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetElementType
  nameWithType: TypeDelegator.GetElementType
- uid: System.Reflection.TypeDelegator.GetEvent*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetEvent
  nameWithType: TypeDelegator.GetEvent
- uid: System.Reflection.TypeDelegator.GetEvents*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetEvents
  nameWithType: TypeDelegator.GetEvents
- uid: System.Reflection.TypeDelegator.GetField*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetField
  nameWithType: TypeDelegator.GetField
- uid: System.Reflection.TypeDelegator.GetFields*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetFields
  nameWithType: TypeDelegator.GetFields
- uid: System.Reflection.TypeDelegator.GetInterface*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetInterface
  nameWithType: TypeDelegator.GetInterface
- uid: System.Reflection.TypeDelegator.GetInterfaceMap*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetInterfaceMap
  nameWithType: TypeDelegator.GetInterfaceMap
- uid: System.Reflection.TypeDelegator.GetInterfaces*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetInterfaces
  nameWithType: TypeDelegator.GetInterfaces
- uid: System.Reflection.TypeDelegator.GetMember*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetMember
  nameWithType: TypeDelegator.GetMember
- uid: System.Reflection.TypeDelegator.GetMembers*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetMembers
  nameWithType: TypeDelegator.GetMembers
- uid: System.Reflection.TypeDelegator.GetMethodImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetMethodImpl
  nameWithType: TypeDelegator.GetMethodImpl
- uid: System.Reflection.TypeDelegator.GetMethods*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetMethods
  nameWithType: TypeDelegator.GetMethods
- uid: System.Reflection.TypeDelegator.GetNestedType*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetNestedType
  nameWithType: TypeDelegator.GetNestedType
- uid: System.Reflection.TypeDelegator.GetNestedTypes*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetNestedTypes
  nameWithType: TypeDelegator.GetNestedTypes
- uid: System.Reflection.TypeDelegator.GetProperties*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetProperties
  nameWithType: TypeDelegator.GetProperties
- uid: System.Reflection.TypeDelegator.GetPropertyImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetPropertyImpl
  nameWithType: TypeDelegator.GetPropertyImpl
- uid: System.Reflection.TypeDelegator.GUID*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GUID
  nameWithType: TypeDelegator.GUID
- uid: System.Reflection.TypeDelegator.HasElementTypeImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: HasElementTypeImpl
  nameWithType: TypeDelegator.HasElementTypeImpl
- uid: System.Reflection.TypeDelegator.InvokeMember*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: InvokeMember
  nameWithType: TypeDelegator.InvokeMember
- uid: System.Reflection.TypeDelegator.IsArrayImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsArrayImpl
  nameWithType: TypeDelegator.IsArrayImpl
- uid: System.Reflection.TypeDelegator.IsAssignableFrom*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsAssignableFrom
  nameWithType: TypeDelegator.IsAssignableFrom
- uid: System.Reflection.TypeDelegator.IsByRefImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsByRefImpl
  nameWithType: TypeDelegator.IsByRefImpl
- uid: System.Reflection.TypeDelegator.IsCOMObjectImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsCOMObjectImpl
  nameWithType: TypeDelegator.IsCOMObjectImpl
- uid: System.Reflection.TypeDelegator.IsConstructedGenericType*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsConstructedGenericType
  nameWithType: TypeDelegator.IsConstructedGenericType
- uid: System.Reflection.TypeDelegator.IsDefined*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsDefined
  nameWithType: TypeDelegator.IsDefined
- uid: System.Reflection.TypeDelegator.IsPointerImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsPointerImpl
  nameWithType: TypeDelegator.IsPointerImpl
- uid: System.Reflection.TypeDelegator.IsPrimitiveImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsPrimitiveImpl
  nameWithType: TypeDelegator.IsPrimitiveImpl
- uid: System.Reflection.TypeDelegator.IsValueTypeImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsValueTypeImpl
  nameWithType: TypeDelegator.IsValueTypeImpl
- uid: System.Reflection.TypeDelegator.MetadataToken*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: MetadataToken
  nameWithType: TypeDelegator.MetadataToken
- uid: System.Reflection.TypeDelegator.Module*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: Module
  nameWithType: TypeDelegator.Module
- uid: System.Reflection.TypeDelegator.Name*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: Name
  nameWithType: TypeDelegator.Name
- uid: System.Reflection.TypeDelegator.Namespace*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: Namespace
  nameWithType: TypeDelegator.Namespace
- uid: System.Reflection.TypeDelegator.TypeHandle*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: TypeHandle
  nameWithType: TypeDelegator.TypeHandle
- uid: System.Reflection.TypeDelegator.UnderlyingSystemType*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: UnderlyingSystemType
  nameWithType: TypeDelegator.UnderlyingSystemType
