### YamlMime:ManagedReference
items:
- uid: System.AppDomainSetup
  id: AppDomainSetup
  children:
  - System.AppDomainSetup.#ctor
  - System.AppDomainSetup.#ctor(System.ActivationContext)
  - System.AppDomainSetup.#ctor(System.Runtime.Hosting.ActivationArguments)
  - System.AppDomainSetup.ActivationArguments
  - System.AppDomainSetup.AppDomainInitializer
  - System.AppDomainSetup.AppDomainInitializerArguments
  - System.AppDomainSetup.AppDomainManagerAssembly
  - System.AppDomainSetup.AppDomainManagerType
  - System.AppDomainSetup.ApplicationBase
  - System.AppDomainSetup.ApplicationName
  - System.AppDomainSetup.ApplicationTrust
  - System.AppDomainSetup.CachePath
  - System.AppDomainSetup.ConfigurationFile
  - System.AppDomainSetup.DisallowApplicationBaseProbing
  - System.AppDomainSetup.DisallowBindingRedirects
  - System.AppDomainSetup.DisallowCodeDownload
  - System.AppDomainSetup.DisallowPublisherPolicy
  - System.AppDomainSetup.DynamicBase
  - System.AppDomainSetup.GetConfigurationBytes
  - System.AppDomainSetup.LicenseFile
  - System.AppDomainSetup.LoaderOptimization
  - System.AppDomainSetup.PartialTrustVisibleAssemblies
  - System.AppDomainSetup.PrivateBinPath
  - System.AppDomainSetup.PrivateBinPathProbe
  - System.AppDomainSetup.SandboxInterop
  - System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})
  - System.AppDomainSetup.SetConfigurationBytes(System.Byte[])
  - System.AppDomainSetup.SetNativeFunction(System.String,System.Int32,System.IntPtr)
  - System.AppDomainSetup.ShadowCopyDirectories
  - System.AppDomainSetup.ShadowCopyFiles
  - System.AppDomainSetup.TargetFrameworkName
  langs:
  - csharp
  name: AppDomainSetup
  nameWithType: AppDomainSetup
  fullName: System.AppDomainSetup
  type: Class
  summary: "表示可以添加到的实例的程序集绑定信息<xref href=&quot;System.AppDomain&quot;> </xref>。"
  remarks: "更改 AppDomainSetup 实例的属性不影响任何现有<xref:System.AppDomain>.</xref:System.AppDomain> 它可能会影响仅创建一个新<xref:System.AppDomain>，当<xref:System.AppDomain.CreateDomain%2A>与 AppDomainSetup 实例作为参数调用方法。</xref:System.AppDomain.CreateDomain%2A> </xref:System.AppDomain>       此类实现<xref:System.IAppDomainSetup>接口。</xref:System.IAppDomainSetup>      1> [!CAUTION]&1;> 的默认值为<xref:System.AppDomainSetup.DisallowCodeDownload%2A>属性为 false。</xref:System.AppDomainSetup.DisallowCodeDownload%2A> 此设置是不安全的服务。 为了帮助防止服务下载部分受信任的代码，请将此属性设置为 true"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]

      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class AppDomainSetup : IAppDomainSetup
  inheritance:
  - System.Object
  implements:
  - System.IAppDomainSetup
  inheritedMembers: []
  platform:
  - net462
- uid: System.AppDomainSetup.#ctor
  id: '#ctor'
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: AppDomainSetup()
  nameWithType: AppDomainSetup.AppDomainSetup()
  fullName: System.AppDomainSetup.AppDomainSetup()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System
  summary: "初始化的新实例<xref href=&quot;System.AppDomainSetup&quot;></xref>类。"
  syntax:
    content: public AppDomainSetup ();
    parameters: []
  overload: System.AppDomainSetup.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.#ctor(System.ActivationContext)
  id: '#ctor(System.ActivationContext)'
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: AppDomainSetup(ActivationContext)
  nameWithType: AppDomainSetup.AppDomainSetup(ActivationContext)
  fullName: System.AppDomainSetup.AppDomainSetup(ActivationContext)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System
  summary: "初始化的新实例<xref href=&quot;System.AppDomainSetup&quot;></xref>与指定的激活上下文，用于基于清单的应用程序域的激活的类。"
  remarks: "<xref:System.ActivationContext>对象指定的用于`activationContext`用于生成<xref:System.Runtime.Hosting.ActivationArguments>对象，其中包含激活新的应用程序域所需信息。</xref:System.Runtime.Hosting.ActivationArguments> </xref:System.ActivationContext> 这<xref:System.Runtime.Hosting.ActivationArguments>对象可以通过使用访问<xref:System.AppDomainSetup.ActivationArguments%2A>属性。</xref:System.AppDomainSetup.ActivationArguments%2A> </xref:System.Runtime.Hosting.ActivationArguments>"
  syntax:
    content: public AppDomainSetup (ActivationContext activationContext);
    parameters:
    - id: activationContext
      type: System.ActivationContext
      description: "要用于应用程序域的激活上下文。"
  overload: System.AppDomainSetup.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>activationContext</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomainSetup.#ctor(System.Runtime.Hosting.ActivationArguments)
  id: '#ctor(System.Runtime.Hosting.ActivationArguments)'
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: AppDomainSetup(ActivationArguments)
  nameWithType: AppDomainSetup.AppDomainSetup(ActivationArguments)
  fullName: System.AppDomainSetup.AppDomainSetup(ActivationArguments)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System
  summary: "初始化的新实例<xref href=&quot;System.AppDomainSetup&quot;></xref>类以基于清单的应用程序域激活所需的指定的激活参数。"
  remarks: "为指定的对象`activationArguments`可以通过使用访问<xref:System.AppDomainSetup.ActivationArguments%2A>属性。</xref:System.AppDomainSetup.ActivationArguments%2A>"
  syntax:
    content: public AppDomainSetup (System.Runtime.Hosting.ActivationArguments activationArguments);
    parameters:
    - id: activationArguments
      type: System.Runtime.Hosting.ActivationArguments
      description: "一个指定以基于清单的新的应用程序域激活所需信息的对象。"
  overload: System.AppDomainSetup.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>activationArguments</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomainSetup.ActivationArguments
  id: ActivationArguments
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: ActivationArguments
  nameWithType: AppDomainSetup.ActivationArguments
  fullName: System.AppDomainSetup.ActivationArguments
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取或设置应用程序域的激活有关的数据。"
  remarks: "在此属性设置为引发任何异常`null`。       提供的信息<xref:System.Runtime.Hosting.ActivationArguments>对象支持基于清单的激活。</xref:System.Runtime.Hosting.ActivationArguments>"
  syntax:
    content: public System.Runtime.Hosting.ActivationArguments ActivationArguments { get; set; }
    return:
      type: System.Runtime.Hosting.ActivationArguments
      description: "包含应用程序域的激活有关的数据的对象。"
  overload: System.AppDomainSetup.ActivationArguments*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "属性设置为<xref href=&quot;System.Runtime.Hosting.ActivationArguments&quot;></xref>其应用程序标识不匹配的应用程序标识的对象<xref href=&quot;System.Security.Policy.ApplicationTrust&quot;></xref>返回对象<> *1> 属性。在引发任何异常<> *1> 属性是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.AppDomainSetup.AppDomainInitializer
  id: AppDomainInitializer
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: AppDomainInitializer
  nameWithType: AppDomainSetup.AppDomainInitializer
  fullName: System.AppDomainSetup.AppDomainInitializer
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取或设置<xref href=&quot;System.AppDomainInitializer&quot;></xref>委托，表示初始化应用程序域时调用的回调方法。"
  remarks: "若要将信息传递给回调方法，分配的字符串转换为数组<xref:System.AppDomainSetup.AppDomainInitializerArguments%2A>属性。</xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> 该数组传递给回调方法每次<xref:System.AppDomain>初始化。</xref:System.AppDomain>       新创建的应用程序域的上下文中执行此回调方法。"
  example:
  - "The following example creates a child application domain named `ChildDomain`, using an <xref:System.AppDomainSetup> object and evidence from the default application domain. The AppDomainInitializer property is set to the callback method `AppDomainInit`, which is invoked when the child domain is initialized. The arguments for the callback method are placed in an array of strings, which is assigned to the <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> property. When the child domain is created, the callback method simply prints the strings.  \n  \n [!code-cpp[AppDomainInitializer#1](~/add/codesnippet/cpp/p-system.appdomainsetup._4_1.cpp)]\n [!code-cs[AppDomainInitializer#1](~/add/codesnippet/csharp/p-system.appdomainsetup._4_1.cs)]\n [!code-vb[AppDomainInitializer#1](~/add/codesnippet/visualbasic/p-system.appdomainsetup._4_1.vb)]"
  syntax:
    content: public AppDomainInitializer AppDomainInitializer { get; set; }
    return:
      type: System.AppDomainInitializer
      description: "一个委托，表示初始化应用程序域时调用的回调方法。"
  overload: System.AppDomainSetup.AppDomainInitializer*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.AppDomainInitializerArguments
  id: AppDomainInitializerArguments
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: AppDomainInitializerArguments
  nameWithType: AppDomainSetup.AppDomainInitializerArguments
  fullName: System.AppDomainSetup.AppDomainInitializerArguments
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取或设置传递给所表示的回调方法的参数<xref href=&quot;System.AppDomainInitializer&quot;></xref>委托。 在初始化应用程序域时调用的回调方法。"
  remarks: "使用<xref:System.AppDomainSetup.AppDomainInitializer%2A>属性指定一个期间调用的回调方法<xref:System.AppDomain>初始化。</xref:System.AppDomain> </xref:System.AppDomainSetup.AppDomainInitializer%2A> 如果<xref:System.AppDomainSetup.AppDomainInitializer%2A>未设置属性，则不使用分配给此属性的数组。</xref:System.AppDomainSetup.AppDomainInitializer%2A>       新创建的应用程序域的上下文中执行此回调方法。"
  example:
  - "The following code example creates a child application domain named `ChildDomain`, using an <xref:System.AppDomainSetup> object and evidence from the default application domain. The <xref:System.AppDomainSetup.AppDomainInitializer%2A> property is set to the callback method `AppDomainInit`, which is invoked when the child domain is initialized. The arguments for the callback method are placed in an array of strings, which is assigned to the AppDomainInitializerArguments property. When the child domain is created, the callback method simply prints the strings.  \n  \n [!code-cpp[AppDomainInitializer#1](~/add/codesnippet/cpp/p-system.appdomainsetup._0_1.cpp)]\n [!code-cs[AppDomainInitializer#1](~/add/codesnippet/csharp/p-system.appdomainsetup._0_1.cs)]\n [!code-vb[AppDomainInitializer#1](~/add/codesnippet/visualbasic/p-system.appdomainsetup._0_1.vb)]"
  syntax:
    content: public string[] AppDomainInitializerArguments { get; set; }
    return:
      type: System.String[]
      description: "传递给所表示的回调方法的字符串数组<xref href=&quot;System.AppDomainInitializer&quot;></xref>期间调用的回调方法委托时<xref href=&quot;System.AppDomain&quot;></xref>初始化。"
  overload: System.AppDomainSetup.AppDomainInitializerArguments*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.AppDomainManagerAssembly
  id: AppDomainManagerAssembly
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: AppDomainManagerAssembly
  nameWithType: AppDomainSetup.AppDomainManagerAssembly
  fullName: System.AppDomainSetup.AppDomainManagerAssembly
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取或设置创建使用此应用程序域提供应用程序域管理器的类型的程序集的显示名称<xref href=&quot;System.AppDomainSetup&quot;></xref>对象。"
  remarks: "To specify the type of the application domain manager, set both this property and the <xref:System.AppDomainSetup.AppDomainManagerType%2A> property. If either of these properties is not set, the other is ignored.  \n  \n If no type is provided, the application domain manager is created from the same type as the parent application domain (that is, the application domain from which the <xref:System.AppDomain.CreateDomain%2A?displayProperty=fullName> method is called).  \n  \n When the application domain is loaded, <xref:System.TypeLoadException> is thrown if the assembly does not exist, or if the assembly does not contain the type specified by the <xref:System.AppDomainSetup.AppDomainManagerType%2A> property. <xref:System.IO.FileLoadException> is thrown if the assembly is found but the version information does not match.  \n  \n To set the application domain manager for the default application domain, use the [\\<appDomainManagerAssembly>](../Topic/%3CappDomainManagerAssembly%3E%20Element.md) and [\\<appDomainManagerType>](../Topic/%3CappDomainManagerType%3E%20Element.md) elements in the [\\<runtime>](../Topic/%3Cruntime%3E%20Element.md) section of the application configuration file, or use the environment variables described in <xref:System.AppDomainManager>.  \n  \n This feature requires the application to have full trust. (For example, an application running on the desktop has full trust.) If the application does not have full trust, a <xref:System.TypeLoadException> is thrown.  \n  \n The format of the assembly display name is given by the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName> property."
  syntax:
    content: public string AppDomainManagerAssembly { get; set; }
    return:
      type: System.String
      description: "提供的程序集的显示名称<xref:System.Type>的应用程序域管理器。</xref:System.Type>"
  overload: System.AppDomainSetup.AppDomainManagerAssembly*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.AppDomainManagerType
  id: AppDomainManagerType
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: AppDomainManagerType
  nameWithType: AppDomainSetup.AppDomainManagerType
  fullName: System.AppDomainSetup.AppDomainManagerType
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取或设置用于创建使用此应用程序域提供应用程序域管理器的类型的全名<xref href=&quot;System.AppDomainSetup&quot;></xref>对象。"
  remarks: "To specify the type of the application domain manager, set both this property and the <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> property. If either of these properties is not set, the other is ignored.  \n  \n If no type is provided, the application domain manager is created from the same type as the parent application domain (that is, the application domain from which the <xref:System.AppDomain.CreateDomain%2A?displayProperty=fullName> method is called).  \n  \n When the application domain is loaded, <xref:System.TypeLoadException> is thrown if the assembly specified by the <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> property does not contain the type specified by this property.  \n  \n To set the application domain manager for the default application domain, use the [\\<appDomainManagerAssembly>](../Topic/%3CappDomainManagerAssembly%3E%20Element.md) and [\\<appDomainManagerType>](../Topic/%3CappDomainManagerType%3E%20Element.md) elements in the [\\<runtime>](../Topic/%3Cruntime%3E%20Element.md) section of the application configuration file, or use the environment variables described in <xref:System.AppDomainManager>.  \n  \n This feature requires the application to have full trust. (For example, an application running on the desktop has full trust.) If the application does not have full trust, a <xref:System.TypeLoadException> is thrown.  \n  \n The format of the full name of a type is given by the <xref:System.Type.FullName%2A?displayProperty=fullName> property."
  syntax:
    content: public string AppDomainManagerType { get; set; }
    return:
      type: System.String
      description: "类型，包括命名空间的完整名称。"
  overload: System.AppDomainSetup.AppDomainManagerType*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.ApplicationBase
  id: ApplicationBase
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: ApplicationBase
  nameWithType: AppDomainSetup.ApplicationBase
  fullName: System.AppDomainSetup.ApplicationBase
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取或设置包含应用程序的目录的名称。"
  remarks: "应用程序基目录是程序集管理器开始探测程序集。       ApplicationBase 属性可能会影响到应用程序域授予的权限。 例如，应用程序域通常来自本地计算机接收基于源其位置的完全信任。 但是，如果的 ApplicationBase 属性<xref:System.AppDomain>设置为一个 intranet 目录，则设置将限制授予应用程序域到 LocalIntranet 授予，即使应用程序域实际来自本地计算机的权限在其中 ApplicationBase 的完整名称。</xref:System.AppDomain>"
  example:
  - "The following example demonstrates how to use the ApplicationBase property to set the location where the assembly loader begins probing for assemblies to load into a new application domain.  \n  \n> [!NOTE]\n>  You must ensure that the folder you specify exists.  \n  \n [!code-vb[ADApplicationBase#1](~/add/codesnippet/visualbasic/p-system.appdomainsetup._5_1.vb)]\n [!code-cpp[ADApplicationBase#1](~/add/codesnippet/cpp/p-system.appdomainsetup._5_1.cpp)]\n [!code-cs[ADApplicationBase#1](~/add/codesnippet/csharp/p-system.appdomainsetup._5_1.cs)]"
  syntax:
    content: public string ApplicationBase { get; set; }
    return:
      type: System.String
      description: "应用程序基目录的名称。"
  overload: System.AppDomainSetup.ApplicationBase*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.ApplicationName
  id: ApplicationName
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: ApplicationName
  nameWithType: AppDomainSetup.ApplicationName
  fullName: System.AppDomainSetup.ApplicationName
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取或设置应用程序的名称。"
  remarks: ''
  example:
  - "The following example shows how to set the ApplicationName property when you create a new application domain.  \n  \n The example creates a new application domain, and then calls the <xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=fullName> method to load the example assembly into the new application domain and create an instance of the `Worker` class. The `Worker` class inherits <xref:System.MarshalByRefObject>, so the example can use the proxy returned by <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> to call the `TestLoad` method.  \n  \n The `TestLoad` method loads an assembly that you specify. You must either specify a valid, fully qualified assembly name, or comment out the <xref:System.Reflection.Assembly.Load%28System.String%29> method. The `TestLoad` method lists the assemblies that are loaded into the new application domain, showing that your specified assembly and the example assembly are loaded.  \n  \n The example uses the <xref:System.LoaderOptimizationAttribute> attribute to tell the assembly loader how the application will share code across application domains.  \n  \n [!code-cpp[ADMultiDomain#1](~/add/codesnippet/cpp/p-system.appdomainsetup._2_1.cpp)]\n [!code-cs[ADMultiDomain#1](~/add/codesnippet/csharp/p-system.appdomainsetup._2_1.cs)]\n [!code-vb[ADMultiDomain#1](~/add/codesnippet/visualbasic/p-system.appdomainsetup._2_1.vb)]"
  syntax:
    content: public string ApplicationName { get; set; }
    return:
      type: System.String
      description: "应用程序的名称。"
  overload: System.AppDomainSetup.ApplicationName*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.ApplicationTrust
  id: ApplicationTrust
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: ApplicationTrust
  nameWithType: AppDomainSetup.ApplicationTrust
  fullName: System.AppDomainSetup.ApplicationTrust
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取或设置一个包含安全性和信任信息的对象。"
  remarks: "此属性是`null`时<xref:System.AppDomainSetup>创建。</xref:System.AppDomainSetup> 更改后，则无法重置为空引用。"
  syntax:
    content: public System.Security.Policy.ApplicationTrust ApplicationTrust { get; set; }
    return:
      type: System.Security.Policy.ApplicationTrust
      description: "一个包含安全性和信任信息的对象。"
  overload: System.AppDomainSetup.ApplicationTrust*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "属性设置为<xref href=&quot;System.Security.Policy.ApplicationTrust&quot;></xref>其应用程序标识不匹配的应用程序标识的对象<xref href=&quot;System.Runtime.Hosting.ActivationArguments&quot;></xref>返回对象<> *1> 属性。在引发任何异常<> *1> 属性是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "属性设置为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.AppDomainSetup.CachePath
  id: CachePath
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: CachePath
  nameWithType: AppDomainSetup.CachePath
  fullName: System.AppDomainSetup.CachePath
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取或设置特定于应用程序的、 从中对文件进行卷影复制使用的区域名称。"
  remarks: "为了使此属性产生任何影响，<xref:System.AppDomainSetup.ApplicationName%2A>还必须设置属性。</xref:System.AppDomainSetup.ApplicationName%2A> 如果<xref:System.AppDomainSetup.ApplicationName%2A>未设置属性，将忽略的 CachePath 属性和卷影副本缓存位置默认为下载缓存。</xref:System.AppDomainSetup.ApplicationName%2A>       卷影复制的详细信息，请参阅[影像复制程序集](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public string CachePath { get; set; }
    return:
      type: System.String
      description: "从中对文件进行卷影复制的目录路径和文件名称的完全限定的名称。"
  overload: System.AppDomainSetup.CachePath*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.ConfigurationFile
  id: ConfigurationFile
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: ConfigurationFile
  nameWithType: AppDomainSetup.ConfigurationFile
  fullName: System.AppDomainSetup.ConfigurationFile
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取或设置应用程序域的配置文件的名称。"
  remarks: "配置文件描述的搜索规则和应用程序域的配置数据。 创建应用程序域的主机负责提供此数据，因为有意义的值会变化情况。       例如，ASP.NET 应用程序的配置数据存储为每个应用程序、 站点以及计算机，可执行文件的配置数据存储为每个应用程序、 用户和计算机时。 仅主机知道特定情况的配置数据的详细信息。"
  syntax:
    content: public string ConfigurationFile { get; set; }
    return:
      type: System.String
      description: "配置文件的名称。"
  overload: System.AppDomainSetup.ConfigurationFile*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.DisallowApplicationBaseProbing
  id: DisallowApplicationBaseProbing
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: DisallowApplicationBaseProbing
  nameWithType: AppDomainSetup.DisallowApplicationBaseProbing
  fullName: System.AppDomainSetup.DisallowApplicationBaseProbing
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "指定在搜索要加载的程序集时是否探测应用程序基路径和专用二进制路径。"
  remarks: "如果 DisallowApplicationBaseProbing 属性为`true`的值<xref:System.AppDomainSetup.ApplicationBase%2A>属性将被忽略。</xref:System.AppDomainSetup.ApplicationBase%2A> 通过指定的目录中的探测没有任何程序集，即<xref:System.AppDomainSetup.ApplicationBase%2A>属性。</xref:System.AppDomainSetup.ApplicationBase%2A> 此外的值<xref:System.AppDomainSetup.PrivateBinPath%2A>属性和<xref:System.AppDomainSetup.PrivateBinPathProbe%2A>属性将被忽略。</xref:System.AppDomainSetup.PrivateBinPathProbe%2A> </xref:System.AppDomainSetup.PrivateBinPath%2A> 任何程序集指定的目录中探测<xref:System.AppDomainSetup.PrivateBinPath%2A>属性。</xref:System.AppDomainSetup.PrivateBinPath%2A>       DisallowApplicationBaseProbing 属性提供一层额外的控制加载过程。 在正常的程序集加载序列，应用程序基探测之前<xref:System.AppDomain.AssemblyResolve?displayProperty=fullName>引发事件。</xref:System.AppDomain.AssemblyResolve?displayProperty=fullName> 但是，某些应用程序可能需要从在文档中，OLE 复合文件中或从既不在全局程序集缓存中上也不由指定的目录中的唯一已知位置加载程序集<xref:System.AppDomainSetup.ApplicationBase%2A>和<xref:System.AppDomainSetup.PrivateBinPath%2A>属性。</xref:System.AppDomainSetup.PrivateBinPath%2A> </xref:System.AppDomainSetup.ApplicationBase%2A> 此类应用程序可以使用 DisallowApplicationBaseProbing 属性，以避免导致正常探测的延迟和避免加载可能位于正常的探测路径的必需程序集的副本。"
  syntax:
    content: public bool DisallowApplicationBaseProbing { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果不允许探测;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.AppDomainSetup.DisallowApplicationBaseProbing*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.DisallowBindingRedirects
  id: DisallowBindingRedirects
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: DisallowBindingRedirects
  nameWithType: AppDomainSetup.DisallowBindingRedirects
  fullName: System.AppDomainSetup.DisallowBindingRedirects
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取或设置一个值，该值指示应用程序域是否允许程序集绑定重定向。"
  remarks: "DisallowBindingRedirects 属性设计为供服务和服务器应用程序程序集绑定重定向不是应用程序方案的一部分。"
  syntax:
    content: public bool DisallowBindingRedirects { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果不允许重定向的程序集;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>如果允许它。"
  overload: System.AppDomainSetup.DisallowBindingRedirects*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.DisallowCodeDownload
  id: DisallowCodeDownload
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: DisallowCodeDownload
  nameWithType: AppDomainSetup.DisallowCodeDownload
  fullName: System.AppDomainSetup.DisallowCodeDownload
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取或设置一个值，该值指示应用程序域是否允许 HTTP 下载程序集。"
  remarks: "DisallowCodeDownload 属性设计为供服务和服务器应用程序从 intranet 或 Internet 下载代码不是应用程序方案的一部分。      1> [!CAUTION]&1;> DisallowCodeDownload 属性的默认值是`false`。 此设置是不安全的服务。 为了帮助防止服务下载部分受信任的代码，请将此属性设置为`true`。"
  syntax:
    content: public bool DisallowCodeDownload { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果 HTTP 下载程序集则不允许;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>如果允许它。"
  overload: System.AppDomainSetup.DisallowCodeDownload*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.DisallowPublisherPolicy
  id: DisallowPublisherPolicy
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: DisallowPublisherPolicy
  nameWithType: AppDomainSetup.DisallowPublisherPolicy
  fullName: System.AppDomainSetup.DisallowPublisherPolicy
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取或设置一个值，该值指示是否[ &lt;publisherPolicy&gt; ](../Topic/%3CpublisherPolicy%3E%20Element.md)配置文件的部分应用于应用程序域。"
  remarks: "DisallowPublisherPolicy 属性特别适用于本地加载 Web 应用程序。 使用此属性以帮助防止恶意尝试在安全模式下执行不安全的 Web 应用程序。       有关跳过发布服务器策略的详细信息，请参阅[重定向程序集版本](~/add/includes/ajax-current-ext-md.md)主题。 有关安全模式的详细信息，请参阅的&quot;检查配置文件&quot;部分[运行时如何定位程序集](~/add/includes/ajax-current-ext-md.md)主题。"
  syntax:
    content: public bool DisallowPublisherPolicy { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref uid=&quot;langword_csharp_&lt;publisherPolicy&gt;&quot; name=&quot;&lt;publisherPolicy&gt;&quot; href=&quot;&quot;></xref>应用程序域配置文件的部分将被忽略;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>如果接受所声明的发行者策略。"
  overload: System.AppDomainSetup.DisallowPublisherPolicy*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.DynamicBase
  id: DynamicBase
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: DynamicBase
  nameWithType: AppDomainSetup.DynamicBase
  fullName: System.AppDomainSetup.DynamicBase
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取或设置动态生成的文件的目录所在的位置的基目录。"
  remarks: "Use this property to set the base directory where the dynamic directory for the new application domain will be located. When code in the new application domain loads an assembly, assembly resolution looks first in the normal probing paths. If it does not find the assembly, it looks in the dynamic directory, which is returned by the <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=fullName> property. Dynamic assemblies that will be loaded and executed by the new application domain can be placed there.  \n  \n When you assign a path to the DynamicBase property, an additional subdirectory is added; the name of this subdirectory is the hash code of the value assigned to the <xref:System.AppDomainSetup.ApplicationName%2A> property. Thus, the base directory subsequently returned by this property is always different from the value assigned.  \n  \n> [!IMPORTANT]\n>  Assigning a value to this property does not create any directories. The directories must be created or verified by the code that uses them.  \n  \n The dynamic directory is a subdirectory of DynamicBase. Its simple name is the value returned by the <xref:System.AppDomainSetup.ApplicationName%2A> property, so its format is *original path*\\\\*hash code*\\\\*application name*."
  example:
  - "The following example demonstrates how to use the DynamicBase property to set the path an application domain probes when loading dynamic assemblies.  \n  \n The example creates an <xref:System.AppDomainSetup> object and sets its <xref:System.AppDomainSetup.ApplicationName%2A> property to \"Example\" and its DynamicBase property to \"C:\\DynamicAssemblyDir\". The example then displays the DynamicBase property, to show that the hash code of the application name has been appended as a subdirectory of the path that was originally assigned.  \n  \n> [!NOTE]\n>  The base directory in this example is intended to be outside the probing path for the example application. Be sure to compile the example in a different location. Delete the base directory and all its subdirectories each time you run the example.  \n  \n The example creates a new application domain using the <xref:System.AppDomainSetup> object. The example then creates the dynamic directory if it does not already exist. Although the example uses the application domain's <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=fullName> property to get the name of the dynamic directory, it could just as easily create the directory beforehand by concatenating the original path, the hash code of the application name, and the application name.  \n  \n The example has a `GenerateDynamicAssembly` method that emits an assembly named `DynamicHelloWorld.dll` and stores it in the new application domain's dynamic directory. The dynamic assembly contains one type, `HelloWorld`, that has a static method (`Shared` method in Visual Basic) named `HelloFromAD`. Calling this method displays the name of the application domain.  \n  \n The `Example` class derives from <xref:System.MarshalByRefObject>, so the example can create an instance of the class in the new application domain and call its `Test` method. The `Test` method loads the dynamic assembly by its display name and calls the static `HelloFromAD` method.  \n  \n You can show that the dynamic directory is searched after the normal probing paths by writing code for an assembly named `DynamicHelloWorld.dll` and compiling it in the same directory as this example. The assembly must have a class named `HelloWorld` with a static method named `HelloFromAD`. This method does not have to have the same functionality as the one in the example; it can simply display a string to the console. The assembly must also have an <xref:System.Reflection.AssemblyVersionAttribute> attribute that sets its version to 1.0.0.0. When you run the example, the assembly you compiled in the current directory is found before the dynamic directory is searched.  \n  \n [!code-cpp[ADDynamicBase#1](~/add/codesnippet/cpp/p-system.appdomainsetup._1_1.cpp)]\n [!code-cs[ADDynamicBase#1](~/add/codesnippet/csharp/p-system.appdomainsetup._1_1.cs)]\n [!code-vb[ADDynamicBase#1](~/add/codesnippet/visualbasic/p-system.appdomainsetup._1_1.vb)]"
  syntax:
    content: public string DynamicBase { get; set; }
    return:
      type: System.String
      description: "目录其中&lt;xref:System.AppDomain.DynamicDirectory%2A?displayProperty=fullName&gt;所在。       <div class=&quot;alert NOTE&quot;>    此属性的返回值是不同的分配的值。 请参阅备注部分。      </div>"
  overload: System.AppDomainSetup.DynamicBase*
  exceptions:
  - type: System.MemberAccessException
    commentId: T:System.MemberAccessException
    description: "无法设置此属性，因为应用程序域上的应用程序名称是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.AppDomainSetup.GetConfigurationBytes
  id: GetConfigurationBytes
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: GetConfigurationBytes()
  nameWithType: AppDomainSetup.GetConfigurationBytes()
  fullName: System.AppDomainSetup.GetConfigurationBytes()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "返回设置的 XML 配置信息<xref:System.AppDomainSetup.SetConfigurationBytes*>方法，重写应用程序的 XML 配置信息。</xref:System.AppDomainSetup.SetConfigurationBytes*>"
  remarks: "<xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法提供了如何重写创建新的应用程序域的应用程序的配置信息。</xref:System.AppDomainSetup.SetConfigurationBytes%2A> 中的配置文件信息`value`重写应用程序的配置文件信息。 例如，当 Example.exe 应用程序创建新的应用程序域时，它会重写最初从 Example.exe.config 文件中获取的配置信息。      1> [!IMPORTANT]&1;> 某些的配置文件信息的使用者不使用存储的信息<xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法。</xref:System.AppDomainSetup.SetConfigurationBytes%2A> 运行时不会强制此。 若要确保新的应用程序域中被重写所有配置文件信息，请使用<xref:System.AppDomainSetup.ConfigurationFile%2A>属性来指定配置文件。</xref:System.AppDomainSetup.ConfigurationFile%2A> <xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法会影响程序集绑定。</xref:System.AppDomainSetup.SetConfigurationBytes%2A>       中的 XML`value`具有与在常规配置文件中，XML 相同，只不过它存储为<xref:System.Byte>数组。</xref:System.Byte>       若要访问应用程序域的配置字节，使用<xref:System.AppDomain.SetupInformation%2A?displayProperty=fullName>属性来获取<xref:System.AppDomainSetup>对象对于应用程序域中，然后使用 GetConfigurationBytes 方法。</xref:System.AppDomainSetup> </xref:System.AppDomain.SetupInformation%2A?displayProperty=fullName>"
  syntax:
    content: public byte[] GetConfigurationBytes ();
    parameters: []
    return:
      type: System.Byte[]
      description: "一个数组，包含所设置的 XML 配置信息<> *1> 方法，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果<> *1> 尚未调用方法。"
  overload: System.AppDomainSetup.GetConfigurationBytes*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.LicenseFile
  id: LicenseFile
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: LicenseFile
  nameWithType: AppDomainSetup.LicenseFile
  fullName: System.AppDomainSetup.LicenseFile
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取或设置与此域关联的许可证文件的位置。"
  syntax:
    content: public string LicenseFile { get; set; }
    return:
      type: System.String
      description: "位置和许可证文件的名称。"
  overload: System.AppDomainSetup.LicenseFile*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.LoaderOptimization
  id: LoaderOptimization
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: LoaderOptimization
  nameWithType: AppDomainSetup.LoaderOptimization
  fullName: System.AppDomainSetup.LoaderOptimization
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "指定用于加载可执行文件的优化策略。"
  remarks: ''
  example:
  - "The following example creates a dynamic assembly and saves it to disk, and then uses the LoaderOptimization property to set the optimization policy used to load the assembly into an application domain.  \n  \n [!code-cpp[ADDyno#1](~/add/codesnippet/cpp/p-system.appdomainsetup._3_1.cpp)]\n [!code-cs[ADDyno#1](~/add/codesnippet/csharp/p-system.appdomainsetup._3_1.cs)]\n [!code-vb[ADDyno#1](~/add/codesnippet/visualbasic/p-system.appdomainsetup._3_1.vb)]"
  syntax:
    content: public LoaderOptimization LoaderOptimization { get; set; }
    return:
      type: System.LoaderOptimization
      description: "与一起使用的枚举的常数<xref href=&quot;System.LoaderOptimizationAttribute&quot;> </xref>。"
  overload: System.AppDomainSetup.LoaderOptimization*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.PartialTrustVisibleAssemblies
  id: PartialTrustVisibleAssemblies
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: PartialTrustVisibleAssemblies
  nameWithType: AppDomainSetup.PartialTrustVisibleAssemblies
  fullName: System.AppDomainSetup.PartialTrustVisibleAssemblies
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取或设置与标记的程序集的列表<xref href=&quot;System.Security.PartialTrustVisibilityLevel&quot;></xref>的对沙盒应用程序域中运行的部分信任代码可见的标志。"
  remarks: "开头[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]， <xref:System.Security.AllowPartiallyTrustedCallersAttribute>(APTCA) 特性可通过设置其<xref:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel%2A>属性设置为<xref:System.Security.PartialTrustVisibilityLevel>.</xref:System.Security.PartialTrustVisibilityLevel></xref:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel%2A>条件</xref:System.Security.AllowPartiallyTrustedCallersAttribute> APTCA 程序集<xref:System.Security.PartialTrustVisibilityLevel>不能由部分受信任的代码，除非主机应用程序允许它。</xref:System.Security.PartialTrustVisibilityLevel>使用标记       沙盒应用程序域的主机允许的应用程序域使用带有条件 APTCA 特性的程序集，通过创建一个数组，包含的简单名称和公钥的每个程序集，并将数组分配给此属性中的代码。 For example, an element of the array might look like the following: &quot;MyAssembly, PublicKey=0024000004800000940000000602000000240000525341310004000001000100db2ad5e5fedc67ea526ff72ad426ef68e08e241d296c499eedfec6648dcc62b1a12f72be5833a45bbec481b68415b08a5fbc9f9ef247b523dd72bbea65bb532784ddc5c704544bd2f1c2d46fdbe41e4f949e76f9947357b2d5cf8ca9f970701bbd6e8ab64ad31b20ad0be9b56dae4f6b83332b92a2a3b8ea2804c40efbc0b6b9&quot;.      1> [!IMPORTANT]&1;> 如果你使用的一个子类<xref:System.AppDomainManager>，并定义它的程序集依赖于用条件 APTCA 特性标记的程序集，你必须在传递给 PartialTrustVisibleAssemblies 属性列表中包括这些程序集<xref:System.AppDomainSetup>使用来创建应用程序域。</xref:System.AppDomainSetup> </xref:System.AppDomainManager> 否则将禁用用条件 APTCA 特性标记的程序集。      1> [!NOTE]&1;> 调试的应用程序在沙盒应用程序域中，运行时某些<xref:System.Security.SecurityException>消息可能会产生误导。</xref:System.Security.SecurityException> 例如，一条消息可能状态，你完全受信任的程序集之一只具有有限权限，超过沙盒应用程序域的授予集的安全要求已传播到沙盒应用程序域边界问题的真正原因时，操作失败。"
  syntax:
    content: public string[] PartialTrustVisibleAssemblies { get; set; }
    return:
      type: System.String[]
      description: "部分程序集名称，其中每个部分名称组成的简单程序集名称和公钥的数组。"
  overload: System.AppDomainSetup.PartialTrustVisibleAssemblies*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.PrivateBinPath
  id: PrivateBinPath
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: PrivateBinPath
  nameWithType: AppDomainSetup.PrivateBinPath
  fullName: System.AppDomainSetup.PrivateBinPath
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取或设置的私有程序集的探测应用程序基目录下的目录列表。"
  remarks: "专用程序集部署在与应用程序相同的目录结构中。 如果为 PrivateBinPath 指定的目录不在<xref:System.AppDomainSetup.ApplicationBase%2A>，它们将被忽略。</xref:System.AppDomainSetup.ApplicationBase%2A>"
  syntax:
    content: public string PrivateBinPath { get; set; }
    return:
      type: System.String
      description: "用分号分隔的目录名称的列表。"
  overload: System.AppDomainSetup.PrivateBinPath*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.PrivateBinPathProbe
  id: PrivateBinPathProbe
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: PrivateBinPathProbe
  nameWithType: AppDomainSetup.PrivateBinPathProbe
  fullName: System.AppDomainSetup.PrivateBinPathProbe
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取或设置一个字符串值，包括或排除<> *1> 应用程序，并且仅搜索的搜索路径中<> *1>。"
  remarks: "将此属性设置为任何非 null 字符串值，包括<xref:System.String?displayProperty=fullName>(&quot;&quot;)，以排除应用程序目录路径-即， <xref:System.AppDomainSetup.ApplicationBase%2A>-对于应用程序，并仅中<xref:System.AppDomainSetup.PrivateBinPath%2A>.</xref:System.AppDomainSetup.PrivateBinPath%2A>的程序集搜索的搜索路径中</xref:System.AppDomainSetup.ApplicationBase%2A></xref:System.String?displayProperty=fullName>"
  syntax:
    content: public string PrivateBinPathProbe { get; set; }
    return:
      type: System.String
      description: "空引用 (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref>在 Visual Basic 中) 以包括搜索程序集时的应用程序基路径; 任何非 null 字符串值，包括路径。 默认值是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.AppDomainSetup.PrivateBinPathProbe*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.SandboxInterop
  id: SandboxInterop
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: SandboxInterop
  nameWithType: AppDomainSetup.SandboxInterop
  fullName: System.AppDomainSetup.SandboxInterop
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取或设置一个值，指示为互操作调用在应用程序域中，是否禁用接口缓存，以便`QueryInterface`对每个调用执行。"
  remarks: "对性能的互操作调用禁用接口缓存产生重大影响。       此成员在中引入[!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)]。"
  syntax:
    content: public bool SandboxInterop { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果为创建与当前的应用程序域中的互操作调用禁用接口缓存<xref href=&quot;System.AppDomainSetup&quot;></xref>对象; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.AppDomainSetup.SandboxInterop*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})
  id: SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: SetCompatibilitySwitches(IEnumerable<String>)
  nameWithType: AppDomainSetup.SetCompatibilitySwitches(IEnumerable<String>)
  fullName: System.AppDomainSetup.SetCompatibilitySwitches(IEnumerable<String>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "设置指定的开关，从而使应用程序域与针对指定问题的.NET framework 的早期版本兼容。"
  remarks: "Major versions of the .NET Framework sometimes introduce breaking changes from the previous version. For example, the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)] introduces a small number of breaking changes from the [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)]. Use the SetCompatibilitySwitches method to specify that one or more of these breaking changes should be rolled back for the application domain, to make the behavior compatible with the previous version of the .NET Framework.  \n  \n Each time you call this method, it replaces the existing switch settings. To erase the settings, specify `null` for the `switches` parameter.  \n  \n The set of string values you provide for `switches` can be a simple string array, because arrays implement the <xref:System.Collections.IEnumerable> interface.  \n  \n The following table provides examples of compatibility switches that can be set to restore the behavior of earlier versions of the .NET Framework.  \n  \n|Switch|Meaning|  \n|------------|-------------|  \n|\"NetFx40_LegacySecurityPolicy\"|Code access security (CAS) for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] is enabled in this application domain. See [\\&lt;NetFx40_LegacySecurityPolicy\\&gt; Element](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md).|  \n|\"NetFx40_Legacy20SortingBehavior\"|String sorting defaults for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] are enabled in this application domain. Successfully restoring legacy sorting behavior also requires the sort00001000.dll dynamic link library to be available on the local system. See [\\&lt;CompatSortNLSVersion\\&gt; Element](../Topic/%3CCompatSortNLSVersion%3E%20Element.md).|  \n|\"NetFx40_Legacy40SortingBehavior\"|String sorting defaults for the [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)] and Unicode 5.0 are enabled in this application domain. Successfully restoring legacy sorting behavior also requires the sort00060101.dll dynamic link library to be available on the local system.|  \n|\"NetFx40_TimeSpanLegacyFormatMode\"|<xref:System.TimeSpan> formatting behavior for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] is enabled in this application domain. See [\\&lt;TimeSpan_LegacyFormatMode\\&gt; Element](../Topic/%3CTimeSpan_LegacyFormatMode%3E%20Element.md) and the \"Restoring Legacy TimeSpan Formatting\" section of the <xref:System.TimeSpan> topic.|  \n|\"UseRandomizedStringHashAlgorithm\"|The runtime calculates hash codes for strings on a per application domain basis instead of using a single hashing algorithm that produces a consistent hash code across application domains. See [\\&lt;UseRandomizedStringHashAlgorithm\\&gt; Element](../Topic/%3CUseRandomizedStringHashAlgorithm%3E%20Element.md).|"
  syntax:
    content: public void SetCompatibilitySwitches (System.Collections.Generic.IEnumerable<string> switches);
    parameters:
    - id: switches
      type: System.Collections.Generic.IEnumerable{System.String}
      description: "指定兼容性开关的字符串值的可枚举集或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>擦除现有兼容性开关。"
  overload: System.AppDomainSetup.SetCompatibilitySwitches*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.SetConfigurationBytes(System.Byte[])
  id: SetConfigurationBytes(System.Byte[])
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: SetConfigurationBytes(Byte[])
  nameWithType: AppDomainSetup.SetConfigurationBytes(Byte[])
  fullName: System.AppDomainSetup.SetConfigurationBytes(Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "提供应用程序域，并替换应用程序的 XML 配置信息的 XML 配置信息。"
  remarks: "SetConfigurationBytes 方法使您能够将创建新的应用程序域的应用程序的配置信息。 中的配置文件信息`value`替换应用程序的配置文件信息。 例如，当 Example.exe 应用程序创建新的应用程序域时，它可以替换最初从 Example.exe.config 文件中获取的配置信息。      1> [!IMPORTANT]&1;> 某些的配置文件信息的使用者不使用 SetConfigurationBytes 方法所存储的信息。 运行时不会强制此。 若要确保所有的配置文件信息已替换为新的应用程序域中，使用<xref:System.AppDomainSetup.ConfigurationFile%2A>属性来指定配置文件。</xref:System.AppDomainSetup.ConfigurationFile%2A> SetConfigurationBytes 方法会影响程序集绑定。       中的 XML`value`具有与在常规配置文件中，XML 相同，只不过它存储为<xref:System.Byte>数组。</xref:System.Byte>"
  syntax:
    content: public void SetConfigurationBytes (byte[] value);
    parameters:
    - id: value
      type: System.Byte[]
      description: "包含要用于应用程序域的 XML 配置信息的数组。"
  overload: System.AppDomainSetup.SetConfigurationBytes*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.SetNativeFunction(System.String,System.Int32,System.IntPtr)
  id: SetNativeFunction(System.String,System.Int32,System.IntPtr)
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: SetNativeFunction(String,Int32,IntPtr)
  nameWithType: AppDomainSetup.SetNativeFunction(String,Int32,IntPtr)
  fullName: System.AppDomainSetup.SetNativeFunction(String,Int32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "公共语言运行时提供备用字符串比较函数的实现。"
  remarks: "下面的字符串比较和排序方法 SetNativeFunction 方法可重写:- `IsNLSDefinedString`       -    `CompareStringEx`       -    `LCMapStringEx`       -    `FindNLSStringEx`       -    `CompareStringOrdinal`       -    `GetNLSVersion`有关这些函数的信息，请参阅[国家/地区的语言支持功能](http://go.microsoft.com/fwlink/?LinkId=228134)。"
  syntax:
    content: public void SetNativeFunction (string functionName, int functionVersion, IntPtr functionPointer);
    parameters:
    - id: functionName
      type: System.String
      description: "若要重写的字符串比较函数的名称。"
    - id: functionVersion
      type: System.Int32
      description: "函数版本。 有关[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]，其值必须为 1 或更高版本。"
    - id: functionPointer
      type: System.IntPtr
      description: "重写函数指针`functionName`。"
  overload: System.AppDomainSetup.SetNativeFunction*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>functionName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>functionVersion</code>不是 1 或更高版本。       -<code>functionPointer</code>是&lt;xref:System.IntPtr?displayProperty=fullName&gt;。"
  platform:
  - net462
- uid: System.AppDomainSetup.ShadowCopyDirectories
  id: ShadowCopyDirectories
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: ShadowCopyDirectories
  nameWithType: AppDomainSetup.ShadowCopyDirectories
  fullName: System.AppDomainSetup.ShadowCopyDirectories
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取或设置包含要进行影像复制程序集的目录的名称。"
  remarks: "启用卷影复制后，默认值是向通过探测; 找到的所有程序集的卷影副本即指定的目录的<xref:System.AppDomainSetup.PrivateBinPath%2A>和<xref:System.AppDomainSetup.ApplicationBase%2A>属性。</xref:System.AppDomainSetup.ApplicationBase%2A> </xref:System.AppDomainSetup.PrivateBinPath%2A> ShadowCopyDirectories 属性会限制对 ShadowCopyDirectories 所指定的目录中的程序集卷影副本。       如果不将字符串分配给 ShadowCopyDirectories 属性，或将此属性设置为`null`，通过指定的目录中的所有程序集<xref:System.AppDomainSetup.ApplicationBase%2A>和<xref:System.AppDomainSetup.PrivateBinPath%2A>属性进行卷影复制。</xref:System.AppDomainSetup.PrivateBinPath%2A> </xref:System.AppDomainSetup.ApplicationBase%2A>      1> [!IMPORTANT]&1;> 目录路径不能包含分号，因为分号是分隔符字符。 分号没有转义符。       卷影复制生效时，程序集文件复制到其他位置，这些程序集加载之前。 没有锁定原始程序集文件，因此它可以进行更新。 卷影复制的详细信息，请参阅[影像复制程序集](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public string ShadowCopyDirectories { get; set; }
    return:
      type: System.String
      description: "用分号分隔的目录名称的列表。"
  overload: System.AppDomainSetup.ShadowCopyDirectories*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.ShadowCopyFiles
  id: ShadowCopyFiles
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: ShadowCopyFiles
  nameWithType: AppDomainSetup.ShadowCopyFiles
  fullName: System.AppDomainSetup.ShadowCopyFiles
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取或设置指示是否卷影复制打开还是关闭的字符串。"
  remarks: "卷影复制的详细信息，请参阅[影像复制程序集](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public string ShadowCopyFiles { get; set; }
    return:
      type: System.String
      description: "字符串值&quot;true&quot;指示卷影复制处于打开状态;或者&quot;false&quot;指示卷影复制处于关闭状态。"
  overload: System.AppDomainSetup.ShadowCopyFiles*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.TargetFrameworkName
  id: TargetFrameworkName
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: TargetFrameworkName
  nameWithType: AppDomainSetup.TargetFrameworkName
  fullName: System.AppDomainSetup.TargetFrameworkName
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "获取或设置一个字符串，指定的目标版本和配置文件的.NET Framework 的应用程序域中，可以通过分析的格式&lt;xref:System.Runtime.Versioning.FrameworkName.%23ctor%28System.String%29?displayProperty=fullName&gt;构造函数。"
  remarks: "设置此属性来告诉当前正在运行.NET Framework 版本，将使用的应用程序域加载并运行目标版本和配置文件已编译的程序集。 如果当前正在运行.NET Framework 版本有影响的兼容性用目标版本编译的代码的可选行为，它可以启用或禁用这些行为，根据需要，为了提高兼容性。 当应用程序支持在单独的应用程序域中运行它们编译使用.NET framework 的多个版本的外接程序时，这很有用。       对于客户端应用程序，TargetFrameworkName 属性的值推断从<xref:System.Runtime.Versioning.TargetFrameworkAttribute>属性。</xref:System.Runtime.Versioning.TargetFrameworkAttribute> 在[!INCLUDE[vs_dev10_long](~/add/includes/vs-dev10-long-md.md)]和更高版本，此属性添加到程序集将根据项目的设置自动**目标框架**属性。"
  syntax:
    content: public string TargetFrameworkName { get; set; }
    return:
      type: System.String
      description: "目标版本和.NET Framework 配置文件。"
  overload: System.AppDomainSetup.TargetFrameworkName*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.MemberAccessException
  isExternal: true
  name: System.MemberAccessException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.AppDomainSetup.#ctor
  parent: System.AppDomainSetup
  isExternal: false
  name: AppDomainSetup()
  nameWithType: AppDomainSetup.AppDomainSetup()
  fullName: System.AppDomainSetup.AppDomainSetup()
- uid: System.AppDomainSetup.#ctor(System.ActivationContext)
  parent: System.AppDomainSetup
  isExternal: false
  name: AppDomainSetup(ActivationContext)
  nameWithType: AppDomainSetup.AppDomainSetup(ActivationContext)
  fullName: System.AppDomainSetup.AppDomainSetup(ActivationContext)
- uid: System.ActivationContext
  parent: System
  isExternal: false
  name: ActivationContext
  nameWithType: ActivationContext
  fullName: System.ActivationContext
- uid: System.AppDomainSetup.#ctor(System.Runtime.Hosting.ActivationArguments)
  parent: System.AppDomainSetup
  isExternal: false
  name: AppDomainSetup(ActivationArguments)
  nameWithType: AppDomainSetup.AppDomainSetup(ActivationArguments)
  fullName: System.AppDomainSetup.AppDomainSetup(ActivationArguments)
- uid: System.Runtime.Hosting.ActivationArguments
  parent: System.Runtime.Hosting
  isExternal: false
  name: ActivationArguments
  nameWithType: ActivationArguments
  fullName: System.Runtime.Hosting.ActivationArguments
- uid: System.AppDomainSetup.ActivationArguments
  parent: System.AppDomainSetup
  isExternal: false
  name: ActivationArguments
  nameWithType: AppDomainSetup.ActivationArguments
  fullName: System.AppDomainSetup.ActivationArguments
- uid: System.AppDomainSetup.AppDomainInitializer
  parent: System.AppDomainSetup
  isExternal: false
  name: AppDomainInitializer
  nameWithType: AppDomainSetup.AppDomainInitializer
  fullName: System.AppDomainSetup.AppDomainInitializer
- uid: System.AppDomainInitializer
  parent: System
  isExternal: false
  name: AppDomainInitializer
  nameWithType: AppDomainInitializer
  fullName: System.AppDomainInitializer
- uid: System.AppDomainSetup.AppDomainInitializerArguments
  parent: System.AppDomainSetup
  isExternal: false
  name: AppDomainInitializerArguments
  nameWithType: AppDomainSetup.AppDomainInitializerArguments
  fullName: System.AppDomainSetup.AppDomainInitializerArguments
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomainSetup.AppDomainManagerAssembly
  parent: System.AppDomainSetup
  isExternal: false
  name: AppDomainManagerAssembly
  nameWithType: AppDomainSetup.AppDomainManagerAssembly
  fullName: System.AppDomainSetup.AppDomainManagerAssembly
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.AppDomainSetup.AppDomainManagerType
  parent: System.AppDomainSetup
  isExternal: false
  name: AppDomainManagerType
  nameWithType: AppDomainSetup.AppDomainManagerType
  fullName: System.AppDomainSetup.AppDomainManagerType
- uid: System.AppDomainSetup.ApplicationBase
  parent: System.AppDomainSetup
  isExternal: false
  name: ApplicationBase
  nameWithType: AppDomainSetup.ApplicationBase
  fullName: System.AppDomainSetup.ApplicationBase
- uid: System.AppDomainSetup.ApplicationName
  parent: System.AppDomainSetup
  isExternal: false
  name: ApplicationName
  nameWithType: AppDomainSetup.ApplicationName
  fullName: System.AppDomainSetup.ApplicationName
- uid: System.AppDomainSetup.ApplicationTrust
  parent: System.AppDomainSetup
  isExternal: false
  name: ApplicationTrust
  nameWithType: AppDomainSetup.ApplicationTrust
  fullName: System.AppDomainSetup.ApplicationTrust
- uid: System.Security.Policy.ApplicationTrust
  parent: System.Security.Policy
  isExternal: false
  name: ApplicationTrust
  nameWithType: ApplicationTrust
  fullName: System.Security.Policy.ApplicationTrust
- uid: System.AppDomainSetup.CachePath
  parent: System.AppDomainSetup
  isExternal: false
  name: CachePath
  nameWithType: AppDomainSetup.CachePath
  fullName: System.AppDomainSetup.CachePath
- uid: System.AppDomainSetup.ConfigurationFile
  parent: System.AppDomainSetup
  isExternal: false
  name: ConfigurationFile
  nameWithType: AppDomainSetup.ConfigurationFile
  fullName: System.AppDomainSetup.ConfigurationFile
- uid: System.AppDomainSetup.DisallowApplicationBaseProbing
  parent: System.AppDomainSetup
  isExternal: false
  name: DisallowApplicationBaseProbing
  nameWithType: AppDomainSetup.DisallowApplicationBaseProbing
  fullName: System.AppDomainSetup.DisallowApplicationBaseProbing
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.AppDomainSetup.DisallowBindingRedirects
  parent: System.AppDomainSetup
  isExternal: false
  name: DisallowBindingRedirects
  nameWithType: AppDomainSetup.DisallowBindingRedirects
  fullName: System.AppDomainSetup.DisallowBindingRedirects
- uid: System.AppDomainSetup.DisallowCodeDownload
  parent: System.AppDomainSetup
  isExternal: false
  name: DisallowCodeDownload
  nameWithType: AppDomainSetup.DisallowCodeDownload
  fullName: System.AppDomainSetup.DisallowCodeDownload
- uid: System.AppDomainSetup.DisallowPublisherPolicy
  parent: System.AppDomainSetup
  isExternal: false
  name: DisallowPublisherPolicy
  nameWithType: AppDomainSetup.DisallowPublisherPolicy
  fullName: System.AppDomainSetup.DisallowPublisherPolicy
- uid: System.AppDomainSetup.DynamicBase
  parent: System.AppDomainSetup
  isExternal: false
  name: DynamicBase
  nameWithType: AppDomainSetup.DynamicBase
  fullName: System.AppDomainSetup.DynamicBase
- uid: System.AppDomainSetup.GetConfigurationBytes
  parent: System.AppDomainSetup
  isExternal: false
  name: GetConfigurationBytes()
  nameWithType: AppDomainSetup.GetConfigurationBytes()
  fullName: System.AppDomainSetup.GetConfigurationBytes()
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomainSetup.LicenseFile
  parent: System.AppDomainSetup
  isExternal: false
  name: LicenseFile
  nameWithType: AppDomainSetup.LicenseFile
  fullName: System.AppDomainSetup.LicenseFile
- uid: System.AppDomainSetup.LoaderOptimization
  parent: System.AppDomainSetup
  isExternal: false
  name: LoaderOptimization
  nameWithType: AppDomainSetup.LoaderOptimization
  fullName: System.AppDomainSetup.LoaderOptimization
- uid: System.LoaderOptimization
  parent: System
  isExternal: false
  name: LoaderOptimization
  nameWithType: LoaderOptimization
  fullName: System.LoaderOptimization
- uid: System.AppDomainSetup.PartialTrustVisibleAssemblies
  parent: System.AppDomainSetup
  isExternal: false
  name: PartialTrustVisibleAssemblies
  nameWithType: AppDomainSetup.PartialTrustVisibleAssemblies
  fullName: System.AppDomainSetup.PartialTrustVisibleAssemblies
- uid: System.AppDomainSetup.PrivateBinPath
  parent: System.AppDomainSetup
  isExternal: false
  name: PrivateBinPath
  nameWithType: AppDomainSetup.PrivateBinPath
  fullName: System.AppDomainSetup.PrivateBinPath
- uid: System.AppDomainSetup.PrivateBinPathProbe
  parent: System.AppDomainSetup
  isExternal: false
  name: PrivateBinPathProbe
  nameWithType: AppDomainSetup.PrivateBinPathProbe
  fullName: System.AppDomainSetup.PrivateBinPathProbe
- uid: System.AppDomainSetup.SandboxInterop
  parent: System.AppDomainSetup
  isExternal: false
  name: SandboxInterop
  nameWithType: AppDomainSetup.SandboxInterop
  fullName: System.AppDomainSetup.SandboxInterop
- uid: System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})
  parent: System.AppDomainSetup
  isExternal: false
  name: SetCompatibilitySwitches(IEnumerable<String>)
  nameWithType: AppDomainSetup.SetCompatibilitySwitches(IEnumerable<String>)
  fullName: System.AppDomainSetup.SetCompatibilitySwitches(IEnumerable<String>)
- uid: System.Collections.Generic.IEnumerable{System.String}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<String>
  nameWithType: IEnumerable<String>
  fullName: System.Collections.Generic.IEnumerable<System.String>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.String>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomainSetup.SetConfigurationBytes(System.Byte[])
  parent: System.AppDomainSetup
  isExternal: false
  name: SetConfigurationBytes(Byte[])
  nameWithType: AppDomainSetup.SetConfigurationBytes(Byte[])
  fullName: System.AppDomainSetup.SetConfigurationBytes(Byte[])
- uid: System.AppDomainSetup.SetNativeFunction(System.String,System.Int32,System.IntPtr)
  parent: System.AppDomainSetup
  isExternal: false
  name: SetNativeFunction(String,Int32,IntPtr)
  nameWithType: AppDomainSetup.SetNativeFunction(String,Int32,IntPtr)
  fullName: System.AppDomainSetup.SetNativeFunction(String,Int32,IntPtr)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.AppDomainSetup.ShadowCopyDirectories
  parent: System.AppDomainSetup
  isExternal: false
  name: ShadowCopyDirectories
  nameWithType: AppDomainSetup.ShadowCopyDirectories
  fullName: System.AppDomainSetup.ShadowCopyDirectories
- uid: System.AppDomainSetup.ShadowCopyFiles
  parent: System.AppDomainSetup
  isExternal: false
  name: ShadowCopyFiles
  nameWithType: AppDomainSetup.ShadowCopyFiles
  fullName: System.AppDomainSetup.ShadowCopyFiles
- uid: System.AppDomainSetup.TargetFrameworkName
  parent: System.AppDomainSetup
  isExternal: false
  name: TargetFrameworkName
  nameWithType: AppDomainSetup.TargetFrameworkName
  fullName: System.AppDomainSetup.TargetFrameworkName
- uid: System.AppDomainSetup.#ctor*
  parent: System.AppDomainSetup
  isExternal: false
  name: AppDomainSetup
  nameWithType: AppDomainSetup.AppDomainSetup
- uid: System.AppDomainSetup.ActivationArguments*
  parent: System.AppDomainSetup
  isExternal: false
  name: ActivationArguments
  nameWithType: AppDomainSetup.ActivationArguments
- uid: System.AppDomainSetup.AppDomainInitializer*
  parent: System.AppDomainSetup
  isExternal: false
  name: AppDomainInitializer
  nameWithType: AppDomainSetup.AppDomainInitializer
- uid: System.AppDomainSetup.AppDomainInitializerArguments*
  parent: System.AppDomainSetup
  isExternal: false
  name: AppDomainInitializerArguments
  nameWithType: AppDomainSetup.AppDomainInitializerArguments
- uid: System.AppDomainSetup.AppDomainManagerAssembly*
  parent: System.AppDomainSetup
  isExternal: false
  name: AppDomainManagerAssembly
  nameWithType: AppDomainSetup.AppDomainManagerAssembly
- uid: System.AppDomainSetup.AppDomainManagerType*
  parent: System.AppDomainSetup
  isExternal: false
  name: AppDomainManagerType
  nameWithType: AppDomainSetup.AppDomainManagerType
- uid: System.AppDomainSetup.ApplicationBase*
  parent: System.AppDomainSetup
  isExternal: false
  name: ApplicationBase
  nameWithType: AppDomainSetup.ApplicationBase
- uid: System.AppDomainSetup.ApplicationName*
  parent: System.AppDomainSetup
  isExternal: false
  name: ApplicationName
  nameWithType: AppDomainSetup.ApplicationName
- uid: System.AppDomainSetup.ApplicationTrust*
  parent: System.AppDomainSetup
  isExternal: false
  name: ApplicationTrust
  nameWithType: AppDomainSetup.ApplicationTrust
- uid: System.AppDomainSetup.CachePath*
  parent: System.AppDomainSetup
  isExternal: false
  name: CachePath
  nameWithType: AppDomainSetup.CachePath
- uid: System.AppDomainSetup.ConfigurationFile*
  parent: System.AppDomainSetup
  isExternal: false
  name: ConfigurationFile
  nameWithType: AppDomainSetup.ConfigurationFile
- uid: System.AppDomainSetup.DisallowApplicationBaseProbing*
  parent: System.AppDomainSetup
  isExternal: false
  name: DisallowApplicationBaseProbing
  nameWithType: AppDomainSetup.DisallowApplicationBaseProbing
- uid: System.AppDomainSetup.DisallowBindingRedirects*
  parent: System.AppDomainSetup
  isExternal: false
  name: DisallowBindingRedirects
  nameWithType: AppDomainSetup.DisallowBindingRedirects
- uid: System.AppDomainSetup.DisallowCodeDownload*
  parent: System.AppDomainSetup
  isExternal: false
  name: DisallowCodeDownload
  nameWithType: AppDomainSetup.DisallowCodeDownload
- uid: System.AppDomainSetup.DisallowPublisherPolicy*
  parent: System.AppDomainSetup
  isExternal: false
  name: DisallowPublisherPolicy
  nameWithType: AppDomainSetup.DisallowPublisherPolicy
- uid: System.AppDomainSetup.DynamicBase*
  parent: System.AppDomainSetup
  isExternal: false
  name: DynamicBase
  nameWithType: AppDomainSetup.DynamicBase
- uid: System.AppDomainSetup.GetConfigurationBytes*
  parent: System.AppDomainSetup
  isExternal: false
  name: GetConfigurationBytes
  nameWithType: AppDomainSetup.GetConfigurationBytes
- uid: System.AppDomainSetup.LicenseFile*
  parent: System.AppDomainSetup
  isExternal: false
  name: LicenseFile
  nameWithType: AppDomainSetup.LicenseFile
- uid: System.AppDomainSetup.LoaderOptimization*
  parent: System.AppDomainSetup
  isExternal: false
  name: LoaderOptimization
  nameWithType: AppDomainSetup.LoaderOptimization
- uid: System.AppDomainSetup.PartialTrustVisibleAssemblies*
  parent: System.AppDomainSetup
  isExternal: false
  name: PartialTrustVisibleAssemblies
  nameWithType: AppDomainSetup.PartialTrustVisibleAssemblies
- uid: System.AppDomainSetup.PrivateBinPath*
  parent: System.AppDomainSetup
  isExternal: false
  name: PrivateBinPath
  nameWithType: AppDomainSetup.PrivateBinPath
- uid: System.AppDomainSetup.PrivateBinPathProbe*
  parent: System.AppDomainSetup
  isExternal: false
  name: PrivateBinPathProbe
  nameWithType: AppDomainSetup.PrivateBinPathProbe
- uid: System.AppDomainSetup.SandboxInterop*
  parent: System.AppDomainSetup
  isExternal: false
  name: SandboxInterop
  nameWithType: AppDomainSetup.SandboxInterop
- uid: System.AppDomainSetup.SetCompatibilitySwitches*
  parent: System.AppDomainSetup
  isExternal: false
  name: SetCompatibilitySwitches
  nameWithType: AppDomainSetup.SetCompatibilitySwitches
- uid: System.AppDomainSetup.SetConfigurationBytes*
  parent: System.AppDomainSetup
  isExternal: false
  name: SetConfigurationBytes
  nameWithType: AppDomainSetup.SetConfigurationBytes
- uid: System.AppDomainSetup.SetNativeFunction*
  parent: System.AppDomainSetup
  isExternal: false
  name: SetNativeFunction
  nameWithType: AppDomainSetup.SetNativeFunction
- uid: System.AppDomainSetup.ShadowCopyDirectories*
  parent: System.AppDomainSetup
  isExternal: false
  name: ShadowCopyDirectories
  nameWithType: AppDomainSetup.ShadowCopyDirectories
- uid: System.AppDomainSetup.ShadowCopyFiles*
  parent: System.AppDomainSetup
  isExternal: false
  name: ShadowCopyFiles
  nameWithType: AppDomainSetup.ShadowCopyFiles
- uid: System.AppDomainSetup.TargetFrameworkName*
  parent: System.AppDomainSetup
  isExternal: false
  name: TargetFrameworkName
  nameWithType: AppDomainSetup.TargetFrameworkName
