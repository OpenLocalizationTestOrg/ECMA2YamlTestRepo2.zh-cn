### YamlMime:ManagedReference
items:
- uid: System.Windows.Application
  id: Application
  children:
  - System.Windows.Application.#ctor
  - System.Windows.Application.Activated
  - System.Windows.Application.Current
  - System.Windows.Application.Deactivated
  - System.Windows.Application.DispatcherUnhandledException
  - System.Windows.Application.Exit
  - System.Windows.Application.FindResource(System.Object)
  - System.Windows.Application.FragmentNavigation
  - System.Windows.Application.GetContentStream(System.Uri)
  - System.Windows.Application.GetCookie(System.Uri)
  - System.Windows.Application.GetRemoteStream(System.Uri)
  - System.Windows.Application.GetResourceStream(System.Uri)
  - System.Windows.Application.LoadCompleted
  - System.Windows.Application.LoadComponent(System.Uri)
  - System.Windows.Application.LoadComponent(System.Object,System.Uri)
  - System.Windows.Application.MainWindow
  - System.Windows.Application.Navigated
  - System.Windows.Application.Navigating
  - System.Windows.Application.NavigationFailed
  - System.Windows.Application.NavigationProgress
  - System.Windows.Application.NavigationStopped
  - System.Windows.Application.OnActivated(System.EventArgs)
  - System.Windows.Application.OnDeactivated(System.EventArgs)
  - System.Windows.Application.OnExit(System.Windows.ExitEventArgs)
  - System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)
  - System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)
  - System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)
  - System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)
  - System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)
  - System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)
  - System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)
  - System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)
  - System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)
  - System.Windows.Application.Properties
  - System.Windows.Application.ResourceAssembly
  - System.Windows.Application.Resources
  - System.Windows.Application.Run
  - System.Windows.Application.Run(System.Windows.Window)
  - System.Windows.Application.SessionEnding
  - System.Windows.Application.SetCookie(System.Uri,System.String)
  - System.Windows.Application.Shutdown
  - System.Windows.Application.Shutdown(System.Int32)
  - System.Windows.Application.ShutdownMode
  - System.Windows.Application.Startup
  - System.Windows.Application.StartupUri
  - System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  - System.Windows.Application.TryFindResource(System.Object)
  - System.Windows.Application.Windows
  langs:
  - csharp
  name: Application
  nameWithType: Application
  fullName: System.Windows.Application
  type: Class
  summary: "封装[!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)]应用程序。"
  remarks: "应用程序是一个类，封装[!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]应用程序特定的功能，其中包括:-**应用程序生存期**: <xref:System.Windows.Application.Activated> <xref:System.Windows.Application.Current%2A> <xref:System.Windows.Application.Deactivated> <xref:System.Windows.Application.DispatcherUnhandledException> <xref:System.Windows.Application.Exit> <xref:System.Windows.Application.Run%2A> <xref:System.Windows.Application.SessionEnding> <xref:System.Windows.Application.Shutdown%2A> <xref:System.Windows.Application.ShutdownMode%2A>、 <xref:System.Windows.Application.Startup>.</xref:System.Windows.Application.Startup> </xref:System.Windows.Application.ShutdownMode%2A> </xref:System.Windows.Application.Shutdown%2A> </xref:System.Windows.Application.SessionEnding> </xref:System.Windows.Application.Run%2A> </xref:System.Windows.Application.Exit> </xref:System.Windows.Application.DispatcherUnhandledException> </xref:System.Windows.Application.Deactivated> </xref:System.Windows.Application.Current%2A> </xref:System.Windows.Application.Activated>      -**作用域的应用程序窗口、 属性和资源管理**: <xref:System.Windows.Application.FindResource%2A> <xref:System.Windows.Application.GetContentStream%2A> <xref:System.Windows.Application.GetResourceStream%2A> <xref:System.Windows.Application.LoadComponent%2A> <xref:System.Windows.Application.MainWindow%2A> <xref:System.Windows.Application.Properties%2A> <xref:System.Windows.Application.Resources%2A> <xref:System.Windows.Application.StartupUri%2A>、 <xref:System.Windows.Application.Windows%2A>.</xref:System.Windows.Application.Windows%2A> </xref:System.Windows.Application.StartupUri%2A> </xref:System.Windows.Application.Resources%2A> </xref:System.Windows.Application.Properties%2A> </xref:System.Windows.Application.MainWindow%2A> </xref:System.Windows.Application.LoadComponent%2A> </xref:System.Windows.Application.GetResourceStream%2A> </xref:System.Windows.Application.GetContentStream%2A> </xref:System.Windows.Application.FindResource%2A>      -**命令行参数和退出代码处理**: <xref:System.Windows.Application.Startup?displayProperty=fullName> <xref:System.Windows.Application.Exit?displayProperty=fullName>、 <xref:System.Windows.Application.Shutdown%2A?displayProperty=fullName>.</xref:System.Windows.Application.Shutdown%2A?displayProperty=fullName> </xref:System.Windows.Application.Exit?displayProperty=fullName> </xref:System.Windows.Application.Startup?displayProperty=fullName>      -   **Navigation**: <xref:System.Windows.Application.FragmentNavigation>, <xref:System.Windows.Application.LoadCompleted>, <xref:System.Windows.Application.Navigated>, <xref:System.Windows.Application.Navigating>, <xref:System.Windows.Application.NavigationProgress>, <xref:System.Windows.Application.NavigationStopped>, <xref:System.Windows.Application.NavigationFailed>, <xref:System.Windows.Application.SetCookie%2A>, <xref:System.Windows.Application.GetCookie%2A>.</xref:System.Windows.Application.GetCookie%2A></xref:System.Windows.Application.SetCookie%2A></xref:System.Windows.Application.NavigationFailed></xref:System.Windows.Application.NavigationStopped></xref:System.Windows.Application.NavigationProgress></xref:System.Windows.Application.Navigating></xref:System.Windows.Application.Navigated></xref:System.Windows.Application.LoadCompleted></xref:System.Windows.Application.FragmentNavigation>       应用程序实现以提供对其窗口、 属性和资源作用域服务的共享的访问的单一实例模式。 因此，在每<xref:System.AppDomain>.</xref:System.AppDomain>创建应用程序类的一个实例       你可以实现使用标记、 标记和代码隐藏或代码的应用程序。 如果应用程序通过实现的标记，是否标记文件标记或标记和代码隐藏，必须配置为[!INCLUDE[TLA#tla_msbuild](~/add/includes/tlasharptla-msbuild-md.md)]`ApplicationDefinition`项。      1> [!NOTE]&1;> 独立的应用程序不需要应用程序对象; 它是可以实现一个自定义`static`入口点方法 (`Main`)，这将打开一个窗口，而无需创建应用程序的实例。 但是，[!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)]需要应用程序对象。"
  example:
  - "The following example shows how a standard application is defined using only markup:  \n  \n [!code-xml[ApplicationSnippets#ApplicationMARKUP](~/add/codesnippet/xaml/ApplicationSnippets.CSharp/AppMarkup.xaml#applicationmarkup)]  \n  \n The following example shows how a standard application is defined using only code:  \n  \n [!code-cs[ApplicationSnippets#ApplicationCODE](~/add/codesnippet/csharp/ApplicationSnippets.CSharp/AppCode.cs#applicationcode)]\n [!code-vb[ApplicationSnippets#ApplicationCODE](~/add/codesnippet/visualbasic/applicationsnippets/appcode.vb#applicationcode)]  \n  \n The following example shows how a standard application is defined using a combination of markup and code-behind.  \n  \n [!code-xml[ApplicationSnippets#ApplicationXAML](~/add/codesnippet/xaml/ApplicationSnippets.CSharp/App.xaml#applicationxaml)]  \n  \n [!code-cs[ApplicationSnippets#ApplicationCODEBEHIND](~/add/codesnippet/csharp/ApplicationSnippets.CSharp/App.xaml.cs#applicationcodebehind)]\n [!code-vb[ApplicationSnippets#ApplicationCODEBEHIND](~/add/codesnippet/visualbasic/applicationsnippets/application.xaml.vb#applicationcodebehind)]"
  syntax:
    content: 'public class Application : System.Windows.Threading.DispatcherObject, System.Windows.Markup.IQueryAmbient'
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  implements:
  - System.Windows.Markup.IQueryAmbient
  inheritedMembers:
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  platform:
  - net462
- uid: System.Windows.Application.#ctor
  id: '#ctor'
  parent: System.Windows.Application
  langs:
  - csharp
  name: Application()
  nameWithType: Application.Application()
  fullName: System.Windows.Application.Application()
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "初始化的新实例<xref href=&quot;System.Windows.Application&quot;></xref>类。"
  remarks: "一个实例<xref:System.Windows.Application>类可以创建每个<xref:System.AppDomain>，以确保对单个数据集的作用域的应用程序窗口、 属性和资源的共享的访问。</xref:System.AppDomain> </xref:System.Windows.Application> 因此，默认构造函数的<xref:System.Windows.Application>类检测到正在初始化的实例是否中的第一个实例<xref:System.AppDomain>; 如果不是，<xref:System.InvalidOperationException>引发。</xref:System.InvalidOperationException> </xref:System.AppDomain> </xref:System.Windows.Application>       <xref:System.Windows.Application>当前对象<xref:System.AppDomain>公开从静态<xref:System.Windows.Application.Current%2A>属性。</xref:System.Windows.Application.Current%2A> </xref:System.AppDomain> </xref:System.Windows.Application>"
  syntax:
    content: public Application ();
    parameters: []
  overload: System.Windows.Application.#ctor*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "多个实例<xref href=&quot;System.Windows.Application&quot;></xref>类创建每个<xref href=&quot;System.AppDomain&quot;> </xref>。"
  platform:
  - net462
- uid: System.Windows.Application.Activated
  id: Activated
  parent: System.Windows.Application
  langs:
  - csharp
  name: Activated
  nameWithType: Application.Activated
  fullName: System.Windows.Application.Activated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "当应用程序变得前台应用程序时发生。"
  remarks: "A[!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)]激活应用程序具有一个或多个打开的窗口 （成为前景应用程序） 时一窗口以来激活时首次启动应用程序，或在应用程序处于非活动状态期间激活了一窗口时︰ 具体而言，执行了激活时:-应用程序打开其第一个窗口。      -A 用户切换到应用程序，通过使用 ALT + TAB 或使用任务管理器。      -用户单击其中一个应用程序中窗口的任务栏按钮。       需要检测何时及其激活的应用程序可以处理已激活事件。       第一次激活应用程序之后，它可能会停用并且在其生存期内多次重新激活。 如果应用程序的行为或状态取决于其激活状态，它可以处理已激活和<xref:System.Windows.Application.Deactivated>事件，以确定哪些激活状态的单元</xref:System.Windows.Application.Deactivated>       一旦应用程序将变为活动状态，已激活将不会再次引发直到停用应用程序，而不考虑应用程序处于活动状态时激活了多少应用程序中的窗口。       激活不的引发[!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)]。"
  example:
  - "The following example shows how to detect when a standalone application activates and deactivates.  \n  \n [!code-xml[ApplicationActivationSnippets#DetectActivationStateXAML](~/add/codesnippet/xaml/ApplicationActivationSnippets.CSharp/App.xaml#detectactivationstatexaml)]  \n  \n [!code-cs[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/add/codesnippet/csharp/ApplicationActivationSnippets.CSharp/App.xaml.cs#detectactivationstatecodebehind)]\n [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/add/codesnippet/visualbasic/applicationactivationsnippets/application.xaml.vb#detectactivationstatecodebehind)]"
  syntax:
    content: public event EventHandler Activated;
    return:
      type: System.EventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Current
  id: Current
  parent: System.Windows.Application
  langs:
  - csharp
  name: Current
  nameWithType: Application.Current
  fullName: System.Windows.Application.Current
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "获取<xref href=&quot;System.Windows.Application&quot;></xref>当前对象<xref href=&quot;System.AppDomain&quot;> </xref>。"
  remarks: "<xref:System.Windows.Application>为每个-<xref:System.AppDomain>实现静态当前的属性，以提供对<xref:System.Windows.Application>当前<xref:System.AppDomain>.</xref:System.AppDomain>实例</xref:System.Windows.Application>的共享的访问的单一实例类型</xref:System.AppDomain></xref:System.Windows.Application> 这种设计保证由该状态<xref:System.Windows.Application>，包括共享的资源和状态，可从一个单个的共享位置。</xref:System.Windows.Application>       此属性是线程安全的可从任意线程。"
  syntax:
    content: public static System.Windows.Application Current { get; }
    return:
      type: System.Windows.Application
      description: "<xref href=&quot;System.Windows.Application&quot;> </xref>当前对象<xref href=&quot;System.AppDomain&quot;> </xref>。"
  overload: System.Windows.Application.Current*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Deactivated
  id: Deactivated
  parent: System.Windows.Application
  langs:
  - csharp
  name: Deactivated
  nameWithType: Application.Deactivated
  fullName: System.Windows.Application.Deactivated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "在应用程序不再前台应用程序时发生。"
  remarks: "A[!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)]具有一个或多个打开的 windows 应用程序会停用 （停止作为前台应用程序） 时用户执行下列任务:-通过使用 ALT + TAB 或使用任务管理器切换到另一个应用程序。      -单击另一个应用程序中的窗口的任务栏按钮。       需要检测停用应用程序可以处理已停用事件。       第一次激活应用程序之后，它可能会停用并且在其生存期内多次重新激活。 如果应用程序的行为或状态取决于其激活状态，它可以处理这两个已停用和<xref:System.Windows.Application.Activated>事件，以确定其状态很单元</xref:System.Windows.Application.Activated>       停用的情况下不会引发[!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)]。"
  example:
  - "The following example shows how to detect when a standalone application deactivates and activates.  \n  \n [!code-xml[ApplicationActivationSnippets#DetectActivationStateXAML](~/add/codesnippet/xaml/ApplicationActivationSnippets.CSharp/App.xaml#detectactivationstatexaml)]  \n  \n [!code-cs[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/add/codesnippet/csharp/ApplicationActivationSnippets.CSharp/App.xaml.cs#detectactivationstatecodebehind)]\n [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/add/codesnippet/visualbasic/applicationactivationsnippets/application.xaml.vb#detectactivationstatecodebehind)]"
  syntax:
    content: public event EventHandler Deactivated;
    return:
      type: System.EventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.DispatcherUnhandledException
  id: DispatcherUnhandledException
  parent: System.Windows.Application
  langs:
  - csharp
  name: DispatcherUnhandledException
  nameWithType: Application.DispatcherUnhandledException
  fullName: System.Windows.Application.DispatcherUnhandledException
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "当应用程序引发但未处理异常时发生。"
  remarks: "默认情况下，[!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)]捕获未经处理的异常、 将通知用户 （它们可以从该对话框报告异常） 对话框中，从异常和应用程序将自动关闭。       但是，如果应用程序需要执行自定义处理从一个集中位置的未经处理的异常，则应处理 DispatcherUnhandledException。       由引发 DispatcherUnhandledException<xref:System.Windows.Application>对于每个主 UI 线程上运行的代码中未经处理的异常。</xref:System.Windows.Application>       如果未处理异常时在后台[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]线程 (具有其自己的线程<xref:System.Windows.Threading.Dispatcher>) 或后台辅助线程 (而无需线程<xref:System.Windows.Threading.Dispatcher>)，该异常不会转发到主[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]线程。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher> 因此，不会引发 DispatcherUnhandledException。 在这些情况下，你将需要编写代码来执行以下操作︰ 1。  处理异常的后台线程上。      2.  这些异常调度到主[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]线程。      3.  再次引发这些异常在主[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]而不进行处理，以允许 DispatcherUnhandledException 引发的线程。       有关详细信息，请参阅[线程处理模型](~/add/includes/ajax-current-ext-md.md)概述。       DispatcherUnhandledException 事件处理程序传递<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs>包含与异常，相关的上下文信息的自变量包括:-异常 (<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A>)。</xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A> </xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs>      -<xref:System.Windows.Threading.Dispatcher>从它 (<xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A>)。</xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A> </xref:System.Windows.Threading.Dispatcher>       可以使用此信息来确定异常是否可恢复。 可恢复的异常可能是<xref:System.IO.FileNotFoundException>，例如，尽管可能不可恢复的异常<xref:System.StackOverflowException>，例如。</xref:System.StackOverflowException> </xref:System.IO.FileNotFoundException>       当处理 DispatcherUnhandledException，未经处理的异常，并且不希望[!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]以便继续处理它，你需要设置<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A>属性`true`。</xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A>       与其他事件不同，<xref:System.Windows.Application>引发，DispatcherUnhandledException 没有匹配的受保护虚拟实现 (OnDispatcherUnhandledException)。</xref:System.Windows.Application> 因此，类派生自<xref:System.Windows.Application>必须始终将注册事件处理程序 DispatcherUnhandledException 处理未经处理的异常。</xref:System.Windows.Application>"
  example:
  - "The following example shows how to process unhandled exceptions by handling the DispatcherUnhandledException event.  \n  \n [!code-cs[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/add/codesnippet/csharp/ApplicationDispatcherUnhandledExceptionSnippets.CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind1)]\n [!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/add/codesnippet/visualbasic/applicationdispatcherunhandledexceptionsnippets/application.xaml.vb#handledispatcherunhandledexceptioncodebehind1)]  \n[!code-cs[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/add/codesnippet/csharp/ApplicationDispatcherUnhandledExceptionSnippets.CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind2)]\n[!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/add/codesnippet/visualbasic/applicationdispatcherunhandledexceptionsnippets/application.xaml.vb#handledispatcherunhandledexceptioncodebehind2)]"
  syntax:
    content: public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException;
    return:
      type: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Exit
  id: Exit
  parent: System.Windows.Application
  langs:
  - csharp
  name: Exit
  nameWithType: Application.Exit
  fullName: System.Windows.Application.Exit
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "应用程序关闭，且无法取消之前发生。"
  remarks: "应用程序可以关闭这两个由于以下原因:-<xref:System.Windows.Application.Shutdown%2A>方法<xref:System.Windows.Application>调用对象时，无论是显式还是作为确定通过<xref:System.Windows.Application.ShutdownMode%2A>属性。</xref:System.Windows.Application.ShutdownMode%2A> </xref:System.Windows.Application> </xref:System.Windows.Application.Shutdown%2A>      -用户将通过注销或关闭来结束会话。       你可以检测应用程序关闭时通过处理退出事件，并执行所需进行任何其他处理。       你还可以处理退出以检查或更改应用程序退出代码时无需调用<xref:System.Windows.Application.Shutdown%2A>显式。</xref:System.Windows.Application.Shutdown%2A> 退出代码公开从<xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A>属性<xref:System.Windows.ExitEventArgs>传递给退出事件处理程序自变量。</xref:System.Windows.ExitEventArgs> </xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> 当应用程序停止运行时，退出代码将被传递到操作系统，以进行后续处理。       如果你的应用程序处理<xref:System.Windows.Application.SessionEnding>事件并且随后它退出，则不会引发的取消和应用程序将继续在符合关闭模式中运行。</xref:System.Windows.Application.SessionEnding>       退出代码可以设置从[!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)]，尽管忽略的值。       有关[!INCLUDE[TLA2#tla_xbap#plural](~/add/includes/tla2sharptla-xbapsharpplural-md.md)]，在以下情况下引发退出:-一个[!INCLUDE[TLA2#tla_xbap](~/add/includes/ajax-current-ext-md.md)]离开。      -在[!INCLUDE[TLA2#tla_ie7](~/add/includes/tla2sharptla-ie7-md.md)]，当选项卡承载[!INCLUDE[TLA2#tla_xbap](~/add/includes/ajax-current-ext-md.md)]已关闭。      -如果已关闭浏览器。       在所有情况下，值<xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A>属性将被忽略。</xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A>"
  example:
  - "The following example demonstrates how to:  \n  \n-   Handle the Exit event.  \n  \n-   Inspect and update the <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> property of the <xref:System.Windows.ExitEventArgs>.  \n  \n-   Write an entry to an application log in isolated storage.  \n  \n-   Persist the application state to isolated storage.  \n  \n [!code-xml[ApplicationExitSnippets#HandleExitXAML](~/add/codesnippet/xaml/ApplicationExitSnippets.CSharp/App.xaml#handleexitxaml)]  \n  \n [!code-cs[ApplicationExitSnippets#HandleExitCODEBEHIND](~/add/codesnippet/csharp/ApplicationExitSnippets.CSharp/App.xaml.cs#handleexitcodebehind)]\n [!code-vb[ApplicationExitSnippets#HandleExitCODEBEHIND](~/add/codesnippet/visualbasic/applicationexitsnippets/application.xaml.vb#handleexitcodebehind)]"
  syntax:
    content: public event System.Windows.ExitEventHandler Exit;
    return:
      type: System.Windows.ExitEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.FindResource(System.Object)
  id: FindResource(System.Object)
  parent: System.Windows.Application
  langs:
  - csharp
  name: FindResource(Object)
  nameWithType: Application.FindResource(Object)
  fullName: System.Windows.Application.FindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "搜索[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]资源，如<xref href=&quot;System.Windows.Style&quot;></xref>或<xref href=&quot;System.Windows.Media.Brush&quot;> </xref>、 与指定的键，将引发异常如果找不到请求的资源 (请参阅[XAML 资源](~/add/includes/ajax-current-ext-md.md))。"
  remarks: "FindResource 将首先在应用程序范围内指定资源的资源中查找。 应用程序范围的资源由<xref:System.Windows.Application>，和从公开<xref:System.Windows.Application.Resources%2A>属性。</xref:System.Windows.Application.Resources%2A> </xref:System.Windows.Application> 如果应用程序范围的资源组中未找到指定的资源，FindResource 下一步搜索系统资源。 系统资源是由用户定义的命令行程序资源，包括颜色、 字体和外壳程序配置。 这些来自<xref:System.Windows.SystemColors>， <xref:System.Windows.SystemFonts>，和<xref:System.Windows.SystemParameters>分别为静态属性类型。</xref:System.Windows.SystemParameters> </xref:System.Windows.SystemFonts> </xref:System.Windows.SystemColors> 若要使用 FindResource 获取它们，这些类型还公开旨在传递给 FindResource; 的资源键属性例如， <xref:System.Windows.SystemParameters.IconWidthKey%2A>.</xref:System.Windows.SystemParameters.IconWidthKey%2A>       因为 FindResource 返回一个对象，您必须强制转换为适当的类型的返回的值，如果找到资源。      1> [!IMPORTANT]&1;> 如果找不到键调用此方法，将引发异常。 如果你不希望以处理调用 FindResource 导致的异常，请改为; 调用<xref:System.Windows.Application.TryFindResource%2A><xref:System.Windows.Application.TryFindResource%2A>返回`null`引用时找不到请求的资源，并不会引发异常。</xref:System.Windows.Application.TryFindResource%2A> </xref:System.Windows.Application.TryFindResource%2A>       此方法是线程安全的可以从任何线程调用。"
  example:
  - "The following example shows how to use FindResource to find a resource, and to handle <xref:System.Windows.ResourceReferenceKeyNotFoundException> if the resource is not found.  \n  \n [!code-cs[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/add/codesnippet/csharp/ApplicationFindResourceSnippets/MainWindow.xaml.cs#applicationcallfindresourcecodebehind)]\n [!code-vb[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/add/codesnippet/visualbasic/applicationfindresourcesnippets/mainwindow.xaml.vb#applicationcallfindresourcecodebehind)]"
  syntax:
    content: public object FindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "要查找的资源的名称。"
    return:
      type: System.Object
      description: "所请求的资源对象。 如果未找到请求的资源， <xref href=&quot;System.Windows.ResourceReferenceKeyNotFoundException&quot;> </xref>引发。"
  overload: System.Windows.Application.FindResource*
  exceptions:
  - type: System.Windows.ResourceReferenceKeyNotFoundException
    commentId: T:System.Windows.ResourceReferenceKeyNotFoundException
    description: "找不到资源。"
  platform:
  - net462
- uid: System.Windows.Application.FragmentNavigation
  id: FragmentNavigation
  parent: System.Windows.Application
  langs:
  - csharp
  name: FragmentNavigation
  nameWithType: Application.FragmentNavigation
  fullName: System.Windows.Application.FragmentNavigation
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "当应用程序中的导航器开始导航到内容片段中，如果所需的片段中的当前内容，或源之后立即发生导航[!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)]如果所需的片段位于不同的内容已加载内容。"
  remarks: "导航器是其中一种<xref:System.Windows.Navigation.NavigationWindow>或一种<xref:System.Windows.Controls.Frame>。</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       请参阅<xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=fullName>。</xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=fullName>"
  syntax:
    content: public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;
    return:
      type: System.Windows.Navigation.FragmentNavigationEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.GetContentStream(System.Uri)
  id: GetContentStream(System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: GetContentStream(Uri)
  nameWithType: Application.GetContentStream(Uri)
  fullName: System.Windows.Application.GetContentStream(Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "返回位于指定的内容的数据文件的资源流<xref:System.Uri>(请参阅[WPF 应用程序资源、 内容和数据文件](~/add/includes/ajax-current-ext-md.md))。</xref:System.Uri>"
  remarks: "此方法不是线程安全。"
  syntax:
    content: public static System.Windows.Resources.StreamResourceInfo GetContentStream (Uri uriContent);
    parameters:
    - id: uriContent
      type: System.Uri
      description: "相对<xref:System.Uri>映射到松散的资源。</xref:System.Uri>"
    return:
      type: System.Windows.Resources.StreamResourceInfo
      description: "A <xref href=&quot;System.Windows.Resources.StreamResourceInfo&quot;> </xref>包含位于指定<xref:System.Uri>.</xref:System.Uri>的内容的数据文件 如果未找到松散资源，则返回 null。"
  overload: System.Windows.Application.GetContentStream*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<xref:System.Uri>传递给 GetContentStream 为 null。</xref:System.Uri>"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<xref:System.Uri>，它是传递给 GetContentStream 是绝对<xref:System.Uri>.</xref:System.Uri> </xref:System.Uri>"
  platform:
  - net462
- uid: System.Windows.Application.GetCookie(System.Uri)
  id: GetCookie(System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: GetCookie(Uri)
  nameWithType: Application.GetCookie(Uri)
  fullName: System.Windows.Application.GetCookie(Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "检索用于指定一种<xref:System.Uri>。</xref:System.Uri>的位置的 cookie。"
  remarks: "GetCookie 检索指定<xref:System.Uri>。</xref:System.Uri> cookie 如果无法检索 cookie，<xref:System.ComponentModel.Win32Exception>引发。</xref:System.ComponentModel.Win32Exception> 你需要编写代码以将 cookie 字符串分析为名称/值对的列表。       有关概述中的 cookie [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]，请参阅[导航概述](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public static string GetCookie (Uri uri);
    parameters:
    - id: uri
      type: System.Uri
      description: "<xref:System.Uri>，它指定为其创建 cookie 的位置。</xref:System.Uri>"
    return:
      type: System.String
      description: "A<xref:System.String>值，如果存在 cookie; 否则为<xref href=&quot;System.ComponentModel.Win32Exception&quot;></xref>引发。</xref:System.String>"
  overload: System.Windows.Application.GetCookie*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "A[!INCLUDE[TLA#tla_win32](~/add/includes/tlasharptla-win32-md.md)]错误由<xref uid=&quot;langword_csharp_InternetGetCookie&quot; name=&quot;InternetGetCookie&quot; href=&quot;&quot;></xref>函数 （由 GetCookie） 如果尝试检索指定的 cookie 时出现问题。"
  platform:
  - net462
- uid: System.Windows.Application.GetRemoteStream(System.Uri)
  id: GetRemoteStream(System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: GetRemoteStream(Uri)
  nameWithType: Application.GetRemoteStream(Uri)
  fullName: System.Windows.Application.GetRemoteStream(Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "返回位于指定的源站点数据文件的资源流<xref:System.Uri>(请参阅[WPF 应用程序资源、 内容和数据文件](~/add/includes/ajax-current-ext-md.md))。</xref:System.Uri>"
  remarks: "此方法不是线程安全。"
  syntax:
    content: public static System.Windows.Resources.StreamResourceInfo GetRemoteStream (Uri uriRemote);
    parameters:
    - id: uriRemote
      type: System.Uri
      description: "<xref:System.Uri>映射到在源站点的松散资源。</xref:System.Uri>"
    return:
      type: System.Windows.Resources.StreamResourceInfo
      description: "A <xref href=&quot;System.Windows.Resources.StreamResourceInfo&quot;> </xref> ，其中包含指定<xref:System.Uri>.</xref:System.Uri>在所在的源站点数据文件的资源流 如果未找到松散的资源， <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>返回。"
  overload: System.Windows.Application.GetRemoteStream*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<xref:System.Uri>传递给 GetRemoteStream 为 null。</xref:System.Uri>"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<xref:System.Uri>传递给 GetRemoteStream 不是相对的而不是在绝对值`pack://siteoforigin:,,,/`窗体。</xref:System.Uri>"
  platform:
  - net462
- uid: System.Windows.Application.GetResourceStream(System.Uri)
  id: GetResourceStream(System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: GetResourceStream(Uri)
  nameWithType: Application.GetResourceStream(Uri)
  fullName: System.Windows.Application.GetResourceStream(Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "返回位于指定的资源数据文件的资源流<xref:System.Uri>(请参阅[WPF 应用程序资源、 内容和数据文件](~/add/includes/ajax-current-ext-md.md))。</xref:System.Uri>"
  remarks: "此方法不是线程安全。"
  syntax:
    content: public static System.Windows.Resources.StreamResourceInfo GetResourceStream (Uri uriResource);
    parameters:
    - id: uriResource
      type: System.Uri
      description: "<xref:System.Uri>映射到嵌入的资源。</xref:System.Uri>"
    return:
      type: System.Windows.Resources.StreamResourceInfo
      description: "A <xref href=&quot;System.Windows.Resources.StreamResourceInfo&quot;> </xref> ，其中包含指定<xref:System.Uri>.</xref:System.Uri>在所在的资源数据文件的资源流"
  overload: System.Windows.Application.GetResourceStream*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<xref:System.Uri>传递给 GetResourceStream 为 null。</xref:System.Uri>"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<xref:System.Uri>传递给 GetResourceStream 不是相对的而不是在绝对值`pack://application:,,,/`窗体。</xref:System.Uri>"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<xref:System.Uri>传递给找不到 GetResourceStream。</xref:System.Uri>"
  platform:
  - net462
- uid: System.Windows.Application.LoadCompleted
  id: LoadCompleted
  parent: System.Windows.Application
  langs:
  - csharp
  name: LoadCompleted
  nameWithType: Application.LoadCompleted
  fullName: System.Windows.Application.LoadCompleted
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "在已加载，分析，并开始呈现应用程序中的导航器导航到的内容时发生。"
  remarks: "导航器是其中一种<xref:System.Windows.Navigation.NavigationWindow>或一种<xref:System.Windows.Controls.Frame>。</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       请参阅<xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=fullName>。</xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=fullName>      1> [!NOTE]&1;> 如侦听事件导航内容<xref:System.Windows.FrameworkElement.Loaded>上的事件<xref:System.Windows.Controls.Page>访问导航的内容的属性之前。</xref:System.Windows.Controls.Page> </xref:System.Windows.FrameworkElement.Loaded>"
  syntax:
    content: public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;
    return:
      type: System.Windows.Navigation.LoadCompletedEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.LoadComponent(System.Uri)
  id: LoadComponent(System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: LoadComponent(Uri)
  nameWithType: Application.LoadComponent(Uri)
  fullName: System.Windows.Application.LoadComponent(Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "加载[!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)]位于指定的文件[!INCLUDE[TLA#tla_uri](~/add/includes/tlasharptla-uri-md.md)]，并将其转换到的根元素指定的对象实例[!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)]文件。"
  remarks: "你必须显式转换到的根元素相同类型的返回值[!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)]文件。       [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)]文件可以是应用程序代码文件 (配置为[!INCLUDE[TLA#tla_msbuild](~/add/includes/tlasharptla-msbuild-md.md)]页项) 或应用程序数据文件 (资源文件、 内容文件或的源站点文件; 请参阅[WPF 应用程序资源、 内容和数据文件](~/add/includes/ajax-current-ext-md.md))。      1> [!NOTE]&1;> 此方法不是线程安全。"
  syntax:
    content: public static object LoadComponent (Uri resourceLocator);
    parameters:
    - id: resourceLocator
      type: System.Uri
      description: "A<xref:System.Uri>映射到相对[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]文件。</xref:System.Uri>"
    return:
      type: System.Object
      description: "指定加载的 XAML 文件的根元素的实例。"
  overload: System.Windows.Application.LoadComponent*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>resourceLocator</code>为 null。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>resourceLocator</code> is an absolute [!INCLUDE[TLA2#tla_uri](~/add/includes/tla2sharptla-uri-md.md)]."
  - type: System.Exception
    commentId: T:System.Exception
    description: "文件不是[!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)]文件。"
  platform:
  - net462
- uid: System.Windows.Application.LoadComponent(System.Object,System.Uri)
  id: LoadComponent(System.Object,System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: LoadComponent(Object,Uri)
  nameWithType: Application.LoadComponent(Object,Uri)
  fullName: System.Windows.Application.LoadComponent(Object,Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "加载[!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)]位于指定的文件[!INCLUDE[TLA#tla_uri](~/add/includes/tlasharptla-uri-md.md)]并将其转换到的根元素指定的对象实例[!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)]文件。"
  remarks: "[!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)]文件可以是应用程序代码文件 (配置为[!INCLUDE[TLA#tla_msbuild](~/add/includes/tlasharptla-msbuild-md.md)]页项) 或应用程序数据文件 (资源文件、 内容文件或的源站点文件; 请参阅[WPF 应用程序资源、 内容和数据文件](~/add/includes/ajax-current-ext-md.md))。      1> [!NOTE]&1;> 此方法不是线程安全。"
  syntax:
    content: public static void LoadComponent (object component, Uri resourceLocator);
    parameters:
    - id: component
      type: System.Object
      description: "与的根元素相同的类型的对象[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]文件。"
    - id: resourceLocator
      type: System.Uri
      description: "A<xref:System.Uri>映射到相对[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]文件。</xref:System.Uri>"
  overload: System.Windows.Application.LoadComponent*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>resourceLocator</code>为 null。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>resourceLocator</code> is an absolute [!INCLUDE[TLA2#tla_uri](~/add/includes/tla2sharptla-uri-md.md)]."
  - type: System.Exception
    commentId: T:System.Exception
    description: "<code>component</code>不匹配的根元素的类型[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]文件。"
  platform:
  - net462
- uid: System.Windows.Application.MainWindow
  id: MainWindow
  parent: System.Windows.Application
  langs:
  - csharp
  name: MainWindow
  nameWithType: Application.MainWindow
  fullName: System.Windows.Application.MainWindow
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "获取或设置应用程序的主窗口。"
  remarks: "主窗口将自动设置为第一个<xref:System.Windows.Window>要在<xref:System.AppDomain>。</xref:System.AppDomain>实例化的对象</xref:System.Windows.Window>的引用       你可以通过设置 MainWindow 分配另一个指定不同的主窗口<xref:System.Windows.Application.Windows%2A>到 MainWindow 属性的对象。</xref:System.Windows.Application.Windows%2A>       如果<xref:System.Windows.Application.ShutdownMode%2A>属性<xref:System.Windows.Application>对象设置为<xref:System.Windows.ShutdownMode>，关闭主窗口导致应用程序关闭。</xref:System.Windows.ShutdownMode> </xref:System.Windows.Application> </xref:System.Windows.Application.ShutdownMode%2A>       可以设置从 MainWindow 属性[!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)]，如果应用程序的主窗口不是通过设置生成的窗口<xref:System.Windows.Application.StartupUri%2A>中的属性[!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)]。</xref:System.Windows.Application.StartupUri%2A> 两个限制[!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)]方法是:-你可以指定[!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)]-仅<xref:System.Windows.Window>或[!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)]-仅<xref:System.Windows.Navigation.NavigationWindow>作为主窗口。</xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Window>      -你必须设置<xref:System.Windows.UIElement.Visibility%2A>你指定的窗口的属性，否则它将不会。</xref:System.Windows.UIElement.Visibility%2A>       第一个引用<xref:System.Windows.Window>要实例化的对象还添加到的第一项为<xref:System.Windows.Application.Windows%2A>集合。</xref:System.Windows.Application.Windows%2A> </xref:System.Windows.Window> 如果使用的引用为另一种随后设置 MainWindow <xref:System.Windows.Window>，与对主窗口的引用项的位置会更改，而在中的项的顺序<xref:System.Windows.Application.Windows%2A>保持不变。</xref:System.Windows.Application.Windows%2A> </xref:System.Windows.Window> 因此，始终使用 MainWindow 来引用而不是<xref:System.Windows.Application.Windows%2A>.</xref:System.Windows.Application.Windows%2A>的第一项的主窗口      1> [!NOTE]&1;> 主窗口是否<xref:System.Windows.Navigation.NavigationWindow>，而且您需要<xref:System.Windows.Navigation.NavigationWindow>成员，您将需要为<xref:System.Windows.Navigation.NavigationWindow>。</xref:System.Windows.Navigation.NavigationWindow> MainWindow 的值转换</xref:System.Windows.Navigation.NavigationWindow>到的特定权限</xref:System.Windows.Navigation.NavigationWindow>   >> 此属性则仅可从创建的线程<xref:System.Windows.Application>对象。</xref:System.Windows.Application>"
  example:
  - "The following example shows how to find the main application window.  \n  \n [!code-cs[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/add/codesnippet/csharp/ApplicationMainWindowSnippets.CSharp/App.xaml.cs#getapplicationmainwindowcode)]\n [!code-vb[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/add/codesnippet/visualbasic/applicationmainwindowsnippets/application.xaml.vb#getapplicationmainwindowcode)]  \n  \n The following example shows how to set MainWindow using [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)].  \n  \n [!code-xml[ApplicationMainWindowSnippets#SetApplicationMainWindowXAML](~/add/codesnippet/xaml/ApplicationMainWindowSnippets.XAML/App.xaml#setapplicationmainwindowxaml)]  \n  \n The following example shows how to instantiate the MainWindow in code during application startup.  \n  \n [!code-cs[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/add/codesnippet/csharp/HOWTOWindowManagementSnippets/App.xaml.cs#firstwindowusingcodecodebehind)]\n [!code-vb[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/add/codesnippet/visualbasic/howtowindowmanagementsnippets/application.xaml.vb#firstwindowusingcodecodebehind)]"
  syntax:
    content: public System.Windows.Window MainWindow { get; set; }
    return:
      type: System.Windows.Window
      description: "A <xref href=&quot;System.Windows.Window&quot;> </xref>被指定为应用程序主窗口。"
  overload: System.Windows.Application.MainWindow*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "从应用程序托管在浏览器中，如设置 MainWindow [!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)]。"
  platform:
  - net462
- uid: System.Windows.Application.Navigated
  id: Navigated
  parent: System.Windows.Application
  langs:
  - csharp
  name: Navigated
  nameWithType: Application.Navigated
  fullName: System.Windows.Application.Navigated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "当已发现应用程序中的导航器要将其导航到的内容，即使可能未完成加载时发生。"
  remarks: "导航器是其中一种<xref:System.Windows.Navigation.NavigationWindow>或一种<xref:System.Windows.Controls.Frame>。</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       请参阅<xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=fullName>。</xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=fullName>"
  syntax:
    content: public event System.Windows.Navigation.NavigatedEventHandler Navigated;
    return:
      type: System.Windows.Navigation.NavigatedEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Navigating
  id: Navigating
  parent: System.Windows.Application
  langs:
  - csharp
  name: Navigating
  nameWithType: Application.Navigating
  fullName: System.Windows.Application.Navigating
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "当新导航请求的应用程序中的导航器时发生。"
  remarks: "导航器是其中一种<xref:System.Windows.Navigation.NavigationWindow>或一种<xref:System.Windows.Controls.Frame>。</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       请参阅<xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=fullName>。</xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=fullName>"
  syntax:
    content: public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;
    return:
      type: System.Windows.Navigation.NavigatingCancelEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.NavigationFailed
  id: NavigationFailed
  parent: System.Windows.Application
  langs:
  - csharp
  name: NavigationFailed
  nameWithType: Application.NavigationFailed
  fullName: System.Windows.Application.NavigationFailed
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "在应用程序中的导航器导航到所请求的内容时发生错误时发生。"
  remarks: "导航器是其中一种<xref:System.Windows.Navigation.NavigationWindow>或一种<xref:System.Windows.Controls.Frame>。</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       请参阅<xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=fullName>。</xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=fullName>"
  syntax:
    content: public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;
    return:
      type: System.Windows.Navigation.NavigationFailedEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.NavigationProgress
  id: NavigationProgress
  parent: System.Windows.Application
  langs:
  - csharp
  name: NavigationProgress
  nameWithType: Application.NavigationProgress
  fullName: System.Windows.Application.NavigationProgress
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "在由应用程序以提供导航进度信息中的导航器的下载期间定期发生。"
  remarks: "导航器是其中一种<xref:System.Windows.Navigation.NavigationWindow>或一种<xref:System.Windows.Controls.Frame>。</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       请参阅<xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=fullName>。</xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=fullName>"
  syntax:
    content: public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;
    return:
      type: System.Windows.Navigation.NavigationProgressEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.NavigationStopped
  id: NavigationStopped
  parent: System.Windows.Application
  langs:
  - csharp
  name: NavigationStopped
  nameWithType: Application.NavigationStopped
  fullName: System.Windows.Application.NavigationStopped
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "发生时<xref uid=&quot;langword_csharp_StopLoading&quot; name=&quot;StopLoading&quot; href=&quot;&quot;></xref>调用应用程序中的导航器的方法，或正在进行当前导航时，通过导航器请求一个新的导航时发生时。"
  remarks: "导航器是其中一种<xref:System.Windows.Navigation.NavigationWindow>或一种<xref:System.Windows.Controls.Frame>。</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       请参阅<xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=fullName>。</xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=fullName>"
  syntax:
    content: public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;
    return:
      type: System.Windows.Navigation.NavigationStoppedEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnActivated(System.EventArgs)
  id: OnActivated(System.EventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnActivated(EventArgs)
  nameWithType: Application.OnActivated(EventArgs)
  fullName: System.Windows.Application.OnActivated(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "引发<xref href=&quot;System.Windows.Application.Activated&quot;></xref>事件。"
  remarks: "OnActivated 引发<xref:System.Windows.Application.Activated>事件。</xref:System.Windows.Application.Activated>       派生自类型<xref:System.Windows.Application>可能会重写 OnActivated。</xref:System.Windows.Application> 重写的方法必须调用 OnActivated 基类中如果<xref:System.Windows.Application.Activated>需要引发。</xref:System.Windows.Application.Activated>"
  syntax:
    content: protected virtual void OnActivated (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "<xref:System.EventArgs>包含事件数据。</xref:System.EventArgs>"
  overload: System.Windows.Application.OnActivated*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnDeactivated(System.EventArgs)
  id: OnDeactivated(System.EventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnDeactivated(EventArgs)
  nameWithType: Application.OnDeactivated(EventArgs)
  fullName: System.Windows.Application.OnDeactivated(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "引发<xref href=&quot;System.Windows.Application.Deactivated&quot;></xref>事件。"
  remarks: "OnDeactivated 引发<xref:System.Windows.Application.Deactivated>事件。</xref:System.Windows.Application.Deactivated>       派生自类型<xref:System.Windows.Application>可能会重写 OnDeactivated。</xref:System.Windows.Application> 重写的方法必须调用 OnDeactivated 基类中如果<xref:System.Windows.Application.Deactivated>需要引发。</xref:System.Windows.Application.Deactivated>"
  syntax:
    content: protected virtual void OnDeactivated (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "<xref:System.EventArgs>包含事件数据。</xref:System.EventArgs>"
  overload: System.Windows.Application.OnDeactivated*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnExit(System.Windows.ExitEventArgs)
  id: OnExit(System.Windows.ExitEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnExit(ExitEventArgs)
  nameWithType: Application.OnExit(ExitEventArgs)
  fullName: System.Windows.Application.OnExit(ExitEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "引发<xref href=&quot;System.Windows.Application.Exit&quot;></xref>事件。"
  remarks: "OnExit 引发<xref:System.Windows.Application.Exit>事件。</xref:System.Windows.Application.Exit>       派生自类型<xref:System.Windows.Application>可以重写 OnExit 方法。</xref:System.Windows.Application> 重写的方法必须调用 OnExit 基类中如果<xref:System.Windows.Application.Exit>需要引发。</xref:System.Windows.Application.Exit>"
  syntax:
    content: protected virtual void OnExit (System.Windows.ExitEventArgs e);
    parameters:
    - id: e
      type: System.Windows.ExitEventArgs
      description: "<xref href=&quot;System.Windows.ExitEventArgs&quot;> </xref>包含事件数据。"
  overload: System.Windows.Application.OnExit*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)
  id: OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnFragmentNavigation(FragmentNavigationEventArgs)
  nameWithType: Application.OnFragmentNavigation(FragmentNavigationEventArgs)
  fullName: System.Windows.Application.OnFragmentNavigation(FragmentNavigationEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "引发<xref href=&quot;System.Windows.Application.FragmentNavigation&quot;></xref>事件。"
  remarks: "OnFragmentNavigation 引发<xref:System.Windows.Application.FragmentNavigation>事件。</xref:System.Windows.Application.FragmentNavigation>       派生自类型<xref:System.Windows.Application>可能会重写 OnFragmentNavigation。</xref:System.Windows.Application> 重写的方法必须调用 OnFragmentNavigation 基类中如果<xref:System.Windows.Application.FragmentNavigation>需要引发。</xref:System.Windows.Application.FragmentNavigation>"
  syntax:
    content: protected virtual void OnFragmentNavigation (System.Windows.Navigation.FragmentNavigationEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.FragmentNavigationEventArgs
      description: "A <xref href=&quot;System.Windows.Navigation.FragmentNavigationEventArgs&quot;> </xref>包含事件数据。"
  overload: System.Windows.Application.OnFragmentNavigation*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)
  id: OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnLoadCompleted(NavigationEventArgs)
  nameWithType: Application.OnLoadCompleted(NavigationEventArgs)
  fullName: System.Windows.Application.OnLoadCompleted(NavigationEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "引发<xref href=&quot;System.Windows.Application.LoadCompleted&quot;></xref>事件。"
  remarks: "OnLoadCompleted 引发<xref:System.Windows.Application.LoadCompleted>事件。</xref:System.Windows.Application.LoadCompleted>       派生自类型<xref:System.Windows.Application>可能会重写 OnLoadCompleted。</xref:System.Windows.Application> 重写的方法必须调用 OnLoadCompleted 基类中如果<xref:System.Windows.Application.LoadCompleted>需要引发。</xref:System.Windows.Application.LoadCompleted>"
  syntax:
    content: protected virtual void OnLoadCompleted (System.Windows.Navigation.NavigationEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigationEventArgs
      description: "A <xref href=&quot;System.Windows.Navigation.NavigationEventArgs&quot;> </xref>包含事件数据。"
  overload: System.Windows.Application.OnLoadCompleted*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)
  id: OnNavigated(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnNavigated(NavigationEventArgs)
  nameWithType: Application.OnNavigated(NavigationEventArgs)
  fullName: System.Windows.Application.OnNavigated(NavigationEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "引发<xref href=&quot;System.Windows.Application.Navigated&quot;></xref>事件。"
  remarks: "OnNavigated 引发<xref:System.Windows.Application.Navigated>事件。</xref:System.Windows.Application.Navigated>       派生自类型<xref:System.Windows.Application>可能会重写 OnNavigated。</xref:System.Windows.Application> 重写的方法必须调用 OnNavigated 基类中如果<xref:System.Windows.Application.Navigated>需要引发。</xref:System.Windows.Application.Navigated>"
  syntax:
    content: protected virtual void OnNavigated (System.Windows.Navigation.NavigationEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigationEventArgs
      description: "A <xref href=&quot;System.Windows.Navigation.NavigationEventArgs&quot;> </xref>包含事件数据。"
  overload: System.Windows.Application.OnNavigated*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)
  id: OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnNavigating(NavigatingCancelEventArgs)
  nameWithType: Application.OnNavigating(NavigatingCancelEventArgs)
  fullName: System.Windows.Application.OnNavigating(NavigatingCancelEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "引发<xref href=&quot;System.Windows.Application.Navigating&quot;></xref>事件。"
  remarks: "OnNavigating 引发<xref:System.Windows.Application.Navigating>事件。</xref:System.Windows.Application.Navigating>       派生自类型<xref:System.Windows.Application>可能会重写 OnNavigating。</xref:System.Windows.Application> 重写的方法必须调用 OnNavigating 基类中如果<xref:System.Windows.Application.Navigating>需要引发。</xref:System.Windows.Application.Navigating>"
  syntax:
    content: protected virtual void OnNavigating (System.Windows.Navigation.NavigatingCancelEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigatingCancelEventArgs
      description: "A <xref href=&quot;System.Windows.Navigation.NavigatingCancelEventArgs&quot;> </xref>包含事件数据。"
  overload: System.Windows.Application.OnNavigating*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)
  id: OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnNavigationFailed(NavigationFailedEventArgs)
  nameWithType: Application.OnNavigationFailed(NavigationFailedEventArgs)
  fullName: System.Windows.Application.OnNavigationFailed(NavigationFailedEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "引发<xref href=&quot;System.Windows.Application.NavigationFailed&quot;></xref>事件。"
  remarks: "OnNavigationFailed 引发<xref:System.Windows.Application.NavigationFailed>事件。</xref:System.Windows.Application.NavigationFailed>       派生自类型<xref:System.Windows.Application>可能会重写 OnNavigationFailed。</xref:System.Windows.Application> 重写的方法必须调用 OnNavigationFailed 基类中如果<xref:System.Windows.Application.NavigationFailed>需要引发。</xref:System.Windows.Application.NavigationFailed>"
  example:
  - "<xref:System.Windows.Application.OnFragmentNavigation%2A>  \n  \n <xref:System.Windows.Application.OnLoadCompleted%2A>  \n  \n <xref:System.Windows.Application.OnNavigating%2A>  \n  \n <xref:System.Windows.Application.OnNavigated%2A>  \n  \n <xref:System.Windows.Application.OnNavigationProgress%2A>  \n  \n <xref:System.Windows.Application.OnNavigationStopped%2A>"
  syntax:
    content: protected virtual void OnNavigationFailed (System.Windows.Navigation.NavigationFailedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigationFailedEventArgs
      description: "A <xref href=&quot;System.Windows.Navigation.NavigationFailedEventArgs&quot;> </xref>包含事件数据。"
  overload: System.Windows.Application.OnNavigationFailed*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)
  id: OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnNavigationProgress(NavigationProgressEventArgs)
  nameWithType: Application.OnNavigationProgress(NavigationProgressEventArgs)
  fullName: System.Windows.Application.OnNavigationProgress(NavigationProgressEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "引发<xref href=&quot;System.Windows.Application.NavigationProgress&quot;></xref>事件。"
  remarks: "OnNavigationProgress 引发<xref:System.Windows.Application.NavigationProgress>事件。</xref:System.Windows.Application.NavigationProgress>       派生自类型<xref:System.Windows.Application>可能会重写 OnNavigationProgress。</xref:System.Windows.Application> 重写的方法必须显式调用 OnNavigationProgress 基类中如果<xref:System.Windows.Application.NavigationProgress>需要引发。</xref:System.Windows.Application.NavigationProgress>"
  syntax:
    content: protected virtual void OnNavigationProgress (System.Windows.Navigation.NavigationProgressEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigationProgressEventArgs
      description: "A <xref href=&quot;System.Windows.Navigation.NavigationProgressEventArgs&quot;> </xref>包含事件数据。"
  overload: System.Windows.Application.OnNavigationProgress*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)
  id: OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnNavigationStopped(NavigationEventArgs)
  nameWithType: Application.OnNavigationStopped(NavigationEventArgs)
  fullName: System.Windows.Application.OnNavigationStopped(NavigationEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "引发<xref href=&quot;System.Windows.Application.NavigationStopped&quot;></xref>事件。"
  remarks: "OnNavigationStopped 引发<xref:System.Windows.Application.NavigationStopped>事件。</xref:System.Windows.Application.NavigationStopped>       派生自类型<xref:System.Windows.Application>可能会重写 OnNavigationStopped。</xref:System.Windows.Application> 重写的方法必须调用 OnNavigationStopped 基类中如果<xref:System.Windows.Application.NavigationStopped>需要引发。</xref:System.Windows.Application.NavigationStopped>"
  syntax:
    content: protected virtual void OnNavigationStopped (System.Windows.Navigation.NavigationEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigationEventArgs
      description: "A <xref href=&quot;System.Windows.Navigation.NavigationEventArgs&quot;> </xref>包含事件数据。"
  overload: System.Windows.Application.OnNavigationStopped*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)
  id: OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnSessionEnding(SessionEndingCancelEventArgs)
  nameWithType: Application.OnSessionEnding(SessionEndingCancelEventArgs)
  fullName: System.Windows.Application.OnSessionEnding(SessionEndingCancelEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "引发<xref href=&quot;System.Windows.Application.SessionEnding&quot;></xref>事件。"
  remarks: "OnSessionEnding 引发<xref:System.Windows.Application.SessionEnding>事件。</xref:System.Windows.Application.SessionEnding>       派生自类型<xref:System.Windows.Application>可能会重写 OnSessionEnding。</xref:System.Windows.Application> 重写的方法必须调用 OnSessionEnding 基类中如果<xref:System.Windows.Application.SessionEnding>需要引发。</xref:System.Windows.Application.SessionEnding>"
  syntax:
    content: protected virtual void OnSessionEnding (System.Windows.SessionEndingCancelEventArgs e);
    parameters:
    - id: e
      type: System.Windows.SessionEndingCancelEventArgs
      description: "A <xref href=&quot;System.Windows.SessionEndingCancelEventArgs&quot;> </xref>包含事件数据。"
  overload: System.Windows.Application.OnSessionEnding*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)
  id: OnStartup(System.Windows.StartupEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnStartup(StartupEventArgs)
  nameWithType: Application.OnStartup(StartupEventArgs)
  fullName: System.Windows.Application.OnStartup(StartupEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "引发<xref href=&quot;System.Windows.Application.Startup&quot;></xref>事件。"
  remarks: "OnStartup 引发<xref:System.Windows.Application.Startup>事件。</xref:System.Windows.Application.Startup>       派生自类型<xref:System.Windows.Application>可能会重写 OnStartup。</xref:System.Windows.Application> 重写的方法必须调用 OnStartup 基类中如果<xref:System.Windows.Application.Startup>需要发出的事件。</xref:System.Windows.Application.Startup>"
  syntax:
    content: protected virtual void OnStartup (System.Windows.StartupEventArgs e);
    parameters:
    - id: e
      type: System.Windows.StartupEventArgs
      description: "A <xref href=&quot;System.Windows.StartupEventArgs&quot;> </xref>包含事件数据。"
  overload: System.Windows.Application.OnStartup*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Properties
  id: Properties
  parent: System.Windows.Application
  langs:
  - csharp
  name: Properties
  nameWithType: Application.Properties
  fullName: System.Windows.Application.Properties
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "获取应用程序作用域属性的集合。"
  remarks: "<xref:System.Windows.Application>显示通过属性可以用于存储应用程序作用域属性的字典。</xref:System.Windows.Application> 这使您可以共享状态中的所有代码<xref:System.AppDomain>以线程安全的方式，而无需编写你自己的状态代码。</xref:System.AppDomain>       存储在属性中的属性必须转换为适当的返回类型。       TheProperties 属性是线程安全的且都可从任何线程。"
  example:
  - "The following example shows how create and use an application-scope property using Properties.  \n  \n [!code-xml[ApplicationPropertiesSnippets#HandleStartupXAML](~/add/codesnippet/xaml/ApplicationPropertiesSnippets.CSharp/App.xaml#handlestartupxaml)]  \n  \n [!code-cs[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/add/codesnippet/csharp/ApplicationPropertiesSnippets.CSharp/App.xaml.cs#handlestartupcodebehind)]\n [!code-vb[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/add/codesnippet/visualbasic/applicationpropertiessnippets/application.xaml.vb#handlestartupcodebehind)]  \n  \n [!code-xml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML1](~/add/codesnippet/xaml/ApplicationPropertiesSnippets.CSharp/MainWindow.xaml#mainwindowgetpropertyxaml1)]  \n[!code-xml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML2](~/add/codesnippet/xaml/ApplicationPropertiesSnippets.CSharp/MainWindow.xaml#mainwindowgetpropertyxaml2)]  \n  \n [!code-cs[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/add/codesnippet/csharp/ApplicationPropertiesSnippets.CSharp/MainWindow.xaml.cs#mainwindowgetpropertycodebehind)]\n [!code-vb[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/add/codesnippet/visualbasic/applicationpropertiessnippets/mainwindow.xaml.vb#mainwindowgetpropertycodebehind)]"
  syntax:
    content: public System.Collections.IDictionary Properties { get; }
    return:
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>包含的应用程序作用域属性。</xref:System.Collections.IDictionary>"
  overload: System.Windows.Application.Properties*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.ResourceAssembly
  id: ResourceAssembly
  parent: System.Windows.Application
  langs:
  - csharp
  name: ResourceAssembly
  nameWithType: Application.ResourceAssembly
  fullName: System.Windows.Application.ResourceAssembly
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "获取或设置<xref:System.Reflection.Assembly>提供包[!INCLUDE[TLA#tla_uri#plural](~/add/includes/tlasharptla-urisharpplural-md.md)]中的资源[!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]应用程序。</xref:System.Reflection.Assembly>"
  remarks: "默认情况下，[!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]资源项程序集，从返回的值由标识相关的运行时进行解析<xref:System.Reflection.Assembly.GetEntryAssembly%2A>方法。</xref:System.Reflection.Assembly.GetEntryAssembly%2A>       入口程序集是通过返回的程序集<xref:System.Reflection.Assembly.GetEntryAssembly%2A>，并且可能以下:-默认应用程序域中的可执行程序集。</xref:System.Reflection.Assembly.GetEntryAssembly%2A>      的通过调用<xref:System.AppDomain.ExecuteAssembly%2A>.</xref:System.AppDomain.ExecuteAssembly%2A>要执行第一个程序集       在以下情况，但是，[!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]程序集无法获取项程序集的引用:-一个非托管 （本机） 应用程序主机[!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]程序集。      -A 托管应用程序主机[!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]通过加载到新应用程序域之外使用某种方法<xref:System.AppDomain.ExecuteAssembly%2A>.</xref:System.AppDomain.ExecuteAssembly%2A>的程序集       在这两种情况，<xref:System.Reflection.Assembly.GetEntryAssembly%2A>返回`null`，和[!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]无法解析程序集的资源。</xref:System.Reflection.Assembly.GetEntryAssembly%2A> 在这些情况下，ResourceAssembly 可以设置，一次仅具有对应该用于解析资源的程序集的引用。       ResourceAssembly 只能设置一次由于不可能的资源程序集将更改后[!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]则加载程序集。      1> [!NOTE]&1;> ResourceAssembly 不能设置时[!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]程序集可以发现入口程序集-即，当<xref:System.Reflection.Assembly.GetEntryAssembly%2A>返回对程序集的引用而非`null`。</xref:System.Reflection.Assembly.GetEntryAssembly%2A>       此属性是线程安全的可从任意线程。       ResourceAssembly 是.NET Framework 3.5 版中引入的。  有关详细信息，请参阅[版本和依赖关系](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public static System.Reflection.Assembly ResourceAssembly { get; set; }
    return:
      type: System.Reflection.Assembly
      description: "对引用<xref:System.Reflection.Assembly>提供包[!INCLUDE[TLA#tla_uri#plural](~/add/includes/tlasharptla-urisharpplural-md.md)]中的资源[!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]应用程序。</xref:System.Reflection.Assembly>"
  overload: System.Windows.Application.ResourceAssembly*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A[!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]应用程序都有一个条目程序集，或 ResourceAssembly 已设置。"
  platform:
  - net462
- uid: System.Windows.Application.Resources
  id: Resources
  parent: System.Windows.Application
  langs:
  - csharp
  name: Resources
  nameWithType: Application.Resources
  fullName: System.Windows.Application.Resources
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "获取或设置应用程序范围的资源，如样式和画笔的集合。"
  remarks: "资源属性可用于在 windows 和应用程序的元素之间共享资源。 此外，资源属性包含在资源查找路径中，按以下顺序遍历︰ 1。  2 的元素。  Windows 3。  资源 4。  系统因此，[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]可以将元素绑定到应用程序范围的资源。 此外，如果更改资源，资源系统可确保该元素属性绑定到这些资源会自动更新以反映更改。       应用程序范围的资源提供了一种简单的方法，可支持你的应用程序一致的主题。 你可以轻松创建中的主题[!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)]使用`Application.Resources`标记。 但是，如果你的应用程序支持多个主题，其中可能包含大量的主题元素，则可能是更轻松地管理它们使用一个<xref:System.Windows.ResourceDictionary>每个主题的实例。</xref:System.Windows.ResourceDictionary> 这种方式，可以通过将资源属性设置为适当的<xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>应用新的主题       有两个注意事项，以便使用资源时。 首先，字典*密钥*是一个对象，因此你需要使用完全相同的对象实例时设置和获取属性值 （请注意，使用字符串键时区分大小写）。 其次，字典*值*是一个对象，因此你将需要获取的属性值时，将的值转换为所需的类型。       资源是线程安全的且都可从任何线程。"
  example:
  - "This example illustrates how to use [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] together with application-scope resources to create a consistent visual appearance.  \n  \n [!code-xml[ApplicationResourcesSnippets#ResourcesPropertyXAML](~/add/codesnippet/xaml/ApplicationResourcesSnippets.XAML/App.xaml#resourcespropertyxaml)]  \n  \n [!code-xml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML1](~/add/codesnippet/xaml/ApplicationResourcesSnippets.XAML/MainWindow.xaml#windowbackgroundpropertyxaml1)]  \n[!code-xml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML2](~/add/codesnippet/xaml/ApplicationResourcesSnippets.XAML/MainWindow.xaml#windowbackgroundpropertyxaml2)]  \n  \n The following example shows how to set an application resource in code and XAML.  \n  \n [!code-vb[HOWTOApplicationModelSnippets#SetApplicationScopeResourceCODE](~/add/codesnippet/visualbasic/howtoapplicationmodelsnippets/applicationpropertiessnippet.xaml.vb#setapplicationscoperesourcecode)]\n [!code-cs[HOWTOApplicationModelSnippets#SetApplicationScopeResourceCODE](~/add/codesnippet/csharp/HOWTOApplicationModelSnippets/ApplicationPropertiesSnippet.xaml.cs#setapplicationscoperesourcecode)]  \n  \n [!code-xml[HOWTOApplicationModelSnippets#SetApplicationScopeResourceXAML](~/add/codesnippet/xaml/HOWTOApplicationModelSnippets/App.xaml#setapplicationscoperesourcexaml)]  \n  \n The following example shows how to get an application resource in code.  \n  \n [!code-vb[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/add/codesnippet/visualbasic/howtoapplicationmodelsnippets/applicationpropertiessnippet.xaml.vb#getapplicationscoperesourcecode)]\n [!code-cs[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/add/codesnippet/csharp/HOWTOApplicationModelSnippets/ApplicationPropertiesSnippet.xaml.cs#getapplicationscoperesourcecode)]"
  syntax:
    content: public System.Windows.ResourceDictionary Resources { get; set; }
    return:
      type: System.Windows.ResourceDictionary
      description: "A <xref href=&quot;System.Windows.ResourceDictionary&quot;> </xref>对象，其中包含零个或多个应用程序范围的资源。"
  overload: System.Windows.Application.Resources*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Run
  id: Run
  parent: System.Windows.Application
  langs:
  - csharp
  name: Run()
  nameWithType: Application.Run()
  fullName: System.Windows.Application.Run()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "启动[!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)]应用程序。"
  remarks: "<xref:System.Windows.Application.Run%2A>调用以启动[!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]应用程序。</xref:System.Windows.Application.Run%2A> 如果你定义你<xref:System.Windows.Application>使用标记，或标记和代码隐藏<xref:System.Windows.Application.Run%2A>将隐式调用。</xref:System.Windows.Application.Run%2A> </xref:System.Windows.Application> 但是，如果你定义<xref:System.Windows.Application>使用的代码中，你将需要显式调用<xref:System.Windows.Application.Run%2A>.</xref:System.Windows.Application.Run%2A></xref:System.Windows.Application>你       当<xref:System.Windows.Application.Run%2A>调用时，<xref:System.Windows.Application>将附加新<xref:System.Windows.Threading.Dispatcher>到实例[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]线程。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Application> </xref:System.Windows.Application.Run%2A> 接下来，<xref:System.Windows.Threading.Dispatcher>对象的<xref:System.Windows.Threading.Dispatcher.Run%2A>调用方法，以启动处理 windows 消息的消息泵。</xref:System.Windows.Threading.Dispatcher.Run%2A> </xref:System.Windows.Threading.Dispatcher> 最后，<xref:System.Windows.Threading.Dispatcher>对象调用<xref:System.Windows.Application>对象的<xref:System.Windows.Application.OnStartup%2A>方法来引发<xref:System.Windows.Application.Startup>事件。</xref:System.Windows.Application.Startup> </xref:System.Windows.Application.OnStartup%2A> </xref:System.Windows.Application> </xref:System.Windows.Threading.Dispatcher> 因此，你处理时建立的应用程序执行模型<xref:System.Windows.Application.Startup>，此时视为应用程序是否正在运行。</xref:System.Windows.Application.Startup>       应用程序停止运行时<xref:System.Windows.Application.Shutdown%2A>称为; 的值<xref:System.Windows.Application.ShutdownMode%2A>属性确定何时<xref:System.Windows.Application.Shutdown%2A>被调用，并且是自动还是需要显式调用它。</xref:System.Windows.Application.Shutdown%2A> </xref:System.Windows.Application.ShutdownMode%2A> </xref:System.Windows.Application.Shutdown%2A>       <xref:System.Windows.Application.Run%2A>可以仅从创建的线程调用<xref:System.Windows.Application>对象。</xref:System.Windows.Application></xref:System.Windows.Application.Run%2A> 此外，<xref:System.Windows.Application.Run%2A>不能从调用[!INCLUDE[TLA2#tla_xbap](~/add/includes/ajax-current-ext-md.md)]。</xref:System.Windows.Application.Run%2A>"
  example:
  - "The following example shows an application that uses a custom <xref:System.Windows.Application> and must therefore explicitly call <xref:System.Windows.Application.Run%2A>.  \n  \n [!code-vb[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/add/codesnippet/visualbasic/applicationrunsnippets/app.vb#customentrypointandruncode)]\n [!code-cs[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/add/codesnippet/csharp/ApplicationRunSnippets.CSharp/App.cs#customentrypointandruncode)]"
  syntax:
    content: public int Run ();
    parameters: []
    return:
      type: System.Int32
      description: "<xref:System.Int32>应用程序关闭时返回到操作系统的应用程序退出代码。</xref:System.Int32> 默认情况下，退出代码值为 0。"
  overload: System.Windows.Application.Run*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "从浏览器承载的应用程序调用运行 (例如， [!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)])。"
  platform:
  - net462
- uid: System.Windows.Application.Run(System.Windows.Window)
  id: Run(System.Windows.Window)
  parent: System.Windows.Application
  langs:
  - csharp
  name: Run(Window)
  nameWithType: Application.Run(Window)
  fullName: System.Windows.Application.Run(Window)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "启动[!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)]应用程序中，打开指定的窗口。"
  remarks: "此重载扩展<xref:System.Windows.Application.Run%2A>方法以在应用程序开始运行后打开指定的窗口。</xref:System.Windows.Application.Run%2A>       如果您定义代码<xref:System.Windows.Application>，这将打开一个窗口，在它开始运行时，显式调用 Run。</xref:System.Windows.Application>       如果你创建你<xref:System.Windows.Application>使用标记，或标记和代码隐藏，您可以自动打开一个窗口在过程中使用以下方法之一:-以声明方式，通过设置<xref:System.Windows.Application.StartupUri%2A>.</xref:System.Windows.Application.StartupUri%2A> </xref:System.Windows.Application>      -以编程方式处理<xref:System.Windows.Application.Startup>.</xref:System.Windows.Application.Startup>"
  example:
  - "The following example shows an application with a manually-created static entry point method that instantiates <xref:System.Windows.Application>, before calling <xref:System.Windows.Application.Run%2A>.  \n  \n [!code-cs[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/add/codesnippet/csharp/ApplicationRunOL1Snippets.CSharp/App.cs#customentrypointandrunol1code)]\n [!code-vb[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/add/codesnippet/visualbasic/applicationrunol1snippets/app.vb#customentrypointandrunol1code)]"
  syntax:
    content: public int Run (System.Windows.Window window);
    parameters:
    - id: window
      type: System.Windows.Window
      description: "A <xref href=&quot;System.Windows.Window&quot;> </xref> ，这将打开自动应用程序启动时。"
    return:
      type: System.Int32
      description: "<xref:System.Int32>应用程序关闭时返回到操作系统的应用程序退出代码。</xref:System.Int32> 默认情况下，退出代码值为 0。"
  overload: System.Windows.Application.Run*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref:System.Windows.Application.Run*>从浏览器承载的应用程序调用 (例如， [!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)])。</xref:System.Windows.Application.Run*>"
  platform:
  - net462
- uid: System.Windows.Application.SessionEnding
  id: SessionEnding
  parent: System.Windows.Application
  langs:
  - csharp
  name: SessionEnding
  nameWithType: Application.SessionEnding
  fullName: System.Windows.Application.SessionEnding
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "用户结束时发生[!INCLUDE[TLA#tla_mswin](~/add/includes/tlasharptla-mswin-md.md)]通过注销或关闭操作系统的会话。"
  remarks: "默认情况下，应用程序关闭时[!INCLUDE[TLA#tla_mswin](~/add/includes/tlasharptla-mswin-md.md)]会话结束时，发生在用户注销或关机。 在此情况下，[!INCLUDE[TLA2#tla_mswin](~/add/includes/tla2sharptla-mswin-md.md)]要求每个打开的应用程序关闭。 但是，它是应用程序可能不会准备好发生此情况时关闭。 例如，应用程序可能拥有是处于不一致状态，或中间长时间运行操作的数据。 在这些情况下，它可能需要阻止会话结束，并可能更需要允许用户决定让结束会话的选项。       你可以检测通过处理 SessionEnding 事件会话结束时。 如果应用程序需要阻止会话结束，<xref:System.Windows.SessionEndingCancelEventArgs>传递给事件处理程序自变量公开<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>，设置为`true`(默认值是`false`)。</xref:System.ComponentModel.CancelEventArgs.Cancel%2A> </xref:System.Windows.SessionEndingCancelEventArgs>       如果 SessionEnding 未经处理，或不被取消的情况下处理<xref:System.Windows.Application.Shutdown%2A>称为和<xref:System.Windows.Application.Exit>引发事件。</xref:System.Windows.Application.Exit> </xref:System.Windows.Application.Shutdown%2A>       若要获取有关为什么结束会话的详细信息，应用程序可以检查<xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A>，即之一<xref:System.Windows.ReasonSessionEnding>值 (<xref:System.Windows.ReasonSessionEnding>和<xref:System.Windows.ReasonSessionEnding>)。</xref:System.Windows.ReasonSessionEnding> </xref:System.Windows.ReasonSessionEnding> </xref:System.Windows.ReasonSessionEnding> </xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A>       SessionEnding 则不会引发由控制台应用程序。       仅在创建的线程上引发 SessionEnding<xref:System.Windows.Application>对象。</xref:System.Windows.Application>       不会引发 SessionEnding [!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)]。"
  example:
  - "The following example demonstrates how to handle the SessionEnding event and allow the user to cancel it.  \n  \n [!code-xml[ApplicationSessionEndingSnippets#HandlingSessionEndingXAML](~/add/codesnippet/xaml/ApplicationSessionEndingSnippets.CSharp/App.xaml#handlingsessionendingxaml)]  \n  \n [!code-vb[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/add/codesnippet/visualbasic/applicationsessionendingsnippets/application.xaml.vb#handlingsessionendingcodebehind)]\n [!code-cs[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/add/codesnippet/csharp/ApplicationSessionEndingSnippets.CSharp/App.xaml.cs#handlingsessionendingcodebehind)]"
  syntax:
    content: public event System.Windows.SessionEndingCancelEventHandler SessionEnding;
    return:
      type: System.Windows.SessionEndingCancelEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.SetCookie(System.Uri,System.String)
  id: SetCookie(System.Uri,System.String)
  parent: System.Windows.Application
  langs:
  - csharp
  name: SetCookie(Uri,String)
  nameWithType: Application.SetCookie(Uri,String)
  fullName: System.Windows.Application.SetCookie(Uri,String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "创建位置指定的一种<xref:System.Uri>。</xref:System.Uri> cookie"
  remarks: "Cookie 是任意的应用程序客户端计算机上应用程序的会话 (会话 cookie) 期间或跨应用程序会话 (永久 cookie) 可以存储的数据。 可以通过调用 SetCookie 创建两种类型的 cookie。       Cookie 数据通常采用以下格式的名称/值对的形式︰`Name=Value`连同的这种格式的字符串传递给 SetCookie，<xref:System.Uri>应为其设置 cookie 的位置 （通常情况下，应用程序域）。</xref:System.Uri>       Cookie 是会话 cookie 或持久性 cookie 取决于传递给 SetCookie cookie 字符串是否包含一个到期日期。 会话 cookie 的字符串不包括一个到期日期。 持久性 cookie 的字符串存在，并且必须采用以下格式︰`NAME=VALUE; expires=DAY, DD-MMM-YYYY HH:MM:SS GMT`永久 cookie 存储在当前[!INCLUDE[TLA#tla_mswin](~/add/includes/tlasharptla-mswin-md.md)]到期，在这种情况下删除它们之前安装的 Internet 临时文件文件夹。 通过将其到期日期设置为在过去的日期/时间值，可以从你的应用程序删除持久性 cookie。       有关概述中的 cookie [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]，请参阅[导航概述](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public static void SetCookie (Uri uri, string value);
    parameters:
    - id: uri
      type: System.Uri
      description: "<xref:System.Uri>，它指定应为其创建 cookie 的位置。</xref:System.Uri>"
    - id: value
      type: System.String
      description: "<xref:System.String>包含 cookie 数据。</xref:System.String>"
  overload: System.Windows.Application.SetCookie*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "A[!INCLUDE[TLA#tla_win32](~/add/includes/tlasharptla-win32-md.md)]错误由<xref uid=&quot;langword_csharp_InternetSetCookie&quot; name=&quot;InternetSetCookie&quot; href=&quot;&quot;></xref>函数 （由 SetCookie） 如果尝试创建指定的 cookie 时出现问题。"
  platform:
  - net462
- uid: System.Windows.Application.Shutdown
  id: Shutdown
  parent: System.Windows.Application
  langs:
  - csharp
  name: Shutdown()
  nameWithType: Application.Shutdown()
  fullName: System.Windows.Application.Shutdown()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "关闭应用程序。"
  remarks: "当调用关闭时，应用程序停止运行。 你可以处理<xref:System.Windows.Application.Exit>事件来检测应用程序时将要停止运行，以执行任何适当的处理。</xref:System.Windows.Application.Exit>       隐式调用关闭[!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)]在以下情况:-当<xref:System.Windows.Application.ShutdownMode%2A>设置为<xref:System.Windows.ShutdownMode>。</xref:System.Windows.ShutdownMode> </xref:System.Windows.Application.ShutdownMode%2A>      -当<xref:System.Windows.Application.ShutdownMode%2A>设置为<xref:System.Windows.ShutdownMode>。</xref:System.Windows.ShutdownMode> </xref:System.Windows.Application.ShutdownMode%2A>      -当用户结束会话和<xref:System.Windows.Application.SessionEnding>未处理时，或处理而无需取消事件。</xref:System.Windows.Application.SessionEnding>       显式调用关闭会导致应用程序才可关闭，而不考虑<xref:System.Windows.Application.ShutdownMode%2A>设置。</xref:System.Windows.Application.ShutdownMode%2A> 但是，如果<xref:System.Windows.Application.ShutdownMode%2A>设置为<xref:System.Windows.ShutdownMode>，必须调用关闭以关闭应用程序。</xref:System.Windows.ShutdownMode> </xref:System.Windows.Application.ShutdownMode%2A>      1> [!IMPORTANT]&1;> 被调用时关闭时，应用程序将关闭而不考虑是否<xref:System.Windows.Window.Closing>取消事件的任何打开的窗口。</xref:System.Windows.Window.Closing>       此方法可以仅从创建的线程调用<xref:System.Windows.Application>对象。</xref:System.Windows.Application>"
  syntax:
    content: public void Shutdown ();
    parameters: []
  overload: System.Windows.Application.Shutdown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Shutdown(System.Int32)
  id: Shutdown(System.Int32)
  parent: System.Windows.Application
  langs:
  - csharp
  name: Shutdown(Int32)
  nameWithType: Application.Shutdown(Int32)
  fullName: System.Windows.Application.Shutdown(Int32)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "关闭的应用程序将指定的退出代码返回到操作系统。"
  remarks: "你可以处理<xref:System.Windows.Application.Exit>事件设置退出代码。</xref:System.Windows.Application.Exit> 但是，如果你明确地调用<xref:System.Windows.Application.Shutdown%2A>，并且你处理<xref:System.Windows.Application.Exit>仅若要设置退出代码，可以改为调用关闭。</xref:System.Windows.Application.Exit> </xref:System.Windows.Application.Shutdown%2A>       此方法可以仅从创建的线程调用<xref:System.Windows.Application>对象。</xref:System.Windows.Application>"
  syntax:
    content: public void Shutdown (int exitCode);
    parameters:
    - id: exitCode
      type: System.Int32
      description: "整数退出应用程序代码。 默认的退出代码为 0。"
  overload: System.Windows.Application.Shutdown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.ShutdownMode
  id: ShutdownMode
  parent: System.Windows.Application
  langs:
  - csharp
  name: ShutdownMode
  nameWithType: Application.ShutdownMode
  fullName: System.Windows.Application.ShutdownMode
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "获取或设置导致的条件<xref:System.Windows.Application.Shutdown*>要调用方法。</xref:System.Windows.Application.Shutdown*>"
  remarks: "应用程序停止运行时，才<xref:System.Windows.Application.Shutdown%2A>调用应用程序的方法。</xref:System.Windows.Application.Shutdown%2A> 关闭可以进行隐式或显式指定的 ShutdownMode 属性的值。       如果 ShutdownMode 设置为<xref:System.Windows.ShutdownMode>，[!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)]隐式调用<xref:System.Windows.Application.Shutdown%2A>应用程序中的最后一个窗口关闭时，即使任何当前已实例化的 windows 设置作为主窗口 (请参阅<xref:System.Windows.Application.MainWindow%2A>)。</xref:System.Windows.Application.MainWindow%2A> </xref:System.Windows.Application.Shutdown%2A> </xref:System.Windows.ShutdownMode>       ShutdownMode<xref:System.Windows.ShutdownMode>导致[!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)]隐式调用<xref:System.Windows.Application.Shutdown%2A>时<xref:System.Windows.Application.MainWindow%2A>关闭，即使其他窗口处于当前打开。</xref:System.Windows.Application.MainWindow%2A> </xref:System.Windows.Application.Shutdown%2A> </xref:System.Windows.ShutdownMode>       某些应用程序的生存期可能不是依赖于主窗口或最后一个窗口已关闭，或可能根本不依赖于 windows 的时。 你需要为这些方案将 ShutdownMode 属性设置为<xref:System.Windows.ShutdownMode>，这需要显式<xref:System.Windows.Application.Shutdown%2A>方法调用停止应用程序。</xref:System.Windows.Application.Shutdown%2A> </xref:System.Windows.ShutdownMode> 否则，应用程序将继续在后台运行。       可以从以声明方式配置 ShutdownMode[!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)]或以编程方式从代码。       此属性则仅可从创建的线程<xref:System.Windows.Application>对象。</xref:System.Windows.Application>"
  example:
  - "The following example shows how to configure ShutdownMode to specify that an application must be closed explicitly.  \n  \n [!code-xml[ApplicationShutdownModeSnippets#SetShutdownModeXAML](~/add/codesnippet/xaml/ApplicationShutdownModeSnippets.XAML/App.xaml#setshutdownmodexaml)]"
  syntax:
    content: public System.Windows.ShutdownMode ShutdownMode { get; set; }
    return:
      type: System.Windows.ShutdownMode
      description: "A <xref href=&quot;System.Windows.ShutdownMode&quot;> </xref>枚举值。 默认值是<xref href=&quot;System.Windows.ShutdownMode&quot;> </xref>。"
  overload: System.Windows.Application.ShutdownMode*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Startup
  id: Startup
  parent: System.Windows.Application
  langs:
  - csharp
  name: Startup
  nameWithType: Application.Startup
  fullName: System.Windows.Application.Startup
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "发生时<xref:System.Windows.Application.Run*>方法<xref href=&quot;System.Windows.Application&quot;></xref>对象称为。</xref:System.Windows.Application.Run*>"
  remarks: "典型[!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)]应用程序可能会执行的各种初始化任务，它在启动时，包括:-处理命令行参数。      --打开主窗口。      初始化应用程序范围的资源。      初始化应用程序作用域属性。       你可以以声明方式指定的主窗口和使用的应用程序作用域资源[!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)](<xref:System.Windows.Application.StartupUri%2A>和<xref:System.Windows.Application.Resources%2A>分别)。</xref:System.Windows.Application.Resources%2A> </xref:System.Windows.Application.StartupUri%2A> 有时，但是，资源或应用程序的主窗口可以仅将以编程方式在运行时确定。 此外，应用程序作用域属性和命令行参数只能以编程方式。 可以通过处理启动事件，其中包括执行以编程方式初始化:-获取并处理命令行参数，它们是可从<xref:System.Windows.StartupEventArgs.Args%2A>属性<xref:System.Windows.StartupEventArgs>传递给启动事件处理程序的类。</xref:System.Windows.StartupEventArgs> </xref:System.Windows.StartupEventArgs.Args%2A>      -通过使用初始化应用程序范围的资源<xref:System.Windows.Application.Resources%2A>属性。</xref:System.Windows.Application.Resources%2A>      -通过使用初始化应用程序作用域属性<xref:System.Windows.Application.Properties%2A>属性。</xref:System.Windows.Application.Properties%2A>      的实例化并显示一个 （或多个） 窗口。      1> [!NOTE]&1;> 命令行参数还可获取通过调用静态<xref:System.Environment.GetCommandLineArgs%2A>方法<xref:System.Environment>对象。</xref:System.Environment> </xref:System.Environment.GetCommandLineArgs%2A> 但是，<xref:System.Environment.GetCommandLineArgs%2A>需要完全信任才能执行。</xref:System.Environment.GetCommandLineArgs%2A>       如果你设置<xref:System.Windows.Application.StartupUri%2A>使用[!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)]，创建主窗口不可用从<xref:System.Windows.Application.MainWindow%2A>属性或<xref:System.Windows.Application.Windows%2A>属性<xref:System.Windows.Application>处理启动事件后，直到对象。</xref:System.Windows.Application> </xref:System.Windows.Application.Windows%2A> </xref:System.Windows.Application.MainWindow%2A> </xref:System.Windows.Application.StartupUri%2A> 如果在启动期间需要向主窗口的访问，你需要手动启动事件处理程序创建新的窗口对象。      1> [!NOTE]&1;> 如果你的应用程序使用<xref:System.Net.AuthenticationManager.CredentialPolicy%2A>若要指定凭据策略，你需要设置<xref:System.Net.AuthenticationManager.CredentialPolicy%2A>启动引发; 否则为后[!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]将其设置为默认内部策略直接后引发启动事件。</xref:System.Net.AuthenticationManager.CredentialPolicy%2A> </xref:System.Net.AuthenticationManager.CredentialPolicy%2A>       传递给启动事件处理程序的命令行自变量不是相同[!INCLUDE[TLA#tla_url](~/add/includes/tlasharptla-url-md.md)]查询字符串参数传递给[!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)]。"
  example:
  - "The following example shows how to acquire and process command-line options from a standalone application. If the **/StartMinimized** command-line parameter was provided, the application opens the main window in a minimized state.  \n  \n [!code-xml[ApplicationStartupSnippets#HandleStartupXAML](~/add/codesnippet/xaml/ApplicationStartupSnippets.CSharp/App.xaml#handlestartupxaml)]  \n  \n [!code-cs[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/add/codesnippet/csharp/ApplicationStartupSnippets.CSharp/App.xaml.cs#handlestartupcodebehind)]\n [!code-vb[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/add/codesnippet/visualbasic/applicationstartupsnippets/application.xaml.vb#handlestartupcodebehind)]  \n  \n [!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)] cannot retrieve and process command-line arguments because they are launched with [!INCLUDE[TLA#tla_clickonce](~/add/includes/tlasharptla-clickonce-md.md)] deployment (see [Deploying a WPF Application (WPF)](~/add/includes/ajax-current-ext-md.md)). However, they can retrieve and process query string parameters from the URLs that are used to launch them."
  syntax:
    content: public event System.Windows.StartupEventHandler Startup;
    return:
      type: System.Windows.StartupEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.StartupUri
  id: StartupUri
  parent: System.Windows.Application
  langs:
  - csharp
  name: StartupUri
  nameWithType: Application.StartupUri
  fullName: System.Windows.Application.StartupUri
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "获取或设置[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]应用程序启动时自动显示。"
  remarks: "你可以使用 StartupUri 自动加载[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]资源应用程序启动时。       下表显示类型的[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]可以加载的资源，到打开的窗口的类型，这些资源可以设置为 StartupUri 的应用程序的类型。      |类型 |窗口 |应用程序类型 |  |----------|------------|----------------------|  |<xref:System.Windows.Window>|<xref:System.Windows.Window>|仅独立应用程序 |  |<xref:System.Windows.Navigation.NavigationWindow>|<xref:System.Windows.Navigation.NavigationWindow>|仅独立应用程序 |  |<xref:System.Windows.Controls.Page>|<xref:System.Windows.Navigation.NavigationWindow>|独立/浏览器承载 |  |<xref:System.Windows.Controls.UserControl>|<xref:System.Windows.Navigation.NavigationWindow>|独立/浏览器承载 |  |<xref:System.Windows.Documents.FlowDocument>|<xref:System.Windows.Navigation.NavigationWindow>|独立/浏览器承载 |  |<xref:System.Windows.Navigation.PageFunction%601>|<xref:System.Windows.Navigation.NavigationWindow>|独立/浏览器承载 |      通常情况下，设置 StartupUri 属性以声明方式在[!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)]。</xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Navigation.PageFunction%601> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Documents.FlowDocument> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Controls.UserControl> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Controls.Page> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Window> </xref:System.Windows.Window> 但是，可以以编程方式设置 StartupUri 如从<xref:System.Windows.Application.Startup>事件处理程序，如果对于只能加载所需的应用程序有用[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]在运行时的资源。</xref:System.Windows.Application.Startup> 例如，应用程序可能会等待，直到运行时才加载其资源，如果名称[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]资源存储在配置文件中。       是否以声明方式设置 StartupUri 或以编程方式，相应[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]资源不会加载直到后<xref:System.Windows.Application.Startup>处理事件。</xref:System.Windows.Application.Startup> 因此，你将无权访问生成的窗口从<xref:System.Windows.Application.Windows%2A>属性或<xref:System.Windows.Application.MainWindow%2A>属性时处理<xref:System.Windows.Application.Startup>.</xref:System.Windows.Application.Startup> </xref:System.Windows.Application.MainWindow%2A> </xref:System.Windows.Application.Windows%2A>"
  syntax:
    content: public Uri StartupUri { get; set; }
    return:
      type: System.Uri
      description: "A <xref:System.Uri>，是指[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]，这会自动将打开应用程序启动时。</xref:System.Uri>"
  overload: System.Windows.Application.StartupUri*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "StartupUri 设置的值为 null。"
  platform:
  - net462
- uid: System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  id: System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  isEii: true
  parent: System.Windows.Application
  langs:
  - csharp
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: Application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.Application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "为当前作用域中指定的环境属性是否可用的查询。"
  remarks: "此成员是显式接口成员的实现。 可以使用它时，才<xref:System.Windows.Application>实例被强制转换为<xref:System.Windows.Markup.IQueryAmbient>接口。</xref:System.Windows.Markup.IQueryAmbient> </xref:System.Windows.Application>"
  syntax:
    content: bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);
    parameters:
    - id: propertyName
      type: System.String
      description: "请求的环境属性的名称。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果可用; 请求的环境属性否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.TryFindResource(System.Object)
  id: TryFindResource(System.Object)
  parent: System.Windows.Application
  langs:
  - csharp
  name: TryFindResource(Object)
  nameWithType: Application.TryFindResource(Object)
  fullName: System.Windows.Application.TryFindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "搜索指定的资源。"
  remarks: "TryFindResource 将首先在应用程序范围内指定资源的资源中查找。 应用程序范围的资源由<xref:System.Windows.Application>，和从公开<xref:System.Windows.Application.Resources%2A>属性。</xref:System.Windows.Application.Resources%2A> </xref:System.Windows.Application> 如果应用程序范围的资源组中未找到指定的资源，TryFindResource 下一步搜索系统资源。 系统资源是由用户定义的命令行程序资源，包括颜色、 字体和外壳程序配置。 这些来自<xref:System.Windows.SystemColors>， <xref:System.Windows.SystemFonts>，和<xref:System.Windows.SystemParameters>分别为静态属性类型。</xref:System.Windows.SystemParameters> </xref:System.Windows.SystemFonts> </xref:System.Windows.SystemColors> 若要使用 TryFindResource 获取它们，这些类型还公开旨在传递给 TryFindResource; 的资源键属性例如， <xref:System.Windows.SystemParameters.IconWidthKey%2A>.</xref:System.Windows.SystemParameters.IconWidthKey%2A>       因为 TryFindResource 返回一个对象，您必须强制转换为适当的类型的返回的值，如果找到资源。       此方法是线程安全的可以从任何线程调用。"
  example:
  - "The following example shows how to use TryFindResource to acquire a resource.  \n  \n [!code-xml[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceXAML](~/add/codesnippet/xaml/ApplicationTryFindResourceSnippets/App.xaml#applicationcalltryfindresourcexaml)]  \n  \n [!code-cs[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/add/codesnippet/csharp/ApplicationTryFindResourceSnippets/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind1)]\n [!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/add/codesnippet/visualbasic/applicationtryfindresourcesnippets/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind1)]  \n[!code-cs[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/add/codesnippet/csharp/ApplicationTryFindResourceSnippets/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind2)]\n[!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/add/codesnippet/visualbasic/applicationtryfindresourcesnippets/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind2)]"
  syntax:
    content: public object TryFindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "要查找的资源的名称。"
    return:
      type: System.Object
      description: "所请求的资源对象。 如果未找到请求的资源，则返回空引用。"
  overload: System.Windows.Application.TryFindResource*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Windows
  id: Windows
  parent: System.Windows.Application
  langs:
  - csharp
  name: Windows
  nameWithType: Application.Windows
  fullName: System.Windows.Application.Windows
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "获取应用程序中实例化的窗口。"
  remarks: "A<xref:System.Windows.Window>引用会自动添加到 Windows 上实例化一个窗口时，就会立即[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]线程; 创建辅助线程的线程不会添加的 windows。</xref:System.Windows.Window> A<xref:System.Windows.Window>后自动删除引用其<xref:System.Windows.Window.Closing>处理事件和之前其<xref:System.Windows.Window.Closed>引发事件。</xref:System.Windows.Window.Closed> </xref:System.Windows.Window.Closing> </xref:System.Windows.Window>       默认情况下，添加到 Windows 属性的第一项将成为<xref:System.Windows.Application.MainWindow%2A>.</xref:System.Windows.Application.MainWindow%2A>       此属性则仅可从创建的线程<xref:System.Windows.Application>对象。</xref:System.Windows.Application>"
  example:
  - "The following example demonstrates how to enumerate the Windows property to build a top-level Windows menu, which is common to [!INCLUDE[TLA#tla_mdi](~/add/includes/tlasharptla-mdi-md.md)] applications like [!INCLUDE[TLA#tla_xl](~/add/includes/tlasharptla-xl-md.md)], or multiple-instance Single Document Interface (SDI) applications like [!INCLUDE[TLA#tla_word](~/add/includes/tlasharptla-word-md.md)].  \n  \n [!code-vb[ApplicationWindowsSnippets#WindowMenuItemCODE](~/add/codesnippet/visualbasic/applicationwindowssnippets/windowmenuitem.vb#windowmenuitemcode)]\n [!code-cs[ApplicationWindowsSnippets#WindowMenuItemCODE](~/add/codesnippet/csharp/ApplicationWindowsSnippets.CSharp/WindowMenuItem.cs#windowmenuitemcode)]  \n  \n [!code-xml[ApplicationWindowsSnippets#MainWindowSetWindowsXAML](~/add/codesnippet/xaml/ApplicationWindowsSnippets.CSharp/MainWindow.xaml#mainwindowsetwindowsxaml)]  \n  \n [!code-cs[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/add/codesnippet/csharp/ApplicationWindowsSnippets.CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind1)]\n [!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/add/codesnippet/visualbasic/applicationwindowssnippets/mainwindow.xaml.vb#mainwindowsetwindowscodebehind1)]  \n[!code-cs[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/add/codesnippet/csharp/ApplicationWindowsSnippets.CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind2)]\n[!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/add/codesnippet/visualbasic/applicationwindowssnippets/mainwindow.xaml.vb#mainwindowsetwindowscodebehind2)]"
  syntax:
    content: public System.Windows.WindowCollection Windows { get; }
    return:
      type: System.Windows.WindowCollection
      description: "A <xref href=&quot;System.Windows.WindowCollection&quot;> </xref> ，其中包含在当前的所有窗口对象的引用<xref href=&quot;System.AppDomain&quot;> </xref>。"
  overload: System.Windows.Application.Windows*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.Threading.DispatcherObject
  isExternal: false
  name: System.Windows.Threading.DispatcherObject
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Windows.ResourceReferenceKeyNotFoundException
  parent: System.Windows
  isExternal: false
  name: ResourceReferenceKeyNotFoundException
  nameWithType: ResourceReferenceKeyNotFoundException
  fullName: System.Windows.ResourceReferenceKeyNotFoundException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ComponentModel.Win32Exception
  parent: System.ComponentModel
  isExternal: false
  name: Win32Exception
  nameWithType: Win32Exception
  fullName: System.ComponentModel.Win32Exception
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.Exception
  isExternal: true
  name: System.Exception
- uid: System.Windows.Application.#ctor
  parent: System.Windows.Application
  isExternal: false
  name: Application()
  nameWithType: Application.Application()
  fullName: System.Windows.Application.Application()
- uid: System.Windows.Application.Activated
  parent: System.Windows.Application
  isExternal: false
  name: Activated
  nameWithType: Application.Activated
  fullName: System.Windows.Application.Activated
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Windows.Application.Current
  parent: System.Windows.Application
  isExternal: false
  name: Current
  nameWithType: Application.Current
  fullName: System.Windows.Application.Current
- uid: System.Windows.Application
  parent: System.Windows
  isExternal: false
  name: Application
  nameWithType: Application
  fullName: System.Windows.Application
- uid: System.Windows.Application.Deactivated
  parent: System.Windows.Application
  isExternal: false
  name: Deactivated
  nameWithType: Application.Deactivated
  fullName: System.Windows.Application.Deactivated
- uid: System.Windows.Application.DispatcherUnhandledException
  parent: System.Windows.Application
  isExternal: false
  name: DispatcherUnhandledException
  nameWithType: Application.DispatcherUnhandledException
  fullName: System.Windows.Application.DispatcherUnhandledException
- uid: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherUnhandledExceptionEventHandler
  nameWithType: DispatcherUnhandledExceptionEventHandler
  fullName: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
- uid: System.Windows.Application.Exit
  parent: System.Windows.Application
  isExternal: false
  name: Exit
  nameWithType: Application.Exit
  fullName: System.Windows.Application.Exit
- uid: System.Windows.ExitEventHandler
  parent: System.Windows
  isExternal: false
  name: ExitEventHandler
  nameWithType: ExitEventHandler
  fullName: System.Windows.ExitEventHandler
- uid: System.Windows.Application.FindResource(System.Object)
  parent: System.Windows.Application
  isExternal: false
  name: FindResource(Object)
  nameWithType: Application.FindResource(Object)
  fullName: System.Windows.Application.FindResource(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.Application.FragmentNavigation
  parent: System.Windows.Application
  isExternal: false
  name: FragmentNavigation
  nameWithType: Application.FragmentNavigation
  fullName: System.Windows.Application.FragmentNavigation
- uid: System.Windows.Navigation.FragmentNavigationEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: FragmentNavigationEventHandler
  nameWithType: FragmentNavigationEventHandler
  fullName: System.Windows.Navigation.FragmentNavigationEventHandler
- uid: System.Windows.Application.GetContentStream(System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: GetContentStream(Uri)
  nameWithType: Application.GetContentStream(Uri)
  fullName: System.Windows.Application.GetContentStream(Uri)
- uid: System.Windows.Resources.StreamResourceInfo
  parent: System.Windows.Resources
  isExternal: false
  name: StreamResourceInfo
  nameWithType: StreamResourceInfo
  fullName: System.Windows.Resources.StreamResourceInfo
- uid: System.Uri
  parent: System
  isExternal: true
  name: Uri
  nameWithType: Uri
  fullName: System.Uri
- uid: System.Windows.Application.GetCookie(System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: GetCookie(Uri)
  nameWithType: Application.GetCookie(Uri)
  fullName: System.Windows.Application.GetCookie(Uri)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.Application.GetRemoteStream(System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: GetRemoteStream(Uri)
  nameWithType: Application.GetRemoteStream(Uri)
  fullName: System.Windows.Application.GetRemoteStream(Uri)
- uid: System.Windows.Application.GetResourceStream(System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: GetResourceStream(Uri)
  nameWithType: Application.GetResourceStream(Uri)
  fullName: System.Windows.Application.GetResourceStream(Uri)
- uid: System.Windows.Application.LoadCompleted
  parent: System.Windows.Application
  isExternal: false
  name: LoadCompleted
  nameWithType: Application.LoadCompleted
  fullName: System.Windows.Application.LoadCompleted
- uid: System.Windows.Navigation.LoadCompletedEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: LoadCompletedEventHandler
  nameWithType: LoadCompletedEventHandler
  fullName: System.Windows.Navigation.LoadCompletedEventHandler
- uid: System.Windows.Application.LoadComponent(System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: LoadComponent(Uri)
  nameWithType: Application.LoadComponent(Uri)
  fullName: System.Windows.Application.LoadComponent(Uri)
- uid: System.Windows.Application.LoadComponent(System.Object,System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: LoadComponent(Object,Uri)
  nameWithType: Application.LoadComponent(Object,Uri)
  fullName: System.Windows.Application.LoadComponent(Object,Uri)
- uid: System.Windows.Application.MainWindow
  parent: System.Windows.Application
  isExternal: false
  name: MainWindow
  nameWithType: Application.MainWindow
  fullName: System.Windows.Application.MainWindow
- uid: System.Windows.Window
  parent: System.Windows
  isExternal: false
  name: Window
  nameWithType: Window
  fullName: System.Windows.Window
- uid: System.Windows.Application.Navigated
  parent: System.Windows.Application
  isExternal: false
  name: Navigated
  nameWithType: Application.Navigated
  fullName: System.Windows.Application.Navigated
- uid: System.Windows.Navigation.NavigatedEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigatedEventHandler
  nameWithType: NavigatedEventHandler
  fullName: System.Windows.Navigation.NavigatedEventHandler
- uid: System.Windows.Application.Navigating
  parent: System.Windows.Application
  isExternal: false
  name: Navigating
  nameWithType: Application.Navigating
  fullName: System.Windows.Application.Navigating
- uid: System.Windows.Navigation.NavigatingCancelEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigatingCancelEventHandler
  nameWithType: NavigatingCancelEventHandler
  fullName: System.Windows.Navigation.NavigatingCancelEventHandler
- uid: System.Windows.Application.NavigationFailed
  parent: System.Windows.Application
  isExternal: false
  name: NavigationFailed
  nameWithType: Application.NavigationFailed
  fullName: System.Windows.Application.NavigationFailed
- uid: System.Windows.Navigation.NavigationFailedEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationFailedEventHandler
  nameWithType: NavigationFailedEventHandler
  fullName: System.Windows.Navigation.NavigationFailedEventHandler
- uid: System.Windows.Application.NavigationProgress
  parent: System.Windows.Application
  isExternal: false
  name: NavigationProgress
  nameWithType: Application.NavigationProgress
  fullName: System.Windows.Application.NavigationProgress
- uid: System.Windows.Navigation.NavigationProgressEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationProgressEventHandler
  nameWithType: NavigationProgressEventHandler
  fullName: System.Windows.Navigation.NavigationProgressEventHandler
- uid: System.Windows.Application.NavigationStopped
  parent: System.Windows.Application
  isExternal: false
  name: NavigationStopped
  nameWithType: Application.NavigationStopped
  fullName: System.Windows.Application.NavigationStopped
- uid: System.Windows.Navigation.NavigationStoppedEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationStoppedEventHandler
  nameWithType: NavigationStoppedEventHandler
  fullName: System.Windows.Navigation.NavigationStoppedEventHandler
- uid: System.Windows.Application.OnActivated(System.EventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnActivated(EventArgs)
  nameWithType: Application.OnActivated(EventArgs)
  fullName: System.Windows.Application.OnActivated(EventArgs)
- uid: System.EventArgs
  parent: System
  isExternal: true
  name: EventArgs
  nameWithType: EventArgs
  fullName: System.EventArgs
- uid: System.Windows.Application.OnDeactivated(System.EventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnDeactivated(EventArgs)
  nameWithType: Application.OnDeactivated(EventArgs)
  fullName: System.Windows.Application.OnDeactivated(EventArgs)
- uid: System.Windows.Application.OnExit(System.Windows.ExitEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnExit(ExitEventArgs)
  nameWithType: Application.OnExit(ExitEventArgs)
  fullName: System.Windows.Application.OnExit(ExitEventArgs)
- uid: System.Windows.ExitEventArgs
  parent: System.Windows
  isExternal: false
  name: ExitEventArgs
  nameWithType: ExitEventArgs
  fullName: System.Windows.ExitEventArgs
- uid: System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnFragmentNavigation(FragmentNavigationEventArgs)
  nameWithType: Application.OnFragmentNavigation(FragmentNavigationEventArgs)
  fullName: System.Windows.Application.OnFragmentNavigation(FragmentNavigationEventArgs)
- uid: System.Windows.Navigation.FragmentNavigationEventArgs
  parent: System.Windows.Navigation
  isExternal: false
  name: FragmentNavigationEventArgs
  nameWithType: FragmentNavigationEventArgs
  fullName: System.Windows.Navigation.FragmentNavigationEventArgs
- uid: System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnLoadCompleted(NavigationEventArgs)
  nameWithType: Application.OnLoadCompleted(NavigationEventArgs)
  fullName: System.Windows.Application.OnLoadCompleted(NavigationEventArgs)
- uid: System.Windows.Navigation.NavigationEventArgs
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationEventArgs
  nameWithType: NavigationEventArgs
  fullName: System.Windows.Navigation.NavigationEventArgs
- uid: System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigated(NavigationEventArgs)
  nameWithType: Application.OnNavigated(NavigationEventArgs)
  fullName: System.Windows.Application.OnNavigated(NavigationEventArgs)
- uid: System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigating(NavigatingCancelEventArgs)
  nameWithType: Application.OnNavigating(NavigatingCancelEventArgs)
  fullName: System.Windows.Application.OnNavigating(NavigatingCancelEventArgs)
- uid: System.Windows.Navigation.NavigatingCancelEventArgs
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigatingCancelEventArgs
  nameWithType: NavigatingCancelEventArgs
  fullName: System.Windows.Navigation.NavigatingCancelEventArgs
- uid: System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationFailed(NavigationFailedEventArgs)
  nameWithType: Application.OnNavigationFailed(NavigationFailedEventArgs)
  fullName: System.Windows.Application.OnNavigationFailed(NavigationFailedEventArgs)
- uid: System.Windows.Navigation.NavigationFailedEventArgs
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationFailedEventArgs
  nameWithType: NavigationFailedEventArgs
  fullName: System.Windows.Navigation.NavigationFailedEventArgs
- uid: System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationProgress(NavigationProgressEventArgs)
  nameWithType: Application.OnNavigationProgress(NavigationProgressEventArgs)
  fullName: System.Windows.Application.OnNavigationProgress(NavigationProgressEventArgs)
- uid: System.Windows.Navigation.NavigationProgressEventArgs
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationProgressEventArgs
  nameWithType: NavigationProgressEventArgs
  fullName: System.Windows.Navigation.NavigationProgressEventArgs
- uid: System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationStopped(NavigationEventArgs)
  nameWithType: Application.OnNavigationStopped(NavigationEventArgs)
  fullName: System.Windows.Application.OnNavigationStopped(NavigationEventArgs)
- uid: System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnSessionEnding(SessionEndingCancelEventArgs)
  nameWithType: Application.OnSessionEnding(SessionEndingCancelEventArgs)
  fullName: System.Windows.Application.OnSessionEnding(SessionEndingCancelEventArgs)
- uid: System.Windows.SessionEndingCancelEventArgs
  parent: System.Windows
  isExternal: false
  name: SessionEndingCancelEventArgs
  nameWithType: SessionEndingCancelEventArgs
  fullName: System.Windows.SessionEndingCancelEventArgs
- uid: System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnStartup(StartupEventArgs)
  nameWithType: Application.OnStartup(StartupEventArgs)
  fullName: System.Windows.Application.OnStartup(StartupEventArgs)
- uid: System.Windows.StartupEventArgs
  parent: System.Windows
  isExternal: false
  name: StartupEventArgs
  nameWithType: StartupEventArgs
  fullName: System.Windows.StartupEventArgs
- uid: System.Windows.Application.Properties
  parent: System.Windows.Application
  isExternal: false
  name: Properties
  nameWithType: Application.Properties
  fullName: System.Windows.Application.Properties
- uid: System.Collections.IDictionary
  parent: System.Collections
  isExternal: true
  name: IDictionary
  nameWithType: IDictionary
  fullName: System.Collections.IDictionary
- uid: System.Windows.Application.ResourceAssembly
  parent: System.Windows.Application
  isExternal: false
  name: ResourceAssembly
  nameWithType: Application.ResourceAssembly
  fullName: System.Windows.Application.ResourceAssembly
- uid: System.Reflection.Assembly
  parent: System.Reflection
  isExternal: true
  name: Assembly
  nameWithType: Assembly
  fullName: System.Reflection.Assembly
- uid: System.Windows.Application.Resources
  parent: System.Windows.Application
  isExternal: false
  name: Resources
  nameWithType: Application.Resources
  fullName: System.Windows.Application.Resources
- uid: System.Windows.ResourceDictionary
  parent: System.Windows
  isExternal: false
  name: ResourceDictionary
  nameWithType: ResourceDictionary
  fullName: System.Windows.ResourceDictionary
- uid: System.Windows.Application.Run
  parent: System.Windows.Application
  isExternal: false
  name: Run()
  nameWithType: Application.Run()
  fullName: System.Windows.Application.Run()
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.Application.Run(System.Windows.Window)
  parent: System.Windows.Application
  isExternal: false
  name: Run(Window)
  nameWithType: Application.Run(Window)
  fullName: System.Windows.Application.Run(Window)
- uid: System.Windows.Application.SessionEnding
  parent: System.Windows.Application
  isExternal: false
  name: SessionEnding
  nameWithType: Application.SessionEnding
  fullName: System.Windows.Application.SessionEnding
- uid: System.Windows.SessionEndingCancelEventHandler
  parent: System.Windows
  isExternal: false
  name: SessionEndingCancelEventHandler
  nameWithType: SessionEndingCancelEventHandler
  fullName: System.Windows.SessionEndingCancelEventHandler
- uid: System.Windows.Application.SetCookie(System.Uri,System.String)
  parent: System.Windows.Application
  isExternal: false
  name: SetCookie(Uri,String)
  nameWithType: Application.SetCookie(Uri,String)
  fullName: System.Windows.Application.SetCookie(Uri,String)
- uid: System.Windows.Application.Shutdown
  parent: System.Windows.Application
  isExternal: false
  name: Shutdown()
  nameWithType: Application.Shutdown()
  fullName: System.Windows.Application.Shutdown()
- uid: System.Windows.Application.Shutdown(System.Int32)
  parent: System.Windows.Application
  isExternal: false
  name: Shutdown(Int32)
  nameWithType: Application.Shutdown(Int32)
  fullName: System.Windows.Application.Shutdown(Int32)
- uid: System.Windows.Application.ShutdownMode
  parent: System.Windows.Application
  isExternal: false
  name: ShutdownMode
  nameWithType: Application.ShutdownMode
  fullName: System.Windows.Application.ShutdownMode
- uid: System.Windows.ShutdownMode
  parent: System.Windows
  isExternal: false
  name: ShutdownMode
  nameWithType: ShutdownMode
  fullName: System.Windows.ShutdownMode
- uid: System.Windows.Application.Startup
  parent: System.Windows.Application
  isExternal: false
  name: Startup
  nameWithType: Application.Startup
  fullName: System.Windows.Application.Startup
- uid: System.Windows.StartupEventHandler
  parent: System.Windows
  isExternal: false
  name: StartupEventHandler
  nameWithType: StartupEventHandler
  fullName: System.Windows.StartupEventHandler
- uid: System.Windows.Application.StartupUri
  parent: System.Windows.Application
  isExternal: false
  name: StartupUri
  nameWithType: Application.StartupUri
  fullName: System.Windows.Application.StartupUri
- uid: System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  parent: System.Windows.Application
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: Application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.Application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Application.TryFindResource(System.Object)
  parent: System.Windows.Application
  isExternal: false
  name: TryFindResource(Object)
  nameWithType: Application.TryFindResource(Object)
  fullName: System.Windows.Application.TryFindResource(Object)
- uid: System.Windows.Application.Windows
  parent: System.Windows.Application
  isExternal: false
  name: Windows
  nameWithType: Application.Windows
  fullName: System.Windows.Application.Windows
- uid: System.Windows.WindowCollection
  parent: System.Windows
  isExternal: false
  name: WindowCollection
  nameWithType: WindowCollection
  fullName: System.Windows.WindowCollection
- uid: System.Windows.Application.#ctor*
  parent: System.Windows.Application
  isExternal: false
  name: Application
  nameWithType: Application.Application
- uid: System.Windows.Application.Current*
  parent: System.Windows.Application
  isExternal: false
  name: Current
  nameWithType: Application.Current
- uid: System.Windows.Application.FindResource*
  parent: System.Windows.Application
  isExternal: false
  name: FindResource
  nameWithType: Application.FindResource
- uid: System.Windows.Application.GetContentStream*
  parent: System.Windows.Application
  isExternal: false
  name: GetContentStream
  nameWithType: Application.GetContentStream
- uid: System.Windows.Application.GetCookie*
  parent: System.Windows.Application
  isExternal: false
  name: GetCookie
  nameWithType: Application.GetCookie
- uid: System.Windows.Application.GetRemoteStream*
  parent: System.Windows.Application
  isExternal: false
  name: GetRemoteStream
  nameWithType: Application.GetRemoteStream
- uid: System.Windows.Application.GetResourceStream*
  parent: System.Windows.Application
  isExternal: false
  name: GetResourceStream
  nameWithType: Application.GetResourceStream
- uid: System.Windows.Application.LoadComponent*
  parent: System.Windows.Application
  isExternal: false
  name: LoadComponent
  nameWithType: Application.LoadComponent
- uid: System.Windows.Application.MainWindow*
  parent: System.Windows.Application
  isExternal: false
  name: MainWindow
  nameWithType: Application.MainWindow
- uid: System.Windows.Application.OnActivated*
  parent: System.Windows.Application
  isExternal: false
  name: OnActivated
  nameWithType: Application.OnActivated
- uid: System.Windows.Application.OnDeactivated*
  parent: System.Windows.Application
  isExternal: false
  name: OnDeactivated
  nameWithType: Application.OnDeactivated
- uid: System.Windows.Application.OnExit*
  parent: System.Windows.Application
  isExternal: false
  name: OnExit
  nameWithType: Application.OnExit
- uid: System.Windows.Application.OnFragmentNavigation*
  parent: System.Windows.Application
  isExternal: false
  name: OnFragmentNavigation
  nameWithType: Application.OnFragmentNavigation
- uid: System.Windows.Application.OnLoadCompleted*
  parent: System.Windows.Application
  isExternal: false
  name: OnLoadCompleted
  nameWithType: Application.OnLoadCompleted
- uid: System.Windows.Application.OnNavigated*
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigated
  nameWithType: Application.OnNavigated
- uid: System.Windows.Application.OnNavigating*
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigating
  nameWithType: Application.OnNavigating
- uid: System.Windows.Application.OnNavigationFailed*
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationFailed
  nameWithType: Application.OnNavigationFailed
- uid: System.Windows.Application.OnNavigationProgress*
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationProgress
  nameWithType: Application.OnNavigationProgress
- uid: System.Windows.Application.OnNavigationStopped*
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationStopped
  nameWithType: Application.OnNavigationStopped
- uid: System.Windows.Application.OnSessionEnding*
  parent: System.Windows.Application
  isExternal: false
  name: OnSessionEnding
  nameWithType: Application.OnSessionEnding
- uid: System.Windows.Application.OnStartup*
  parent: System.Windows.Application
  isExternal: false
  name: OnStartup
  nameWithType: Application.OnStartup
- uid: System.Windows.Application.Properties*
  parent: System.Windows.Application
  isExternal: false
  name: Properties
  nameWithType: Application.Properties
- uid: System.Windows.Application.ResourceAssembly*
  parent: System.Windows.Application
  isExternal: false
  name: ResourceAssembly
  nameWithType: Application.ResourceAssembly
- uid: System.Windows.Application.Resources*
  parent: System.Windows.Application
  isExternal: false
  name: Resources
  nameWithType: Application.Resources
- uid: System.Windows.Application.Run*
  parent: System.Windows.Application
  isExternal: false
  name: Run
  nameWithType: Application.Run
- uid: System.Windows.Application.SetCookie*
  parent: System.Windows.Application
  isExternal: false
  name: SetCookie
  nameWithType: Application.SetCookie
- uid: System.Windows.Application.Shutdown*
  parent: System.Windows.Application
  isExternal: false
  name: Shutdown
  nameWithType: Application.Shutdown
- uid: System.Windows.Application.ShutdownMode*
  parent: System.Windows.Application
  isExternal: false
  name: ShutdownMode
  nameWithType: Application.ShutdownMode
- uid: System.Windows.Application.StartupUri*
  parent: System.Windows.Application
  isExternal: false
  name: StartupUri
  nameWithType: Application.StartupUri
- uid: System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  parent: System.Windows.Application
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
  nameWithType: Application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
- uid: System.Windows.Application.TryFindResource*
  parent: System.Windows.Application
  isExternal: false
  name: TryFindResource
  nameWithType: Application.TryFindResource
- uid: System.Windows.Application.Windows*
  parent: System.Windows.Application
  isExternal: false
  name: Windows
  nameWithType: Application.Windows
