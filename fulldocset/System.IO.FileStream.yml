### YamlMime:ManagedReference
items:
- uid: System.IO.FileStream
  id: FileStream
  children:
  - System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode)
  - System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  - System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)
  - System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.FileStream.CanRead
  - System.IO.FileStream.CanSeek
  - System.IO.FileStream.CanWrite
  - System.IO.FileStream.Dispose(System.Boolean)
  - System.IO.FileStream.EndRead(System.IAsyncResult)
  - System.IO.FileStream.EndWrite(System.IAsyncResult)
  - System.IO.FileStream.Finalize
  - System.IO.FileStream.Flush
  - System.IO.FileStream.Flush(System.Boolean)
  - System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  - System.IO.FileStream.GetAccessControl
  - System.IO.FileStream.Handle
  - System.IO.FileStream.IsAsync
  - System.IO.FileStream.Length
  - System.IO.FileStream.Lock(System.Int64,System.Int64)
  - System.IO.FileStream.Name
  - System.IO.FileStream.Position
  - System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.FileStream.ReadByte
  - System.IO.FileStream.SafeFileHandle
  - System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  - System.IO.FileStream.SetLength(System.Int64)
  - System.IO.FileStream.Unlock(System.Int64,System.Int64)
  - System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.FileStream.WriteByte(System.Byte)
  langs:
  - csharp
  name: FileStream
  nameWithType: FileStream
  fullName: System.IO.FileStream
  type: Class
  summary: "提供<xref:System.IO.Stream>文件，程序支持同步和异步读取和写入操作。</xref:System.IO.Stream>       若要浏览此类型的.NET Framework 源代码，请参阅[引用源](http://referencesource.microsoft.com/#mscorlib/system/io/filestream.cs#e23a38af5d11ddd3)。"
  remarks: "> [!NOTE]\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/io/filestream.cs#e23a38af5d11ddd3). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \n  \n Use the FileStream class to read from, write to, open, and close files on a file system, and to manipulate other file-related operating system handles, including pipes, standard input, and standard output. You can use the [Read(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True), [Write(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True), <xref:System.IO.Stream.CopyTo%2A>, and <xref:System.IO.FileStream.Flush%2A> methods to perform synchronous operations, or the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.FileStream.FlushAsync%2A> methods to perform asynchronous operations. Use the asynchronous methods to perform resource-intensive file operations without blocking the main thread. This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/add/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working. FileStream buffers input and output for better performance.  \n  \n> [!IMPORTANT]\n>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  \n  \n The <xref:System.IO.FileStream.IsAsync%2A> property detects whether the file handle was opened asynchronously. You specify this value when you create an instance of the FileStream class using a constructor that has an `isAsync`, `useAsync`, or `options` parameter. When the property is `true`, the stream utilizes overlapped I/O to perform file operations asynchronously. However, the <xref:System.IO.FileStream.IsAsync%2A> property does not have to be `true` to call the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, or <xref:System.IO.Stream.CopyToAsync%2A> method. When the <xref:System.IO.FileStream.IsAsync%2A> property is `false` and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.  \n  \n The <xref:System.IO.FileStream.Seek%2A> method supports random access to files. <xref:System.IO.FileStream.Seek%2A> allows the read/write position to be moved to any position within the file. This is done with byte offset reference point parameters. The byte offset is relative to the seek reference point, which can be the beginning, the current position, or the end of the underlying file, as represented by the three members of the <xref:System.IO.SeekOrigin> enumeration.  \n  \n> [!NOTE]\n>  Disk files always support random access. At the time of construction, the <xref:System.IO.FileStream.CanSeek%2A> property value is set to `true` or `false` depending on the underlying file type.If the underlying file type is FILE_TYPE_DISK, as defined in winbase.h, the <xref:System.IO.FileStream.CanSeek%2A> property value is `true`. Otherwise, the <xref:System.IO.FileStream.CanSeek%2A> property value is `false`.  \n  \n If a process terminates with part of a file locked or closes a file that has outstanding locks, the behavior is undefined.  \n  \n For directory operations and other file operations, see the <xref:System.IO.File>, <xref:System.IO.Directory>, and <xref:System.IO.Path> classes. The <xref:System.IO.File> class is a utility class that has static methods primarily for the creation of FileStream objects based on file paths. The <xref:System.IO.MemoryStream> class creates a stream from a byte array and is similar to the FileStream class.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md).  \n  \n## Detection of Stream Position Changes  \n When a FileStream object does not have an exclusive hold on its handle, another thread could access the file handle concurrently and change the position of the operating system's file pointer that is associated with the file handle. In this case, the cached position in the FileStream object and the cached data in the buffer could be compromised. The FileStream object routinely performs checks on methods that access the cached buffer to ensure that the operating system's handle position is the same as the cached position used by the FileStream object.  \n  \n If an unexpected change in the handle position is detected in a call to the <xref:System.IO.FileStream.Read%2A> method, the .NET Framework discards the contents of the buffer and reads the stream from the file again. This can affect performance, depending on the size of the file and any other processes that could affect the position of the file stream.  \n  \n If an unexpected change in the handle position is detected in a call to the <xref:System.IO.FileStream.Write%2A> method, the contents of the buffer are discarded and an <xref:System.IO.IOException> exception is thrown.  \n  \n A FileStream object will not have an exclusive hold on its handle when either the <xref:System.IO.FileStream.SafeFileHandle%2A> property is accessed to expose the handle or the FileStream object is given the <xref:System.IO.FileStream.SafeFileHandle%2A> property in its constructor."
  example:
  - "The following example demonstrates some of the FileStream constructors.  \n  \n [!code-cs[fstream class#1](~/add/codesnippet/csharp/t-system.io.filestream_1.cs)]\n [!code-vb[fstream class#1](~/add/codesnippet/visualbasic/t-system.io.filestream_1.vb)]\n [!code-cpp[fstream class#1](~/add/codesnippet/cpp/t-system.io.filestream_1.cpp)]  \n  \n The following example shows how to write to a file asynchronously. This code runs in a WPF app that has a TextBlock named UserInput and a button hooked up to a Click event handler that is named Button_Click. The file path needs to be changed to a file than exits on the computer.  \n  \n [!code-vb[Asynchronous_File_IO_async#3](~/add/codesnippet/visualbasic/t-system.io.filestream_2.vb)]\n [!code-cs[Asynchronous_File_IO_async#3](~/add/codesnippet/csharp/t-system.io.filestream_2.cs)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public class FileStream : System.IO.Stream
  inheritance:
  - System.IO.Stream
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(SafeFileHandle,FileAccess)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新实例<xref href=&quot;System.IO.FileStream&quot;></xref>为指定的文件句柄，使用指定的读/写权限的类。"
  remarks: "当<xref:System.IO.Stream.Close%2A>是调用，还关闭此句柄和文件的句柄计数会递减。</xref:System.IO.Stream.Close%2A>       `FileStream`假定它具有对该句柄的独有控制。 读取、 写入或查找时`FileStream`也持有句柄可能会导致数据损坏。 为了数据安全，调用<xref:System.IO.FileStream.Flush%2A>之前使用该句柄，并避免之外调用任何方法`Close`完成后使用此句柄。</xref:System.IO.FileStream.Flush%2A>      1> [!CAUTION]&1;> 当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能不是可解释，而且可能会导致引发异常。       `FileShare.Read`默认值为那些<xref:System.IO.FileStream>构造函数，而无需`FileShare`参数。</xref:System.IO.FileStream>       通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "文件的文件句柄的当前<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象将封装。"
    - id: access
      type: System.IO.FileAccess
      description: "一个常数，用于设置<> *1> 和<> *1> 属性<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>access</code>不是字段<xref href=&quot;System.IO.FileAccess&quot;> </xref>。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "出现 I/O 错误，例如磁盘错误发生。       -或者-关闭流。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>请求为指定的文件句柄，例如，当操作系统不允许使用<code> access </code>是<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>并的文件句柄设置为只读访问。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)
  id: '#ctor(System.IntPtr,System.IO.FileAccess)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新实例<xref href=&quot;System.IO.FileStream&quot;></xref>为指定的文件句柄，使用指定的读/写权限的类。"
  remarks: "当<xref:System.IO.Stream.Close%2A>是调用，还关闭此句柄和文件的句柄计数会递减。</xref:System.IO.Stream.Close%2A>       `FileStream`假定它具有对该句柄的独有控制。 读取、 写入或查找时`FileStream`也持有句柄可能会导致数据损坏。 为了数据安全，调用<xref:System.IO.FileStream.Flush%2A>之前使用该句柄，并避免之外调用任何方法`Close`完成后使用此句柄。</xref:System.IO.FileStream.Flush%2A>      1> [!CAUTION]&1;> 当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能不是可解释，而且可能会导致引发异常。       `FileShare.Read`默认值为那些<xref:System.IO.FileStream>构造函数，而无需`FileShare`参数。</xref:System.IO.FileStream>       通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "文件的文件句柄的当前<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象将封装。"
    - id: access
      type: System.IO.FileAccess
      description: "一个常数，用于设置<> *1> 和<> *1> 属性<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>access</code>不是字段<xref href=&quot;System.IO.FileAccess&quot;> </xref>。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "出现 I/O 错误，例如磁盘错误发生。       -或者-关闭流。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>请求为指定的文件句柄，例如，当操作系统不允许使用<code> access </code>是<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>并的文件句柄设置为只读访问。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode)
  id: '#ctor(System.String,System.IO.FileMode)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode)
  nameWithType: FileStream.FileStream(String,FileMode)
  fullName: System.IO.FileStream.FileStream(String,FileMode)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新实例<xref href=&quot;System.IO.FileStream&quot;></xref>使用指定的路径和创建模式的类。"
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed).  \n  \n You cannot use this constructor to open read-only files; instead, you must use a constructor that accepts a `FileAccess` parameter with the value set to `FileAccess.Read`.  \n  \n The buffer size is set to the default size of 4096 bytes (4 KB).  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n `FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.  \n  \n For constructors without a <xref:System.IO.FileAccess> parameter, if the `mode` parameter is set to <xref:System.IO.FileMode>, <xref:System.IO.FileAccess> is the default access. Otherwise, the access is set to <xref:System.IO.FileAccess>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.s_0_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.s_0_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.s_0_1.cpp)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode);
    parameters:
    - id: path
      type: System.String
      description: "该文件的相对或绝对路径，当前<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象将封装。"
    - id: mode
      type: System.IO.FileMode
      description: "一个常数，确定如何打开或创建文件。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>为空字符串 (&quot;&quot;)，仅包含空格，或包含一个或多个无效字符。       -或-<code>path</code>指非文件设备，如&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt1:&quot;，NTFS 环境中的等。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>指非文件设备，如&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt1:&quot;，等非 NTFS 环境中的。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "无法找到该文件，例如，当<code> mode </code>是<xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>，和指定的文件<code> path </code>不存在。 该文件必须以这些模式存在。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "出现 I/O 错误，例如，指定<xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;></xref>指定的文件<code> path </code>已存在，出现错误。       -或者-关闭流。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路径无效，例如位于未映射的驱动器上。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>包含无效值。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(SafeFileHandle,FileAccess,Int32)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新实例<xref href=&quot;System.IO.FileStream&quot;></xref>为指定的文件句柄，使用指定的读/写权限、 类和缓冲区大小。"
  remarks: "`FileStream`假定它具有对该句柄的独有控制。 读取、 写入或查找时`FileStream`也持有句柄可能会导致数据损坏。 为了数据安全，调用<xref:System.IO.FileStream.Flush%2A>之前使用该句柄，并避免之外调用任何方法`Close`完成后使用此句柄。</xref:System.IO.FileStream.Flush%2A> 或者，对读取和写入句柄之前调用此`FileStream`构造函数。       `FileShare.Read`默认值为那些<xref:System.IO.FileStream>构造函数，而无需`FileShare`参数。</xref:System.IO.FileStream>      1> [!CAUTION]&1;> 当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能不是可解释，而且可能会导致引发异常。       通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "文件的文件句柄的当前<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象将封装。"
    - id: access
      type: System.IO.FileAccess
      description: "A <xref href=&quot;System.IO.FileAccess&quot;> </xref>常数，用于设置<> *1> 和<> *1> 属性<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象。"
    - id: bufferSize
      type: System.Int32
      description: "一个值为正<xref:System.Int32>值大于 0，表示缓冲区大小。</xref:System.Int32> 默认缓冲区大小为 4096。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> handle </code>参数是无效的句柄。       -或- <code> handle </code>参数是同步句柄，但被异步使用。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> bufferSize </code>参数是负数。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "出现 I/O 错误，例如磁盘错误发生。       -或者-关闭流。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>请求为指定的文件句柄，例如，当操作系统不允许使用<code> access </code>是<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>并的文件句柄设置为只读访问。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)
  id: '#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新实例<xref href=&quot;System.IO.FileStream&quot;></xref>为指定的文件句柄，使用指定的读/写权限的类和<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>实例所属权。"
  remarks: "`FileStream`对象为文件指定指定的访问权限。 句柄的所有权将按指定方式。 如果此进程拥有句柄调用<xref:System.IO.Stream.Close%2A>方法也将关闭句柄和文件的句柄计数会递减。</xref:System.IO.Stream.Close%2A> `FileStream`对象都提供了默认缓冲区大小 （4096 字节）。       `FileStream`假定它具有对该句柄的独有控制。 读取、 写入或查找时`FileStream`也持有句柄可能会导致数据损坏。 为了数据安全，调用<xref:System.IO.FileStream.Flush%2A>之前使用该句柄，并避免调用的方法以外`Close`完成后使用此句柄。</xref:System.IO.FileStream.Flush%2A>       `FileShare.Read`默认值为那些<xref:System.IO.FileStream>构造函数，而无需`FileShare`参数。</xref:System.IO.FileStream>      1> [!CAUTION]&1;> 当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能不是可解释，而且可能会导致引发异常。       通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "文件的文件句柄的当前<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象将封装。"
    - id: access
      type: System.IO.FileAccess
      description: "一个常数，用于设置<> *1> 和<> *1> 属性<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象。"
    - id: ownsHandle
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果文件句柄将由此拥有<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>实例; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>access</code>不是字段<xref href=&quot;System.IO.FileAccess&quot;> </xref>。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "出现 I/O 错误，例如磁盘错误发生。       -或者-关闭流。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>请求为指定的文件句柄，例如，当操作系统不允许使用<code> access </code>是<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>并的文件句柄设置为只读访问。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新实例<xref href=&quot;System.IO.FileStream&quot;></xref>类使用指定的路径、 创建模式和读/写权限。"
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed). The buffer size is set to the default size of 4096 bytes (4 KB).  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n `FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);
    parameters:
    - id: path
      type: System.String
      description: "该文件的相对或绝对路径，当前<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象将封装。"
    - id: mode
      type: System.IO.FileMode
      description: "一个常数，确定如何打开或创建文件。"
    - id: access
      type: System.IO.FileAccess
      description: "一个常数，确定如何通过访问文件<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象。 这也确定返回的值<> *1> 和<> *1> 属性<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象。 <xref:System.IO.FileStream.CanSeek*>是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果`path`指定磁盘文件。</xref:System.IO.FileStream.CanSeek*>"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>为空字符串 (&quot;&quot;)，仅包含空格，或包含一个或多个无效字符。       -或-<code>path</code>指非文件设备，如&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt1:&quot;，NTFS 环境中的等。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>指非文件设备，如&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt1:&quot;，等非 NTFS 环境中的。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "无法找到该文件，例如，当<code> mode </code>是<xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>，和指定的文件<code> path </code>不存在。 该文件必须以这些模式存在。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "出现 I/O 错误，例如，指定<xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;></xref>指定的文件<code> path </code>已存在，出现错误。       -或者-关闭流。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路径无效，例如位于未映射的驱动器上。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>请求不允许使用指定操作系统<code> path </code>，例如，当<code> access </code>是<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>和文件或目录设置为只读访问。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>包含无效值。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新实例<xref href=&quot;System.IO.FileStream&quot;></xref>为指定的文件句柄，使用指定的读/写权限、 缓冲区大小和同步或异步状态的类。"
  remarks: "你设置`isAsync`参数`true`以异步方式打开的文件句柄。 当该参数是`true`，流利用重叠的 I/O，异步执行文件操作。 但是，该参数不一定要`true`调用<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>，或<xref:System.IO.Stream.CopyToAsync%2A>方法。</xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A> 当`isAsync`参数是`false`和调用异步读取和写入操作，仍未被阻止 UI 线程、，但同步执行实际的 I/O 操作。       `FileStream`假定它具有对该句柄的独有控制。 读取、 写入或查找时`FileStream`也持有句柄可能会导致数据损坏。 为了数据安全，调用<xref:System.IO.FileStream.Flush%2A>之前使用该句柄，并避免之外调用任何方法`Close`完成后使用此句柄。</xref:System.IO.FileStream.Flush%2A> 或者，对读取和写入句柄之前调用此`FileStream`构造函数。       `FileShare.Read`默认值为那些<xref:System.IO.FileStream>构造函数，而无需`FileShare`参数。</xref:System.IO.FileStream>      1> [!CAUTION]&1;> 当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能不是可解释，而且可能会导致引发异常。       通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "文件的文件句柄此<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象将封装。"
    - id: access
      type: System.IO.FileAccess
      description: "一个常数，用于设置<> *1> 和<> *1> 属性<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象。"
    - id: bufferSize
      type: System.Int32
      description: "一个值为正<xref:System.Int32>值大于 0，表示缓冲区大小。</xref:System.Int32> 默认缓冲区大小为 4096。"
    - id: isAsync
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果异步打开句柄 （即以重叠的 I/O 模式）;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> handle </code>参数是无效的句柄。       -或- <code> handle </code>参数是同步句柄，但被异步使用。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> bufferSize </code>参数是负数。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "出现 I/O 错误，例如磁盘错误发生。       -或者-关闭流。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>请求为指定的文件句柄，例如，当操作系统不允许使用<code> access </code>是<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>并的文件句柄设置为只读访问。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)
  id: '#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess,Boolean,Int32)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新实例<xref href=&quot;System.IO.FileStream&quot;></xref>为指定的文件句柄，使用指定的读/写权限、 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>实例所属权和缓冲区大小。"
  remarks: "`FileStream`对象为文件指定指定的访问权限。 句柄的所有权将按指定方式。 如果此`FileStream`拥有句柄，调用<xref:System.IO.Stream.Close%2A>方法也将关闭句柄。</xref:System.IO.Stream.Close%2A> 具体而言，该文件的句柄计数会递减。 `FileStream`对象都提供了指定的缓冲区大小。       `FileStream`假定它具有对该句柄的独有控制。 读取、 写入或查找时`FileStream`也持有句柄可能会导致数据损坏。 为了数据安全，调用<xref:System.IO.FileStream.Flush%2A>之前使用该句柄，并避免之外调用任何方法`Close`完成后使用此句柄。</xref:System.IO.FileStream.Flush%2A> 或者，对读取和写入句柄之前调用此`FileStream`构造函数。       `FileShare.Read`默认值为那些<xref:System.IO.FileStream>构造函数，而无需`FileShare`参数。</xref:System.IO.FileStream>      1> [!CAUTION]&1;> 当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能不是可解释，而且可能会导致引发异常。       通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "文件的文件句柄此<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象将封装。"
    - id: access
      type: System.IO.FileAccess
      description: "一个常数，用于设置<> *1> 和<> *1> 属性<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象。"
    - id: ownsHandle
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果文件句柄将由此拥有<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>实例; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    - id: bufferSize
      type: System.Int32
      description: "一个值为正<xref:System.Int32>值大于 0，表示缓冲区大小。</xref:System.Int32> 默认缓冲区大小为 4096。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>为负数。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "出现 I/O 错误，例如磁盘错误发生。       -或者-关闭流。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>请求为指定的文件句柄，例如，当操作系统不允许使用<code> access </code>是<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>并的文件句柄设置为只读访问。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新实例<xref href=&quot;System.IO.FileStream&quot;></xref>使用指定的路径、 创建模式、 读/写权限和共享权限的类。"
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed). The buffer size is set to the default size of 4096 bytes (4 KB).  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.  \n  \n [!code-cs[System.IO.FileStream3#2](~/add/codesnippet/csharp/904a8302-b9b6-44f1-89c4-_1.cs)]\n [!code-cpp[System.IO.FileStream3#2](~/add/codesnippet/cpp/904a8302-b9b6-44f1-89c4-_1.cpp)]\n [!code-vb[System.IO.FileStream3#2](~/add/codesnippet/visualbasic/904a8302-b9b6-44f1-89c4-_1.vb)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
    parameters:
    - id: path
      type: System.String
      description: "该文件的相对或绝对路径，当前<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象将封装。"
    - id: mode
      type: System.IO.FileMode
      description: "一个常数，确定如何打开或创建文件。"
    - id: access
      type: System.IO.FileAccess
      description: "一个常数，确定如何通过访问文件<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象。 这也确定返回的值<> *1> 和<> *1> 属性<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象。 <xref:System.IO.FileStream.CanSeek*>是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果`path`指定磁盘文件。</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "一个常数，确定将如何由进程共享文件。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>为空字符串 (&quot;&quot;)，仅包含空格，或包含一个或多个无效字符。       -或-<code>path</code>指非文件设备，如&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt1:&quot;，NTFS 环境中的等。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>指非文件设备，如&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt1:&quot;，等非 NTFS 环境中的。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "无法找到该文件，例如，当<code> mode </code>是<xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>，和指定的文件<code> path </code>不存在。 该文件必须以这些模式存在。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "出现 I/O 错误，例如，指定<xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;></xref>指定的文件<code> path </code>已存在，出现错误。       -或-系统正在运行 Windows 98 或 Windows 98 Second Edition 和<code> share </code>设置为<xref uid=&quot;langword_csharp_FileShare.Delete&quot; name=&quot;FileShare.Delete&quot; href=&quot;&quot;> </xref>。       -或者-关闭流。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路径无效，例如位于未映射的驱动器上。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>请求不允许使用指定操作系统<code> path </code>，例如，当<code> access </code>是<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>和文件或目录设置为只读访问。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>包含无效值。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)
  id: '#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新实例<xref href=&quot;System.IO.FileStream&quot;></xref>为指定的文件句柄，使用指定的读/写权限、 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>实例所属权、 缓冲区大小和同步或异步状态。"
  remarks: "`FileStream`对象为文件指定指定的访问权限。 句柄的所有权将按指定方式。 如果此`FileStream`拥有句柄，调用<xref:System.IO.Stream.Close%2A>方法也将关闭句柄。</xref:System.IO.Stream.Close%2A> 具体而言，该文件的句柄计数会递减。 `FileStream`对象都提供了指定的缓冲区大小。       `FileStream`假定它具有对该句柄的独有控制。 读取、 写入或查找时`FileStream`也持有句柄可能会导致数据损坏。 为了数据安全，调用<xref:System.IO.FileStream.Flush%2A>之前使用该句柄，并避免之外调用任何方法`Close`完成后使用此句柄。</xref:System.IO.FileStream.Flush%2A> 或者，对读取和写入句柄之前调用此`FileStream`构造函数。       `FileShare.Read`默认值为那些<xref:System.IO.FileStream>构造函数，而无需`FileShare`参数。</xref:System.IO.FileStream>      1> [!CAUTION]&1;> 当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能不是可解释，而且可能会导致引发异常。       通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "文件的文件句柄此<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象将封装。"
    - id: access
      type: System.IO.FileAccess
      description: "一个常数，用于设置<> *1> 和<> *1> 属性<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象。"
    - id: ownsHandle
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果文件句柄将由此拥有<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>实例; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    - id: bufferSize
      type: System.Int32
      description: "一个值为正<xref:System.Int32>值大于 0，表示缓冲区大小。</xref:System.Int32> 默认缓冲区大小为 4096。"
    - id: isAsync
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果异步打开句柄 （即以重叠的 I/O 模式）;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>access</code>是小于<xref uid=&quot;langword_csharp_FileAccess.Read&quot; name=&quot;FileAccess.Read&quot; href=&quot;&quot;></xref>或大于<xref uid=&quot;langword_csharp_FileAccess.ReadWrite&quot; name=&quot;FileAccess.ReadWrite&quot; href=&quot;&quot;></xref>或<code>bufferSize</code>小于或等于 0。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "句柄无效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "出现 I/O 错误，例如磁盘错误发生。       -或者-关闭流。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>请求为指定的文件句柄，例如，当操作系统不允许使用<code> access </code>是<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>并的文件句柄设置为只读访问。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新实例<xref href=&quot;System.IO.FileStream&quot;></xref>类使用指定的路径、 创建模式、 读/写和共享权限和缓冲区大小。"
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);
    parameters:
    - id: path
      type: System.String
      description: "该文件的相对或绝对路径，当前<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象将封装。"
    - id: mode
      type: System.IO.FileMode
      description: "一个常数，确定如何打开或创建文件。"
    - id: access
      type: System.IO.FileAccess
      description: "一个常数，确定如何通过访问文件<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象。 这也确定返回的值<> *1> 和<> *1> 属性<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象。 <xref:System.IO.FileStream.CanSeek*>是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果`path`指定磁盘文件。</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "一个常数，确定将如何由进程共享文件。"
    - id: bufferSize
      type: System.Int32
      description: "一个值为正<xref:System.Int32>值大于 0，表示缓冲区大小。</xref:System.Int32> 默认缓冲区大小为 4096。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>为空字符串 (&quot;&quot;)，仅包含空格，或包含一个或多个无效字符。       -或-<code>path</code>指非文件设备，如&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt1:&quot;，NTFS 环境中的等。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>指非文件设备，如&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt1:&quot;，等非 NTFS 环境中的。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>为负数或零。       - <code>mode</code>， <code>access</code>，或<code>share</code>包含无效的值。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "无法找到该文件，例如，当<code> mode </code>是<xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>，和指定的文件<code> path </code>不存在。 该文件必须以这些模式存在。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "出现 I/O 错误，例如，指定<xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;></xref>指定的文件<code> path </code>已存在，出现错误。       -或-系统正在运行 Windows 98 或 Windows 98 Second Edition 和<code> share </code>设置为<xref uid=&quot;langword_csharp_FileShare.Delete&quot; name=&quot;FileShare.Delete&quot; href=&quot;&quot;> </xref>。       -或者-关闭流。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路径无效，例如位于未映射的驱动器上。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>请求不允许使用指定操作系统<code> path </code>，例如，当<code> access </code>是<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>和文件或目录设置为只读访问。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新实例<xref href=&quot;System.IO.FileStream&quot;></xref>类使用指定的路径、 创建模式、 读/写和共享权限、 缓冲区大小和同步或异步状态。"
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example shows how to asynchronously write data to a file and then verify that the data was written correctly. A `State` object is created to pass information from the main thread to the `EndReadCallback` and `EndWriteCallback` methods.  \n  \n [!code-cs[System.IO.FileStream2#1](~/add/codesnippet/csharp/ff94fabb-a26d-4ac2-a74e-_1.cs)]\n [!code-vb[System.IO.FileStream2#1](~/add/codesnippet/visualbasic/ff94fabb-a26d-4ac2-a74e-_1.vb)]\n [!code-cpp[System.IO.FileStream2#1](~/add/codesnippet/cpp/ff94fabb-a26d-4ac2-a74e-_1.cpp)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);
    parameters:
    - id: path
      type: System.String
      description: "该文件的相对或绝对路径，当前<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象将封装。"
    - id: mode
      type: System.IO.FileMode
      description: "一个常数，确定如何打开或创建文件。"
    - id: access
      type: System.IO.FileAccess
      description: "一个常数，确定如何通过访问文件<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象。 这也确定返回的值<> *1> 和<> *1> 属性<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象。 <xref:System.IO.FileStream.CanSeek*>是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果`path`指定磁盘文件。</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "一个常数，确定将如何由进程共享文件。"
    - id: bufferSize
      type: System.Int32
      description: "一个值为正<xref:System.Int32>值大于 0，表示缓冲区大小。</xref:System.Int32> 默认缓冲区大小为 4096..."
    - id: useAsync
      type: System.Boolean
      description: "指定是否使用异步 I/O 还是同步 I/O。 但请注意，基础操作系统可能不支持异步 I/O，因此在指定<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>，句柄可能同步打开因平台而异。 以异步方式打开时<> *1> 和<> *1> 方法更好地执行大量读或写操作，但它们可能要慢得多对于少量的读 / 写。 如果应用程序打算利用异步 I/O，设置`useAsync`参数<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。 正确使用异步 I/O 可以加快应用程序尽可能系数为 10，但使用它而无需重新设计的应用程序异步 I/O 可以使性能降低尽可能多的 10 倍。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>为空字符串 (&quot;&quot;)，仅包含空格，或包含一个或多个无效字符。       -或-<code>path</code>指非文件设备，如&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt1:&quot;，NTFS 环境中的等。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>指非文件设备，如&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt1:&quot;，等非 NTFS 环境中的。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>为负数或零。       - <code>mode</code>， <code>access</code>，或<code>share</code>包含无效的值。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "无法找到该文件，例如，当<code> mode </code>是<xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>，和指定的文件<code> path </code>不存在。 该文件必须以这些模式存在。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "出现 I/O 错误，例如，指定<xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;></xref>指定的文件<code> path </code>已存在，出现错误。       -或-系统正在运行 Windows 98 或 Windows 98 Second Edition 和<code> share </code>设置为<xref uid=&quot;langword_csharp_FileShare.Delete&quot; name=&quot;FileShare.Delete&quot; href=&quot;&quot;> </xref>。       -或者-关闭流。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路径无效，例如位于未映射的驱动器上。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>请求不允许使用指定操作系统<code> path </code>，例如，当<code> access </code>是<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>和文件或目录设置为只读访问。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新实例<xref href=&quot;System.IO.FileStream&quot;></xref>类指定的路径、 创建模式、 读/写和共享权限、 访问其他 FileStreams 可以具有相同的文件、 缓冲区大小和附加文件选项。"
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example writes data to a file and then reads the data using the <xref:System.IO.FileStream> object.  \n  \n [!code-cpp[IO.FileStream.ctor1#1](~/add/codesnippet/cpp/53f739ba-7c4d-43ff-a387-_1.cpp)]\n [!code-vb[IO.FileStream.ctor1#1](~/add/codesnippet/visualbasic/53f739ba-7c4d-43ff-a387-_1.vb)]\n [!code-cs[IO.FileStream.ctor1#1](~/add/codesnippet/csharp/53f739ba-7c4d-43ff-a387-_1.cs)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);
    parameters:
    - id: path
      type: System.String
      description: "该文件的相对或绝对路径，当前<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象将封装。"
    - id: mode
      type: System.IO.FileMode
      description: "一个常数，确定如何打开或创建文件。"
    - id: access
      type: System.IO.FileAccess
      description: "一个常数，确定如何通过访问文件<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象。 这也确定返回的值<> *1> 和<> *1> 属性<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象。 <xref:System.IO.FileStream.CanSeek*>是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果`path`指定磁盘文件。</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "一个常数，确定将如何由进程共享文件。"
    - id: bufferSize
      type: System.Int32
      description: "一个值为正<xref:System.Int32>值大于 0，表示缓冲区大小。</xref:System.Int32> 默认缓冲区大小为 4096。"
    - id: options
      type: System.IO.FileOptions
      description: "一个值，指定附加文件选项。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>为空字符串 (&quot;&quot;)，仅包含空格，或包含一个或多个无效字符。       -或-<code>path</code>指非文件设备，如&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt1:&quot;，NTFS 环境中的等。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>指非文件设备，如&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt1:&quot;，等非 NTFS 环境中的。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>为负数或零。       - <code>mode</code>， <code>access</code>，或<code>share</code>包含无效的值。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "无法找到该文件，例如，当<code> mode </code>是<xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>，和指定的文件<code> path </code>不存在。 该文件必须以这些模式存在。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "出现 I/O 错误，例如，指定<xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;></xref>指定的文件<code> path </code>已存在，出现错误。       -或者-关闭流。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路径无效，例如位于未映射的驱动器上。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>请求不允许使用指定操作系统<code> path </code>，例如，当<code> access </code>是<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>和文件或目录设置为只读访问。       - <xref href=&quot;System.IO.FileOptions&quot;> </xref>为指定<code> options </code>，但在当前平台上不支持文件加密。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  id: '#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新实例<xref href=&quot;System.IO.FileStream&quot;></xref>使用指定的路径、 创建模式、 访问权限和共享权限、 缓冲区大小和附加文件选项的类。"
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n Use this FileStream constructor to apply access rights at the point of creation of a file. To access or modify rights on an existing file, consider using the <xref:System.IO.File.GetAccessControl%2A> and <xref:System.IO.File.SetAccessControl%2A> methods.  \n  \n The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);
    parameters:
    - id: path
      type: System.String
      description: "该文件的相对或绝对路径，当前<xref href=&quot;System.IO.FileStream&quot;></xref>对象将封装。"
    - id: mode
      type: System.IO.FileMode
      description: "一个常数，确定如何打开或创建文件。"
    - id: rights
      type: System.Security.AccessControl.FileSystemRights
      description: "一个常数，确定创建文件的访问和审核规则时要使用的访问权限。"
    - id: share
      type: System.IO.FileShare
      description: "一个常数，确定将如何由进程共享文件。"
    - id: bufferSize
      type: System.Int32
      description: "一个值为正<xref:System.Int32>值大于 0，表示缓冲区大小。</xref:System.Int32> 默认缓冲区大小为 4096。"
    - id: options
      type: System.IO.FileOptions
      description: "一个指定附加文件选项的常数。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>为空字符串 (&quot;&quot;)，仅包含空格，或包含一个或多个无效字符。       -或-<code>path</code>指非文件设备，如&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt1:&quot;，NTFS 环境中的等。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>指非文件设备，如&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt1:&quot;，等非 NTFS 环境中的。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>为负数或零。       - <code>mode</code>， <code>access</code>，或<code>share</code>包含无效的值。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "无法找到该文件，例如，当<code> mode </code>是<xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>，和指定的文件<code> path </code>不存在。 该文件必须以这些模式存在。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "当前操作系统不是 Windows NT 或更高版本。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "出现 I/O 错误，例如，指定<xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;></xref>指定的文件<code> path </code>已存在，出现错误。       -或者-关闭流。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路径无效，例如位于未映射的驱动器上。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>请求不允许使用指定操作系统<code> path </code>，例如，当<code> access </code>是<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>和文件或目录设置为只读访问。       - <xref href=&quot;System.IO.FileOptions&quot;> </xref>为指定<code> options </code>，但在当前平台上不支持文件加密。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定<code> path </code>，和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)
  id: '#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新实例<xref href=&quot;System.IO.FileStream&quot;></xref>类使用指定的路径、 创建模式、 访问权限和共享权限、 缓冲区大小、 附加文件选项、 访问控制和审核安全。"
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n Use this FileStream constructor to apply access rights at the point of creation of a file. To access or modify rights on an existing file, consider using the <xref:System.IO.File.GetAccessControl%2A> and <xref:System.IO.File.SetAccessControl%2A> methods.  \n  \n The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example writes data to a file and then reads the data using the <xref:System.IO.FileStream> object.  \n  \n [!code-cpp[IO.FileStream.ctor2#1](~/add/codesnippet/cpp/7f323125-1dac-495a-a4ee-_1.cpp)]\n [!code-cs[IO.FileStream.ctor2#1](~/add/codesnippet/csharp/7f323125-1dac-495a-a4ee-_1.cs)]\n [!code-vb[IO.FileStream.ctor2#1](~/add/codesnippet/visualbasic/7f323125-1dac-495a-a4ee-_1.vb)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: path
      type: System.String
      description: "该文件的相对或绝对路径，当前<xref href=&quot;System.IO.FileStream&quot;></xref>对象将封装。"
    - id: mode
      type: System.IO.FileMode
      description: "一个常数，确定如何打开或创建文件。"
    - id: rights
      type: System.Security.AccessControl.FileSystemRights
      description: "一个常数，确定创建文件的访问和审核规则时要使用的访问权限。"
    - id: share
      type: System.IO.FileShare
      description: "一个常数，确定将如何由进程共享文件。"
    - id: bufferSize
      type: System.Int32
      description: "一个值为正<xref:System.Int32>值大于 0，表示缓冲区大小。</xref:System.Int32> 默认缓冲区大小为 4096。"
    - id: options
      type: System.IO.FileOptions
      description: "一个指定附加文件选项的常数。"
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "一个常数，确定访问控制和审核对文件的安全。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>为空字符串 (&quot;&quot;)，仅包含空格，或包含一个或多个无效字符。       -或-<code>path</code>指非文件设备，如&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt1:&quot;，NTFS 环境中的等。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>指非文件设备，如&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt1:&quot;，等非 NTFS 环境中的。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>为负数或零。       - <code>mode</code>， <code>access</code>，或<code>share</code>包含无效的值。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "无法找到该文件，例如，当<code> mode </code>是<xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>，和指定的文件<code> path </code>不存在。 该文件必须以这些模式存在。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "出现 I/O 错误，例如，指定<xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;></xref>指定的文件<code> path </code>已存在，出现错误。       -或者-关闭流。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路径无效，例如位于未映射的驱动器上。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>请求不允许使用指定操作系统<code> path </code>，例如，当<code> access </code>是<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>和文件或目录设置为只读访问。       - <xref href=&quot;System.IO.FileOptions&quot;> </xref>为指定<code> options </code>，但在当前平台上不支持文件加密。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定<code> path </code>，和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "当前操作系统不是 Windows NT 或更高版本。"
  platform:
  - net462
- uid: System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "开始异步读的操作。 (考虑使用<xref:System.IO.FileStream.ReadAsync*>替换; 请参见备注部分。)</xref:System.IO.FileStream.ReadAsync*>"
  remarks: "在.NET Framework 4 和更早版本中，你必须使用方法，如 BeginRead 和<xref:System.IO.FileStream.EndRead%2A>来实现异步文件操作。</xref:System.IO.FileStream.EndRead%2A> 这些方法是在中仍然可用[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]以支持旧版代码; 但是，新的异步方法，如<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>， <xref:System.IO.Stream.CopyToAsync%2A>，和<xref:System.IO.FileStream.FlushAsync%2A>，帮助你更轻松地实现异步文件操作。</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       <xref:System.IO.FileStream.EndRead%2A>必须为 BeginRead 每次调用一次调用。</xref:System.IO.FileStream.EndRead%2A> 如果在开始另一个读取之前，结束读取的进程可能会导致意外行为，如死锁。       <xref:System.IO.FileStream>提供两个不同的操作模式︰ I/O 同步和异步 I/O。</xref:System.IO.FileStream> 尽管可以使用任一，基础的操作系统资源可能允许访问，只有其中一种模式中。 默认情况下，<xref:System.IO.FileStream>同步打开的操作系统句柄。</xref:System.IO.FileStream> 在 Windows 中，这将降低异步方法。 如果使用异步方法，使用<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>构造函数。</xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>      1> [!NOTE]&1;> 使用<xref:System.IO.FileStream.CanRead%2A>属性来确定当前实例是否支持读取。</xref:System.IO.FileStream.CanRead%2A> 有关其他信息，请参阅<xref:System.IO.Stream.CanRead%2A>。</xref:System.IO.Stream.CanRead%2A>       如果流已关闭或传递了无效参数，将从 BeginRead 立即引发异常。 异步读取请求，例如 IO 请求过程的磁盘故障过程中发生的错误发生在线程池线程和<xref:System.IO.FileStream.EndRead%2A>.</xref:System.IO.FileStream.EndRead%2A>调用时变得可见       <xref:System.IO.Stream.EndRead%2A>必须与此调用<xref:System.IAsyncResult>若要了解已读取的字节。</xref:System.IAsyncResult></xref:System.IO.Stream.EndRead%2A>       多个同时进行的异步请求呈现请求完成顺序不确定。       通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#3](~/add/codesnippet/csharp/82be2bd0-0603-4287-b351-_1.cs)]\n [!code-vb[System.IO.FileStream2#3](~/add/codesnippet/visualbasic/82be2bd0-0603-4287-b351-_1.vb)]\n [!code-cpp[System.IO.FileStream2#3](~/add/codesnippet/cpp/82be2bd0-0603-4287-b351-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    parameters:
    - id: array
      type: System.Byte[]
      description: "要将数据读入的缓冲区。"
    - id: offset
      type: System.Int32
      description: "中的字节偏移量`array`从此处开始读取。"
    - id: numBytes
      type: System.Int32
      description: "最大读取的字节数。"
    - id: userCallback
      type: System.AsyncCallback
      description: "完成的异步读取操作时要调用的方法。"
    - id: stateObject
      type: System.Object
      description: "用户提供的对象，用于区分此特定的异步读取请求与其他请求。"
    return:
      type: System.IAsyncResult
      description: "引用异步读取的对象。"
  overload: System.IO.FileStream.BeginRead*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "数组长度减去<code> offset </code>是小于<code> numBytes </code>。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>或<code>numBytes</code>为负。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "异步读取试图超出文件末尾。"
  platform:
  - net462
- uid: System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "开始异步写操作。 (考虑使用<xref:System.IO.FileStream.WriteAsync*>替换; 请参见备注部分。)</xref:System.IO.FileStream.WriteAsync*>"
  remarks: "在.NET Framework 4 和更早版本中，你必须使用方法，如调用和<xref:System.IO.FileStream.EndWrite%2A>来实现异步文件操作。</xref:System.IO.FileStream.EndWrite%2A> 这些方法是在中仍然可用[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]以支持旧版代码; 但是，新的异步方法，如<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>， <xref:System.IO.Stream.CopyToAsync%2A>，和<xref:System.IO.FileStream.FlushAsync%2A>，帮助你更轻松地实现异步文件操作。</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       <xref:System.IO.FileStream.EndWrite%2A>必须在上一次调用每个<xref:System.IAsyncResult>调用从。</xref:System.IAsyncResult></xref:System.IO.FileStream.EndWrite%2A> <xref:System.IO.FileStream.EndWrite%2A>将阻止，直到 I/O 操作已完成。</xref:System.IO.FileStream.EndWrite%2A>       此方法将替代<xref:System.IO.Stream.BeginWrite%2A>.</xref:System.IO.Stream.BeginWrite%2A>       <xref:System.IO.FileStream>提供两个不同的操作模式︰ I/O 同步和异步 I/O。</xref:System.IO.FileStream> 尽管可以使用任一，基础的操作系统资源可能允许访问，只有其中一种模式中。 默认情况下，<xref:System.IO.FileStream>同步打开的操作系统句柄。</xref:System.IO.FileStream> 在 Windows 中，这将降低异步方法。 如果使用异步方法，使用<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>构造函数。</xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>       如果流已关闭或传递了无效参数，将从调用立即引发异常。 异步写入请求，例如 IO 请求过程的磁盘故障过程中发生的错误发生在线程池线程和<xref:System.IO.FileStream.EndWrite%2A>.</xref:System.IO.FileStream.EndWrite%2A>调用时变得可见       多个同时进行的异步请求呈现请求完成顺序不确定。       通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#2](~/add/codesnippet/csharp/439bdb1f-5241-4046-a4ad-_1.cs)]\n [!code-vb[System.IO.FileStream2#2](~/add/codesnippet/visualbasic/439bdb1f-5241-4046-a4ad-_1.vb)]\n [!code-cpp[System.IO.FileStream2#2](~/add/codesnippet/cpp/439bdb1f-5241-4046-a4ad-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    parameters:
    - id: array
      type: System.Byte[]
      description: "包含要写入当前流数据的缓冲区。"
    - id: offset
      type: System.Int32
      description: "中的从零开始的字节偏移量`array`从此处开始将字节复制到当前流。"
    - id: numBytes
      type: System.Int32
      description: "最大写入的字节数。"
    - id: userCallback
      type: System.AsyncCallback
      description: "异步写操作完成时调用的方法。"
    - id: stateObject
      type: System.Object
      description: "一个用户提供的对象，它将此特定的异步写入请求与其他请求区别开来。"
    return:
      type: System.IAsyncResult
      description: "引用异步写入一个对象。"
  overload: System.IO.FileStream.BeginWrite*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>长度减去<code>offset</code>是小于<code>numBytes</code>。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>或<code>numBytes</code>为负。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "流不支持写入。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "流已关闭。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "发生 I/O 错误。"
  platform:
  - net462
- uid: System.IO.FileStream.CanRead
  id: CanRead
  parent: System.IO.FileStream
  langs:
  - csharp
  name: CanRead
  nameWithType: FileStream.CanRead
  fullName: System.IO.FileStream.CanRead
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "获取一个值，该值指示当前流是否支持读取。"
  remarks: "如果从派生的类<xref:System.IO.Stream>不支持读取，则调用<xref:System.IO.FileStream.Read%2A>， <xref:System.IO.FileStream.ReadByte%2A>，和<xref:System.IO.FileStream.BeginRead%2A>方法将引发一种<xref:System.NotSupportedException>。</xref:System.NotSupportedException> </xref:System.IO.FileStream.BeginRead%2A> </xref:System.IO.FileStream.ReadByte%2A> </xref:System.IO.FileStream.Read%2A> </xref:System.IO.Stream>       如果流已关闭，则此属性返回`false`。"
  example:
  - "The following example demonstrates a use of the `CanRead` property. The output of this code is \"MyFile.txt is not writable.\" To get the output message \"MyFile.txt can be both written to and read from.\", change the `FileAccess` parameter to `ReadWrite` in the `FileStream` constructor.  \n  \n [!code-cs[Classic FileStream.CanRead Example#1](~/add/codesnippet/csharp/p-system.io.filestream.c_1_1.cs)]\n [!code-cpp[Classic FileStream.CanRead Example#1](~/add/codesnippet/cpp/p-system.io.filestream.c_1_1.cpp)]\n [!code-vb[Classic FileStream.CanRead Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_1_1.vb)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果流支持读取;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>如果流已关闭或是通过只写访问方式打开。"
  overload: System.IO.FileStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.CanSeek
  id: CanSeek
  parent: System.IO.FileStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: FileStream.CanSeek
  fullName: System.IO.FileStream.CanSeek
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "获取一个值，该值指示当前流是否支持查找。"
  remarks: "如果从派生的类<xref:System.IO.Stream>不支持查找，则调用<xref:System.IO.FileStream.Length%2A>， <xref:System.IO.FileStream.SetLength%2A>， <xref:System.IO.FileStream.Position%2A>，并<xref:System.IO.FileStream.Seek%2A>引发一种<xref:System.NotSupportedException>。</xref:System.NotSupportedException> </xref:System.IO.FileStream.Seek%2A> </xref:System.IO.FileStream.Position%2A> </xref:System.IO.FileStream.SetLength%2A> </xref:System.IO.FileStream.Length%2A> </xref:System.IO.Stream>       如果流已关闭，则此属性返回`false`。"
  example:
  - "The following example uses the `CanSeek` property to check whether a stream supports seeking.  \n  \n [!code-cpp[fstream canseek#1](~/add/codesnippet/cpp/p-system.io.filestream.c_0_1.cpp)]\n [!code-vb[fstream canseek#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_0_1.vb)]\n [!code-cs[fstream canseek#1](~/add/codesnippet/csharp/p-system.io.filestream.c_0_1.cs)]"
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果流支持查找;，<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>如果流已关闭，或如果<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>构造从操作系统句柄如管道或输出到控制台。"
  overload: System.IO.FileStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.CanWrite
  id: CanWrite
  parent: System.IO.FileStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: FileStream.CanWrite
  fullName: System.IO.FileStream.CanWrite
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "获取一个值，该值指示当前流是否支持写入。"
  remarks: "如果从派生的类<xref:System.IO.Stream>不支持写入，调用<xref:System.IO.FileStream.SetLength%2A>， <xref:System.IO.FileStream.Write%2A>， <xref:System.IO.FileStream.BeginWrite%2A>，或<xref:System.IO.FileStream.WriteByte%2A>引发一种<xref:System.NotSupportedException>。</xref:System.NotSupportedException> </xref:System.IO.FileStream.WriteByte%2A> </xref:System.IO.FileStream.BeginWrite%2A> </xref:System.IO.FileStream.Write%2A> </xref:System.IO.FileStream.SetLength%2A> </xref:System.IO.Stream>       如果流已关闭，则此属性返回`false`。"
  example:
  - "The following example uses the `CanWrite` property to check whether a stream supports writing.  \n  \n [!code-cs[fstream canwrite#1](~/add/codesnippet/csharp/p-system.io.filestream.c_2_1.cs)]\n [!code-cpp[fstream canwrite#1](~/add/codesnippet/cpp/p-system.io.filestream.c_2_1.cpp)]\n [!code-vb[fstream canwrite#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_2_1.vb)]  \n  \n The following is an example using the `CanWrite` property. The output of this code is \"MyFile.txt is writable.\" To get the output message \"MyFile.txt can be both written to and read from.\", change the `FileAccess` parameter to `ReadWrite` in the `FileStream` constructor.  \n  \n [!code-cs[Classic FileStream.CanWrite Example#1](~/add/codesnippet/csharp/p-system.io.filestream.c_2_2.cs)]\n [!code-vb[Classic FileStream.CanWrite Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_2_2.vb)]\n [!code-cpp[Classic FileStream.CanWrite Example#1](~/add/codesnippet/cpp/p-system.io.filestream.c_2_2.cpp)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果流支持写入，则<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>如果流已关闭或是通过只读访问方式打开。"
  overload: System.IO.FileStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: FileStream.Dispose(Boolean)
  fullName: System.IO.FileStream.Dispose(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "释放由非托管的资源<xref href=&quot;System.IO.FileStream&quot;> </xref> ，还可以释放托管的资源。"
  remarks: "此方法称为由公共<xref:System.ComponentModel.Component.Dispose%2A>方法和<xref:System.Object.Finalize%2A>方法。</xref:System.Object.Finalize%2A> </xref:System.ComponentModel.Component.Dispose%2A> <xref:System.ComponentModel.Component.Dispose%2A>调用与受保护的 Dispose 方法`disposing`参数设置为`true`。</xref:System.ComponentModel.Component.Dispose%2A> <xref:System.Object.Finalize%2A>调用与 Dispose`disposing`设置为`false`。</xref:System.Object.Finalize%2A>       当`disposing`参数是`true`，此方法释放由任何托管对象持有的全部资源此<xref:System.IO.FileStream>引用。</xref:System.IO.FileStream> 此方法调用<xref:System.ComponentModel.Component.Dispose%2A>每个引用对象的方法。</xref:System.ComponentModel.Component.Dispose%2A>"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要释放托管和非托管资源;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>若要仅释放非托管的资源。"
  overload: System.IO.FileStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.EndRead(System.IAsyncResult)
  id: EndRead(System.IAsyncResult)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: EndRead(IAsyncResult)
  nameWithType: FileStream.EndRead(IAsyncResult)
  fullName: System.IO.FileStream.EndRead(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "等待挂起的异步读取操作完成。 (考虑使用<xref:System.IO.FileStream.ReadAsync*>替换; 请参见备注部分。)</xref:System.IO.FileStream.ReadAsync*>"
  remarks: "在.NET Framework 4 和更早版本中，你必须使用方法，如<xref:System.IO.FileStream.BeginRead%2A>和 EndRead 来实现异步文件操作。</xref:System.IO.FileStream.BeginRead%2A> 这些方法是在中仍然可用[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]以支持旧版代码; 但是，新的异步方法，如<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>， <xref:System.IO.Stream.CopyToAsync%2A>，和<xref:System.IO.FileStream.FlushAsync%2A>，帮助你更轻松地实现异步文件操作。</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       必须正好为<xref:System.IO.FileStream.BeginRead%2A>.</xref:System.IO.FileStream.BeginRead%2A>每次调用调用 EndRead 如果在开始另一个读取之前，结束读取的进程可能会导致意外行为，如死锁。       此方法将替代<xref:System.IO.Stream.EndRead%2A>.</xref:System.IO.Stream.EndRead%2A>       可以对每个<xref:System.IAsyncResult><xref:System.IO.FileStream.BeginRead%2A>。</xref:System.IO.FileStream.BeginRead%2A></xref:System.IAsyncResult>调用 EndRead 调用 EndRead 告知你已从流中读取字节数。 EndRead 将阻止，直到 I/O 操作已完成。"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#4](~/add/codesnippet/csharp/m-system.io.filestream.e_0_1.cs)]\n [!code-vb[System.IO.FileStream2#4](~/add/codesnippet/visualbasic/m-system.io.filestream.e_0_1.vb)]\n [!code-cpp[System.IO.FileStream2#4](~/add/codesnippet/cpp/m-system.io.filestream.e_0_1.cpp)]"
  syntax:
    content: public override int EndRead (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "对要等待的挂起异步请求的引用。"
    return:
      type: System.Int32
      description: "从流，介于 0 和你请求的字节数之间中读取的字节数。 流仅返回在流末尾的 0，否则，它们应一直进行阻止至少 1 个字节可用。"
  overload: System.IO.FileStream.EndRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "此<xref:System.IAsyncResult>对象不通过调用<xref:System.IO.FileStream.BeginRead*>此类</xref:System.IO.FileStream.BeginRead*>创建</xref:System.IAsyncResult>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "多次调用 EndRead。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "流已关闭或出现内部错误。"
  platform:
  - net462
- uid: System.IO.FileStream.EndWrite(System.IAsyncResult)
  id: EndWrite(System.IAsyncResult)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: EndWrite(IAsyncResult)
  nameWithType: FileStream.EndWrite(IAsyncResult)
  fullName: System.IO.FileStream.EndWrite(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "结束异步写操作和块，直到 I/O 操作已完成。 (考虑使用<xref:System.IO.FileStream.WriteAsync*>替换; 请参见备注部分。)</xref:System.IO.FileStream.WriteAsync*>"
  remarks: "在.NET Framework 4 和更早版本中，你必须使用方法，如<xref:System.IO.FileStream.BeginWrite%2A>和 EndWrite 来实现异步文件操作。</xref:System.IO.FileStream.BeginWrite%2A> 这些方法是在中仍然可用[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]以支持旧版代码; 但是，新的异步方法，如<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>， <xref:System.IO.Stream.CopyToAsync%2A>，和<xref:System.IO.FileStream.FlushAsync%2A>，帮助你更轻松地实现异步文件操作。</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       此方法将替代<xref:System.IO.Stream.EndWrite%2A>.</xref:System.IO.Stream.EndWrite%2A>       必须在每个<xref:System.IAsyncResult><xref:System.IO.FileStream.BeginWrite%2A>.</xref:System.IO.FileStream.BeginWrite%2A>从</xref:System.IAsyncResult>上一次调用 EndWrite EndWrite 将阻止，直到 I/O 操作已完成。"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#3](~/add/codesnippet/csharp/m-system.io.filestream.e_1_1.cs)]\n [!code-vb[System.IO.FileStream2#3](~/add/codesnippet/visualbasic/m-system.io.filestream.e_1_1.vb)]\n [!code-cpp[System.IO.FileStream2#3](~/add/codesnippet/cpp/m-system.io.filestream.e_1_1.cpp)]"
  syntax:
    content: public override void EndWrite (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "挂起的异步 I/O 请求。"
  overload: System.IO.FileStream.EndWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "此<xref:System.IAsyncResult>对象不通过调用<xref:System.IO.Stream.BeginWrite*>此类</xref:System.IO.Stream.BeginWrite*>创建</xref:System.IAsyncResult>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "EndWrite 多次调用。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "流已关闭或出现内部错误。"
  platform:
  - net462
- uid: System.IO.FileStream.Finalize
  id: Finalize
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Finalize()
  nameWithType: FileStream.Finalize()
  fullName: System.IO.FileStream.Finalize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "确保释放资源并在垃圾回收器回收时，并执行其他清理操作<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>。"
  remarks: "垃圾回收器调用`Finalize`何时准备好完成当前的对象。 `Finalize`关闭`FileStream`。"
  syntax:
    content: ~FileStream ();
    parameters: []
  overload: System.IO.FileStream.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Flush
  id: Flush
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Flush()
  nameWithType: FileStream.Flush()
  fullName: System.IO.FileStream.Flush()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "清除此流的缓冲区，使得所有缓冲的数据写入到文件。"
  remarks: "此方法将替代<xref:System.IO.Stream.Flush%2A?displayProperty=fullName>.</xref:System.IO.Stream.Flush%2A?displayProperty=fullName>       在调用 Flush 方法时，也会刷新操作系统 I/O 缓冲区。       除非你显式刷新调用，或者释放对象，不会刷新流的编码器。 设置<xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=fullName>到`true`意味着数据从缓冲区刷新到流中，但不是会刷新编码器状态。</xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=fullName> 这将允许编码器，以便它可以正确编码的字符的下一步块保持其状态 （部分字符）。 这种情况下会影响 UTF8 和 UTF7 其中某些字符仅后才能进行编码的编码器收到的相邻字符。       刷新因为缓冲区可以用于读取或写入，执行以下两个函数:-以前向缓冲区写入任何数据复制到文件和其编码器状态除外清除缓冲区。      -如果<xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=fullName>是`true`和以前将数据从文件复制到缓冲区以进行读取，该文件中的当前位置将减少的缓冲区中的未读字节数。</xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=fullName> 然后清除缓冲区。       使用<xref:System.IO.FileStream.Flush%28System.Boolean%29>方法重载时你想要确保中间文件缓冲区中的所有缓冲数据写入到磁盘。</xref:System.IO.FileStream.Flush%28System.Boolean%29>"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.  \n  \n [!code-cs[System.IO.FileStream3#4](~/add/codesnippet/csharp/m-system.io.filestream.f_1.cs)]\n [!code-cpp[System.IO.FileStream3#4](~/add/codesnippet/cpp/m-system.io.filestream.f_1.cpp)]\n [!code-vb[System.IO.FileStream3#4](~/add/codesnippet/visualbasic/m-system.io.filestream.f_1.vb)]"
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.IO.FileStream.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "发生 I/O 错误。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "流已关闭。"
  platform:
  - net462
- uid: System.IO.FileStream.Flush(System.Boolean)
  id: Flush(System.Boolean)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Flush(Boolean)
  nameWithType: FileStream.Flush(Boolean)
  fullName: System.IO.FileStream.Flush(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "清除此流的缓冲区并使所有缓冲的数据都写入到该文件，并清除所有中间文件缓冲区。"
  remarks: "使用此重载时你想要确保中间文件缓冲区中的所有缓冲数据写入到磁盘。       在调用 Flush 方法时，也会刷新操作系统 I/O 缓冲区。"
  syntax:
    content: public virtual void Flush (bool flushToDisk);
    parameters:
    - id: flushToDisk
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要刷新所有中间文件缓冲区;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.FileStream.Flush*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  id: FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FlushAsync(CancellationToken)
  nameWithType: FileStream.FlushAsync(CancellationToken)
  fullName: System.IO.FileStream.FlushAsync(CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "异步清除此流的所有缓冲区，使得所有缓冲的数据都写入到基础设备，并监视取消请求。"
  remarks: "在调用 FlushAsync 方法时，也会刷新操作系统 I/O 缓冲区。       如果在完成之前，将取消该操作，返回的任务包含<xref:System.Threading.Tasks.TaskStatus>值<xref:System.Threading.Tasks.Task.Status%2A>属性。</xref:System.Threading.Tasks.Task.Status%2A> </xref:System.Threading.Tasks.TaskStatus> 如果文件句柄将被释放，则返回的任务包含<xref:System.ObjectDisposedException>中的异常<xref:System.Threading.Tasks.Task.Exception%2A>属性。</xref:System.Threading.Tasks.Task.Exception%2A> </xref:System.ObjectDisposedException>"
  syntax:
    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "要监视取消请求的标记。"
    return:
      type: System.Threading.Tasks.Task
      description: "表示异步刷新操作的任务。"
  overload: System.IO.FileStream.FlushAsync*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已释放流。"
  platform:
  - net462
- uid: System.IO.FileStream.GetAccessControl
  id: GetAccessControl
  parent: System.IO.FileStream
  langs:
  - csharp
  name: GetAccessControl()
  nameWithType: FileStream.GetAccessControl()
  fullName: System.IO.FileStream.GetAccessControl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "获取<xref href=&quot;System.Security.AccessControl.FileSecurity&quot;></xref>对象，它封装由当前所描述的文件的访问控制列表 (ACL) 项<xref href=&quot;System.IO.FileStream&quot;></xref>对象。"
  remarks: "虽然<xref:System.IO.FileStream>类和 GetAccessControl 可以用于检索现有文件的访问控制列表 (ACL) 项，请考虑使用<xref:System.IO.File.GetAccessControl%2A?displayProperty=fullName>方法，因为它是使用起来更为简便。</xref:System.IO.File.GetAccessControl%2A?displayProperty=fullName> </xref:System.IO.FileStream>       GetAccessControl 方法用于检索文件的 ACL 项。       ACL 描述个人和/或组具有或没有执行到给定的文件上的特定操作的权限。 有关详细信息，请参阅[如何︰ 添加或移除访问控制列表项](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public System.Security.AccessControl.FileSecurity GetAccessControl ();
    parameters: []
    return:
      type: System.Security.AccessControl.FileSecurity
      description: "一个对象，封装当前所描述的文件的访问控制设置<xref href=&quot;System.IO.FileStream&quot;></xref>对象。"
  overload: System.IO.FileStream.GetAccessControl*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "文件关闭。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "打开文件时发生 I/O 错误。"
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "找不到该文件。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "当前平台上不支持此操作。       -或者-调用方没有所要求的权限。"
  platform:
  - net462
- uid: System.IO.FileStream.Handle
  id: Handle
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Handle
  nameWithType: FileStream.Handle
  fullName: System.IO.FileStream.Handle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "获取操作系统文件句柄的文件的当前<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象所封装。"
  remarks: "此属性是与操作系统的系统提供的系统调用一起使用的操作系统句柄 (如`ReadFile`Windows 上)。 它不会使用 C 库函数，如预期的文件描述符， `fread`。       操作系统句柄可能打开过同步或异步，具体取决于`FileStream`已调用构造函数。 使用<xref:System.IO.FileStream.IsAsync%2A>属性来发现是否以异步方式打开此句柄。</xref:System.IO.FileStream.IsAsync%2A> 在 Win32 中，这意味着句柄已打开为重叠的 IO，并且它要求在不同的参数到`ReadFile`和`WriteFile`。      1> [!CAUTION]&1;> 如果，则可能发生数据损坏`FileStream`是创建，其句柄传递、 某些操作移动句柄的文件指针，然后`FileStream`会再次使用。 多个线程不能同时安全地写入到相同文件，和`FileStream`缓冲代码假定它以独占方式控制该句柄。 `FileStream`可能引发<xref:System.IO.IOException>如果`FileStream`检测到某些其他进程已移动的文件指针。</xref:System.IO.IOException> 若要避免此问题，不写入任何数据到文件的一部分，`FileStream`可能具有缓冲，并将文件指针还原到在上一次调用方法时的位置`FileStream`。"
  syntax:
    content: public virtual IntPtr Handle { get; }
    return:
      type: System.IntPtr
      description: "此封装的文件的操作系统文件句柄<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>对象或为-1 如果<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>已关闭。"
  overload: System.IO.FileStream.Handle*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  platform:
  - net462
- uid: System.IO.FileStream.IsAsync
  id: IsAsync
  parent: System.IO.FileStream
  langs:
  - csharp
  name: IsAsync
  nameWithType: FileStream.IsAsync
  fullName: System.IO.FileStream.IsAsync
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "获取一个值，该值指示是否<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>异步还是同步打开。"
  remarks: "`IsAsync`属性检测是否`FileStream`句柄已异步打开的使代码能够使用<xref:System.IO.FileStream.Handle%2A>属性正确。</xref:System.IO.FileStream.Handle%2A> 在 Win32 中，`IsAsync`正在 true 表示句柄为重叠 I/O 打开并因而需要不同的参数到`ReadFile`和`WriteFile`。       在创建的实例时指定此值<xref:System.IO.FileStream>类使用的构造函数`isAsync`， `useAsync`，或`options`参数。</xref:System.IO.FileStream> 当该属性是`true`，流利用重叠的 I/O，异步执行文件操作。 但是，IsAsync 属性不一定要`true`调用<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>，或<xref:System.IO.Stream.CopyToAsync%2A>方法。</xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A> 当 IsAsync 属性是`false`和调用异步读取和写入操作，仍未被阻止 UI 线程、，但同步执行实际的 I/O 操作。"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#2](~/add/codesnippet/csharp/p-system.io.filestream.i_1.cs)]\n [!code-vb[System.IO.FileStream2#2](~/add/codesnippet/visualbasic/p-system.io.filestream.i_1.vb)]\n [!code-cpp[System.IO.FileStream2#2](~/add/codesnippet/cpp/p-system.io.filestream.i_1.cpp)]"
  syntax:
    content: public virtual bool IsAsync { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>已异步打开; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.FileStream.IsAsync*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Length
  id: Length
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Length
  nameWithType: FileStream.Length
  fullName: System.IO.FileStream.Length
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "获取用字节表示的流长度。"
  remarks: "通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example uses the `Length` and `Position` properties to check for an end-of-file condition.  \n  \n [!code-cpp[Classic FileStream.Length Example#1](~/add/codesnippet/cpp/p-system.io.filestream.l_1.cpp)]\n [!code-cs[Classic FileStream.Length Example#1](~/add/codesnippet/csharp/p-system.io.filestream.l_1.cs)]\n [!code-vb[Classic FileStream.Length Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.l_1.vb)]"
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "表示以字节为单位的流的长度的长值。"
  overload: System.IO.FileStream.Length*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref:System.IO.FileStream.CanSeek*>此流为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.IO.FileStream.CanSeek*>"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "出现 I/O 错误，例如文件被关闭，出现。"
  platform:
  - net462
- uid: System.IO.FileStream.Lock(System.Int64,System.Int64)
  id: Lock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Lock(Int64,Int64)
  nameWithType: FileStream.Lock(Int64,Int64)
  fullName: System.IO.FileStream.Lock(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "防止其他进程读取或写入<xref href=&quot;System.IO.FileStream&quot;> </xref>。"
  remarks: "文件流的范围锁定赋予该区域的文件流的锁定的进程独占访问的线程。       通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file. Run the program simultaneously in different command windows and investigate using the different console input options.  \n  \n [!code-cs[System.IO.FileStream3#1](~/add/codesnippet/csharp/m-system.io.filestream.l_1.cs)]\n [!code-cpp[System.IO.FileStream3#1](~/add/codesnippet/cpp/m-system.io.filestream.l_1.cpp)]\n [!code-vb[System.IO.FileStream3#1](~/add/codesnippet/visualbasic/m-system.io.filestream.l_1.vb)]"
  syntax:
    content: public virtual void Lock (long position, long length);
    parameters:
    - id: position
      type: System.Int64
      description: "要锁定的范围的开头。 此参数的值必须等于或大于零 (0)。"
    - id: length
      type: System.Int64
      description: "要锁定的范围。"
  overload: System.IO.FileStream.Lock*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>position</code>或<code>length</code>为负。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "文件关闭。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "进程无法访问该文件，因为另一个进程已锁定文件的一部分。"
  platform:
  - net462
- uid: System.IO.FileStream.Name
  id: Name
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Name
  nameWithType: FileStream.Name
  fullName: System.IO.FileStream.Name
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "获取的名称<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> ，传递到构造函数。"
  remarks: "通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#4](~/add/codesnippet/csharp/p-system.io.filestream.n_1.cs)]\n [!code-vb[System.IO.FileStream2#4](~/add/codesnippet/visualbasic/p-system.io.filestream.n_1.vb)]\n [!code-cpp[System.IO.FileStream2#4](~/add/codesnippet/cpp/p-system.io.filestream.n_1.cpp)]"
  syntax:
    content: public string Name { get; }
    return:
      type: System.String
      description: "一个字符串，它的名称<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.FileStream.Name*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Position
  id: Position
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Position
  nameWithType: FileStream.Position
  fullName: System.IO.FileStream.Position
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "获取或设置此流的当前位置。"
  remarks: "支持查找到流的长度超出任何位置。  当您寻求超出长度的文件时，文件大小就会增加。  在 Microsoft Windows NT 和更高，则将添加到文件末尾的任何数据设置为零。  在 Microsoft Windows 98 或更早版本，添加到文件末尾的任何数据未设置为零，这意味着，先前删除的数据是可见写入流。 将流的当前位置设置为较大的值超出在 Windows 98 或更早版本的流的末尾，则可能会导致正在引发的异常。       通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example uses the `Length` and `Position` properties to check for an end-of-file condition.  \n  \n [!code-cpp[Classic FileStream.Length Example#1](~/add/codesnippet/cpp/p-system.io.filestream.p_1.cpp)]\n [!code-cs[Classic FileStream.Length Example#1](~/add/codesnippet/csharp/p-system.io.filestream.p_1.cs)]\n [!code-vb[Classic FileStream.Length Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.p_1.vb)]"
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "此流的当前位置。"
  overload: System.IO.FileStream.Position*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "流不支持查找。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurred.  \n  \n \\- or -  \n  \n The position was set to a very large value beyond the end of the stream in Windows 98 or earlier."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "试图将位置设置为负值。"
  - type: System.IO.EndOfStreamException
    commentId: T:System.IO.EndOfStreamException
    description: "尝试查找不支持此流的末尾。"
  platform:
  - net462
- uid: System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: FileStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "从流中读取字节块并将数据写入给定缓冲区中。"
  remarks: "此方法将替代<xref:System.IO.Stream.Read%2A>.</xref:System.IO.Stream.Read%2A>       `offset`参数指定了中的字节的偏移量`array`（缓冲区索引） 在此处开始读取，和`count`参数指定了最大要从此流中读取的字节数。 如果已到达流结尾，则返回的值是实际数字节，则为零。 如果读取的操作成功，是通过读取的字节数高级流的当前位置。 如果发生异常，则流的当前位置不变。       Read 方法将返回仅在到达流的末尾后的零。 否则，读取始终至少&1; 个字节从流中读取在返回之前。 如果没有数据时调用读取流中可用，该方法将可以返回至少一个字节的数据一直阻止。 实现可以自由地返回少于所请求的字节，即使尚未达到流结尾。       使用<xref:System.IO.BinaryReader>读取基元数据类型。</xref:System.IO.BinaryReader>       不会中断正在执行读取的操作的线程。 尽管应用程序可能看起来后取消阻止该线程尚未成功运行，但中断会降低应用程序的性能和可靠性。       通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example reads the contents from a <xref:System.IO.FileStream> and writes it into another <xref:System.IO.FileStream>.  \n  \n [!code-vb[FSRead#1](~/add/codesnippet/visualbasic/m-system.io.filestream.r_1_1.vb)]\n [!code-cs[FSRead#1](~/add/codesnippet/csharp/m-system.io.filestream.r_1_1.cs)]"
  syntax:
    content: public override int Read (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "此方法返回时，包含之间的值的指定的字节数组`offset`和 (`offset`  +  `count` -1`)`由从当前源中读取的字节替换。"
    - id: offset
      type: System.Int32
      description: "中的字节偏移量`array`在放置读取的字节。"
    - id: count
      type: System.Int32
      description: "最大读取的字节数。"
    return:
      type: System.Int32
      description: "读取到缓冲区的字节总数。 这可能小于请求的字节数的如果字节数当前不可用，或零个如果已到达流结尾。"
  overload: System.IO.FileStream.Read*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>或<code>count</code>为负。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "流不支持读取。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "发生 I/O 错误。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>offset</code>和<code>count</code>描述中的无效范围<code>array</code>。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "在流关闭后调用方法。"
  platform:
  - net462
- uid: System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "从当前流异步读取字节序列的流中的位置提升读取的字节数，并监视取消请求。"
  remarks: "ReadAsync 方法，可在不阻塞主线程的情况下执行占用大量资源的文件操作。 此性能的考虑就特别重要[!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)]应用或[!INCLUDE[desktop_appname](~/add/includes/desktop-appname-md.md)]应用其中一个耗时的流操作可以阻塞 UI 线程并让你的应用看起来好像不工作。 结合使用异步方法`async`和`await`Visual Basic 和 C# 中的关键字。       使用<xref:System.IO.FileStream.CanRead%2A>属性来确定当前实例是否支持读取。</xref:System.IO.FileStream.CanRead%2A>       如果在完成之前，将取消该操作，返回的任务包含<xref:System.Threading.Tasks.TaskStatus>值<xref:System.Threading.Tasks.Task.Status%2A>属性。</xref:System.Threading.Tasks.Task.Status%2A> </xref:System.Threading.Tasks.TaskStatus> 如果文件句柄将被释放，则返回的任务包含<xref:System.ObjectDisposedException>中的异常<xref:System.Threading.Tasks.Task.Exception%2A>属性。</xref:System.Threading.Tasks.Task.Exception%2A> </xref:System.ObjectDisposedException>"
  example:
  - "The following example shows how to read from a file asynchronously.  \n  \n [!code-vb[Asynchronous_File_IO_async#4](~/add/codesnippet/visualbasic/9c5ba435-5f90-4f89-b415-_1.vb)]\n [!code-cs[Asynchronous_File_IO_async#4](~/add/codesnippet/csharp/9c5ba435-5f90-4f89-b415-_1.cs)]"
  syntax:
    content: public override System.Threading.Tasks.Task<int> ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "要写入到数据的缓冲区。"
    - id: offset
      type: System.Int32
      description: "中的字节偏移量`buffer`从此处开始写入从流读取的数据。"
    - id: count
      type: System.Int32
      description: "最大读取的字节数。"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "要监视取消请求的标记。"
    return:
      type: System.Threading.Tasks.Task{System.Int32}
      description: "一个任务，它表示异步读取操作。 值<code> TResult </code>参数包含读入缓冲区的字节总数。 结果值可能小于请求的字节数的如果当前可用字节数小于所请求的数目，或如果已到达流结尾，它可以是 0 （零）。"
  overload: System.IO.FileStream.ReadAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>或<code>count</code>为负。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "总和<code> offset </code>和<code> count </code>大于缓冲区长度。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "流不支持读取。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已释放流。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "当前正在使用以前的读取操作流。"
  platform:
  - net462
- uid: System.IO.FileStream.ReadByte
  id: ReadByte
  parent: System.IO.FileStream
  langs:
  - csharp
  name: ReadByte()
  nameWithType: FileStream.ReadByte()
  fullName: System.IO.FileStream.ReadByte()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "从文件读取一个字节，并将读取的位置提升一个字节。"
  remarks: "此方法将替代<xref:System.IO.Stream.ReadByte%2A>.</xref:System.IO.Stream.ReadByte%2A>      1> [!NOTE]&1;> 使用<xref:System.IO.FileStream.CanRead%2A>属性来确定当前实例是否支持读取。</xref:System.IO.FileStream.CanRead%2A> 有关其他信息，请参阅<xref:System.IO.Stream.CanRead%2A>。</xref:System.IO.Stream.CanRead%2A>"
  example:
  - "The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.r_0_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.r_0_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.r_0_1.cpp)]"
  syntax:
    content: public override int ReadByte ();
    parameters: []
    return:
      type: System.Int32
      description: "字节，强制转换为<xref:System.Int32>，则为-1 如果已到达流结尾。</xref:System.Int32>"
  overload: System.IO.FileStream.ReadByte*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "当前流不支持读取。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "当前流已关闭。"
  platform:
  - net462
- uid: System.IO.FileStream.SafeFileHandle
  id: SafeFileHandle
  parent: System.IO.FileStream
  langs:
  - csharp
  name: SafeFileHandle
  nameWithType: FileStream.SafeFileHandle
  fullName: System.IO.FileStream.SafeFileHandle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "获取<xref href=&quot;Microsoft.Win32.SafeHandles.SafeFileHandle&quot;></xref>表示该文件的操作系统文件句柄的对象，当前<xref href=&quot;System.IO.FileStream&quot;></xref>对象所封装。"
  remarks: "SafeFileHandle 属性自动刷新流，并将当前流位置设置为 0。  这允许要移动文件或要通过使用此属性返回 SafeFileHandle 的另一个流进行重置的流位置。"
  syntax:
    content: public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }
    return:
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "一个对象，表示该文件的操作系统文件句柄的当前<xref href=&quot;System.IO.FileStream&quot;></xref>对象所封装。"
  overload: System.IO.FileStream.SafeFileHandle*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: FileStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.FileStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "将此流的当前位置设置为给定的值。"
  remarks: "此方法将替代<xref:System.IO.Stream.Seek%2A?displayProperty=fullName>.</xref:System.IO.Stream.Seek%2A?displayProperty=fullName>      1> [!NOTE]&1;> 使用<xref:System.IO.FileStream.CanSeek%2A?displayProperty=fullName>属性来确定当前实例是否支持查找。</xref:System.IO.FileStream.CanSeek%2A?displayProperty=fullName> 有关其他信息，请参阅<xref:System.IO.Stream.CanSeek%2A?displayProperty=fullName>。</xref:System.IO.Stream.CanSeek%2A?displayProperty=fullName>       您可以搜索到流的长度超出任何位置。 当您寻求超出长度的文件时，文件大小就会增加。 在 Windows NT 和更高版本中，添加到文件末尾的数据设置为零。 在 Windows 98 或更早版本中，添加到文件末尾的数据未设置为零，这意味着，先前删除的数据是可见写入流。       通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.s_1_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.s_1_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.s_1_1.cpp)]  \n  \n The following example reads text in the reverse direction, from the end of file to the beginning of the file, by using the various <xref:System.IO.SeekOrigin> values with the Seek method.  \n  \n [!code-vb[System.IO.FileStream.Seek#1](~/add/codesnippet/visualbasic/m-system.io.filestream.s_1_2.vb)]\n [!code-cs[System.IO.FileStream.Seek#1](~/add/codesnippet/csharp/m-system.io.filestream.s_1_2.cs)]"
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "相对于点`origin`从此处开始查找。"
    - id: origin
      type: System.IO.SeekOrigin
      description: "将开始、 结束时或当前位置指定为的参考点`offset`，使用类型<xref:System.IO.SeekOrigin>.</xref:System.IO.SeekOrigin>的值"
    return:
      type: System.Int64
      description: "流中的新位置。"
  overload: System.IO.FileStream.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "发生 I/O 错误。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "流不支持查找，如<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>从管道或控制台输出构造。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "试图在流的开始位置之前。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "在流关闭后调用方法。"
  platform:
  - net462
- uid: System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  id: SetAccessControl(System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: SetAccessControl(FileSecurity)
  nameWithType: FileStream.SetAccessControl(FileSecurity)
  fullName: System.IO.FileStream.SetAccessControl(FileSecurity)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "将访问控制列表 (ACL) 项所描述应用<xref href=&quot;System.Security.AccessControl.FileSecurity&quot;></xref>对象当前所描述的文件<xref href=&quot;System.IO.FileStream&quot;></xref>对象。"
  remarks: "虽然<xref:System.IO.FileStream>类，SetAccessControl 可对现有文件，请考虑使用<xref:System.IO.File.SetAccessControl%2A?displayProperty=fullName>作为它的方法是使用起来更为简便。</xref:System.IO.File.SetAccessControl%2A?displayProperty=fullName> </xref:System.IO.FileStream>       SetAccessControl 方法适用于表示非继承的 ACL 列表的文件的访问控制列表 (ACL) 项。      1> [!CAUTION]&1;> 为 ACL 指定`fileSecurity`参数替换现有文件 ACL。 若要添加的新用户的权限，请使用<xref:System.IO.FileStream.GetAccessControl%2A>方法来获取现有的 ACL，对其进行修改，然后使用 SetAccessControl 以将其应用回文件。</xref:System.IO.FileStream.GetAccessControl%2A>       ACL 描述个人和/或组具有或没有执行到给定的文件上的特定操作的权限。 有关详细信息，请参阅[如何︰ 添加或移除访问控制列表项](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "一个对象，描述要应用于当前文件的 ACL 项。"
  overload: System.IO.FileStream.SetAccessControl*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "文件关闭。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>fileSecurity</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "无法找到或修改该文件。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "当前进程不具有打开该文件的权限。"
  platform:
  - net462
- uid: System.IO.FileStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: FileStream.SetLength(Int64)
  fullName: System.IO.FileStream.SetLength(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "将此流的长度设置为给定的值。"
  remarks: "此方法将替代<xref:System.IO.Stream.SetLength%2A>.</xref:System.IO.Stream.SetLength%2A>       如果给定的值小于当前流的长度，则流将被截断。 在此方案中，如果当前的位置大于的新长度当前位置移至最后一字节的流。 如果给定的值大于当前流的长度，则流扩展，并当前位置保持不变。 如果流已展开，旧和新的长度之间流的内容是不确定的。       流必须支持写入和查找有关`SetLength`工作。      1> [!NOTE]&1;> 使用<xref:System.IO.FileStream.CanWrite%2A>属性来确定当前实例是否支持写入，和<xref:System.IO.FileStream.CanSeek%2A>属性来确定是否支持查找。</xref:System.IO.FileStream.CanSeek%2A> </xref:System.IO.FileStream.CanWrite%2A> 有关其他信息，请参阅<xref:System.IO.Stream.CanWrite%2A>和<xref:System.IO.Stream.CanSeek%2A>.</xref:System.IO.Stream.CanSeek%2A> </xref:System.IO.Stream.CanWrite%2A>       通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "流的新长度。"
  overload: System.IO.FileStream.SetLength*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "发生了 I/O 错误。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "流不支持写入和查找。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "尝试设置<code> value </code>为小于 0 的参数。"
  platform:
  - net462
- uid: System.IO.FileStream.Unlock(System.Int64,System.Int64)
  id: Unlock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Unlock(Int64,Int64)
  nameWithType: FileStream.Unlock(Int64,Int64)
  fullName: System.IO.FileStream.Unlock(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "允许访问以前锁定的文件的全部或部分其他进程。"
  remarks: "通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file, and then unlock the specified part of the file . Run the program simultaneously in different command windows and investigate using the different console input options.  \n  \n [!code-cs[System.IO.FileStream3#1](~/add/codesnippet/csharp/m-system.io.filestream.u_1.cs)]\n [!code-cpp[System.IO.FileStream3#1](~/add/codesnippet/cpp/m-system.io.filestream.u_1.cpp)]\n [!code-vb[System.IO.FileStream3#1](~/add/codesnippet/visualbasic/m-system.io.filestream.u_1.vb)]"
  syntax:
    content: public virtual void Unlock (long position, long length);
    parameters:
    - id: position
      type: System.Int64
      description: "解锁范围的开头。"
    - id: length
      type: System.Int64
      description: "要解锁的范围。"
  overload: System.IO.FileStream.Unlock*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>position</code>或<code>length</code>为负。"
  platform:
  - net462
- uid: System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: FileStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "将字节块写入文件流。"
  remarks: "此方法将替代<xref:System.IO.Stream.Write%2A>.</xref:System.IO.Stream.Write%2A>       `offset`参数指定了中的字节的偏移量`array`（缓冲区索引） 从此处开始复制，和`count`参数指定了将写入到流的字节数。 如果写入操作成功，流的当前位置被高级通过写入的字节数。 如果发生异常，则流的当前位置不变。      1> [!NOTE]&1;> 使用<xref:System.IO.FileStream.CanWrite%2A>属性来确定当前实例是否支持写入。</xref:System.IO.FileStream.CanWrite%2A> 有关其他信息，请参阅<xref:System.IO.Stream.CanWrite%2A>。</xref:System.IO.Stream.CanWrite%2A>       不会中断正在执行的写入操作的线程。 尽管应用程序可能看起来后取消阻止该线程尚未成功运行，但中断会降低应用程序的性能和可靠性。       通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.  \n  \n [!code-cs[System.IO.FileStream3#3](~/add/codesnippet/csharp/m-system.io.filestream.w_1_1.cs)]\n [!code-cpp[System.IO.FileStream3#3](~/add/codesnippet/cpp/m-system.io.filestream.w_1_1.cpp)]\n [!code-vb[System.IO.FileStream3#3](~/add/codesnippet/visualbasic/m-system.io.filestream.w_1_1.vb)]"
  syntax:
    content: public override void Write (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "包含要写入到流数据的缓冲区。"
    - id: offset
      type: System.Int32
      description: "中的从零开始的字节偏移量`array`从此处开始将字节复制到流。"
    - id: count
      type: System.Int32
      description: "最大写入的字节数。"
  overload: System.IO.FileStream.Write*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>offset</code>和<code>count</code>描述中的无效范围<code>array</code>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>或<code>count</code>为负。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurred.  \n  \n \\- or -  \n  \n Another thread may have caused an unexpected change in the position of the operating system's file handle."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "流已关闭。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "当前的流实例不支持写入。"
  platform:
  - net462
- uid: System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "以异步方式将一个字节序列写入当前流，使此流中的当前位置提升写入字节数，并监视取消请求。"
  remarks: "WriteAsync 方法，可在不阻塞主线程的情况下执行占用大量资源的文件操作。 此性能的考虑就特别重要[!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)]应用或[!INCLUDE[desktop_appname](~/add/includes/desktop-appname-md.md)]应用其中一个耗时的流操作可以阻塞 UI 线程并让你的应用看起来好像不工作。 结合使用异步方法`async`和`await`Visual Basic 和 C# 中的关键字。       使用<xref:System.IO.FileStream.CanWrite%2A>属性来确定当前实例是否支持读取。</xref:System.IO.FileStream.CanWrite%2A>       如果在完成之前，将取消该操作，返回的任务包含<xref:System.Threading.Tasks.TaskStatus>值<xref:System.Threading.Tasks.Task.Status%2A>属性。</xref:System.Threading.Tasks.Task.Status%2A> </xref:System.Threading.Tasks.TaskStatus> 如果文件句柄将被释放，则返回的任务包含<xref:System.ObjectDisposedException>中的异常<xref:System.Threading.Tasks.Task.Exception%2A>属性。</xref:System.Threading.Tasks.Task.Exception%2A> </xref:System.ObjectDisposedException>"
  example:
  - "The following example shows how to write asynchronously to a file.  \n  \n [!code-vb[Asynchronous_File_IO_async#3](~/add/codesnippet/visualbasic/7726d527-d678-42ba-9864-_1.vb)]\n [!code-cs[Asynchronous_File_IO_async#3](~/add/codesnippet/csharp/7726d527-d678-42ba-9864-_1.cs)]"
  syntax:
    content: public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "要写入数据的缓冲区。"
    - id: offset
      type: System.Int32
      description: "中的从零开始的字节偏移量`buffer`从此处开始将字节复制到流。"
    - id: count
      type: System.Int32
      description: "最大写入的字节数。"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "要监视取消请求的标记。"
    return:
      type: System.Threading.Tasks.Task
      description: "表示异步写入操作的任务。"
  overload: System.IO.FileStream.WriteAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>或<code>count</code>为负。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "总和<code> offset </code>和<code> count </code>大于缓冲区长度。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "流不支持写入。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已释放流。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "当前正在由前一个写操作使用流。"
  platform:
  - net462
- uid: System.IO.FileStream.WriteByte(System.Byte)
  id: WriteByte(System.Byte)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: WriteByte(Byte)
  nameWithType: FileStream.WriteByte(Byte)
  fullName: System.IO.FileStream.WriteByte(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "将一个字节写入文件流中的当前位置。"
  remarks: "此方法将替代<xref:System.IO.Stream.WriteByte%2A>.</xref:System.IO.Stream.WriteByte%2A>       使用`WriteByte`写入到一个字节`FileStream`有效。 如果流已关闭，或者不可写，则将引发异常。      1> [!NOTE]&1;> 使用<xref:System.IO.FileStream.CanWrite%2A>属性来确定当前实例是否支持写入。</xref:System.IO.FileStream.CanWrite%2A> 有关其他信息，请参阅<xref:System.IO.Stream.CanWrite%2A>。</xref:System.IO.Stream.CanWrite%2A>"
  example:
  - "The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.w_0_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.w_0_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.w_0_1.cpp)]"
  syntax:
    content: public override void WriteByte (byte value);
    parameters:
    - id: value
      type: System.Byte
      description: "要写入到流字节。"
  overload: System.IO.FileStream.WriteByte*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "流已关闭。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "流不支持写入。"
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.DirectoryNotFoundException
  isExternal: true
  name: System.IO.DirectoryNotFoundException
- uid: System.IO.PathTooLongException
  isExternal: true
  name: System.IO.PathTooLongException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.IO.EndOfStreamException
  isExternal: true
  name: System.IO.EndOfStreamException
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(SafeFileHandle,FileAccess)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess)
- uid: Microsoft.Win32.SafeHandles.SafeFileHandle
  parent: Microsoft.Win32.SafeHandles
  isExternal: false
  name: SafeFileHandle
  nameWithType: SafeFileHandle
  fullName: Microsoft.Win32.SafeHandles.SafeFileHandle
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess)
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode)
  nameWithType: FileStream.FileStream(String,FileMode)
  fullName: System.IO.FileStream.FileStream(String,FileMode)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.FileMode
  parent: System.IO
  isExternal: false
  name: FileMode
  nameWithType: FileMode
  fullName: System.IO.FileMode
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(SafeFileHandle,FileAccess,Int32)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess)
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess,Boolean,Int32)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare)
- uid: System.IO.FileShare
  parent: System.IO
  isExternal: false
  name: FileShare
  nameWithType: FileShare
  fullName: System.IO.FileShare
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
- uid: System.IO.FileOptions
  parent: System.IO
  isExternal: false
  name: FileOptions
  nameWithType: FileOptions
  fullName: System.IO.FileOptions
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
- uid: System.Security.AccessControl.FileSystemRights
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSystemRights
  nameWithType: FileSystemRights
  fullName: System.Security.AccessControl.FileSystemRights
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
- uid: System.Security.AccessControl.FileSecurity
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSecurity
  nameWithType: FileSecurity
  fullName: System.Security.AccessControl.FileSecurity
- uid: System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  isExternal: false
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  isExternal: false
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IO.FileStream.CanRead
  parent: System.IO.FileStream
  isExternal: false
  name: CanRead
  nameWithType: FileStream.CanRead
  fullName: System.IO.FileStream.CanRead
- uid: System.IO.FileStream.CanSeek
  parent: System.IO.FileStream
  isExternal: false
  name: CanSeek
  nameWithType: FileStream.CanSeek
  fullName: System.IO.FileStream.CanSeek
- uid: System.IO.FileStream.CanWrite
  parent: System.IO.FileStream
  isExternal: false
  name: CanWrite
  nameWithType: FileStream.CanWrite
  fullName: System.IO.FileStream.CanWrite
- uid: System.IO.FileStream.Dispose(System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: FileStream.Dispose(Boolean)
  fullName: System.IO.FileStream.Dispose(Boolean)
- uid: System.IO.FileStream.EndRead(System.IAsyncResult)
  parent: System.IO.FileStream
  isExternal: false
  name: EndRead(IAsyncResult)
  nameWithType: FileStream.EndRead(IAsyncResult)
  fullName: System.IO.FileStream.EndRead(IAsyncResult)
- uid: System.IO.FileStream.EndWrite(System.IAsyncResult)
  parent: System.IO.FileStream
  isExternal: false
  name: EndWrite(IAsyncResult)
  nameWithType: FileStream.EndWrite(IAsyncResult)
  fullName: System.IO.FileStream.EndWrite(IAsyncResult)
- uid: System.IO.FileStream.Finalize
  parent: System.IO.FileStream
  isExternal: false
  name: Finalize()
  nameWithType: FileStream.Finalize()
  fullName: System.IO.FileStream.Finalize()
- uid: System.IO.FileStream.Flush
  parent: System.IO.FileStream
  isExternal: false
  name: Flush()
  nameWithType: FileStream.Flush()
  fullName: System.IO.FileStream.Flush()
- uid: System.IO.FileStream.Flush(System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: Flush(Boolean)
  nameWithType: FileStream.Flush(Boolean)
  fullName: System.IO.FileStream.Flush(Boolean)
- uid: System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.FileStream
  isExternal: false
  name: FlushAsync(CancellationToken)
  nameWithType: FileStream.FlushAsync(CancellationToken)
  fullName: System.IO.FileStream.FlushAsync(CancellationToken)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.IO.FileStream.GetAccessControl
  parent: System.IO.FileStream
  isExternal: false
  name: GetAccessControl()
  nameWithType: FileStream.GetAccessControl()
  fullName: System.IO.FileStream.GetAccessControl()
- uid: System.IO.FileStream.Handle
  parent: System.IO.FileStream
  isExternal: false
  name: Handle
  nameWithType: FileStream.Handle
  fullName: System.IO.FileStream.Handle
- uid: System.IO.FileStream.IsAsync
  parent: System.IO.FileStream
  isExternal: false
  name: IsAsync
  nameWithType: FileStream.IsAsync
  fullName: System.IO.FileStream.IsAsync
- uid: System.IO.FileStream.Length
  parent: System.IO.FileStream
  isExternal: false
  name: Length
  nameWithType: FileStream.Length
  fullName: System.IO.FileStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.FileStream.Lock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  isExternal: false
  name: Lock(Int64,Int64)
  nameWithType: FileStream.Lock(Int64,Int64)
  fullName: System.IO.FileStream.Lock(Int64,Int64)
- uid: System.IO.FileStream.Name
  parent: System.IO.FileStream
  isExternal: false
  name: Name
  nameWithType: FileStream.Name
  fullName: System.IO.FileStream.Name
- uid: System.IO.FileStream.Position
  parent: System.IO.FileStream
  isExternal: false
  name: Position
  nameWithType: FileStream.Position
  fullName: System.IO.FileStream.Position
- uid: System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: FileStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Read(Byte[],Int32,Int32)
- uid: System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  isExternal: false
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.Threading.Tasks.Task{System.Int32}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<Int32>
  nameWithType: Task<Int32>
  fullName: System.Threading.Tasks.Task<System.Int32>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Int32>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.FileStream.ReadByte
  parent: System.IO.FileStream
  isExternal: false
  name: ReadByte()
  nameWithType: FileStream.ReadByte()
  fullName: System.IO.FileStream.ReadByte()
- uid: System.IO.FileStream.SafeFileHandle
  parent: System.IO.FileStream
  isExternal: false
  name: SafeFileHandle
  nameWithType: FileStream.SafeFileHandle
  fullName: System.IO.FileStream.SafeFileHandle
- uid: System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.FileStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: FileStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.FileStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileStream
  isExternal: false
  name: SetAccessControl(FileSecurity)
  nameWithType: FileStream.SetAccessControl(FileSecurity)
  fullName: System.IO.FileStream.SetAccessControl(FileSecurity)
- uid: System.IO.FileStream.SetLength(System.Int64)
  parent: System.IO.FileStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: FileStream.SetLength(Int64)
  fullName: System.IO.FileStream.SetLength(Int64)
- uid: System.IO.FileStream.Unlock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  isExternal: false
  name: Unlock(Int64,Int64)
  nameWithType: FileStream.Unlock(Int64,Int64)
  fullName: System.IO.FileStream.Unlock(Int64,Int64)
- uid: System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: FileStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Write(Byte[],Int32,Int32)
- uid: System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  isExternal: false
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.IO.FileStream.WriteByte(System.Byte)
  parent: System.IO.FileStream
  isExternal: false
  name: WriteByte(Byte)
  nameWithType: FileStream.WriteByte(Byte)
  fullName: System.IO.FileStream.WriteByte(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.IO.FileStream.#ctor*
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream
  nameWithType: FileStream.FileStream
- uid: System.IO.FileStream.BeginRead*
  parent: System.IO.FileStream
  isExternal: false
  name: BeginRead
  nameWithType: FileStream.BeginRead
- uid: System.IO.FileStream.BeginWrite*
  parent: System.IO.FileStream
  isExternal: false
  name: BeginWrite
  nameWithType: FileStream.BeginWrite
- uid: System.IO.FileStream.CanRead*
  parent: System.IO.FileStream
  isExternal: false
  name: CanRead
  nameWithType: FileStream.CanRead
- uid: System.IO.FileStream.CanSeek*
  parent: System.IO.FileStream
  isExternal: false
  name: CanSeek
  nameWithType: FileStream.CanSeek
- uid: System.IO.FileStream.CanWrite*
  parent: System.IO.FileStream
  isExternal: false
  name: CanWrite
  nameWithType: FileStream.CanWrite
- uid: System.IO.FileStream.Dispose*
  parent: System.IO.FileStream
  isExternal: false
  name: Dispose
  nameWithType: FileStream.Dispose
- uid: System.IO.FileStream.EndRead*
  parent: System.IO.FileStream
  isExternal: false
  name: EndRead
  nameWithType: FileStream.EndRead
- uid: System.IO.FileStream.EndWrite*
  parent: System.IO.FileStream
  isExternal: false
  name: EndWrite
  nameWithType: FileStream.EndWrite
- uid: System.IO.FileStream.Finalize*
  parent: System.IO.FileStream
  isExternal: false
  name: Finalize
  nameWithType: FileStream.Finalize
- uid: System.IO.FileStream.Flush*
  parent: System.IO.FileStream
  isExternal: false
  name: Flush
  nameWithType: FileStream.Flush
- uid: System.IO.FileStream.FlushAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: FlushAsync
  nameWithType: FileStream.FlushAsync
- uid: System.IO.FileStream.GetAccessControl*
  parent: System.IO.FileStream
  isExternal: false
  name: GetAccessControl
  nameWithType: FileStream.GetAccessControl
- uid: System.IO.FileStream.Handle*
  parent: System.IO.FileStream
  isExternal: false
  name: Handle
  nameWithType: FileStream.Handle
- uid: System.IO.FileStream.IsAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: IsAsync
  nameWithType: FileStream.IsAsync
- uid: System.IO.FileStream.Length*
  parent: System.IO.FileStream
  isExternal: false
  name: Length
  nameWithType: FileStream.Length
- uid: System.IO.FileStream.Lock*
  parent: System.IO.FileStream
  isExternal: false
  name: Lock
  nameWithType: FileStream.Lock
- uid: System.IO.FileStream.Name*
  parent: System.IO.FileStream
  isExternal: false
  name: Name
  nameWithType: FileStream.Name
- uid: System.IO.FileStream.Position*
  parent: System.IO.FileStream
  isExternal: false
  name: Position
  nameWithType: FileStream.Position
- uid: System.IO.FileStream.Read*
  parent: System.IO.FileStream
  isExternal: false
  name: Read
  nameWithType: FileStream.Read
- uid: System.IO.FileStream.ReadAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: ReadAsync
  nameWithType: FileStream.ReadAsync
- uid: System.IO.FileStream.ReadByte*
  parent: System.IO.FileStream
  isExternal: false
  name: ReadByte
  nameWithType: FileStream.ReadByte
- uid: System.IO.FileStream.SafeFileHandle*
  parent: System.IO.FileStream
  isExternal: false
  name: SafeFileHandle
  nameWithType: FileStream.SafeFileHandle
- uid: System.IO.FileStream.Seek*
  parent: System.IO.FileStream
  isExternal: false
  name: Seek
  nameWithType: FileStream.Seek
- uid: System.IO.FileStream.SetAccessControl*
  parent: System.IO.FileStream
  isExternal: false
  name: SetAccessControl
  nameWithType: FileStream.SetAccessControl
- uid: System.IO.FileStream.SetLength*
  parent: System.IO.FileStream
  isExternal: false
  name: SetLength
  nameWithType: FileStream.SetLength
- uid: System.IO.FileStream.Unlock*
  parent: System.IO.FileStream
  isExternal: false
  name: Unlock
  nameWithType: FileStream.Unlock
- uid: System.IO.FileStream.Write*
  parent: System.IO.FileStream
  isExternal: false
  name: Write
  nameWithType: FileStream.Write
- uid: System.IO.FileStream.WriteAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: WriteAsync
  nameWithType: FileStream.WriteAsync
- uid: System.IO.FileStream.WriteByte*
  parent: System.IO.FileStream
  isExternal: false
  name: WriteByte
  nameWithType: FileStream.WriteByte
