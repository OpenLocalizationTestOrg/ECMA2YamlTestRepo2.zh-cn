### YamlMime:ManagedReference
items:
- uid: System.Collections.Queue
  id: Queue
  children:
  - System.Collections.Queue.#ctor
  - System.Collections.Queue.#ctor(System.Collections.ICollection)
  - System.Collections.Queue.#ctor(System.Int32)
  - System.Collections.Queue.#ctor(System.Int32,System.Single)
  - System.Collections.Queue.Clear
  - System.Collections.Queue.Clone
  - System.Collections.Queue.Contains(System.Object)
  - System.Collections.Queue.CopyTo(System.Array,System.Int32)
  - System.Collections.Queue.Count
  - System.Collections.Queue.Dequeue
  - System.Collections.Queue.Enqueue(System.Object)
  - System.Collections.Queue.GetEnumerator
  - System.Collections.Queue.IsSynchronized
  - System.Collections.Queue.Peek
  - System.Collections.Queue.Synchronized(System.Collections.Queue)
  - System.Collections.Queue.SyncRoot
  - System.Collections.Queue.ToArray
  - System.Collections.Queue.TrimToSize
  langs:
  - csharp
  name: Queue
  nameWithType: Queue
  fullName: System.Collections.Queue
  type: Class
  summary: "表示对象的第一个中先进先出集合。"
  remarks: "此类实现队列为一个循环的数组。 某一端插入和删除从其他对象存储在队列中。       当你需要为信息; 临时存储时，队列和堆栈非常有用也就是说，当你可能想要检索其值后放弃元素。 如果你需要访问集合中存储的相同顺序的信息，请使用队列。 使用<xref:System.Collections.Stack>如果你需要按相反的顺序访问的信息。</xref:System.Collections.Stack> 使用<xref:System.Collections.Concurrent.ConcurrentQueue%601>或<xref:System.Collections.Concurrent.ConcurrentStack%601>你是否需要同时从多个线程访问集合。</xref:System.Collections.Concurrent.ConcurrentStack%601> </xref:System.Collections.Concurrent.ConcurrentQueue%601>       可以在队列和它的元素上执行三个主要操作:-<xref:System.Collections.Queue.Enqueue%2A>将元素添加到队列的末尾。</xref:System.Collections.Queue.Enqueue%2A>      -<xref:System.Collections.Queue.Dequeue%2A>从队列开头移除最旧的元素。</xref:System.Collections.Queue.Dequeue%2A>      -<xref:System.Collections.Queue.Peek%2A>返回位于队列开头但不会从队列删除它的最旧元素。</xref:System.Collections.Queue.Peek%2A>       队列的容量是队列可容纳的元素数。 当元素添加到队列时，自动增加容量通过重新分配所需的方式。  可以通过调用<xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>减少容量       增长因子是的数是当前容量的乘数需要更大的容量时。  增长因子是在构造队列时确定的。 默认增长因子为 2.0。 队列的容量将始终增加按&4; 的倍数，而不考虑增长因子至少达到了最小值。 例如，具有增长因子 1.0 的队列将始终增加容量由 4 个需要更大的容量时。       队列接受`null`作为有效的值，并允许重复的元素。       此集合的泛型版本，请参阅<xref:System.Collections.Generic.Queue%601?displayProperty=fullName></xref:System.Collections.Generic.Queue%601?displayProperty=fullName>"
  example:
  - "The following example shows how to create and add values to a Queue and how to print out its values.  \n  \n [!code-cs[Classic Queue Example#1](~/add/codesnippet/csharp/t-system.collections.queue_1.cs)]\n [!code-cpp[Classic Queue Example#1](~/add/codesnippet/cpp/t-system.collections.queue_1.cpp)]\n [!code-vb[Classic Queue Example#1](~/add/codesnippet/visualbasic/t-system.collections.queue_1.vb)]"
  syntax:
    content: >-
      [System.Diagnostics.DebuggerDisplay("Count = {Count}")]

      [System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Queue/QueueDebugView))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public class Queue : ICloneable, System.Collections.ICollection
  inheritance:
  - System.Object
  implements:
  - System.Collections.ICollection
  - System.ICloneable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Collections.Queue.#ctor
  id: '#ctor'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue()
  nameWithType: Queue.Queue()
  fullName: System.Collections.Queue.Queue()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化的新实例<xref href=&quot;System.Collections.Queue&quot;></xref>类为空，具有默认初始容量，并使用默认增长因子。"
  remarks: "容量<xref:System.Collections.Queue>是元素的数目<xref:System.Collections.Queue>可以容纳。</xref:System.Collections.Queue> </xref:System.Collections.Queue>  如元素添加到<xref:System.Collections.Queue>，自动增加容量通过重新分配所需的方式。</xref:System.Collections.Queue>  可以通过调用<xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>减少容量       增长因子是的数是当前容量的乘数需要更大的容量时。  确定增长因子时<xref:System.Collections.Queue>构造。</xref:System.Collections.Queue>       此构造函数是 o （1） 操作。"
  syntax:
    content: public Queue ();
    parameters: []
  overload: System.Collections.Queue.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.#ctor(System.Collections.ICollection)
  id: '#ctor(System.Collections.ICollection)'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue(ICollection)
  nameWithType: Queue.Queue(ICollection)
  fullName: System.Collections.Queue.Queue(ICollection)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化的新实例<xref href=&quot;System.Collections.Queue&quot;></xref>类，该类包含从指定集合中复制的元素具有为复制的元素数相同的初始容量并使用默认增长因子。"
  remarks: "容量<xref:System.Collections.Queue>是元素的数目<xref:System.Collections.Queue>可以容纳。</xref:System.Collections.Queue> </xref:System.Collections.Queue>  如元素添加到<xref:System.Collections.Queue>，自动增加容量通过重新分配所需的方式。</xref:System.Collections.Queue>  可以通过调用<xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>减少容量       增长因子是的数是当前容量的乘数需要更大的容量时。  确定增长因子时<xref:System.Collections.Queue>构造。</xref:System.Collections.Queue>       将元素复制到<xref:System.Collections.Queue>它们由<xref:System.Collections.IEnumerator>的<xref:System.Collections.ICollection>。</xref:System.Collections.ICollection></xref:System.Collections.IEnumerator>读取的相同顺序</xref:System.Collections.Queue>       此构造函数是 O (`n`) 操作，其中`n`是中的元素数`col`。"
  syntax:
    content: public Queue (System.Collections.ICollection col);
    parameters:
    - id: col
      type: System.Collections.ICollection
      description: "<xref:System.Collections.ICollection>从中复制元素。</xref:System.Collections.ICollection>"
  overload: System.Collections.Queue.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>col</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Queue.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue(Int32)
  nameWithType: Queue.Queue(Int32)
  fullName: System.Collections.Queue.Queue(Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化的新实例<xref href=&quot;System.Collections.Queue&quot;></xref>类为空，具有指定的初始容量，并使用默认增长因子。"
  remarks: "容量<xref:System.Collections.Queue>是元素的数目<xref:System.Collections.Queue>可以容纳。</xref:System.Collections.Queue> </xref:System.Collections.Queue>  如元素添加到<xref:System.Collections.Queue>，自动增加容量通过重新分配所需的方式。</xref:System.Collections.Queue>  可以通过调用<xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>减少容量       增长因子是的数是当前容量的乘数需要更大的容量时。  确定增长因子时<xref:System.Collections.Queue>构造。</xref:System.Collections.Queue>       如果可以估计集合的大小，指定的初始容量，则无需执行大量的大小将元素添加到<xref:System.Collections.Queue>。</xref:System.Collections.Queue>时调整操作       此构造函数是 O (`n`) 操作，其中`n`是`capacity`。"
  syntax:
    content: public Queue (int capacity);
    parameters:
    - id: capacity
      type: System.Int32
      description: "初始元素数的<xref href=&quot;System.Collections.Queue&quot;></xref>可以包含。"
  overload: System.Collections.Queue.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>小于零。"
  platform:
  - net462
- uid: System.Collections.Queue.#ctor(System.Int32,System.Single)
  id: '#ctor(System.Int32,System.Single)'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue(Int32,Single)
  nameWithType: Queue.Queue(Int32,Single)
  fullName: System.Collections.Queue.Queue(Int32,Single)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化的新实例<xref href=&quot;System.Collections.Queue&quot;></xref>类为空，具有指定的初始容量，并使用指定的增长因子。"
  remarks: "容量<xref:System.Collections.Queue>是元素的数目<xref:System.Collections.Queue>可以容纳。</xref:System.Collections.Queue> </xref:System.Collections.Queue>  如元素添加到<xref:System.Collections.Queue>，自动增加容量通过重新分配所需的方式。</xref:System.Collections.Queue>  可以通过调用<xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>减少容量       增长因子是的数是当前容量的乘数需要更大的容量时。  确定增长因子时<xref:System.Collections.Queue>构造。</xref:System.Collections.Queue> 容量<xref:System.Collections.Queue>始终将增加最小值，而不考虑增长因子; 将不会阻止 1.0 增长因子<xref:System.Collections.Queue>从大小在增加。</xref:System.Collections.Queue> </xref:System.Collections.Queue>       如果可以估计集合的大小，指定的初始容量，则无需执行大量的大小将元素添加到<xref:System.Collections.Queue>。</xref:System.Collections.Queue>时调整操作       此构造函数是 O (`n`) 操作，其中`n`是`capacity`。"
  syntax:
    content: public Queue (int capacity, float growFactor);
    parameters:
    - id: capacity
      type: System.Int32
      description: "初始元素数的<xref href=&quot;System.Collections.Queue&quot;></xref>可以包含。"
    - id: growFactor
      type: System.Single
      description: "因子的容量<xref href=&quot;System.Collections.Queue&quot;></xref>展开。"
  overload: System.Collections.Queue.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>小于零。       -或-<code>growFactor</code>小于 1.0 或大于 10.0。"
  platform:
  - net462
- uid: System.Collections.Queue.Clear
  id: Clear
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Clear()
  nameWithType: Queue.Clear()
  fullName: System.Collections.Queue.Clear()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "删除中的所有对象<xref href=&quot;System.Collections.Queue&quot;> </xref>。"
  remarks: "<xref:System.Collections.Queue.Count%2A>是设置为零，并且集合的元素对其他对象的引用也被释放。</xref:System.Collections.Queue.Count%2A>       容量保持不变。 若要重置<xref:System.Collections.Queue>，请调用<xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A></xref:System.Collections.Queue>容量 截去空<xref:System.Collections.Queue>的容量设置<xref:System.Collections.Queue>到默认的容量。</xref:System.Collections.Queue> </xref:System.Collections.Queue>       此方法为 O (`n`) 操作，其中`n`为<xref:System.Collections.Queue.Count%2A>。</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to clear the values of the <xref:System.Collections.Queue>.  \n  \n [!code-cpp[Classic Queue.Clear Example#1](~/add/codesnippet/cpp/m-system.collections.que_6_1.cpp)]\n [!code-cs[Classic Queue.Clear Example#1](~/add/codesnippet/csharp/m-system.collections.que_6_1.cs)]\n [!code-vb[Classic Queue.Clear Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_6_1.vb)]"
  syntax:
    content: public virtual void Clear ();
    parameters: []
  overload: System.Collections.Queue.Clear*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Clone
  id: Clone
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Clone()
  nameWithType: Queue.Clone()
  fullName: System.Collections.Queue.Clone()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "创建的浅表复制<xref href=&quot;System.Collections.Queue&quot;> </xref>。"
  remarks: "集合的浅表副本复制仅的元素集合，不论它们是引用类型还是值类型，但它不会复制引用所引用的对象。 新集合中的引用都指向原始集合中的引用指向同一对象。       与此相反，集合的深层副本复制这些元素，以及由这些元素直接或间接引用的所有内容。       此方法为 O (`n`) 操作，其中`n`为<xref:System.Collections.Queue.Count%2A>。</xref:System.Collections.Queue.Count%2A>"
  syntax:
    content: public virtual object Clone ();
    parameters: []
    return:
      type: System.Object
      description: "浅表复制<xref href=&quot;System.Collections.Queue&quot;> </xref>。"
  overload: System.Collections.Queue.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Contains(System.Object)
  id: Contains(System.Object)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Contains(Object)
  nameWithType: Queue.Contains(Object)
  fullName: System.Collections.Queue.Contains(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "确定某元素是否在<xref href=&quot;System.Collections.Queue&quot;> </xref>。"
  remarks: "此方法通过调用<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>确定相等性       此方法执行的线性搜索;因此，此方法为 O (`n`) 操作，其中`n`为<xref:System.Collections.Queue.Count%2A>。</xref:System.Collections.Queue.Count%2A>       从.NET Framework 2.0 开始，此方法使用集合的对象<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>上的方法`obj`以确定是否`item`存在。</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> 在.NET Framework 的早期版本，通过进行此决定<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`obj`参数的集合中的对象。</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  syntax:
    content: public virtual bool Contains (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "<xref:System.Object>要在中查找<xref href=&quot;System.Collections.Queue&quot;> </xref>。</xref:System.Object> 该值可以为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>if <code>obj</code> is found in the <xref href=&quot;System.Collections.Queue&quot;></xref>; otherwise, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>."
  overload: System.Collections.Queue.Contains*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.CopyTo(System.Array,System.Int32)
  id: CopyTo(System.Array,System.Int32)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: CopyTo(Array,Int32)
  nameWithType: Queue.CopyTo(Array,Int32)
  fullName: System.Collections.Queue.CopyTo(Array,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "副本<xref href=&quot;System.Collections.Queue&quot;></xref>元素到一个现有的一维<xref:System.Array>指定的数组索引处开始。</xref:System.Array>"
  remarks: "元素被复制到<xref:System.Array>与在其中的枚举数循环访问<xref:System.Collections.Queue>.</xref:System.Collections.Queue>相同的顺序</xref:System.Array>       此方法为 O (`n`) 操作，其中`n`为<xref:System.Collections.Queue.Count%2A>。</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Queue> into a one-dimensional array.  \n  \n [!code-cpp[Classic Queue.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.que_4_1.cpp)]\n [!code-cs[Classic Queue.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.que_4_1.cs)]\n [!code-vb[Classic Queue.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_4_1.vb)]"
  syntax:
    content: public virtual void CopyTo (Array array, int index);
    parameters:
    - id: array
      type: System.Array
      description: "一维<xref:System.Array>，它是从复制的元素的目标<xref href=&quot;System.Collections.Queue&quot;> </xref>。</xref:System.Array> <xref:System.Array>必须具有从零开始的索引。</xref:System.Array>"
    - id: index
      type: System.Int32
      description: "中的从零开始索引`array`复制开始处。"
  overload: System.Collections.Queue.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>小于零。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>是多维的。       -源中的元素的数目<xref href=&quot;System.Collections.Queue&quot;></xref>大于从的可用空间<code>index</code>到目标的末尾<code>array</code>。"
  - type: System.ArrayTypeMismatchException
    commentId: T:System.ArrayTypeMismatchException
    description: "源类型<xref href=&quot;System.Collections.Queue&quot;></xref>无法自动转换为目标的类型<code> array </code>。"
  platform:
  - net462
- uid: System.Collections.Queue.Count
  id: Count
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Count
  nameWithType: Queue.Count
  fullName: System.Collections.Queue.Count
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "获取包含中的元素数<xref href=&quot;System.Collections.Queue&quot;> </xref>。"
  remarks: "容量<xref:System.Collections.Queue>是元素的数目，<xref:System.Collections.Queue>可以存储。</xref:System.Collections.Queue> </xref:System.Collections.Queue> 计数是其实是<xref:System.Collections.Queue>.</xref:System.Collections.Queue>的元素的数目       容量<xref:System.Collections.Queue>始终是大于或等于计数。</xref:System.Collections.Queue> 如果计数超出添加元素时的容量，通过在复制旧元素和添加新的元素之前重新分配在内部数组自动增大容量。 新的容量取决于当前容量乘以增长因子，这是确定何时<xref:System.Collections.Queue>构造。</xref:System.Collections.Queue> 容量<xref:System.Collections.Queue>始终将增加最小值，而不考虑增长因子; 将不会阻止 1.0 增长因子<xref:System.Collections.Queue>从大小在增加。</xref:System.Collections.Queue> </xref:System.Collections.Queue>       可以通过调用<xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>减少容量       检索此属性的值是一个 o （1） 操作。"
  syntax:
    content: public virtual int Count { get; }
    return:
      type: System.Int32
      description: "中包含的元素数<xref href=&quot;System.Collections.Queue&quot;> </xref>。"
  overload: System.Collections.Queue.Count*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Dequeue
  id: Dequeue
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Dequeue()
  nameWithType: Queue.Dequeue()
  fullName: System.Collections.Queue.Dequeue()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "移除并返回的开始处对象<xref href=&quot;System.Collections.Queue&quot;> </xref>。"
  remarks: "此方法类似于<xref:System.Collections.Queue.Peek%2A>方法，但<xref:System.Collections.Queue.Peek%2A>不是会修改<xref:System.Collections.Queue>.</xref:System.Collections.Queue></xref:System.Collections.Queue.Peek%2A></xref:System.Collections.Queue.Peek%2A>是       `null`可以添加到<xref:System.Collections.Queue>作为值。</xref:System.Collections.Queue> 若要区分 null 值和结束<xref:System.Collections.Queue>，检查<xref:System.Collections.Queue.Count%2A>属性或 catch <xref:System.InvalidOperationException>，时引发<xref:System.Collections.Queue>为空。</xref:System.Collections.Queue> </xref:System.InvalidOperationException> </xref:System.Collections.Queue.Count%2A> </xref:System.Collections.Queue>       此方法为 o （1） 运算。"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Queue>, remove elements from the <xref:System.Collections.Queue>, or view the element at the beginning of the <xref:System.Collections.Queue>.  \n  \n [!code-vb[Classic Queue.Enqueue Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_0_1.vb)]\n [!code-cs[Classic Queue.Enqueue Example#1](~/add/codesnippet/csharp/m-system.collections.que_0_1.cs)]\n [!code-cpp[Classic Queue.Enqueue Example#1](~/add/codesnippet/cpp/m-system.collections.que_0_1.cpp)]"
  syntax:
    content: public virtual object Dequeue ();
    parameters: []
    return:
      type: System.Object
      description: "删除从开始处的对象<xref href=&quot;System.Collections.Queue&quot;> </xref>。"
  overload: System.Collections.Queue.Dequeue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Collections.Queue&quot;> </xref>为空。"
  platform:
  - net462
- uid: System.Collections.Queue.Enqueue(System.Object)
  id: Enqueue(System.Object)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Enqueue(Object)
  nameWithType: Queue.Enqueue(Object)
  fullName: System.Collections.Queue.Enqueue(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "将对象添加到的末尾<xref href=&quot;System.Collections.Queue&quot;> </xref>。"
  remarks: "容量<xref:System.Collections.Queue>是元素的数目<xref:System.Collections.Queue>可以容纳。</xref:System.Collections.Queue> </xref:System.Collections.Queue>  如元素添加到<xref:System.Collections.Queue>，自动增加容量通过重新分配所需的方式。</xref:System.Collections.Queue>  可以通过调用<xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>减少容量       增长因子是的数是当前容量的乘数需要更大的容量时。  确定增长因子时<xref:System.Collections.Queue>构造。</xref:System.Collections.Queue> 容量<xref:System.Collections.Queue>始终将增加最小值，而不考虑增长因子; 将不会阻止 1.0 增长因子<xref:System.Collections.Queue>从大小在增加。</xref:System.Collections.Queue> </xref:System.Collections.Queue>       如果<xref:System.Collections.Queue.Count%2A>小于比在内部数组的容量，此方法为 o （1） 运算。</xref:System.Collections.Queue.Count%2A> 如果在内部数组需要可重新分配以容纳新元素，此方法会成为 O (`n`) 操作，其中`n`为<xref:System.Collections.Queue.Count%2A>。</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Queue>, remove elements from the <xref:System.Collections.Queue>, or view the element at the beginning of the <xref:System.Collections.Queue>.  \n  \n [!code-vb[Classic Queue.Enqueue Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_5_1.vb)]\n [!code-cs[Classic Queue.Enqueue Example#1](~/add/codesnippet/csharp/m-system.collections.que_5_1.cs)]\n [!code-cpp[Classic Queue.Enqueue Example#1](~/add/codesnippet/cpp/m-system.collections.que_5_1.cpp)]"
  syntax:
    content: public virtual void Enqueue (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "要添加到对象<xref href=&quot;System.Collections.Queue&quot;> </xref>。 该值可以为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Collections.Queue.Enqueue*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.GetEnumerator
  id: GetEnumerator
  parent: System.Collections.Queue
  langs:
  - csharp
  name: GetEnumerator()
  nameWithType: Queue.GetEnumerator()
  fullName: System.Collections.Queue.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "返回的枚举数循环访问<xref href=&quot;System.Collections.Queue&quot;> </xref>。"
  remarks: "`foreach` C# 语言的语句 (`for each`在 Visual Basic 中) 隐藏了枚举数的复杂性。  因此，使用`foreach`建议，而不是直接操作枚举数。       枚举器可用于读取集合中中的数据，但它们不能用于修改基础集合。       最初，枚举数定位在集合中的第一个元素之前。 <xref:System.Collections.IEnumerator.Reset%2A>此外会回此位置的枚举数。</xref:System.Collections.IEnumerator.Reset%2A>  在此位置上，<xref:System.Collections.IEnumerator.Current%2A>是不确定的。</xref:System.Collections.IEnumerator.Current%2A> 因此，你必须调用<xref:System.Collections.IEnumerator.MoveNext%2A>的第一个元素的集合，然后再读取<xref:System.Collections.IEnumerator.Current%2A>.</xref:System.Collections.IEnumerator.Current%2A>的值枚举器向前移动</xref:System.Collections.IEnumerator.MoveNext%2A>       <xref:System.Collections.IEnumerator.Current%2A>返回相同的对象之前<xref:System.Collections.IEnumerator.MoveNext%2A>或<xref:System.Collections.IEnumerator.Reset%2A>称为。</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>设置<xref:System.Collections.IEnumerator.Current%2A>到下一个元素。</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>       如果<xref:System.Collections.IEnumerator.MoveNext%2A>越过的末尾的集合，枚举数定位在集合中的最后一个元素的后面和<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`。</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> 当枚举器位于此位置上，后续调用<xref:System.Collections.IEnumerator.MoveNext%2A>还返回`false`。</xref:System.Collections.IEnumerator.MoveNext%2A> 如果最后一次调用到<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`，<xref:System.Collections.IEnumerator.Current%2A>是不确定的。</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> 若要设置<xref:System.Collections.IEnumerator.Current%2A>可以再次，集合的第一个元素调用<xref:System.Collections.IEnumerator.Reset%2A>后, 跟<xref:System.Collections.IEnumerator.MoveNext%2A>.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.Current%2A>       只要集合保持不变，枚举数就保持有效。 如果对集合进行更改，如添加、 修改或删除元素，则枚举数将失效且不可恢复，而且其行为是不确定。       枚举数没有对集合; 独占访问权因此，枚举整个集合本质上不是一个线程安全的过程。  若要确保枚举过程中的线程安全性，可以锁定在整个枚举期间的集合。  若要允许访问集合以进行读取和写入的多个线程，则必须实现自己的同步。       此方法为 o （1） 运算。"
  syntax:
    content: public virtual System.Collections.IEnumerator GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: "An <xref:System.Collections.IEnumerator> for the <xref href=&quot;System.Collections.Queue&quot;></xref>.</xref:System.Collections.IEnumerator>"
  overload: System.Collections.Queue.GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.IsSynchronized
  id: IsSynchronized
  parent: System.Collections.Queue
  langs:
  - csharp
  name: IsSynchronized
  nameWithType: Queue.IsSynchronized
  fullName: System.Collections.Queue.IsSynchronized
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "获取一个值，该值指示是否访问<xref href=&quot;System.Collections.Queue&quot;></xref>是同步的 （线程安全）。"
  remarks: "若要确保的线程安全性<xref:System.Collections.Queue>，所有操作必须通过返回的包装器来都完成<xref:System.Collections.Queue.Synchronized%2A>方法。</xref:System.Collections.Queue.Synchronized%2A> </xref:System.Collections.Queue>       枚举整个集合本质上不是一个线程安全的过程。 即使某个集合已同步，其他线程仍可以修改集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改导致的异常。"
  example:
  - "The following code example shows how to lock the collection using the <xref:System.Collections.Queue.SyncRoot%2A> during the entire enumeration. Retrieving the value of this property is an O(1) operation.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/cpp/p-system.collections.que_0_1.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/csharp/p-system.collections.que_0_1.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/visualbasic/p-system.collections.que_0_1.vb)]  \n  \n The following example shows how to synchronize a <xref:System.Collections.Queue>, determine if a <xref:System.Collections.Queue> is synchronized, and use a synchronized <xref:System.Collections.Queue>.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/cpp/p-system.collections.que_0_2.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/csharp/p-system.collections.que_0_2.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/visualbasic/p-system.collections.que_0_2.vb)]"
  syntax:
    content: public virtual bool IsSynchronized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果访问<xref href=&quot;System.Collections.Queue&quot;></xref>是同步的 （线程安全）; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Collections.Queue.IsSynchronized*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Peek
  id: Peek
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Peek()
  nameWithType: Queue.Peek()
  fullName: System.Collections.Queue.Peek()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "返回的开始处对象<xref href=&quot;System.Collections.Queue&quot;></xref>而不删除它。"
  remarks: "此方法类似于<xref:System.Collections.Queue.Dequeue%2A>方法，但扫视不会修改<xref:System.Collections.Queue>.</xref:System.Collections.Queue></xref:System.Collections.Queue.Dequeue%2A>是       `null`可以添加到<xref:System.Collections.Queue>作为值。</xref:System.Collections.Queue> 若要区分 null 值和结束<xref:System.Collections.Queue>，检查<xref:System.Collections.Queue.Count%2A>属性或 catch <xref:System.InvalidOperationException>，时引发<xref:System.Collections.Queue>为空。</xref:System.Collections.Queue> </xref:System.InvalidOperationException> </xref:System.Collections.Queue.Count%2A> </xref:System.Collections.Queue>       此方法为 o （1） 运算。"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Queue>, remove elements from the <xref:System.Collections.Queue>, or view the element at the beginning of the <xref:System.Collections.Queue>.  \n  \n [!code-vb[Classic Queue.Enqueue Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_1_1.vb)]\n [!code-cs[Classic Queue.Enqueue Example#1](~/add/codesnippet/csharp/m-system.collections.que_1_1.cs)]\n [!code-cpp[Classic Queue.Enqueue Example#1](~/add/codesnippet/cpp/m-system.collections.que_1_1.cpp)]"
  syntax:
    content: public virtual object Peek ();
    parameters: []
    return:
      type: System.Object
      description: "开始处对象<xref href=&quot;System.Collections.Queue&quot;> </xref>。"
  overload: System.Collections.Queue.Peek*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Collections.Queue&quot;> </xref>为空。"
  platform:
  - net462
- uid: System.Collections.Queue.Synchronized(System.Collections.Queue)
  id: Synchronized(System.Collections.Queue)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Synchronized(Queue)
  nameWithType: Queue.Synchronized(Queue)
  fullName: System.Collections.Queue.Synchronized(Queue)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "返回一个新<xref href=&quot;System.Collections.Queue&quot;> </xref> ，包装原始队列并且是线程安全。"
  remarks: "此方法返回的包装器锁定队列之前，以便执行以线程安全的方式执行操作。       若要确保的线程安全性<xref:System.Collections.Queue>，所有操作必须通过此包装来都完成。</xref:System.Collections.Queue>       枚举整个集合本质上不是一个线程安全的过程。 即使某个集合已同步，其他线程仍可以修改集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改导致的异常。"
  example:
  - "The following code example shows how to lock the collection using the <xref:System.Collections.Queue.SyncRoot%2A> during the entire enumeration. This method is an O(1) operation.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/cpp/m-system.collections.que_3_1.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/csharp/m-system.collections.que_3_1.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/visualbasic/m-system.collections.que_3_1.vb)]  \n  \n The following example shows how to synchronize a <xref:System.Collections.Queue>, determine if a <xref:System.Collections.Queue> is synchronized and use a synchronized <xref:System.Collections.Queue>.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/cpp/m-system.collections.que_3_2.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/csharp/m-system.collections.que_3_2.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_3_2.vb)]"
  syntax:
    content: public static System.Collections.Queue Synchronized (System.Collections.Queue queue);
    parameters:
    - id: queue
      type: System.Collections.Queue
      description: "<xref href=&quot;System.Collections.Queue&quot;> </xref>进行同步。"
    return:
      type: System.Collections.Queue
      description: "A <xref href=&quot;System.Collections.Queue&quot;> </xref>同步 （线程安全） 的包装。"
  overload: System.Collections.Queue.Synchronized*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>queue</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Queue.SyncRoot
  id: SyncRoot
  parent: System.Collections.Queue
  langs:
  - csharp
  name: SyncRoot
  nameWithType: Queue.SyncRoot
  fullName: System.Collections.Queue.SyncRoot
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "获取可以用于对访问进行同步的对象<xref href=&quot;System.Collections.Queue&quot;> </xref>。"
  remarks: "若要创建的同步的版本<xref:System.Collections.Queue>，使用<xref:System.Collections.Queue.Synchronized%2A>方法。</xref:System.Collections.Queue.Synchronized%2A> </xref:System.Collections.Queue> 但是，派生的类可以提供自己的同步的版本<xref:System.Collections.Queue>使用 SyncRoot 属性。</xref:System.Collections.Queue> 同步代码必须对执行操作的 SyncRoot <xref:System.Collections.Queue>，不是直接对<xref:System.Collections.Queue>.</xref:System.Collections.Queue> </xref:System.Collections.Queue> 这可确保正确地执行操作的从其他对象派生的集合。 具体地说，这样可保持正确的同步，与可能同时对修改其他线程<xref:System.Collections.Queue>对象。</xref:System.Collections.Queue>       枚举整个集合本质上不是一个线程安全的过程。 即使某个集合已同步，其他线程仍可以修改集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改导致的异常。"
  example:
  - "The following code example shows how to lock the collection using the SyncRoot during the entire enumeration. Retrieving the value of this property is an O(1) operation.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/cpp/p-system.collections.que_1_1.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/csharp/p-system.collections.que_1_1.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/visualbasic/p-system.collections.que_1_1.vb)]"
  syntax:
    content: public virtual object SyncRoot { get; }
    return:
      type: System.Object
      description: "可以用于对访问进行同步的对象<xref href=&quot;System.Collections.Queue&quot;> </xref>。"
  overload: System.Collections.Queue.SyncRoot*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.ToArray
  id: ToArray
  parent: System.Collections.Queue
  langs:
  - csharp
  name: ToArray()
  nameWithType: Queue.ToArray()
  fullName: System.Collections.Queue.ToArray()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "副本<xref href=&quot;System.Collections.Queue&quot;></xref>到新数组的元素。"
  remarks: "<xref:System.Collections.Queue>则不会修改。</xref:System.Collections.Queue> 新数组中元素的顺序是从开始处的元素的顺序相同<xref:System.Collections.Queue>到其最终。</xref:System.Collections.Queue>       此方法为 O (`n`) 操作，其中`n`为<xref:System.Collections.Queue.Count%2A>。</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Queue> into a one-dimensional array.  \n  \n [!code-cpp[Classic Queue.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.que_2_1.cpp)]\n [!code-cs[Classic Queue.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.que_2_1.cs)]\n [!code-vb[Classic Queue.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_2_1.vb)]"
  syntax:
    content: public virtual object[] ToArray ();
    parameters: []
    return:
      type: System.Object[]
      description: "新数组包含从复制的元素<xref href=&quot;System.Collections.Queue&quot;> </xref>。"
  overload: System.Collections.Queue.ToArray*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.TrimToSize
  id: TrimToSize
  parent: System.Collections.Queue
  langs:
  - csharp
  name: TrimToSize()
  nameWithType: Queue.TrimToSize()
  fullName: System.Collections.Queue.TrimToSize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "将容量设置中的元素的实际数目<xref href=&quot;System.Collections.Queue&quot;> </xref>。"
  remarks: "此方法可以用于降低队列的内存开销，如果没有新的元素将添加到队列。       若要重置<xref:System.Collections.Queue>为其初始状态，请在调用<xref:System.Collections.Queue.Clear%2A>方法之前调用 TrimToSize。</xref:System.Collections.Queue.Clear%2A> </xref:System.Collections.Queue> 截去空<xref:System.Collections.Queue>的容量设置<xref:System.Collections.Queue>到默认的容量。</xref:System.Collections.Queue> </xref:System.Collections.Queue>       此方法为 O (`n`) 操作，其中`n`为<xref:System.Collections.Queue.Count%2A>。</xref:System.Collections.Queue.Count%2A>"
  syntax:
    content: public virtual void TrimToSize ();
    parameters: []
  overload: System.Collections.Queue.TrimToSize*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.Queue&quot;> </xref>是只读的。"
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArrayTypeMismatchException
  isExternal: true
  name: System.ArrayTypeMismatchException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.Collections.Queue.#ctor
  parent: System.Collections.Queue
  isExternal: false
  name: Queue()
  nameWithType: Queue.Queue()
  fullName: System.Collections.Queue.Queue()
- uid: System.Collections.Queue.#ctor(System.Collections.ICollection)
  parent: System.Collections.Queue
  isExternal: false
  name: Queue(ICollection)
  nameWithType: Queue.Queue(ICollection)
  fullName: System.Collections.Queue.Queue(ICollection)
- uid: System.Collections.ICollection
  parent: System.Collections
  isExternal: true
  name: ICollection
  nameWithType: ICollection
  fullName: System.Collections.ICollection
- uid: System.Collections.Queue.#ctor(System.Int32)
  parent: System.Collections.Queue
  isExternal: false
  name: Queue(Int32)
  nameWithType: Queue.Queue(Int32)
  fullName: System.Collections.Queue.Queue(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Collections.Queue.#ctor(System.Int32,System.Single)
  parent: System.Collections.Queue
  isExternal: false
  name: Queue(Int32,Single)
  nameWithType: Queue.Queue(Int32,Single)
  fullName: System.Collections.Queue.Queue(Int32,Single)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: System.Collections.Queue.Clear
  parent: System.Collections.Queue
  isExternal: false
  name: Clear()
  nameWithType: Queue.Clear()
  fullName: System.Collections.Queue.Clear()
- uid: System.Collections.Queue.Clone
  parent: System.Collections.Queue
  isExternal: false
  name: Clone()
  nameWithType: Queue.Clone()
  fullName: System.Collections.Queue.Clone()
- uid: System.Collections.Queue.Contains(System.Object)
  parent: System.Collections.Queue
  isExternal: false
  name: Contains(Object)
  nameWithType: Queue.Contains(Object)
  fullName: System.Collections.Queue.Contains(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Collections.Queue.CopyTo(System.Array,System.Int32)
  parent: System.Collections.Queue
  isExternal: false
  name: CopyTo(Array,Int32)
  nameWithType: Queue.CopyTo(Array,Int32)
  fullName: System.Collections.Queue.CopyTo(Array,Int32)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: System.Collections.Queue.Count
  parent: System.Collections.Queue
  isExternal: false
  name: Count
  nameWithType: Queue.Count
  fullName: System.Collections.Queue.Count
- uid: System.Collections.Queue.Dequeue
  parent: System.Collections.Queue
  isExternal: false
  name: Dequeue()
  nameWithType: Queue.Dequeue()
  fullName: System.Collections.Queue.Dequeue()
- uid: System.Collections.Queue.Enqueue(System.Object)
  parent: System.Collections.Queue
  isExternal: false
  name: Enqueue(Object)
  nameWithType: Queue.Enqueue(Object)
  fullName: System.Collections.Queue.Enqueue(Object)
- uid: System.Collections.Queue.GetEnumerator
  parent: System.Collections.Queue
  isExternal: false
  name: GetEnumerator()
  nameWithType: Queue.GetEnumerator()
  fullName: System.Collections.Queue.GetEnumerator()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Collections.Queue.IsSynchronized
  parent: System.Collections.Queue
  isExternal: false
  name: IsSynchronized
  nameWithType: Queue.IsSynchronized
  fullName: System.Collections.Queue.IsSynchronized
- uid: System.Collections.Queue.Peek
  parent: System.Collections.Queue
  isExternal: false
  name: Peek()
  nameWithType: Queue.Peek()
  fullName: System.Collections.Queue.Peek()
- uid: System.Collections.Queue.Synchronized(System.Collections.Queue)
  parent: System.Collections.Queue
  isExternal: false
  name: Synchronized(Queue)
  nameWithType: Queue.Synchronized(Queue)
  fullName: System.Collections.Queue.Synchronized(Queue)
- uid: System.Collections.Queue
  parent: System.Collections
  isExternal: false
  name: Queue
  nameWithType: Queue
  fullName: System.Collections.Queue
- uid: System.Collections.Queue.SyncRoot
  parent: System.Collections.Queue
  isExternal: false
  name: SyncRoot
  nameWithType: Queue.SyncRoot
  fullName: System.Collections.Queue.SyncRoot
- uid: System.Collections.Queue.ToArray
  parent: System.Collections.Queue
  isExternal: false
  name: ToArray()
  nameWithType: Queue.ToArray()
  fullName: System.Collections.Queue.ToArray()
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Collections.Queue.TrimToSize
  parent: System.Collections.Queue
  isExternal: false
  name: TrimToSize()
  nameWithType: Queue.TrimToSize()
  fullName: System.Collections.Queue.TrimToSize()
- uid: System.Collections.Queue.#ctor*
  parent: System.Collections.Queue
  isExternal: false
  name: Queue
  nameWithType: Queue.Queue
- uid: System.Collections.Queue.Clear*
  parent: System.Collections.Queue
  isExternal: false
  name: Clear
  nameWithType: Queue.Clear
- uid: System.Collections.Queue.Clone*
  parent: System.Collections.Queue
  isExternal: false
  name: Clone
  nameWithType: Queue.Clone
- uid: System.Collections.Queue.Contains*
  parent: System.Collections.Queue
  isExternal: false
  name: Contains
  nameWithType: Queue.Contains
- uid: System.Collections.Queue.CopyTo*
  parent: System.Collections.Queue
  isExternal: false
  name: CopyTo
  nameWithType: Queue.CopyTo
- uid: System.Collections.Queue.Count*
  parent: System.Collections.Queue
  isExternal: false
  name: Count
  nameWithType: Queue.Count
- uid: System.Collections.Queue.Dequeue*
  parent: System.Collections.Queue
  isExternal: false
  name: Dequeue
  nameWithType: Queue.Dequeue
- uid: System.Collections.Queue.Enqueue*
  parent: System.Collections.Queue
  isExternal: false
  name: Enqueue
  nameWithType: Queue.Enqueue
- uid: System.Collections.Queue.GetEnumerator*
  parent: System.Collections.Queue
  isExternal: false
  name: GetEnumerator
  nameWithType: Queue.GetEnumerator
- uid: System.Collections.Queue.IsSynchronized*
  parent: System.Collections.Queue
  isExternal: false
  name: IsSynchronized
  nameWithType: Queue.IsSynchronized
- uid: System.Collections.Queue.Peek*
  parent: System.Collections.Queue
  isExternal: false
  name: Peek
  nameWithType: Queue.Peek
- uid: System.Collections.Queue.Synchronized*
  parent: System.Collections.Queue
  isExternal: false
  name: Synchronized
  nameWithType: Queue.Synchronized
- uid: System.Collections.Queue.SyncRoot*
  parent: System.Collections.Queue
  isExternal: false
  name: SyncRoot
  nameWithType: Queue.SyncRoot
- uid: System.Collections.Queue.ToArray*
  parent: System.Collections.Queue
  isExternal: false
  name: ToArray
  nameWithType: Queue.ToArray
- uid: System.Collections.Queue.TrimToSize*
  parent: System.Collections.Queue
  isExternal: false
  name: TrimToSize
  nameWithType: Queue.TrimToSize
