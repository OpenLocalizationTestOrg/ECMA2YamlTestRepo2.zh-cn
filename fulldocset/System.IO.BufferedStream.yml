### YamlMime:ManagedReference
items:
- uid: System.IO.BufferedStream
  id: BufferedStream
  children:
  - System.IO.BufferedStream.#ctor(System.IO.Stream)
  - System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)
  - System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.BufferedStream.CanRead
  - System.IO.BufferedStream.CanSeek
  - System.IO.BufferedStream.CanWrite
  - System.IO.BufferedStream.Dispose(System.Boolean)
  - System.IO.BufferedStream.EndRead(System.IAsyncResult)
  - System.IO.BufferedStream.EndWrite(System.IAsyncResult)
  - System.IO.BufferedStream.Flush
  - System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)
  - System.IO.BufferedStream.Length
  - System.IO.BufferedStream.Position
  - System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.BufferedStream.ReadByte
  - System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.IO.BufferedStream.SetLength(System.Int64)
  - System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.BufferedStream.WriteByte(System.Byte)
  langs:
  - csharp
  name: BufferedStream
  nameWithType: BufferedStream
  fullName: System.IO.BufferedStream
  type: Class
  summary: "添加缓冲层以读取和写入另一个流上的操作。 此类不能被继承。"
  remarks: "A buffer is a block of bytes in memory used to cache data, thereby reducing the number of calls to the operating system. Buffers improve read and write performance. A buffer can be used for either reading or writing, but never both simultaneously. The [Read(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True) and [Write(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True) methods of `BufferedStream` automatically maintain the buffer.  \n  \n> [!IMPORTANT]\n>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  \n  \n `BufferedStream` can be composed around certain types of streams. It provides implementations for reading and writing bytes to an underlying data source or repository. Use <xref:System.IO.BinaryReader> and <xref:System.IO.BinaryWriter> for reading and writing other data types. `BufferedStream` is designed to prevent the buffer from slowing down input and output when the buffer is not needed. If you always read and write for sizes greater than the internal buffer size, then `BufferedStream` might not even allocate the internal buffer. `BufferedStream` also buffers reads and writes in a shared buffer. It is assumed that you will almost always be doing a series of reads or writes, but rarely alternate between the two of them."
  example:
  - "The following code examples show how to use the `BufferedStream` class over the `NetworkStream` class to increase the performance of certain I/O operations. Start the server on a remote computer before starting the client. Specify the remote computer name as a command-line argument when starting the client. Vary the `dataArraySize` and `streamBufferSize` constants to view their effect on performance.  \n  \n The first example shows the code that runs on the client, and the second example shows the code that runs on the server.  \n  \n **Example 1: Code that runs on the client**  \n  \n [!code-cs[System.IO.BufferedStream1#1](~/add/codesnippet/csharp/t-system.io.bufferedstream_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#1](~/add/codesnippet/cpp/t-system.io.bufferedstream_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#1](~/add/codesnippet/visualbasic/t-system.io.bufferedstream_1.vb)]  \n  \n **Example 2: Code that runs on the server**  \n  \n [!code-vb[System.IO.BufferedStream2#1](~/add/codesnippet/visualbasic/t-system.io.bufferedstream_2.vb)]\n [!code-cs[System.IO.BufferedStream2#1](~/add/codesnippet/csharp/t-system.io.bufferedstream_2.cs)]\n [!code-cpp[System.IO.BufferedStream2#1](~/add/codesnippet/cpp/t-system.io.bufferedstream_2.cpp)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class BufferedStream : System.IO.Stream
  inheritance:
  - System.IO.Stream
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.BufferedStream.#ctor(System.IO.Stream)
  id: '#ctor(System.IO.Stream)'
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: BufferedStream(Stream)
  nameWithType: BufferedStream.BufferedStream(Stream)
  fullName: System.IO.BufferedStream.BufferedStream(Stream)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新实例<xref href=&quot;System.IO.BufferedStream&quot;></xref>默认缓冲区大小 （4096 字节） 的类。"
  remarks: "共享的读/写缓冲区分配第一次`BufferedStream`使用此构造函数初始化对象。 如果所有读取和写入都都大于或等于，则不会使用共享的缓冲`bufferSize`。"
  syntax:
    content: public BufferedStream (System.IO.Stream stream);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "当前流中。"
  overload: System.IO.BufferedStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>stream</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)
  id: '#ctor(System.IO.Stream,System.Int32)'
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: BufferedStream(Stream,Int32)
  nameWithType: BufferedStream.BufferedStream(Stream,Int32)
  fullName: System.IO.BufferedStream.BufferedStream(Stream,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新实例<xref href=&quot;System.IO.BufferedStream&quot;></xref>类具有指定的缓冲区大小。"
  remarks: "共享的读/写缓冲区分配第一次`BufferedStream`使用此构造函数初始化对象。 如果所有读取和写入都都大于或等于，则不会使用共享的缓冲`bufferSize`。"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#2](~/add/codesnippet/csharp/m-system.io.bufferedstre_2_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#2](~/add/codesnippet/cpp/m-system.io.bufferedstre_2_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#2](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_2_1.vb)]"
  syntax:
    content: public BufferedStream (System.IO.Stream stream, int bufferSize);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "当前流中。"
    - id: bufferSize
      type: System.Int32
      description: "缓冲区大小 （字节）。"
  overload: System.IO.BufferedStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>stream</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>为负数。"
  platform:
  - net462
- uid: System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "开始异步读的操作。 (考虑使用<xref:System.IO.BufferedStream.ReadAsync*>替换; 请参见备注部分。)</xref:System.IO.BufferedStream.ReadAsync*>"
  remarks: "在.NET Framework 4 和更早版本中，你必须使用方法，如<xref:System.IO.Stream.BeginRead%2A>和<xref:System.IO.Stream.EndRead%2A>来实现异步文件操作。</xref:System.IO.Stream.EndRead%2A> </xref:System.IO.Stream.BeginRead%2A> 这些方法是在中仍然可用[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]以支持旧版代码; 但是，新的异步方法，如<xref:System.IO.BufferedStream.ReadAsync%2A>， <xref:System.IO.BufferedStream.WriteAsync%2A>，和<xref:System.IO.BufferedStream.FlushAsync%2A>，帮助你更轻松地实现异步文件操作。</xref:System.IO.BufferedStream.FlushAsync%2A> </xref:System.IO.BufferedStream.WriteAsync%2A> </xref:System.IO.BufferedStream.ReadAsync%2A>       <xref:System.IO.BufferedStream.EndWrite%2A>必须为 BeginRead 每次调用一次调用。</xref:System.IO.BufferedStream.EndWrite%2A> 如果在开始另一个读取之前，结束读取的进程可能会导致意外行为，如死锁。      1> [!NOTE]&1;> 使用<xref:System.IO.BufferedStream.CanRead%2A>属性来确定当前实例是否支持读取。</xref:System.IO.BufferedStream.CanRead%2A>       <xref:System.IO.BufferedStream.EndRead%2A>必须与此调用<xref:System.IAsyncResult>若要了解已读取的字节。</xref:System.IAsyncResult></xref:System.IO.BufferedStream.EndRead%2A>"
  syntax:
    content: public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "要将数据读入的缓冲区。"
    - id: offset
      type: System.Int32
      description: "中的字节偏移量`buffer`从此处开始写入从流中读取的数据。"
    - id: count
      type: System.Int32
      description: "最大读取的字节数。"
    - id: callback
      type: System.AsyncCallback
      description: "可选的异步回调，以完成读取时调用。"
    - id: state
      type: System.Object
      description: "用户提供的对象，用于区分此特定的异步读取请求与其他请求。"
    return:
      type: System.IAsyncResult
      description: "表示异步读取可能仍处于挂起状态的对象。"
  overload: System.IO.BufferedStream.BeginRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>或<code>count</code>为负。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "尝试超出末尾的流的异步读取。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "缓冲区长度减去<code> offset </code>是小于<code> count </code>。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "当前流不支持读取的操作。"
  platform:
  - net462
- uid: System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "开始异步写操作。 (考虑使用<xref:System.IO.BufferedStream.WriteAsync*>替换; 请参见备注部分。)</xref:System.IO.BufferedStream.WriteAsync*>"
  remarks: "在.NET Framework 4 和更早版本中，你必须使用方法，如<xref:System.IO.Stream.BeginWrite%2A>和<xref:System.IO.Stream.EndWrite%2A>来实现异步文件操作。</xref:System.IO.Stream.EndWrite%2A> </xref:System.IO.Stream.BeginWrite%2A> 这些方法是在中仍然可用[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]以支持旧版代码; 但是，新的异步方法，如<xref:System.IO.BufferedStream.ReadAsync%2A>， <xref:System.IO.BufferedStream.WriteAsync%2A>，和<xref:System.IO.BufferedStream.FlushAsync%2A>，帮助你更轻松地实现异步文件操作。</xref:System.IO.BufferedStream.FlushAsync%2A> </xref:System.IO.BufferedStream.WriteAsync%2A> </xref:System.IO.BufferedStream.ReadAsync%2A>       <xref:System.IO.BufferedStream.EndWrite%2A>必须在上一次调用每个<xref:System.IAsyncResult>调用从。</xref:System.IAsyncResult></xref:System.IO.BufferedStream.EndWrite%2A> <xref:System.IO.BufferedStream.EndWrite%2A>将阻止，直到 I/O 操作已完成。</xref:System.IO.BufferedStream.EndWrite%2A>"
  syntax:
    content: public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "包含要写入当前流数据的缓冲区。"
    - id: offset
      type: System.Int32
      description: "中的从零开始的字节偏移量`buffer`从此处开始将字节复制到当前流。"
    - id: count
      type: System.Int32
      description: "最大写入的字节数。"
    - id: callback
      type: System.AsyncCallback
      description: "异步写操作完成时调用的方法。"
    - id: state
      type: System.Object
      description: "一个用户提供的对象，它将此特定的异步写入请求与其他请求区别开来。"
    return:
      type: System.IAsyncResult
      description: "一个引用异步写入可能仍处于挂起状态的对象。"
  overload: System.IO.BufferedStream.BeginWrite*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>buffer</code>长度减去<code>offset</code>是小于<code>count</code>。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>或<code>count</code>为负。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "流不支持写入。"
  platform:
  - net462
- uid: System.IO.BufferedStream.CanRead
  id: CanRead
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: CanRead
  nameWithType: BufferedStream.CanRead
  fullName: System.IO.BufferedStream.CanRead
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "获取一个值，该值指示当前流是否支持读取。"
  remarks: "如果从派生的类<xref:System.IO.Stream>不支持读取，则调用<xref:System.IO.BufferedStream.Read%2A>， <xref:System.IO.BufferedStream.ReadByte%2A>， <xref:System.IO.Stream.BeginRead%2A>， <xref:System.IO.Stream.EndRead%2A>，和`Peek`方法<xref:System.IO.StreamReader>， <xref:System.IO.StringReader>，并<xref:System.IO.TextReader>引发一种<xref:System.NotSupportedException>。</xref:System.NotSupportedException> </xref:System.IO.TextReader> </xref:System.IO.StringReader> </xref:System.IO.StreamReader> </xref:System.IO.Stream.EndRead%2A> </xref:System.IO.Stream.BeginRead%2A> </xref:System.IO.BufferedStream.ReadByte%2A> </xref:System.IO.BufferedStream.Read%2A> </xref:System.IO.Stream>       如果流已关闭，则此属性返回`false`。"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#5](~/add/codesnippet/csharp/p-system.io.bufferedstre_2_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#5](~/add/codesnippet/cpp/p-system.io.bufferedstre_2_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#5](~/add/codesnippet/visualbasic/p-system.io.bufferedstre_2_1.vb)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果流支持读取;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>如果流已关闭或是通过只写访问方式打开。"
  overload: System.IO.BufferedStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.IO.BufferedStream.CanSeek
  id: CanSeek
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: BufferedStream.CanSeek
  fullName: System.IO.BufferedStream.CanSeek
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "获取一个值，该值指示当前流是否支持查找。"
  remarks: "如果从派生的类<xref:System.IO.Stream>不支持查找，则调用<xref:System.IO.BufferedStream.Length%2A>， <xref:System.IO.BufferedStream.SetLength%2A>， <xref:System.IO.BufferedStream.Position%2A>，并<xref:System.IO.BufferedStream.Seek%2A>引发一种<xref:System.NotSupportedException>。</xref:System.NotSupportedException> </xref:System.IO.BufferedStream.Seek%2A> </xref:System.IO.BufferedStream.Position%2A> </xref:System.IO.BufferedStream.SetLength%2A> </xref:System.IO.BufferedStream.Length%2A> </xref:System.IO.Stream>       如果流已关闭，则此属性返回`false`。"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#3](~/add/codesnippet/csharp/p-system.io.bufferedstre_0_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#3](~/add/codesnippet/cpp/p-system.io.bufferedstre_0_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#3](~/add/codesnippet/visualbasic/p-system.io.bufferedstre_0_1.vb)]"
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果流支持查找;，<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>如果流已关闭或者如果流已从构造的操作系统句柄如管道或输出到控制台。"
  overload: System.IO.BufferedStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.IO.BufferedStream.CanWrite
  id: CanWrite
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: BufferedStream.CanWrite
  fullName: System.IO.BufferedStream.CanWrite
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "获取一个值，该值指示当前流是否支持写入。"
  remarks: "如果从派生的类<xref:System.IO.Stream>不支持写入，调用<xref:System.IO.BufferedStream.SetLength%2A>， <xref:System.IO.BufferedStream.Write%2A>，或<xref:System.IO.BufferedStream.WriteByte%2A>引发一种<xref:System.NotSupportedException>。</xref:System.NotSupportedException> </xref:System.IO.BufferedStream.WriteByte%2A> </xref:System.IO.BufferedStream.Write%2A> </xref:System.IO.BufferedStream.SetLength%2A> </xref:System.IO.Stream>       如果流已关闭，则此属性返回`false`。"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#4](~/add/codesnippet/csharp/p-system.io.bufferedstre_1_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#4](~/add/codesnippet/cpp/p-system.io.bufferedstre_1_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#4](~/add/codesnippet/visualbasic/p-system.io.bufferedstre_1_1.vb)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果流支持写入，则<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>如果流已关闭或是通过只读访问方式打开。"
  overload: System.IO.BufferedStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.IO.BufferedStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: BufferedStream.Dispose(Boolean)
  fullName: System.IO.BufferedStream.Dispose(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "要添加。"
  overload: System.IO.BufferedStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.IO.BufferedStream.EndRead(System.IAsyncResult)
  id: EndRead(System.IAsyncResult)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: EndRead(IAsyncResult)
  nameWithType: BufferedStream.EndRead(IAsyncResult)
  fullName: System.IO.BufferedStream.EndRead(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "等待挂起的异步读取操作完成。 (考虑使用<xref:System.IO.BufferedStream.ReadAsync*>替换; 请参见备注部分。)</xref:System.IO.BufferedStream.ReadAsync*>"
  remarks: "在.NET Framework 4 和更早版本中，你必须使用方法，如<xref:System.IO.Stream.BeginRead%2A>和<xref:System.IO.Stream.EndRead%2A>来实现异步文件操作。</xref:System.IO.Stream.EndRead%2A> </xref:System.IO.Stream.BeginRead%2A> 这些方法是在中仍然可用[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]以支持旧版代码; 但是，新的异步方法，如<xref:System.IO.BufferedStream.ReadAsync%2A>， <xref:System.IO.BufferedStream.WriteAsync%2A>，和<xref:System.IO.BufferedStream.FlushAsync%2A>，帮助你更轻松地实现异步文件操作。</xref:System.IO.BufferedStream.FlushAsync%2A> </xref:System.IO.BufferedStream.WriteAsync%2A> </xref:System.IO.BufferedStream.ReadAsync%2A>       必须与此调用 EndRead<xref:System.IAsyncResult>若要了解已读取的字节。</xref:System.IAsyncResult>"
  syntax:
    content: public override int EndRead (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "对要等待的挂起异步请求的引用。"
    return:
      type: System.Int32
      description: "从 0 （零） 和你请求的字节数之间的流中读取的字节数。 流仅返回 0 仅在流结尾，否则，它们应一直进行阻止至少 1 个字节可用。"
  overload: System.IO.BufferedStream.EndRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "此<xref:System.IAsyncResult>对象不通过调用<xref:System.IO.BufferedStream.BeginRead*>此类</xref:System.IO.BufferedStream.BeginRead*>创建</xref:System.IAsyncResult>"
  platform:
  - net462
- uid: System.IO.BufferedStream.EndWrite(System.IAsyncResult)
  id: EndWrite(System.IAsyncResult)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: EndWrite(IAsyncResult)
  nameWithType: BufferedStream.EndWrite(IAsyncResult)
  fullName: System.IO.BufferedStream.EndWrite(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "结束异步写操作和块，直到 I/O 操作已完成。 (考虑使用<xref:System.IO.BufferedStream.WriteAsync*>替换; 请参见备注部分。)</xref:System.IO.BufferedStream.WriteAsync*>"
  remarks: "在.NET Framework 4 和更早版本中，你必须使用方法，如<xref:System.IO.Stream.BeginWrite%2A>和<xref:System.IO.Stream.EndWrite%2A>来实现异步文件操作。</xref:System.IO.Stream.EndWrite%2A> </xref:System.IO.Stream.BeginWrite%2A> 这些方法是在中仍然可用[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]以支持旧版代码; 但是，新的异步方法，如<xref:System.IO.BufferedStream.ReadAsync%2A>， <xref:System.IO.BufferedStream.WriteAsync%2A>，和<xref:System.IO.BufferedStream.FlushAsync%2A>，帮助你更轻松地实现异步文件操作。</xref:System.IO.BufferedStream.FlushAsync%2A> </xref:System.IO.BufferedStream.WriteAsync%2A> </xref:System.IO.BufferedStream.ReadAsync%2A>       必须为<xref:System.IO.BufferedStream.BeginRead%2A>.</xref:System.IO.BufferedStream.BeginRead%2A>每次调用一次调用 EndWrite 如果结束一个读取的进程在开始之前另一个读取的操作可能会导致死锁或其他意外行为。"
  syntax:
    content: public override void EndWrite (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "挂起的异步请求。"
  overload: System.IO.BufferedStream.EndWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "此<xref:System.IAsyncResult>对象不通过调用<xref:System.IO.BufferedStream.BeginWrite*>此类</xref:System.IO.BufferedStream.BeginWrite*>创建</xref:System.IAsyncResult>"
  platform:
  - net462
- uid: System.IO.BufferedStream.Flush
  id: Flush
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Flush()
  nameWithType: BufferedStream.Flush()
  fullName: System.IO.BufferedStream.Flush()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "清除此流的所有缓冲区，使得所有缓冲的数据都写入基础设备。"
  remarks: "刷新流将不会刷新其基础的编码器，除非你明确地调用`Flush`或<xref:System.IO.Stream.Close%2A>。</xref:System.IO.Stream.Close%2A>       如果你使用<xref:System.IO.BufferedStream.%23ctor%2A>构造函数，因此在创建时指定缓冲区大小`BufferedStream`对象，它达到缓冲区大小时刷新内容。</xref:System.IO.BufferedStream.%23ctor%2A> 例如，代码如`BufferedStream bs = new BufferedStream(bs, 5)`的缓冲区大小达到 5 个字节时，将刷新内容。       所有读取和写入方法`BufferedStream`自动维护缓冲区，因此无需调用`Flush`时读取和写入之间来回切换。"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#6](~/add/codesnippet/csharp/m-system.io.bufferedstre_0_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#6](~/add/codesnippet/cpp/m-system.io.bufferedstre_0_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#6](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_0_1.vb)]"
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.IO.BufferedStream.Flush*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已释放流。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "未打开的数据源或存储库。"
  platform:
  - net462
- uid: System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)
  id: FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: FlushAsync(CancellationToken)
  nameWithType: BufferedStream.FlushAsync(CancellationToken)
  fullName: System.IO.BufferedStream.FlushAsync(CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "异步清除此流的所有缓冲区，使得所有缓冲的数据都写入到基础设备，并监视取消请求。"
  syntax:
    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "要监视取消请求的标记。"
    return:
      type: System.Threading.Tasks.Task
      description: "表示异步刷新操作的任务。"
  overload: System.IO.BufferedStream.FlushAsync*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已释放流。"
  platform:
  - net462
- uid: System.IO.BufferedStream.Length
  id: Length
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Length
  nameWithType: BufferedStream.Length
  fullName: System.IO.BufferedStream.Length
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "获取用字节表示的流的长度。"
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "流的长度以字节为单位。"
  overload: System.IO.BufferedStream.Length*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "基础流是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>或已关闭。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "流不支持查找。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "在流关闭后调用方法。"
  platform:
  - net462
- uid: System.IO.BufferedStream.Position
  id: Position
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Position
  nameWithType: BufferedStream.Position
  fullName: System.IO.BufferedStream.Position
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "获取当前流中的位置。"
  remarks: "`get`访问器时，将调用<xref:System.IO.BufferedStream.Seek%2A>以获取基础流中的当前位置，然后调整此值根据缓冲区中的当前位置。</xref:System.IO.BufferedStream.Seek%2A>       `set`访问器将复制任何以前写入到基础流缓冲区的数据，并调用<xref:System.IO.BufferedStream.Seek%2A>.</xref:System.IO.BufferedStream.Seek%2A>       支持查找到流的长度超出任何位置。"
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "当前流中的位置。"
  overload: System.IO.BufferedStream.Position*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "传递给值<xref:System.IO.BufferedStream.Seek*>为负。</xref:System.IO.BufferedStream.Seek*>"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "发生了 I/O 错误，如正在关闭的流。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "流不支持查找。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "在流关闭后调用方法。"
  platform:
  - net462
- uid: System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: BufferedStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.BufferedStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "将字节从当前缓冲的流复制到一个数组。"
  remarks: "`Read`方法将返回 0，仅当已到达流结尾。 在所有其他情况下，`Read`始终至少&1; 个字节从流中读取在返回之前。 根据定义，如果不会提供数据时调用流中`Read`、`Read`方法返回的零 （自动到达流结尾）。 实现可以自由地返回少于所请求的字节，即使尚未达到流结尾。       使用<xref:System.IO.BinaryReader>读取基元数据类型。</xref:System.IO.BinaryReader>"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#7](~/add/codesnippet/csharp/m-system.io.bufferedstre_3_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#7](~/add/codesnippet/cpp/m-system.io.bufferedstre_3_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#7](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_3_1.vb)]"
  syntax:
    content: public override int Read (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "字节是要复制的缓冲区。"
    - id: offset
      type: System.Int32
      description: "从此处开始读取的字节的缓冲区字节偏移量。"
    - id: count
      type: System.Int32
      description: "要读取的字节数。"
    return:
      type: System.Int32
      description: "总字节数读入<code> array </code>。 这可能小于请求的字节数; 如果读取很多字节当前不可用，或如果任何数据前就已到达流结尾为 0 可以。"
  overload: System.IO.BufferedStream.Read*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Length of <code>array</code> minus <code>offset</code> is less than <code>count</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>或<code>count</code>为负。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "流不是打开的或者是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "流不支持读取。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "在流关闭后调用方法。"
  platform:
  - net462
- uid: System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "从当前流异步读取字节序列的流中的位置提升读取的字节数，并监视取消请求。"
  remarks: "你可以通过创建的实例创建一个取消标记<xref:System.Threading.CancellationTokenSource>类并传入<xref:System.Threading.CancellationTokenSource.Token%2A>属性作为`cancellationToken`参数。</xref:System.Threading.CancellationTokenSource.Token%2A> </xref:System.Threading.CancellationTokenSource>"
  syntax:
    content: public override System.Threading.Tasks.Task<int> ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "要写入到数据的缓冲区。"
    - id: offset
      type: System.Int32
      description: "中的字节偏移量`buffer`从此处开始写入从流读取的数据。"
    - id: count
      type: System.Int32
      description: "最大读取的字节数。"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "要监视取消请求的标记。"
    return:
      type: System.Threading.Tasks.Task{System.Int32}
      description: "一个任务，它表示异步读取操作。 值<code> TResult </code>参数包含读入缓冲区的字节总数。 结果值可能小于请求的字节数的如果当前可用字节数小于所请求的数目，或如果已到达流结尾，它可以是 0 （零）。"
  overload: System.IO.BufferedStream.ReadAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>或<code>count</code>为负。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "总和<code> offset </code>和<code> count </code>大于缓冲区长度。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "流不支持读取。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已释放流。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "当前正在使用以前的读取操作流。"
  platform:
  - net462
- uid: System.IO.BufferedStream.ReadByte
  id: ReadByte
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: ReadByte()
  nameWithType: BufferedStream.ReadByte()
  fullName: System.IO.BufferedStream.ReadByte()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "从基础流中读取一个字节，并返回强制转换为字节<xref uid=&quot;langword_csharp_int&quot; name=&quot;int&quot; href=&quot;&quot;> </xref>，或如果读取来自流的末尾，则返回-1。"
  syntax:
    content: public override int ReadByte ();
    parameters: []
    return:
      type: System.Int32
      description: "字节强制转换为<xref uid=&quot;langword_csharp_int&quot; name=&quot;int&quot; href=&quot;&quot;> </xref>，则为-1 如果从流的末尾进行读取。"
  overload: System.IO.BufferedStream.ReadByte*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "发生了 I/O 错误，如正在关闭的流。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "流不支持读取。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "在流关闭后调用方法。"
  platform:
  - net462
- uid: System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: BufferedStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.BufferedStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "当前缓冲的流中设置的位置。"
  remarks: "如果`offset`为负，新的位置将指定的位置之前通过`origin`按指定的字节数`offset`。 如果`offset`为 0，新的位置将为指定的位置`origin`。 如果`offset`为正，新的位置将遵循由指定的位置`origin`按指定的字节数`offset`。       当<xref:System.IO.BufferedStream>对象是基流<xref:System.IO.StreamReader>对象，调用 Seek 方法可能会导致要不再匹配内部缓冲区的位置的读取器中的流的位置。</xref:System.IO.StreamReader> </xref:System.IO.BufferedStream> 若要重置内部缓冲区，调用<xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=fullName>方法; 但是，此方法会降低性能，应仅当绝对必要时调用。</xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=fullName>       支持查找到流的长度超出任何位置。"
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "相对于的字节偏移量`origin`。"
    - id: origin
      type: System.IO.SeekOrigin
      description: "类型的值<xref:System.IO.SeekOrigin>，该值指示要从中获取新位置的参考点。</xref:System.IO.SeekOrigin>"
    return:
      type: System.Int64
      description: "当前缓冲的流中的新位置。"
  overload: System.IO.BufferedStream.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "流不是打开的或者是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "流不支持查找。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "在流关闭后调用方法。"
  platform:
  - net462
- uid: System.IO.BufferedStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: BufferedStream.SetLength(Int64)
  fullName: System.IO.BufferedStream.SetLength(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "设置缓冲的流的长度。"
  remarks: "对缓冲区进行刷新之前设置的基础数据源或存储库的长度。 如果指定的值小于当前缓冲的流的长度，缓冲的流将被截断。 如果指定的值大于当前缓冲的流的长度，则扩展缓冲的流。 如果展开缓冲的流时，旧和新的长度之间缓冲的流的内容是未定义。       `SetLength`如有必要，请刷新任何缓冲的写入。       流必须支持写入和查找有关`SetLength`工作。"
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "指示当前缓冲流以字节为单位的所需的长度的整数。"
  overload: System.IO.BufferedStream.SetLength*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>value</code>为负数。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "流不是打开的或者是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "流不支持写入和查找。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "在流关闭后调用方法。"
  platform:
  - net462
- uid: System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: BufferedStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.BufferedStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "将字节复制到缓冲的流并使中缓冲的流的当前位置提升写入的字节数。"
  remarks: ''
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#6](~/add/codesnippet/csharp/m-system.io.bufferedstre_1_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#6](~/add/codesnippet/cpp/m-system.io.bufferedstre_1_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#6](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_1_1.vb)]"
  syntax:
    content: public override void Write (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "要从其中复制的字节数组`count`个字节写入当前缓冲的流。"
    - id: offset
      type: System.Int32
      description: "从此处开始将字节复制到当前缓冲的流缓冲区中的偏移量。"
    - id: count
      type: System.Int32
      description: "要写入到当前缓冲的流的字节数。"
  overload: System.IO.BufferedStream.Write*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Length of <code>array</code> minus <code>offset</code> is less than <code>count</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>或<code>count</code>为负。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "流已关闭或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "流不支持写入。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "在流关闭后调用方法。"
  platform:
  - net462
- uid: System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "以异步方式将一个字节序列写入当前流，使此流中的当前位置提升写入字节数，并监视取消请求。"
  remarks: "你可以通过创建的实例创建一个取消标记<xref:System.Threading.CancellationTokenSource>类并传入<xref:System.Threading.CancellationTokenSource.Token%2A>属性作为`cancellationToken`参数。</xref:System.Threading.CancellationTokenSource.Token%2A> </xref:System.Threading.CancellationTokenSource>"
  syntax:
    content: public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "要写入数据的缓冲区。"
    - id: offset
      type: System.Int32
      description: "中的从零开始的字节偏移量`buffer`从此处开始将字节复制到流。"
    - id: count
      type: System.Int32
      description: "最大写入的字节数。"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "要监视取消请求的标记。"
    return:
      type: System.Threading.Tasks.Task
      description: "表示异步写入操作的任务。"
  overload: System.IO.BufferedStream.WriteAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>或<code>count</code>为负。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "总和<code> offset </code>和<code> count </code>大于缓冲区长度。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "流不支持写入。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已释放流。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "当前正在由前一个写操作使用流。"
  platform:
  - net462
- uid: System.IO.BufferedStream.WriteByte(System.Byte)
  id: WriteByte(System.Byte)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: WriteByte(Byte)
  nameWithType: BufferedStream.WriteByte(Byte)
  fullName: System.IO.BufferedStream.WriteByte(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "将一个字节写入中缓冲的流的当前位置。"
  syntax:
    content: public override void WriteByte (byte value);
    parameters:
    - id: value
      type: System.Byte
      description: "要写入到流字节。"
  overload: System.IO.BufferedStream.WriteByte*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "流不支持写入。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>value</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "在流关闭后调用方法。"
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.IO.BufferedStream.#ctor(System.IO.Stream)
  parent: System.IO.BufferedStream
  isExternal: false
  name: BufferedStream(Stream)
  nameWithType: BufferedStream.BufferedStream(Stream)
  fullName: System.IO.BufferedStream.BufferedStream(Stream)
- uid: System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)
  parent: System.IO.BufferedStream
  isExternal: false
  name: BufferedStream(Stream,Int32)
  nameWithType: BufferedStream.BufferedStream(Stream,Int32)
  fullName: System.IO.BufferedStream.BufferedStream(Stream,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.BufferedStream
  isExternal: false
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.BufferedStream
  isExternal: false
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IO.BufferedStream.CanRead
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanRead
  nameWithType: BufferedStream.CanRead
  fullName: System.IO.BufferedStream.CanRead
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.BufferedStream.CanSeek
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanSeek
  nameWithType: BufferedStream.CanSeek
  fullName: System.IO.BufferedStream.CanSeek
- uid: System.IO.BufferedStream.CanWrite
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanWrite
  nameWithType: BufferedStream.CanWrite
  fullName: System.IO.BufferedStream.CanWrite
- uid: System.IO.BufferedStream.Dispose(System.Boolean)
  parent: System.IO.BufferedStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: BufferedStream.Dispose(Boolean)
  fullName: System.IO.BufferedStream.Dispose(Boolean)
- uid: System.IO.BufferedStream.EndRead(System.IAsyncResult)
  parent: System.IO.BufferedStream
  isExternal: false
  name: EndRead(IAsyncResult)
  nameWithType: BufferedStream.EndRead(IAsyncResult)
  fullName: System.IO.BufferedStream.EndRead(IAsyncResult)
- uid: System.IO.BufferedStream.EndWrite(System.IAsyncResult)
  parent: System.IO.BufferedStream
  isExternal: false
  name: EndWrite(IAsyncResult)
  nameWithType: BufferedStream.EndWrite(IAsyncResult)
  fullName: System.IO.BufferedStream.EndWrite(IAsyncResult)
- uid: System.IO.BufferedStream.Flush
  parent: System.IO.BufferedStream
  isExternal: false
  name: Flush()
  nameWithType: BufferedStream.Flush()
  fullName: System.IO.BufferedStream.Flush()
- uid: System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  isExternal: false
  name: FlushAsync(CancellationToken)
  nameWithType: BufferedStream.FlushAsync(CancellationToken)
  fullName: System.IO.BufferedStream.FlushAsync(CancellationToken)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.IO.BufferedStream.Length
  parent: System.IO.BufferedStream
  isExternal: false
  name: Length
  nameWithType: BufferedStream.Length
  fullName: System.IO.BufferedStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.BufferedStream.Position
  parent: System.IO.BufferedStream
  isExternal: false
  name: Position
  nameWithType: BufferedStream.Position
  fullName: System.IO.BufferedStream.Position
- uid: System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.BufferedStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: BufferedStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.BufferedStream.Read(Byte[],Int32,Int32)
- uid: System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  isExternal: false
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.Threading.Tasks.Task{System.Int32}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<Int32>
  nameWithType: Task<Int32>
  fullName: System.Threading.Tasks.Task<System.Int32>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Int32>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.BufferedStream.ReadByte
  parent: System.IO.BufferedStream
  isExternal: false
  name: ReadByte()
  nameWithType: BufferedStream.ReadByte()
  fullName: System.IO.BufferedStream.ReadByte()
- uid: System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.BufferedStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: BufferedStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.BufferedStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.IO.BufferedStream.SetLength(System.Int64)
  parent: System.IO.BufferedStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: BufferedStream.SetLength(Int64)
  fullName: System.IO.BufferedStream.SetLength(Int64)
- uid: System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.BufferedStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: BufferedStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.BufferedStream.Write(Byte[],Int32,Int32)
- uid: System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  isExternal: false
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.IO.BufferedStream.WriteByte(System.Byte)
  parent: System.IO.BufferedStream
  isExternal: false
  name: WriteByte(Byte)
  nameWithType: BufferedStream.WriteByte(Byte)
  fullName: System.IO.BufferedStream.WriteByte(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.IO.BufferedStream.#ctor*
  parent: System.IO.BufferedStream
  isExternal: false
  name: BufferedStream
  nameWithType: BufferedStream.BufferedStream
- uid: System.IO.BufferedStream.BeginRead*
  parent: System.IO.BufferedStream
  isExternal: false
  name: BeginRead
  nameWithType: BufferedStream.BeginRead
- uid: System.IO.BufferedStream.BeginWrite*
  parent: System.IO.BufferedStream
  isExternal: false
  name: BeginWrite
  nameWithType: BufferedStream.BeginWrite
- uid: System.IO.BufferedStream.CanRead*
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanRead
  nameWithType: BufferedStream.CanRead
- uid: System.IO.BufferedStream.CanSeek*
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanSeek
  nameWithType: BufferedStream.CanSeek
- uid: System.IO.BufferedStream.CanWrite*
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanWrite
  nameWithType: BufferedStream.CanWrite
- uid: System.IO.BufferedStream.Dispose*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Dispose
  nameWithType: BufferedStream.Dispose
- uid: System.IO.BufferedStream.EndRead*
  parent: System.IO.BufferedStream
  isExternal: false
  name: EndRead
  nameWithType: BufferedStream.EndRead
- uid: System.IO.BufferedStream.EndWrite*
  parent: System.IO.BufferedStream
  isExternal: false
  name: EndWrite
  nameWithType: BufferedStream.EndWrite
- uid: System.IO.BufferedStream.Flush*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Flush
  nameWithType: BufferedStream.Flush
- uid: System.IO.BufferedStream.FlushAsync*
  parent: System.IO.BufferedStream
  isExternal: false
  name: FlushAsync
  nameWithType: BufferedStream.FlushAsync
- uid: System.IO.BufferedStream.Length*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Length
  nameWithType: BufferedStream.Length
- uid: System.IO.BufferedStream.Position*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Position
  nameWithType: BufferedStream.Position
- uid: System.IO.BufferedStream.Read*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Read
  nameWithType: BufferedStream.Read
- uid: System.IO.BufferedStream.ReadAsync*
  parent: System.IO.BufferedStream
  isExternal: false
  name: ReadAsync
  nameWithType: BufferedStream.ReadAsync
- uid: System.IO.BufferedStream.ReadByte*
  parent: System.IO.BufferedStream
  isExternal: false
  name: ReadByte
  nameWithType: BufferedStream.ReadByte
- uid: System.IO.BufferedStream.Seek*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Seek
  nameWithType: BufferedStream.Seek
- uid: System.IO.BufferedStream.SetLength*
  parent: System.IO.BufferedStream
  isExternal: false
  name: SetLength
  nameWithType: BufferedStream.SetLength
- uid: System.IO.BufferedStream.Write*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Write
  nameWithType: BufferedStream.Write
- uid: System.IO.BufferedStream.WriteAsync*
  parent: System.IO.BufferedStream
  isExternal: false
  name: WriteAsync
  nameWithType: BufferedStream.WriteAsync
- uid: System.IO.BufferedStream.WriteByte*
  parent: System.IO.BufferedStream
  isExternal: false
  name: WriteByte
  nameWithType: BufferedStream.WriteByte
