### YamlMime:ManagedReference
items:
- uid: System.Security.Cryptography.Rfc2898DeriveBytes
  id: Rfc2898DeriveBytes
  children:
  - System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])
  - System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)
  - System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)
  - System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)
  - System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)
  - System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])
  - System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)
  - System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)
  - System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount
  - System.Security.Cryptography.Rfc2898DeriveBytes.Reset
  - System.Security.Cryptography.Rfc2898DeriveBytes.Salt
  langs:
  - csharp
  name: Rfc2898DeriveBytes
  nameWithType: Rfc2898DeriveBytes
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes
  type: Class
  summary: "实现基于密码的密钥派生功能 （PBKDF2) 通过使用基于的伪随机数生成器<xref href=&quot;System.Security.Cryptography.HMACSHA1&quot;> </xref>。"
  remarks: "Rfc2898DeriveBytes 采用密码、 salt 值和迭代次数，，然后生成密钥对的调用通过<xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A>方法。</xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A>       RFC 2898 包括用于从密码和 salt 创建密钥和初始化向量 (IV) 的方法。 PBKDF2，基于密码的密钥派生函数，可用于派生密钥使用允许键几乎不受限制的长度，以生成一个伪随机函数。 Rfc2898DeriveBytes 类可以用于生成派生的密钥从是基项和其他参数。 在基于密码的密钥派生函数中，基密钥是密码和其他参数是一个 salt 值和迭代次数。       有关 PBKDF2 的详细信息，请参阅 RFC 2898&quot;PKCS #5︰ 基于密码的加密规范版本 2.0 中，&quot;可在上找到[征求意见文档网站](http://go.microsoft.com/fwlink/?LinkID=37119)。 有关完整详细信息，请参阅部分 5.2，&quot;PBKDF2，&quot;。      1> [!IMPORTANT]&1;> 切勿硬编码你的源代码中的密码。  可以通过使用从程序集检索硬编码密码[Ildasm.exe （IL 反汇编程序）](~/add/includes/ajax-current-ext-md.md)、 使用十六进制编辑器中，或只需打开 Notepad.exe 等文本编辑器中的程序集。"
  example:
  - "The following code example uses the Rfc2898DeriveBytes class to create two identical keys for the <xref:System.Security.Cryptography.TripleDES> class.  It then encrypts and decrypts some data using the keys.  \n  \n [!code-cs[rfc28981#1](~/add/codesnippet/csharp/t-system.security.crypto_117_1.cs)]\n [!code-vb[rfc28981#1](~/add/codesnippet/visualbasic/t-system.security.crypto_117_1.vb)]\n [!code-cpp[rfc28981#1](~/add/codesnippet/cpp/t-system.security.crypto_117_1.cpp)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public class Rfc2898DeriveBytes : System.Security.Cryptography.DeriveBytes
  inheritance:
  - System.Object
  - System.Security.Cryptography.DeriveBytes
  implements: []
  inheritedMembers:
  - System.Security.Cryptography.DeriveBytes.Dispose
  platform:
  - net462
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])
  id: '#ctor(System.String,System.Byte[])'
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  name: Rfc2898DeriveBytes(String,Byte[])
  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Byte[])
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Byte[])
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "初始化的新实例<xref href=&quot;System.Security.Cryptography.Rfc2898DeriveBytes&quot;></xref>类使用的密码和 salt 值派生密钥。"
  remarks: "Salt 大小必须为 8 个字节或更大。       RFC 2898 包括用于从密码和 salt 创建密钥和初始化向量 (IV) 的方法。 PBKDF2，基于密码的密钥派生函数，可用于派生密钥使用允许键几乎不受限制的长度，以生成一个伪随机函数。 <xref:System.Security.Cryptography.Rfc2898DeriveBytes>类可以用于生成派生的密钥从是基项和其他参数。</xref:System.Security.Cryptography.Rfc2898DeriveBytes> 在基于密码的密钥派生函数中，基密钥是密码和其他参数是一个 salt 值和迭代次数。       有关 PBKDF2 的详细信息，请参阅 RFC 2898&quot;PKCS #5︰ 基于密码的加密规范版本 2.0 中，&quot;可在上找到[征求意见文档网站](http://go.microsoft.com/fwlink/?LinkID=37119)。 有关完整详细信息，请参阅部分 5.2，&quot;PBKDF2，&quot;。      1> [!IMPORTANT]&1;> 切勿硬编码你的源代码中的密码。  可以通过使用从程序集检索硬编码密码[Ildasm.exe （IL 反汇编程序）](~/add/includes/ajax-current-ext-md.md)、 使用十六进制编辑器中，或只需打开 Notepad.exe 等文本编辑器中的程序集。"
  example:
  - "The following code example uses the <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class to create two identical keys for the <xref:System.Security.Cryptography.TripleDES> class.  It then encrypts and decrypts some data using the keys.  \n  \n [!code-cs[rfc28981#1](~/add/codesnippet/csharp/7aa0756c-8905-4e75-ae9a-_1.cs)]\n [!code-vb[rfc28981#1](~/add/codesnippet/visualbasic/7aa0756c-8905-4e75-ae9a-_1.vb)]\n [!code-cpp[rfc28981#1](~/add/codesnippet/cpp/7aa0756c-8905-4e75-ae9a-_1.cpp)]"
  syntax:
    content: public Rfc2898DeriveBytes (string password, byte[] salt);
    parameters:
    - id: password
      type: System.String
      description: "用于派生密钥的密码。"
    - id: salt
      type: System.Byte[]
      description: "用于派生密钥的密钥 salt。"
  overload: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "指定的 salt 大小小于 8 个字节或迭代次数等于或大于 1。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "密码或 salt <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)
  id: '#ctor(System.String,System.Int32)'
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  name: Rfc2898DeriveBytes(String,Int32)
  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Int32)
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "初始化的新实例<xref href=&quot;System.Security.Cryptography.Rfc2898DeriveBytes&quot;></xref>类使用的密码和 salt 大小派生密钥。"
  remarks: "Salt 大小必须为 8 个字节或更大。       RFC 2898 包括用于从密码和 salt 创建密钥和初始化向量 (IV) 的方法。 PBKDF2，基于密码的密钥派生函数，可用于派生密钥使用允许键几乎不受限制的长度，以生成一个伪随机函数。 <xref:System.Security.Cryptography.Rfc2898DeriveBytes>类可以用于生成派生的密钥从是基项和其他参数。</xref:System.Security.Cryptography.Rfc2898DeriveBytes> 在基于密码的密钥派生函数中，基密钥是密码和其他参数是一个 salt 值和迭代次数。       有关 PBKDF2 的详细信息，请参阅 RFC 2898&quot;PKCS #5︰ 基于密码的加密规范版本 2.0 中，&quot;可在上找到[征求意见文档网站](http://go.microsoft.com/fwlink/?LinkID=37119)。 有关完整详细信息，请参阅部分 5.2，&quot;PBKDF2，&quot;。      1> [!IMPORTANT]&1;> 切勿硬编码你的源代码中的密码。  可以通过使用从程序集检索硬编码密码[Ildasm.exe （IL 反汇编程序）](~/add/includes/ajax-current-ext-md.md)、 使用十六进制编辑器中，或只需打开 Notepad.exe 等文本编辑器中的程序集。"
  syntax:
    content: public Rfc2898DeriveBytes (string password, int saltSize);
    parameters:
    - id: password
      type: System.String
      description: "用于派生密钥的密码。"
    - id: saltSize
      type: System.Int32
      description: "你希望类生成的随机 salt 的大小。"
  overload: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "指定的 salt 大小小于 8 个字节。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "密码或 salt <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)
  id: '#ctor(System.Byte[],System.Byte[],System.Int32)'
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  name: Rfc2898DeriveBytes(Byte[],Byte[],Int32)
  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes(Byte[],Byte[],Int32)
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(Byte[],Byte[],Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "初始化的新实例<xref href=&quot;System.Security.Cryptography.Rfc2898DeriveBytes&quot;></xref>类使用密码、 salt 值和迭代次数派生密钥。"
  remarks: "Salt 大小必须为 8 个字节或更大和迭代次数必须是大于零。 建议的最小迭代数为 1000年。       RFC 2898 包括用于从密码和 salt 创建密钥和初始化向量 (IV) 的方法。 PBKDF2，基于密码的密钥派生函数，可用于派生密钥使用允许键几乎不受限制的长度，以生成一个伪随机函数。 <xref:System.Security.Cryptography.Rfc2898DeriveBytes>类可以用于生成派生的密钥从是基项和其他参数。</xref:System.Security.Cryptography.Rfc2898DeriveBytes> 在基于密码的密钥派生函数中，基密钥是密码和其他参数是一个 salt 值和迭代次数。       有关 PBKDF2 的详细信息，请参阅 RFC 2898&quot;PKCS #5︰ 基于密码的加密规范版本 2.0 中，&quot;可在上找到[征求意见文档网站](http://go.microsoft.com/fwlink/?LinkID=37119)。 有关完整详细信息，请参阅部分 5.2，&quot;PBKDF2，&quot;。      1> [!IMPORTANT]&1;> 切勿硬编码你的源代码中的密码。  可以通过使用从程序集检索硬编码密码[Ildasm.exe （IL 反汇编程序）](~/add/includes/ajax-current-ext-md.md)、 使用十六进制编辑器中，或只需打开 Notepad.exe 等文本编辑器中的程序集。"
  syntax:
    content: public Rfc2898DeriveBytes (byte[] password, byte[] salt, int iterations);
    parameters:
    - id: password
      type: System.Byte[]
      description: "用于派生密钥的密码。"
    - id: salt
      type: System.Byte[]
      description: "用于派生密钥的密钥 salt。"
    - id: iterations
      type: System.Int32
      description: "该操作的迭代数。"
  overload: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "指定的 salt 大小小于 8 个字节或迭代次数等于或大于 1。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "密码或 salt <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)
  id: '#ctor(System.String,System.Byte[],System.Int32)'
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  name: Rfc2898DeriveBytes(String,Byte[],Int32)
  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Byte[],Int32)
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Byte[],Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "初始化的新实例<xref href=&quot;System.Security.Cryptography.Rfc2898DeriveBytes&quot;></xref>类使用密码、 salt 值和迭代次数派生密钥。"
  remarks: "Salt 大小必须为 8 个字节或更大和迭代次数必须是大于零。 建议的最小迭代数为 1000年。       RFC 2898 包括用于从密码和 salt 创建密钥和初始化向量 (IV) 的方法。 PBKDF2，基于密码的密钥派生函数，可用于派生密钥使用允许键几乎不受限制的长度，以生成一个伪随机函数。 <xref:System.Security.Cryptography.Rfc2898DeriveBytes>类可以用于生成派生的密钥从是基项和其他参数。</xref:System.Security.Cryptography.Rfc2898DeriveBytes> 在基于密码的密钥派生函数中，基密钥是密码和其他参数是一个 salt 值和迭代次数。       有关 PBKDF2 的详细信息，请参阅 RFC 2898&quot;PKCS #5︰ 基于密码的加密规范版本 2.0 中，&quot;可在上找到[征求意见文档网站](http://go.microsoft.com/fwlink/?LinkID=37119)。 有关完整详细信息，请参阅部分 5.2，&quot;PBKDF2，&quot;。      1> [!IMPORTANT]&1;> 切勿硬编码你的源代码中的密码。  可以通过使用从程序集检索硬编码密码[Ildasm.exe （IL 反汇编程序）](~/add/includes/ajax-current-ext-md.md)、 使用十六进制编辑器中，或只需打开 Notepad.exe 等文本编辑器中的程序集。"
  example:
  - "The following code example uses the <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class to create two identical keys for the <xref:System.Security.Cryptography.TripleDES> class.  It then encrypts and decrypts some data using the keys.  \n  \n [!code-cs[rfc28981#1](~/add/codesnippet/csharp/8b79aa42-3b6a-4a39-985a-_1.cs)]\n [!code-vb[rfc28981#1](~/add/codesnippet/visualbasic/8b79aa42-3b6a-4a39-985a-_1.vb)]\n [!code-cpp[rfc28981#1](~/add/codesnippet/cpp/8b79aa42-3b6a-4a39-985a-_1.cpp)]"
  syntax:
    content: public Rfc2898DeriveBytes (string password, byte[] salt, int iterations);
    parameters:
    - id: password
      type: System.String
      description: "用于派生密钥的密码。"
    - id: salt
      type: System.Byte[]
      description: "用于派生密钥的密钥 salt。"
    - id: iterations
      type: System.Int32
      description: "该操作的迭代数。"
  overload: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "指定的 salt 大小小于 8 个字节或迭代次数等于或大于 1。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "密码或 salt <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)
  id: '#ctor(System.String,System.Int32,System.Int32)'
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  name: Rfc2898DeriveBytes(String,Int32,Int32)
  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Int32,Int32)
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Int32,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "初始化的新实例<xref href=&quot;System.Security.Cryptography.Rfc2898DeriveBytes&quot;></xref>类使用密码、 salt 大小和迭代次数派生密钥。"
  remarks: "Salt 大小必须为 8 个字节或更大和迭代次数必须是大于零。 建议的最小迭代数为 1000年。       RFC 2898 包括用于从密码和 salt 创建密钥和初始化向量 (IV) 的方法。 PBKDF2，基于密码的密钥派生函数，可用于派生密钥使用允许键几乎不受限制的长度，以生成一个伪随机函数。 <xref:System.Security.Cryptography.Rfc2898DeriveBytes>类可以用于生成派生的密钥从是基项和其他参数。</xref:System.Security.Cryptography.Rfc2898DeriveBytes> 在基于密码的密钥派生函数中，基密钥是密码和其他参数是一个 salt 值和迭代次数。       PBKDF2 的详细信息，请参阅 RFC 2898&quot;PKCS #5︰ 基于密码的加密规范版本 2.0 中，&quot;可在上找到[征求意见文档网站](http://go.microsoft.com/fwlink/?LinkID=37119)。 有关完整详细信息，请参阅部分 5.2，&quot;PBKDF2，&quot;。      1> [!IMPORTANT]&1;> 切勿硬编码你的源代码中的密码。  可以通过使用从程序集检索硬编码密码[Ildasm.exe （IL 反汇编程序）](~/add/includes/ajax-current-ext-md.md)、 使用十六进制编辑器中，或只需打开 Notepad.exe 等文本编辑器中的程序集。"
  syntax:
    content: public Rfc2898DeriveBytes (string password, int saltSize, int iterations);
    parameters:
    - id: password
      type: System.String
      description: "用于派生密钥的密码。"
    - id: saltSize
      type: System.Int32
      description: "你希望类生成的随机 salt 的大小。"
    - id: iterations
      type: System.Int32
      description: "该操作的迭代数。"
  overload: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "指定的 salt 大小小于 8 个字节或迭代次数等于或大于 1。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "密码或 salt <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>iterations </code>超出了范围。 此参数要求的非负数。"
  platform:
  - net462
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])
  id: CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  name: CryptDeriveKey(String,String,Int32,Byte[])
  nameWithType: Rfc2898DeriveBytes.CryptDeriveKey(String,String,Int32,Byte[])
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(String,String,Int32,Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "派生的加密密钥<xref href=&quot;System.Security.Cryptography.Rfc2898DeriveBytes&quot;></xref>对象。"
  remarks: "此函数是加密 API 函数 CryptDeriveKey() 的包装器，并旨在提供与使用加密 API 的应用程序的互操作性。       如果`keySize`参数设置为 0 位，则将使用指定的算法的默认密钥大小。"
  syntax:
    content: public byte[] CryptDeriveKey (string algname, string alghashname, int keySize, byte[] rgbIV);
    parameters:
    - id: algname
      type: System.String
      description: "为其派生密钥的算法名称。"
    - id: alghashname
      type: System.String
      description: "要用于派生密钥的哈希算法名称。"
    - id: keySize
      type: System.Int32
      description: "密钥，以位为单位，派生的大小。"
    - id: rgbIV
      type: System.Byte[]
      description: "初始化向量 (IV) 要用于派生密钥。"
    return:
      type: System.Byte[]
      description: "派生的密钥。"
  overload: System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey*
  exceptions:
  - type: System.Security.Cryptography.CryptographicException
    commentId: T:System.Security.Cryptography.CryptographicException
    description: "<code> keySize </code>参数不正确。       -或者-无法获取加密服务提供程序 (CSP)。       -或- <code> algname </code>参数不是有效的算法名称。       -或- <code> alghashname </code>参数不是有效的哈希算法名称。"
  platform:
  - net462
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: Rfc2898DeriveBytes.Dispose(Boolean)
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "释放由非托管的资源<xref href=&quot;System.Security.Cryptography.Rfc2898DeriveBytes&quot;></xref>类，还可以释放托管的资源。"
  remarks: "此方法称为由公共`Dispose()`方法和`Finalize`方法。 `Dispose()`调用受保护`Dispose(Boolean)`方法替换`disposing`参数设置为`true`。 `Finalize`调用`Dispose`与`disposing`设置为`false`。       当`disposing`参数是`true`，此方法释放由任何托管对象持有的全部资源此<xref:System.Security.Cryptography.Rfc2898DeriveBytes>引用。</xref:System.Security.Cryptography.Rfc2898DeriveBytes> 此方法调用`Dispose()`每个引用对象的方法。"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要释放托管和非托管资源;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>若要仅释放非托管的资源。"
  overload: System.Security.Cryptography.Rfc2898DeriveBytes.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)
  id: GetBytes(System.Int32)
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  name: GetBytes(Int32)
  nameWithType: Rfc2898DeriveBytes.GetBytes(Int32)
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "返回此对象的伪随机密钥。"
  remarks: "<xref:System.Security.Cryptography.Rfc2898DeriveBytes>类实现通过使用基于<xref:System.Security.Cryptography.HMACSHA1>.</xref:System.Security.Cryptography.HMACSHA1>的伪随机数生成器的 PBKDF2 功能</xref:System.Security.Cryptography.Rfc2898DeriveBytes> <xref:System.Security.Cryptography.Rfc2898DeriveBytes>类采用密码、 salt 值和迭代次数，，然后生成通过对 GetBytes 方法的调用的键。</xref:System.Security.Cryptography.Rfc2898DeriveBytes> 重复的调用此方法将不会生成相同的密钥;相反，追加两个方法调用的 GetBytes 与`cb`参数值的`20`等效于调用一次带有 GetBytes 方法`cb`的参数值`40`。"
  example:
  - "The following example shows how to use the GetBytes method to get the key for an instance of <xref:System.Security.Cryptography.Rfc2898DeriveBytes>. This code example is part of a larger example provided for the <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class.  \n  \n [!code-cs[rfc28981#2](~/add/codesnippet/csharp/m-system.security.crypto_127_1.cs)]\n [!code-vb[rfc28981#2](~/add/codesnippet/visualbasic/m-system.security.crypto_127_1.vb)]\n [!code-cpp[rfc28981#2](~/add/codesnippet/cpp/m-system.security.crypto_127_1.cpp)]"
  syntax:
    content: public override byte[] GetBytes (int cb);
    parameters:
    - id: cb
      type: System.Int32
      description: "若要生成的伪随机密钥字节数。"
    return:
      type: System.Byte[]
      description: "伪随机密钥字节填充字节数组。"
  overload: System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>cb </code>超出了范围。 此参数要求的非负数。"
  platform:
  - net462
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount
  id: IterationCount
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  name: IterationCount
  nameWithType: Rfc2898DeriveBytes.IterationCount
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "获取或设置操作的迭代数。"
  remarks: "迭代次数是执行操作的次数。 对于此方法中，计数应大于零。 建议的最小迭代数为 1000年。"
  example:
  - "The following example shows how to use the IterationCount property to display the number of iterations used in the generation of the key. This code example is part of a larger example provided for the <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class.  \n  \n [!code-cs[rfc28981#3](~/add/codesnippet/csharp/p-system.security.crypto_117_1.cs)]\n [!code-vb[rfc28981#3](~/add/codesnippet/visualbasic/p-system.security.crypto_117_1.vb)]\n [!code-cpp[rfc28981#3](~/add/codesnippet/cpp/p-system.security.crypto_117_1.cpp)]"
  syntax:
    content: public int IterationCount { get; set; }
    return:
      type: System.Int32
      description: "该操作的迭代数。"
  overload: System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "迭代数为小于 1。"
  platform:
  - net462
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.Reset
  id: Reset
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  name: Reset()
  nameWithType: Rfc2898DeriveBytes.Reset()
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Reset()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "重置操作的状态。"
  remarks: "如果修改 salt 值或迭代计数，会自动调用此方法。"
  example:
  - "The following example shows how to use the Reset method. This code example is part of a larger example provided for the <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class.  \n  \n [!code-cs[rfc28981#5](~/add/codesnippet/csharp/m-system.security.crypto_26_1.cs)]\n [!code-vb[rfc28981#5](~/add/codesnippet/visualbasic/m-system.security.crypto_26_1.vb)]\n [!code-cpp[rfc28981#5](~/add/codesnippet/cpp/m-system.security.crypto_26_1.cpp)]"
  syntax:
    content: public override void Reset ();
    parameters: []
  overload: System.Security.Cryptography.Rfc2898DeriveBytes.Reset*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.Salt
  id: Salt
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  name: Salt
  nameWithType: Rfc2898DeriveBytes.Salt
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Salt
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "获取或设置操作的密钥 salt 值。"
  remarks: "Salt，随机的一组字节，用于使未经授权的难度消息解密。 字典攻击是一种攻击，攻击者尝试通过将以前计算的加密值的最可能的密钥的加密的值进行比较解密加密的消息。 困难得多的 salt，或随机字节，密码才能密钥派生末尾简介进行这种攻击。"
  syntax:
    content: public byte[] Salt { get; set; }
    return:
      type: System.Byte[]
      description: "操作的密钥 salt 值。"
  overload: System.Security.Cryptography.Rfc2898DeriveBytes.Salt*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "指定的 salt 大小小于 8 个字节。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Salt 是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
references:
- uid: System.Security.Cryptography.DeriveBytes
  isExternal: false
  name: System.Security.Cryptography.DeriveBytes
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Security.Cryptography.CryptographicException
  parent: System.Security.Cryptography
  isExternal: false
  name: CryptographicException
  nameWithType: CryptographicException
  fullName: System.Security.Cryptography.CryptographicException
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: Rfc2898DeriveBytes(String,Byte[])
  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Byte[])
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Byte[])
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: Rfc2898DeriveBytes(String,Int32)
  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Int32)
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: Rfc2898DeriveBytes(Byte[],Byte[],Int32)
  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes(Byte[],Byte[],Int32)
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(Byte[],Byte[],Int32)
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: Rfc2898DeriveBytes(String,Byte[],Int32)
  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Byte[],Int32)
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Byte[],Int32)
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: Rfc2898DeriveBytes(String,Int32,Int32)
  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Int32,Int32)
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Int32,Int32)
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: CryptDeriveKey(String,String,Int32,Byte[])
  nameWithType: Rfc2898DeriveBytes.CryptDeriveKey(String,String,Int32,Byte[])
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(String,String,Int32,Byte[])
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: Rfc2898DeriveBytes.Dispose(Boolean)
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: GetBytes(Int32)
  nameWithType: Rfc2898DeriveBytes.GetBytes(Int32)
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(Int32)
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: IterationCount
  nameWithType: Rfc2898DeriveBytes.IterationCount
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.Reset
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: Reset()
  nameWithType: Rfc2898DeriveBytes.Reset()
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Reset()
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.Salt
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: Salt
  nameWithType: Rfc2898DeriveBytes.Salt
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Salt
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor*
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: Rfc2898DeriveBytes
  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey*
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: CryptDeriveKey
  nameWithType: Rfc2898DeriveBytes.CryptDeriveKey
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.Dispose*
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: Dispose
  nameWithType: Rfc2898DeriveBytes.Dispose
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes*
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: GetBytes
  nameWithType: Rfc2898DeriveBytes.GetBytes
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount*
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: IterationCount
  nameWithType: Rfc2898DeriveBytes.IterationCount
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.Reset*
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: Reset
  nameWithType: Rfc2898DeriveBytes.Reset
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.Salt*
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: Salt
  nameWithType: Rfc2898DeriveBytes.Salt
