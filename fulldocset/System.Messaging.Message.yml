### YamlMime:ManagedReference
items:
- uid: System.Messaging.Message
  id: Message
  children:
  - System.Messaging.Message.#ctor
  - System.Messaging.Message.#ctor(System.Object)
  - System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)
  - System.Messaging.Message.AcknowledgeType
  - System.Messaging.Message.Acknowledgment
  - System.Messaging.Message.AdministrationQueue
  - System.Messaging.Message.AppSpecific
  - System.Messaging.Message.ArrivedTime
  - System.Messaging.Message.AttachSenderId
  - System.Messaging.Message.Authenticated
  - System.Messaging.Message.AuthenticationProviderName
  - System.Messaging.Message.AuthenticationProviderType
  - System.Messaging.Message.Body
  - System.Messaging.Message.BodyStream
  - System.Messaging.Message.BodyType
  - System.Messaging.Message.ConnectorType
  - System.Messaging.Message.CorrelationId
  - System.Messaging.Message.DestinationQueue
  - System.Messaging.Message.DestinationSymmetricKey
  - System.Messaging.Message.DigitalSignature
  - System.Messaging.Message.EncryptionAlgorithm
  - System.Messaging.Message.Extension
  - System.Messaging.Message.Formatter
  - System.Messaging.Message.HashAlgorithm
  - System.Messaging.Message.Id
  - System.Messaging.Message.InfiniteTimeout
  - System.Messaging.Message.IsFirstInTransaction
  - System.Messaging.Message.IsLastInTransaction
  - System.Messaging.Message.Label
  - System.Messaging.Message.LookupId
  - System.Messaging.Message.MessageType
  - System.Messaging.Message.Priority
  - System.Messaging.Message.Recoverable
  - System.Messaging.Message.ResponseQueue
  - System.Messaging.Message.SecurityContext
  - System.Messaging.Message.SenderCertificate
  - System.Messaging.Message.SenderId
  - System.Messaging.Message.SenderVersion
  - System.Messaging.Message.SentTime
  - System.Messaging.Message.SourceMachine
  - System.Messaging.Message.TimeToBeReceived
  - System.Messaging.Message.TimeToReachQueue
  - System.Messaging.Message.TransactionId
  - System.Messaging.Message.TransactionStatusQueue
  - System.Messaging.Message.UseAuthentication
  - System.Messaging.Message.UseDeadLetterQueue
  - System.Messaging.Message.UseEncryption
  - System.Messaging.Message.UseJournalQueue
  - System.Messaging.Message.UseTracing
  langs:
  - csharp
  name: Message
  nameWithType: Message
  fullName: System.Messaging.Message
  type: Class
  summary: "提供对定义消息队列消息所需的属性访问。"
  remarks: "若要查看或从队列接收消息，或能够很好的控制消息属性向队列发送消息时，请使用 Message 类。       <xref:System.Messaging.MessageQueue>使用 Message 类在扫视或接收来自队列的消息时，因为同时<xref:System.Messaging.MessageQueue.Peek%2A?displayProperty=fullName>和<xref:System.Messaging.MessageQueue.Receive%2A?displayProperty=fullName>方法创建的邮件类的新实例并设置该实例的属性。</xref:System.Messaging.MessageQueue.Receive%2A?displayProperty=fullName> </xref:System.Messaging.MessageQueue.Peek%2A?displayProperty=fullName></xref:System.Messaging.MessageQueue> Message 类的只读属性适用于从队列检索消息时的读/写属性适用于发送和检索消息。 当<xref:System.Messaging.MessageQueue>扫视或接收来自队列的消息其<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>属性确定消息的属性中哪些检索。</xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> </xref:System.Messaging.MessageQueue>       <xref:System.Messaging.MessageQueue>类的<xref:System.Messaging.MessageQueue.Send%2A>方法允许你指定的任何对象类型为发送到该队列的消息。</xref:System.Messaging.MessageQueue.Send%2A> </xref:System.Messaging.MessageQueue> 你可以使用<xref:System.Messaging.MessageQueue>实例的<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>属性指定的泛型消息发送到队列设置。</xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> </xref:System.Messaging.MessageQueue> 类型的设置包括格式化程序、 标签、 加密和身份验证。 你还可以指定的相应值<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>成员在协调消息传送应用程序以响应确认消息和报告消息时。</xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 使用消息实例来向队列发送一条消息可以灵活地访问和修改其中的许多属性-对单个消息或消息的消息的基础上。 消息属性优先于<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>.</xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>       消息数据存储在<xref:System.Messaging.Message.Body%2A>属性和较小的范围内，<xref:System.Messaging.Message.AppSpecific%2A>和<xref:System.Messaging.Message.Extension%2A>属性。</xref:System.Messaging.Message.Extension%2A> </xref:System.Messaging.Message.AppSpecific%2A> </xref:System.Messaging.Message.Body%2A> 消息数据已加密、 序列化或反序列化的内容<xref:System.Messaging.Message.Body%2A>属性会受到影响。</xref:System.Messaging.Message.Body%2A>       内容<xref:System.Messaging.Message.Body%2A>序列化属性，当使用发送消息时<xref:System.Messaging.Message.Formatter%2A>你指定的属性。</xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.Message.Body%2A> 在中找到的序列化的内容<xref:System.Messaging.Message.BodyStream%2A>属性。</xref:System.Messaging.Message.BodyStream%2A> 你还可以设置<xref:System.Messaging.Message.BodyStream%2A>属性直接，例如，若要将文件作为一条消息的数据内容发送。</xref:System.Messaging.Message.BodyStream%2A> 你可以更改<xref:System.Messaging.Message.Body%2A>或<xref:System.Messaging.Message.Formatter%2A>任何时间之前发送的消息和数据时的属性会进行序列化相应地调用<xref:System.Messaging.MessageQueue.Send%2A>.</xref:System.Messaging.MessageQueue.Send%2A>时</xref:System.Messaging.Message.Formatter%2A></xref:System.Messaging.Message.Body%2A>       属性定义<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=fullName>属性仅适用于不属于类型消息的消息。</xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=fullName> 如果指定<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>属性<xref:System.Messaging.MessageQueue>中发送到该队列的消息实例, 具有相同名称的属性会导致这些默认属性被忽略。</xref:System.Messaging.MessageQueue> </xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>       有关的消息的实例的初始属性值的列表，请参阅<xref:System.Messaging.Message.%23ctor%2A>构造函数。</xref:System.Messaging.Message.%23ctor%2A>"
  example:
  - "The following code example demonstrates formatting a message body using <xref:System.Messaging.BinaryMessageFormatter>.  \n  \n [!code-cpp[MessagingBinaryFormatter#1](~/add/codesnippet/cpp/t-system.messaging.message_1.cpp)]\n [!code-cs[MessagingBinaryFormatter#1](~/add/codesnippet/csharp/t-system.messaging.message_1.cs)]\n [!code-vb[MessagingBinaryFormatter#1](~/add/codesnippet/visualbasic/t-system.messaging.message_1.vb)]  \n  \n The following code example demonstrates formatting a message body using <xref:System.Messaging.XmlMessageFormatter>.  \n  \n [!code-cpp[Message.Body#1](~/add/codesnippet/cpp/t-system.messaging.message_2.cpp)]\n [!code-cs[Message.Body#1](~/add/codesnippet/csharp/t-system.messaging.message_2.cs)]\n [!code-vb[Message.Body#1](~/add/codesnippet/visualbasic/t-system.messaging.message_2.vb)]"
  syntax:
    content: >-
      [System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      public class Message : System.ComponentModel.Component
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements: []
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Dispose(System.Boolean)
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.ComponentModel.Component.ToString
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Messaging.Message.#ctor
  id: '#ctor'
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Message()
  nameWithType: Message.Message()
  fullName: System.Messaging.Message.Message()
  type: Constructor
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "初始化的新实例<xref href=&quot;System.Messaging.Message&quot;></xref>正文为空类。"
  remarks: "使用此重载来创建的新实例<xref:System.Messaging.Message>具有空主体的类。</xref:System.Messaging.Message>       指定<xref:System.Messaging.Message.Body%2A>属性或<xref:System.Messaging.Message.BodyStream%2A>属性在发送之前<xref:System.Messaging.Message>对象。</xref:System.Messaging.Message> </xref:System.Messaging.Message.BodyStream%2A> </xref:System.Messaging.Message.Body%2A> <xref:System.Messaging.Message.Body%2A>属性可以是任何可序列化的对象，例如文本字符串、 结构对象、 类实例或嵌入的对象。</xref:System.Messaging.Message.Body%2A>       除非你将写入消息的内容直接<xref:System.Messaging.Message.BodyStream%2A>属性，设置<xref:System.Messaging.Message.Formatter%2A>属性后，发送消息。</xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.Message.BodyStream%2A> 正文将序列使用<xref:System.Messaging.Message.Formatter%2A>属性的值时<xref:System.Messaging.MessageQueue.Send%2A>方法调用<xref:System.Messaging.MessageQueue>实例。</xref:System.Messaging.MessageQueue> </xref:System.Messaging.MessageQueue.Send%2A> </xref:System.Messaging.Message.Formatter%2A>       <xref:System.Messaging.XmlMessageFormatter>松散耦合的因此不需要具有相同的对象时使用此格式类型上的发送者和接收者。</xref:System.Messaging.XmlMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>和<xref:System.Messaging.BinaryMessageFormatter>数据序列化为二进制表示形式。</xref:System.Messaging.BinaryMessageFormatter> </xref:System.Messaging.ActiveXMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>发送或接收 COM 组件时使用。</xref:System.Messaging.ActiveXMessageFormatter>       下表显示<xref:System.Messaging.Message>.</xref:System.Messaging.Message>实例的初始属性的值      |属性 |初始值 |  |--------------|-------------------|  |<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  |<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  |<xref:System.Messaging.Message.AppSpecific%2A>|0|  |<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  |<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider 1.0 版 |  |<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  |<xref:System.Messaging.Message.Body%2A>|`null`|  |<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  |<xref:System.Messaging.Message.BodyType%2A>|0|  |<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  |<xref:System.Messaging.Message.CorrelationId%2A>|空字符串 (&quot;&quot;) |  |<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|一个零长度的字节数组 |  |<xref:System.Messaging.Message.DigitalSignature%2A>|一个零长度的字节数组 |  |<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  |<xref:System.Messaging.Message.Extension%2A>|一个零长度的字节数组 |  |<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  |<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  |<xref:System.Messaging.Message.Label%2A>|空字符串 (&quot;&quot;) |  |<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  |<xref:System.Messaging.Message.Recoverable%2A>|`false`|  |<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  |<xref:System.Messaging.Message.SenderCertificate%2A>|一个零长度的字节数组 |  |<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  |<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  |<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  |<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  |<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  |<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  |<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  |<xref:System.Messaging.Message.UseTracing%2A>|`false`|</xref:System.Messaging.Message.UseTracing%2A></xref:System.Messaging.Message.UseJournalQueue%2A></xref:System.Messaging.Message.UseEncryption%2A></xref:System.Messaging.Message.UseDeadLetterQueue%2A></xref:System.Messaging.Message.UseAuthentication%2A></xref:System.Messaging.Message.TransactionStatusQueue%2A></xref:System.Messaging.Message.TimeToReachQueue%2A></xref:System.Messaging.Message.TimeToBeReceived%2A></xref:System.Messaging.Message.SenderCertificate%2A></xref:System.Messaging.Message.ResponseQueue%2A></xref:System.Messaging.Message.Recoverable%2A></xref:System.Messaging.Message.Priority%2A></xref:System.Messaging.Message.Label%2A></xref:System.Messaging.Message.HashAlgorithm%2A></xref:System.Messaging.Message.Formatter%2A></xref:System.Messaging.Message.Extension%2A></xref:System.Messaging.Message.EncryptionAlgorithm%2A></xref:System.Messaging.Message.DigitalSignature%2A></xref:System.Messaging.Message.DestinationSymmetricKey%2A></xref:System.Messaging.Message.CorrelationId%2A></xref:System.Messaging.Message.ConnectorType%2A></xref:System.Messaging.Message.BodyType%2A></xref:System.Messaging.Message.BodyStream%2A></xref:System.Messaging.Message.Body%2A></xref:System.Messaging.Message.AuthenticationProviderType%2A></xref:System.Messaging.Message.AuthenticationProviderName%2A></xref:System.Messaging.Message.AttachSenderId%2A></xref:System.Messaging.Message.AppSpecific%2A></xref:System.Messaging.Message.AdministrationQueue%2A></xref:System.Messaging.Message.AcknowledgeType%2A>"
  example:
  - "The following code example sends two messages of different priorities to the queue, and retrieves them subsequently.  \n  \n [!code-cpp[Message.DefaultPropertiesToSend#1](~/add/codesnippet/cpp/m-system.messaging.messa_16_1.cpp)]\n [!code-vb[Message.DefaultPropertiesToSend#1](~/add/codesnippet/visualbasic/m-system.messaging.messa_16_1.vb)]\n [!code-cs[Message.DefaultPropertiesToSend#1](~/add/codesnippet/csharp/m-system.messaging.messa_16_1.cs)]"
  syntax:
    content: public Message ();
    parameters: []
  overload: System.Messaging.Message.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.Message.#ctor(System.Object)
  id: '#ctor(System.Object)'
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Message(Object)
  nameWithType: Message.Message(Object)
  fullName: System.Messaging.Message.Message(Object)
  type: Constructor
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "初始化的新实例<xref href=&quot;System.Messaging.Message&quot;></xref>类，使用<xref href=&quot;System.Messaging.XmlMessageFormatter&quot;></xref>将指定的对象序列化为消息的正文。"
  remarks: "使用此重载来创建的新实例<xref:System.Messaging.Message>类，该类包含<xref:System.Messaging.Message.Body%2A>指定的`body`参数。</xref:System.Messaging.Message.Body%2A> </xref:System.Messaging.Message> `body`参数可以是任何可序列化，如文本字符串、 结构对象、 类实例或嵌入的对象的对象。 正文将序列使用<xref:System.Messaging.XmlMessageFormatter>除非您更改<xref:System.Messaging.Message.Formatter%2A>属性之前<xref:System.Messaging.Message>发送。</xref:System.Messaging.Message> </xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.XmlMessageFormatter> 如果你更改<xref:System.Messaging.Message.Body%2A>或<xref:System.Messaging.Message.Formatter%2A>属性之前调用的任何时候<xref:System.Messaging.MessageQueue.Send%2A>，消息会根据新的属性值进行序列化。</xref:System.Messaging.MessageQueue.Send%2A> </xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.Message.Body%2A>       <xref:System.Messaging.XmlMessageFormatter>松散耦合的因此不需要具有相同的对象时使用此格式类型上的发送者和接收者。</xref:System.Messaging.XmlMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>和<xref:System.Messaging.BinaryMessageFormatter>数据序列化为二进制表示形式。</xref:System.Messaging.BinaryMessageFormatter> </xref:System.Messaging.ActiveXMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>发送或接收 COM 组件时使用。</xref:System.Messaging.ActiveXMessageFormatter>       下表显示<xref:System.Messaging.Message>.</xref:System.Messaging.Message>实例的初始属性的值      |属性 |初始值 |  |--------------|-------------------|  |<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  |<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  |<xref:System.Messaging.Message.AppSpecific%2A>|0|  |<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  |<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider 1.0 版 |  |<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  |<xref:System.Messaging.Message.Body%2A>|`body`参数。 |  |<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  |<xref:System.Messaging.Message.BodyType%2A>|0|  |<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  |<xref:System.Messaging.Message.CorrelationId%2A>|空字符串 (&quot;&quot;) |  |<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|一个零长度的字节数组 |  |<xref:System.Messaging.Message.DigitalSignature%2A>|一个零长度的字节数组 |  |<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  |<xref:System.Messaging.Message.Extension%2A>|一个零长度的字节数组 |  |<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  |<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  |<xref:System.Messaging.Message.Label%2A>|空字符串 (&quot;&quot;) |  |<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  |<xref:System.Messaging.Message.Recoverable%2A>|`false`|  |<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  |<xref:System.Messaging.Message.SenderCertificate%2A>|一个零长度的字节数组 |  |<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  |<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  |<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  |<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  |<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  |<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  |<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  |<xref:System.Messaging.Message.UseTracing%2A>|`false`|</xref:System.Messaging.Message.UseTracing%2A></xref:System.Messaging.Message.UseJournalQueue%2A></xref:System.Messaging.Message.UseEncryption%2A></xref:System.Messaging.Message.UseDeadLetterQueue%2A></xref:System.Messaging.Message.UseAuthentication%2A></xref:System.Messaging.Message.TransactionStatusQueue%2A></xref:System.Messaging.Message.TimeToReachQueue%2A></xref:System.Messaging.Message.TimeToBeReceived%2A></xref:System.Messaging.Message.SenderCertificate%2A></xref:System.Messaging.Message.ResponseQueue%2A></xref:System.Messaging.Message.Recoverable%2A></xref:System.Messaging.Message.Priority%2A></xref:System.Messaging.Message.Label%2A></xref:System.Messaging.Message.HashAlgorithm%2A></xref:System.Messaging.Message.Formatter%2A></xref:System.Messaging.Message.Extension%2A></xref:System.Messaging.Message.EncryptionAlgorithm%2A></xref:System.Messaging.Message.DigitalSignature%2A></xref:System.Messaging.Message.DestinationSymmetricKey%2A></xref:System.Messaging.Message.CorrelationId%2A></xref:System.Messaging.Message.ConnectorType%2A></xref:System.Messaging.Message.BodyType%2A></xref:System.Messaging.Message.BodyStream%2A></xref:System.Messaging.Message.Body%2A></xref:System.Messaging.Message.AuthenticationProviderType%2A></xref:System.Messaging.Message.AuthenticationProviderName%2A></xref:System.Messaging.Message.AttachSenderId%2A></xref:System.Messaging.Message.AppSpecific%2A></xref:System.Messaging.Message.AdministrationQueue%2A></xref:System.Messaging.Message.AcknowledgeType%2A>"
  example:
  - "The following code example creates a new queue, sends a message that contains an order to it, and then retrieves it.  \n  \n [!code-cpp[Message.Body#1](~/add/codesnippet/cpp/m-system.messaging.messa_33_1.cpp)]\n [!code-cs[Message.Body#1](~/add/codesnippet/csharp/m-system.messaging.messa_33_1.cs)]\n [!code-vb[Message.Body#1](~/add/codesnippet/visualbasic/m-system.messaging.messa_33_1.vb)]"
  syntax:
    content: public Message (object body);
    parameters:
    - id: body
      type: System.Object
      description: "要序列化到消息的正文的对象。"
  overload: System.Messaging.Message.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)
  id: '#ctor(System.Object,System.Messaging.IMessageFormatter)'
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Message(Object,IMessageFormatter)
  nameWithType: Message.Message(Object,IMessageFormatter)
  fullName: System.Messaging.Message.Message(Object,IMessageFormatter)
  type: Constructor
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "初始化的新实例<xref href=&quot;System.Messaging.Message&quot;></xref>类使用指定的格式化程序将指定的对象序列化为消息的正文。"
  remarks: "使用此重载来创建的新实例<xref:System.Messaging.Message>类，该类包含<xref:System.Messaging.Message.Body%2A>指定的`body`参数且使用任何有效的格式化程序进行序列化正文。</xref:System.Messaging.Message.Body%2A> </xref:System.Messaging.Message> `body`参数是可序列化，如文本字符串、 结构对象、 类实例或嵌入的对象的任何对象。 如果你更改<xref:System.Messaging.Message.Body%2A>或<xref:System.Messaging.Message.Formatter%2A>属性之前调用的任何时候<xref:System.Messaging.MessageQueue.Send%2A>，消息会根据新的属性值进行序列化。</xref:System.Messaging.MessageQueue.Send%2A> </xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.Message.Body%2A>       <xref:System.Messaging.XmlMessageFormatter>松散耦合的因此不需要具有相同的对象时使用此格式类型上的发送者和接收者。</xref:System.Messaging.XmlMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>和<xref:System.Messaging.BinaryMessageFormatter>数据序列化为二进制表示形式。</xref:System.Messaging.BinaryMessageFormatter> </xref:System.Messaging.ActiveXMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>发送或接收 COM 组件时使用。</xref:System.Messaging.ActiveXMessageFormatter>       下表显示<xref:System.Messaging.Message>.</xref:System.Messaging.Message>实例的初始属性的值      |属性 |初始值 |  |--------------|-------------------|  |<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  |<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  |<xref:System.Messaging.Message.AppSpecific%2A>|0|  |<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  |<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider 1.0 版 |  |<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  |<xref:System.Messaging.Message.Body%2A>|`body`参数。 |  |<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  |<xref:System.Messaging.Message.BodyType%2A>|0|  |<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  |<xref:System.Messaging.Message.CorrelationId%2A>|空字符串 (&quot;&quot;) |  |<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|一个零长度的字节数组 |  |<xref:System.Messaging.Message.DigitalSignature%2A>|一个零长度的字节数组 |  |<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  |<xref:System.Messaging.Message.Extension%2A>|一个零长度的字节数组 |  |<xref:System.Messaging.Message.Formatter%2A>|`formatter`参数。 |  |<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  |<xref:System.Messaging.Message.Label%2A>|空字符串 (&quot;&quot;) |  |<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  |<xref:System.Messaging.Message.Recoverable%2A>|`false`|  |<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  |<xref:System.Messaging.Message.SenderCertificate%2A>|一个零长度的字节数组 |  |<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  |<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  |<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  |<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  |<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  |<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  |<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  |<xref:System.Messaging.Message.UseTracing%2A>|`false`|</xref:System.Messaging.Message.UseTracing%2A></xref:System.Messaging.Message.UseJournalQueue%2A></xref:System.Messaging.Message.UseEncryption%2A></xref:System.Messaging.Message.UseDeadLetterQueue%2A></xref:System.Messaging.Message.UseAuthentication%2A></xref:System.Messaging.Message.TransactionStatusQueue%2A></xref:System.Messaging.Message.TimeToReachQueue%2A></xref:System.Messaging.Message.TimeToBeReceived%2A></xref:System.Messaging.Message.SenderCertificate%2A></xref:System.Messaging.Message.ResponseQueue%2A></xref:System.Messaging.Message.Recoverable%2A></xref:System.Messaging.Message.Priority%2A></xref:System.Messaging.Message.Label%2A></xref:System.Messaging.Message.HashAlgorithm%2A></xref:System.Messaging.Message.Formatter%2A></xref:System.Messaging.Message.Extension%2A></xref:System.Messaging.Message.EncryptionAlgorithm%2A></xref:System.Messaging.Message.DigitalSignature%2A></xref:System.Messaging.Message.DestinationSymmetricKey%2A></xref:System.Messaging.Message.CorrelationId%2A></xref:System.Messaging.Message.ConnectorType%2A></xref:System.Messaging.Message.BodyType%2A></xref:System.Messaging.Message.BodyStream%2A></xref:System.Messaging.Message.Body%2A></xref:System.Messaging.Message.AuthenticationProviderType%2A></xref:System.Messaging.Message.AuthenticationProviderName%2A></xref:System.Messaging.Message.AttachSenderId%2A></xref:System.Messaging.Message.AppSpecific%2A></xref:System.Messaging.Message.AdministrationQueue%2A></xref:System.Messaging.Message.AcknowledgeType%2A>"
  example:
  - >-
    [!code-cpp[MessagingBinaryFormatter#1](~/add/codesnippet/cpp/6734a59e-0a86-49d1-96b9-_1.cpp)]
     [!code-cs[MessagingBinaryFormatter#1](~/add/codesnippet/csharp/6734a59e-0a86-49d1-96b9-_1.cs)]
     [!code-vb[MessagingBinaryFormatter#1](~/add/codesnippet/visualbasic/6734a59e-0a86-49d1-96b9-_1.vb)]
  syntax:
    content: public Message (object body, System.Messaging.IMessageFormatter formatter);
    parameters:
    - id: body
      type: System.Object
      description: "要序列化到消息的正文的对象。"
    - id: formatter
      type: System.Messaging.IMessageFormatter
      description: "A <xref href=&quot;System.Messaging.IMessageFormatter&quot;> </xref> ，指定用来序列化消息正文的格式化程序。"
  overload: System.Messaging.Message.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.Message.AcknowledgeType
  id: AcknowledgeType
  parent: System.Messaging.Message
  langs:
  - csharp
  name: AcknowledgeType
  nameWithType: Message.AcknowledgeType
  fullName: System.Messaging.Message.AcknowledgeType
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取或设置确认消息返回给发送应用程序的类型。"
  remarks: "AcknowledgeType 属性指定发送应用程序请求的确认消息的类型。 在发送消息来请求特定事件的通知之前设置 AcknowledgeType 属性 — 例如，消息到达其目标队列、 正在检索消息或超时妨碍到达或正在从目标队列检索消息。       消息队列的确认将消息发送到返回通知<xref:System.Messaging.Message.AdministrationQueue%2A>指定原始消息属性。</xref:System.Messaging.Message.AdministrationQueue%2A> 确认消息的<xref:System.Messaging.Message.Acknowledgment%2A>属性指示确认它所表示的类型。</xref:System.Messaging.Message.Acknowledgment%2A> 例如，如果发送确认消息，因为消息未到达之前目标<xref:System.Messaging.Message.TimeToReachQueue%2A>间隔过期，<xref:System.Messaging.Message.Acknowledgment%2A>的确认消息的属性将包含值`ReachQueueTimeout`。</xref:System.Messaging.Message.Acknowledgment%2A> </xref:System.Messaging.Message.TimeToReachQueue%2A>"
  example:
  - "The following code example sends and receives a message containing an order to and from a queue. It specifically requests a positive acknowledgment when the original message reaches or is retrieved from the queue.  \n  \n [!code-cs[Message.Acknowledgment#1](~/add/codesnippet/csharp/p-system.messaging.messa_11_1.cs)]\n [!code-cpp[Message.Acknowledgment#1](~/add/codesnippet/cpp/p-system.messaging.messa_11_1.cpp)]\n [!code-vb[Message.Acknowledgment#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_11_1.vb)]"
  syntax:
    content: public System.Messaging.AcknowledgeTypes AcknowledgeType { get; set; }
    return:
      type: System.Messaging.AcknowledgeTypes
      description: "之一<xref href=&quot;System.Messaging.AcknowledgeTypes&quot;></xref>表示的确认消息中的管理队列并在其下确认返回到发送应用程序的条件时，系统开机的这两种类型的值。 默认值是<xref uid=&quot;langword_csharp_None&quot; name=&quot;None&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.AcknowledgeType*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "消息筛选以忽略 AcknowledgeType 属性。"
  platform:
  - net462
- uid: System.Messaging.Message.Acknowledgment
  id: Acknowledgment
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Acknowledgment
  nameWithType: Message.Acknowledgment
  fullName: System.Messaging.Message.Acknowledgment
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取此消息表示的确认的分类。"
  remarks: "当你将收到来自管理队列时，读取确认属性以验证原始消息的状态。       当消息发送到其目标队列时，消息队列可以请求将数据发送确认消息。 例如，使用消息到达并被检索在指定超时值，也可能表明发生了什么错误传递失败的情况下，可以指示此类消息。 目标队列返回确认消息，并将其发布到原始消息中指定的管理队列<xref:System.Messaging.Message.AdministrationQueue%2A>属性。</xref:System.Messaging.Message.AdministrationQueue%2A> <xref:System.Messaging.Message.Id%2A>的确认消息的属性标识的确认消息，不是原始消息。</xref:System.Messaging.Message.Id%2A> 你可以在该确认找到原始消息的标识符<xref:System.Messaging.Message>实例的<xref:System.Messaging.Message.CorrelationId%2A>属性。</xref:System.Messaging.Message.CorrelationId%2A> </xref:System.Messaging.Message>       如果此<xref:System.Messaging.Message>实例表示的确认消息，确认属性指定的确认类型。</xref:System.Messaging.Message> 否则，确认属性将包含值`Normal`。       使用<xref:System.Messaging.Message.AcknowledgeType%2A>以指定将在其下返回确认的情况的原始消息的属性。</xref:System.Messaging.Message.AcknowledgeType%2A>"
  syntax:
    content: public System.Messaging.Acknowledgment Acknowledgment { get; }
    return:
      type: System.Messaging.Acknowledgment
      description: "之一<xref href=&quot;System.Messaging.Acknowledgment&quot;></xref>枚举值。"
  overload: System.Messaging.Message.Acknowledgment*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "尚未发送消息。 此属性仅可以在从队列中检索的消息上读取。       -或-消息队列筛选以忽略<xref:System.Messaging.MessagePropertyFilter.Acknowledgment*>属性。</xref:System.Messaging.MessagePropertyFilter.Acknowledgment*>"
  platform:
  - net462
- uid: System.Messaging.Message.AdministrationQueue
  id: AdministrationQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: AdministrationQueue
  nameWithType: Message.AdministrationQueue
  fullName: System.Messaging.Message.AdministrationQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取或设置接收消息队列生成的确认消息的队列。"
  remarks: "AdministrationQueue 属性中指定的队列可以是任何非事务性队列。 发送到管理队列的确认消息可以指示原始消息是否到达其目标队列以及是否已从队列中已删除。       当<xref:System.Messaging.Message.AcknowledgeType%2A>属性以外的任何值`None`，发送应用程序必须指定要用作管理队列的队列。</xref:System.Messaging.Message.AcknowledgeType%2A>"
  example:
  - "The following code example sends and receives a message containing an order to and from a queue. It specifically requests a positive acknowledgment when the original message reaches or is retrieved from the queue.  \n  \n [!code-cs[Message.Acknowledgment#1](~/add/codesnippet/csharp/p-system.messaging.messa_47_1.cs)]\n [!code-cpp[Message.Acknowledgment#1](~/add/codesnippet/cpp/p-system.messaging.messa_47_1.cpp)]\n [!code-vb[Message.Acknowledgment#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_47_1.vb)]"
  syntax:
    content: public System.Messaging.MessageQueue AdministrationQueue { get; set; }
    return:
      type: System.Messaging.MessageQueue
      description: "<xref href=&quot;System.Messaging.MessageQueue&quot;> </xref> ，它指定用于系统生成的确认消息的管理队列。 默认值是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.AdministrationQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "消息队列筛选以忽略 AdministrationQueue 属性。"
  platform:
  - net462
- uid: System.Messaging.Message.AppSpecific
  id: AppSpecific
  parent: System.Messaging.Message
  langs:
  - csharp
  name: AppSpecific
  nameWithType: Message.AppSpecific
  fullName: System.Messaging.Message.AppSpecific
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取或设置、 应用程序特定的附加信息。"
  remarks: "AppSpecific 属性包含可用于组织不同类型的消息的应用程序特定信息。 例如，你可以使用应用程序特定的索引。 它负责要解释 AppSpecific 属性信息的应用程序。       只要有可能，应将消息数据包含的消息，而不是 AppSpecific 属性正文中。       在使用外部队列，使用<xref:System.Messaging.Message.Extension%2A>属性指定在消息队列中不存在的消息属性。</xref:System.Messaging.Message.Extension%2A> 因为与 AppSpecific 属性，它是要了解的内容的应用程序的责任<xref:System.Messaging.Message.Extension%2A>属性。</xref:System.Messaging.Message.Extension%2A>"
  syntax:
    content: public int AppSpecific { get; set; }
    return:
      type: System.Int32
      description: "特定于应用程序的信息。 默认值为零。"
  overload: System.Messaging.Message.AppSpecific*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "消息队列筛选以忽略 AppSpecific 属性。"
  platform:
  - net462
- uid: System.Messaging.Message.ArrivedTime
  id: ArrivedTime
  parent: System.Messaging.Message
  langs:
  - csharp
  name: ArrivedTime
  nameWithType: Message.ArrivedTime
  fullName: System.Messaging.Message.ArrivedTime
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取消息到达目标队列的时间。"
  remarks: "消息的<xref:System.Messaging.Message.TimeToBeReceived%2A>属性指示必须从目标队列收到的消息的速度。</xref:System.Messaging.Message.TimeToBeReceived%2A> <xref:System.Messaging.Message.TimeToBeReceived%2A>属性计时器将开始发送消息，不在消息到达队列中时。</xref:System.Messaging.Message.TimeToBeReceived%2A>"
  example:
  - "The following code example displays the value of a message's ArrivedTime property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public DateTime ArrivedTime { get; }
    return:
      type: System.DateTime
      description: "A<xref:System.DateTime>表示消息的到达目标队列的时间。</xref:System.DateTime> 该时间从格林威治标准时间调整为目标队列所驻留的计算机的本地时间。"
  overload: System.Messaging.Message.ArrivedTime*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "尚未发送消息。 此属性仅可以在从队列中检索的消息上读取。       -或者-消息队列筛选以忽略 ArrivedTime 属性。"
  platform:
  - net462
- uid: System.Messaging.Message.AttachSenderId
  id: AttachSenderId
  parent: System.Messaging.Message
  langs:
  - csharp
  name: AttachSenderId
  nameWithType: Message.AttachSenderId
  fullName: System.Messaging.Message.AttachSenderId
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取或设置一个值，该值指示是否发件人 ID 应附加到消息。"
  remarks: "<xref:System.Messaging.Message.SenderId%2A>属性是表示发送用户的标识符的字节数组。</xref:System.Messaging.Message.SenderId%2A> 发件人 ID 由消息队列设置，并且用于通过接收队列管理器来验证发件人是否有权访问队列。       发件人 ID，则发送应用程序，消息队列应不验证消息的发件人，也不验证发件人的访问权限表示缺少权限到接收队列。 <xref:System.Messaging.Message.SenderId%2A>值得仅当消息已验证时它已达到目标队列。</xref:System.Messaging.Message.SenderId%2A> 消息队列接受仅经过身份验证的消息，并且如果到达目标队列时被拒绝<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>或<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>属性是`false`。</xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A> </xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>      1> [!CAUTION]&1;> 如果被拒绝消息，它或者被发送到死信队列 (如果<xref:System.Messaging.Message.UseDeadLetterQueue%2A>是`true`)，或它将被忽略。</xref:System.Messaging.Message.UseDeadLetterQueue%2A> 当一条消息未能到达队列时，你可以请求确认。 否则为在<xref:System.Messaging.Message.UseDeadLetterQueue%2A>是`false`消息可能会丢失而不发出警告。</xref:System.Messaging.Message.UseDeadLetterQueue%2A>"
  example:
  - "The following code example gets and sets the value of a message's AttachSenderId property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool AttachSenderId { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref:System.Messaging.Message.SenderId*>附加到消息; 否则为应为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.Messaging.Message.SenderId*> 默认值是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.AttachSenderId*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "消息队列筛选以忽略 AttachSenderId 属性。"
  platform:
  - net462
- uid: System.Messaging.Message.Authenticated
  id: Authenticated
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Authenticated
  nameWithType: Message.Authenticated
  fullName: System.Messaging.Message.Authenticated
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取一个值，该值指示消息是否已验证。"
  remarks: "它是与消息交互，并尝试确定是否已请求身份验证时，只能由应用程序使用身份验证属性。 如果消息已在队列中，消息已验证。 相反，如果已通过身份验证属性为`true`，接收队列管理器身份验证消息，当收到该消息。       无法确定消息是否未通过查看其属性通过身份验证。 消息队列丢弃身份验证失败之前它们传递到队列的消息。 但是，你可以请求如果传送失败防止消息到达队列中，会发送确认消息。"
  example:
  - "The following code example displays the value of a message's Authenticated property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool Authenticated { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果其输入队列; 已请求消息身份验证，否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.Authenticated*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "尚未发送消息。 此属性仅可以在从队列中检索的消息上读取。       -或者-消息队列筛选若要忽略的身份验证属性。"
  platform:
  - net462
- uid: System.Messaging.Message.AuthenticationProviderName
  id: AuthenticationProviderName
  parent: System.Messaging.Message
  langs:
  - csharp
  name: AuthenticationProviderName
  nameWithType: Message.AuthenticationProviderName
  fullName: System.Messaging.Message.AuthenticationProviderName
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取或设置用于生成消息的数字签名的加密提供程序的名称。"
  remarks: "使用外部队列时，通常可以使用 AuthenticationProviderName。 消息队列需要的身份验证提供程序名称和加密服务提供程序 （身份验证提供程序） 来验证发送到外队列的消息和从外队列传递到消息队列的消息的数字签名的身份验证提供程序类型。       发送邮件时，始终设置 AuthenticationProviderName 和<xref:System.Messaging.Message.ConnectorType%2A>属性组合在一起。</xref:System.Messaging.Message.ConnectorType%2A> 如果连接器类型还未设置，发送消息，消息队列将忽略身份验证提供程序名称。       AuthenticationProviderName 属性不能为`null`，但它可以是空字符串 (&quot;&quot;)。"
  syntax:
    content: public string AuthenticationProviderName { get; set; }
    return:
      type: System.String
      description: "用于生成消息的数字签名的加密提供程序的名称。 默认值为 Microsoft Base Cryptographic Provider 1.0 版。"
  overload: System.Messaging.Message.AuthenticationProviderName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "无法设置 AuthenticationProviderName 属性。       -或者-消息队列筛选以忽略 AuthenticationProviderName 属性。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "AuthenticationProviderName 已设置为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.Messaging.Message.AuthenticationProviderType
  id: AuthenticationProviderType
  parent: System.Messaging.Message
  langs:
  - csharp
  name: AuthenticationProviderType
  nameWithType: Message.AuthenticationProviderType
  fullName: System.Messaging.Message.AuthenticationProviderType
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取或设置用于生成消息的数字签名的加密提供程序的类型。"
  remarks: "你通常用于 AuthenticationProviderType 属性使用外部队列时指定的加密服务提供程序是与消息关联。 消息队列需要的身份验证提供程序名称和加密服务提供程序 （身份验证提供程序） 来验证发送到外队列的消息和从外队列传递到消息队列的消息的数字签名的身份验证提供程序类型。       仅`RsaFull`旨在与消息一起使用。       发送邮件时，始终设置 AuthenticationProviderType 和<xref:System.Messaging.Message.ConnectorType%2A>属性组合在一起。</xref:System.Messaging.Message.ConnectorType%2A> 如果连接器类型还未设置，发送消息，消息队列将忽略的身份验证提供程序类型。"
  syntax:
    content: public System.Messaging.CryptographicProviderType AuthenticationProviderType { get; set; }
    return:
      type: System.Messaging.CryptographicProviderType
      description: "之一<xref href=&quot;System.Messaging.CryptographicProviderType&quot;></xref>值。 默认值是<xref uid=&quot;langword_csharp_RSA_FULL&quot; name=&quot;RSA_FULL&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.AuthenticationProviderType*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "无法设置 AuthenticationProviderType 属性。       -或者-消息队列筛选以忽略 AuthenticationProviderType 属性。"
  platform:
  - net462
- uid: System.Messaging.Message.Body
  id: Body
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Body
  nameWithType: Message.Body
  fullName: System.Messaging.Message.Body
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取或设置消息的内容。"
  remarks: "消息的正文属性通常包含与消息关联的数据。 虽然你还可以发送应用程序特定数据<xref:System.Messaging.Message.AppSpecific%2A>和<xref:System.Messaging.Message.Extension%2A>属性，您应尽可能消息的正文中包含消息数据。</xref:System.Messaging.Message.Extension%2A> </xref:System.Messaging.Message.AppSpecific%2A> 序列化或加密正文的属性内容。       Body 属性可以包含任何对象，其大小不超过 4 MB。 如果你使用<xref:System.Messaging.MessageQueue.Send%2A?displayProperty=fullName>发送程序的类型<xref:System.Messaging.Message><xref:System.Messaging.MessageQueue>，该对象将位于<xref:System.Messaging.Message>实例返回<xref:System.Messaging.MessageQueue.Peek%2A>或<xref:System.Messaging.MessageQueue.Receive%2A>。</xref:System.Messaging.MessageQueue.Receive%2A></xref:System.Messaging.MessageQueue.Peek%2A></xref:System.Messaging.Message>的 Body 属性</xref:System.Messaging.MessageQueue></xref:System.Messaging.Message>不是任何对象</xref:System.Messaging.MessageQueue.Send%2A?displayProperty=fullName>       中的字符串自变量`MessageQueue.Send(&quot;hello.&quot;)`是一个示例是一般的对象。       <xref:System.Messaging.Message.BodyType%2A>属性指示消息正文中存储的信息的类型。</xref:System.Messaging.Message.BodyType%2A> 消息队列使用此信息来标识的正文属性内容类型。       指定正文属性或<xref:System.Messaging.Message.BodyStream%2A>属性在发送之前<xref:System.Messaging.Message>对象。</xref:System.Messaging.Message> </xref:System.Messaging.Message.BodyStream%2A> Body 属性可以是任何可序列化对象，例如文本字符串、 结构对象、 类实例或嵌入的对象。       除非你将写入消息的内容直接<xref:System.Messaging.Message.BodyStream%2A>属性，设置<xref:System.Messaging.Message.Formatter%2A>属性后，发送消息。</xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.Message.BodyStream%2A> 当<xref:System.Messaging.MessageQueue.Send%2A>方法调用<xref:System.Messaging.MessageQueue>实例，正文使用序列化格式化程序中包含<xref:System.Messaging.Message.Formatter%2A>属性。</xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.MessageQueue> </xref:System.Messaging.MessageQueue.Send%2A> 如果你发送消息时未指定<xref:System.Messaging.Message.Formatter%2A>属性，则格式化程序默认为<xref:System.Messaging.XmlMessageFormatter>.</xref:System.Messaging.XmlMessageFormatter></xref:System.Messaging.Message.Formatter%2A>的值      1> [!NOTE]&1;> 正在尝试设置到的消息正文<xref:System.Decimal.MaxValue>将导致<xref:System.OverflowException>时`Send`方法<xref:System.Messaging.MessageQueue>类称为和<xref:System.Messaging.ActiveXMessageFormatter>使用。</xref:System.Messaging.ActiveXMessageFormatter> </xref:System.Messaging.MessageQueue> </xref:System.OverflowException> </xref:System.Decimal.MaxValue>"
  example:
  - "The following code example sends two messages of different priorities to the queue, and retrieves them subsequently.  \n  \n [!code-cpp[Message.DefaultPropertiesToSend#1](~/add/codesnippet/cpp/p-system.messaging.messa_13_1.cpp)]\n [!code-vb[Message.DefaultPropertiesToSend#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_13_1.vb)]\n [!code-cs[Message.DefaultPropertiesToSend#1](~/add/codesnippet/csharp/p-system.messaging.messa_13_1.cs)]"
  syntax:
    content: public object Body { get; set; }
    return:
      type: System.Object
      description: "一个指定消息内容的对象。 对象可以是字符串、 日期、 货币、 数字、 字节，数组或任何托管的对象。"
  overload: System.Messaging.Message.Body*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref:System.Messaging.Message.Formatter*>属性是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。</xref:System.Messaging.Message.Formatter*>       -或者-消息队列筛选若要忽略的 Body 属性。"
  platform:
  - net462
- uid: System.Messaging.Message.BodyStream
  id: BodyStream
  parent: System.Messaging.Message
  langs:
  - csharp
  name: BodyStream
  nameWithType: Message.BodyStream
  fullName: System.Messaging.Message.BodyStream
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取或设置消息的正文中的信息。"
  remarks: "一条消息的主体可以包含的任何类型的信息 —，字符串、 日期、 货币、 数字、 字节，数组或任何托管的对象。 此信息序列化为<xref:System.IO.Stream>要传递给队列。</xref:System.IO.Stream>       指定<xref:System.Messaging.Message.Body%2A>属性或 BodyStream 属性在发送之前<xref:System.Messaging.Message>对象。</xref:System.Messaging.Message> </xref:System.Messaging.Message.Body%2A> 如果你设置<xref:System.Messaging.Message.Body%2A>属性，内容序列化到 BodyStream 属性。</xref:System.Messaging.Message.Body%2A> 但是，你可以选择将数据直接写入 BodyStream 属性。 这很有用，例如，如果想要打开的连接到文件并将其内容序列作为你的消息的正文。       消息的内容直接写入 BodyStream 属性，除非设置<xref:System.Messaging.Message.Formatter%2A>属性后，发送消息。</xref:System.Messaging.Message.Formatter%2A> 当<xref:System.Messaging.MessageQueue.Send%2A>方法调用<xref:System.Messaging.MessageQueue>实例，正文使用序列化格式化程序中包含<xref:System.Messaging.Message.Formatter%2A>属性。</xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.MessageQueue> </xref:System.Messaging.MessageQueue.Send%2A> 如果你发送消息时未指定<xref:System.Messaging.Message.Formatter%2A>属性，则格式化程序默认为<xref:System.Messaging.XmlMessageFormatter>.</xref:System.Messaging.XmlMessageFormatter></xref:System.Messaging.Message.Formatter%2A>的值       如果你设置<xref:System.Messaging.Message.UseEncryption%2A>属性`true`为此消息的正文，消息将被加密发送时，不是在你设置时<xref:System.Messaging.Message.Body%2A>属性。</xref:System.Messaging.Message.Body%2A> </xref:System.Messaging.Message.UseEncryption%2A> 因此，永远不会进行加密 BodyStream 属性。"
  syntax:
    content: public System.IO.Stream BodyStream { get; set; }
    return:
      type: System.IO.Stream
      description: "A<xref:System.IO.Stream>包含中包含的序列化的信息<xref:System.Messaging.Message.Body*>的消息。</xref:System.Messaging.Message.Body*> </xref:System.IO.Stream>"
  overload: System.Messaging.Message.BodyStream*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "消息队列筛选以忽略<xref:System.Messaging.Message.Body*>属性。</xref:System.Messaging.Message.Body*>"
  platform:
  - net462
- uid: System.Messaging.Message.BodyType
  id: BodyType
  parent: System.Messaging.Message
  langs:
  - csharp
  name: BodyType
  nameWithType: Message.BodyType
  fullName: System.Messaging.Message.BodyType
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取或设置消息正文所包含的数据的类型。"
  remarks: "消息队列会将正文内容视为一个对象或序列化的流。 BodyType 属性指示中的对象的类型<xref:System.Messaging.Message.Body%2A>消息的属性。</xref:System.Messaging.Message.Body%2A>       <xref:System.Messaging.XmlMessageFormatter>完成消息正文中本机类型与对象之间的绑定。</xref:System.Messaging.XmlMessageFormatter> 如果你使用<xref:System.Messaging.XmlMessageFormatter>，格式化程序会为您设置 BodyType 属性。</xref:System.Messaging.XmlMessageFormatter>       此外，如下面的 C# 代码中所示，其他格式化程序可以提供绑定功能。      ```   message.Formatter = new ActiveXMessageFormatter();   object myObject message.Body;   if (myObject is string) {   }   if (myObject is int) {   }   if (myObject is float) {   }   ```"
  example:
  - "The following code example displays the value of a message's BodyType property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public int BodyType { get; set; }
    return:
      type: System.Int32
      description: "消息正文的 true 类型，如字符串、 日期、 货币、 或数字。"
  overload: System.Messaging.Message.BodyType*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "消息队列筛选以忽略<xref:System.Messaging.Message.Body*>属性。</xref:System.Messaging.Message.Body*>"
  platform:
  - net462
- uid: System.Messaging.Message.ConnectorType
  id: ConnectorType
  parent: System.Messaging.Message
  langs:
  - csharp
  name: ConnectorType
  nameWithType: Message.ConnectorType
  fullName: System.Messaging.Message.ConnectorType
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取或设置一个值，表示一些通常由消息队列设置的消息属性已由发送应用程序设置。"
  remarks: "消息队列要求 ConnectorType 属性将设置只要应用程序设置通常由消息队列设置的消息属性。 应用程序通常在以下两种情况下使用 ConnectorType:-每当连接器应用程序将消息传递。 ConnectorType 告知发送和接收应用程序如何解释消息的安全性和确认属性。      -每当发送应用程序，而不是消息队列，加密消息。 ConnectorType 通知消息队列使用<xref:System.Messaging.Message.DestinationSymmetricKey%2A>属性值来对消息进行解密。</xref:System.Messaging.Message.DestinationSymmetricKey%2A>       如果设置了任何以下属性，必须设置 ConnectorType 属性 （否则，队列将忽略这些属性在发送邮件时）:- <xref:System.Messaging.Message.AuthenticationProviderName%2A>- <xref:System.Messaging.Message.AuthenticationProviderType%2A>- <xref:System.Messaging.Message.DestinationSymmetricKey%2A>- <xref:System.Messaging.Message.DigitalSignature%2A>- <xref:System.Messaging.Message.MessageType%2A>- <xref:System.Messaging.Message.SenderId%2A></xref:System.Messaging.Message.SenderId%2A> </xref:System.Messaging.Message.MessageType%2A> </xref:System.Messaging.Message.DigitalSignature%2A> </xref:System.Messaging.Message.DestinationSymmetricKey%2A> </xref:System.Messaging.Message.AuthenticationProviderType%2A> </xref:System.Messaging.Message.AuthenticationProviderName%2A>"
  syntax:
    content: public Guid ConnectorType { get; set; }
    return:
      type: System.Guid
      description: "A<xref:System.Guid>由应用程序定义，并与连接器应用程序或消息加密结合使用。</xref:System.Guid> 这<xref:System.Guid>允许接收的应用程序来解释由发送应用程序设置，但通常设置的消息队列的消息属性。</xref:System.Guid>"
  overload: System.Messaging.Message.ConnectorType*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "消息队列筛选以忽略 ConnectorType 属性。"
  platform:
  - net462
- uid: System.Messaging.Message.CorrelationId
  id: CorrelationId
  parent: System.Messaging.Message
  langs:
  - csharp
  name: CorrelationId
  nameWithType: Message.CorrelationId
  fullName: System.Messaging.Message.CorrelationId
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取或设置确认、 报告和响应消息用以引用原始消息的消息标识符。"
  remarks: "消息队列生成确认或报告消息时，它将使用相关标识符属性来指定原始消息的消息标识符。 这种方式，相关标识符就将报表或确认消息与原始消息关联起来。       发送应用程序然后可以进行匹配将确认或报告与原始消息通过使用 CorrelationId 属性标识原始消息的<xref:System.Messaging.Message.Id%2A>属性。</xref:System.Messaging.Message.Id%2A>       连接器应用程序还必须设置确认和报告消息的 CorrelationId 属性为原始消息的消息标识符。       你的应用程序将响应消息发送到发送应用程序，可以将响应消息的 CorrelationId 属性设为原始消息的消息标识符。 然后，发送应用程序可以将响应消息与已发送的消息进行匹配。"
  example:
  - "The following code example sends and receives a message that contains an order to and from a queue. It specifically requests a positive acknowledgment when the original message reaches or is retrieved from the queue.  \n  \n [!code-cs[Message.Acknowledgment#1](~/add/codesnippet/csharp/p-system.messaging.messa_95_1.cs)]\n [!code-cpp[Message.Acknowledgment#1](~/add/codesnippet/cpp/p-system.messaging.messa_95_1.cpp)]\n [!code-vb[Message.Acknowledgment#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_95_1.vb)]"
  syntax:
    content: public string CorrelationId { get; set; }
    return:
      type: System.String
      description: "通过指定的消息标识符<xref:System.Messaging.Message.Id*>原始消息的属性。</xref:System.Messaging.Message.Id*> 相关标识符由消息队列时它会生成确认或报告消息，而应用程序时使用它将生成响应消息。"
  overload: System.Messaging.Message.CorrelationId*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "消息队列筛选以忽略 CorrelationId 属性。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "CorrelationId 是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.Messaging.Message.DestinationQueue
  id: DestinationQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: DestinationQueue
  nameWithType: Message.DestinationQueue
  fullName: System.Messaging.Message.DestinationQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取一条消息的预期的目标队列。"
  remarks: "DestinationQueue 属性通常用于确定到达日记队列或死信队列的消息的原始目标。 通常情况下，你不必检查此属性，因为通常从其目标队列检索消息。"
  example:
  - "The following code example displays the value of a message's DestinationQueue property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public System.Messaging.MessageQueue DestinationQueue { get; }
    return:
      type: System.Messaging.MessageQueue
      description: "A <xref href=&quot;System.Messaging.MessageQueue&quot;> </xref> ，它指定消息的预期的目标队列。"
  overload: System.Messaging.Message.DestinationQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "尚未发送消息。 此属性仅可以在从队列中检索的消息上读取。       -或者-消息队列筛选以忽略 DestinationQueue 属性。"
  platform:
  - net462
- uid: System.Messaging.Message.DestinationSymmetricKey
  id: DestinationSymmetricKey
  parent: System.Messaging.Message
  langs:
  - csharp
  name: DestinationSymmetricKey
  nameWithType: Message.DestinationSymmetricKey
  fullName: System.Messaging.Message.DestinationSymmetricKey
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取或设置对称密钥用于加密应用程序加密的消息或发送到外部队列的消息。"
  remarks: "两种方案需要使用 DestinationSymmetricKey 属性。 第一种是当你应用程序，而不是消息队列，对消息进行加密。 第二个是当将加密的消息发送到以外消息队列的队列系统。       设置此属性之前，必须对接收队列管理器的公共密钥的对称密钥进行加密。 当你发送应用程序加密的消息时，接收队列管理器使用对称密钥对消息发送到其目标队列之前进行解密。       如果向外队列发送一条消息，将加密的消息转发到接收应用程序的附加对称密钥与相应的连接器应用程序先接收消息。 然后，它是接收应用程序中，可以对消息使用的对称密钥进行解密的责任。       当设置 DestinationSymmetricKey 属性时，你还必须设置<xref:System.Messaging.Message.ConnectorType%2A>属性。</xref:System.Messaging.Message.ConnectorType%2A> 发送消息，消息队列会忽略 DestinationSymmetricKey 属性如果<xref:System.Messaging.Message.ConnectorType%2A>还未设置属性。</xref:System.Messaging.Message.ConnectorType%2A>       DestinationSymmetricKey 属性具有的最大数组大小为 256。"
  syntax:
    content: public byte[] DestinationSymmetricKey { get; set; }
    return:
      type: System.Byte[]
      description: "指定用来加密消息的目标对称密钥的字节值数组。 默认值为零长度数组。"
  overload: System.Messaging.Message.DestinationSymmetricKey*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "消息队列筛选以忽略 DestinationSymmetricKey 属性。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "DestinationSymmetricKey 是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.Messaging.Message.DigitalSignature
  id: DigitalSignature
  parent: System.Messaging.Message
  langs:
  - csharp
  name: DigitalSignature
  nameWithType: Message.DigitalSignature
  fullName: System.Messaging.Message.DigitalSignature
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取或设置消息队列用于对消息进行身份验证的数字签名。"
  remarks: "已发送的消息队列版本 1.0 的消息进行身份验证时，消息队列将使用数字签名。 在大多数情况下，消息队列生成，并在发送应用程序请求身份验证时设置 DigitalSignature 属性。 接收应用程序使用此属性来检索附加到消息的数字签名。       运行消息队列 2.0 版时，你可以只使用 DigitalSignature 属性。 请求身份验证时，发送应用程序必须指定消息队列 1.0 版签名。 如果发送应用程序发送的消息队列 2.0 版签名，此属性将包含四个字节，每个包含零的缓冲区。       DigitalSignature 属性，与一起<xref:System.Messaging.Message.SenderCertificate%2A>属性，也使用连接器应用程序发送一条消息时。</xref:System.Messaging.Message.SenderCertificate%2A> 在此方案中，连接器应用程序，而不是消息队列-生成的数字签名，它将根据发送消息的用户的证书。       DigitalSignature 属性具有的最大数组大小为 256。       当设置 DigitalSignature 属性时，你还必须设置<xref:System.Messaging.Message.ConnectorType%2A>属性。</xref:System.Messaging.Message.ConnectorType%2A> 在发送一条消息，消息队列会忽略 DigitalSignature 属性如果<xref:System.Messaging.Message.ConnectorType%2A>还未设置属性。</xref:System.Messaging.Message.ConnectorType%2A>"
  syntax:
    content: public byte[] DigitalSignature { get; set; }
    return:
      type: System.Byte[]
      description: "指定用于对消息进行身份验证的消息队列 1.0 数字签名的字节值数组。 默认值为零长度数组。"
  overload: System.Messaging.Message.DigitalSignature*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "消息队列筛选以忽略 DigitalSignature 属性。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "DigitalSignature 属性是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.Messaging.Message.EncryptionAlgorithm
  id: EncryptionAlgorithm
  parent: System.Messaging.Message
  langs:
  - csharp
  name: EncryptionAlgorithm
  nameWithType: Message.EncryptionAlgorithm
  fullName: System.Messaging.Message.EncryptionAlgorithm
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取或设置用于加密私有消息的正文的加密算法。"
  remarks: "如果消息是私有 （加密），则消息前发送和在接收时解密被加密。 EncryptionAlgorithm 属性指定用于加密私有消息的消息正文的算法。       队列可以要求该传入消息进行加密。 如果应用程序的非加密 （非专用） 消息发送到的队列，只接受私有消息，或如果它将私有消息发送到队列，只接受非私有消息，队列将拒绝该消息。 发送应用程序可以请求，这种情况下会返回否定确认消息。"
  syntax:
    content: public System.Messaging.EncryptionAlgorithm EncryptionAlgorithm { get; set; }
    return:
      type: System.Messaging.EncryptionAlgorithm
      description: "之一<xref href=&quot;System.Messaging.EncryptionAlgorithm&quot;></xref>枚举值。 默认值是<xref uid=&quot;langword_csharp_RC2&quot; name=&quot;RC2&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.EncryptionAlgorithm*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "消息队列筛选以忽略 EncryptionAlgorithm 属性。"
  platform:
  - net462
- uid: System.Messaging.Message.Extension
  id: Extension
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Extension
  nameWithType: Message.Extension
  fullName: System.Messaging.Message.Extension
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取或设置与消息关联的、 应用程序定义的附加信息。"
  remarks: "扩展属性提供有关应用程序定义的信息，如与消息关联的大型二进制对象。 它负责接收应用程序来解释扩展属性的内容。       如果可能，应包含在消息数据<xref:System.Messaging.Message.Body%2A>的消息，而不是扩展属性的属性。</xref:System.Messaging.Message.Body%2A>       在使用外部队列，用于扩展属性指定不存在的消息属性在消息队列中。       非 Microsoft 消息队列的队列系统中不存在外队列。 与此类通过连接器应用程序的队列，消息队列进行通信。"
  syntax:
    content: public byte[] Extension { get; set; }
    return:
      type: System.Byte[]
      description: "提供与消息关联的应用程序定义的信息的字节值数组。 默认值为零长度数组。"
  overload: System.Messaging.Message.Extension*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "消息队列筛选以忽略扩展属性。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "扩展属性是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.Messaging.Message.Formatter
  id: Formatter
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Formatter
  nameWithType: Message.Formatter
  fullName: System.Messaging.Message.Formatter
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取或设置用于序列化到对象或反序列化消息正文中的对象格式化程序。"
  remarks: "使用格式化程序属性时读取和写入一条消息。 当消息发送到队列时，序列化格式化程序<xref:System.Messaging.Message.Body%2A>属性转换成可以发送到消息队列的流。</xref:System.Messaging.Message.Body%2A> 当从队列中读取，格式化程序反序列化到消息数据<xref:System.Messaging.Message.Body%2A>属性。</xref:System.Messaging.Message.Body%2A>       除非你将写入消息的内容直接<xref:System.Messaging.Message.BodyStream%2A>属性，格式化程序前设置属性，你将消息发送。</xref:System.Messaging.Message.BodyStream%2A> 当<xref:System.Messaging.MessageQueue.Send%2A>方法调用<xref:System.Messaging.MessageQueue>实例，正文使用序列化格式化程序属性中包含的格式化程序。</xref:System.Messaging.MessageQueue> </xref:System.Messaging.MessageQueue.Send%2A> 如果发送消息时未指定格式化程序属性的值，则格式化程序默认到<xref:System.Messaging.XmlMessageFormatter>。</xref:System.Messaging.XmlMessageFormatter>       <xref:System.Messaging.XmlMessageFormatter>松散耦合的因此不需要具有相同的对象时使用此格式类型上的发送者和接收者。</xref:System.Messaging.XmlMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>和<xref:System.Messaging.BinaryMessageFormatter>数据序列化为二进制表示形式。</xref:System.Messaging.BinaryMessageFormatter> </xref:System.Messaging.ActiveXMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>发送或接收 COM 组件时使用。</xref:System.Messaging.ActiveXMessageFormatter>"
  example:
  - "The following code example demonstrates formatting a message body using <xref:System.Messaging.BinaryMessageFormatter>.  \n  \n [!code-cpp[MessagingBinaryFormatter#1](~/add/codesnippet/cpp/p-system.messaging.messa_5_1.cpp)]\n [!code-cs[MessagingBinaryFormatter#1](~/add/codesnippet/csharp/p-system.messaging.messa_5_1.cs)]\n [!code-vb[MessagingBinaryFormatter#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_5_1.vb)]  \n  \n The following code example demonstrates formatting a message body using <xref:System.Messaging.XmlMessageFormatter>.  \n  \n [!code-cpp[Message.Body#1](~/add/codesnippet/cpp/p-system.messaging.messa_5_2.cpp)]\n [!code-cs[Message.Body#1](~/add/codesnippet/csharp/p-system.messaging.messa_5_2.cs)]\n [!code-vb[Message.Body#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_5_2.vb)]"
  syntax:
    content: public System.Messaging.IMessageFormatter Formatter { get; set; }
    return:
      type: System.Messaging.IMessageFormatter
      description: "<xref href=&quot;System.Messaging.IMessageFormatter&quot;> </xref>生成可写入或读取从消息正文的流。 默认值是<xref href=&quot;System.Messaging.XmlMessageFormatter&quot;> </xref>。"
  overload: System.Messaging.Message.Formatter*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "格式化程序属性是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.Messaging.Message.HashAlgorithm
  id: HashAlgorithm
  parent: System.Messaging.Message
  langs:
  - csharp
  name: HashAlgorithm
  nameWithType: Message.HashAlgorithm
  fullName: System.Messaging.Message.HashAlgorithm
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取或设置哈希消息队列在消息进行身份验证时使用的算法或创建一条消息的数字签名。"
  remarks: "在源计算机上消息队列使用的哈希算法时创建一条消息的数字签名。 目标队列管理器然后使用相同的哈希算法时将会收到该消息进行身份验证。"
  syntax:
    content: public System.Messaging.HashAlgorithm HashAlgorithm { get; set; }
    return:
      type: System.Messaging.HashAlgorithm
      description: "之一<xref href=&quot;System.Messaging.HashAlgorithm&quot;></xref>枚举值。 对于 Windows XP 中，默认值是<xref uid=&quot;langword_csharp_SHA&quot; name=&quot;SHA&quot; href=&quot;&quot;> </xref>。 否则，默认值是<xref uid=&quot;langword_csharp_MD5&quot; name=&quot;MD5&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.HashAlgorithm*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "消息队列筛选以忽略 HashAlgorithm 属性。"
  platform:
  - net462
- uid: System.Messaging.Message.Id
  id: Id
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Id
  nameWithType: Message.Id
  fullName: System.Messaging.Message.Id
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取消息的标识符。"
  remarks: "发送消息时，消息队列会生成消息标识符。 标识符由 20 个字节组成，包括两个项︰ 机<xref:System.Guid>发送计算机和计算机上消息的唯一标识符。</xref:System.Guid> 两个项组合在一起产生了一个网络是唯一的消息标识符。       消息队列会生成的所有消息的消息标识符 — 包括确认消息和报告消息。 确认消息通常由消息队列发送响应的到达或失败的原始、 发送消息。 你可以查找中的原始消息的 Id 属性值<xref:System.Messaging.Message.CorrelationId%2A>的确认消息的属性。</xref:System.Messaging.Message.CorrelationId%2A>       将响应消息发送到响应队列时，你还可以使用 Id 属性。 若要将响应消息中包含的原始消息的标识符，设置<xref:System.Messaging.Message.CorrelationId%2A>的响应消息写入原始消息的 Id 属性的属性。</xref:System.Messaging.Message.CorrelationId%2A> 然后可以在读取响应消息的应用程序中使用响应消息的相关标识符来标识原始消息。"
  example:
  - "The following code example sends and receives a message containing an order to and from a queue. It specifically requests a positive acknowledgment when the original message reaches or is retrieved from the queue.  \n  \n [!code-cs[Message.Acknowledgment#1](~/add/codesnippet/csharp/p-system.messaging.messa_19_1.cs)]\n [!code-cpp[Message.Acknowledgment#1](~/add/codesnippet/cpp/p-system.messaging.messa_19_1.cpp)]\n [!code-vb[Message.Acknowledgment#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_19_1.vb)]"
  syntax:
    content: public string Id { get; }
    return:
      type: System.String
      description: "消息的唯一标识符，由消息队列生成。"
  overload: System.Messaging.Message.Id*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "尚未发送消息。 此属性仅可以在从队列中检索的消息上读取。       -或者-消息队列筛选若要忽略的 Id 属性。"
  platform:
  - net462
- uid: System.Messaging.Message.InfiniteTimeout
  id: InfiniteTimeout
  parent: System.Messaging.Message
  langs:
  - csharp
  name: InfiniteTimeout
  nameWithType: Message.InfiniteTimeout
  fullName: System.Messaging.Message.InfiniteTimeout
  type: Field
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "指定不存在超时。"
  remarks: "<xref:System.Messaging.Message.TimeToBeReceived%2A>和<xref:System.Messaging.Message.TimeToReachQueue%2A>需要一个值，指定超时。</xref:System.Messaging.Message.TimeToReachQueue%2A></xref:System.Messaging.Message.TimeToBeReceived%2A> 对于前者，超时是允许从队列接收消息的最长时间。 对于后者，该超时是消息到达队列所允许的时间。 在这两种情况下，你可以为的秒数指定的超时，或使用 InfiniteTimeout，指示无超时存在。"
  example:
  - "The following code example demonstrates the use of the InfiniteTimeout field.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public static readonly TimeSpan InfiniteTimeout;
    return:
      type: System.TimeSpan
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.Message.IsFirstInTransaction
  id: IsFirstInTransaction
  parent: System.Messaging.Message
  langs:
  - csharp
  name: IsFirstInTransaction
  nameWithType: Message.IsFirstInTransaction
  fullName: System.Messaging.Message.IsFirstInTransaction
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取一个值，该值指示消息是否已在事务中发送的第一个消息。"
  remarks: "接收应用程序使用 IsFirstInTransaction 属性以验证消息已发送到单个队列单个事务中的第一个消息。       此属性是仅适用于消息队列版本 2.0 及更高版本。       若要验证事务边界，你可以使用 IsFirstInTransaction 属性以及其他两个属性︰<xref:System.Messaging.Message.IsLastInTransaction%2A>和<xref:System.Messaging.Message.TransactionId%2A>。</xref:System.Messaging.Message.TransactionId%2A> </xref:System.Messaging.Message.IsLastInTransaction%2A> 前者用于检查消息是否已在该事务中发送的最后一条消息，并使用后者来检索事务的标识符。       如果只在事务中，IsFirstInTransaction 发送一条消息和<xref:System.Messaging.Message.IsLastInTransaction%2A>属性都设置为`true`。</xref:System.Messaging.Message.IsLastInTransaction%2A>"
  example:
  - "The following code example displays the value of a message's IsFirstInTransaction property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool IsFirstInTransaction { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果消息已发送在事务; 中的第一个消息否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.IsFirstInTransaction*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "尚未发送消息。 此属性仅可以在从队列中检索的消息上读取。       -或者-消息队列筛选以忽略 IsFirstInTransaction 属性。"
  platform:
  - net462
- uid: System.Messaging.Message.IsLastInTransaction
  id: IsLastInTransaction
  parent: System.Messaging.Message
  langs:
  - csharp
  name: IsLastInTransaction
  nameWithType: Message.IsLastInTransaction
  fullName: System.Messaging.Message.IsLastInTransaction
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取一个值，该值指示消息是否已在事务中发送的最后一条消息。"
  remarks: "接收应用程序使用 IsLastInTransaction 属性以验证消息已发送到单个队列单个事务中的最后一条消息。       此属性是仅适用于消息队列版本 2.0 及更高版本。       若要验证事务边界，你可以使用 IsLastInTransaction 属性以及其他两个属性︰<xref:System.Messaging.Message.IsFirstInTransaction%2A>和<xref:System.Messaging.Message.TransactionId%2A>。</xref:System.Messaging.Message.TransactionId%2A> </xref:System.Messaging.Message.IsFirstInTransaction%2A> 前者用于检查消息是否已在该事务中发送的第一个消息，并使用后者来检索事务的标识符。       如果只在事务中，发送一条消息<xref:System.Messaging.Message.IsFirstInTransaction%2A>和 IsLastInTransaction 属性都设置为`true`。</xref:System.Messaging.Message.IsFirstInTransaction%2A>"
  example:
  - "The following code example displays the value of a message's IsLastInTransaction property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool IsLastInTransaction { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果消息已在单个事务; 发送最后一条消息否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.IsLastInTransaction*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "尚未发送消息。 此属性仅可以在从队列中检索的消息上读取。       -或者-消息队列筛选以忽略 IsLastInTransaction 属性。"
  platform:
  - net462
- uid: System.Messaging.Message.Label
  id: Label
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Label
  nameWithType: Message.Label
  fullName: System.Messaging.Message.Label
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取或设置描述消息的应用程序定义 Unicode 字符串。"
  remarks: "你可以使用消息标签有多种用途。 例如，这样一你将可以使用它用于显示目的，或有选择地处理消息的标签值。 标签不必是唯一的消息范围内。       消息队列和消息标签表示一个应用程序定义的值，可帮助标识队列或消息用户可读的条款。 它负责解释标签的内容，其中没有任何实质意义到消息队列应用程序的应用程序。"
  example:
  - "The following code example gets and sets the value of a message's Label property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public string Label { get; set; }
    return:
      type: System.String
      description: "消息的标签。 默认值为空字符串 (&quot;&quot;)。"
  overload: System.Messaging.Message.Label*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "消息队列筛选若要忽略的 Label 属性。"
  platform:
  - net462
- uid: System.Messaging.Message.LookupId
  id: LookupId
  parent: System.Messaging.Message
  langs:
  - csharp
  name: LookupId
  nameWithType: Message.LookupId
  fullName: System.Messaging.Message.LookupId
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "在 MSMQ 3.0 中引入。 获取消息的查找标识符。"
  remarks: "LookupId 属性提供对消息的查找标识符的只读访问。 在 MSMQ 3.0 中引入的查找标识符是一个 64 位标识符，由消息队列生成并将其分配到每条消息时该消息会放在队列中。 查找标识符不是发送消息时生成的消息标识符相同。       消息队列会生成连接器和传出队列都将置于任何队列，包括应用程序生成的目标、 管理和报告队列，以及系统生成的日记、 死信的所有消息的查找标识符。 换而言之，这包括这两个发送由发送应用程序和由消息队列的消息。 查找标识符是唯一的队列，并且队列外部没有意义。       如果消息发送到多个目标队列，或如果消息的副本存储在计算机日志或队列日志，位于其各自的队列中时，该消息的每个副本将具有其自己的查找标识符。       仅可以对从队列中检索的消息读取 LookupId 属性。       查找标识符用于读取队列中的特定邮件。 接收应用程序后已知的一条消息的查找标识符，可以调用<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>或<xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A>函数来直接转到该消息并扫视或检索它从队列中，与游标，必须在队列开头处开始，并且队列末尾导航不同，获取队列中消息的查找标识符是应用程序的责任。</xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> </xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 若要获取的查找标识符的一种是创建缓存的每条消息的标识符，因为它们放置在队列中的组件时，将调用的目标队列的触发器。"
  syntax:
    content: public long LookupId { get; }
    return:
      type: System.Int64
      description: "消息的查找标识符，也不能由消息队列生成是唯一的队列的消息所在的位置。"
  overload: System.Messaging.Message.LookupId*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "未安装 MSMQ 3.0。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "尚未发送消息。 此属性仅可以在从队列中检索的消息上读取。       -或者-消息队列筛选以忽略 LookupId 属性。"
  platform:
  - net462
- uid: System.Messaging.Message.MessageType
  id: MessageType
  parent: System.Messaging.Message
  langs:
  - csharp
  name: MessageType
  nameWithType: Message.MessageType
  fullName: System.Messaging.Message.MessageType
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: 'Gets the message type: <xref uid=&quot;langword_csharp_Normal&quot; name=&quot;Normal&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Acknowledgment&quot; name=&quot;Acknowledgment&quot; href=&quot;&quot;></xref>, or <xref uid=&quot;langword_csharp_Report&quot; name=&quot;Report&quot; href=&quot;&quot;></xref>.'
  remarks: "消息队列发送消息时，通常设置此属性。 消息队列消息可以是以下类型之一:- `Normal`，这典型消息从应用程序发送到队列，或响应消息返回给发送应用程序。      - `Acknowledgement`，发送应用程序请求一个时，消息队列生成的。 例如，消息队列可生成肯定消息或否定消息以指示原始消息已到达或已被读取。 消息队列会将相应的确认消息返回到发送应用程序所指定的管理队列。      - `Report`，只要源队列管理器中定义报告队列消息队列生成的。 启用跟踪后，消息队列发送报告消息到消息队列报告队列的每当原始消息进入或离开消息队列服务器。"
  example:
  - "The following code example displays the value of a message's MessageType property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public System.Messaging.MessageType MessageType { get; }
    return:
      type: System.Messaging.MessageType
      description: "MessageType 值之一。"
  overload: System.Messaging.Message.MessageType*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "尚未发送消息。 此属性仅可以在从队列中检索的消息上读取。       -或者-消息队列筛选以忽略 MessageType 属性。"
  platform:
  - net462
- uid: System.Messaging.Message.Priority
  id: Priority
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Priority
  nameWithType: Message.Priority
  fullName: System.Messaging.Message.Priority
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取或设置消息优先级，确定在队列中消息的位置。"
  remarks: "优先级属性会影响消息队列处理消息的方式路由时，以及在到达其目标。 在路由过程给定首选项和插入到目标队列的队优先级较高的消息。 具有相同优先级的消息都将置于其到达时间根据队列。       你可以设置非事务性消息才有意义的优先级。 消息队列将自动设置到的事务性消息的优先级`Lowest`，这将导致产生事务性消息优先级被忽略。"
  example:
  - "The following code example sends two messages of different priorities to the queue, and retrieves them subsequently.  \n  \n [!code-cpp[Message.DefaultPropertiesToSend#1](~/add/codesnippet/cpp/p-system.messaging.messa_87_1.cpp)]\n [!code-vb[Message.DefaultPropertiesToSend#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_87_1.vb)]\n [!code-cs[Message.DefaultPropertiesToSend#1](~/add/codesnippet/csharp/p-system.messaging.messa_87_1.cs)]"
  syntax:
    content: public System.Messaging.MessagePriority Priority { get; set; }
    return:
      type: System.Messaging.MessagePriority
      description: "之一<xref href=&quot;System.Messaging.MessagePriority&quot;></xref>表示的非事务性消息的优先级级别的值。 默认值是<xref uid=&quot;langword_csharp_Normal&quot; name=&quot;Normal&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.Priority*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "消息队列筛选以忽略 Priority 属性。"
  platform:
  - net462
- uid: System.Messaging.Message.Recoverable
  id: Recoverable
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Recoverable
  nameWithType: Message.Recoverable
  fullName: System.Messaging.Message.Recoverable
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取或设置一个值，该值指示是否保证消息传递出现计算机故障或网络问题时。"
  remarks: "可恢复属性指示是否保证消息的传递 — 即使消息启用路由到目标队列的过程中出现计算机故障。       如果保证消息的传递，消息是本地存储在路由过程中，每个步骤直到消息成功转发到下一台计算机。 将可恢复属性设置为`true`可能会影响吞吐量。       如果消息是事务性的消息队列会自动将消息视为可恢复的而不考虑可恢复属性的值。"
  example:
  - "The following code example gets and sets the value of a message's Recoverable property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool Recoverable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果消息传递保证 （通过将消息保存到磁盘上来）;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>如果不能保证传递。 默认值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.Recoverable*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "消息队列筛选若要忽略的可恢复属性。"
  platform:
  - net462
- uid: System.Messaging.Message.ResponseQueue
  id: ResponseQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: ResponseQueue
  nameWithType: Message.ResponseQueue
  fullName: System.Messaging.Message.ResponseQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取或设置接收应用程序生成的响应消息的队列。"
  remarks: "ResponseQueue 属性标识接收应用程序生成的响应消息，接收应用程序返回到发送应用程序的队列。 当应用程序发送其消息时，发送应用程序指定响应队列。 任何可用队列均可指定为响应队列。       返回到响应队列消息是特定于应用程序。 应用程序必须定义消息使用以及在收到消息时采取操作的内容。"
  example:
  - "The following code example gets and sets the value of a message's ResponseQueue property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public System.Messaging.MessageQueue ResponseQueue { get; set; }
    return:
      type: System.Messaging.MessageQueue
      description: "<xref href=&quot;System.Messaging.MessageQueue&quot;> </xref>消息返回到哪些应用程序生成的响应。 默认值是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.ResponseQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "消息队列筛选以忽略 ResponseQueue 属性。"
  platform:
  - net462
- uid: System.Messaging.Message.SecurityContext
  id: SecurityContext
  parent: System.Messaging.Message
  langs:
  - csharp
  name: SecurityContext
  nameWithType: Message.SecurityContext
  fullName: System.Messaging.Message.SecurityContext
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取或设置一条消息的安全上下文。"
  syntax:
    content: public System.Messaging.SecurityContext SecurityContext { get; set; }
    return:
      type: System.Messaging.SecurityContext
      description: "A <xref href=&quot;System.Messaging.SecurityContext&quot;> </xref>如果以前设置该属性包含一条消息的安全上下文的对象; 否则为 NULL。"
  overload: System.Messaging.Message.SecurityContext*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.Message.SenderCertificate
  id: SenderCertificate
  parent: System.Messaging.Message
  langs:
  - csharp
  name: SenderCertificate
  nameWithType: Message.SenderCertificate
  fullName: System.Messaging.Message.SenderCertificate
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取或设置用于对消息进行身份验证的安全证书。"
  remarks: "如果消息包含外部安全证书，则接收应用程序使用 SenderCertificate 属性。       消息队列可以进行身份验证使用一条消息的内部或外部的安全证书。 消息队列提供了内部证书，用来验证消息的完整性。 证书颁发机构提供的外部证书，这可以通过消息的 SenderCertificate 属性访问。 除了允许消息队列进行身份验证消息的外部证书允许接收应用程序中，可以进一步验证发件人。 内部证书的接收应用程序没有可用值。       必须与目录服务的消息队列系统注册的外部证书。 外部证书包含证书颁发机构、 证书用户、 证书的有效期，证书用户和证书颁发机构签名的公钥有关的信息。"
  syntax:
    content: public byte[] SenderCertificate { get; set; }
    return:
      type: System.Byte[]
      description: "表示消息队列使用来验证消息的发送方的安全证书的字节值数组。 默认值为零长度数组。"
  overload: System.Messaging.Message.SenderCertificate*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "消息队列筛选以忽略 SenderCertificate 属性。"
  platform:
  - net462
- uid: System.Messaging.Message.SenderId
  id: SenderId
  parent: System.Messaging.Message
  langs:
  - csharp
  name: SenderId
  nameWithType: Message.SenderId
  fullName: System.Messaging.Message.SenderId
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取发送用户的标识符。"
  remarks: "如果<xref:System.Messaging.Message.AttachSenderId%2A>属性是`false`，SenderId 属性中指定的发件人标识符未附加到消息，发送时。</xref:System.Messaging.Message.AttachSenderId%2A> 这指示消息队列将消息发送到目标队列时，应不验证发件人。 如果<xref:System.Messaging.Message.AttachSenderId%2A>属性是`true`，SenderId 属性值是仅当消息已验证的可信。</xref:System.Messaging.Message.AttachSenderId%2A> 使用<xref:System.Messaging.Message.Authenticated%2A>属性结合使用 SenderId 属性以验证发件人的访问权限。</xref:System.Messaging.Message.Authenticated%2A>       连接器应用程序是使用连接器服务器来提供消息队列和其他队列系统之间的通信的应用程序。 消息队列要求连接器应用程序提供发送方标识。 必须设置<xref:System.Messaging.Message.ConnectorType%2A>属性时通过连接器应用程序发送消息。</xref:System.Messaging.Message.ConnectorType%2A>"
  syntax:
    content: public byte[] SenderId { get; }
    return:
      type: System.Byte[]
      description: "标识发件人的字节值数组。 接收队列管理器使用标识符时对邮件以验证消息和对队列的发件人的访问权限，则发送方进行身份验证。"
  overload: System.Messaging.Message.SenderId*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "尚未发送消息。 此属性仅可以在从队列中检索的消息上读取。       -或者-消息队列筛选以忽略 SenderId 属性。"
  platform:
  - net462
- uid: System.Messaging.Message.SenderVersion
  id: SenderVersion
  parent: System.Messaging.Message
  langs:
  - csharp
  name: SenderVersion
  nameWithType: Message.SenderVersion
  fullName: System.Messaging.Message.SenderVersion
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取消息队列用于发送消息的版本。"
  remarks: "SenderVersion 属性很重要针对的某些功能。 例如，只能由 Message Queuing 2.0 及更高版本，才支持事务处理和使用数字签名进行身份验证发送 MSMQ 1.0 的消息。       发送消息时，发送队列管理器设置 SenderVersion 属性。"
  example:
  - "The following code example displays the value of a message's SenderVersion property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public long SenderVersion { get; }
    return:
      type: System.Int64
      description: "用于将消息发送的消息队列版本。"
  overload: System.Messaging.Message.SenderVersion*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "尚未发送消息。 此属性仅可以在从队列中检索的消息上读取。       -或者-消息队列筛选以忽略 SenderVersion 属性。"
  platform:
  - net462
- uid: System.Messaging.Message.SentTime
  id: SentTime
  parent: System.Messaging.Message
  langs:
  - csharp
  name: SentTime
  nameWithType: Message.SentTime
  fullName: System.Messaging.Message.SentTime
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取发送的源队列管理器发送消息的计算机上的日期和时间。"
  remarks: "SentTime 属性将会调整为此计算机的本地时间实例<xref:System.Messaging.Message>创建类。</xref:System.Messaging.Message> 此时区可能不同于源和目标队列。"
  example:
  - "The following code example displays the value of a message's SentTime property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public DateTime SentTime { get; }
    return:
      type: System.DateTime
      description: "A <xref:System.DateTime>，表示发送消息的时间。</xref:System.DateTime>"
  overload: System.Messaging.Message.SentTime*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "尚未发送消息。 此属性仅可以在从队列中检索的消息上读取。       -或者-消息队列被筛选为忽略 SentTime 属性。"
  platform:
  - net462
- uid: System.Messaging.Message.SourceMachine
  id: SourceMachine
  parent: System.Messaging.Message
  langs:
  - csharp
  name: SourceMachine
  nameWithType: Message.SourceMachine
  fullName: System.Messaging.Message.SourceMachine
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取消息所源自的计算机。"
  remarks: "SourceMachine 属性的格式不包括前面两个正斜杠 (\\\\\\\\)。 例如，`myServer`是有效 SourceMachine。"
  example:
  - "The following code example displays the value of a message's SourceMachine property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public string SourceMachine { get; }
    return:
      type: System.String
      description: "从其发送消息的计算机的名称。"
  overload: System.Messaging.Message.SourceMachine*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "尚未发送消息。 此属性仅可以在从队列中检索的消息上读取。       -或者-消息队列筛选以忽略 SourceMachine 属性。"
  - type: System.Messaging.MessageQueueException
    commentId: T:System.Messaging.MessageQueueException
    description: "无法访问计算机信息或目录服务。"
  platform:
  - net462
- uid: System.Messaging.Message.TimeToBeReceived
  id: TimeToBeReceived
  parent: System.Messaging.Message
  langs:
  - csharp
  name: TimeToBeReceived
  nameWithType: Message.TimeToBeReceived
  fullName: System.Messaging.Message.TimeToBeReceived
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取或设置的最大从目标队列接收消息的时间量。"
  remarks: "TimeToBeReceived 属性指定发送的消息从目标队列接收的总时间。 时间限制包括到达目标队列和所用之前接收到消息队列中等待的时间所用的时间。      1> [!CAUTION]&1;> 时使用从属客户端计算机，请确保客户端计算机上的时钟是否与正在运行消息队列服务器上的时钟同步。 否则，可能会导致不可预知的行为，当发送其 TimeToBeReceived 属性的消息不是<xref:System.Messaging.Message.InfiniteTimeout>.</xref:System.Messaging.Message.InfiniteTimeout>       如果 TimeToBeReceived 属性指定的时间间隔到期之前从队列中删除消息，消息队列丢弃该消息在两种方式之一。 如果消息的<xref:System.Messaging.Message.UseDeadLetterQueue%2A>属性是`true`，消息发送到死信队列。</xref:System.Messaging.Message.UseDeadLetterQueue%2A> 如果<xref:System.Messaging.Message.UseDeadLetterQueue%2A>是`false`，则忽略此消息。</xref:System.Messaging.Message.UseDeadLetterQueue%2A>       你可以设置消息的<xref:System.Messaging.Message.AcknowledgeType%2A>属性来请求，消息队列将否定确认消息发送回发送应用程序如果计时器过期之前未检索到的消息。</xref:System.Messaging.Message.AcknowledgeType%2A>       如果指定 TimeToBeReceived 属性的值小于指定的值<xref:System.Messaging.Message.TimeToReachQueue%2A>属性，TimeToBeReceived 优先。</xref:System.Messaging.Message.TimeToReachQueue%2A>       在单个事务中发送多条消息，消息队列使用 TimeToBeReceived 属性的第一条消息。"
  example:
  - "The following code example gets and sets the value of a message's TimeToBeReceived property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public TimeSpan TimeToBeReceived { get; set; }
    return:
      type: System.TimeSpan
      description: "个要从目标队列接收的已发送消息的总时间。 默认值是<xref href=&quot;System.Messaging.Message.InfiniteTimeout&quot;> </xref>。"
  overload: System.Messaging.Message.TimeToBeReceived*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "消息队列筛选以忽略 TimeToBeReceived 属性。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "TimeToBeReceived 为指定的值无效。"
  platform:
  - net462
- uid: System.Messaging.Message.TimeToReachQueue
  id: TimeToReachQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: TimeToReachQueue
  nameWithType: Message.TimeToReachQueue
  fullName: System.Messaging.Message.TimeToReachQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取或设置的最大消息到达目标队列的时间量。"
  remarks: "如果 TimeToReachQueue 属性指定的时间间隔到期消息到达其目标之前，消息队列将丢弃两种方式之一中的消息。 如果消息的<xref:System.Messaging.Message.UseDeadLetterQueue%2A>属性是`true`，消息发送到死信队列。</xref:System.Messaging.Message.UseDeadLetterQueue%2A> 如果<xref:System.Messaging.Message.UseDeadLetterQueue%2A>是`false`，则忽略此消息可以设置他消息<xref:System.Messaging.Message.AcknowledgeType%2A>属性来请求，消息队列将否定确认消息发送回发送应用程序如果消息没有到达之前在计时器过期。</xref:System.Messaging.Message.AcknowledgeType%2A> </xref:System.Messaging.Message.UseDeadLetterQueue%2A>       如果 TimeToReachQueue 属性设置为 0 秒，消息队列再次尝试将消息发送到其目标 — 如果队列等待消息。 如果本地队列，消息总是到达它。       如果指定 TimeToReachQueue 属性的值大于指定的值<xref:System.Messaging.Message.TimeToBeReceived%2A>属性，<xref:System.Messaging.Message.TimeToBeReceived%2A>优先。</xref:System.Messaging.Message.TimeToBeReceived%2A> </xref:System.Messaging.Message.TimeToBeReceived%2A>       在单个事务中发送多条消息，消息队列使用 TimeToReachQueue 属性的第一条消息。"
  example:
  - "The following code example gets and sets the value of a message's TimeToReachQueue property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public TimeSpan TimeToReachQueue { get; set; }
    return:
      type: System.TimeSpan
      description: "从时间开始消息发送的消息到达目标队列的时间限制。 默认值是<xref href=&quot;System.Messaging.Message.InfiniteTimeout&quot;> </xref>。"
  overload: System.Messaging.Message.TimeToReachQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "消息队列筛选以忽略 TimeToReachQueue 属性。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "TimeToReachQueue 为指定的值无效。 它也可以表示为负数。"
  platform:
  - net462
- uid: System.Messaging.Message.TransactionId
  id: TransactionId
  parent: System.Messaging.Message
  langs:
  - csharp
  name: TransactionId
  nameWithType: Message.TransactionId
  fullName: System.Messaging.Message.TransactionId
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "事务的消息已一部分获取的标识符。"
  remarks: "接收应用程序使用 TransactionId 属性以验证消息已发送特定事务的一部分。 事务的事务标识符包含的标识符的 4 字节事务序列号后跟发送计算机 （第一个 16 位）。       此属性是仅适用于消息队列版本 2.0 及更高版本。       不保证事务标识符都是唯一的因为事务序列号不是永久性的而且它们处重新开始 2 <sup>20</sup>。 消息队列仅保证，后续的事务将具有不同的事务序列号。       你可以使用 TransactionId 属性连同<xref:System.Messaging.Message.IsFirstInTransaction%2A>和<xref:System.Messaging.Message.IsLastInTransaction%2A>属性，以验证事务边界。</xref:System.Messaging.Message.IsLastInTransaction%2A> </xref:System.Messaging.Message.IsFirstInTransaction%2A>"
  example:
  - "The following code example displays the value of a message's TransactionId property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public string TransactionId { get; }
    return:
      type: System.String
      description: "与消息关联的事务标识符。"
  overload: System.Messaging.Message.TransactionId*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "尚未发送消息。 此属性仅可以在从队列中检索的消息上读取。       -或者-消息队列筛选以忽略 TransactionId 属性。"
  platform:
  - net462
- uid: System.Messaging.Message.TransactionStatusQueue
  id: TransactionStatusQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: TransactionStatusQueue
  nameWithType: Message.TransactionStatusQueue
  fullName: System.Messaging.Message.TransactionStatusQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取源计算机上的事务状态队列。"
  remarks: "TransactionStatusQueue 属性标识阅读回执确认收到连接器应用程序的源计算机上的事务性队列。 消息队列设置的属性，并检索事务性消息发送到外部队列时，连接器应用程序将使用属性。       非 Microsoft 消息队列的队列系统中不存在外队列。 与此类通过连接器应用程序的队列，消息队列进行通信。       连接器应用程序可以使用的事务状态队列发送确认消息返回到发送应用程序。 即使发送应用程序不会请求其他确认的事务状态队列应接收这些确认。"
  example:
  - "The following code example displays the value of a message's TransactionStatusQueue property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public System.Messaging.MessageQueue TransactionStatusQueue { get; set; }
    return:
      type: System.Messaging.MessageQueue
      description: "用于将确认消息发送回给发送应用程序与源计算机上的事务状态队列。 默认值是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.TransactionStatusQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "尚未发送消息。 此属性仅可以在从队列中检索的消息上读取。       -或者-消息队列筛选以忽略 TransactionStatusQueue 属性。"
  platform:
  - net462
- uid: System.Messaging.Message.UseAuthentication
  id: UseAuthentication
  parent: System.Messaging.Message
  langs:
  - csharp
  name: UseAuthentication
  nameWithType: Message.UseAuthentication
  fullName: System.Messaging.Message.UseAuthentication
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取或设置一个值，该值指示是否消息 （或必须） 发送之前已经过身份验证。"
  remarks: "UseAuthentication 属性指定是否需要进行身份验证消息。 如果发送应用程序请求身份验证，消息队列创建数字签名，并使用它来发送时对消息进行签名和时将会收到该消息进行身份验证。       如果 UseAuthentication`false`和一条消息发送到的队列，只接受经过身份验证的消息，在到达队列时，将被拒绝消息。       无法确定消息是否未通过查看其属性通过身份验证。 它们传递到队列之前，消息队列将放弃此类消息。 但是，你可以请求如果传送失败可以阻止一条消息到达队列中发送确认消息。"
  syntax:
    content: public bool UseAuthentication { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果发送应用程序请求消息; 身份验证，否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.UseAuthentication*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "消息队列筛选以忽略 UseAuthentication 属性。"
  platform:
  - net462
- uid: System.Messaging.Message.UseDeadLetterQueue
  id: UseDeadLetterQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: UseDeadLetterQueue
  nameWithType: Message.UseDeadLetterQueue
  fullName: System.Messaging.Message.UseDeadLetterQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取或设置一个值，该值指示是否应将无法传递消息的副本发送到死信队列。"
  remarks: "<xref:System.Messaging.Message.UseJournalQueue%2A>和 UseDeadLetterQueue 属性指定消息队列如何跟踪消息。</xref:System.Messaging.Message.UseJournalQueue%2A> 如果 UseDeadLetterQueue `true`，（的非事务性消息） 的传递失败将导致消息发送到无法传递消息的计算机上的非事务性死信队列。 传送失败可能引起消息计时器过期时，例如。       对于事务性消息的传送失败，消息队列为事务性死信队列中所有负数，有疑问的情况下在源计算机上发送消息。       当你将消息存储在死信队列时，则应该清除定期要删除不再需要的消息的队列。 存储在死信队列计数针对队列所驻留的计算机的大小配额的消息。 计算机配额由管理员设置，并分配用于存储消息的整个计算机上，而不仅仅是在单个队列的大小是指。       不要创建日志或死信队列。 这些是消息队列生成两个系统队列。"
  example:
  - "The following code example gets and sets the value of a message's UseDeadLetterQueue property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool UseDeadLetterQueue { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果消息传递失败会导致消息发送到死信队列; 的副本，否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.UseDeadLetterQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "消息队列筛选以忽略 UseDeadLetterQueue 属性。"
  platform:
  - net462
- uid: System.Messaging.Message.UseEncryption
  id: UseEncryption
  parent: System.Messaging.Message
  langs:
  - csharp
  name: UseEncryption
  nameWithType: Message.UseEncryption
  fullName: System.Messaging.Message.UseEncryption
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取或设置一个值，该值指示是否将消息变成私有成员。"
  remarks: "如果消息是私有的其正文已加密之前发送和接收时解密。 若要发送私有消息，发送应用程序必须指定要使用加密和 （可选） 的加密算法。       发送私有消息时，则不需要执行的消息加密你的应用程序。 如果你的应用程序正在发送中的 Microsoft Windows 2000 企业中，该组可以对目录服务的访问的消息，消息队列可以为你加密消息正文。 在接收时私有消息，接收队列管理器将始终解密消息正文。"
  example:
  - "The following code example gets and sets the value of a message's UseEncryption property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool UseEncryption { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>需要消息队列来加密消息;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.UseEncryption*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "消息队列筛选以忽略 UseEncryption 属性。"
  platform:
  - net462
- uid: System.Messaging.Message.UseJournalQueue
  id: UseJournalQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: UseJournalQueue
  nameWithType: Message.UseJournalQueue
  fullName: System.Messaging.Message.UseJournalQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取或设置一个值，指示消息的副本是否应保存在原始计算机上的计算机日记中。"
  remarks: "UseJournalQueue 和<xref:System.Messaging.Message.UseDeadLetterQueue%2A>属性指定消息队列如何跟踪消息。</xref:System.Messaging.Message.UseDeadLetterQueue%2A> 如果 UseJournalQueue `true`，然后在传输消息的每个步骤处的源计算机上的计算机日志保留副本。       目标队列是否在远程计算机上，发送的消息是仅复制到日记队列中。 如果目标为本地计算机上，该消息被直接发送到队列，则为没有中间步骤需要日记记录。       当将消息存储在日记队列中时，清除定期要删除不再需要的消息的队列。 针对队列所驻留的计算机的配额的日记队列计数中存储的消息。 （计算机配额设置管理员。）     不要创建日志或死信队列。 这些是消息队列生成两个系统队列。"
  example:
  - "The following code example gets and sets the value of a message's UseJournalQueue property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool UseJournalQueue { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>要求的消息后将保留在原始计算机的计算机日记中消息的副本已成功地 （从传送到下一步的服务器的原始计算机）;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.UseJournalQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "消息队列筛选以忽略 UseJournalQueue 属性。"
  platform:
  - net462
- uid: System.Messaging.Message.UseTracing
  id: UseTracing
  parent: System.Messaging.Message
  langs:
  - csharp
  name: UseTracing
  nameWithType: Message.UseTracing
  fullName: System.Messaging.Message.UseTracing
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "获取或设置一个值，该值指示是否向其目标队列移动跟踪消息。"
  remarks: "UseTracing 属性指定是否向其目标队列移动跟踪消息的路由。 如果`true`，（由消息队列生成） 报告消息发送到报告队列每次该消息通过消息队列的路由服务器。 源队列管理器指定的报告队列。 报告队列并不局限于由消息队列; 生成的报告消息你应用程序生成的消息也可以发送到报告队列。       使用跟踪包括设置 Active Directory 和指定报表队列的消息队列企业。 管理员配置这些设置。"
  example:
  - "The following code example gets and sets the value of a message's UseTracing property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool UseTracing { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果由原始消息路由到目标队列的每个中间步骤生成要发送到系统的报告队列; 的报表否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.UseTracing*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "消息队列筛选以忽略 UseTracing 属性。"
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.Messaging.MessageQueueException
  parent: System.Messaging
  isExternal: false
  name: MessageQueueException
  nameWithType: MessageQueueException
  fullName: System.Messaging.MessageQueueException
- uid: System.Messaging.Message.#ctor
  parent: System.Messaging.Message
  isExternal: false
  name: Message()
  nameWithType: Message.Message()
  fullName: System.Messaging.Message.Message()
- uid: System.Messaging.Message.#ctor(System.Object)
  parent: System.Messaging.Message
  isExternal: false
  name: Message(Object)
  nameWithType: Message.Message(Object)
  fullName: System.Messaging.Message.Message(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)
  parent: System.Messaging.Message
  isExternal: false
  name: Message(Object,IMessageFormatter)
  nameWithType: Message.Message(Object,IMessageFormatter)
  fullName: System.Messaging.Message.Message(Object,IMessageFormatter)
- uid: System.Messaging.IMessageFormatter
  parent: System.Messaging
  isExternal: false
  name: IMessageFormatter
  nameWithType: IMessageFormatter
  fullName: System.Messaging.IMessageFormatter
- uid: System.Messaging.Message.AcknowledgeType
  parent: System.Messaging.Message
  isExternal: false
  name: AcknowledgeType
  nameWithType: Message.AcknowledgeType
  fullName: System.Messaging.Message.AcknowledgeType
- uid: System.Messaging.AcknowledgeTypes
  parent: System.Messaging
  isExternal: false
  name: AcknowledgeTypes
  nameWithType: AcknowledgeTypes
  fullName: System.Messaging.AcknowledgeTypes
- uid: System.Messaging.Message.Acknowledgment
  parent: System.Messaging.Message
  isExternal: false
  name: Acknowledgment
  nameWithType: Message.Acknowledgment
  fullName: System.Messaging.Message.Acknowledgment
- uid: System.Messaging.Acknowledgment
  parent: System.Messaging
  isExternal: false
  name: Acknowledgment
  nameWithType: Acknowledgment
  fullName: System.Messaging.Acknowledgment
- uid: System.Messaging.Message.AdministrationQueue
  parent: System.Messaging.Message
  isExternal: false
  name: AdministrationQueue
  nameWithType: Message.AdministrationQueue
  fullName: System.Messaging.Message.AdministrationQueue
- uid: System.Messaging.MessageQueue
  parent: System.Messaging
  isExternal: false
  name: MessageQueue
  nameWithType: MessageQueue
  fullName: System.Messaging.MessageQueue
- uid: System.Messaging.Message.AppSpecific
  parent: System.Messaging.Message
  isExternal: false
  name: AppSpecific
  nameWithType: Message.AppSpecific
  fullName: System.Messaging.Message.AppSpecific
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Messaging.Message.ArrivedTime
  parent: System.Messaging.Message
  isExternal: false
  name: ArrivedTime
  nameWithType: Message.ArrivedTime
  fullName: System.Messaging.Message.ArrivedTime
- uid: System.DateTime
  parent: System
  isExternal: true
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: System.Messaging.Message.AttachSenderId
  parent: System.Messaging.Message
  isExternal: false
  name: AttachSenderId
  nameWithType: Message.AttachSenderId
  fullName: System.Messaging.Message.AttachSenderId
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Messaging.Message.Authenticated
  parent: System.Messaging.Message
  isExternal: false
  name: Authenticated
  nameWithType: Message.Authenticated
  fullName: System.Messaging.Message.Authenticated
- uid: System.Messaging.Message.AuthenticationProviderName
  parent: System.Messaging.Message
  isExternal: false
  name: AuthenticationProviderName
  nameWithType: Message.AuthenticationProviderName
  fullName: System.Messaging.Message.AuthenticationProviderName
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Messaging.Message.AuthenticationProviderType
  parent: System.Messaging.Message
  isExternal: false
  name: AuthenticationProviderType
  nameWithType: Message.AuthenticationProviderType
  fullName: System.Messaging.Message.AuthenticationProviderType
- uid: System.Messaging.CryptographicProviderType
  parent: System.Messaging
  isExternal: false
  name: CryptographicProviderType
  nameWithType: CryptographicProviderType
  fullName: System.Messaging.CryptographicProviderType
- uid: System.Messaging.Message.Body
  parent: System.Messaging.Message
  isExternal: false
  name: Body
  nameWithType: Message.Body
  fullName: System.Messaging.Message.Body
- uid: System.Messaging.Message.BodyStream
  parent: System.Messaging.Message
  isExternal: false
  name: BodyStream
  nameWithType: Message.BodyStream
  fullName: System.Messaging.Message.BodyStream
- uid: System.IO.Stream
  parent: System.IO
  isExternal: true
  name: Stream
  nameWithType: Stream
  fullName: System.IO.Stream
- uid: System.Messaging.Message.BodyType
  parent: System.Messaging.Message
  isExternal: false
  name: BodyType
  nameWithType: Message.BodyType
  fullName: System.Messaging.Message.BodyType
- uid: System.Messaging.Message.ConnectorType
  parent: System.Messaging.Message
  isExternal: false
  name: ConnectorType
  nameWithType: Message.ConnectorType
  fullName: System.Messaging.Message.ConnectorType
- uid: System.Guid
  parent: System
  isExternal: true
  name: Guid
  nameWithType: Guid
  fullName: System.Guid
- uid: System.Messaging.Message.CorrelationId
  parent: System.Messaging.Message
  isExternal: false
  name: CorrelationId
  nameWithType: Message.CorrelationId
  fullName: System.Messaging.Message.CorrelationId
- uid: System.Messaging.Message.DestinationQueue
  parent: System.Messaging.Message
  isExternal: false
  name: DestinationQueue
  nameWithType: Message.DestinationQueue
  fullName: System.Messaging.Message.DestinationQueue
- uid: System.Messaging.Message.DestinationSymmetricKey
  parent: System.Messaging.Message
  isExternal: false
  name: DestinationSymmetricKey
  nameWithType: Message.DestinationSymmetricKey
  fullName: System.Messaging.Message.DestinationSymmetricKey
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Messaging.Message.DigitalSignature
  parent: System.Messaging.Message
  isExternal: false
  name: DigitalSignature
  nameWithType: Message.DigitalSignature
  fullName: System.Messaging.Message.DigitalSignature
- uid: System.Messaging.Message.EncryptionAlgorithm
  parent: System.Messaging.Message
  isExternal: false
  name: EncryptionAlgorithm
  nameWithType: Message.EncryptionAlgorithm
  fullName: System.Messaging.Message.EncryptionAlgorithm
- uid: System.Messaging.EncryptionAlgorithm
  parent: System.Messaging
  isExternal: false
  name: EncryptionAlgorithm
  nameWithType: EncryptionAlgorithm
  fullName: System.Messaging.EncryptionAlgorithm
- uid: System.Messaging.Message.Extension
  parent: System.Messaging.Message
  isExternal: false
  name: Extension
  nameWithType: Message.Extension
  fullName: System.Messaging.Message.Extension
- uid: System.Messaging.Message.Formatter
  parent: System.Messaging.Message
  isExternal: false
  name: Formatter
  nameWithType: Message.Formatter
  fullName: System.Messaging.Message.Formatter
- uid: System.Messaging.Message.HashAlgorithm
  parent: System.Messaging.Message
  isExternal: false
  name: HashAlgorithm
  nameWithType: Message.HashAlgorithm
  fullName: System.Messaging.Message.HashAlgorithm
- uid: System.Messaging.HashAlgorithm
  parent: System.Messaging
  isExternal: false
  name: HashAlgorithm
  nameWithType: HashAlgorithm
  fullName: System.Messaging.HashAlgorithm
- uid: System.Messaging.Message.Id
  parent: System.Messaging.Message
  isExternal: false
  name: Id
  nameWithType: Message.Id
  fullName: System.Messaging.Message.Id
- uid: System.Messaging.Message.InfiniteTimeout
  parent: System.Messaging.Message
  isExternal: false
  name: InfiniteTimeout
  nameWithType: Message.InfiniteTimeout
  fullName: System.Messaging.Message.InfiniteTimeout
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Messaging.Message.IsFirstInTransaction
  parent: System.Messaging.Message
  isExternal: false
  name: IsFirstInTransaction
  nameWithType: Message.IsFirstInTransaction
  fullName: System.Messaging.Message.IsFirstInTransaction
- uid: System.Messaging.Message.IsLastInTransaction
  parent: System.Messaging.Message
  isExternal: false
  name: IsLastInTransaction
  nameWithType: Message.IsLastInTransaction
  fullName: System.Messaging.Message.IsLastInTransaction
- uid: System.Messaging.Message.Label
  parent: System.Messaging.Message
  isExternal: false
  name: Label
  nameWithType: Message.Label
  fullName: System.Messaging.Message.Label
- uid: System.Messaging.Message.LookupId
  parent: System.Messaging.Message
  isExternal: false
  name: LookupId
  nameWithType: Message.LookupId
  fullName: System.Messaging.Message.LookupId
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Messaging.Message.MessageType
  parent: System.Messaging.Message
  isExternal: false
  name: MessageType
  nameWithType: Message.MessageType
  fullName: System.Messaging.Message.MessageType
- uid: System.Messaging.MessageType
  parent: System.Messaging
  isExternal: false
  name: MessageType
  nameWithType: MessageType
  fullName: System.Messaging.MessageType
- uid: System.Messaging.Message.Priority
  parent: System.Messaging.Message
  isExternal: false
  name: Priority
  nameWithType: Message.Priority
  fullName: System.Messaging.Message.Priority
- uid: System.Messaging.MessagePriority
  parent: System.Messaging
  isExternal: false
  name: MessagePriority
  nameWithType: MessagePriority
  fullName: System.Messaging.MessagePriority
- uid: System.Messaging.Message.Recoverable
  parent: System.Messaging.Message
  isExternal: false
  name: Recoverable
  nameWithType: Message.Recoverable
  fullName: System.Messaging.Message.Recoverable
- uid: System.Messaging.Message.ResponseQueue
  parent: System.Messaging.Message
  isExternal: false
  name: ResponseQueue
  nameWithType: Message.ResponseQueue
  fullName: System.Messaging.Message.ResponseQueue
- uid: System.Messaging.Message.SecurityContext
  parent: System.Messaging.Message
  isExternal: false
  name: SecurityContext
  nameWithType: Message.SecurityContext
  fullName: System.Messaging.Message.SecurityContext
- uid: System.Messaging.SecurityContext
  parent: System.Messaging
  isExternal: false
  name: SecurityContext
  nameWithType: SecurityContext
  fullName: System.Messaging.SecurityContext
- uid: System.Messaging.Message.SenderCertificate
  parent: System.Messaging.Message
  isExternal: false
  name: SenderCertificate
  nameWithType: Message.SenderCertificate
  fullName: System.Messaging.Message.SenderCertificate
- uid: System.Messaging.Message.SenderId
  parent: System.Messaging.Message
  isExternal: false
  name: SenderId
  nameWithType: Message.SenderId
  fullName: System.Messaging.Message.SenderId
- uid: System.Messaging.Message.SenderVersion
  parent: System.Messaging.Message
  isExternal: false
  name: SenderVersion
  nameWithType: Message.SenderVersion
  fullName: System.Messaging.Message.SenderVersion
- uid: System.Messaging.Message.SentTime
  parent: System.Messaging.Message
  isExternal: false
  name: SentTime
  nameWithType: Message.SentTime
  fullName: System.Messaging.Message.SentTime
- uid: System.Messaging.Message.SourceMachine
  parent: System.Messaging.Message
  isExternal: false
  name: SourceMachine
  nameWithType: Message.SourceMachine
  fullName: System.Messaging.Message.SourceMachine
- uid: System.Messaging.Message.TimeToBeReceived
  parent: System.Messaging.Message
  isExternal: false
  name: TimeToBeReceived
  nameWithType: Message.TimeToBeReceived
  fullName: System.Messaging.Message.TimeToBeReceived
- uid: System.Messaging.Message.TimeToReachQueue
  parent: System.Messaging.Message
  isExternal: false
  name: TimeToReachQueue
  nameWithType: Message.TimeToReachQueue
  fullName: System.Messaging.Message.TimeToReachQueue
- uid: System.Messaging.Message.TransactionId
  parent: System.Messaging.Message
  isExternal: false
  name: TransactionId
  nameWithType: Message.TransactionId
  fullName: System.Messaging.Message.TransactionId
- uid: System.Messaging.Message.TransactionStatusQueue
  parent: System.Messaging.Message
  isExternal: false
  name: TransactionStatusQueue
  nameWithType: Message.TransactionStatusQueue
  fullName: System.Messaging.Message.TransactionStatusQueue
- uid: System.Messaging.Message.UseAuthentication
  parent: System.Messaging.Message
  isExternal: false
  name: UseAuthentication
  nameWithType: Message.UseAuthentication
  fullName: System.Messaging.Message.UseAuthentication
- uid: System.Messaging.Message.UseDeadLetterQueue
  parent: System.Messaging.Message
  isExternal: false
  name: UseDeadLetterQueue
  nameWithType: Message.UseDeadLetterQueue
  fullName: System.Messaging.Message.UseDeadLetterQueue
- uid: System.Messaging.Message.UseEncryption
  parent: System.Messaging.Message
  isExternal: false
  name: UseEncryption
  nameWithType: Message.UseEncryption
  fullName: System.Messaging.Message.UseEncryption
- uid: System.Messaging.Message.UseJournalQueue
  parent: System.Messaging.Message
  isExternal: false
  name: UseJournalQueue
  nameWithType: Message.UseJournalQueue
  fullName: System.Messaging.Message.UseJournalQueue
- uid: System.Messaging.Message.UseTracing
  parent: System.Messaging.Message
  isExternal: false
  name: UseTracing
  nameWithType: Message.UseTracing
  fullName: System.Messaging.Message.UseTracing
- uid: System.Messaging.Message.#ctor*
  parent: System.Messaging.Message
  isExternal: false
  name: Message
  nameWithType: Message.Message
- uid: System.Messaging.Message.AcknowledgeType*
  parent: System.Messaging.Message
  isExternal: false
  name: AcknowledgeType
  nameWithType: Message.AcknowledgeType
- uid: System.Messaging.Message.Acknowledgment*
  parent: System.Messaging.Message
  isExternal: false
  name: Acknowledgment
  nameWithType: Message.Acknowledgment
- uid: System.Messaging.Message.AdministrationQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: AdministrationQueue
  nameWithType: Message.AdministrationQueue
- uid: System.Messaging.Message.AppSpecific*
  parent: System.Messaging.Message
  isExternal: false
  name: AppSpecific
  nameWithType: Message.AppSpecific
- uid: System.Messaging.Message.ArrivedTime*
  parent: System.Messaging.Message
  isExternal: false
  name: ArrivedTime
  nameWithType: Message.ArrivedTime
- uid: System.Messaging.Message.AttachSenderId*
  parent: System.Messaging.Message
  isExternal: false
  name: AttachSenderId
  nameWithType: Message.AttachSenderId
- uid: System.Messaging.Message.Authenticated*
  parent: System.Messaging.Message
  isExternal: false
  name: Authenticated
  nameWithType: Message.Authenticated
- uid: System.Messaging.Message.AuthenticationProviderName*
  parent: System.Messaging.Message
  isExternal: false
  name: AuthenticationProviderName
  nameWithType: Message.AuthenticationProviderName
- uid: System.Messaging.Message.AuthenticationProviderType*
  parent: System.Messaging.Message
  isExternal: false
  name: AuthenticationProviderType
  nameWithType: Message.AuthenticationProviderType
- uid: System.Messaging.Message.Body*
  parent: System.Messaging.Message
  isExternal: false
  name: Body
  nameWithType: Message.Body
- uid: System.Messaging.Message.BodyStream*
  parent: System.Messaging.Message
  isExternal: false
  name: BodyStream
  nameWithType: Message.BodyStream
- uid: System.Messaging.Message.BodyType*
  parent: System.Messaging.Message
  isExternal: false
  name: BodyType
  nameWithType: Message.BodyType
- uid: System.Messaging.Message.ConnectorType*
  parent: System.Messaging.Message
  isExternal: false
  name: ConnectorType
  nameWithType: Message.ConnectorType
- uid: System.Messaging.Message.CorrelationId*
  parent: System.Messaging.Message
  isExternal: false
  name: CorrelationId
  nameWithType: Message.CorrelationId
- uid: System.Messaging.Message.DestinationQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: DestinationQueue
  nameWithType: Message.DestinationQueue
- uid: System.Messaging.Message.DestinationSymmetricKey*
  parent: System.Messaging.Message
  isExternal: false
  name: DestinationSymmetricKey
  nameWithType: Message.DestinationSymmetricKey
- uid: System.Messaging.Message.DigitalSignature*
  parent: System.Messaging.Message
  isExternal: false
  name: DigitalSignature
  nameWithType: Message.DigitalSignature
- uid: System.Messaging.Message.EncryptionAlgorithm*
  parent: System.Messaging.Message
  isExternal: false
  name: EncryptionAlgorithm
  nameWithType: Message.EncryptionAlgorithm
- uid: System.Messaging.Message.Extension*
  parent: System.Messaging.Message
  isExternal: false
  name: Extension
  nameWithType: Message.Extension
- uid: System.Messaging.Message.Formatter*
  parent: System.Messaging.Message
  isExternal: false
  name: Formatter
  nameWithType: Message.Formatter
- uid: System.Messaging.Message.HashAlgorithm*
  parent: System.Messaging.Message
  isExternal: false
  name: HashAlgorithm
  nameWithType: Message.HashAlgorithm
- uid: System.Messaging.Message.Id*
  parent: System.Messaging.Message
  isExternal: false
  name: Id
  nameWithType: Message.Id
- uid: System.Messaging.Message.IsFirstInTransaction*
  parent: System.Messaging.Message
  isExternal: false
  name: IsFirstInTransaction
  nameWithType: Message.IsFirstInTransaction
- uid: System.Messaging.Message.IsLastInTransaction*
  parent: System.Messaging.Message
  isExternal: false
  name: IsLastInTransaction
  nameWithType: Message.IsLastInTransaction
- uid: System.Messaging.Message.Label*
  parent: System.Messaging.Message
  isExternal: false
  name: Label
  nameWithType: Message.Label
- uid: System.Messaging.Message.LookupId*
  parent: System.Messaging.Message
  isExternal: false
  name: LookupId
  nameWithType: Message.LookupId
- uid: System.Messaging.Message.MessageType*
  parent: System.Messaging.Message
  isExternal: false
  name: MessageType
  nameWithType: Message.MessageType
- uid: System.Messaging.Message.Priority*
  parent: System.Messaging.Message
  isExternal: false
  name: Priority
  nameWithType: Message.Priority
- uid: System.Messaging.Message.Recoverable*
  parent: System.Messaging.Message
  isExternal: false
  name: Recoverable
  nameWithType: Message.Recoverable
- uid: System.Messaging.Message.ResponseQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: ResponseQueue
  nameWithType: Message.ResponseQueue
- uid: System.Messaging.Message.SecurityContext*
  parent: System.Messaging.Message
  isExternal: false
  name: SecurityContext
  nameWithType: Message.SecurityContext
- uid: System.Messaging.Message.SenderCertificate*
  parent: System.Messaging.Message
  isExternal: false
  name: SenderCertificate
  nameWithType: Message.SenderCertificate
- uid: System.Messaging.Message.SenderId*
  parent: System.Messaging.Message
  isExternal: false
  name: SenderId
  nameWithType: Message.SenderId
- uid: System.Messaging.Message.SenderVersion*
  parent: System.Messaging.Message
  isExternal: false
  name: SenderVersion
  nameWithType: Message.SenderVersion
- uid: System.Messaging.Message.SentTime*
  parent: System.Messaging.Message
  isExternal: false
  name: SentTime
  nameWithType: Message.SentTime
- uid: System.Messaging.Message.SourceMachine*
  parent: System.Messaging.Message
  isExternal: false
  name: SourceMachine
  nameWithType: Message.SourceMachine
- uid: System.Messaging.Message.TimeToBeReceived*
  parent: System.Messaging.Message
  isExternal: false
  name: TimeToBeReceived
  nameWithType: Message.TimeToBeReceived
- uid: System.Messaging.Message.TimeToReachQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: TimeToReachQueue
  nameWithType: Message.TimeToReachQueue
- uid: System.Messaging.Message.TransactionId*
  parent: System.Messaging.Message
  isExternal: false
  name: TransactionId
  nameWithType: Message.TransactionId
- uid: System.Messaging.Message.TransactionStatusQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: TransactionStatusQueue
  nameWithType: Message.TransactionStatusQueue
- uid: System.Messaging.Message.UseAuthentication*
  parent: System.Messaging.Message
  isExternal: false
  name: UseAuthentication
  nameWithType: Message.UseAuthentication
- uid: System.Messaging.Message.UseDeadLetterQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: UseDeadLetterQueue
  nameWithType: Message.UseDeadLetterQueue
- uid: System.Messaging.Message.UseEncryption*
  parent: System.Messaging.Message
  isExternal: false
  name: UseEncryption
  nameWithType: Message.UseEncryption
- uid: System.Messaging.Message.UseJournalQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: UseJournalQueue
  nameWithType: Message.UseJournalQueue
- uid: System.Messaging.Message.UseTracing*
  parent: System.Messaging.Message
  isExternal: false
  name: UseTracing
  nameWithType: Message.UseTracing
