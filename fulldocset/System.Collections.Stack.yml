### YamlMime:ManagedReference
items:
- uid: System.Collections.Stack
  id: Stack
  children:
  - System.Collections.Stack.#ctor
  - System.Collections.Stack.#ctor(System.Collections.ICollection)
  - System.Collections.Stack.#ctor(System.Int32)
  - System.Collections.Stack.Clear
  - System.Collections.Stack.Clone
  - System.Collections.Stack.Contains(System.Object)
  - System.Collections.Stack.CopyTo(System.Array,System.Int32)
  - System.Collections.Stack.Count
  - System.Collections.Stack.GetEnumerator
  - System.Collections.Stack.IsSynchronized
  - System.Collections.Stack.Peek
  - System.Collections.Stack.Pop
  - System.Collections.Stack.Push(System.Object)
  - System.Collections.Stack.Synchronized(System.Collections.Stack)
  - System.Collections.Stack.SyncRoot
  - System.Collections.Stack.ToArray
  langs:
  - csharp
  name: Stack
  nameWithType: Stack
  fullName: System.Collections.Stack
  type: Class
  summary: "表示对象的简单后进先出 (LIFO) 非泛型集合。"
  remarks: "此集合的泛型版本，请参阅<xref:System.Collections.Generic.Stack%601?displayProperty=fullName>。</xref:System.Collections.Generic.Stack%601?displayProperty=fullName>       堆栈的容量是堆栈可以容纳的元素数。 当元素添加到堆栈时，自动增加容量通过重新分配所需的方式。       如果<xref:System.Collections.Stack.Count%2A>小于的堆栈，容量<xref:System.Collections.Stack.Push%2A>o （1） 运算。</xref:System.Collections.Stack.Push%2A> </xref:System.Collections.Stack.Count%2A> 如果需要增加以容纳新元素，容量<xref:System.Collections.Stack.Push%2A>会成为 O (`n`) 操作，其中`n`为<xref:System.Collections.Stack.Count%2A>。</xref:System.Collections.Stack.Count%2A> </xref:System.Collections.Stack.Push%2A> <xref:System.Collections.Stack.Pop%2A>是一项 o （1） 操作。</xref:System.Collections.Stack.Pop%2A>       堆栈接受`null`作为有效的值，并允许重复的元素。"
  example:
  - "The following example shows how to create and add values to a Stack and how to display its values.  \n  \n [!code-cs[Classic Stack Example#1](~/add/codesnippet/csharp/t-system.collections.stack_1.cs)]\n [!code-vb[Classic Stack Example#1](~/add/codesnippet/visualbasic/t-system.collections.stack_1.vb)]\n [!code-cpp[Classic Stack Example#1](~/add/codesnippet/cpp/t-system.collections.stack_1.cpp)]"
  syntax:
    content: >-
      [System.Diagnostics.DebuggerDisplay("Count = {Count}")]

      [System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Stack/StackDebugView))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public class Stack : ICloneable, System.Collections.ICollection
  inheritance:
  - System.Object
  implements:
  - System.Collections.ICollection
  - System.ICloneable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Collections.Stack.#ctor
  id: '#ctor'
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Stack()
  nameWithType: Stack.Stack()
  fullName: System.Collections.Stack.Stack()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化的新实例<xref href=&quot;System.Collections.Stack&quot;></xref>为空并且具有默认初始容量的类。"
  remarks: "容量<xref:System.Collections.Stack>是元素的数目，<xref:System.Collections.Stack>可以容纳。</xref:System.Collections.Stack> </xref:System.Collections.Stack> 如元素添加到<xref:System.Collections.Stack>，自动增加容量通过重新分配在内部数组所需的方式。</xref:System.Collections.Stack>       如果可以估计集合的大小，指定的初始容量，则无需执行大量的大小将元素添加到<xref:System.Collections.Stack>。</xref:System.Collections.Stack>时调整操作       此构造函数是 o （1） 操作。"
  syntax:
    content: public Stack ();
    parameters: []
  overload: System.Collections.Stack.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.#ctor(System.Collections.ICollection)
  id: '#ctor(System.Collections.ICollection)'
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Stack(ICollection)
  nameWithType: Stack.Stack(ICollection)
  fullName: System.Collections.Stack.Stack(ICollection)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化的新实例<xref href=&quot;System.Collections.Stack&quot;></xref>类，该类包含从指定集合中复制的元素并具有相同的初始容量与复制的元素数。"
  remarks: "容量<xref:System.Collections.Stack>是元素的数目，<xref:System.Collections.Stack>可以容纳。</xref:System.Collections.Stack> </xref:System.Collections.Stack> 如元素添加到<xref:System.Collections.Stack>，自动增加容量通过重新分配在内部数组所需的方式。</xref:System.Collections.Stack>       如果可以估计集合的大小，指定的初始容量，则无需执行大量的大小将元素添加到<xref:System.Collections.Stack>。</xref:System.Collections.Stack>时调整操作       将元素复制到<xref:System.Collections.Stack>它们由<xref:System.Collections.IEnumerator>的<xref:System.Collections.ICollection>。</xref:System.Collections.ICollection></xref:System.Collections.IEnumerator>读取的相同顺序</xref:System.Collections.Stack>       此构造函数是 O (`n`) 操作，其中`n`是中的元素数`col`。"
  syntax:
    content: public Stack (System.Collections.ICollection col);
    parameters:
    - id: col
      type: System.Collections.ICollection
      description: "<xref:System.Collections.ICollection>从中复制元素。</xref:System.Collections.ICollection>"
  overload: System.Collections.Stack.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>col</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Stack.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Stack(Int32)
  nameWithType: Stack.Stack(Int32)
  fullName: System.Collections.Stack.Stack(Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化的新实例<xref href=&quot;System.Collections.Stack&quot;></xref>类的空并具有指定的初始容量或默认的初始容量，则两者中较大。"
  remarks: "容量<xref:System.Collections.Stack>是元素的数目，<xref:System.Collections.Stack>可以容纳。</xref:System.Collections.Stack> </xref:System.Collections.Stack> 如元素添加到<xref:System.Collections.Stack>，自动增加容量通过重新分配在内部数组所需的方式。</xref:System.Collections.Stack>       如果可以估计集合的大小，指定的初始容量，则无需执行大量的大小将元素添加到<xref:System.Collections.Stack>。</xref:System.Collections.Stack>时调整操作       此构造函数是 O (`n`) 操作，其中`n`是`initialCapacity`。"
  syntax:
    content: public Stack (int initialCapacity);
    parameters:
    - id: initialCapacity
      type: System.Int32
      description: "初始元素数的<xref href=&quot;System.Collections.Stack&quot;></xref>可以包含。"
  overload: System.Collections.Stack.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>initialCapacity</code>小于零。"
  platform:
  - net462
- uid: System.Collections.Stack.Clear
  id: Clear
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Clear()
  nameWithType: Stack.Clear()
  fullName: System.Collections.Stack.Clear()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "删除中的所有对象<xref href=&quot;System.Collections.Stack&quot;> </xref>。"
  remarks: "<xref:System.Collections.Stack.Count%2A>是设置为零，并且集合的元素对其他对象的引用也被释放。</xref:System.Collections.Stack.Count%2A>       此方法为 O (`n`) 操作，其中`n`为<xref:System.Collections.Stack.Count%2A>。</xref:System.Collections.Stack.Count%2A>"
  example:
  - "The following example shows how to clear the values of the <xref:System.Collections.Stack>.  \n  \n [!code-cpp[Classic Stack.Clear Example#1](~/add/codesnippet/cpp/m-system.collections.sta_5_1.cpp)]\n [!code-vb[Classic Stack.Clear Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_5_1.vb)]\n [!code-cs[Classic Stack.Clear Example#1](~/add/codesnippet/csharp/m-system.collections.sta_5_1.cs)]"
  syntax:
    content: public virtual void Clear ();
    parameters: []
  overload: System.Collections.Stack.Clear*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.Clone
  id: Clone
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Clone()
  nameWithType: Stack.Clone()
  fullName: System.Collections.Stack.Clone()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "创建的浅表复制<xref href=&quot;System.Collections.Stack&quot;> </xref>。"
  remarks: "集合的浅表副本复制仅的元素集合，不论它们是引用类型还是值类型，但它不会复制引用所引用的对象。 新集合中的引用都指向原始集合中的引用指向同一对象。       与此相反，集合的深层副本复制这些元素，以及由这些元素直接或间接引用的所有内容。       此方法为 O (`n`) 操作，其中`n`为<xref:System.Collections.Stack.Count%2A>。</xref:System.Collections.Stack.Count%2A>"
  syntax:
    content: public virtual object Clone ();
    parameters: []
    return:
      type: System.Object
      description: "浅表复制<xref href=&quot;System.Collections.Stack&quot;> </xref>。"
  overload: System.Collections.Stack.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.Contains(System.Object)
  id: Contains(System.Object)
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Contains(Object)
  nameWithType: Stack.Contains(Object)
  fullName: System.Collections.Stack.Contains(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "确定某元素是否在<xref href=&quot;System.Collections.Stack&quot;> </xref>。"
  remarks: "此方法通过调用可确定相等性<xref:System.Object.Equals%2A?displayProperty=fullName>方法。</xref:System.Object.Equals%2A?displayProperty=fullName>       此方法执行的线性搜索;因此，此方法为 O (`n`) 操作，其中`n`为<xref:System.Collections.Stack.Count%2A>。</xref:System.Collections.Stack.Count%2A>       从.NET Framework 2.0 开始，此方法的测试相等性通过传递`obj`参数<xref:System.Object.Equals%2A>的集合中的单个对象的方法。</xref:System.Object.Equals%2A> 在.NET Framework 的早期版本，通过传递到集合中的各个项进行此决定<xref:System.Object.Equals%2A>方法`obj`自变量。</xref:System.Object.Equals%2A>"
  syntax:
    content: public virtual bool Contains (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "要在中找到的对象<xref href=&quot;System.Collections.Stack&quot;> </xref>。 该值可以为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>, if <code>obj</code> is found in the <xref href=&quot;System.Collections.Stack&quot;></xref>; otherwise, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>."
  overload: System.Collections.Stack.Contains*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.CopyTo(System.Array,System.Int32)
  id: CopyTo(System.Array,System.Int32)
  parent: System.Collections.Stack
  langs:
  - csharp
  name: CopyTo(Array,Int32)
  nameWithType: Stack.CopyTo(Array,Int32)
  fullName: System.Collections.Stack.CopyTo(Array,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "副本<xref href=&quot;System.Collections.Stack&quot;></xref>到现有一维<xref:System.Array>指定的数组索引处开始。</xref:System.Array>"
  remarks: "将元素复制到先出 (LIFO) 顺序，对返回的<xref:System.Collections.Stack.Pop%2A>.</xref:System.Collections.Stack.Pop%2A>调用一系列元素的顺序类似数组       此方法为 O (`n`) 操作，其中`n`为<xref:System.Collections.Stack.Count%2A>。</xref:System.Collections.Stack.Count%2A>"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Stack> into a one-dimensional array.  \n  \n [!code-cpp[Classic Stack.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.sta_6_1.cpp)]\n [!code-vb[Classic Stack.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_6_1.vb)]\n [!code-cs[Classic Stack.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.sta_6_1.cs)]"
  syntax:
    content: public virtual void CopyTo (Array array, int index);
    parameters:
    - id: array
      type: System.Array
      description: "一维<xref:System.Array>，它是从复制的元素的目标<xref href=&quot;System.Collections.Stack&quot;> </xref>。</xref:System.Array> <xref:System.Array>必须具有从零开始的索引。</xref:System.Array>"
    - id: index
      type: System.Int32
      description: "中的从零开始索引`array`复制开始处。"
  overload: System.Collections.Stack.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>小于零。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>是多维的。       -源中的元素的数目<xref href=&quot;System.Collections.Stack&quot;></xref>大于从的可用空间<code>index</code>到目标的末尾<code>array</code>。"
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "源类型<xref href=&quot;System.Collections.Stack&quot;></xref>无法自动转换为目标的类型<code> array </code>。"
  platform:
  - net462
- uid: System.Collections.Stack.Count
  id: Count
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Count
  nameWithType: Stack.Count
  fullName: System.Collections.Stack.Count
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "获取包含中的元素数<xref href=&quot;System.Collections.Stack&quot;> </xref>。"
  remarks: "容量是元素的数目，<xref:System.Collections.Stack>可以存储。</xref:System.Collections.Stack> 计数是其实是<xref:System.Collections.Stack>.</xref:System.Collections.Stack>的元素的数目       容量始终是大于或等于计数。 如果计数超出添加元素时的容量，通过在复制旧元素和添加新的元素之前重新分配在内部数组自动增大容量。       检索此属性的值是一个 o （1） 操作。"
  syntax:
    content: public virtual int Count { get; }
    return:
      type: System.Int32
      description: "中包含的元素数<xref href=&quot;System.Collections.Stack&quot;> </xref>。"
  overload: System.Collections.Stack.Count*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.GetEnumerator
  id: GetEnumerator
  parent: System.Collections.Stack
  langs:
  - csharp
  name: GetEnumerator()
  nameWithType: Stack.GetEnumerator()
  fullName: System.Collections.Stack.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "返回<xref:System.Collections.IEnumerator>为<xref href=&quot;System.Collections.Stack&quot;> </xref>。</xref:System.Collections.IEnumerator>"
  remarks: "[Visual Basic、 C#]      `foreach` C# 语言的语句 (`for each`在 Visual Basic 中) 隐藏了枚举数的复杂性。  因此，使用`foreach`建议，而不是直接操作枚举数。       枚举器可用于读取集合中中的数据，但它们不能用于修改基础集合。       最初，枚举数定位在集合中的第一个元素之前。 <xref:System.Collections.IEnumerator.Reset%2A>此外会回此位置的枚举数。</xref:System.Collections.IEnumerator.Reset%2A>  在此位置上，<xref:System.Collections.IEnumerator.Current%2A>是不确定的。</xref:System.Collections.IEnumerator.Current%2A> 因此，你必须调用<xref:System.Collections.IEnumerator.MoveNext%2A>的第一个元素的集合，然后再读取<xref:System.Collections.IEnumerator.Current%2A>.</xref:System.Collections.IEnumerator.Current%2A>的值枚举器向前移动</xref:System.Collections.IEnumerator.MoveNext%2A>       <xref:System.Collections.IEnumerator.Current%2A>返回相同的对象之前<xref:System.Collections.IEnumerator.MoveNext%2A>或<xref:System.Collections.IEnumerator.Reset%2A>称为。</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>设置<xref:System.Collections.IEnumerator.Current%2A>到下一个元素。</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>       如果<xref:System.Collections.IEnumerator.MoveNext%2A>越过的末尾的集合，枚举数定位在集合中的最后一个元素的后面和<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`。</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> 当枚举器位于此位置上，后续调用<xref:System.Collections.IEnumerator.MoveNext%2A>还返回`false`。</xref:System.Collections.IEnumerator.MoveNext%2A> 如果最后一次调用到<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`，<xref:System.Collections.IEnumerator.Current%2A>是不确定的。</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> 若要设置<xref:System.Collections.IEnumerator.Current%2A>可以再次，集合的第一个元素调用<xref:System.Collections.IEnumerator.Reset%2A>后, 跟<xref:System.Collections.IEnumerator.MoveNext%2A>.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.Current%2A>       只要集合保持不变，枚举数就保持有效。 如果对集合进行更改，如添加、 修改或删除元素，则枚举数将失效且不可恢复，而且其行为是不确定。       枚举数没有对集合; 独占访问权因此，枚举整个集合本质上不是一个线程安全的过程。  若要确保枚举过程中的线程安全性，可以锁定在整个枚举期间的集合。  若要允许访问集合以进行读取和写入的多个线程，则必须实现自己的同步。       此方法为 o （1） 运算。"
  syntax:
    content: public virtual System.Collections.IEnumerator GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: "An <xref:System.Collections.IEnumerator> for the <xref href=&quot;System.Collections.Stack&quot;></xref>.</xref:System.Collections.IEnumerator>"
  overload: System.Collections.Stack.GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.IsSynchronized
  id: IsSynchronized
  parent: System.Collections.Stack
  langs:
  - csharp
  name: IsSynchronized
  nameWithType: Stack.IsSynchronized
  fullName: System.Collections.Stack.IsSynchronized
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "获取一个值，该值指示是否访问<xref href=&quot;System.Collections.Stack&quot;></xref>是同步的 （线程安全）。"
  remarks: "若要确保的线程安全性<xref:System.Collections.Stack>，所有操作必须通过返回的包装器来都完成<xref:System.Collections.Stack.Synchronized%2A>方法。</xref:System.Collections.Stack.Synchronized%2A> </xref:System.Collections.Stack>       枚举整个集合本质上不是一个线程安全的过程。 即使某个集合已同步，其他线程仍可以修改集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改导致的异常。       下面的代码示例演示如何锁定集合使用<xref:System.Collections.Stack.SyncRoot%2A>在整个枚举期间。</xref:System.Collections.Stack.SyncRoot%2A>       [!code-cpp[经典 Stack.IsSynchronized 第二个示例](~/add/codesnippet/cpp/p-system.collections.sta_0_1.cpp)][!code-cs[经典 Stack.IsSynchronized 第二个示例](~/add/codesnippet/csharp/p-system.collections.sta_0_1.cs)][!code-vb[经典 Stack.IsSynchronized 第二个示例](~/add/codesnippet/visualbasic/p-system.collections.sta_0_1.vb)]检索此属性的值是一项 o （1） 操作。    "
  example:
  - "The following example shows how to synchronize a <xref:System.Collections.Stack>, determine if a <xref:System.Collections.Stack> is synchronized, and use a synchronized <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/visualbasic/p-system.collections.sta_0_2.vb)]\n [!code-cpp[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/cpp/p-system.collections.sta_0_2.cpp)]\n [!code-cs[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/csharp/p-system.collections.sta_0_2.cs)]"
  syntax:
    content: public virtual bool IsSynchronized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果访问<xref href=&quot;System.Collections.Stack&quot;></xref>是同步的 （线程安全）; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Collections.Stack.IsSynchronized*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.Peek
  id: Peek
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Peek()
  nameWithType: Stack.Peek()
  fullName: System.Collections.Stack.Peek()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "返回在顶部的对象<xref href=&quot;System.Collections.Stack&quot;></xref>而不删除它。"
  remarks: "此方法类似于<xref:System.Collections.Stack.Pop%2A>方法，但扫视不会修改<xref:System.Collections.Stack>.</xref:System.Collections.Stack></xref:System.Collections.Stack.Pop%2A>是       `null`可以被推送到<xref:System.Collections.Stack>用作占位符，如有必要。</xref:System.Collections.Stack> 若要区分 null 值和在堆栈结尾，请检查<xref:System.Collections.Stack.Count%2A>属性或 catch <xref:System.InvalidOperationException>，时引发<xref:System.Collections.Stack>为空。</xref:System.Collections.Stack> </xref:System.InvalidOperationException> </xref:System.Collections.Stack.Count%2A>       此方法为 o （1） 运算。"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Stack>, remove elements from the <xref:System.Collections.Stack>, or view the element at the top of the <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.Peek Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_4_1.vb)]\n [!code-cs[Classic Stack.Peek Example#1](~/add/codesnippet/csharp/m-system.collections.sta_4_1.cs)]\n [!code-cpp[Classic Stack.Peek Example#1](~/add/codesnippet/cpp/m-system.collections.sta_4_1.cpp)]"
  syntax:
    content: public virtual object Peek ();
    parameters: []
    return:
      type: System.Object
      description: "<xref:System.Object>顶部<xref href=&quot;System.Collections.Stack&quot;> </xref>。</xref:System.Object>"
  overload: System.Collections.Stack.Peek*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Collections.Stack&quot;> </xref>为空。"
  platform:
  - net462
- uid: System.Collections.Stack.Pop
  id: Pop
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Pop()
  nameWithType: Stack.Pop()
  fullName: System.Collections.Stack.Pop()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "移除并返回在顶部的对象<xref href=&quot;System.Collections.Stack&quot;> </xref>。"
  remarks: "此方法类似于<xref:System.Collections.Stack.Peek%2A>方法，但<xref:System.Collections.Stack.Peek%2A>不是会修改<xref:System.Collections.Stack>.</xref:System.Collections.Stack></xref:System.Collections.Stack.Peek%2A></xref:System.Collections.Stack.Peek%2A>是       `null`可以被推送到<xref:System.Collections.Stack>用作占位符，如有必要。</xref:System.Collections.Stack> 若要区分 null 值和在堆栈结尾，请检查<xref:System.Collections.Stack.Count%2A>属性或 catch <xref:System.InvalidOperationException>，时引发<xref:System.Collections.Stack>为空。</xref:System.Collections.Stack> </xref:System.InvalidOperationException> </xref:System.Collections.Stack.Count%2A>       此方法为 o （1） 运算。"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Stack>, remove elements from the <xref:System.Collections.Stack>, or view the element at the top of the <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.Peek Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_2_1.vb)]\n [!code-cs[Classic Stack.Peek Example#1](~/add/codesnippet/csharp/m-system.collections.sta_2_1.cs)]\n [!code-cpp[Classic Stack.Peek Example#1](~/add/codesnippet/cpp/m-system.collections.sta_2_1.cpp)]"
  syntax:
    content: public virtual object Pop ();
    parameters: []
    return:
      type: System.Object
      description: "<xref:System.Object>从顶部删除<xref href=&quot;System.Collections.Stack&quot;> </xref>。</xref:System.Object>"
  overload: System.Collections.Stack.Pop*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Collections.Stack&quot;> </xref>为空。"
  platform:
  - net462
- uid: System.Collections.Stack.Push(System.Object)
  id: Push(System.Object)
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Push(Object)
  nameWithType: Stack.Push(Object)
  fullName: System.Collections.Stack.Push(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "在顶部插入一个对象<xref href=&quot;System.Collections.Stack&quot;> </xref>。"
  remarks: "如果<xref:System.Collections.Stack.Count%2A>已经等于容量的容量<xref:System.Collections.Stack>增加通过自动重新分配在内部数组和现有元素被复制到新数组中，在添加新的元素之前。</xref:System.Collections.Stack> </xref:System.Collections.Stack.Count%2A>       `null`可以被推送到<xref:System.Collections.Stack>用作占位符，如有必要。</xref:System.Collections.Stack> 它将占用堆栈中的槽，并且都被视为任何对象。       如果<xref:System.Collections.Stack.Count%2A>小于比堆栈的容量，推送的运算复杂度为 o （1）。</xref:System.Collections.Stack.Count%2A> 如果增加以容纳新元素所需的容量，推送将成为 O (`n`) 操作，其中`n`为<xref:System.Collections.Stack.Count%2A>。</xref:System.Collections.Stack.Count%2A>"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Stack>, remove elements from the <xref:System.Collections.Stack>, or view the element at the top of the <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.Peek Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_1_1.vb)]\n [!code-cs[Classic Stack.Peek Example#1](~/add/codesnippet/csharp/m-system.collections.sta_1_1.cs)]\n [!code-cpp[Classic Stack.Peek Example#1](~/add/codesnippet/cpp/m-system.collections.sta_1_1.cpp)]"
  syntax:
    content: public virtual void Push (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "<xref:System.Object>要推入到<xref href=&quot;System.Collections.Stack&quot;> </xref>。</xref:System.Object> 该值可以为<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Collections.Stack.Push*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.Synchronized(System.Collections.Stack)
  id: Synchronized(System.Collections.Stack)
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Synchronized(Stack)
  nameWithType: Stack.Synchronized(Stack)
  fullName: System.Collections.Stack.Synchronized(Stack)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "返回同步 （线程安全） 包装器<xref href=&quot;System.Collections.Stack&quot;> </xref>。"
  remarks: "若要确保的线程安全性<xref:System.Collections.Stack>，必须通过此包装器完成所有操作。</xref:System.Collections.Stack>       枚举整个集合本质上不是一个线程安全的过程。 即使某个集合已同步，其他线程仍可以修改集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改导致的异常。       下面的代码示例演示如何锁定集合使用<xref:System.Collections.Stack.SyncRoot%2A>在整个枚举期间。</xref:System.Collections.Stack.SyncRoot%2A>       [!code-cpp[经典 Stack.IsSynchronized 第二个示例](~/add/codesnippet/cpp/m-system.collections.sta_3_1.cpp)][!code-cs[经典 Stack.IsSynchronized 第二个示例](~/add/codesnippet/csharp/m-system.collections.sta_3_1.cs)][!code-vb[经典 Stack.IsSynchronized 第二个示例](~/add/codesnippet/visualbasic/m-system.collections.sta_3_1.vb)]此方法为 o （1） 运算。    "
  example:
  - "The following example shows how to synchronize a <xref:System.Collections.Stack>, determine if a <xref:System.Collections.Stack> is synchronized, and use a synchronized <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_3_2.vb)]\n [!code-cpp[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/cpp/m-system.collections.sta_3_2.cpp)]\n [!code-cs[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/csharp/m-system.collections.sta_3_2.cs)]"
  syntax:
    content: public static System.Collections.Stack Synchronized (System.Collections.Stack stack);
    parameters:
    - id: stack
      type: System.Collections.Stack
      description: "<xref href=&quot;System.Collections.Stack&quot;> </xref>进行同步。"
    return:
      type: System.Collections.Stack
      description: "同步的包装<xref href=&quot;System.Collections.Stack&quot;> </xref>。"
  overload: System.Collections.Stack.Synchronized*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>stack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Stack.SyncRoot
  id: SyncRoot
  parent: System.Collections.Stack
  langs:
  - csharp
  name: SyncRoot
  nameWithType: Stack.SyncRoot
  fullName: System.Collections.Stack.SyncRoot
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "获取可以用于对访问进行同步的对象<xref href=&quot;System.Collections.Stack&quot;> </xref>。"
  remarks: "若要创建的同步的版本<xref:System.Collections.Stack>，使用<xref:System.Collections.Stack.Synchronized%2A>方法。</xref:System.Collections.Stack.Synchronized%2A> </xref:System.Collections.Stack> 但是，派生的类可以提供自己的同步的版本<xref:System.Collections.Stack>使用 SyncRoot 属性。</xref:System.Collections.Stack> 同步代码必须对执行操作的 SyncRoot <xref:System.Collections.Stack>，不是直接对<xref:System.Collections.Stack>.</xref:System.Collections.Stack> </xref:System.Collections.Stack> 这可确保正确地执行操作的从其他对象派生的集合。 具体地说，这样可保持正确的同步，与可能同时对修改其他线程<xref:System.Collections.Stack>对象。</xref:System.Collections.Stack>       枚举整个集合本质上不是一个线程安全的过程。 即使某个集合已同步，其他线程仍可以修改集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改导致的异常。       下面的代码示例演示如何锁定在整个枚举过程中使用 SyncRoot 的集合。       [!code-cpp[经典 Stack.IsSynchronized 第二个示例](~/add/codesnippet/cpp/p-system.collections.sta_1_1.cpp)][!code-cs[经典 Stack.IsSynchronized 第二个示例](~/add/codesnippet/csharp/p-system.collections.sta_1_1.cs)][!code-vb[经典 Stack.IsSynchronized 第二个示例](~/add/codesnippet/visualbasic/p-system.collections.sta_1_1.vb)]检索此属性的值是一项 o （1） 操作。    "
  syntax:
    content: public virtual object SyncRoot { get; }
    return:
      type: System.Object
      description: "<xref:System.Object>可用于同步对访问<xref href=&quot;System.Collections.Stack&quot;> </xref>。</xref:System.Object>"
  overload: System.Collections.Stack.SyncRoot*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.ToArray
  id: ToArray
  parent: System.Collections.Stack
  langs:
  - csharp
  name: ToArray()
  nameWithType: Stack.ToArray()
  fullName: System.Collections.Stack.ToArray()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "副本<xref href=&quot;System.Collections.Stack&quot;></xref>到新数组。"
  remarks: "将元素复制到先出 (LIFO) 顺序，对返回的<xref:System.Collections.Stack.Pop%2A>.</xref:System.Collections.Stack.Pop%2A>调用一系列元素的顺序类似数组       此方法为 O (`n`) 操作，其中`n`为<xref:System.Collections.Stack.Count%2A>。</xref:System.Collections.Stack.Count%2A>"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Stack> into a one-dimensional array.  \n  \n [!code-cpp[Classic Stack.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.sta_0_1.cpp)]\n [!code-vb[Classic Stack.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_0_1.vb)]\n [!code-cs[Classic Stack.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.sta_0_1.cs)]"
  syntax:
    content: public virtual object[] ToArray ();
    parameters: []
    return:
      type: System.Object[]
      description: "新数组包含元素的副本<xref href=&quot;System.Collections.Stack&quot;> </xref>。"
  overload: System.Collections.Stack.ToArray*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidCastException
  isExternal: true
  name: System.InvalidCastException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Collections.Stack.#ctor
  parent: System.Collections.Stack
  isExternal: false
  name: Stack()
  nameWithType: Stack.Stack()
  fullName: System.Collections.Stack.Stack()
- uid: System.Collections.Stack.#ctor(System.Collections.ICollection)
  parent: System.Collections.Stack
  isExternal: false
  name: Stack(ICollection)
  nameWithType: Stack.Stack(ICollection)
  fullName: System.Collections.Stack.Stack(ICollection)
- uid: System.Collections.ICollection
  parent: System.Collections
  isExternal: true
  name: ICollection
  nameWithType: ICollection
  fullName: System.Collections.ICollection
- uid: System.Collections.Stack.#ctor(System.Int32)
  parent: System.Collections.Stack
  isExternal: false
  name: Stack(Int32)
  nameWithType: Stack.Stack(Int32)
  fullName: System.Collections.Stack.Stack(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Collections.Stack.Clear
  parent: System.Collections.Stack
  isExternal: false
  name: Clear()
  nameWithType: Stack.Clear()
  fullName: System.Collections.Stack.Clear()
- uid: System.Collections.Stack.Clone
  parent: System.Collections.Stack
  isExternal: false
  name: Clone()
  nameWithType: Stack.Clone()
  fullName: System.Collections.Stack.Clone()
- uid: System.Collections.Stack.Contains(System.Object)
  parent: System.Collections.Stack
  isExternal: false
  name: Contains(Object)
  nameWithType: Stack.Contains(Object)
  fullName: System.Collections.Stack.Contains(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Collections.Stack.CopyTo(System.Array,System.Int32)
  parent: System.Collections.Stack
  isExternal: false
  name: CopyTo(Array,Int32)
  nameWithType: Stack.CopyTo(Array,Int32)
  fullName: System.Collections.Stack.CopyTo(Array,Int32)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: System.Collections.Stack.Count
  parent: System.Collections.Stack
  isExternal: false
  name: Count
  nameWithType: Stack.Count
  fullName: System.Collections.Stack.Count
- uid: System.Collections.Stack.GetEnumerator
  parent: System.Collections.Stack
  isExternal: false
  name: GetEnumerator()
  nameWithType: Stack.GetEnumerator()
  fullName: System.Collections.Stack.GetEnumerator()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Collections.Stack.IsSynchronized
  parent: System.Collections.Stack
  isExternal: false
  name: IsSynchronized
  nameWithType: Stack.IsSynchronized
  fullName: System.Collections.Stack.IsSynchronized
- uid: System.Collections.Stack.Peek
  parent: System.Collections.Stack
  isExternal: false
  name: Peek()
  nameWithType: Stack.Peek()
  fullName: System.Collections.Stack.Peek()
- uid: System.Collections.Stack.Pop
  parent: System.Collections.Stack
  isExternal: false
  name: Pop()
  nameWithType: Stack.Pop()
  fullName: System.Collections.Stack.Pop()
- uid: System.Collections.Stack.Push(System.Object)
  parent: System.Collections.Stack
  isExternal: false
  name: Push(Object)
  nameWithType: Stack.Push(Object)
  fullName: System.Collections.Stack.Push(Object)
- uid: System.Collections.Stack.Synchronized(System.Collections.Stack)
  parent: System.Collections.Stack
  isExternal: false
  name: Synchronized(Stack)
  nameWithType: Stack.Synchronized(Stack)
  fullName: System.Collections.Stack.Synchronized(Stack)
- uid: System.Collections.Stack
  parent: System.Collections
  isExternal: false
  name: Stack
  nameWithType: Stack
  fullName: System.Collections.Stack
- uid: System.Collections.Stack.SyncRoot
  parent: System.Collections.Stack
  isExternal: false
  name: SyncRoot
  nameWithType: Stack.SyncRoot
  fullName: System.Collections.Stack.SyncRoot
- uid: System.Collections.Stack.ToArray
  parent: System.Collections.Stack
  isExternal: false
  name: ToArray()
  nameWithType: Stack.ToArray()
  fullName: System.Collections.Stack.ToArray()
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Collections.Stack.#ctor*
  parent: System.Collections.Stack
  isExternal: false
  name: Stack
  nameWithType: Stack.Stack
- uid: System.Collections.Stack.Clear*
  parent: System.Collections.Stack
  isExternal: false
  name: Clear
  nameWithType: Stack.Clear
- uid: System.Collections.Stack.Clone*
  parent: System.Collections.Stack
  isExternal: false
  name: Clone
  nameWithType: Stack.Clone
- uid: System.Collections.Stack.Contains*
  parent: System.Collections.Stack
  isExternal: false
  name: Contains
  nameWithType: Stack.Contains
- uid: System.Collections.Stack.CopyTo*
  parent: System.Collections.Stack
  isExternal: false
  name: CopyTo
  nameWithType: Stack.CopyTo
- uid: System.Collections.Stack.Count*
  parent: System.Collections.Stack
  isExternal: false
  name: Count
  nameWithType: Stack.Count
- uid: System.Collections.Stack.GetEnumerator*
  parent: System.Collections.Stack
  isExternal: false
  name: GetEnumerator
  nameWithType: Stack.GetEnumerator
- uid: System.Collections.Stack.IsSynchronized*
  parent: System.Collections.Stack
  isExternal: false
  name: IsSynchronized
  nameWithType: Stack.IsSynchronized
- uid: System.Collections.Stack.Peek*
  parent: System.Collections.Stack
  isExternal: false
  name: Peek
  nameWithType: Stack.Peek
- uid: System.Collections.Stack.Pop*
  parent: System.Collections.Stack
  isExternal: false
  name: Pop
  nameWithType: Stack.Pop
- uid: System.Collections.Stack.Push*
  parent: System.Collections.Stack
  isExternal: false
  name: Push
  nameWithType: Stack.Push
- uid: System.Collections.Stack.Synchronized*
  parent: System.Collections.Stack
  isExternal: false
  name: Synchronized
  nameWithType: Stack.Synchronized
- uid: System.Collections.Stack.SyncRoot*
  parent: System.Collections.Stack
  isExternal: false
  name: SyncRoot
  nameWithType: Stack.SyncRoot
- uid: System.Collections.Stack.ToArray*
  parent: System.Collections.Stack
  isExternal: false
  name: ToArray
  nameWithType: Stack.ToArray
