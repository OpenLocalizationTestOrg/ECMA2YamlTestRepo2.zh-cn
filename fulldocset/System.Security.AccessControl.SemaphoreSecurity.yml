### YamlMime:ManagedReference
items:
- uid: System.Security.AccessControl.SemaphoreSecurity
  id: SemaphoreSecurity
  children:
  - System.Security.AccessControl.SemaphoreSecurity.#ctor
  - System.Security.AccessControl.SemaphoreSecurity.#ctor(System.String,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.SemaphoreSecurity.AccessRightType
  - System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  - System.Security.AccessControl.SemaphoreSecurity.AccessRuleType
  - System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  - System.Security.AccessControl.SemaphoreSecurity.AddAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  - System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  - System.Security.AccessControl.SemaphoreSecurity.AuditRuleType
  - System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  - System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)
  - System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)
  - System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  - System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll(System.Security.AccessControl.SemaphoreAuditRule)
  - System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.SemaphoreAuditRule)
  - System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  - System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  - System.Security.AccessControl.SemaphoreSecurity.SetAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  langs:
  - csharp
  name: SemaphoreSecurity
  nameWithType: SemaphoreSecurity
  fullName: System.Security.AccessControl.SemaphoreSecurity
  type: Class
  summary: "表示命名信号量的 Windows 访问控制安全性。 此类不能被继承。"
  remarks: "SemaphoreSecurity 对象指定已命名的系统信号量的访问权限，并且还指定如何审核访问尝试。 信号量的访问权限表示为规则，由表示每个访问规则<xref:System.Security.AccessControl.SemaphoreAccessRule>对象。</xref:System.Security.AccessControl.SemaphoreAccessRule> 每个审核规则由<xref:System.Security.AccessControl.SemaphoreAuditRule>对象。</xref:System.Security.AccessControl.SemaphoreAuditRule>       这反映了基础的 Windows 安全系统，其中每个安全对象具有最多有一个自定义访问控制列表 (DACL) 控制访问受保护的对象以及最多有一个系统访问控制列表 (SACL) 指定哪些访问尝试进行审核。 DACL 和 SACL 进行排序的指定访问和审核用户和组的访问控制项 (ACE) 的列表。 A<xref:System.Security.AccessControl.SemaphoreAccessRule>或<xref:System.Security.AccessControl.SemaphoreAuditRule>对象可以表示多个 ACE。</xref:System.Security.AccessControl.SemaphoreAuditRule> </xref:System.Security.AccessControl.SemaphoreAccessRule>      1> [!NOTE]&1;> A<xref:System.Threading.Semaphore>对象可以表示本地信号量或已命名的系统信号量。</xref:System.Threading.Semaphore> Windows 访问控制安全，则仅对已命名的系统信号量有意义。       SemaphoreSecurity， <xref:System.Security.AccessControl.SemaphoreAccessRule>，和<xref:System.Security.AccessControl.SemaphoreAuditRule>类隐藏 Acl 和 Ace 的实现详细信息。</xref:System.Security.AccessControl.SemaphoreAuditRule> </xref:System.Security.AccessControl.SemaphoreAccessRule> 这使你忽略十七不同的 ACE 类型和正确维护继承和访问权限的传播的复杂性。 这些对象还旨在防止以下常见的访问控制错误:-使用 null DACL 创建安全描述符。 对 DACL 的 null 引用允许任何用户将访问规则添加到一个对象，该对象可能创建的拒绝服务攻击。 新的 SemaphoreSecurity 对象开始时始终具有一个空元素，此操作会拒绝所有用户的所有访问权限的 DACL。      -违反 Ace 的规范顺序。 如果 DACL 中的 ACE 列表不保存在规范顺序，用户可能会无意中被赋予访问受保护的对象。 例如，被拒绝的访问权限必须始终出现在允许的访问权限之前。 SemaphoreSecurity 对象内部维护正确的顺序。      操作安全描述符标志，它应在资源管理器控件。      -创建 ACE 标志的无效的组合。      -操纵继承的 Ace。 继承和传播由资源管理器，以响应对访问和审核规则所做的更改处理。      -将无意义的 Ace 插入到 Acl。       不支持的.NET 安全对象的唯一功能是应当避免由应用程序开发人员，如下所示的大部分的危险活动:-低级通常由资源管理器执行的任务。      -添加或移除访问控制项的不维护规范排序的方式。       若要修改名称为信号量的 Windows 访问控制安全性，请使用<xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName>方法以获取 SemaphoreSecurity 对象。</xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName> 通过添加和删除规则，修改安全对象，然后使用该<xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>方法将重新附加它。</xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>      1> [!IMPORTANT]&1;> SemaphoreSecurity 对象所做的更改不影响名称为信号量的访问级别直到你调用<xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>方法以将修改过的安全对象分配给命名信号量。</xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>       若要将访问控制安全性复制到另一个信号量，使用<xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName>方法来获取表示的第一个信号的访问和审核规则的 SemaphoreSecurity 对象然后使用<xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>方法或接受 SemaphoreSecurity 对象，将这些规则分配给第二个信号量的构造函数。</xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName> </xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName>       以安全描述符定义语言 (SDDL) 中的投资的用户可以使用<xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A>方法以设置访问规则命名信号量，与<xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A>方法来获取表示访问规则的 SDDL 格式的字符串。</xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> </xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> 这不是建议新的开发。      1> [!NOTE] 1> Windows 98 或 Windows Millennium Edition 不支持同步对象的安全性。"
  example:
  - "The following code example demonstrates the separation between <xref:System.Security.AccessControl.AccessControlType> rules and <xref:System.Security.AccessControl.AccessControlType> rules, and shows the combination of rights in compatible rules. The example creates a SemaphoreSecurity object, adds rules that allow and deny various rights for the current user, and displays the resulting pair of rules. The example then allows new rights for the current user and displays the result, showing that the new rights are merged with the existing <xref:System.Security.AccessControl.AccessControlType> rule.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:System.Threading.Semaphore> object. Examples that attach security objects can be found in <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName> and <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-cs[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/add/codesnippet/csharp/t-system.security.access_8_1.cs)]\n [!code-vb[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/add/codesnippet/visualbasic/t-system.security.access_8_1.vb)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(false)]

      public sealed class SemaphoreSecurity : System.Security.AccessControl.NativeObjectSecurity
  inheritance:
  - System.Object
  - System.Security.AccessControl.ObjectSecurity
  - System.Security.AccessControl.CommonObjectSecurity
  - System.Security.AccessControl.NativeObjectSecurity
  implements: []
  inheritedMembers:
  - System.Security.AccessControl.CommonObjectSecurity.AddAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.AddAuditRule(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.GetAccessRules(System.Boolean,System.Boolean,System.Type)
  - System.Security.AccessControl.CommonObjectSecurity.GetAuditRules(System.Boolean,System.Boolean,System.Type)
  - System.Security.AccessControl.CommonObjectSecurity.ModifyAccess(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AccessRule,System.Boolean@)
  - System.Security.AccessControl.CommonObjectSecurity.ModifyAudit(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AuditRule,System.Boolean@)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAccessRuleAll(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAuditRule(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAuditRuleAll(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.ResetAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.SetAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.SetAuditRule(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.Runtime.InteropServices.SafeHandle,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.Runtime.InteropServices.SafeHandle,System.Security.AccessControl.AccessControlSections,System.Object)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.String,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.String,System.Security.AccessControl.AccessControlSections,System.Object)
  - System.Security.AccessControl.ObjectSecurity.AccessRulesModified
  - System.Security.AccessControl.ObjectSecurity.AreAccessRulesCanonical
  - System.Security.AccessControl.ObjectSecurity.AreAccessRulesProtected
  - System.Security.AccessControl.ObjectSecurity.AreAuditRulesCanonical
  - System.Security.AccessControl.ObjectSecurity.AreAuditRulesProtected
  - System.Security.AccessControl.ObjectSecurity.AuditRulesModified
  - System.Security.AccessControl.ObjectSecurity.GetGroup(System.Type)
  - System.Security.AccessControl.ObjectSecurity.GetOwner(System.Type)
  - System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm
  - System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm(System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.GroupModified
  - System.Security.AccessControl.ObjectSecurity.IsContainer
  - System.Security.AccessControl.ObjectSecurity.IsDS
  - System.Security.AccessControl.ObjectSecurity.IsSddlConversionSupported
  - System.Security.AccessControl.ObjectSecurity.ModifyAccessRule(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AccessRule,System.Boolean@)
  - System.Security.AccessControl.ObjectSecurity.ModifyAuditRule(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AuditRule,System.Boolean@)
  - System.Security.AccessControl.ObjectSecurity.OwnerModified
  - System.Security.AccessControl.ObjectSecurity.Persist(System.Boolean,System.String,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.PurgeAccessRules(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.PurgeAuditRules(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.ReadLock
  - System.Security.AccessControl.ObjectSecurity.ReadUnlock
  - System.Security.AccessControl.ObjectSecurity.SetAccessRuleProtection(System.Boolean,System.Boolean)
  - System.Security.AccessControl.ObjectSecurity.SetAuditRuleProtection(System.Boolean,System.Boolean)
  - System.Security.AccessControl.ObjectSecurity.SetGroup(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.SetOwner(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm(System.Byte[])
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm(System.Byte[],System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm(System.String)
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm(System.String,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.WriteLock
  - System.Security.AccessControl.ObjectSecurity.WriteUnlock
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.#ctor
  id: '#ctor'
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: SemaphoreSecurity()
  nameWithType: SemaphoreSecurity.SemaphoreSecurity()
  fullName: System.Security.AccessControl.SemaphoreSecurity.SemaphoreSecurity()
  type: Constructor
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "初始化的新实例<xref href=&quot;System.Security.AccessControl.SemaphoreSecurity&quot;></xref>类使用默认值。"
  remarks: "一个新<xref:System.Security.AccessControl.SemaphoreSecurity>对象开始时始终具有空的自由访问控制列表 (DACL)，此操作会拒绝所有用户的所有访问权限。</xref:System.Security.AccessControl.SemaphoreSecurity>"
  syntax:
    content: public SemaphoreSecurity ();
    parameters: []
  overload: System.Security.AccessControl.SemaphoreSecurity.#ctor*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "在 Windows 98 或 Windows Millennium Edition 上不支持此类。"
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.#ctor(System.String,System.Security.AccessControl.AccessControlSections)
  id: '#ctor(System.String,System.Security.AccessControl.AccessControlSections)'
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: SemaphoreSecurity(String,AccessControlSections)
  nameWithType: SemaphoreSecurity.SemaphoreSecurity(String,AccessControlSections)
  fullName: System.Security.AccessControl.SemaphoreSecurity.SemaphoreSecurity(String,AccessControlSections)
  type: Constructor
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "初始化的新实例<xref href=&quot;System.Security.AccessControl.SemaphoreSecurity&quot;></xref>类从具有指定名称的系统信号量的访问控制安全规则的指定部分。"
  remarks: "此构造函数，可获取已命名的系统信号量的访问控制安全性，而不必首先创建<xref:System.Threading.Semaphore>对象。</xref:System.Threading.Semaphore>       在使用已命名的系统对象时必须小心谨慎。 如果没有名为系统对象`name`不信号量，可能会检索其访问控制安全性。"
  syntax:
    content: public SemaphoreSecurity (string name, System.Security.AccessControl.AccessControlSections includeSections);
    parameters:
    - id: name
      type: System.String
      description: "其访问控制安全性规则是要检索的系统信号量的名称。"
    - id: includeSections
      type: System.Security.AccessControl.AccessControlSections
      description: "组合<xref href=&quot;System.Security.AccessControl.AccessControlSections&quot;></xref>标志指定要检索的部分。"
  overload: System.Security.AccessControl.SemaphoreSecurity.#ctor*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "在 Windows 98 或 Windows Millennium Edition 上不支持此类。"
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.AccessRightType
  id: AccessRightType
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: AccessRightType
  nameWithType: SemaphoreSecurity.AccessRightType
  fullName: System.Security.AccessControl.SemaphoreSecurity.AccessRightType
  type: Property
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "获取枚举<xref href=&quot;System.Security.AccessControl.SemaphoreSecurity&quot;></xref>类用于表示的访问权限。"
  remarks: "派生自的类<xref:System.Security.AccessControl.ObjectSecurity>类替代<xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A>属性，并返回它们用于表示的访问权限的类型。</xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> </xref:System.Security.AccessControl.ObjectSecurity> 当使用数组或包含多个类型的安全对象的集合时，使用此属性来确定要用于每个安全对象的正确的枚举类型。"
  syntax:
    content: public override Type AccessRightType { get; }
    return:
      type: System.Type
      description: "A<xref:System.Type>对象，表示<xref href=&quot;System.Security.AccessControl.SemaphoreRights&quot;></xref>枚举。</xref:System.Type>"
  overload: System.Security.AccessControl.SemaphoreSecurity.AccessRightType*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  id: AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  nameWithType: SemaphoreSecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  fullName: System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "创建新的访问控制规则指定的用户，使用指定的访问权限、 访问控制和标志。"
  remarks: "创建访问控制规则的建议的方法是使用<xref:System.Security.AccessControl.SemaphoreAccessRule>类</xref:System.Security.AccessControl.SemaphoreAccessRule>的构造函数      1> [!NOTE]&1;> 虽然继承和传播标志对命名信号量无意义，就仍然可以指定它们不建议这样做，因为它不必要地增加复杂性进行维护的规则，例如通过干扰本来可以兼容的规则的组合。"
  syntax:
    content: public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);
    parameters:
    - id: identityReference
      type: System.Security.Principal.IdentityReference
      description: "<xref href=&quot;System.Security.Principal.IdentityReference&quot;> </xref>标识用户或组规则适用于。"
    - id: accessMask
      type: System.Int32
      description: "按位组合<xref href=&quot;System.Security.AccessControl.SemaphoreRights&quot;></xref>值指定的访问权限以允许或拒绝，强制转换为整数。"
    - id: isInherited
      type: System.Boolean
      description: "对于没有意义命名信号量，因为它们没有层次结构。"
    - id: inheritanceFlags
      type: System.Security.AccessControl.InheritanceFlags
      description: "对于没有意义命名信号量，因为它们没有层次结构。"
    - id: propagationFlags
      type: System.Security.AccessControl.PropagationFlags
      description: "对于没有意义命名信号量，因为它们没有层次结构。"
    - id: type
      type: System.Security.AccessControl.AccessControlType
      description: "之一<xref href=&quot;System.Security.AccessControl.AccessControlType&quot;></xref>值指定是否允许或拒绝权限。"
    return:
      type: System.Security.AccessControl.AccessRule
      description: "A <xref href=&quot;System.Security.AccessControl.SemaphoreAccessRule&quot;> </xref>对象，表示指定的用户指定的权限。"
  overload: System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>accessMask</code><code>inheritanceFlags</code>， <code>propagationFlags</code>，或<code>type</code>指定了一个无效值。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>identityReference</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或-<code>accessMask</code>为零。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>identityReference</code>既不属于类型<xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>，也不的类型，如<xref href=&quot;System.Security.Principal.NTAccount&quot;></xref>可以转换为类型<xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>。"
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.AccessRuleType
  id: AccessRuleType
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: AccessRuleType
  nameWithType: SemaphoreSecurity.AccessRuleType
  fullName: System.Security.AccessControl.SemaphoreSecurity.AccessRuleType
  type: Property
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "获取的类型<xref href=&quot;System.Security.AccessControl.SemaphoreSecurity&quot;></xref>类用于表示访问规则。"
  remarks: "派生自的类<xref:System.Security.AccessControl.ObjectSecurity>类替代<xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A>属性，并返回它们用于表示访问规则的类型。</xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> </xref:System.Security.AccessControl.ObjectSecurity> 当使用数组或包含多个类型的安全对象的集合时，使用此属性来确定要使用每个安全对象的正确的访问规则类型。"
  syntax:
    content: public override Type AccessRuleType { get; }
    return:
      type: System.Type
      description: "A<xref:System.Type>对象，表示<xref href=&quot;System.Security.AccessControl.SemaphoreAccessRule&quot;></xref>类</xref:System.Type>"
  overload: System.Security.AccessControl.SemaphoreSecurity.AccessRuleType*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  id: AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: AddAccessRule(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.AddAccessRule(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(SemaphoreAccessRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "与新的规则可以合并规则匹配的搜索。 如果找不到之后，将添加新规则。"
  remarks: "AddAccessRule 方法搜索与同一用户或组，以及相同的规则<xref:System.Security.AccessControl.AccessControlType>作为`rule`。</xref:System.Security.AccessControl.AccessControlType> 如果找不到之后，`rule`添加。 如果找到匹配规则是中的权限`rule`合并与现有规则。"
  example:
  - "The following code example demonstrates the separation between <xref:System.Security.AccessControl.AccessControlType> rules and <xref:System.Security.AccessControl.AccessControlType> rules, and shows the combination of rights in compatible rules. The example creates a <xref:System.Security.AccessControl.SemaphoreSecurity> object, adds rules that allow and deny various rights for the current user, and displays the resulting pair of rules. The example then allows new rights for the current user and displays the result, showing that the new rights are merged with the existing <xref:System.Security.AccessControl.AccessControlType> rule.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:System.Threading.Semaphore> object. Examples that attach security objects can be found in <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName> and <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-cs[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/add/codesnippet/csharp/5be6d691-cc28-4e1b-ae9c-_1.cs)]\n [!code-vb[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/add/codesnippet/visualbasic/5be6d691-cc28-4e1b-ae9c-_1.vb)]"
  syntax:
    content: public void AddAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAccessRule
      description: "要添加的访问控制规则。"
  overload: System.Security.AccessControl.SemaphoreSecurity.AddAccessRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.AddAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  id: AddAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: AddAuditRule(SemaphoreAuditRule)
  nameWithType: SemaphoreSecurity.AddAuditRule(SemaphoreAuditRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.AddAuditRule(SemaphoreAuditRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "可以与之合并新规则的审核规则的搜索。 如果找不到之后，将添加新规则。"
  remarks: "AddAuditRule 方法搜索规则具有相同的用户或组作为`rule`。 如果找不到之后，`rule`添加。 如果找到匹配规则是中的标志`rule`合并到现有规则。"
  syntax:
    content: public void AddAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAuditRule
      description: "要添加的审核规则。 此规则指定的用户确定搜索。"
  overload: System.Security.AccessControl.SemaphoreSecurity.AddAuditRule*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  id: AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  nameWithType: SemaphoreSecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  fullName: System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "创建一个新的审核规则，指定该规则适用于审核的访问权限以及触发审计规则的结果的用户。"
  remarks: "创建审核规则的建议的方法是使用<xref:System.Security.AccessControl.SemaphoreAuditRule>类</xref:System.Security.AccessControl.SemaphoreAuditRule>的构造函数      1> [!NOTE]&1;> 虽然继承和传播标志对命名信号量无意义，则仍可以指定它们。 这不是建议，因为它不必要地增加复杂性进行维护的规则，例如通过干扰本来可以兼容的规则的组合。"
  syntax:
    content: public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);
    parameters:
    - id: identityReference
      type: System.Security.Principal.IdentityReference
      description: "<xref href=&quot;System.Security.Principal.IdentityReference&quot;> </xref>标识用户或组规则适用于。"
    - id: accessMask
      type: System.Int32
      description: "按位组合<xref href=&quot;System.Security.AccessControl.SemaphoreRights&quot;></xref>值指定的访问权限审核，强制转换为整数。"
    - id: isInherited
      type: System.Boolean
      description: "对于没有意义命名的等待句柄，因为它们没有层次结构。"
    - id: inheritanceFlags
      type: System.Security.AccessControl.InheritanceFlags
      description: "对于没有意义命名的等待句柄，因为它们没有层次结构。"
    - id: propagationFlags
      type: System.Security.AccessControl.PropagationFlags
      description: "对于没有意义命名的等待句柄，因为它们没有层次结构。"
    - id: flags
      type: System.Security.AccessControl.AuditFlags
      description: "按位组合<xref href=&quot;System.Security.AccessControl.AuditFlags&quot;></xref>指定是否要审核的成功访问、 失败的访问，或两者的值。"
    return:
      type: System.Security.AccessControl.AuditRule
      description: "A <xref href=&quot;System.Security.AccessControl.SemaphoreAuditRule&quot;> </xref>对象，表示指定的用户指定的审核规则。 该方法的返回类型是基类， <xref href=&quot;System.Security.AccessControl.AuditRule&quot;> </xref>，但返回的值可以安全地强制转换到派生的类。"
  overload: System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>accessMask</code><code>inheritanceFlags</code>， <code>propagationFlags</code>，或<code>flags</code>指定了一个无效值。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>identityReference</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或-<code>accessMask</code>为零。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>identityReference</code>既不属于类型<xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>，也不的类型，如<xref href=&quot;System.Security.Principal.NTAccount&quot;></xref>可以转换为类型<xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>。"
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.AuditRuleType
  id: AuditRuleType
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: AuditRuleType
  nameWithType: SemaphoreSecurity.AuditRuleType
  fullName: System.Security.AccessControl.SemaphoreSecurity.AuditRuleType
  type: Property
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "获取的类型<xref href=&quot;System.Security.AccessControl.SemaphoreSecurity&quot;></xref>类用于表示审核规则。"
  remarks: "派生自的类<xref:System.Security.AccessControl.ObjectSecurity>类替代<xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A>属性，并返回它们用于表示审核权限的类型。</xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> </xref:System.Security.AccessControl.ObjectSecurity> 当使用数组或包含多个类型的安全对象的集合时，使用此属性来确定要用于每个安全对象的正确的审核规则类型。"
  syntax:
    content: public override Type AuditRuleType { get; }
    return:
      type: System.Type
      description: "A<xref:System.Type>对象，表示<xref href=&quot;System.Security.AccessControl.SemaphoreAuditRule&quot;></xref>类</xref:System.Type>"
  overload: System.Security.AccessControl.SemaphoreSecurity.AuditRuleType*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  id: RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: RemoveAccessRule(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.RemoveAccessRule(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(SemaphoreAccessRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "搜索与同一用户的访问控制规则和<xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> （允许或拒绝） 与指定的规则，并具有兼容的继承和传播标志; 如果找到此类规则，指定的访问规则中包含的权限会从删除它。"
  remarks: "当前<xref:System.Security.AccessControl.SemaphoreSecurity>具有相同的用户和相同的规则，将会搜索<xref:System.Security.AccessControl.AccessControlType>值作为`rule`。</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.SemaphoreSecurity> 如果找到任何此类规则，不执行任何操作，并且该方法返回`false`。 如果找到匹配的规则，它们继承和兼容性标志将检查与中指定的标志的兼容性`rule`。 如果找到任何兼容的规则，不执行任何操作，并且该方法返回`false`。 如果找到具有兼容的标志的规则，则在指定的权限`rule`会从兼容的规则，并且该方法返回`true`。 如果`rule`指定不兼容的规则中包含的权限，根据这些权限不执行任何操作。 如果从兼容的规则中移除所有权限，将整个规则都删除从当前<xref:System.Security.AccessControl.SemaphoreSecurity>对象。</xref:System.Security.AccessControl.SemaphoreSecurity>      1> [!IMPORTANT]&1;> 虽然可以通过创建与指定为信号量的访问规则的继承和传播标志<xref:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory%2A>，这不推荐使用方法。</xref:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory%2A> 继承和传播对于没有任何意义命名信号量，并且它们使访问规则的维护更复杂。"
  example:
  - "The following code example demonstrates the use of the RemoveAccessRule method to remove rights from an <xref:System.Security.AccessControl.AccessControlType> rule in a <xref:System.Security.AccessControl.SemaphoreSecurity> object. It also shows that other rights in `rule` are ignored.  \n  \n The example creates a <xref:System.Security.AccessControl.SemaphoreSecurity> object and adds rules that allow and deny various rights for the current user. The rights allowed include <xref:System.Security.AccessControl.SemaphoreRights>, <xref:System.Security.AccessControl.SemaphoreRights>, and <xref:System.Security.AccessControl.SemaphoreRights>. The example then creates a new rule for the current user, including <xref:System.Security.AccessControl.SemaphoreRights> and <xref:System.Security.AccessControl.SemaphoreRights> rights, and uses that rule with the RemoveAccessRule method to remove <xref:System.Security.AccessControl.SemaphoreRights> from the <xref:System.Security.AccessControl.AccessControlType> rule in the <xref:System.Security.AccessControl.SemaphoreSecurity> object. The extraneous <xref:System.Security.AccessControl.SemaphoreRights> right in `rule` is ignored.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:System.Threading.Semaphore> object. Examples that attach security objects can be found in <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName> and <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-cs[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule#1](~/add/codesnippet/csharp/967006c5-d60e-4018-a570-_1.cs)]\n [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule#1](~/add/codesnippet/visualbasic/967006c5-d60e-4018-a570-_1.vb)]"
  syntax:
    content: public bool RemoveAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAccessRule
      description: "A <xref href=&quot;System.Security.AccessControl.SemaphoreAccessRule&quot;> </xref>指定的用户和<xref href=&quot;System.Security.AccessControl.AccessControlType&quot;></xref>搜索，以及一组继承和传播标志，用于匹配规则，如果找到，则必须是与兼容。 指定的权限删除兼容的规则，如果找到。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果找到兼容的规则;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)
  id: RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: RemoveAccessRuleAll(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.RemoveAccessRuleAll(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(SemaphoreAccessRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "搜索所有访问控制规则具有相同的用户和<xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> （允许或拒绝） 指定规则且，如果找到，则删除它们。"
  remarks: "当前<xref:System.Security.AccessControl.SemaphoreSecurity>对象，具有相同的用户和相同的规则将会搜索<xref:System.Security.AccessControl.AccessControlType>值作为`rule`。</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.SemaphoreSecurity> 指定的任何权限`rule`时执行此搜索将忽略。 如果不找到任何匹配的规则，不执行任何操作。"
  example:
  - "The following code example shows that the RemoveAccessRuleAll method removes all rules that match user and <xref:System.Security.AccessControl.AccessControlType>, ignoring rights.  \n  \n The example creates a <xref:System.Security.AccessControl.SemaphoreSecurity> object, adds rules that allow and deny various rights for the current user, and then merges additional rights into the <xref:System.Security.AccessControl.AccessControlType> rule. The example then creates a new rule that allows the current user to take ownership, and uses that rule to remove the <xref:System.Security.AccessControl.AccessControlType> rule from the <xref:System.Security.AccessControl.SemaphoreSecurity> object.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:System.Threading.Semaphore> object. Examples that attach security objects can be found in <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName> and <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll#1](~/add/codesnippet/visualbasic/0b2e6ab3-65bc-4eea-922e-_1.vb)]\n [!code-cs[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll#1](~/add/codesnippet/csharp/0b2e6ab3-65bc-4eea-922e-_1.cs)]"
  syntax:
    content: public void RemoveAccessRuleAll (System.Security.AccessControl.SemaphoreAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAccessRule
      description: "A <xref href=&quot;System.Security.AccessControl.SemaphoreAccessRule&quot;> </xref>指定的用户和<xref href=&quot;System.Security.AccessControl.AccessControlType&quot;></xref>搜索。 指定此规则的任何权限将被忽略。"
  overload: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)
  id: RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: RemoveAccessRuleSpecific(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.RemoveAccessRuleSpecific(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(SemaphoreAccessRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "搜索完全匹配所指定的访问控制规则的规则和，如果找到，则删除它。"
  remarks: "仅当完全匹配时，才移除规则`rule`中的所有详细信息，包括标志。 具有相同的用户的其他规则和<xref:System.Security.AccessControl.AccessControlType>不会受到影响。</xref:System.Security.AccessControl.AccessControlType>      1> [!IMPORTANT]&1;> 规则表示一个或多个基础访问控制项 (ACE)，和拆分或修改用户的访问安全性规则时，根据需要组合这些条目。 因此，一个规则可能不再存在时它已添加的特定形式，RemoveAccessRuleSpecific 方法不能在这种情况下删除它。"
  example:
  - "The following code example shows that the RemoveAccessRuleSpecific method requires an exact match in order to remove a rule, and that rules to allow and deny rights are independent of each other.  \n  \n The example creates a <xref:System.Security.AccessControl.SemaphoreSecurity> object, adds rules that allow and deny various rights for the current user, and then merges additional rights into the <xref:System.Security.AccessControl.AccessControlType> access rule. The example then passes the original <xref:System.Security.AccessControl.AccessControlType> rule to the RemoveAccessRuleSpecific method, and displays the results, showing that nothing is deleted. The example then constructs a rule that matches the <xref:System.Security.AccessControl.AccessControlType> rule in the <xref:System.Security.AccessControl.SemaphoreSecurity> object, and successfully uses the RemoveAccessRuleSpecific method to remove the rule.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:System.Threading.Semaphore> object. Examples that attach security objects can be found in <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName> and <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific#1](~/add/codesnippet/visualbasic/0797aedd-e0bb-444b-b25e-_1.vb)]\n [!code-cs[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific#1](~/add/codesnippet/csharp/0797aedd-e0bb-444b-b25e-_1.cs)]"
  syntax:
    content: public void RemoveAccessRuleSpecific (System.Security.AccessControl.SemaphoreAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAccessRule
      description: "<xref href=&quot;System.Security.AccessControl.SemaphoreAccessRule&quot;> </xref>删除。"
  overload: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  id: RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: RemoveAuditRule(SemaphoreAuditRule)
  nameWithType: SemaphoreSecurity.RemoveAuditRule(SemaphoreAuditRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(SemaphoreAuditRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "搜索与同一用户作为指定的规则，并具有兼容的继承和传播标志; 审核控制规则如果找到兼容的规则，则会从其删除指定的规则中包含的权限。"
  remarks: "当前<xref:System.Security.AccessControl.SemaphoreSecurity>搜索已为同一用户的审核规则`rule`。</xref:System.Security.AccessControl.SemaphoreSecurity> 如果找到任何此类规则，不执行任何操作，并且该方法返回`false`。 如果找到匹配的规则，它们继承和兼容性标志将检查与中指定的标志的兼容性`rule`。 如果找到任何兼容的规则，不执行任何操作，并且该方法返回`false`。 如果找到具有兼容的标志的规则，则在指定的权限`rule`会从兼容的规则，并且该方法返回`true`。 如果`rule`指定不兼容的规则中包含的权限，根据这些权限不执行任何操作。 如果从兼容的规则中移除所有权限，将整个规则都删除从当前<xref:System.Security.AccessControl.SemaphoreSecurity>对象。</xref:System.Security.AccessControl.SemaphoreSecurity>      1> [!IMPORTANT]&1;> 虽然可以通过创建与指定为信号量审核规则的继承和传播标志<xref:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory%2A>，这不推荐使用方法。</xref:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory%2A> 继承和传播对于没有任何意义命名信号量，并且它们使审核规则的维护更复杂。"
  syntax:
    content: public bool RemoveAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAuditRule
      description: "A <xref href=&quot;System.Security.AccessControl.SemaphoreAuditRule&quot;> </xref> ，它指定用户来进行搜索和一组继承和传播标志匹配规则，如果找到，则必须是与兼容。 指定的权限删除兼容的规则，如果找到。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果找到兼容的规则;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll(System.Security.AccessControl.SemaphoreAuditRule)
  id: RemoveAuditRuleAll(System.Security.AccessControl.SemaphoreAuditRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: RemoveAuditRuleAll(SemaphoreAuditRule)
  nameWithType: SemaphoreSecurity.RemoveAuditRuleAll(SemaphoreAuditRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll(SemaphoreAuditRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "搜索所有审核规则与同一用户与指定的规则，如果找到，将删除它们。"
  remarks: "当前<xref:System.Security.AccessControl.SemaphoreSecurity>会为使用相同用户作为的审核规则搜索`rule`。</xref:System.Security.AccessControl.SemaphoreSecurity> 指定的任何权限`rule`时执行此搜索将忽略。 将删除所有匹配规则。 如果不找到任何匹配的规则，不执行任何操作。"
  syntax:
    content: public void RemoveAuditRuleAll (System.Security.AccessControl.SemaphoreAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAuditRule
      description: "A <xref href=&quot;System.Security.AccessControl.SemaphoreAuditRule&quot;> </xref> ，指定要搜索的用户。 指定此规则的任何权限将被忽略。"
  overload: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.SemaphoreAuditRule)
  id: RemoveAuditRuleSpecific(System.Security.AccessControl.SemaphoreAuditRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: RemoveAuditRuleSpecific(SemaphoreAuditRule)
  nameWithType: SemaphoreSecurity.RemoveAuditRuleSpecific(SemaphoreAuditRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific(SemaphoreAuditRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "搜索完全匹配所指定的审核规则的规则和，如果找到，则删除它。"
  remarks: "仅当完全匹配时，才移除规则`rule`中的所有详细信息，包括标志。 不会影响同一用户其他审核规则。      1> [!IMPORTANT]&1;> 规则表示一个或多个基础访问控制项 (ACE)，和拆分或修改用户的审核安全规则时，根据需要组合这些条目。 因此，一个规则可能不再存在时它已添加的特定形式，RemoveAuditRuleSpecific 方法不能在这种情况下删除它。"
  syntax:
    content: public void RemoveAuditRuleSpecific (System.Security.AccessControl.SemaphoreAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAuditRule
      description: "<xref href=&quot;System.Security.AccessControl.SemaphoreAuditRule&quot;> </xref>删除。"
  overload: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  id: ResetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: ResetAccessRule(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.ResetAccessRule(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(SemaphoreAccessRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "移除带有相同用户作为指定的规则，而不考虑的所有访问控制规则<xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref>，然后将添加指定的规则。"
  remarks: "如果没有指定的规则，与匹配的用户的访问规则`rule`添加。"
  example:
  - "The following code example shows how the ResetAccessRule method replaces all rules for the matching user with the rule specified for the match.  \n  \n The example creates a <xref:System.Security.AccessControl.SemaphoreSecurity> object and adds rules that allow and deny various rights for the current user. The example then creates a new rule that allows the current user full control, and uses the ResetAccessRule method to replace both of the existing rules with the new rule.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:System.Threading.Semaphore> object. Examples that attach security objects can be found in <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName> and <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-cs[System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule#1](~/add/codesnippet/csharp/950b9d2b-d0bb-443e-8790-_1.cs)]\n [!code-vb[System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule#1](~/add/codesnippet/visualbasic/950b9d2b-d0bb-443e-8790-_1.vb)]"
  syntax:
    content: public void ResetAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAccessRule
      description: "The <xref href=&quot;System.Security.AccessControl.SemaphoreAccessRule&quot;></xref> to add. 此规则指定的用户确定要移除之前添加此规则的规则。"
  overload: System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  id: SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: SetAccessRule(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.SetAccessRule(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(SemaphoreAccessRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "移除带有相同的用户的所有访问控制规则和<xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> （允许或拒绝） 与指定的规则，然后将添加指定的规则。"
  remarks: "如果指定的规则具有<xref:System.Security.AccessControl.AccessControlType>，此方法的效果是移除所有<xref:System.Security.AccessControl.AccessControlType>对于指定的用户，并将它们替换为指定的规则的规则。</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.AccessControlType> 如果指定的规则具有<xref:System.Security.AccessControl.AccessControlType>，所有<xref:System.Security.AccessControl.AccessControlType>规则指定的用户替换与指定的规则。</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.AccessControlType>       如果没有规则的用户和<xref:System.Security.AccessControl.AccessControlType>匹配指定的规则，`rule`添加。</xref:System.Security.AccessControl.AccessControlType>"
  example:
  - "The following code example shows how the SetAccessRule method removes all rules that match both the user and the <xref:System.Security.AccessControl.AccessControlType> of `rule`, replacing them with `rule`.  \n  \n The example creates a <xref:System.Security.AccessControl.SemaphoreSecurity> object and adds rules that allow and deny various rights for the current user. The example then creates a new rule that allows the current user full control, and uses the SetAccessRule method to replace the existing Allow rule with the new rule. The rule that denies access is not affected.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:System.Threading.Semaphore> object. Examples that attach security objects can be found in <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName> and <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-vb[System.Security.AccessControl.SemaphoreSecurity.SetAccessRule#1](~/add/codesnippet/visualbasic/8a133971-d359-43dd-87ab-_1.vb)]\n [!code-cs[System.Security.AccessControl.SemaphoreSecurity.SetAccessRule#1](~/add/codesnippet/csharp/8a133971-d359-43dd-87ab-_1.cs)]"
  syntax:
    content: public void SetAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAccessRule
      description: "The <xref href=&quot;System.Security.AccessControl.SemaphoreAccessRule&quot;></xref> to add. 用户和<xref href=&quot;System.Security.AccessControl.AccessControlType&quot;></xref>此规则确定要移除之前添加此规则的规则。"
  overload: System.Security.AccessControl.SemaphoreSecurity.SetAccessRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.SetAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  id: SetAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: SetAuditRule(SemaphoreAuditRule)
  nameWithType: SemaphoreSecurity.SetAuditRule(SemaphoreAuditRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.SetAuditRule(SemaphoreAuditRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "移除所有审核规则与同一用户作为指定的规则，而不考虑<xref href=&quot;System.Security.AccessControl.AuditFlags&quot;></xref>值，并将指定的规则。"
  remarks: "如果没有指定的规则，与匹配的用户的审核规则`rule`添加。"
  syntax:
    content: public void SetAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAuditRule
      description: "The <xref href=&quot;System.Security.AccessControl.SemaphoreAuditRule&quot;></xref> to add. 此规则指定的用户确定要移除之前添加此规则的规则。"
  overload: System.Security.AccessControl.SemaphoreSecurity.SetAuditRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
references:
- uid: System.Security.AccessControl.NativeObjectSecurity
  isExternal: false
  name: System.Security.AccessControl.NativeObjectSecurity
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Security.AccessControl.SemaphoreSecurity.#ctor
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: SemaphoreSecurity()
  nameWithType: SemaphoreSecurity.SemaphoreSecurity()
  fullName: System.Security.AccessControl.SemaphoreSecurity.SemaphoreSecurity()
- uid: System.Security.AccessControl.SemaphoreSecurity.#ctor(System.String,System.Security.AccessControl.AccessControlSections)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: SemaphoreSecurity(String,AccessControlSections)
  nameWithType: SemaphoreSecurity.SemaphoreSecurity(String,AccessControlSections)
  fullName: System.Security.AccessControl.SemaphoreSecurity.SemaphoreSecurity(String,AccessControlSections)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Security.AccessControl.AccessControlSections
  parent: System.Security.AccessControl
  isExternal: false
  name: AccessControlSections
  nameWithType: AccessControlSections
  fullName: System.Security.AccessControl.AccessControlSections
- uid: System.Security.AccessControl.SemaphoreSecurity.AccessRightType
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AccessRightType
  nameWithType: SemaphoreSecurity.AccessRightType
  fullName: System.Security.AccessControl.SemaphoreSecurity.AccessRightType
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  nameWithType: SemaphoreSecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  fullName: System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
- uid: System.Security.AccessControl.AccessRule
  parent: System.Security.AccessControl
  isExternal: false
  name: AccessRule
  nameWithType: AccessRule
  fullName: System.Security.AccessControl.AccessRule
- uid: System.Security.Principal.IdentityReference
  parent: System.Security.Principal
  isExternal: false
  name: IdentityReference
  nameWithType: IdentityReference
  fullName: System.Security.Principal.IdentityReference
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Security.AccessControl.InheritanceFlags
  parent: System.Security.AccessControl
  isExternal: false
  name: InheritanceFlags
  nameWithType: InheritanceFlags
  fullName: System.Security.AccessControl.InheritanceFlags
- uid: System.Security.AccessControl.PropagationFlags
  parent: System.Security.AccessControl
  isExternal: false
  name: PropagationFlags
  nameWithType: PropagationFlags
  fullName: System.Security.AccessControl.PropagationFlags
- uid: System.Security.AccessControl.AccessControlType
  parent: System.Security.AccessControl
  isExternal: false
  name: AccessControlType
  nameWithType: AccessControlType
  fullName: System.Security.AccessControl.AccessControlType
- uid: System.Security.AccessControl.SemaphoreSecurity.AccessRuleType
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AccessRuleType
  nameWithType: SemaphoreSecurity.AccessRuleType
  fullName: System.Security.AccessControl.SemaphoreSecurity.AccessRuleType
- uid: System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AddAccessRule(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.AddAccessRule(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(SemaphoreAccessRule)
- uid: System.Security.AccessControl.SemaphoreAccessRule
  parent: System.Security.AccessControl
  isExternal: false
  name: SemaphoreAccessRule
  nameWithType: SemaphoreAccessRule
  fullName: System.Security.AccessControl.SemaphoreAccessRule
- uid: System.Security.AccessControl.SemaphoreSecurity.AddAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AddAuditRule(SemaphoreAuditRule)
  nameWithType: SemaphoreSecurity.AddAuditRule(SemaphoreAuditRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.AddAuditRule(SemaphoreAuditRule)
- uid: System.Security.AccessControl.SemaphoreAuditRule
  parent: System.Security.AccessControl
  isExternal: false
  name: SemaphoreAuditRule
  nameWithType: SemaphoreAuditRule
  fullName: System.Security.AccessControl.SemaphoreAuditRule
- uid: System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  nameWithType: SemaphoreSecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  fullName: System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
- uid: System.Security.AccessControl.AuditRule
  parent: System.Security.AccessControl
  isExternal: false
  name: AuditRule
  nameWithType: AuditRule
  fullName: System.Security.AccessControl.AuditRule
- uid: System.Security.AccessControl.AuditFlags
  parent: System.Security.AccessControl
  isExternal: false
  name: AuditFlags
  nameWithType: AuditFlags
  fullName: System.Security.AccessControl.AuditFlags
- uid: System.Security.AccessControl.SemaphoreSecurity.AuditRuleType
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AuditRuleType
  nameWithType: SemaphoreSecurity.AuditRuleType
  fullName: System.Security.AccessControl.SemaphoreSecurity.AuditRuleType
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAccessRule(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.RemoveAccessRule(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(SemaphoreAccessRule)
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAccessRuleAll(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.RemoveAccessRuleAll(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(SemaphoreAccessRule)
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAccessRuleSpecific(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.RemoveAccessRuleSpecific(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(SemaphoreAccessRule)
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAuditRule(SemaphoreAuditRule)
  nameWithType: SemaphoreSecurity.RemoveAuditRule(SemaphoreAuditRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(SemaphoreAuditRule)
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll(System.Security.AccessControl.SemaphoreAuditRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAuditRuleAll(SemaphoreAuditRule)
  nameWithType: SemaphoreSecurity.RemoveAuditRuleAll(SemaphoreAuditRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll(SemaphoreAuditRule)
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.SemaphoreAuditRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAuditRuleSpecific(SemaphoreAuditRule)
  nameWithType: SemaphoreSecurity.RemoveAuditRuleSpecific(SemaphoreAuditRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific(SemaphoreAuditRule)
- uid: System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: ResetAccessRule(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.ResetAccessRule(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(SemaphoreAccessRule)
- uid: System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: SetAccessRule(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.SetAccessRule(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(SemaphoreAccessRule)
- uid: System.Security.AccessControl.SemaphoreSecurity.SetAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: SetAuditRule(SemaphoreAuditRule)
  nameWithType: SemaphoreSecurity.SetAuditRule(SemaphoreAuditRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.SetAuditRule(SemaphoreAuditRule)
- uid: System.Security.AccessControl.SemaphoreSecurity.#ctor*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: SemaphoreSecurity
  nameWithType: SemaphoreSecurity.SemaphoreSecurity
- uid: System.Security.AccessControl.SemaphoreSecurity.AccessRightType*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AccessRightType
  nameWithType: SemaphoreSecurity.AccessRightType
- uid: System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AccessRuleFactory
  nameWithType: SemaphoreSecurity.AccessRuleFactory
- uid: System.Security.AccessControl.SemaphoreSecurity.AccessRuleType*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AccessRuleType
  nameWithType: SemaphoreSecurity.AccessRuleType
- uid: System.Security.AccessControl.SemaphoreSecurity.AddAccessRule*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AddAccessRule
  nameWithType: SemaphoreSecurity.AddAccessRule
- uid: System.Security.AccessControl.SemaphoreSecurity.AddAuditRule*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AddAuditRule
  nameWithType: SemaphoreSecurity.AddAuditRule
- uid: System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AuditRuleFactory
  nameWithType: SemaphoreSecurity.AuditRuleFactory
- uid: System.Security.AccessControl.SemaphoreSecurity.AuditRuleType*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AuditRuleType
  nameWithType: SemaphoreSecurity.AuditRuleType
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAccessRule
  nameWithType: SemaphoreSecurity.RemoveAccessRule
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAccessRuleAll
  nameWithType: SemaphoreSecurity.RemoveAccessRuleAll
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAccessRuleSpecific
  nameWithType: SemaphoreSecurity.RemoveAccessRuleSpecific
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAuditRule
  nameWithType: SemaphoreSecurity.RemoveAuditRule
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAuditRuleAll
  nameWithType: SemaphoreSecurity.RemoveAuditRuleAll
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAuditRuleSpecific
  nameWithType: SemaphoreSecurity.RemoveAuditRuleSpecific
- uid: System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: ResetAccessRule
  nameWithType: SemaphoreSecurity.ResetAccessRule
- uid: System.Security.AccessControl.SemaphoreSecurity.SetAccessRule*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: SetAccessRule
  nameWithType: SemaphoreSecurity.SetAccessRule
- uid: System.Security.AccessControl.SemaphoreSecurity.SetAuditRule*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: SetAuditRule
  nameWithType: SemaphoreSecurity.SetAuditRule
