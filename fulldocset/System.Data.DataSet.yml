### YamlMime:ManagedReference
items:
- uid: System.Data.DataSet
  id: DataSet
  children:
  - System.Data.DataSet.#ctor
  - System.Data.DataSet.#ctor(System.String)
  - System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)
  - System.Data.DataSet.AcceptChanges
  - System.Data.DataSet.BeginInit
  - System.Data.DataSet.CaseSensitive
  - System.Data.DataSet.Clear
  - System.Data.DataSet.Clone
  - System.Data.DataSet.Copy
  - System.Data.DataSet.CreateDataReader
  - System.Data.DataSet.CreateDataReader(System.Data.DataTable[])
  - System.Data.DataSet.DataSetName
  - System.Data.DataSet.DefaultViewManager
  - System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)
  - System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Data.DataSet.EndInit
  - System.Data.DataSet.EnforceConstraints
  - System.Data.DataSet.ExtendedProperties
  - System.Data.DataSet.GetChanges
  - System.Data.DataSet.GetChanges(System.Data.DataRowState)
  - System.Data.DataSet.GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)
  - System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Data.DataSet.GetSchemaSerializable
  - System.Data.DataSet.GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Data.DataSet.GetXml
  - System.Data.DataSet.GetXmlSchema
  - System.Data.DataSet.HasChanges
  - System.Data.DataSet.HasChanges(System.Data.DataRowState)
  - System.Data.DataSet.HasErrors
  - System.Data.DataSet.InferXmlSchema(System.IO.Stream,System.String[])
  - System.Data.DataSet.InferXmlSchema(System.IO.TextReader,System.String[])
  - System.Data.DataSet.InferXmlSchema(System.String,System.String[])
  - System.Data.DataSet.InferXmlSchema(System.Xml.XmlReader,System.String[])
  - System.Data.DataSet.Initialized
  - System.Data.DataSet.InitializeDerivedDataSet
  - System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Data.DataSet.IsInitialized
  - System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])
  - System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])
  - System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])
  - System.Data.DataSet.Locale
  - System.Data.DataSet.Merge(System.Data.DataRow[])
  - System.Data.DataSet.Merge(System.Data.DataSet)
  - System.Data.DataSet.Merge(System.Data.DataTable)
  - System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)
  - System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)
  - System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)
  - System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)
  - System.Data.DataSet.MergeFailed
  - System.Data.DataSet.Namespace
  - System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)
  - System.Data.DataSet.OnRemoveRelation(System.Data.DataRelation)
  - System.Data.DataSet.OnRemoveTable(System.Data.DataTable)
  - System.Data.DataSet.Prefix
  - System.Data.DataSet.RaisePropertyChanging(System.String)
  - System.Data.DataSet.ReadXml(System.IO.Stream)
  - System.Data.DataSet.ReadXml(System.IO.TextReader)
  - System.Data.DataSet.ReadXml(System.String)
  - System.Data.DataSet.ReadXml(System.Xml.XmlReader)
  - System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)
  - System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)
  - System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)
  - System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)
  - System.Data.DataSet.ReadXmlSchema(System.IO.Stream)
  - System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)
  - System.Data.DataSet.ReadXmlSchema(System.String)
  - System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)
  - System.Data.DataSet.ReadXmlSerializable(System.Xml.XmlReader)
  - System.Data.DataSet.RejectChanges
  - System.Data.DataSet.Relations
  - System.Data.DataSet.RemotingFormat
  - System.Data.DataSet.Reset
  - System.Data.DataSet.SchemaSerializationMode
  - System.Data.DataSet.ShouldSerializeRelations
  - System.Data.DataSet.ShouldSerializeTables
  - System.Data.DataSet.Site
  - System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection
  - System.Data.DataSet.System#ComponentModel#IListSource#GetList
  - System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema
  - System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
  - System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
  - System.Data.DataSet.Tables
  - System.Data.DataSet.WriteXml(System.IO.Stream)
  - System.Data.DataSet.WriteXml(System.IO.TextWriter)
  - System.Data.DataSet.WriteXml(System.String)
  - System.Data.DataSet.WriteXml(System.Xml.XmlWriter)
  - System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)
  - System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)
  - System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)
  - System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)
  - System.Data.DataSet.WriteXmlSchema(System.IO.Stream)
  - System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)
  - System.Data.DataSet.WriteXmlSchema(System.String)
  - System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)
  - System.Data.DataSet.WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})
  - System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})
  - System.Data.DataSet.WriteXmlSchema(System.String,System.Converter{System.Type,System.String})
  - System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})
  langs:
  - csharp
  name: DataSet
  nameWithType: DataSet
  fullName: System.Data.DataSet
  type: Class
  summary: "表示内存中缓存的数据。"
  remarks: "数据集，这是从数据源检索数据的内存中缓存，是的 ADO.NET 体系结构的主要组件。 数据集的集合组成<xref:System.Data.DataTable>对象，你可以将互相关联起来与<xref:System.Data.DataRelation>对象。</xref:System.Data.DataRelation> </xref:System.Data.DataTable> 你可以通过使用来强制数据集中的数据完整性<xref:System.Data.UniqueConstraint>和<xref:System.Data.ForeignKeyConstraint>对象。</xref:System.Data.ForeignKeyConstraint> </xref:System.Data.UniqueConstraint> 有关使用数据集对象的更多详细信息，请参阅[数据集、 数据表和数据视图](~/add/includes/ajax-current-ext-md.md)。       而<xref:System.Data.DataTable>对象包含的数据，<xref:System.Data.DataRelationCollection>使您可以通过导航表的层次结构。</xref:System.Data.DataRelationCollection> </xref:System.Data.DataTable> 这些表包含在<xref:System.Data.DataTableCollection>通过访问<xref:System.Data.DataSet.Tables%2A>属性。</xref:System.Data.DataSet.Tables%2A> </xref:System.Data.DataTableCollection> 在访问时<xref:System.Data.DataTable>对象，请注意，它们是有条件地区分大小写。</xref:System.Data.DataTable> 例如，如果一个<xref:System.Data.DataTable>名为&quot;mydatatable&quot;和另一个名为&quot;Mydatatable&quot;，用于搜索表中的一个的字符串将被视为区分大小写。</xref:System.Data.DataTable> 但是，如果&quot;mydatatable&quot;存在，并且&quot;Mydatatable&quot;不，搜索字符串将被视为区分。 有关使用<xref:System.Data.DataTable>对象，请参阅[创建数据表](~/add/includes/ajax-current-ext-md.md)。</xref:System.Data.DataTable>       数据集可以读取和写入 XML 文档的数据和架构。 数据和架构可以然后可跨 HTTP 传输和使用由任何应用程序，在 XML 启用任何平台上。 你可以将架构保存为 XML 架构与<xref:System.Data.DataSet.WriteXmlSchema%2A>方法，、 架构和数据可以保存使用<xref:System.Data.DataSet.WriteXml%2A>方法。</xref:System.Data.DataSet.WriteXml%2A> </xref:System.Data.DataSet.WriteXmlSchema%2A> 若要读取包含架构和数据的 XML 文档，使用<xref:System.Data.DataSet.ReadXml%2A>方法。</xref:System.Data.DataSet.ReadXml%2A>       在典型的多个层实现中，更新原始数据的步骤用于创建和刷新数据集，并在轮次，受到︰ 1。  生成和每次<xref:System.Data.DataTable>使用一种<xref:System.Data.Common.DataAdapter>。</xref:System.Data.Common.DataAdapter>的数据源中的数据集中的数据</xref:System.Data.DataTable>填充      2.  更改在单个数据<xref:System.Data.DataTable>通过添加、 更新或删除的对象<xref:System.Data.DataRow>对象。</xref:System.Data.DataRow> </xref:System.Data.DataTable>      3.  调用<xref:System.Data.DataSet.GetChanges%2A>方法创建的功能仅对数据的更改的第二个数据集。</xref:System.Data.DataSet.GetChanges%2A>      4.  调用<xref:System.Data.Common.DataAdapter.Update%2A>方法<xref:System.Data.Common.DataAdapter>，将第二个数据集作为参数传递。</xref:System.Data.Common.DataAdapter> </xref:System.Data.Common.DataAdapter.Update%2A>      5.  调用<xref:System.Data.DataSet.Merge%2A>方法中的第二个数据集的更改合并到第一个。</xref:System.Data.DataSet.Merge%2A>      6.  调用<xref:System.Data.DataSet.AcceptChanges%2A>对数据集。</xref:System.Data.DataSet.AcceptChanges%2A> 此外，调用<xref:System.Data.DataSet.RejectChanges%2A>可取消更改。</xref:System.Data.DataSet.RejectChanges%2A>      1> [!NOTE]&1;> 的数据集和<xref:System.Data.DataTable>对象继承自<xref:System.ComponentModel.MarshalByValueComponent>，并且支持<xref:System.Runtime.Serialization.ISerializable>以进行远程处理的接口。</xref:System.Runtime.Serialization.ISerializable> </xref:System.ComponentModel.MarshalByValueComponent> </xref:System.Data.DataTable> 这些是唯一可远程处理的 ADO.NET 对象。      1> [!NOTE]&1;> 由于终结器已取消数据集中，垃圾回收器中，不终止从数据集继承的类。 派生的类可以调用<xref:System.GC.ReRegisterForFinalize%2A>其构造函数，以允许通过垃圾回收器来完成类中的方法。</xref:System.GC.ReRegisterForFinalize%2A>"
  example:
  - "The following example consists of several methods that, combined, create and fill a DataSet from the **Northwind** database.  \n  \n [!code-cs[Classic WebData DataSet Example#1](~/add/codesnippet/csharp/t-system.data.dataset_1.cs)]\n [!code-vb[Classic WebData DataSet Example#1](~/add/codesnippet/visualbasic/t-system.data.dataset_1.vb)]"
  syntax:
    content: >-
      [System.ComponentModel.DefaultProperty("DataSetName")]

      [System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      [System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      [System.Xml.Serialization.XmlRoot("DataSet")]

      [System.Xml.Serialization.XmlSchemaProvider("GetDataSetSchema")]

      public class DataSet : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable
  inheritance:
  - System.Object
  - System.ComponentModel.MarshalByValueComponent
  implements:
  - System.ComponentModel.IListSource
  - System.ComponentModel.ISupportInitializeNotification
  - System.Runtime.Serialization.ISerializable
  - System.Xml.Serialization.IXmlSerializable
  inheritedMembers:
  - System.ComponentModel.MarshalByValueComponent.Container
  - System.ComponentModel.MarshalByValueComponent.DesignMode
  - System.ComponentModel.MarshalByValueComponent.Dispose
  - System.ComponentModel.MarshalByValueComponent.Dispose(System.Boolean)
  - System.ComponentModel.MarshalByValueComponent.Disposed
  - System.ComponentModel.MarshalByValueComponent.Events
  - System.ComponentModel.MarshalByValueComponent.GetService(System.Type)
  - System.ComponentModel.MarshalByValueComponent.ToString
  platform:
  - net462
- uid: System.Data.DataSet.#ctor
  id: '#ctor'
  parent: System.Data.DataSet
  langs:
  - csharp
  name: DataSet()
  nameWithType: DataSet.DataSet()
  fullName: System.Data.DataSet.DataSet()
  type: Constructor
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "初始化的新实例<xref href=&quot;System.Data.DataSet&quot;></xref>类。"
  remarks: "此实现的<xref:System.Data.DataSet>构造函数不采用任何参数，并创建一个默认名称，&quot;NewDataSet，&quot;的新实例。</xref:System.Data.DataSet>       名称<xref:System.Data.DataSet>需确保的 XML 表示形式<xref:System.Data.DataSet>始终有文档元素，它是架构定义中的最高级别的元素的名称。</xref:System.Data.DataSet> </xref:System.Data.DataSet>"
  example:
  - "The following example creates a new <xref:System.Data.DataSet>, and adds two <xref:System.Data.DataTable> objects to it.  \n  \n [!code-vb[Classic WebData DataSet.DataSet Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.sh_1_1.vb)]"
  syntax:
    content: public DataSet ();
    parameters: []
  overload: System.Data.DataSet.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.#ctor(System.String)
  id: '#ctor(System.String)'
  parent: System.Data.DataSet
  langs:
  - csharp
  name: DataSet(String)
  nameWithType: DataSet.DataSet(String)
  fullName: System.Data.DataSet.DataSet(String)
  type: Constructor
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "初始化的新实例<xref href=&quot;System.Data.DataSet&quot;></xref>具有给定名称的类。"
  remarks: "名称<xref:System.Data.DataSet>需确保的 XML 表示形式<xref:System.Data.DataSet>始终有文档元素，它是架构定义中的最高级别的元素的名称。</xref:System.Data.DataSet> </xref:System.Data.DataSet>"
  example:
  - "The following example creates a new <xref:System.Data.DataSet>, to which two <xref:System.Data.DataTable> objects are added.  \n  \n [!code-vb[Classic WebData DataSet.DataSet1 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.sh_0_1.vb)]"
  syntax:
    content: public DataSet (string dataSetName);
    parameters:
    - id: dataSetName
      type: System.String
      description: "名称<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  overload: System.Data.DataSet.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: '#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)'
  parent: System.Data.DataSet
  langs:
  - csharp
  name: DataSet(SerializationInfo,StreamingContext)
  nameWithType: DataSet.DataSet(SerializationInfo,StreamingContext)
  fullName: System.Data.DataSet.DataSet(SerializationInfo,StreamingContext)
  type: Constructor
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "初始化的新实例<xref href=&quot;System.Data.DataSet&quot;></xref>具有给定序列化信息和上下文的类。"
  syntax:
    content: protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "要序列化或反序列化对象所需的数据。"
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "源和给定的序列化流的目标。"
  overload: System.Data.DataSet.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)
  id: '#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)'
  parent: System.Data.DataSet
  langs:
  - csharp
  name: DataSet(SerializationInfo,StreamingContext,Boolean)
  nameWithType: DataSet.DataSet(SerializationInfo,StreamingContext,Boolean)
  fullName: System.Data.DataSet.DataSet(SerializationInfo,StreamingContext,Boolean)
  type: Constructor
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "初始化的新实例<xref href=&quot;System.Data.DataSet&quot;></xref>类。"
  syntax:
    content: protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context, bool ConstructSchema);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "<xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref>对象。"
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "<xref:System.Runtime.Serialization.StreamingContext>对象。</xref:System.Runtime.Serialization.StreamingContext>"
    - id: ConstructSchema
      type: System.Boolean
      description: "布尔值。"
  overload: System.Data.DataSet.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.AcceptChanges
  id: AcceptChanges
  parent: System.Data.DataSet
  langs:
  - csharp
  name: AcceptChanges()
  nameWithType: DataSet.AcceptChanges()
  fullName: System.Data.DataSet.AcceptChanges()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "对此进行的所有更改都提交<xref href=&quot;System.Data.DataSet&quot;></xref>自加载后或自从上次调用 AcceptChanges。"
  remarks: "同时<xref:System.Data.DataRow>和<xref:System.Data.DataTable>类具有 AcceptChanges 方法。</xref:System.Data.DataTable> </xref:System.Data.DataRow> 调用<xref:System.Data.DataTable.AcceptChanges%2A>在<xref:System.Data.DataTable>级别原因<xref:System.Data.DataRow.AcceptChanges%2A>方法为每个<xref:System.Data.DataRow>调用。</xref:System.Data.DataRow> </xref:System.Data.DataRow.AcceptChanges%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.AcceptChanges%2A> 同样，<xref:System.Data.DataSet><xref:System.Data.DataTable.AcceptChanges%2A>不能对<xref:System.Data.DataSet>.</xref:System.Data.DataSet>中每个表调用</xref:System.Data.DataTable.AcceptChanges%2A>，则会</xref:System.Data.DataSet>在调用 AcceptChanges 在这种方式，你必须可以从该处调用该方法的多个级别。 调用的 AcceptChanges<xref:System.Data.DataSet>使您能够针对所有附属对象 （例如，表和行） 的一个调用调用方法。</xref:System.Data.DataSet>       当调用`AcceptChanges`上`DataSet`、 任何<xref:System.Data.DataRow>仍处于编辑模式的对象已成功结束其编辑。</xref:System.Data.DataRow> 每个<xref:System.Data.DataRow><xref:System.Data.DataRow.RowState%2A>属性也会更改;`Added`和`Modified`行都变为`Unchanged`，和`Deleted`已删除的行。 </xref:System.Data.DataRow.RowState%2A></xref:System.Data.DataRow>       如果`DataSet`包含<xref:System.Data.ForeignKeyConstraint>对象，则调用`AcceptChanges`方法也会导致<xref:System.Data.ForeignKeyConstraint.AcceptRejectRule%2A>强制执行。</xref:System.Data.ForeignKeyConstraint.AcceptRejectRule%2A> </xref:System.Data.ForeignKeyConstraint>      1> [!NOTE]  >   `AcceptChanges`和`RejectChanges`仅适用于`DataRow`相关更改 （即，添加、 删除、 删除和修改）。 它们不是适用于架构或结构上的更改。   >> 调用 AcceptChanges 不会返回到数据源复制这些更改，如果已使用 DataAdapter 填充数据集。 在这种情况下，调用<xref:System.Data.Common.DataAdapter.Update%2A>相反。</xref:System.Data.Common.DataAdapter.Update%2A> 请参阅[使用 Dataadapter 更新数据源](http://msdn.microsoft.com/library/33y2221y.aspx)有关详细信息。"
  example:
  - "The following example adds a <xref:System.Data.DataRow> to a <xref:System.Data.DataTable> in a <xref:System.Data.DataSet>. The AcceptChanges method is then called on the <xref:System.Data.DataSet>, which cascades to all <xref:System.Data.DataTable> objects that it contains.  \n  \n [!code-vb[Classic WebData DataSet.AcceptChanges#1](~/add/codesnippet/visualbasic/m-system.data.dataset.ac_1.vb)]\n [!code-cs[Classic WebData DataSet.AcceptChanges#1](~/add/codesnippet/csharp/m-system.data.dataset.ac_1.cs)]"
  syntax:
    content: public void AcceptChanges ();
    parameters: []
  overload: System.Data.DataSet.AcceptChanges*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.BeginInit
  id: BeginInit
  parent: System.Data.DataSet
  langs:
  - csharp
  name: BeginInit()
  nameWithType: DataSet.BeginInit()
  fullName: System.Data.DataSet.BeginInit()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "开始初始化<xref href=&quot;System.Data.DataSet&quot;></xref>窗体上使用或由另一个组件。 初始化发生在运行时。"
  remarks: "Visual Studio.NET 设计环境使用此方法来启动窗体上使用或由另一个组件的组件的初始化。 <xref:System.Data.DataSet.EndInit%2A>方法初始化已结束。</xref:System.Data.DataSet.EndInit%2A> 使用 BeginInit 和<xref:System.Data.DataSet.EndInit%2A>方法阻止控件完全初始化之前使用。</xref:System.Data.DataSet.EndInit%2A>"
  syntax:
    content: public void BeginInit ();
    parameters: []
  overload: System.Data.DataSet.BeginInit*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.CaseSensitive
  id: CaseSensitive
  parent: System.Data.DataSet
  langs:
  - csharp
  name: CaseSensitive
  nameWithType: DataSet.CaseSensitive
  fullName: System.Data.DataSet.CaseSensitive
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "获取或设置一个值，该值指示是否中的字符串比较<xref href=&quot;System.Data.DataTable&quot;></xref>对象是区分大小写。"
  remarks: "CaseSensitive 属性会影响排序、 搜索和筛选操作执行的方式上每个<xref:System.Data.DataTable>对象中包含<xref:System.Data.DataSet>时使用<xref:System.Data.DataTable.Select%2A>方法。</xref:System.Data.DataTable.Select%2A> </xref:System.Data.DataSet> </xref:System.Data.DataTable>       默认情况下，设置 CaseSensitive 属性<xref:System.Data.DataSet>还设置<xref:System.Data.DataTable.CaseSensitive%2A>的每个关联的属性<xref:System.Data.DataTable>为相同的值。</xref:System.Data.DataTable> </xref:System.Data.DataTable.CaseSensitive%2A> </xref:System.Data.DataSet>"
  example:
  - "The following example toggles the CaseSensitive property.  \n  \n [!code-vb[Classic WebData DataSet.CaseSensitive Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.ca_1.vb)]"
  syntax:
    content: public bool CaseSensitive { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果字符串比较是区分大小写;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.DataSet.CaseSensitive*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Clear
  id: Clear
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Clear()
  nameWithType: DataSet.Clear()
  fullName: System.Data.DataSet.Clear()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "清除<xref href=&quot;System.Data.DataSet&quot;></xref>的所有表中删除所有行的任何数据。"
  remarks: "如果<xref:System.Data.DataSet>绑定到某个<xref:System.Xml.XmlDataDocument>、 调用清除或<xref:System.Data.DataTable.Clear%2A?displayProperty=fullName>引发<xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.Data.DataTable.Clear%2A?displayProperty=fullName> </xref:System.Xml.XmlDataDocument> </xref:System.Data.DataSet> 若要避免这种情况下，遍历每个表，一次移除每一行。"
  example:
  - "The following example clears the <xref:System.Data.DataSet> of all rows in all tables.  \n  \n [!code-vb[Classic WebData DataSet.Clear Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.cl_1_1.vb)]\n [!code-cs[Classic WebData DataSet.Clear Example#1](~/add/codesnippet/csharp/m-system.data.dataset.cl_1_1.cs)]"
  syntax:
    content: public void Clear ();
    parameters: []
  overload: System.Data.DataSet.Clear*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Clone
  id: Clone
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Clone()
  nameWithType: DataSet.Clone()
  fullName: System.Data.DataSet.Clone()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "将复制的结构<xref href=&quot;System.Data.DataSet&quot;> </xref>，包括所有<xref href=&quot;System.Data.DataTable&quot;></xref>架构、 关系和约束。 不会复制任何数据。"
  remarks: >-
    > [!NOTE]

    >  If these classes have been subclassed, the clone will also be of the same subclasses.
  example:
  - "The following example creates a clone of a <xref:System.Data.DataSet> object's schema.  \n  \n [!code-cs[Classic WebData DataSet.Clone Example#1](~/add/codesnippet/csharp/m-system.data.dataset.cl_0_1.cs)]\n [!code-vb[Classic WebData DataSet.Clone Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.cl_0_1.vb)]"
  syntax:
    content: public virtual System.Data.DataSet Clone ();
    parameters: []
    return:
      type: System.Data.DataSet
      description: "一个新<xref href=&quot;System.Data.DataSet&quot;></xref>具有相同的架构与当前<xref href=&quot;System.Data.DataSet&quot;> </xref>，但是不包含任何数据。"
  overload: System.Data.DataSet.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Copy
  id: Copy
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Copy()
  nameWithType: DataSet.Copy()
  fullName: System.Data.DataSet.Copy()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "将结构和数据复制此<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  remarks: ''
  example:
  - "The following example uses the Copy method to create a copy of the original <xref:System.Data.DataSet>.  \n  \n [!code-cs[Classic WebData DataSet.Copy Example#1](~/add/codesnippet/csharp/m-system.data.dataset.copy_1.cs)]\n [!code-vb[Classic WebData DataSet.Copy Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.copy_1.vb)]"
  syntax:
    content: public System.Data.DataSet Copy ();
    parameters: []
    return:
      type: System.Data.DataSet
      description: "一个新<xref href=&quot;System.Data.DataSet&quot;></xref>具有相同的结构 （表架构、 关系和约束） 和数据作为这<xref href=&quot;System.Data.DataSet&quot;> </xref>。       <div class=&quot;alert NOTE&quot;>    如果已创建这些类的子类，副本还将属于相同的子类。      </div>"
  overload: System.Data.DataSet.Copy*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.CreateDataReader
  id: CreateDataReader
  parent: System.Data.DataSet
  langs:
  - csharp
  name: CreateDataReader()
  nameWithType: DataSet.CreateDataReader()
  fullName: System.Data.DataSet.CreateDataReader()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "返回<xref href=&quot;System.Data.DataTableReader&quot;></xref>带有每个设置的一个结果<xref href=&quot;System.Data.DataTable&quot;></xref>中相同序列，因为表将显示在<xref:System.Data.DataSet.Tables*>集合。</xref:System.Data.DataSet.Tables*>"
  remarks: "为了确保在返回的结果集的顺序<xref:System.Data.DataTableReader>，如果<xref:System.Data.DataTable>内<xref:System.Data.DataSet>是空的它由一个空结果集内返回`DataTableReader`。</xref:System.Data.DataSet> </xref:System.Data.DataTable> </xref:System.Data.DataTableReader>"
  example:
  - "The following example creates three <xref:System.Data.DataTable> instances, and adds each to a <xref:System.Data.DataSet>. The example then passes the filled `DataSet` to a procedure that calls the CreateDataReader method, and proceeds to iterate through all the result sets contained within the <xref:System.Data.DataTableReader>. The example displays the results in the Console window.  \n  \n [!code-vb[DataWorks DataSet.DataTableReader#1](~/add/codesnippet/visualbasic/m-system.data.dataset.cr_0_1.vb)]\n [!code-cs[DataWorks DataSet.DataTableReader#1](~/add/codesnippet/csharp/m-system.data.dataset.cr_0_1.cs)]"
  syntax:
    content: public System.Data.DataTableReader CreateDataReader ();
    parameters: []
    return:
      type: System.Data.DataTableReader
      description: "A <xref href=&quot;System.Data.DataTableReader&quot;> </xref>包含一个或多个结果集，对应于<xref href=&quot;System.Data.DataTable&quot;></xref>的源中所包含的实例<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  overload: System.Data.DataSet.CreateDataReader*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.CreateDataReader(System.Data.DataTable[])
  id: CreateDataReader(System.Data.DataTable[])
  parent: System.Data.DataSet
  langs:
  - csharp
  name: CreateDataReader(DataTable[])
  nameWithType: DataSet.CreateDataReader(DataTable[])
  fullName: System.Data.DataSet.CreateDataReader(DataTable[])
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "返回<xref href=&quot;System.Data.DataTableReader&quot;></xref>带有每个设置的一个结果<xref href=&quot;System.Data.DataTable&quot;> </xref>。"
  remarks: "为了确保结果的顺序设置在返回<xref:System.Data.DataTableReader>，如果<xref:System.Data.DataTable>内<xref:System.Data.DataSet>是空的它由一个空结果集内返回`DataTableReader`。</xref:System.Data.DataSet> </xref:System.Data.DataTable> </xref:System.Data.DataTableReader> 此重载的版本，可提供的列表，因为`DataTable`作为参数的实例，你可以指定在返回的结果集出现的顺序`DataTableReader`。"
  example:
  - "This example, a Console application, creates three <xref:System.Data.DataTable> instances and adds each to a <xref:System.Data.DataSet>. The example calls the CreateDataReader method and displays the contents of the returned <xref:System.Data.DataTableReader>. Note that the order of the result sets in the `DataTableReader` is controlled by the order of the `DataTable` instances passed as parameters. The example displays the results in the Console window.  \n  \n [!code-vb[DataWorks DataSet.DataTableReaderTables#1](~/add/codesnippet/visualbasic/m-system.data.dataset.cr_1_1.vb)]\n [!code-cs[DataWorks DataSet.DataTableReaderTables#1](~/add/codesnippet/csharp/m-system.data.dataset.cr_1_1.cs)]"
  syntax:
    content: public System.Data.DataTableReader CreateDataReader (System.Data.DataTable[] dataTables);
    parameters:
    - id: dataTables
      type: System.Data.DataTable[]
      description: "将设置为数据表提供结果的顺序的数组中返回<xref href=&quot;System.Data.DataTableReader&quot;> </xref>。"
    return:
      type: System.Data.DataTableReader
      description: "A <xref href=&quot;System.Data.DataTableReader&quot;> </xref>包含一个或多个结果集，对应于<xref href=&quot;System.Data.DataTable&quot;></xref>的源中所包含的实例<xref href=&quot;System.Data.DataSet&quot;> </xref>。 返回的结果集是以指定顺序<code> dataTables </code>参数。"
  overload: System.Data.DataSet.CreateDataReader*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.DataSetName
  id: DataSetName
  parent: System.Data.DataSet
  langs:
  - csharp
  name: DataSetName
  nameWithType: DataSet.DataSetName
  fullName: System.Data.DataSet.DataSetName
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "获取或设置的当前名称<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  remarks: ''
  example:
  - "The following example creates a new <xref:System.Data.DataSet> with the given DataSetName.  \n  \n [!code-vb[Classic WebData DataSet.DataSetName Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.da_1.vb)]\n [!code-cs[Classic WebData DataSet.DataSetName Example#1](~/add/codesnippet/csharp/p-system.data.dataset.da_1.cs)]"
  syntax:
    content: public string DataSetName { get; set; }
    return:
      type: System.String
      description: "名称<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  overload: System.Data.DataSet.DataSetName*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.DefaultViewManager
  id: DefaultViewManager
  parent: System.Data.DataSet
  langs:
  - csharp
  name: DefaultViewManager
  nameWithType: DataSet.DefaultViewManager
  fullName: System.Data.DataSet.DefaultViewManager
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "获取中包含的数据的自定义视图<xref href=&quot;System.Data.DataSet&quot;></xref>以允许筛选、 搜索和导航使用自定义<xref href=&quot;System.Data.DataViewManager&quot;> </xref>。"
  remarks: "<xref:System.Data.DataViewManager>返回的属性，可创建自定义设置为每个<xref:System.Data.DataTable>在<xref:System.Data.DataSet>。</xref:System.Data.DataSet> </xref:System.Data.DataTable> DefaultViewManager</xref:System.Data.DataViewManager>       当你获取<xref:System.Data.DataView>从<xref:System.Data.DataTable>，排序顺序、 筛选和<xref:System.Data.DataViewRowState>根据 DefaultViewManager 属性中的设置配置。</xref:System.Data.DataViewRowState> </xref:System.Data.DataTable> </xref:System.Data.DataView>"
  example:
  - "The following example gets the default <xref:System.Data.DataViewManager> for a <xref:System.Data.DataSet>, and adds a <xref:System.Data.DataTable> to the <xref:System.Data.DataTableCollection>.  \n  \n [!code-vb[Classic WebData DataSet.DefaultViewManager Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.de_1.vb)]"
  syntax:
    content: public System.Data.DataViewManager DefaultViewManager { get; }
    return:
      type: System.Data.DataViewManager
      description: "A <xref href=&quot;System.Data.DataViewManager&quot;></xref> object."
  overload: System.Data.DataSet.DefaultViewManager*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)
  id: DetermineSchemaSerializationMode(System.Xml.XmlReader)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: DetermineSchemaSerializationMode(XmlReader)
  nameWithType: DataSet.DetermineSchemaSerializationMode(XmlReader)
  fullName: System.Data.DataSet.DetermineSchemaSerializationMode(XmlReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "确定<xref:System.Data.DataSet.SchemaSerializationMode*>为<xref href=&quot;System.Data.DataSet&quot;> </xref>。</xref:System.Data.DataSet.SchemaSerializationMode*>"
  remarks: "类型化<xref:System.Data.DataSet>以确定其<xref:System.Data.DataSet.SchemaSerializationMode%2A>.</xref:System.Data.DataSet.SchemaSerializationMode%2A></xref:System.Data.DataSet>反序列化时，可以调用此方法"
  syntax:
    content: protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Xml.XmlReader reader);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "<xref:System.Xml.XmlReader>反序列化期间传递的实例<xref href=&quot;System.Data.DataSet&quot;> </xref>。</xref:System.Xml.XmlReader>"
    return:
      type: System.Data.SchemaSerializationMode
      description: "<xref href=&quot;System.Data.SchemaSerializationMode&quot;> </xref>枚举，该值指示是否已从负载中忽略架构信息。"
  overload: System.Data.DataSet.DetermineSchemaSerializationMode*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: DetermineSchemaSerializationMode(SerializationInfo,StreamingContext)
  nameWithType: DataSet.DetermineSchemaSerializationMode(SerializationInfo,StreamingContext)
  fullName: System.Data.DataSet.DetermineSchemaSerializationMode(SerializationInfo,StreamingContext)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "确定<xref:System.Data.DataSet.SchemaSerializationMode*>为<xref href=&quot;System.Data.DataSet&quot;> </xref>。</xref:System.Data.DataSet.SchemaSerializationMode*>"
  remarks: "类型化<xref:System.Data.DataSet>以确定其<xref:System.Data.DataSet.SchemaSerializationMode%2A>.</xref:System.Data.DataSet.SchemaSerializationMode%2A></xref:System.Data.DataSet>反序列化时，可以调用此方法"
  syntax:
    content: protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "<xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref> ， <xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;></xref>的受保护构造函数&lt;xref:System.Data.DataSet.%23ctor%2A&gt;远程处理方案中的反序列化期间使用调用。"
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "<xref:System.Runtime.Serialization.StreamingContext>， <xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;></xref>的受保护构造函数&lt;xref:System.Data.DataSet.%23ctor%2A&gt;远程处理方案中的反序列化期间使用调用。</xref:System.Runtime.Serialization.StreamingContext>"
    return:
      type: System.Data.SchemaSerializationMode
      description: "<xref href=&quot;System.Data.SchemaSerializationMode&quot;> </xref>枚举，该值指示是否已从负载中忽略架构信息。"
  overload: System.Data.DataSet.DetermineSchemaSerializationMode*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.EndInit
  id: EndInit
  parent: System.Data.DataSet
  langs:
  - csharp
  name: EndInit()
  nameWithType: DataSet.EndInit()
  fullName: System.Data.DataSet.EndInit()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "初始化已结束<xref href=&quot;System.Data.DataSet&quot;></xref>窗体上使用或由另一个组件。 初始化发生在运行时。"
  remarks: "Visual Studio.NET 设计环境使用此方法来结束的窗体上使用或由另一个组件的组件初始化。 <xref:System.Data.DataSet.BeginInit%2A>方法开始初始化。</xref:System.Data.DataSet.BeginInit%2A> 使用<xref:System.Data.DataSet.BeginInit%2A>和 EndInit 方法阻止控件完全初始化之前使用。</xref:System.Data.DataSet.BeginInit%2A>"
  syntax:
    content: public void EndInit ();
    parameters: []
  overload: System.Data.DataSet.EndInit*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.EnforceConstraints
  id: EnforceConstraints
  parent: System.Data.DataSet
  langs:
  - csharp
  name: EnforceConstraints
  nameWithType: DataSet.EnforceConstraints
  fullName: System.Data.DataSet.EnforceConstraints
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "获取或设置一个值，该值指示是否在尝试任何更新操作时遵循约束规则。"
  remarks: "在设置约束<xref:System.Data.DataTable>级别 (<xref:System.Data.DataTable.Constraints%2A>属性)。</xref:System.Data.DataTable.Constraints%2A> </xref:System.Data.DataTable> 有关创建约束的详细信息，请参阅[数据表约束](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example creates a <xref:System.Data.DataSet> with one table, one column, five rows, and one <xref:System.Data.UniqueConstraint>. The EnforceConstraints property is set to `false` and the values of each row are set to the same value. When the EnforceConstraints property is reset to `true`, a <xref:System.Data.ConstraintException> is generated.  \n  \n [!code-cs[Classic WebData DataSet.EnforceConstraints Example#1](~/add/codesnippet/csharp/p-system.data.dataset.en_1.cs)]\n [!code-vb[Classic WebData DataSet.EnforceConstraints Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.en_1.vb)]"
  syntax:
    content: public bool EnforceConstraints { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果强制执行规则;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.DataSet.EnforceConstraints*
  exceptions:
  - type: System.Data.ConstraintException
    commentId: T:System.Data.ConstraintException
    description: "无法强制执行一个或多个约束。"
  platform:
  - net462
- uid: System.Data.DataSet.ExtendedProperties
  id: ExtendedProperties
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ExtendedProperties
  nameWithType: DataSet.ExtendedProperties
  fullName: System.Data.DataSet.ExtendedProperties
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "获取与关联的自定义的用户信息的集合<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>。"
  remarks: "ExtendedProperties 属性使您能够存储使用自定义信息`DataSet`。 例如，你可能会存储的数据应在进行刷新的时间。       扩展的属性的类型必须为<xref:System.String>如果你希望它们时保持<xref:System.Data.DataSet>以 XML 形式写入。</xref:System.Data.DataSet> </xref:System.String>"
  example:
  - "The following example adds a custom property to the <xref:System.Data.PropertyCollection> returned by the <xref:System.Data.DataColumn.ExtendedProperties%2A> property. The second example retrieves the custom property.  \n  \n [!code-cs[Classic WebData DataColumn.ExtendedProperties Example#1](~/add/codesnippet/csharp/p-system.data.dataset.ex_1.cs)]\n [!code-vb[Classic WebData DataColumn.ExtendedProperties Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.ex_1.vb)]"
  syntax:
    content: public System.Data.PropertyCollection ExtendedProperties { get; }
    return:
      type: System.Data.PropertyCollection
      description: "A <xref href=&quot;System.Data.PropertyCollection&quot;> </xref>所有的自定义用户信息。"
  overload: System.Data.DataSet.ExtendedProperties*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.GetChanges
  id: GetChanges
  parent: System.Data.DataSet
  langs:
  - csharp
  name: GetChanges()
  nameWithType: DataSet.GetChanges()
  fullName: System.Data.DataSet.GetChanges()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "获取一份<xref href=&quot;System.Data.DataSet&quot;></xref>包含自加载后或以来对它发出的所有更改<xref:System.Data.DataSet.AcceptChanges*>上一次调用。</xref:System.Data.DataSet.AcceptChanges*>"
  remarks: "创建一个新<xref:System.Data.DataSet>，其中包含原始中的所有行的副本<xref:System.Data.DataSet>中具有挂起更改。</xref:System.Data.DataSet> </xref:System.Data.DataSet> 关系约束可能会导致其他未更改的行添加到新<xref:System.Data.DataSet>如果未更改的行包含对应于已更改的行中的外键的主键。</xref:System.Data.DataSet> 该方法返回`null`中是否存在任何行原始<xref:System.Data.DataSet>中具有挂起更改。</xref:System.Data.DataSet>"
  example:
  - "The following example creates a simple <xref:System.Data.DataSet> with one table, two columns, and ten rows. Two values are changed, and one row is added. A subset of the changed data is created using the GetChanges method. After reconciling errors, a new column is added to the subset, changing the schema. When the <xref:System.Data.DataSet.Merge%2A> method is called with the `missingSchemaAction` set to `MissingSchemaAction.Add`, the new column is added to the original <xref:System.Data.DataSet> object's schema.  \n  \n [!code-cs[Classic WebData DataSet.GetChanges Example#1](~/add/codesnippet/csharp/m-system.data.dataset.ge_0_1.cs)]\n [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.ge_0_1.vb)]"
  syntax:
    content: public System.Data.DataSet GetChanges ();
    parameters: []
    return:
      type: System.Data.DataSet
      description: "根据此更改一份<xref href=&quot;System.Data.DataSet&quot;></xref>都可以执行在其上及更高版本返回在使用<xref:System.Data.DataSet.Merge*>.</xref:System.Data.DataSet.Merge*>中进行合并的操作 如果找到任何已更改的行，该方法返回<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.DataSet.GetChanges*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.GetChanges(System.Data.DataRowState)
  id: GetChanges(System.Data.DataRowState)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: GetChanges(DataRowState)
  nameWithType: DataSet.GetChanges(DataRowState)
  fullName: System.Data.DataSet.GetChanges(DataRowState)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "获取一份<xref href=&quot;System.Data.DataSet&quot;></xref>包含自上次加载或以来对其进行的所有更改<xref:System.Data.DataSet.AcceptChanges*>已调用，通过筛选<xref href=&quot;System.Data.DataRowState&quot;> </xref>。</xref:System.Data.DataSet.AcceptChanges*>"
  remarks: "<xref:System.Data.DataSet.GetChanges%2A>方法用于生成第二个<xref:System.Data.DataSet>只包含的更改的对象引入到原始。</xref:System.Data.DataSet> </xref:System.Data.DataSet.GetChanges%2A> 使用`rowStates`自变量以指定新的对象应包含的更改的类型。       此值返回副本用于合并返回到此原始<xref:System.Data.DataSet>.</xref:System.Data.DataSet> 关系约束可能会导致标记的父行`Unchanged`要包含。 如果所需的任何行<xref:System.Data.DataRowState>找到，<xref:System.Data.DataSet.GetChanges%2A>方法返回`null`。</xref:System.Data.DataSet.GetChanges%2A> </xref:System.Data.DataRowState>"
  example:
  - "The following example uses the <xref:System.Data.DataSet.GetChanges%2A> method to create a second <xref:System.Data.DataSet> object, which is then used to update a data source.  \n  \n [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.ge_2_1.vb)]\n [!code-cs[Classic WebData DataSet.GetChanges1 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.ge_2_1.cs)]"
  syntax:
    content: public System.Data.DataSet GetChanges (System.Data.DataRowState rowStates);
    parameters:
    - id: rowStates
      type: System.Data.DataRowState
      description: "之一<xref href=&quot;System.Data.DataRowState&quot;></xref>值。"
    return:
      type: System.Data.DataSet
      description: "筛选的副本<xref href=&quot;System.Data.DataSet&quot;></xref>能够拥有执行它，并随后返回在使用<xref:System.Data.DataSet.Merge*>.</xref:System.Data.DataSet.Merge*>中进行合并的操作 如果所需的任何行<xref href=&quot;System.Data.DataRowState&quot;></xref>找到，则此方法返回<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.DataSet.GetChanges*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)
  id: GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: GetDataSetSchema(XmlSchemaSet)
  nameWithType: DataSet.GetDataSetSchema(XmlSchemaSet)
  fullName: System.Data.DataSet.GetDataSetSchema(XmlSchemaSet)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "获取一份<xref href=&quot;System.Xml.Schema.XmlSchemaSet&quot;></xref>数据集。"
  syntax:
    content: public static System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema (System.Xml.Schema.XmlSchemaSet schemaSet);
    parameters:
    - id: schemaSet
      type: System.Xml.Schema.XmlSchemaSet
      description: "指定的架构集。"
    return:
      type: System.Xml.Schema.XmlSchemaComplexType
      description: "A copy of <xref href=&quot;System.Xml.Schema.XmlSchemaSet&quot;></xref>."
  overload: System.Data.DataSet.GetDataSetSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: GetObjectData(SerializationInfo,StreamingContext)
  nameWithType: DataSet.GetObjectData(SerializationInfo,StreamingContext)
  fullName: System.Data.DataSet.GetObjectData(SerializationInfo,StreamingContext)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "序列化所需的数据，并用其填充序列化信息对象<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  syntax:
    content: public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "A <xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref>它保存与关联的序列化的数据<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "A<xref:System.Runtime.Serialization.StreamingContext>包含源以及与相关联的序列化流的目标<xref href=&quot;System.Data.DataSet&quot;> </xref>。</xref:System.Runtime.Serialization.StreamingContext>"
  overload: System.Data.DataSet.GetObjectData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>info</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Data.DataSet.GetSchemaSerializable
  id: GetSchemaSerializable
  parent: System.Data.DataSet
  langs:
  - csharp
  name: GetSchemaSerializable()
  nameWithType: DataSet.GetSchemaSerializable()
  fullName: System.Data.DataSet.GetSchemaSerializable()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "返回一个可序列化<xref:System.Xml.Schema.XMLSchema>实例。</xref:System.Xml.Schema.XMLSchema>"
  syntax:
    content: protected virtual System.Xml.Schema.XmlSchema GetSchemaSerializable ();
    parameters: []
    return:
      type: System.Xml.Schema.XmlSchema
      description: "<xref:System.Xml.Schema.XMLSchema>实例。</xref:System.Xml.Schema.XMLSchema>"
  overload: System.Data.DataSet.GetSchemaSerializable*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: GetSerializationData(SerializationInfo,StreamingContext)
  nameWithType: DataSet.GetSerializationData(SerializationInfo,StreamingContext)
  fullName: System.Data.DataSet.GetSerializationData(SerializationInfo,StreamingContext)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "反序列化的二进制文件或 XML 流中的表数据。"
  syntax:
    content: protected void GetSerializationData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "<xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref>实例。"
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "流上下文。"
  overload: System.Data.DataSet.GetSerializationData*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.GetXml
  id: GetXml
  parent: System.Data.DataSet
  langs:
  - csharp
  name: GetXml()
  nameWithType: DataSet.GetXml()
  fullName: System.Data.DataSet.GetXml()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "返回的 XML 表示形式中存储的数据<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  remarks: "调用此方法等同于调用<xref:System.Data.DataSet.WriteXml%2A>与<xref:System.Data.XmlWriteMode>设置为<xref:System.Data.XmlWriteMode>。</xref:System.Data.XmlWriteMode> </xref:System.Data.XmlWriteMode> </xref:System.Data.DataSet.WriteXml%2A>       GetXml 返回以字符串形式的 XML，因此要求更多的开销比<xref:System.Data.DataSet.WriteXml%2A>以向文件写入 XML。</xref:System.Data.DataSet.WriteXml%2A>       如果你要构建<xref:System.Data.DataSet>使用架构推理和序列化它使用 XML 或 Web 服务，则列的排序可能更改。</xref:System.Data.DataSet>"
  example:
  - "The following example creates a <xref:System.Data.DataSet> and <xref:System.Data.DataTable>, adds sample data, and then displays the data in XML format.  \n  \n [!code-cs[Classic WebData DataSet.GetXml Example#1](~/add/codesnippet/csharp/m-system.data.dataset.ge_1_1.cs)]\n [!code-vb[Classic WebData DataSet.GetXml Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.ge_1_1.vb)]  \n  \n This sample demonstrates how to write data into an XML file from a DataSet and read data into DataSet from XML. This sample will create one dataset with two tables, use two ways to export a dataset into the XML files (WriteXml and GetXml), and use two ways (ReadXml and InferXmlSchema) to import a dataset from the XML files.  \n  \n Before you compile and run the sample, you need to create four XML files in the sample directory. First, create ElementsWithAttributes.xml:  \n  \n```  \n<MySchool>  \n  <Course CourseID=\"C1045\" Year=\"2012\"  Title=\"Calculus\" Credits=\"4\" DepartmentID=\"7\">New</Course>  \n  <Course CourseID=\"C1061\" Year=\"2012\"  Title=\"Physics\" Credits=\"4\" DepartmentID=\"1\" />  \n  <Department DepartmentID=\"1\" Name=\"Engineering\" Budget=\"350000\" StartDate=\"2007-09-01T00:00:00+08:00\" Administrator=\"2\" />  \n  <Department DepartmentID=\"7\" Name=\"Mathematics\" Budget=\"250024\" StartDate=\"2007-09-01T00:00:00+08:00\" Administrator=\"3\">Cancelled</Department>  \n</MySchool>  \n```  \n  \n Next, create ElementsWithChildElementsxml.xml:  \n  \n```  \n<MySchool>  \n  <Course>  \n    <CourseID>C1045</CourseID>  \n    <Year>2012</Year>  \n    <Title>Calculus</Title>  \n    <Credits>4</Credits>  \n    <DepartmentID>7</DepartmentID>  \n  </Course>  \n  <Course>  \n    <CourseID>C1061</CourseID>  \n    <Year>2012</Year>  \n    <Title>Physics</Title>  \n    <Credits>4</Credits>  \n    <DepartmentID>1</DepartmentID>  \n  </Course>  \n  <Course>  \n    <CourseID>C2021</CourseID>  \n    <Year>2012</Year>  \n    <Title>Composition</Title>  \n    <Credits>3</Credits>  \n    <DepartmentID>2</DepartmentID>  \n  </Course>  \n  <Course>  \n    <CourseID>C2042</CourseID>  \n    <Year>2012</Year>  \n    <Title>Literature</Title>  \n    <Credits>4</Credits>  \n    <DepartmentID>2</DepartmentID>  \n  </Course>  \n  <Department>  \n    <DepartmentID>1</DepartmentID>  \n    <Name>Engineering</Name>  \n    <Budget>350000</Budget>  \n    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  \n    <Administrator>2</Administrator>  \n  </Department>  \n  <Department>  \n    <DepartmentID>2</DepartmentID>  \n    <Name>English</Name>  \n    <Budget>120000</Budget>  \n    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  \n    <Administrator>6</Administrator>  \n  </Department>  \n  <Department>  \n    <DepartmentID>4</DepartmentID>  \n    <Name>Economics</Name>  \n    <Budget>200000</Budget>  \n    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  \n    <Administrator>4</Administrator>  \n  </Department>  \n  <Department>  \n    <DepartmentID>7</DepartmentID>  \n    <Name>Mathematics</Name>  \n    <Budget>250024</Budget>  \n    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  \n    <Administrator>3</Administrator>  \n  </Department>  \n</MySchool>  \n```  \n  \n Now create ElementsWithOnlyAttributes.xml:  \n  \n```  \n<MySchool>  \n  <Course CourseID=\"C1045\" Year=\"2012\"  Title=\"Calculus\" Credits=\"4\" DepartmentID=\"7\" />  \n  <Course CourseID=\"C1061\" Year=\"2012\"  Title=\"Physics\" Credits=\"4\" DepartmentID=\"1\" />  \n  <Department DepartmentID=\"1\" Name=\"Engineering\" Budget=\"350000\" StartDate=\"2007-09-01T00:00:00+08:00\" Administrator=\"2\" />  \n  <Department DepartmentID=\"7\" Name=\"Mathematics\" Budget=\"250024\" StartDate=\"2007-09-01T00:00:00+08:00\" Administrator=\"3\" />  \n</MySchool>  \n```  \n  \n And finally, create RepeatingElements.xml:  \n  \n```  \n<MySchool>  \n  <Course>C1045</Course>  \n  <Course>C1061</Course>  \n  <Department>Engineering</Department>   \n  <Department>Mathematics</Department>  \n</MySchool>  \n```  \n  \n Now you can compile and run the following source code.  [How to Store Data of DataSet into XML File](http://code.msdn.microsoft.com/How-to-Store-Data-of-7b9710f3) has Visual Basic and C# projects for this sample.  \n  \n```  \nusing System;  \nusing System.Data;  \nusing System.IO;  \nusing System.Text;  \nusing System.Xml;  \n  \n// Use WriteXml method to export the dataset.  \nstatic class DataTableHelper {  \n   public static void WriteDataSetToXML(DataSet dataset, String xmlFileName) {  \n      using (FileStream fsWriterStream = new FileStream(xmlFileName, FileMode.Create)) {  \n         using (XmlTextWriter xmlWriter = new XmlTextWriter(fsWriterStream, Encoding.Unicode)) {  \n            dataset.WriteXml(xmlWriter, XmlWriteMode.WriteSchema);  \n            Console.WriteLine(\"Write {0} to the File {1}.\", dataset.DataSetName, xmlFileName);  \n            Console.WriteLine();  \n         }  \n      }  \n   }  \n  \n   // Use GetXml method to get the XML data of the dataset and then export to the file.  \n   public static void GetXMLFromDataSet(DataSet dataset, String xmlFileName) {  \n      using (StreamWriter writer = new StreamWriter(xmlFileName)) {  \n         writer.WriteLine(dataset.GetXml());  \n         Console.WriteLine(\"Get Xml data from {0} and write to the File {1}.\", dataset.DataSetName, xmlFileName);  \n         Console.WriteLine();  \n      }  \n   }  \n  \n   // Use ReadXml method to import the dataset from the dataset.  \n   public static void ReadXmlIntoDataSet(DataSet newDataSet, String xmlFileName) {  \n      using (FileStream fsReaderStream = new FileStream(xmlFileName, FileMode.Open)) {  \n         using (XmlTextReader xmlReader = new XmlTextReader(fsReaderStream)) {  \n            newDataSet.ReadXml(xmlReader, XmlReadMode.ReadSchema);  \n         }  \n      }  \n   }  \n  \n   // Display the columns and value of DataSet.  \n   public static void ShowDataSet(DataSet dataset) {  \n      foreach (DataTable table in dataset.Tables) {  \n         Console.WriteLine(\"Table {0}:\", table.TableName);  \n         ShowDataTable(table);  \n      }  \n   }  \n  \n   // Display the columns and value of DataTable.  \n   private static void ShowDataTable(DataTable table) {  \n      foreach (DataColumn col in table.Columns) {  \n         Console.Write(\"{0,-14}\", col.ColumnName);  \n      }  \n      Console.WriteLine(\"{0,-14}\", \"\");  \n  \n      foreach (DataRow row in table.Rows) {  \n         if (row.RowState == DataRowState.Deleted) {  \n            foreach (DataColumn col in table.Columns) {  \n               if (col.DataType.Equals(typeof(DateTime))) {  \n                  Console.Write(\"{0,-14:d}\", row[col, DataRowVersion.Original]);  \n               }  \n               else if (col.DataType.Equals(typeof(Decimal))) {  \n                  Console.Write(\"{0,-14:C}\", row[col, DataRowVersion.Original]);  \n               }  \n               else {  \n                  Console.Write(\"{0,-14}\", row[col, DataRowVersion.Original]);  \n               }  \n            }  \n         }  \n         else {  \n            foreach (DataColumn col in table.Columns) {  \n               if (col.DataType.Equals(typeof(DateTime))) {  \n                  Console.Write(\"{0,-14:d}\", row[col]);  \n               }  \n               else if (col.DataType.Equals(typeof(Decimal))) {  \n                  Console.Write(\"{0,-14:C}\", row[col]);  \n               }  \n               else {  \n                  Console.Write(\"{0,-14}\", row[col]);  \n               }  \n            }  \n         }  \n         Console.WriteLine(\"{0,-14}\", \"\");  \n      }  \n   }  \n  \n   // Display the columns of DataSet.  \n   public static void ShowDataSetSchema(DataSet dataSet) {  \n      Console.WriteLine(\"{0} contains the following tables:\", dataSet.DataSetName);  \n      foreach (DataTable table in dataSet.Tables) {  \n         Console.WriteLine(\"   Table {0} contains the following columns:\", table.TableName);  \n         ShowDataTableSchema(table);  \n      }  \n   }  \n  \n   // Display the columns of DataTable  \n   private static void ShowDataTableSchema(DataTable table) {  \n      String columnString = \"\";  \n      foreach (DataColumn col in table.Columns) {  \n         columnString += col.ColumnName + \"   \";  \n      }  \n      Console.WriteLine(columnString);  \n   }  \n}  \n  \nclass Program {  \n   static void Main(string[] args) {  \n      // Create the DataSet  \n      DataSet school = new DataSet(\"MySchool\");  \n      DataTable course = CreateCourse();  \n      DataTable department = CreateDepartment();  \n      school.Tables.Add(course);  \n      school.Tables.Add(department);  \n  \n      // Define the constraint between the tables.  \n      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint(\"CourseDepartFK\", department.Columns[\"DepartmentID\"], course.Columns[\"DepartmentID\"]);  \n      courseDepartFK.DeleteRule = Rule.Cascade;  \n      courseDepartFK.UpdateRule = Rule.Cascade;  \n      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  \n      course.Constraints.Add(courseDepartFK);  \n  \n      InsertDepartments(department);  \n      InsertCourses(course);  \n  \n      // Export the dataset to the XML file.  \n      Console.WriteLine(\"Data of the whole DataSet {0}\", school.DataSetName);  \n      DataTableHelper.ShowDataSet(school);  \n  \n      String xmlWithSchemaFileName = \"WriterXMLWithSchema.xml\";  \n      String xmlGetDataFileName = \"GetXML.xml\";  \n  \n      // Use two ways to export the dataset to the Xml file.  \n      DataTableHelper.WriteDataSetToXML(school, xmlWithSchemaFileName);  \n      DataTableHelper.GetXMLFromDataSet(school, xmlGetDataFileName);  \n  \n      // Import the dataset from the XML file.  \n      // Use two ways to import the dataset from the Xml file.  \n      Console.WriteLine(\"Read Xml document into a new DataSet:\");  \n      DataSet newSchool = new DataSet(\"NewSchool\");  \n      DataTableHelper.ReadXmlIntoDataSet(newSchool, xmlWithSchemaFileName);  \n      DataTableHelper.ShowDataSetSchema(newSchool);  \n      Console.WriteLine();  \n  \n      Console.WriteLine(\"Infer a schema for a DataSet from an XML document:\");  \n      InferDataSetSchemaFromXml();  \n  \n      Console.WriteLine(\"Press any key to exit.\");  \n      Console.ReadKey();  \n   }  \n  \n   static DataTable CreateCourse() {  \n      DataTable course = new DataTable(\"Course\");  \n      DataColumn[] cols ={  \n                              new DataColumn(\"CourseID\",typeof(String)),  \n                              new DataColumn(\"Year\",typeof(Int32)),  \n                              new DataColumn(\"Title\",typeof(String)),  \n                              new DataColumn(\"Credits\",typeof(Int32)),  \n                              new DataColumn(\"DepartmentID\",typeof(Int32))};  \n      course.Columns.AddRange(cols);  \n  \n      course.PrimaryKey = new DataColumn[] { course.Columns[\"CourseID\"], course.Columns[\"Year\"] };  \n  \n      return course;  \n   }  \n  \n   static DataTable CreateDepartment() {  \n      DataTable department = new DataTable(\"Department\");  \n      DataColumn[] cols = {   \n                                new DataColumn(\"DepartmentID\", typeof(Int32)),  \n                                new DataColumn(\"Name\",typeof(String)),  \n                                new DataColumn(\"Budget\",typeof(Decimal)),  \n                                new DataColumn(\"StartDate\",typeof(DateTime)),  \n                                new DataColumn(\"Administrator\",typeof(Int32))};  \n      department.Columns.AddRange(cols);  \n  \n      department.PrimaryKey = new DataColumn[] { department.Columns[\"DepartmentID\"] };  \n  \n      return department;  \n   }  \n  \n   static void InsertDepartments(DataTable department) {  \n      Object[] rows = {   \n                            new Object[]{1,\"Engineering\",350000.00,new DateTime(2007,9,1),2},  \n                            new Object[]{2,\"English\",120000.00,new DateTime(2007,9,1),6},  \n                            new Object[]{4,\"Economics\",200000.00,new DateTime(2007,9,1),4},  \n                            new Object[]{7,\"Mathematics\",250024.00,new DateTime(2007,9,1),3}};  \n  \n      foreach (Object[] row in rows) {  \n         department.Rows.Add(row);  \n      }  \n   }  \n  \n   static void InsertCourses(DataTable course) {  \n      Object[] rows ={  \n                               new Object[]{\"C1045\",2012,\"Calculus\",4,7},  \n                               new Object[]{\"C1061\",2012,\"Physics\",4,1},  \n                               new Object[]{\"C2021\",2012,\"Composition\",3,2},  \n                               new Object[]{\"C2042\",2012,\"Literature\",4,2}};  \n  \n      foreach (Object[] row in rows) {  \n         course.Rows.Add(row);  \n      }  \n   }  \n  \n   // Display the results of inferring schema from four types of XML structures  \n   private static void InferDataSetSchemaFromXml() {  \n      String[] xmlFileNames = {   \n  \n                                    @\"ElementsWithOnlyAttributes.xml\",   \n                                    @\"ElementsWithAttributes.xml\",  \n                                    @\"RepeatingElements.xml\",   \n                                    @\"ElementsWithChildElements.xml\" };  \n  \n      foreach (String xmlFileName in xmlFileNames) {  \n         Console.WriteLine(\"Result of {0}\", Path.GetFileNameWithoutExtension(xmlFileName));  \n         DataSet newSchool = new DataSet();  \n         newSchool.InferXmlSchema(xmlFileName, null);  \n         DataTableHelper.ShowDataSetSchema(newSchool);  \n         Console.WriteLine();  \n      }  \n   }  \n}  \n```"
  syntax:
    content: public string GetXml ();
    parameters: []
    return:
      type: System.String
      description: "一个字符串，它存储在数据的表示形式<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  overload: System.Data.DataSet.GetXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.GetXmlSchema
  id: GetXmlSchema
  parent: System.Data.DataSet
  langs:
  - csharp
  name: GetXmlSchema()
  nameWithType: DataSet.GetXmlSchema()
  fullName: System.Data.DataSet.GetXmlSchema()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "返回的 XML 表示形式中存储的数据的 XML 架构<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  remarks: "调用此方法相当于调用<xref:System.Data.DataSet.WriteXmlSchema%2A>，只不过仅在主架构写。</xref:System.Data.DataSet.WriteXmlSchema%2A>       GetXmlSchema 返回以字符串形式的 XML，因此要求更多的开销比<xref:System.Data.DataSet.WriteXmlSchema%2A>以向文件写入 XML。</xref:System.Data.DataSet.WriteXmlSchema%2A>       如果你要构建<xref:System.Data.DataSet>使用架构推理和序列化它使用 XML 或 Web 服务，则列的排序可能更改。</xref:System.Data.DataSet>"
  example:
  - "The following example creates a <xref:System.Data.DataSet> and <xref:System.Data.DataTable>, and then displays the schema in XML format.  \n  \n [!code-cs[Classic WebData DataSet.GetXmlSchema Example#1](~/add/codesnippet/csharp/m-system.data.dataset.ge_3_1.cs)]\n [!code-vb[Classic WebData DataSet.GetXmlSchema Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.ge_3_1.vb)]"
  syntax:
    content: public string GetXmlSchema ();
    parameters: []
    return:
      type: System.String
      description: "字符串，它 XML 架构的 XML 表示形式中存储的数据为<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  overload: System.Data.DataSet.GetXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.HasChanges
  id: HasChanges
  parent: System.Data.DataSet
  langs:
  - csharp
  name: HasChanges()
  nameWithType: DataSet.HasChanges()
  fullName: System.Data.DataSet.HasChanges()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "获取一个值，该值指示是否<xref href=&quot;System.Data.DataSet&quot;></xref>更改，包括新的、 已删除，或已修改的行。"
  remarks: ''
  example:
  - "The following example uses the <xref:System.Data.DataSet.GetChanges%2A> method to create a second <xref:System.Data.DataSet> object that is then used to update a data source.  \n  \n [!code-vb[Classic WebData DataSet.HasChanges Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.ha_0_1.vb)]\n [!code-cs[Classic WebData DataSet.HasChanges Example#1](~/add/codesnippet/csharp/m-system.data.dataset.ha_0_1.cs)]"
  syntax:
    content: public bool HasChanges ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Data.DataSet&quot;></xref>具有更改; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.DataSet.HasChanges*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.HasChanges(System.Data.DataRowState)
  id: HasChanges(System.Data.DataRowState)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: HasChanges(DataRowState)
  nameWithType: DataSet.HasChanges(DataRowState)
  fullName: System.Data.DataSet.HasChanges(DataRowState)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "获取一个值，该值指示是否<xref href=&quot;System.Data.DataSet&quot;></xref>更改，包括新的、 已删除，或已修改的行，通过筛选<xref href=&quot;System.Data.DataRowState&quot;> </xref>。"
  remarks: "检查<xref:System.Data.DataSet.HasChanges%2A>属性`DataSet`之前调用<xref:System.Data.DataSet.GetChanges%2A>方法。</xref:System.Data.DataSet.GetChanges%2A> </xref:System.Data.DataSet.HasChanges%2A>"
  example:
  - "The following example uses the <xref:System.Data.DataSet.GetChanges%2A> method to create a second <xref:System.Data.DataSet> object, which is then used to update a data source.  \n  \n [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.ha_1_1.vb)]\n [!code-cs[Classic WebData DataSet.GetChanges1 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.ha_1_1.cs)]"
  syntax:
    content: public bool HasChanges (System.Data.DataRowState rowStates);
    parameters:
    - id: rowStates
      type: System.Data.DataRowState
      description: "之一<xref href=&quot;System.Data.DataRowState&quot;></xref>值。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Data.DataSet&quot;></xref>具有更改; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.DataSet.HasChanges*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.HasErrors
  id: HasErrors
  parent: System.Data.DataSet
  langs:
  - csharp
  name: HasErrors
  nameWithType: DataSet.HasErrors
  fullName: System.Data.DataSet.HasErrors
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "获取一个值，该值在任何中是否有错误<xref href=&quot;System.Data.DataTable&quot;></xref>对象在此<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  remarks: "每个<xref:System.Data.DataTable>中<xref:System.Data.DataSet>还有<xref:System.Data.DataTable.HasErrors%2A>属性。</xref:System.Data.DataTable.HasErrors%2A> </xref:System.Data.DataSet> </xref:System.Data.DataTable> 使用`HasErrors`属性`DataSet`第一个，以确定是否任何表就会有错误，然后再检查单个<xref:System.Data.DataTable>对象。</xref:System.Data.DataTable> 如果`DataTable`有错误，<xref:System.Data.DataTable.GetErrors%2A>方法返回的数组<xref:System.Data.DataRow>对象包含的错误。</xref:System.Data.DataRow> </xref:System.Data.DataTable.GetErrors%2A>"
  example:
  - "The following example uses the HasErrors property to determine whether a <xref:System.Data.DataSet> object contains errors. If so, the errors for each <xref:System.Data.DataRow> in each <xref:System.Data.DataTable> are printed.  \n  \n [!code-cs[Classic WebData DataSet.HasErrors Example#1](~/add/codesnippet/csharp/p-system.data.dataset.ha_1.cs)]\n [!code-vb[Classic WebData DataSet.HasErrors Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.ha_1.vb)]"
  syntax:
    content: public bool HasErrors { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果任何表包含错误; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.DataSet.HasErrors*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.InferXmlSchema(System.IO.Stream,System.String[])
  id: InferXmlSchema(System.IO.Stream,System.String[])
  parent: System.Data.DataSet
  langs:
  - csharp
  name: InferXmlSchema(Stream,String[])
  nameWithType: DataSet.InferXmlSchema(Stream,String[])
  fullName: System.Data.DataSet.InferXmlSchema(Stream,String[])
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "从指定适用的 XML 架构<xref:System.IO.Stream>到<xref href=&quot;System.Data.DataSet&quot;> </xref>。</xref:System.IO.Stream>"
  syntax:
    content: public void InferXmlSchema (System.IO.Stream stream, string[] nsArray);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "<xref uid=&quot;langword_csharp_Stream&quot; name=&quot;Stream&quot; href=&quot;&quot;> </xref>从中读取该架构。"
    - id: nsArray
      type: System.String[]
      description: "要从架构推理中排除的命名空间统一资源标识符 (URI) 字符串的数组。"
  overload: System.Data.DataSet.InferXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.InferXmlSchema(System.IO.TextReader,System.String[])
  id: InferXmlSchema(System.IO.TextReader,System.String[])
  parent: System.Data.DataSet
  langs:
  - csharp
  name: InferXmlSchema(TextReader,String[])
  nameWithType: DataSet.InferXmlSchema(TextReader,String[])
  fullName: System.Data.DataSet.InferXmlSchema(TextReader,String[])
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "从指定适用的 XML 架构<xref:System.IO.TextReader>到<xref href=&quot;System.Data.DataSet&quot;> </xref>。</xref:System.IO.TextReader>"
  syntax:
    content: public void InferXmlSchema (System.IO.TextReader reader, string[] nsArray);
    parameters:
    - id: reader
      type: System.IO.TextReader
      description: "<xref uid=&quot;langword_csharp_TextReader&quot; name=&quot;TextReader&quot; href=&quot;&quot;> </xref>从中读取该架构。"
    - id: nsArray
      type: System.String[]
      description: "要从架构推理中排除的命名空间统一资源标识符 (URI) 字符串的数组。"
  overload: System.Data.DataSet.InferXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.InferXmlSchema(System.String,System.String[])
  id: InferXmlSchema(System.String,System.String[])
  parent: System.Data.DataSet
  langs:
  - csharp
  name: InferXmlSchema(String,String[])
  nameWithType: DataSet.InferXmlSchema(String,String[])
  fullName: System.Data.DataSet.InferXmlSchema(String,String[])
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "将 XML 架构应用到指定的文件从<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  syntax:
    content: public void InferXmlSchema (string fileName, string[] nsArray);
    parameters:
    - id: fileName
      type: System.String
      description: "要从其中读取架构 （包括路径） 的文件的名称。"
    - id: nsArray
      type: System.String[]
      description: "要从架构推理中排除的命名空间统一资源标识符 (URI) 字符串的数组。"
  overload: System.Data.DataSet.InferXmlSchema*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<xref href=&quot;System.Security.Permissions.FileIOPermission&quot;></xref>未设置为<xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>。"
  platform:
  - net462
- uid: System.Data.DataSet.InferXmlSchema(System.Xml.XmlReader,System.String[])
  id: InferXmlSchema(System.Xml.XmlReader,System.String[])
  parent: System.Data.DataSet
  langs:
  - csharp
  name: InferXmlSchema(XmlReader,String[])
  nameWithType: DataSet.InferXmlSchema(XmlReader,String[])
  fullName: System.Data.DataSet.InferXmlSchema(XmlReader,String[])
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "从指定适用的 XML 架构<xref:System.Xml.XmlReader>到<xref href=&quot;System.Data.DataSet&quot;> </xref>。</xref:System.Xml.XmlReader>"
  syntax:
    content: public void InferXmlSchema (System.Xml.XmlReader reader, string[] nsArray);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "<xref uid=&quot;langword_csharp_XMLReader&quot; name=&quot;XMLReader&quot; href=&quot;&quot;> </xref>从中读取该架构。"
    - id: nsArray
      type: System.String[]
      description: "要从架构推理中排除的命名空间统一资源标识符 (URI) 字符串的数组。"
  overload: System.Data.DataSet.InferXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Initialized
  id: Initialized
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Initialized
  nameWithType: DataSet.Initialized
  fullName: System.Data.DataSet.Initialized
  type: Event
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "之后，将会<xref href=&quot;System.Data.DataSet&quot;></xref>初始化。"
  remarks: "有关详细信息，请参阅<xref:System.Data.DataSet.IsInitialized%2A>。</xref:System.Data.DataSet.IsInitialized%2A>"
  syntax:
    content: public event EventHandler Initialized;
    return:
      type: System.EventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.InitializeDerivedDataSet
  id: InitializeDerivedDataSet
  parent: System.Data.DataSet
  langs:
  - csharp
  name: InitializeDerivedDataSet()
  nameWithType: DataSet.InitializeDerivedDataSet()
  fullName: System.Data.DataSet.InitializeDerivedDataSet()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "反序列化的所有表数据从二进制文件或 XML 流的数据集。"
  syntax:
    content: protected virtual void InitializeDerivedDataSet ();
    parameters: []
  overload: System.Data.DataSet.InitializeDerivedDataSet*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: IsBinarySerialized(SerializationInfo,StreamingContext)
  nameWithType: DataSet.IsBinarySerialized(SerializationInfo,StreamingContext)
  fullName: System.Data.DataSet.IsBinarySerialized(SerializationInfo,StreamingContext)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "检查的序列化表示形式的格式<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>。"
  remarks: "此成员支持.NET Framework 基础结构，不宜在代码中直接使用。"
  syntax:
    content: protected bool IsBinarySerialized (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "<xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref>对象。"
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "<xref:System.Runtime.Serialization.StreamingContext>对象。</xref:System.Runtime.Serialization.StreamingContext>"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果指定<xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;></xref>表示<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;></xref>以二进制格式，序列化<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>否则为。"
  overload: System.Data.DataSet.IsBinarySerialized*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.IsInitialized
  id: IsInitialized
  parent: System.Data.DataSet
  langs:
  - csharp
  name: IsInitialized
  nameWithType: DataSet.IsInitialized
  fullName: System.Data.DataSet.IsInitialized
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "获取一个值，该值指示是否<xref href=&quot;System.Data.DataSet&quot;></xref>初始化。"
  remarks: "返回的状态<xref:System.Data.DataSet>时它正在构造，例如 Visual Studio。</xref:System.Data.DataSet> <xref:System.Data.DataSet.BeginInit%2A>方法将其设置为`false`和<xref:System.Data.DataSet.EndInit%2A>方法将其设置为`true`。</xref:System.Data.DataSet.EndInit%2A> </xref:System.Data.DataSet.BeginInit%2A>"
  syntax:
    content: public bool IsInitialized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>指示组件已完成初始化;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.DataSet.IsInitialized*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])
  id: Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Load(IDataReader,LoadOption,DataTable[])
  nameWithType: DataSet.Load(IDataReader,LoadOption,DataTable[])
  fullName: System.Data.DataSet.Load(IDataReader,LoadOption,DataTable[])
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "填充<xref href=&quot;System.Data.DataSet&quot;></xref>使用所提供的数据源中的值<xref href=&quot;System.Data.IDataReader&quot;> </xref>，使用的数组<xref href=&quot;System.Data.DataTable&quot;></xref>实例提供的架构和命名空间信息。"
  remarks: "<xref:System.Data.DataTable.Load%2A>方法提供了一种技术填充单个<xref:System.Data.DataTable>从检索到的数据与<xref:System.Data.IDataReader>实例。</xref:System.Data.IDataReader> </xref:System.Data.DataTable> </xref:System.Data.DataTable.Load%2A> 此方法提供相同的功能，但允许你从<xref:System.Data.IDataReader>为一种<xref:System.Data.DataSet>。</xref:System.Data.DataSet>内的多个表</xref:System.Data.IDataReader>加载多个结果集      1> [!NOTE]&1;> 加载操作将失败，并<xref:System.InvalidOperationException>如果任何中传入的源数据列`reader`的计算列。</xref:System.InvalidOperationException>       `loadOption`参数可以指定希望导入的数据与现有数据进行交互和可以是任何中的值的方式<xref:System.Data.LoadOption>枚举。</xref:System.Data.LoadOption> 请参阅<xref:System.Data.DataTable>的文档<xref:System.Data.DataTable.Load%2A>有关使用此参数的详细信息的方法。</xref:System.Data.DataTable.Load%2A></xref:System.Data.DataTable>       `tables`参数允许你指定的数组<xref:System.Data.DataTable>实例，指示每个结果集加载从读取器与对应的表的顺序。</xref:System.Data.DataTable> Loadmethod 填充每个提供<xref:System.Data.DataTable>具有数据从单个结果集，从源数据读取器实例。</xref:System.Data.DataTable> 每个结果集之后，Loadmethod 移到下一步中的结果集读取器中，直到没有更多的结果集。       此方法的名称解析方案等同于跟<xref:System.Data.Common.DbDataAdapter.Fill%2A>方法的<xref:System.Data.Common.DbDataAdapter>类。</xref:System.Data.Common.DbDataAdapter> </xref:System.Data.Common.DbDataAdapter.Fill%2A>"
  example:
  - "The following example creates a new <xref:System.Data.DataSet>, adds two <xref:System.Data.DataTable> instances to the <xref:System.Data.DataSet>, and then fills the <xref:System.Data.DataSet> using the Load method, retrieving data from a <xref:System.Data.DataTableReader> that contains two result sets. Finally, the example displays the contents of the tables in the console window.  \n  \n [!code-vb[DataWorks DataSet.LoadTables#1](~/add/codesnippet/visualbasic/54dbea54-b320-4c41-9f97-_1.vb)]\n [!code-cs[DataWorks DataSet.LoadTables#1](~/add/codesnippet/csharp/54dbea54-b320-4c41-9f97-_1.cs)]"
  syntax:
    content: public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.DataTable[] tables);
    parameters:
    - id: reader
      type: System.Data.IDataReader
      description: "<xref href=&quot;System.Data.IDataReader&quot;> </xref> ，提供了一个或多个结果集。"
    - id: loadOption
      type: System.Data.LoadOption
      description: "取值范围为<xref href=&quot;System.Data.LoadOption&quot;></xref>枚举，指示如何中的现有行<xref href=&quot;System.Data.DataTable&quot;></xref>实例内<xref href=&quot;System.Data.DataSet&quot;></xref>组合在一起共享相同的主键的传入行。"
    - id: tables
      type: System.Data.DataTable[]
      description: "数组<xref href=&quot;System.Data.DataTable&quot;></xref>情况下，从其负载方法检索名称和命名空间的信息。 其中每个表必须是属于<xref href=&quot;System.Data.DataTableCollection&quot;></xref>包含由此<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  overload: System.Data.DataSet.Load*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])
  id: Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Load(IDataReader,LoadOption,String[])
  nameWithType: DataSet.Load(IDataReader,LoadOption,String[])
  fullName: System.Data.DataSet.Load(IDataReader,LoadOption,String[])
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "填充<xref href=&quot;System.Data.DataSet&quot;></xref>使用所提供的数据源中的值<xref href=&quot;System.Data.IDataReader&quot;> </xref>，使用一个字符串数组提供中的表名称，从而<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>。"
  remarks: "<xref:System.Data.DataTable.Load%2A>方法提供了一种技术填充单个<xref:System.Data.DataTable>从检索到的数据与<xref:System.Data.IDataReader>实例。</xref:System.Data.IDataReader> </xref:System.Data.DataTable> </xref:System.Data.DataTable.Load%2A> 此方法提供相同的功能，但是允许您将负载从多个结果集`IDataReader`到内的多个表`DataSet`。      1> [!NOTE]&1;> 加载操作将失败，并<xref:System.InvalidOperationException>如果任何中传入的源数据列`reader`的计算列。</xref:System.InvalidOperationException>       `loadOption`参数可以指定希望导入的数据与现有数据进行交互和可以是任何中的值的方式<xref:System.Data.LoadOption>枚举。</xref:System.Data.LoadOption> 请参阅的文档<xref:System.Data.DataTable.Load%2A>有关使用此参数的详细信息的方法。</xref:System.Data.DataTable.Load%2A>       `tables`参数可以指定表名称，指示每个结果集加载从读取器与对应的表的顺序的数组。 `Load`方法尝试查找表中的`DataSet`在顺序中的表名称的数组中找到匹配的名称。 如果找到匹配的表，该表都会加载当前的结果集的内容。 如果不找到任何匹配的表，则使用表名称的数组中提供的名称创建一个表，并且新表的架构推断从结果集中。 在每个结果集之后,`Load`方法会移到下一步中的结果集读取器中，直到没有更多的结果集。       与关联的默认命名空间`DataSet`，如果任何，与每个新创建为关联`DataTable`。 此方法的名称解析方案等同于跟<xref:System.Data.Common.DbDataAdapter.Fill%2A>方法的<xref:System.Data.Common.DbDataAdapter>类。</xref:System.Data.Common.DbDataAdapter> </xref:System.Data.Common.DbDataAdapter.Fill%2A>"
  example:
  - "The following Console application example first creates tables and loads data from a reader into a <xref:System.Data.DataSet>, using the `Load` method. The example then adds tables to a <xref:System.Data.DataSet> and attempts to fill the tables with data from a <xref:System.Data.DataTableReader>. In this example, because the parameters passed to the `Load` method indicate a table name that does not exist, the `Load` method creates a new table to match the name passed as a parameter. Once the data has been loaded, the example displays the contents of all its tables in the Console window.  \n  \n [!code-vb[DataWorks DataSet.LoadString#1](~/add/codesnippet/visualbasic/f903cc41-1885-430a-b43a-_1.vb)]\n [!code-cs[DataWorks DataSet.LoadString#1](~/add/codesnippet/csharp/f903cc41-1885-430a-b43a-_1.cs)]"
  syntax:
    content: public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, string[] tables);
    parameters:
    - id: reader
      type: System.Data.IDataReader
      description: "<xref href=&quot;System.Data.IDataReader&quot;> </xref> ，提供了一个或多个结果集。"
    - id: loadOption
      type: System.Data.LoadOption
      description: "取值范围为<xref href=&quot;System.Data.LoadOption&quot;></xref>枚举，指示如何中的现有行<xref href=&quot;System.Data.DataTable&quot;></xref>实例内<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;></xref>组合在一起共享相同的主键的传入行。"
    - id: tables
      type: System.String[]
      description: "一个字符串，从该数组<xref uid=&quot;langword_csharp_Load&quot; name=&quot;Load&quot; href=&quot;&quot;></xref>方法检索表名称信息。"
  overload: System.Data.DataSet.Load*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])
  id: Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Load(IDataReader,LoadOption,FillErrorEventHandler,DataTable[])
  nameWithType: DataSet.Load(IDataReader,LoadOption,FillErrorEventHandler,DataTable[])
  fullName: System.Data.DataSet.Load(IDataReader,LoadOption,FillErrorEventHandler,DataTable[])
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "填充<xref href=&quot;System.Data.DataSet&quot;></xref>使用所提供的数据源中的值<xref href=&quot;System.Data.IDataReader&quot;> </xref>，使用的数组<xref href=&quot;System.Data.DataTable&quot;></xref>实例提供的架构和命名空间信息。"
  remarks: "<xref:System.Data.DataTable.Load%2A>方法提供了一种技术填充单个<xref:System.Data.DataTable>从检索到的数据与<xref:System.Data.IDataReader>实例。</xref:System.Data.IDataReader> </xref:System.Data.DataTable> </xref:System.Data.DataTable.Load%2A> 此方法提供相同的功能，但允许你从<xref:System.Data.IDataReader>为一种<xref:System.Data.DataSet>。</xref:System.Data.DataSet>内的多个表</xref:System.Data.IDataReader>加载多个结果集      1> [!NOTE]&1;> 加载操作将失败，并<xref:System.InvalidOperationException>如果任何中传入的源数据列`reader`的计算列。</xref:System.InvalidOperationException>       `loadOption`参数可以指定希望导入的数据与现有数据进行交互和可以是任何中的值的方式<xref:System.Data.LoadOption>枚举。</xref:System.Data.LoadOption> 请参阅<xref:System.Data.DataTable>的文档<xref:System.Data.DataTable.Load%2A>有关使用此参数的详细信息的方法。</xref:System.Data.DataTable.Load%2A></xref:System.Data.DataTable>       `errorHandler`参数是<xref:System.Data.FillErrorEventHandler>指将数据加载过程中发生错误时调用的过程的委托。</xref:System.Data.FillErrorEventHandler> <xref:System.Data.FillErrorEventArgs>传递给过程的参数提供的属性，使您得以检索有关错误的发生，而当前行的数据，信息和<xref:System.Data.DataTable>填充的。</xref:System.Data.DataTable> </xref:System.Data.FillErrorEventArgs> 使用此委托机制，而不是更简单的 try/catch 块，可以确定该错误，处理这种情况，并继续如果愿意处理。 <xref:System.Data.FillErrorEventArgs>参数提供<xref:System.Data.FillErrorEventArgs.Continue%2A>属性︰ 将此属性设置为`true`以指示你已处理错误并且希望继续进行处理; 将属性设置为`false`以指示你想要停止处理。</xref:System.Data.FillErrorEventArgs.Continue%2A> </xref:System.Data.FillErrorEventArgs> 请注意，将属性设置为`false`导致触发要引发异常的问题的代码。       `tables`参数允许你指定的数组<xref:System.Data.DataTable>实例，指示每个结果集加载从读取器与对应的表的顺序。</xref:System.Data.DataTable> Loadmethod 填充每个提供<xref:System.Data.DataTable>具有数据从单个结果集，从源数据读取器实例。</xref:System.Data.DataTable> 每个结果集之后，Loadmethod 移到下一步中的结果集读取器中，直到没有更多的结果集。       此方法的名称解析方案等同于跟<xref:System.Data.Common.DbDataAdapter.Fill%2A>方法的<xref:System.Data.Common.DbDataAdapter>类。</xref:System.Data.Common.DbDataAdapter> </xref:System.Data.Common.DbDataAdapter.Fill%2A>"
  example:
  - "The following example adds a table to a <xref:System.Data.DataSet>, and then attempts to use the Load method to load data from a <xref:System.Data.DataTableReader> that contains an incompatible schema. Rather than trapping the error, this example uses a <xref:System.Data.FillErrorEventHandler> delegate to investigate and handle the error. The output is displayed in the console window.  \n  \n [!code-vb[DataWorks DataSet.Load#1](~/add/codesnippet/visualbasic/a22aaabc-2cbb-4c1f-aa4e-_1.vb)]\n [!code-cs[DataWorks DataSet.Load#1](~/add/codesnippet/csharp/a22aaabc-2cbb-4c1f-aa4e-_1.cs)]"
  syntax:
    content: public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler, System.Data.DataTable[] tables);
    parameters:
    - id: reader
      type: System.Data.IDataReader
      description: "<xref href=&quot;System.Data.IDataReader&quot;> </xref> ，提供了一个或多个结果集。"
    - id: loadOption
      type: System.Data.LoadOption
      description: "取值范围为<xref href=&quot;System.Data.LoadOption&quot;></xref>枚举，指示如何中的现有行<xref href=&quot;System.Data.DataTable&quot;></xref>实例内<xref href=&quot;System.Data.DataSet&quot;></xref>组合在一起共享相同的主键的传入行。"
    - id: errorHandler
      type: System.Data.FillErrorEventHandler
      description: "A <xref href=&quot;System.Data.FillErrorEventHandler&quot;> </xref>加载数据时出错时要调用委托。"
    - id: tables
      type: System.Data.DataTable[]
      description: "数组<xref href=&quot;System.Data.DataTable&quot;></xref>情况下，从其负载方法检索名称和命名空间的信息。"
  overload: System.Data.DataSet.Load*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Locale
  id: Locale
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Locale
  nameWithType: DataSet.Locale
  fullName: System.Data.DataSet.Locale
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "获取或设置用来比较字符串表中的区域设置信息。"
  remarks: "区域设置属性指定的区域设置用于排序适用。       默认情况下，设置的区域设置<xref:System.Data.DataSet>还为每个区域设置设定<xref:System.Data.DataTable>中的对象`DataSet`为相同的值。</xref:System.Data.DataTable> </xref:System.Data.DataSet>      1> [!NOTE]&1;> 包含表达式，列中<xref:System.StringComparison>使用。</xref:System.StringComparison> <xref:System.StringComparison>将被忽略。</xref:System.StringComparison>"
  example:
  - "The following example gets the <xref:System.Globalization.CultureInfo> for a <xref:System.Data.DataSet> and prints the <xref:System.Globalization.CultureInfo.DisplayName%2A> and <xref:System.Globalization.CultureInfo.EnglishName%2A> properties.  \n  \n [!code-vb[Classic WebData DataSet.Locale Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.lo_1.vb)]"
  syntax:
    content: public System.Globalization.CultureInfo Locale { get; set; }
    return:
      type: System.Globalization.CultureInfo
      description: "A<xref:System.Globalization.CultureInfo>包含有关用户的计算机的区域设置的数据。</xref:System.Globalization.CultureInfo> 默认值是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.DataSet.Locale*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Merge(System.Data.DataRow[])
  id: Merge(System.Data.DataRow[])
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Merge(DataRow[])
  nameWithType: DataSet.Merge(DataRow[])
  fullName: System.Data.DataSet.Merge(DataRow[])
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "合并的数组<xref href=&quot;System.Data.DataRow&quot;></xref>到当前对象<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  remarks: "<xref:System.Data.DataSet.Merge%2A>方法用于合并两个<xref:System.Data.DataSet>有很大程度上类似的架构的对象。</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 合并通常用于对客户端应用程序，以将数据源的最新的更改合并到现有的<xref:System.Data.DataSet>.</xref:System.Data.DataSet> 这允许客户端应用程序具有刷新<xref:System.Data.DataSet>使用数据源的最新的数据。</xref:System.Data.DataSet>       <xref:System.Data.DataSet.Merge%2A>通常在一系列的过程涉及验证更改、 协调错误、 更新使用所做的更改，数据源和最后刷新现有<xref:System.Data.DataSet>.</xref:System.Data.DataSet>的末尾调用方法</xref:System.Data.DataSet.Merge%2A>       在客户端应用程序中，很常见的单个按钮，用户可以单击收集更改的数据，并将其发送回中间层组件之前对它进行验证。 在此方案中，<xref:System.Data.DataSet.GetChanges%2A>第一次调用方法。</xref:System.Data.DataSet.GetChanges%2A> 方法将返回第二个<xref:System.Data.DataSet>优化为验证和合并。</xref:System.Data.DataSet> 此第二个<xref:System.Data.DataSet>对象只包含<xref:System.Data.DataTable>和<xref:System.Data.DataRow>对象的已更改，从而导致原始<xref:System.Data.DataSet>.</xref:System.Data.DataSet>的子集</xref:System.Data.DataRow></xref:System.Data.DataTable></xref:System.Data.DataSet> 此子集通常较小，因此可以更有效地传递回中间层组件。 然后，中间层组件使用通过存储过程的更改更新原始数据源。 然后，中间层可以发送回一个新<xref:System.Data.DataSet>，包括原始数据和数据源的最新数据 （通过再次运行原始查询），或者它可以发送回包含从数据源对其进行任何更改的子集。</xref:System.Data.DataSet> （例如，如果数据源会自动创建唯一的主键值，这些值可以将传播回客户端应用程序。）在任一情况下，返回<xref:System.Data.DataSet>必须合并回客户端应用程序的原始<xref:System.Data.DataSet>与<xref:System.Data.DataSet.Merge%2A>方法。</xref:System.Data.DataSet.Merge%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet>       当<xref:System.Data.DataSet.Merge%2A>调用方法时，这两个架构<xref:System.Data.DataSet>对象进行比较，因为它是可能的架构可能已更改。</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 例如，在企业到企业方案中，新列可能已被添加到 XML 架构一个自动化过程。 如果源<xref:System.Data.DataSet>包含架构元素 (添加<xref:System.Data.DataColumn>对象) 缺少目标中，通过设置，可以将架构元素添加到目标`missingSchemaAction`参数`MissingSchemaAction.Add`。</xref:System.Data.DataColumn> </xref:System.Data.DataSet> 在这种情况下，合并<xref:System.Data.DataSet>包含添加的架构和数据。</xref:System.Data.DataSet>       合并后的架构，则数据将合并。       合并新的源时<xref:System.Data.DataSet>到目标中时，任何源行与<xref:System.Data.DataRowState>值`Unchanged`， `Modified`，或`Deleted`与具有相同的主键值的目标行匹配。</xref:System.Data.DataRowState> </xref:System.Data.DataSet> 源行<xref:System.Data.DataRowState>值`Added`具有相同作为新的源行的主键值的新目标行匹配。</xref:System.Data.DataRowState>       在合并时，约束被禁用。 如果任何约束不能启用合并，末尾<xref:System.Data.ConstraintException>生成和合并的数据会保留，而会在禁用约束。</xref:System.Data.ConstraintException> 在这种情况下，<xref:System.Data.DataSet.EnforceConstraints%2A>属性设置为`false`，并且无效的所有行均未标记错误。</xref:System.Data.DataSet.EnforceConstraints%2A> 在尝试重置之前，必须解决错误<xref:System.Data.DataSet.EnforceConstraints%2A>属性`true`。</xref:System.Data.DataSet.EnforceConstraints%2A>"
  syntax:
    content: public void Merge (System.Data.DataRow[] rows);
    parameters:
    - id: rows
      type: System.Data.DataRow[]
      description: "数组<xref uid=&quot;langword_csharp_DataRow&quot; name=&quot;DataRow&quot; href=&quot;&quot;></xref>对象合并到<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.DataSet.Merge*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Merge(System.Data.DataSet)
  id: Merge(System.Data.DataSet)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Merge(DataSet)
  nameWithType: DataSet.Merge(DataSet)
  fullName: System.Data.DataSet.Merge(DataSet)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "合并指定<xref href=&quot;System.Data.DataSet&quot;></xref>到当前及其架构<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>。"
  remarks: "Merge 方法用于合并两个<xref:System.Data.DataSet>有很大程度上类似的架构的对象。</xref:System.Data.DataSet> 合并通常用于对客户端应用程序，以将数据源的最新的更改合并到现有的<xref:System.Data.DataSet>.</xref:System.Data.DataSet> 这允许客户端应用程序具有刷新<xref:System.Data.DataSet>使用数据源的最新的数据。</xref:System.Data.DataSet>       Merge 方法通常称为的一系列的过程涉及验证更改、 协调错误、 与所做的更改，更新数据源和最后刷新现有<xref:System.Data.DataSet>.</xref:System.Data.DataSet>末尾       在客户端应用程序中，很常见的单个按钮，用户可以单击收集更改的数据，并将其发送回中间层组件之前对它进行验证。 在此方案中，<xref:System.Data.DataSet.GetChanges%2A>第一次调用方法。</xref:System.Data.DataSet.GetChanges%2A> 方法将返回第二个<xref:System.Data.DataSet>优化为验证和合并。</xref:System.Data.DataSet> 此第二个<xref:System.Data.DataSet>对象只包含<xref:System.Data.DataTable>和<xref:System.Data.DataRow>对象的已更改，从而导致原始<xref:System.Data.DataSet>.</xref:System.Data.DataSet>的子集</xref:System.Data.DataRow></xref:System.Data.DataTable></xref:System.Data.DataSet> 此子集是通常较小，并因此的详细信息有效地传递回中间层组件。 然后，中间层组件使用通过存储过程的更改更新原始数据源。 然后，中间层可以发送回一个新<xref:System.Data.DataSet>，包括原始数据和数据源的最新数据 （通过再次运行原始查询），或者它可以发送回包含从数据源对其进行任何更改的子集。</xref:System.Data.DataSet> （例如，如果数据源会自动创建唯一的主键值，这些值可以将传播回客户端应用程序。）在任一情况下，返回<xref:System.Data.DataSet>必须合并回客户端应用程序的原始<xref:System.Data.DataSet>与 Merge 方法。</xref:System.Data.DataSet> </xref:System.Data.DataSet>       Merge 方法调用时，这两个架构<xref:System.Data.DataSet>对象进行比较，因为它是可能的架构可能已更改。</xref:System.Data.DataSet> 例如，在企业到企业方案中，新列可能已被添加到 XML 架构一个自动化过程。 如果源<xref:System.Data.DataSet>包含架构元素 (添加<xref:System.Data.DataColumn>对象) 缺少目标中，通过设置，可以将架构元素添加到目标`missingSchemaAction`参数`MissingSchemaAction.Add`。</xref:System.Data.DataColumn> </xref:System.Data.DataSet> 在这种情况下，合并<xref:System.Data.DataSet>包含添加的架构和数据。</xref:System.Data.DataSet>       合并后的架构，则数据将合并。       合并新的源时<xref:System.Data.DataSet>到目标中时，任何源行与<xref:System.Data.DataRowState>值`Unchanged`， `Modified`，或`Deleted`与具有相同的主键值的目标行匹配。</xref:System.Data.DataRowState> </xref:System.Data.DataSet> 源行`DataRowState`值`Added`具有相同作为新的源行的主键值的新目标行匹配。       在合并时，约束被禁用。 如果任何约束不能启用合并，末尾<xref:System.Data.ConstraintException>生成和合并的数据会保留，而会在禁用约束。</xref:System.Data.ConstraintException> 在这种情况下，<xref:System.Data.DataSet.EnforceConstraints%2A>属性设置为`false`，并且无效的所有行均未标记错误。</xref:System.Data.DataSet.EnforceConstraints%2A> 在尝试重置之前，必须解决错误<xref:System.Data.DataSet.EnforceConstraints%2A>属性`true`。</xref:System.Data.DataSet.EnforceConstraints%2A>"
  example:
  - "The following example uses the <xref:System.Data.DataSet.GetChanges%2A>, Update, and Merge methods on a <xref:System.Data.DataSet>.  \n  \n [!code-vb[Classic WebData DataSet.Merge Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.me_2_1.vb)]\n [!code-cs[Classic WebData DataSet.Merge Example#1](~/add/codesnippet/csharp/m-system.data.dataset.me_2_1.cs)]"
  syntax:
    content: public void Merge (System.Data.DataSet dataSet);
    parameters:
    - id: dataSet
      type: System.Data.DataSet
      description: "<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>将合并其数据和架构。"
  overload: System.Data.DataSet.Merge*
  exceptions:
  - type: System.Data.ConstraintException
    commentId: T:System.Data.ConstraintException
    description: "无法启用一个或多个约束。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>dataSet</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Data.DataSet.Merge(System.Data.DataTable)
  id: Merge(System.Data.DataTable)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Merge(DataTable)
  nameWithType: DataSet.Merge(DataTable)
  fullName: System.Data.DataSet.Merge(DataTable)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "合并指定<xref href=&quot;System.Data.DataTable&quot;></xref>到当前及其架构<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  remarks: "<xref:System.Data.DataSet.Merge%2A>方法用于合并两个<xref:System.Data.DataSet>有很大程度上类似的架构的对象。</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 合并通常用于对客户端应用程序，以将数据源的最新的更改合并到现有的<xref:System.Data.DataSet>.</xref:System.Data.DataSet> 这允许客户端应用程序具有刷新<xref:System.Data.DataSet>使用数据源的最新的数据。</xref:System.Data.DataSet>       <xref:System.Data.DataSet.Merge%2A>通常在一系列的过程涉及验证更改、 协调错误、 更新使用所做的更改，数据源和最后刷新现有<xref:System.Data.DataSet>.</xref:System.Data.DataSet>的末尾调用方法</xref:System.Data.DataSet.Merge%2A>       在客户端应用程序中，很常见的单个按钮，用户可以单击收集更改的数据，并将其发送回中间层组件之前对它进行验证。 在此方案中，<xref:System.Data.DataSet.GetChanges%2A>第一次调用方法。</xref:System.Data.DataSet.GetChanges%2A> 方法将返回第二个<xref:System.Data.DataSet>优化为验证和合并。</xref:System.Data.DataSet> 此第二个<xref:System.Data.DataSet>对象只包含<xref:System.Data.DataTable>和<xref:System.Data.DataRow>对象的已更改，从而导致原始<xref:System.Data.DataSet>.</xref:System.Data.DataSet>的子集</xref:System.Data.DataRow></xref:System.Data.DataTable></xref:System.Data.DataSet> 此子集是通常较小，并因此的详细信息有效地传递回中间层组件。 然后，中间层组件使用通过存储过程的更改更新原始数据源。 然后，中间层可以发送回一个新<xref:System.Data.DataSet>，包括原始数据和数据源的最新数据 （通过再次运行原始查询），或者它可以发送回包含从数据源对其进行任何更改的子集。</xref:System.Data.DataSet> （例如，如果数据源会自动创建唯一的主键值，这些值可以将传播回客户端应用程序。）在任一情况下，返回<xref:System.Data.DataSet>必须合并回客户端应用程序的原始<xref:System.Data.DataSet>与<xref:System.Data.DataSet.Merge%2A>方法。</xref:System.Data.DataSet.Merge%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet>       当<xref:System.Data.DataSet.Merge%2A>调用方法时，这两个架构<xref:System.Data.DataSet>对象进行比较，因为它是可能的架构可能已更改。</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 例如，在企业到企业方案中，新列可能已被添加到 XML 架构一个自动化过程。 如果源<xref:System.Data.DataSet>包含架构元素 (添加<xref:System.Data.DataColumn>对象) 缺少目标中，通过设置，可以将架构元素添加到目标`missingSchemaAction`参数`MissingSchemaAction.Add`。</xref:System.Data.DataColumn> </xref:System.Data.DataSet> 在这种情况下，合并<xref:System.Data.DataSet>包含添加的架构和数据。</xref:System.Data.DataSet>       合并后的架构，则数据将合并。       合并新的源时<xref:System.Data.DataSet>到目标中时，任何源行与<xref:System.Data.DataRowState>值`Unchanged`， `Modified`，或`Deleted`与具有相同的主键值的目标行匹配。</xref:System.Data.DataRowState> </xref:System.Data.DataSet> 源行`DataRowState`值`Added`具有相同作为新的源行的主键值的新目标行匹配。       在合并时，约束被禁用。 如果任何约束不能启用合并，末尾<xref:System.Data.ConstraintException>生成和合并的数据会保留，而会在禁用约束。</xref:System.Data.ConstraintException> 在这种情况下，<xref:System.Data.DataSet.EnforceConstraints%2A>属性设置为`false`，并且无效的所有行均未标记错误。</xref:System.Data.DataSet.EnforceConstraints%2A> 在尝试重置之前，必须解决错误<xref:System.Data.DataSet.EnforceConstraints%2A>属性`true`。</xref:System.Data.DataSet.EnforceConstraints%2A>"
  example:
  - "The following example creates a simple <xref:System.Data.DataSet> with one table, two columns, and ten rows. A second <xref:System.Data.DataTable> is created that is identical to the first. Two rows are added to the second table, which is then merged into the <xref:System.Data.DataSet>.  \n  \n [!code-vb[Classic WebData DataSet.Merge3 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.me_1_1.vb)]\n [!code-cs[Classic WebData DataSet.Merge3 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.me_1_1.cs)]"
  syntax:
    content: public void Merge (System.Data.DataTable table);
    parameters:
    - id: table
      type: System.Data.DataTable
      description: "<xref href=&quot;System.Data.DataTable&quot;> </xref>将合并其数据和架构。"
  overload: System.Data.DataSet.Merge*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>table</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)
  id: Merge(System.Data.DataSet,System.Boolean)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Merge(DataSet,Boolean)
  nameWithType: DataSet.Merge(DataSet,Boolean)
  fullName: System.Data.DataSet.Merge(DataSet,Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "合并指定<xref href=&quot;System.Data.DataSet&quot;></xref>到当前及其架构<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>、 保留或放弃这方面的更改<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;></xref>根据给定的自变量。"
  remarks: "<xref:System.Data.DataSet.Merge%2A>方法用于合并两个<xref:System.Data.DataSet>有很大程度上类似的架构的对象。</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 合并通常用于对客户端应用程序，以将数据源的最新的更改合并到现有的<xref:System.Data.DataSet>.</xref:System.Data.DataSet> 这允许客户端应用程序具有刷新<xref:System.Data.DataSet>使用数据源的最新的数据。</xref:System.Data.DataSet>       <xref:System.Data.DataSet.Merge%2A>通常在一系列的过程涉及验证更改、 协调错误、 更新使用所做的更改，数据源和最后刷新现有<xref:System.Data.DataSet>.</xref:System.Data.DataSet>的末尾调用方法</xref:System.Data.DataSet.Merge%2A>       在客户端应用程序中，很常见的单个按钮，用户可以单击收集更改的数据，并将其发送回中间层组件之前对它进行验证。 在此方案中，<xref:System.Data.DataSet.GetChanges%2A>第一次调用方法。</xref:System.Data.DataSet.GetChanges%2A> 方法将返回第二个<xref:System.Data.DataSet>优化为验证和合并。</xref:System.Data.DataSet> 此第二个<xref:System.Data.DataSet>对象只包含<xref:System.Data.DataTable>和<xref:System.Data.DataRow>对象的已更改，从而导致原始<xref:System.Data.DataSet>.</xref:System.Data.DataSet>的子集</xref:System.Data.DataRow></xref:System.Data.DataTable></xref:System.Data.DataSet> 此子集是通常较小，并因此的详细信息有效地传递回中间层组件。 然后，中间层组件使用通过存储过程的更改更新原始数据源。 然后，中间层可以发送回一个新<xref:System.Data.DataSet>，包括原始数据和数据源的最新数据 （通过再次运行原始查询），或者它可以发送回包含从数据源对其进行任何更改的子集。</xref:System.Data.DataSet> （例如，如果数据源会自动创建唯一的主键值，这些值可以将传播回客户端应用程序。）在任一情况下，返回<xref:System.Data.DataSet>必须合并回客户端应用程序的原始<xref:System.Data.DataSet>与<xref:System.Data.DataSet.Merge%2A>方法。</xref:System.Data.DataSet.Merge%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet>       当<xref:System.Data.DataSet.Merge%2A>调用方法时，这两个架构<xref:System.Data.DataSet>对象进行比较，因为它是可能的架构可能已更改。</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 例如，在企业到企业方案中，新列可能已被添加到 XML 架构一个自动化过程。 如果源<xref:System.Data.DataSet>包含架构元素 (添加<xref:System.Data.DataColumn>对象) 缺少目标中，通过设置，可以将架构元素添加到目标`missingSchemaAction`参数`MissingSchemaAction.Add`。</xref:System.Data.DataColumn> </xref:System.Data.DataSet> 在这种情况下，合并<xref:System.Data.DataSet>包含添加的架构和数据。</xref:System.Data.DataSet>       合并后的架构，则数据将合并。       合并新的源时<xref:System.Data.DataSet>到目标中时，任何源行与<xref:System.Data.DataRowState>值`Unchanged`， `Modified`，或`Deleted`与具有相同的主键值的目标行匹配。</xref:System.Data.DataRowState> </xref:System.Data.DataSet> 源行`DataRowState`值`Added`具有相同作为新的源行的主键值的新目标行匹配。       在合并时，约束被禁用。 如果任何约束不能启用合并，末尾<xref:System.Data.ConstraintException>生成和合并的数据会保留，而会在禁用约束。</xref:System.Data.ConstraintException> 在这种情况下，<xref:System.Data.DataSet.EnforceConstraints%2A>属性设置为`false`，并且无效的所有行均未标记错误。</xref:System.Data.DataSet.EnforceConstraints%2A> 在尝试重置之前，必须解决错误<xref:System.Data.DataSet.EnforceConstraints%2A>属性`true`。</xref:System.Data.DataSet.EnforceConstraints%2A>"
  example:
  - "The following example creates a simple <xref:System.Data.DataSet> with one table, two columns, and ten rows. After adding ten rows, two values are changed, and one row is added. A subset of the changed data is created using the <xref:System.Data.DataSet.GetChanges%2A> method. After reconciling errors, the subset data is merged into the original <xref:System.Data.DataSet>.  \n  \n [!code-cs[Classic WebData DataSet.GetChanges Example#1](~/add/codesnippet/csharp/m-system.data.dataset.me_0_1.cs)]\n [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.me_0_1.vb)]"
  syntax:
    content: public void Merge (System.Data.DataSet dataSet, bool preserveChanges);
    parameters:
    - id: dataSet
      type: System.Data.DataSet
      description: "<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>将合并其数据和架构。"
    - id: preserveChanges
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要保留在当前的更改<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.DataSet.Merge*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)
  id: Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Merge(DataRow[],Boolean,MissingSchemaAction)
  nameWithType: DataSet.Merge(DataRow[],Boolean,MissingSchemaAction)
  fullName: System.Data.DataSet.Merge(DataRow[],Boolean,MissingSchemaAction)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "合并的数组<xref href=&quot;System.Data.DataRow&quot;></xref>到当前对象<xref href=&quot;System.Data.DataSet&quot;> </xref>、 保留或放弃更改<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;></xref>和处理根据给定的参数不兼容的架构。"
  remarks: "<xref:System.Data.DataSet.Merge%2A>方法用于合并两个<xref:System.Data.DataSet>有很大程度上类似的架构的对象。</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 合并通常用于对客户端应用程序，以将数据源的最新的更改合并到现有的<xref:System.Data.DataSet>.</xref:System.Data.DataSet> 这允许客户端应用程序具有刷新<xref:System.Data.DataSet>使用数据源的最新的数据。</xref:System.Data.DataSet>       <xref:System.Data.DataSet.Merge%2A>通常在一系列的过程涉及验证更改、 协调错误、 更新使用所做的更改，数据源和最后刷新现有<xref:System.Data.DataSet>.</xref:System.Data.DataSet>的末尾调用方法</xref:System.Data.DataSet.Merge%2A>       在客户端应用程序中，很常见的单个按钮，用户可以单击收集更改的数据，并将其发送回中间层组件之前对它进行验证。 在此方案中，<xref:System.Data.DataSet.GetChanges%2A>第一次调用方法。</xref:System.Data.DataSet.GetChanges%2A> 方法将返回第二个<xref:System.Data.DataSet>优化为验证和合并。</xref:System.Data.DataSet> 此第二个<xref:System.Data.DataSet>对象只包含<xref:System.Data.DataTable>和<xref:System.Data.DataRow>对象的已更改，从而导致原始<xref:System.Data.DataSet>.</xref:System.Data.DataSet>的子集</xref:System.Data.DataRow></xref:System.Data.DataTable></xref:System.Data.DataSet> 此子集是通常较小，并因此的详细信息有效地传递回中间层组件。 然后，中间层组件使用通过存储过程的更改更新原始数据源。 然后，中间层可以发送回一个新<xref:System.Data.DataSet>，包括原始数据和数据源的最新数据 （通过再次运行原始查询），或者它可以发送回包含从数据源对其进行任何更改的子集。</xref:System.Data.DataSet> （例如，如果数据源会自动创建唯一的主键值，这些值可以将传播回客户端应用程序。）在任一情况下，返回<xref:System.Data.DataSet>必须合并回客户端应用程序的原始<xref:System.Data.DataSet>与<xref:System.Data.DataSet.Merge%2A>方法。</xref:System.Data.DataSet.Merge%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet>       为了便于说明<xref:System.Data.DataSet.Merge%2A>方法，我们使用&quot;针对&quot;以表示当前<xref:System.Data.DataSet>，和&quot;源&quot;以命名第二个 （参数） <xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 目标<xref:System.Data.DataSet>之所以如此命名，因为它是在其发生某项操作 （合并） 的对象。</xref:System.Data.DataSet> 第二个<xref:System.Data.DataSet>被称为&quot;源&quot;，因为它包含的信息不会更改，但改为合并到当前<xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataSet>       当<xref:System.Data.DataSet.Merge%2A>调用方法时，这两个架构<xref:System.Data.DataSet>对象进行比较，因为它是可能的架构可能已更改。</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 例如，在企业到企业方案中，新列可能已被添加到 XML 架构一个自动化过程。 如果源<xref:System.Data.DataSet>包含架构元素 (添加<xref:System.Data.DataColumn>对象) 缺少目标中，通过设置，可以将架构元素添加到目标`missingSchemaAction`参数`MissingSchemaAction.Add`。</xref:System.Data.DataColumn> </xref:System.Data.DataSet> 在这种情况下，合并<xref:System.Data.DataSet>包含添加的架构和数据。</xref:System.Data.DataSet>       合并后的架构，则数据将合并。       合并新的源时<xref:System.Data.DataSet>到目标中时，任何源行与<xref:System.Data.DataRowState>值`Unchanged`， `Modified`，或`Deleted`与具有相同的主键值的目标行匹配。</xref:System.Data.DataRowState> </xref:System.Data.DataSet> 源行`DataRowState`值`Added`具有相同作为新的源行的主键值的新目标行匹配。       在合并时，约束被禁用。 如果任何约束不能启用合并，末尾<xref:System.Data.ConstraintException>生成和合并的数据会保留，而会在禁用约束。</xref:System.Data.ConstraintException> 在这种情况下，<xref:System.Data.DataSet.EnforceConstraints%2A>属性设置为`false`，并且无效的所有行均未标记错误。</xref:System.Data.DataSet.EnforceConstraints%2A> 在尝试重置之前，必须解决错误<xref:System.Data.DataSet.EnforceConstraints%2A>属性`true`。</xref:System.Data.DataSet.EnforceConstraints%2A>"
  syntax:
    content: public void Merge (System.Data.DataRow[] rows, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);
    parameters:
    - id: rows
      type: System.Data.DataRow[]
      description: "数组<xref href=&quot;System.Data.DataRow&quot;></xref>对象合并到<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>。"
    - id: preserveChanges
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要保留在更改<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    - id: missingSchemaAction
      type: System.Data.MissingSchemaAction
      description: "之一<xref href=&quot;System.Data.MissingSchemaAction&quot;></xref>值。"
  overload: System.Data.DataSet.Merge*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)
  id: Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Merge(DataSet,Boolean,MissingSchemaAction)
  nameWithType: DataSet.Merge(DataSet,Boolean,MissingSchemaAction)
  fullName: System.Data.DataSet.Merge(DataSet,Boolean,MissingSchemaAction)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "合并指定<xref href=&quot;System.Data.DataSet&quot;></xref>和其架构与当前<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>、 保留或放弃更改在当前<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;></xref>和处理根据给定的参数不兼容的架构。"
  remarks: "<xref:System.Data.DataSet.Merge%2A>方法用于合并两个<xref:System.Data.DataSet>有很大程度上类似的架构的对象。</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 合并通常用于对客户端应用程序，以将数据源的最新的更改合并到现有的<xref:System.Data.DataSet>.</xref:System.Data.DataSet> 这允许客户端应用程序具有刷新<xref:System.Data.DataSet>使用数据源的最新的数据。</xref:System.Data.DataSet>       <xref:System.Data.DataSet.Merge%2A>通常在一系列的过程涉及验证更改、 协调错误、 更新使用所做的更改，数据源和最后刷新现有<xref:System.Data.DataSet>.</xref:System.Data.DataSet>的末尾调用方法</xref:System.Data.DataSet.Merge%2A>       在客户端应用程序中，很常见的单个按钮，用户可以单击收集更改的数据，并将其发送回中间层组件之前对它进行验证。 在此方案中，<xref:System.Data.DataSet.GetChanges%2A>第一次调用方法。</xref:System.Data.DataSet.GetChanges%2A> 方法将返回第二个<xref:System.Data.DataSet>优化为验证和合并。</xref:System.Data.DataSet> 此第二个<xref:System.Data.DataSet>对象只包含<xref:System.Data.DataTable>和<xref:System.Data.DataRow>对象的已更改，从而导致原始<xref:System.Data.DataSet>.</xref:System.Data.DataSet>的子集</xref:System.Data.DataRow></xref:System.Data.DataTable></xref:System.Data.DataSet> 此子集是通常较小，并因此的详细信息有效地传递回中间层组件。 然后，中间层组件使用通过存储过程的更改更新原始数据源。 然后，中间层可以发送回一个新<xref:System.Data.DataSet>，包括原始数据和数据源的最新数据 （通过再次运行原始查询），或者它可以发送回包含从数据源对其进行任何更改的子集。</xref:System.Data.DataSet> （例如，如果数据源会自动创建唯一的主键值，这些值可以将传播回客户端应用程序。）在任一情况下，返回<xref:System.Data.DataSet>必须合并回客户端应用程序的原始<xref:System.Data.DataSet>与<xref:System.Data.DataSet.Merge%2A>方法。</xref:System.Data.DataSet.Merge%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet>       为了便于说明<xref:System.Data.DataSet.Merge%2A>方法，我们使用&quot;针对&quot;以表示当前<xref:System.Data.DataSet>，和&quot;源&quot;以命名第二个 （参数） <xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 目标<xref:System.Data.DataSet>之所以如此命名，因为它是在其发生某项操作 （合并） 的对象。</xref:System.Data.DataSet> 第二个<xref:System.Data.DataSet>被称为&quot;源&quot;，因为它包含的信息不会更改，但改为合并到当前<xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataSet>       当<xref:System.Data.DataSet.Merge%2A>调用方法时，这两个架构<xref:System.Data.DataSet>对象进行比较，因为它是可能的架构可能已更改。</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 例如，在企业到企业方案中，新列可能已被添加到 XML 架构一个自动化过程。 如果源<xref:System.Data.DataSet>包含架构元素 (添加<xref:System.Data.DataColumn>对象) 缺少目标中，通过设置，可以将架构元素添加到目标`missingSchemaAction`参数`MissingSchemaAction.Add`。</xref:System.Data.DataColumn> </xref:System.Data.DataSet> 在这种情况下，合并<xref:System.Data.DataSet>包含添加的架构和数据。</xref:System.Data.DataSet>       合并后的架构，则数据将合并。       合并新的源时<xref:System.Data.DataSet>到目标中时，任何源行与<xref:System.Data.DataRowState>值`Unchanged`， `Modified`，或`Deleted`与具有相同的主键值的目标行匹配。</xref:System.Data.DataRowState> </xref:System.Data.DataSet> 源行`DataRowState`值`Added`具有相同作为新的源行的主键值的新目标行匹配。       在合并时，约束被禁用。 如果任何约束不能启用合并，末尾<xref:System.Data.ConstraintException>生成和合并的数据会保留，而会在禁用约束。</xref:System.Data.ConstraintException> 在这种情况下，<xref:System.Data.DataSet.EnforceConstraints%2A>属性设置为`false`，并且无效的所有行均未标记错误。</xref:System.Data.DataSet.EnforceConstraints%2A> 在尝试重置之前，必须解决错误<xref:System.Data.DataSet.EnforceConstraints%2A>属性`true`。</xref:System.Data.DataSet.EnforceConstraints%2A>"
  example:
  - "The following example creates a simple <xref:System.Data.DataSet> with one table, two columns, and ten rows. Two values are changed, and one row is added. A subset of the changed data is created using the <xref:System.Data.DataSet.GetChanges%2A> method. After reconciling errors, a new column is added to the subset, changing the schema. When the <xref:System.Data.DataSet.Merge%2A> method is called with the `missingSchemaAction` set to `MissingSchemaAction.Add`, the new column is added to the original <xref:System.Data.DataSet> object's schema.  \n  \n [!code-cs[Classic WebData DataSet.Merge2 Example#1](~/add/codesnippet/csharp/e5f91548-401c-49b5-ab4b-_1.cs)]\n [!code-vb[Classic WebData DataSet.Merge2 Example#1](~/add/codesnippet/visualbasic/e5f91548-401c-49b5-ab4b-_1.vb)]"
  syntax:
    content: public void Merge (System.Data.DataSet dataSet, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);
    parameters:
    - id: dataSet
      type: System.Data.DataSet
      description: "<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>将合并其数据和架构。"
    - id: preserveChanges
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要保留在当前的更改<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    - id: missingSchemaAction
      type: System.Data.MissingSchemaAction
      description: "之一<xref href=&quot;System.Data.MissingSchemaAction&quot;></xref>值。"
  overload: System.Data.DataSet.Merge*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>dataSet</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)
  id: Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Merge(DataTable,Boolean,MissingSchemaAction)
  nameWithType: DataSet.Merge(DataTable,Boolean,MissingSchemaAction)
  fullName: System.Data.DataSet.Merge(DataTable,Boolean,MissingSchemaAction)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "合并指定<xref href=&quot;System.Data.DataTable&quot;></xref>到当前及其架构<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>、 保留或放弃更改<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;></xref>和处理根据给定的参数不兼容的架构。"
  remarks: "<xref:System.Data.DataSet.Merge%2A>方法用于合并两个<xref:System.Data.DataSet>有很大程度上类似的架构的对象。</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 合并通常用于对客户端应用程序，以将数据源的最新的更改合并到现有的<xref:System.Data.DataSet>.</xref:System.Data.DataSet> 这允许客户端应用程序具有刷新<xref:System.Data.DataSet>使用数据源的最新的数据。</xref:System.Data.DataSet>       <xref:System.Data.DataSet.Merge%2A>通常在一系列的过程涉及验证更改、 协调错误、 更新使用所做的更改，数据源和最后刷新现有<xref:System.Data.DataSet>.</xref:System.Data.DataSet>的末尾调用方法</xref:System.Data.DataSet.Merge%2A>       离子客户端应用程序，它是通常有一个按钮，用户可以单击它来收集已更改的数据并将其发送回中间层组件之前对它进行验证。 在此方案中，<xref:System.Data.DataSet.GetChanges%2A>第一次调用方法。</xref:System.Data.DataSet.GetChanges%2A> 方法将返回第二个<xref:System.Data.DataSet>优化为验证和合并。</xref:System.Data.DataSet> 此第二个<xref:System.Data.DataSet>对象只包含<xref:System.Data.DataTable>和<xref:System.Data.DataRow>对象的已更改，从而导致原始<xref:System.Data.DataSet>.</xref:System.Data.DataSet>的子集</xref:System.Data.DataRow></xref:System.Data.DataTable></xref:System.Data.DataSet> 此子集是通常较小，并因此的详细信息有效地传递回中间层组件。 然后，中间层组件使用通过存储过程的更改更新原始数据源。 然后，中间层可以发送回一个新<xref:System.Data.DataSet>，包括原始数据和数据源的最新数据 （通过再次运行原始查询），或者它可以发送回包含从数据源对其进行任何更改的子集。</xref:System.Data.DataSet> （例如，如果数据源会自动创建唯一的主键值，这些值可以将传播回客户端应用程序。）在任一情况下，返回<xref:System.Data.DataSet>必须合并回客户端应用程序的原始<xref:System.Data.DataSet>与<xref:System.Data.DataSet.Merge%2A>方法。</xref:System.Data.DataSet.Merge%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet>       当<xref:System.Data.DataSet.Merge%2A>调用方法时，这两个架构<xref:System.Data.DataSet>对象进行比较，因为它是可能的架构可能已更改。</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 例如，在企业到企业方案中，新列可能已被添加到 XML 架构一个自动化过程。 如果源<xref:System.Data.DataSet>包含架构元素 (添加<xref:System.Data.DataColumn>对象) 缺少目标中，通过设置，可以将架构元素添加到目标`missingSchemaAction`参数`MissingSchemaAction.Add`。</xref:System.Data.DataColumn> </xref:System.Data.DataSet> 在这种情况下，合并<xref:System.Data.DataSet>包含添加的架构和数据。</xref:System.Data.DataSet>       合并后的架构，则数据将合并。       合并新的源时<xref:System.Data.DataSet>到目标中时，任何源行与<xref:System.Data.DataRowState>值`Unchanged`， `Modified`，或`Deleted`与具有相同的主键值的目标行匹配。</xref:System.Data.DataRowState> </xref:System.Data.DataSet> 源行`DataRowState`值`Added`具有相同作为新的源行的主键值的新目标行匹配。       在合并时，约束被禁用。 如果任何约束不能启用合并，末尾<xref:System.Data.ConstraintException>生成和合并的数据会保留，而会在禁用约束。</xref:System.Data.ConstraintException> 在这种情况下，<xref:System.Data.DataSet.EnforceConstraints%2A>属性设置为`false`，并且无效的所有行均未标记错误。</xref:System.Data.DataSet.EnforceConstraints%2A> 在尝试重置之前，必须解决错误<xref:System.Data.DataSet.EnforceConstraints%2A>属性`true`。</xref:System.Data.DataSet.EnforceConstraints%2A>"
  example:
  - "The following example creates a simple <xref:System.Data.DataSet> with one table, two columns, and ten rows. A second <xref:System.Data.DataTable> is created that is nearly identical to the first except that a new `DataColumn` is added to the table. Two rows are added to the second table, which is then merged into the <xref:System.Data.DataSet> with the `preserveChanges` argument set to `false`, and the `missingSchemaAction` argument set to `MissingSchemaAction.Add`.  \n  \n [!code-cs[Classic WebData DataSet.Merge4 Example#1](~/add/codesnippet/csharp/a63745f5-1a9e-4fc7-9c61-_1.cs)]\n [!code-vb[Classic WebData DataSet.Merge4 Example#1](~/add/codesnippet/visualbasic/a63745f5-1a9e-4fc7-9c61-_1.vb)]"
  syntax:
    content: public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);
    parameters:
    - id: table
      type: System.Data.DataTable
      description: "<xref uid=&quot;langword_csharp_DataTable&quot; name=&quot;DataTable&quot; href=&quot;&quot;> </xref>将合并其数据和架构。"
    - id: preserveChanges
      type: System.Boolean
      description: "之一<xref href=&quot;System.Data.MissingSchemaAction&quot;></xref>值。"
    - id: missingSchemaAction
      type: System.Data.MissingSchemaAction
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要保留在更改<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.DataSet.Merge*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>dataSet</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Data.DataSet.MergeFailed
  id: MergeFailed
  parent: System.Data.DataSet
  langs:
  - csharp
  name: MergeFailed
  nameWithType: DataSet.MergeFailed
  fullName: System.Data.DataSet.MergeFailed
  type: Event
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "当目标和源时发生<xref href=&quot;System.Data.DataRow&quot;></xref>具有相同的主键值，和<xref:System.Data.DataSet.EnforceConstraints*>设置为 true。</xref:System.Data.DataSet.EnforceConstraints*>"
  remarks: '有关处理事件的详细信息，请参阅[NIB︰ 使用事件](http://msdn.microsoft.com/en-us/01e4f1bc-e55e-413f-98c7-6588493e5f67)。'
  example:
  - "The following example demonstrates the use of the MergeFailed event.  \n  \n [!code-vb[Classic WebData DataSet.MergeFailed Example#1](~/add/codesnippet/visualbasic/e-system.data.dataset.me_1.vb)]\n [!code-cs[Classic WebData DataSet.MergeFailed Example#1](~/add/codesnippet/csharp/e-system.data.dataset.me_1.cs)]"
  syntax:
    content: public event System.Data.MergeFailedEventHandler MergeFailed;
    return:
      type: System.Data.MergeFailedEventHandler
      description: "要添加。"
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Namespace
  id: Namespace
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Namespace
  nameWithType: DataSet.Namespace
  fullName: System.Data.DataSet.Namespace
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "获取或设置的命名空间<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  remarks: "Namespace 属性时读取和写入 XML 文档为使用<xref:System.Data.DataSet>使用<xref:System.Data.DataSet.ReadXml%2A>， <xref:System.Data.DataSet.WriteXml%2A>， <xref:System.Data.DataSet.ReadXmlSchema%2A>，或<xref:System.Data.DataSet.WriteXmlSchema%2A>方法。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet.WriteXml%2A> </xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet>       XML 文档的命名空间用于确定范围 XML 特性和元素时读取到一种<xref:System.Data.DataSet>。</xref:System.Data.DataSet> 例如，如果<xref:System.Data.DataSet>包含架构从一个文档的命名空间&quot;myCompany，&quot;读取和尝试读取数据只能从具有不同的命名空间的文档，则忽略与现有架构不对应的任何数据。</xref:System.Data.DataSet>"
  example:
  - "The following example sets the <xref:System.Data.DataSet.Prefix%2A> before calling the <xref:System.Data.DataSet.ReadXml%2A> method.  \n  \n [!code-vb[Classic WebData DataSet.Namespace Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.na_1.vb)]\n [!code-cs[Classic WebData DataSet.Namespace Example#1](~/add/codesnippet/csharp/p-system.data.dataset.na_1.cs)]"
  syntax:
    content: public string Namespace { get; set; }
    return:
      type: System.String
      description: "命名空间<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  overload: System.Data.DataSet.Namespace*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "命名空间上已有数据。"
  platform:
  - net462
- uid: System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)
  id: OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: OnPropertyChanging(PropertyChangedEventArgs)
  nameWithType: DataSet.OnPropertyChanging(PropertyChangedEventArgs)
  fullName: System.Data.DataSet.OnPropertyChanging(PropertyChangedEventArgs)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "引发 OnPropertyChanging 事件。"
  remarks: '引发事件时，将调用事件处理程序，通过委托。 有关概述，请参阅[NIB︰ 引发事件](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)。'
  syntax:
    content: protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);
    parameters:
    - id: pcevent
      type: System.ComponentModel.PropertyChangedEventArgs
      description: "A<xref:System.ComponentModel.PropertyChangedEventArgs>包含事件数据。</xref:System.ComponentModel.PropertyChangedEventArgs>"
  overload: System.Data.DataSet.OnPropertyChanging*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.OnRemoveRelation(System.Data.DataRelation)
  id: OnRemoveRelation(System.Data.DataRelation)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: OnRemoveRelation(DataRelation)
  nameWithType: DataSet.OnRemoveRelation(DataRelation)
  fullName: System.Data.DataSet.OnRemoveRelation(DataRelation)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "发生时<xref href=&quot;System.Data.DataRelation&quot;></xref>对象删除从<xref href=&quot;System.Data.DataTable&quot;> </xref>。"
  remarks: "应重写此方法由子类限制表被移除。"
  syntax:
    content: protected virtual void OnRemoveRelation (System.Data.DataRelation relation);
    parameters:
    - id: relation
      type: System.Data.DataRelation
      description: "<xref href=&quot;System.Data.DataRelation&quot;> </xref>被删除。"
  overload: System.Data.DataSet.OnRemoveRelation*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.OnRemoveTable(System.Data.DataTable)
  id: OnRemoveTable(System.Data.DataTable)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: OnRemoveTable(DataTable)
  nameWithType: DataSet.OnRemoveTable(DataTable)
  fullName: System.Data.DataSet.OnRemoveTable(DataTable)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "发生时<xref href=&quot;System.Data.DataTable&quot;></xref>从删除<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  remarks: "由子类以限制从要删除的表，可以重写此方法。"
  example:
  - "The following example shows a class derived from the <xref:System.Data.DataSet> with the OnRemoveTable method overridden.  \n  \n [!code-vb[Classic WebData DataSet.OnRemoveTable Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.on_1.vb)]\n [!code-cs[Classic WebData DataSet.OnRemoveTable Example#1](~/add/codesnippet/csharp/m-system.data.dataset.on_1.cs)]"
  syntax:
    content: protected virtual void OnRemoveTable (System.Data.DataTable table);
    parameters:
    - id: table
      type: System.Data.DataTable
      description: "<xref href=&quot;System.Data.DataTable&quot;> </xref>被删除。"
  overload: System.Data.DataSet.OnRemoveTable*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Prefix
  id: Prefix
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Prefix
  nameWithType: DataSet.Prefix
  fullName: System.Data.DataSet.Prefix
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "获取或设置 XML 前缀该别名的命名空间<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  remarks: "前缀属性使用整个 XML 文档来标识元素的命名空间属于<xref:System.Data.DataSet>对象 (通过设置，如同<xref:System.Data.DataSet.Namespace%2A>属性)。</xref:System.Data.DataSet.Namespace%2A> </xref:System.Data.DataSet>"
  example:
  - "The following example sets the Prefix before calling the <xref:System.Data.DataSet.ReadXml%2A> method.  \n  \n [!code-vb[Classic WebData DataSet.Namespace Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.pr_1.vb)]\n [!code-cs[Classic WebData DataSet.Namespace Example#1](~/add/codesnippet/csharp/p-system.data.dataset.pr_1.cs)]"
  syntax:
    content: public string Prefix { get; set; }
    return:
      type: System.String
      description: "XML 前缀<xref href=&quot;System.Data.DataSet&quot;></xref>命名空间。"
  overload: System.Data.DataSet.Prefix*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.RaisePropertyChanging(System.String)
  id: RaisePropertyChanging(System.String)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: RaisePropertyChanging(String)
  nameWithType: DataSet.RaisePropertyChanging(String)
  fullName: System.Data.DataSet.RaisePropertyChanging(String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "发送通知指定<xref href=&quot;System.Data.DataSet&quot;></xref>即将更改的属性。"
  syntax:
    content: protected void RaisePropertyChanging (string name);
    parameters:
    - id: name
      type: System.String
      description: "要更改的属性的名称。"
  overload: System.Data.DataSet.RaisePropertyChanging*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ReadXml(System.IO.Stream)
  id: ReadXml(System.IO.Stream)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXml(Stream)
  nameWithType: DataSet.ReadXml(Stream)
  fullName: System.Data.DataSet.ReadXml(Stream)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "将 XML 架构和数据读入<xref href=&quot;System.Data.DataSet&quot;></xref>使用指定&lt;xref:System.IO.Stream?displayProperty=fullName&gt;。"
  remarks: "<xref:System.Data.DataSet.ReadXml%2A>方法提供方法读取只将数据或数据和架构读入<xref:System.Data.DataSet>从 XML 文档，而<xref:System.Data.DataSet.ReadXmlSchema%2A>方法读取仅的架构。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> 若要读取数据和架构，使用之一`ReadXML`重载，以包括`mode`参数，并将其值设置为`ReadSchema`。       请注意，同样适用于<xref:System.Data.DataSet.WriteXml%2A>和<xref:System.Data.DataSet.WriteXmlSchema%2A>方法，分别。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet.WriteXml%2A> 要写入的 XML 数据，或架构和数据从`DataSet`，使用`WriteXml`方法。 若要编写只为架构，使用`WriteXmlSchema`方法。      1> [!NOTE]&1;><xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>       如果指定内联架构，内联架构用于扩展现有的关系结构之前加载数据。 如果存在任何冲突 （例如，定义具有不同数据类型的同一个表中的相同列） 被引发异常。       如果不指定任何内联架构，则关系结构通过推理，如有必要，扩展根据 XML 文档的结构。 如果无法通过推断扩展架构，才能公开的所有数据，则引发异常。      1> [!NOTE]&1;>`DataSet`不将 XML 元素关联与其对应`DataColumn`或`DataTable`合法的 XML 字符，如 (&quot;_&quot;) 在序列化的 XML 中的转义时。 `DataSet`本身仅为 XML 元素名称中的非法 XML 字符进行转义，因此只能使用相同。 当 XML 元素名称中的合法字符进行转义时，处理时将忽略该元素。       如果 XML 架构<xref:System.Data.DataSet>包括`targetNamespace`，可能无法读取数据，并在调用时，你可能会遇到异常<xref:System.Data.DataSet.ReadXml%2A>加载<xref:System.Data.DataSet>与包含的元素有非限定命名空间的 XML。</xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> 若要读取未限定的元素，设置`elementFormDefault`等于&quot;qualified&quot;中的 XML 架构，如以下示例所示。      ```   <xsd:schema id=&quot;MyDataSet&quot;       elementFormDefault=&quot;qualified&quot;       targetNamespace=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;       xmlns:msdata=&quot;urn:schemas-microsoft-com:xml-msdata&quot;>   </xsd:schema>   ```      > [!NOTE]1> 如果的架构你<xref:System.Data.DataSet>包含元素的名称相同但类型不同，在相同的命名空间，当您尝试将架构读入时引发异常<xref:System.Data.DataSet>与<xref:System.Data.DataSet.ReadXml%2A>通过指定`XmlReadMode.ReadSchema`。</xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet> 如果你使用的.NET Framework 1.0 版，则此异常不会发生。"
  example:
  - "The following example first creates a simple <xref:System.Data.DataSet> with one <xref:System.Data.DataTable>, two columns, and ten rows. The <xref:System.Data.DataSet> schema and data are written to disk by invoking the <xref:System.Data.DataSet.WriteXml%2A> method. A second <xref:System.Data.DataSet> is created and the <xref:System.Data.DataSet.ReadXml%2A> method is used to fill it with schema and data.  \n  \n [!code-cs[Classic WebData DataSet.ReadXml1 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.re_7_1.cs)]\n [!code-vb[Classic WebData DataSet.ReadXml1 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.re_7_1.vb)]"
  syntax:
    content: public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "从<xref:System.IO.Stream>.</xref:System.IO.Stream>派生的对象"
    return:
      type: System.Data.XmlReadMode
      description: "<xref href=&quot;System.Data.XmlReadMode&quot;> </xref>用于读取数据。"
  overload: System.Data.DataSet.ReadXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ReadXml(System.IO.TextReader)
  id: ReadXml(System.IO.TextReader)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXml(TextReader)
  nameWithType: DataSet.ReadXml(TextReader)
  fullName: System.Data.DataSet.ReadXml(TextReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "将 XML 架构和数据读入<xref href=&quot;System.Data.DataSet&quot;></xref>使用指定&lt;xref:System.IO.TextReader?displayProperty=fullName&gt;。"
  remarks: "<xref:System.Data.DataSet.ReadXml%2A>方法提供方法读取只将数据或数据和架构读入<xref:System.Data.DataSet>从 XML 文档，而<xref:System.Data.DataSet.ReadXmlSchema%2A>方法读取仅的架构。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> 若要读取数据和架构，使用之一`ReadXML`重载，以包括`mode`参数，并将其值设置为`ReadSchema`。       请注意，同样适用于<xref:System.Data.DataSet.WriteXml%2A>和<xref:System.Data.DataSet.WriteXmlSchema%2A>方法，分别。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet.WriteXml%2A> 要写入的 XML 数据，或架构和数据从`DataSet`，使用`WriteXml`方法。 若要编写只为架构，使用`WriteXmlSchema`方法。      1> [!NOTE]&1;><xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>       如果指定内联架构，内联架构用于扩展现有的关系结构之前加载数据。 如果存在任何冲突 （例如，定义具有不同数据类型的同一个表中的相同列） 被引发异常。       如果不指定任何内联架构，则关系结构通过推理，如有必要，扩展根据 XML 文档的结构。 如果无法通过推断扩展架构，才能公开的所有数据，则引发异常。      1> [!NOTE]&1;>`DataSet`不将 XML 元素关联与其对应`DataColumn`或`DataTable`合法的 XML 字符，如 (&quot;_&quot;) 在序列化的 XML 中的转义时。 `DataSet`本身仅为 XML 元素名称中的非法 XML 字符进行转义，因此只能使用相同。 当 XML 元素名称中的合法字符进行转义时，处理时将忽略该元素。       如果 XML 架构<xref:System.Data.DataSet>包括`targetNamespace`，可能无法读取数据，并在调用时，你可能会遇到异常<xref:System.Data.DataSet.ReadXml%2A>加载<xref:System.Data.DataSet>与包含的元素有非限定命名空间的 XML。</xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> 若要读取未限定的元素，设置`elementFormDefault`等于&quot;qualified&quot;中的 XML 架构如以下示例所示。      ```   <xsd:schema id=&quot;MyDataSet&quot;       elementFormDefault=&quot;qualified&quot;       targetNamespace=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;       xmlns:msdata=&quot;urn:schemas-microsoft-com:xml-msdata&quot;>   </xsd:schema>   ```继承自的类<xref:System.IO.TextReader>类包括<xref:System.IO.StreamReader>和<xref:System.IO.StringReader>类。</xref:System.IO.StringReader> </xref:System.IO.StreamReader> </xref:System.IO.TextReader>      1> [!NOTE]&1;> 如果的架构你<xref:System.Data.DataSet>包含元素的名称相同但类型不同，在相同的命名空间，当您尝试将架构读入时引发异常<xref:System.Data.DataSet>与<xref:System.Data.DataSet.ReadXml%2A>通过指定`XmlReadMode.ReadSchema`。</xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet> 如果你使用的.NET Framework 1.0 版，则此异常不会发生。"
  example:
  - "The following example first creates a simple <xref:System.Data.DataSet> with one <xref:System.Data.DataTable>, two columns, and ten rows. The <xref:System.Data.DataSet> schema and data are written to disk by invoking the <xref:System.Data.DataSet.WriteXml%2A> method. A second <xref:System.Data.DataSet> is created and the <xref:System.Data.DataSet.ReadXml%2A> method is used to fill it with schema and data.  \n  \n [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.re_3_1.vb)]\n [!code-cs[Classic WebData DataSet.ReadXml2 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.re_3_1.cs)]"
  syntax:
    content: public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);
    parameters:
    - id: reader
      type: System.IO.TextReader
      description: "<xref uid=&quot;langword_csharp_TextReader&quot; name=&quot;TextReader&quot; href=&quot;&quot;> </xref>从中进行读取的架构和数据。"
    return:
      type: System.Data.XmlReadMode
      description: "<xref href=&quot;System.Data.XmlReadMode&quot;> </xref>用于读取数据。"
  overload: System.Data.DataSet.ReadXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ReadXml(System.String)
  id: ReadXml(System.String)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXml(String)
  nameWithType: DataSet.ReadXml(String)
  fullName: System.Data.DataSet.ReadXml(String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "将 XML 架构和数据读入<xref href=&quot;System.Data.DataSet&quot;></xref>使用指定的文件。"
  remarks: "<xref:System.Data.DataSet.ReadXml%2A>方法提供方法读取只将数据或数据和架构读入<xref:System.Data.DataSet>从 XML 文档，而<xref:System.Data.DataSet.ReadXmlSchema%2A>方法读取仅的架构。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> 若要读取数据和架构，使用之一`ReadXML`重载，以包括`mode`参数，并将其值设置为`ReadSchema`。       请注意，同样适用于<xref:System.Data.DataSet.WriteXml%2A>和<xref:System.Data.DataSet.WriteXmlSchema%2A>方法，分别。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet.WriteXml%2A> 要写入的 XML 数据，或架构和数据从`DataSet`，使用`WriteXml`方法。 若要编写只为架构，使用`WriteXmlSchema`方法。      1> [!NOTE]&1;><xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>       如果指定内联架构，内联架构用于扩展现有的关系结构之前加载数据。 如果存在任何冲突 （例如，定义具有不同数据类型的同一个表中的相同列） 被引发异常。       如果不指定任何内联架构，则关系结构通过推理，如有必要，扩展根据 XML 文档的结构。 如果无法通过推断扩展架构，才能公开的所有数据，则引发异常。      1> [!NOTE]&1;>`DataSet`不将 XML 元素关联与其对应`DataColumn`或`DataTable`合法的 XML 字符，如 (&quot;_&quot;) 在序列化的 XML 中的转义时。 `DataSet`本身仅为 XML 元素名称中的非法 XML 字符进行转义，因此只能使用相同。 当 XML 元素名称中的合法字符进行转义时，处理时将忽略该元素。       如果 XML 架构<xref:System.Data.DataSet>包括`targetNamespace`，可能无法读取数据，并在调用时，你可能会遇到异常<xref:System.Data.DataSet.ReadXml%2A>加载<xref:System.Data.DataSet>与包含的元素有非限定命名空间的 XML。</xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> 若要读取未限定的元素，设置`elementFormDefault`等于&quot;qualified&quot;中的 XML 架构如以下示例所示。      ```   <xsd:schema id=&quot;MyDataSet&quot;       elementFormDefault=&quot;qualified&quot;       targetNamespace=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;       xmlns:msdata=&quot;urn:schemas-microsoft-com:xml-msdata&quot;>   </xsd:schema>   ```      > [!NOTE]1> 如果的架构你<xref:System.Data.DataSet>包含元素的名称相同但类型不同，在相同的命名空间，当您尝试将架构读入时引发异常<xref:System.Data.DataSet>与<xref:System.Data.DataSet.ReadXml%2A>通过指定`XmlReadMode.ReadSchema`。</xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet> 如果你使用的.NET Framework 1.0 版，则此异常不会发生。"
  example:
  - "The following example first creates a simple <xref:System.Data.DataSet> with one <xref:System.Data.DataTable>, two columns, and ten rows. The <xref:System.Data.DataSet> schema and data are written to disk by invoking the <xref:System.Data.DataSet.WriteXml%2A> method. A second <xref:System.Data.DataSet> is created and the <xref:System.Data.DataSet.ReadXml%2A> method is used to fill it with schema and data.  \n  \n [!code-cs[Classic WebData DataSet.ReadXml3 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.re_1_1.cs)]\n [!code-vb[Classic WebData DataSet.ReadXml3 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.re_1_1.vb)]"
  syntax:
    content: public System.Data.XmlReadMode ReadXml (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "要从其中读取文件名 （包括路径）。"
    return:
      type: System.Data.XmlReadMode
      description: "<xref uid=&quot;langword_csharp_XmlReadMode&quot; name=&quot;XmlReadMode&quot; href=&quot;&quot;> </xref>用于读取数据。"
  overload: System.Data.DataSet.ReadXml*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<xref href=&quot;System.Security.Permissions.FileIOPermission&quot;></xref>未设置为<xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>。"
  platform:
  - net462
- uid: System.Data.DataSet.ReadXml(System.Xml.XmlReader)
  id: ReadXml(System.Xml.XmlReader)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXml(XmlReader)
  nameWithType: DataSet.ReadXml(XmlReader)
  fullName: System.Data.DataSet.ReadXml(XmlReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "将 XML 架构和数据读入<xref href=&quot;System.Data.DataSet&quot;></xref>使用指定&lt;xref:System.Xml.XmlReader?displayProperty=fullName&gt;。"
  remarks: "ReadXml 方法提供方法读取只将数据或数据和架构读入<xref:System.Data.DataSet>从 XML 文档，而<xref:System.Data.DataSet.ReadXmlSchema%2A>方法读取仅的架构。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet> 若要读取数据和架构，使用之一`ReadXML`重载，以包括`mode`参数，并将其值设置为`ReadSchema`。       请注意，同样适用于<xref:System.Data.DataSet.WriteXml%2A>和<xref:System.Data.DataSet.WriteXmlSchema%2A>方法，分别。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet.WriteXml%2A> 要写入的 XML 数据，或架构和数据从`DataSet`，使用`WriteXml`方法。 若要编写只为架构，使用`WriteXmlSchema`方法。      1> [!NOTE]&1;><xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>       如果指定内联架构，内联架构用于扩展现有的关系结构之前加载数据。 如果存在任何冲突 （例如，定义具有不同数据类型的同一个表中的相同列） 被引发异常。       如果不指定任何内联架构，则关系结构通过推理，如有必要，扩展根据 XML 文档的结构。 如果无法通过推断扩展架构，才能公开的所有数据，则引发异常。      1> [!NOTE]&1;>`DataSet`不将 XML 元素关联与其对应`DataColumn`或`DataTable`合法的 XML 字符，如 (&quot;_&quot;) 在序列化的 XML 中的转义时。 `DataSet`本身仅为 XML 元素名称中的非法 XML 字符进行转义，因此只能使用相同。 当 XML 元素名称中的合法字符进行转义时，处理时将忽略该元素。       如果 XML 架构<xref:System.Data.DataSet>包括`targetNamespace`、 不能读取数据，且调用 ReadXml 加载时，你可能会遇到异常<xref:System.Data.DataSet>与包含的元素有非限定命名空间的 XML。</xref:System.Data.DataSet> </xref:System.Data.DataSet> 若要读取未限定的元素，设置`elementFormDefault`等于&quot;qualified&quot;中的 XML 架构如以下示例所示。      ```   <xsd:schema id=&quot;MyDataSet&quot;       elementFormDefault=&quot;qualified&quot;       targetNamespace=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;       xmlns:msdata=&quot;urn:schemas-microsoft-com:xml-msdata&quot;>   </xsd:schema>   ```       <xref:System.Xml.XmlTextReader?displayProperty=fullName>继承自<xref:System.Xml.XmlReader>.</xref:System.Xml.XmlReader></xref:System.Xml.XmlTextReader?displayProperty=fullName>      1> [!NOTE]&1;> 如果的架构你<xref:System.Data.DataSet>包含元素的名称相同但类型不同，在相同的命名空间，当您尝试将架构读入时引发异常<xref:System.Data.DataSet>使用通过指定 ReadXml `XmlReadMode.ReadSchema`。</xref:System.Data.DataSet> </xref:System.Data.DataSet> 如果你使用的.NET Framework 1.0 版，则此异常不会发生。"
  example:
  - "The following example first creates a simple <xref:System.Data.DataSet> with one <xref:System.Data.DataTable>, two columns, and ten rows. The <xref:System.Data.DataSet> schema and data are written to disk by invoking the <xref:System.Data.DataSet.WriteXml%2A> method. A second <xref:System.Data.DataSet> is created and the ReadXml method is used to fill it with schema and data.  \n  \n [!code-cs[Classic WebData DataSet.ReadXml Example#1](~/add/codesnippet/csharp/m-system.data.dataset.re_2_1.cs)]\n [!code-vb[Classic WebData DataSet.ReadXml Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.re_2_1.vb)]"
  syntax:
    content: public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "<xref:System.Xml.XmlReader>从中进行读取。</xref:System.Xml.XmlReader>"
    return:
      type: System.Data.XmlReadMode
      description: "<xref uid=&quot;langword_csharp_XmlReadMode&quot; name=&quot;XmlReadMode&quot; href=&quot;&quot;> </xref>用于读取数据。"
  overload: System.Data.DataSet.ReadXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)
  id: ReadXml(System.IO.Stream,System.Data.XmlReadMode)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXml(Stream,XmlReadMode)
  nameWithType: DataSet.ReadXml(Stream,XmlReadMode)
  fullName: System.Data.DataSet.ReadXml(Stream,XmlReadMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "将 XML 架构和数据读入<xref href=&quot;System.Data.DataSet&quot;></xref>使用指定&lt;xref:System.IO.Stream?displayProperty=fullName&gt;和<xref href=&quot;System.Data.XmlReadMode&quot;> </xref>。"
  remarks: "<xref:System.Data.DataSet.ReadXml%2A>方法提供方法读取只将数据或数据和架构读入<xref:System.Data.DataSet>从 XML 文档，而<xref:System.Data.DataSet.ReadXmlSchema%2A>方法读取仅的架构。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> 若要读取数据和架构，使用之一`ReadXML`重载，以包括`mode`参数，并将其值设置为`ReadSchema`。       同样适用于<xref:System.Data.DataSet.WriteXml%2A>和<xref:System.Data.DataSet.WriteXmlSchema%2A>方法，分别。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet.WriteXml%2A> 要写入的 XML 数据，或架构和数据从`DataSet`，使用`WriteXml`方法。 若要编写只为架构，使用`WriteXmlSchema`方法。      1> [!NOTE]&1;> 使用 ReadXml 和你设置时<xref:System.Data.XmlReadMode>到`Diffgram`，目标的内容`DataSet`和原始`DataSet`由于生成和处理 diffgram 的方式可能不同。</xref:System.Data.XmlReadMode> 有关 diffgram 的详细信息，请参阅[Diffgram](~/add/includes/ajax-current-ext-md.md)。      1> [!NOTE]&1;><xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>       如果指定内联架构，内联架构用于扩展现有的关系结构之前加载数据。 如果存在任何冲突 （例如，定义具有不同数据类型的同一个表中的相同列） 被引发异常。       如果不指定任何内联架构，则关系结构通过推理，如有必要，扩展根据 XML 文档的结构。 如果无法通过推断扩展架构，才能公开的所有数据，则引发异常。      1> [!NOTE]&1;>`DataSet`不将 XML 元素关联与其对应`DataColumn`或`DataTable`合法的 XML 字符，如 (&quot;_&quot;) 在序列化的 XML 中的转义时。 `DataSet`本身仅为 XML 元素名称中的非法 XML 字符进行转义，因此只能使用相同。 当 XML 元素名称中的合法字符进行转义时，处理时将忽略该元素。       如果 XML 架构<xref:System.Data.DataSet>包括`targetNamespace`，可能无法读取数据，并在调用时，你可能会遇到异常<xref:System.Data.DataSet.ReadXml%2A>加载<xref:System.Data.DataSet>与包含的元素有非限定命名空间的 XML。</xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> 若要读取未限定的元素，设置`elementFormDefault`等于&quot;qualified&quot;中的 XML 架构如以下示例所示。      ```   <xsd:schema id=&quot;MyDataSet&quot;       elementFormDefault=&quot;qualified&quot;       targetNamespace=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;       xmlns:msdata=&quot;urn:schemas-microsoft-com:xml-msdata&quot;>   </xsd:schema>   ```      > [!NOTE]1> 如果的架构你<xref:System.Data.DataSet>包含元素的名称相同但类型不同，在相同的命名空间，当您尝试将架构读入时引发异常<xref:System.Data.DataSet>与<xref:System.Data.DataSet.ReadXml%2A>通过指定`XmlReadMode.ReadSchema`。</xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet> 如果你使用的.NET Framework 1.0 版，则此异常不会发生。"
  syntax:
    content: public System.Data.XmlReadMode ReadXml (System.IO.Stream stream, System.Data.XmlReadMode mode);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "<xref:System.IO.Stream>从中进行读取。</xref:System.IO.Stream>"
    - id: mode
      type: System.Data.XmlReadMode
      description: "之一<xref href=&quot;System.Data.XmlReadMode&quot;></xref>值。"
    return:
      type: System.Data.XmlReadMode
      description: "<xref uid=&quot;langword_csharp_XmlReadMode&quot; name=&quot;XmlReadMode&quot; href=&quot;&quot;> </xref>用于读取数据。"
  overload: System.Data.DataSet.ReadXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)
  id: ReadXml(System.IO.TextReader,System.Data.XmlReadMode)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXml(TextReader,XmlReadMode)
  nameWithType: DataSet.ReadXml(TextReader,XmlReadMode)
  fullName: System.Data.DataSet.ReadXml(TextReader,XmlReadMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "将 XML 架构和数据读入<xref href=&quot;System.Data.DataSet&quot;></xref>使用指定&lt;xref:System.IO.TextReader?displayProperty=fullName&gt;和<xref href=&quot;System.Data.XmlReadMode&quot;> </xref>。"
  remarks: "<xref:System.Data.DataSet.ReadXml%2A>方法提供方法读取只将数据或数据和架构读入<xref:System.Data.DataSet>从 XML 文档，而<xref:System.Data.DataSet.ReadXmlSchema%2A>方法读取仅的架构。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> 若要读取数据和架构，使用之一`ReadXML`重载，以包括`mode`参数，并将其值设置为`ReadSchema`。       请注意，同样适用于<xref:System.Data.DataSet.WriteXml%2A>和<xref:System.Data.DataSet.WriteXmlSchema%2A>方法，分别。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet.WriteXml%2A> 要写入的 XML 数据，或架构和数据从`DataSet`，使用`WriteXml`方法。 若要编写只为架构，使用`WriteXmlSchema`方法。      1> [!NOTE]&1;><xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>       如果指定内联架构，内联架构用于扩展现有的关系结构之前加载数据。 如果存在任何冲突 （例如，定义具有不同数据类型的同一个表中的相同列） 被引发异常。       如果不指定任何内联架构，则关系结构通过推理，如有必要，扩展根据 XML 文档的结构。 如果无法通过推断扩展架构，才能公开的所有数据，则引发异常。      1> [!NOTE]&1;>`DataSet`不将 XML 元素关联与其对应`DataColumn`或`DataTable`合法的 XML 字符，如 (&quot;_&quot;) 在序列化的 XML 中的转义时。 `DataSet`本身仅为 XML 元素名称中的非法 XML 字符进行转义，因此只能使用相同。 当 XML 元素名称中的合法字符进行转义时，处理时将忽略该元素。       如果 XML 架构<xref:System.Data.DataSet>包括`targetNamespace`，可能无法读取数据，并在调用时，你可能会遇到异常<xref:System.Data.DataSet.ReadXml%2A>加载<xref:System.Data.DataSet>与包含的元素有非限定命名空间的 XML。</xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> 若要读取未限定的元素，设置`elementFormDefault`等于&quot;qualified&quot;中的 XML 架构如以下示例所示。      ```   <xsd:schema id=&quot;MyDataSet&quot;       elementFormDefault=&quot;qualified&quot;       targetNamespace=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;       xmlns:msdata=&quot;urn:schemas-microsoft-com:xml-msdata&quot;>   </xsd:schema>   ```      > [!NOTE]1> 如果的架构你<xref:System.Data.DataSet>包含元素的名称相同但类型不同，在相同的命名空间，当您尝试将架构读入时引发异常<xref:System.Data.DataSet>与<xref:System.Data.DataSet.ReadXml%2A>通过指定`XmlReadMode.ReadSchema`。</xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet> 如果你使用的.NET Framework 1.0 版，则此异常不会发生。"
  syntax:
    content: public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader, System.Data.XmlReadMode mode);
    parameters:
    - id: reader
      type: System.IO.TextReader
      description: "<xref:System.IO.TextReader>从中进行读取。</xref:System.IO.TextReader>"
    - id: mode
      type: System.Data.XmlReadMode
      description: "之一<xref href=&quot;System.Data.XmlReadMode&quot;></xref>值。"
    return:
      type: System.Data.XmlReadMode
      description: "<xref uid=&quot;langword_csharp_XmlReadMode&quot; name=&quot;XmlReadMode&quot; href=&quot;&quot;> </xref>用于读取数据。"
  overload: System.Data.DataSet.ReadXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)
  id: ReadXml(System.String,System.Data.XmlReadMode)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXml(String,XmlReadMode)
  nameWithType: DataSet.ReadXml(String,XmlReadMode)
  fullName: System.Data.DataSet.ReadXml(String,XmlReadMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "将 XML 架构和数据读入<xref href=&quot;System.Data.DataSet&quot;></xref>使用指定的文件和<xref href=&quot;System.Data.XmlReadMode&quot;> </xref>。"
  remarks: "<xref:System.Data.DataSet.ReadXml%2A>方法提供方法读取只将数据或数据和架构读入<xref:System.Data.DataSet>从 XML 文档，而<xref:System.Data.DataSet.ReadXmlSchema%2A>方法读取仅的架构。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> 若要读取数据和架构，使用之一`ReadXML`重载，以包括`mode`参数，并将其值设置为`ReadSchema`。       请注意，同样适用于<xref:System.Data.DataSet.WriteXml%2A>和<xref:System.Data.DataSet.WriteXmlSchema%2A>方法，分别。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet.WriteXml%2A> 要写入的 XML 数据，或架构和数据从`DataSet`，使用`WriteXml`方法。 若要编写只为架构，使用`WriteXmlSchema`方法。      1> [!NOTE]&1;><xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>       如果指定内联架构，内联架构用于扩展现有的关系结构之前加载数据。 如果存在任何冲突 （例如，定义具有不同数据类型的同一个表中的相同列） 被引发异常。       如果不指定任何内联架构，则关系结构通过推理，如有必要，扩展根据 XML 文档的结构。 如果无法通过推断扩展架构，才能公开的所有数据，则引发异常。      1> [!NOTE]&1;>`DataSet`不将 XML 元素关联与其对应`DataColumn`或`DataTable`合法的 XML 字符，如 (&quot;_&quot;) 在序列化的 XML 中的转义时。 `DataSet`本身仅为 XML 元素名称中的非法 XML 字符进行转义，因此只能使用相同。 当 XML 元素名称中的合法字符进行转义时，处理时将忽略该元素。       如果 XML 架构<xref:System.Data.DataSet>包括`targetNamespace`，可能无法读取数据，并在调用时，你可能会遇到异常<xref:System.Data.DataSet.ReadXml%2A>加载<xref:System.Data.DataSet>与包含的元素有非限定命名空间的 XML。</xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> 若要读取未限定的元素，设置`elementFormDefault`等于&quot;qualified&quot;中的 XML 架构如以下示例所示。      ```   <xsd:schema id=&quot;MyDataSet&quot;       elementFormDefault=&quot;qualified&quot;       targetNamespace=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;       xmlns:msdata=&quot;urn:schemas-microsoft-com:xml-msdata&quot;>   </xsd:schema>   ```      > [!NOTE]1> 如果的架构你<xref:System.Data.DataSet>包含元素的名称相同但类型不同，在相同的命名空间，当您尝试将架构读入时引发异常<xref:System.Data.DataSet>与<xref:System.Data.DataSet.ReadXml%2A>通过指定`XmlReadMode.ReadSchema`。</xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet> 如果你使用的.NET Framework 1.0 版，则此异常不会发生。"
  syntax:
    content: public System.Data.XmlReadMode ReadXml (string fileName, System.Data.XmlReadMode mode);
    parameters:
    - id: fileName
      type: System.String
      description: "要从其中读取文件名 （包括路径）。"
    - id: mode
      type: System.Data.XmlReadMode
      description: "之一<xref href=&quot;System.Data.XmlReadMode&quot;></xref>值。"
    return:
      type: System.Data.XmlReadMode
      description: "<xref uid=&quot;langword_csharp_XmlReadMode&quot; name=&quot;XmlReadMode&quot; href=&quot;&quot;> </xref>用于读取数据。"
  overload: System.Data.DataSet.ReadXml*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<xref href=&quot;System.Security.Permissions.FileIOPermission&quot;></xref>未设置为<xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>。"
  platform:
  - net462
- uid: System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)
  id: ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXml(XmlReader,XmlReadMode)
  nameWithType: DataSet.ReadXml(XmlReader,XmlReadMode)
  fullName: System.Data.DataSet.ReadXml(XmlReader,XmlReadMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "将 XML 架构和数据读入<xref href=&quot;System.Data.DataSet&quot;></xref>使用指定&lt;xref:System.Xml.XmlReader?displayProperty=fullName&gt;和<xref href=&quot;System.Data.XmlReadMode&quot;> </xref>。"
  remarks: "<xref:System.Data.DataSet.ReadXml%2A>方法提供方法读取只将数据或数据和架构读入<xref:System.Data.DataSet>从 XML 文档，而<xref:System.Data.DataSet.ReadXmlSchema%2A>方法读取仅的架构。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> 若要读取数据和架构，使用之一`ReadXML`重载，以包括`mode`参数，并将其值设置为`ReadSchema`。       请注意，同样适用于<xref:System.Data.DataSet.WriteXml%2A>和<xref:System.Data.DataSet.WriteXmlSchema%2A>方法，分别。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet.WriteXml%2A> 要写入的 XML 数据，或架构和数据从`DataSet`，使用`WriteXml`方法。 若要编写只为架构，使用`WriteXmlSchema`方法。      1> [!NOTE]&1;><xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>       如果指定内联架构，内联架构用于扩展现有的关系结构之前加载数据。 如果存在任何冲突 （例如，定义具有不同数据类型的同一个表中的相同列） 被引发异常。       如果不指定任何内联架构，则关系结构通过推理，如有必要，扩展根据 XML 文档的结构。 如果无法通过推断扩展架构，才能公开的所有数据，则引发异常。      1> [!NOTE]&1;>`DataSet`不将 XML 元素关联与其对应`DataColumn`或`DataTable`合法的 XML 字符，如 (&quot;_&quot;) 在序列化的 XML 中的转义时。 `DataSet`本身仅为 XML 元素名称中的非法 XML 字符进行转义，因此只能使用相同。 当 XML 元素名称中的合法字符进行转义时，处理时将忽略该元素。       如果 XML 架构<xref:System.Data.DataSet>包括`targetNamespace`，可能无法读取数据，并在调用时，你可能会遇到异常<xref:System.Data.DataSet.ReadXml%2A>加载<xref:System.Data.DataSet>与包含的元素有非限定命名空间的 XML。</xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> 若要读取未限定的元素，设置`elementFormDefault`等于&quot;qualified&quot;中的 XML 架构如以下示例所示。      ```   <xsd:schema id=&quot;MyDataSet&quot;       elementFormDefault=&quot;qualified&quot;       targetNamespace=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;       xmlns:msdata=&quot;urn:schemas-microsoft-com:xml-msdata&quot;>   </xsd:schema>   ```      > [!NOTE]1> 如果的架构你<xref:System.Data.DataSet>包含元素的名称相同但类型不同，在相同的命名空间，当您尝试将架构读入时引发异常<xref:System.Data.DataSet>与<xref:System.Data.DataSet.ReadXml%2A>通过指定`XmlReadMode.ReadSchema`。</xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet> 如果你使用的.NET Framework 1.0 版，则此异常不会发生。"
  syntax:
    content: public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader, System.Data.XmlReadMode mode);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "<xref:System.Xml.XmlReader>从中进行读取。</xref:System.Xml.XmlReader>"
    - id: mode
      type: System.Data.XmlReadMode
      description: "之一<xref href=&quot;System.Data.XmlReadMode&quot;></xref>值。"
    return:
      type: System.Data.XmlReadMode
      description: "<xref uid=&quot;langword_csharp_XmlReadMode&quot; name=&quot;XmlReadMode&quot; href=&quot;&quot;> </xref>用于读取数据。"
  overload: System.Data.DataSet.ReadXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ReadXmlSchema(System.IO.Stream)
  id: ReadXmlSchema(System.IO.Stream)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXmlSchema(Stream)
  nameWithType: DataSet.ReadXmlSchema(Stream)
  fullName: System.Data.DataSet.ReadXmlSchema(Stream)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "从指定读取 XML 架构<xref:System.IO.Stream>到<xref href=&quot;System.Data.DataSet&quot;> </xref>。</xref:System.IO.Stream>"
  remarks: "使用<xref:System.Data.DataSet.ReadXmlSchema%2A>方法来创建一种<xref:System.Data.DataSet>。</xref:System.Data.DataSet>的架构</xref:System.Data.DataSet.ReadXmlSchema%2A> 架构包含表、 关系和约束定义。 若要写入到 XML 文档的架构，使用<xref:System.Data.DataSet.WriteXmlSchema%2A>方法。</xref:System.Data.DataSet.WriteXmlSchema%2A>       使用 XSD 标准编写 XML 架构。      1> [!NOTE]&1;> 如果 msdata:DataType 和 xs:type 类型不匹配，则会发生数据损坏。 会不引发任何异常。       <xref:System.Data.DataSet.ReadXmlSchema%2A>通常在调用该<xref:System.Data.DataSet.ReadXml%2A>方法用于填充<xref:System.Data.DataSet>.</xref:System.Data.DataSet></xref:System.Data.DataSet.ReadXml%2A>之前调用方法</xref:System.Data.DataSet.ReadXmlSchema%2A>       派生自的类<xref:System.IO.Stream>类包括<xref:System.IO.BufferedStream>， <xref:System.IO.FileStream>， <xref:System.IO.MemoryStream>，和<xref:System.Net.Sockets.NetworkStream>。</xref:System.Net.Sockets.NetworkStream> </xref:System.IO.MemoryStream> </xref:System.IO.FileStream> </xref:System.IO.BufferedStream> </xref:System.IO.Stream>      1> [!NOTE]&1;> 如果的架构你<xref:System.Data.DataSet>包含元素的名称相同但类型不同，在相同的命名空间，当你尝试读取到<xref:System.Data.DataSet><xref:System.Data.DataSet.ReadXmlSchema%2A>。</xref:System.Data.DataSet.ReadXmlSchema%2A></xref:System.Data.DataSet>的架构引发异常</xref:System.Data.DataSet> 如果你使用的.NET Framework 1.0 版，则此异常不会发生。"
  example:
  - "The following example creates a <xref:System.IO.FileStream> object to read an XML schema with, and invokes the <xref:System.Data.DataSet.ReadXmlSchema%2A> method with the object.  \n  \n [!code-cs[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.re_5_1.cs)]\n [!code-vb[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.re_5_1.vb)]"
  syntax:
    content: public void ReadXmlSchema (System.IO.Stream stream);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "<xref:System.IO.Stream>从中进行读取。</xref:System.IO.Stream>"
  overload: System.Data.DataSet.ReadXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)
  id: ReadXmlSchema(System.IO.TextReader)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXmlSchema(TextReader)
  nameWithType: DataSet.ReadXmlSchema(TextReader)
  fullName: System.Data.DataSet.ReadXmlSchema(TextReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "从指定读取 XML 架构<xref:System.IO.TextReader>到<xref href=&quot;System.Data.DataSet&quot;> </xref>。</xref:System.IO.TextReader>"
  remarks: "使用<xref:System.Data.DataSet.ReadXmlSchema%2A>方法来创建一种<xref:System.Data.DataSet>。</xref:System.Data.DataSet>的架构</xref:System.Data.DataSet.ReadXmlSchema%2A> 架构包含表、 关系和约束定义。 若要写入到 XML 文档的架构，使用<xref:System.Data.DataSet.WriteXmlSchema%2A>方法。</xref:System.Data.DataSet.WriteXmlSchema%2A>       使用 XSD 标准编写 XML 架构。      1> [!NOTE]&1;> 如果 msdata:DataType 和 xs:type 类型不匹配，则会发生数据损坏。 会不引发任何异常。       <xref:System.Data.DataSet.ReadXmlSchema%2A>通常在调用该<xref:System.Data.DataSet.ReadXml%2A>方法用于填充<xref:System.Data.DataSet>.</xref:System.Data.DataSet></xref:System.Data.DataSet.ReadXml%2A>之前调用方法</xref:System.Data.DataSet.ReadXmlSchema%2A>       继承自的类<xref:System.IO.TextReader>类包括<xref:System.IO.StreamReader>和<xref:System.IO.StringReader>类。</xref:System.IO.StringReader> </xref:System.IO.StreamReader> </xref:System.IO.TextReader>      1> [!NOTE]&1;> 如果的架构你<xref:System.Data.DataSet>包含元素的名称相同但类型不同，在相同的命名空间，当你尝试读取到<xref:System.Data.DataSet><xref:System.Data.DataSet.ReadXmlSchema%2A>。</xref:System.Data.DataSet.ReadXmlSchema%2A></xref:System.Data.DataSet>的架构引发异常</xref:System.Data.DataSet> 如果你使用的.NET Framework 1.0 版，则此异常不会发生。"
  example:
  - "The following example creates a <xref:System.IO.StreamReader> object to read a schema with, and invokes the <xref:System.Data.DataSet.ReadXmlSchema%2A> method with the object.  \n  \n [!code-vb[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.re_8_1.vb)]\n [!code-cs[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.re_8_1.cs)]"
  syntax:
    content: public void ReadXmlSchema (System.IO.TextReader reader);
    parameters:
    - id: reader
      type: System.IO.TextReader
      description: "<xref:System.IO.TextReader>从中进行读取。</xref:System.IO.TextReader>"
  overload: System.Data.DataSet.ReadXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ReadXmlSchema(System.String)
  id: ReadXmlSchema(System.String)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXmlSchema(String)
  nameWithType: DataSet.ReadXmlSchema(String)
  fullName: System.Data.DataSet.ReadXmlSchema(String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "从到指定的文件中读取的 XML 架构<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  remarks: "使用<xref:System.Data.DataSet.ReadXmlSchema%2A>方法来创建一种<xref:System.Data.DataSet>。</xref:System.Data.DataSet>的架构</xref:System.Data.DataSet.ReadXmlSchema%2A> 架构包含表、 关系和约束定义。 若要写入到 XML 文档的架构，使用<xref:System.Data.DataSet.WriteXmlSchema%2A>方法。</xref:System.Data.DataSet.WriteXmlSchema%2A>       使用 XSD 标准编写 XML 架构。      1> [!NOTE]&1;> 如果 msdata:DataType 和 xs:type 类型不匹配，则会发生数据损坏。 会不引发任何异常。       <xref:System.Data.DataSet.ReadXmlSchema%2A>通常在调用该<xref:System.Data.DataSet.ReadXml%2A>方法用于填充<xref:System.Data.DataSet>.</xref:System.Data.DataSet></xref:System.Data.DataSet.ReadXml%2A>之前调用方法</xref:System.Data.DataSet.ReadXmlSchema%2A>      1> [!NOTE]&1;> 如果的架构你<xref:System.Data.DataSet>包含元素的名称相同但类型不同，在相同的命名空间，当您尝试读取到<xref:System.Data.DataSet><xref:System.Data.DataSet.ReadXmlSchema%2A>。</xref:System.Data.DataSet.ReadXmlSchema%2A></xref:System.Data.DataSet>的架构时引发异常</xref:System.Data.DataSet> 如果你使用的.NET Framework 1.0 版，则此异常不会发生。"
  example:
  - >-
    [!code-cs[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.re_0_1.cs)]
     [!code-vb[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.re_0_1.vb)]
  syntax:
    content: public void ReadXmlSchema (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "文件名称 （包括路径），从中进行读取。"
  overload: System.Data.DataSet.ReadXmlSchema*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<xref href=&quot;System.Security.Permissions.FileIOPermission&quot;></xref>未设置为<xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>。"
  platform:
  - net462
- uid: System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)
  id: ReadXmlSchema(System.Xml.XmlReader)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXmlSchema(XmlReader)
  nameWithType: DataSet.ReadXmlSchema(XmlReader)
  fullName: System.Data.DataSet.ReadXmlSchema(XmlReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "从指定读取 XML 架构<xref:System.Xml.XmlReader>到<xref href=&quot;System.Data.DataSet&quot;> </xref>。</xref:System.Xml.XmlReader>"
  remarks: "ReadXmlSchema 方法用于创建一种<xref:System.Data.DataSet>。</xref:System.Data.DataSet>的架构 架构包含表、 关系和约束定义。       使用 XSD 标准编写 XML 架构。      1> [!NOTE]&1;> 如果 msdata:DataType 和 xs:type 类型不匹配，则会发生数据损坏。 会不引发任何异常。       <xref:System.Data.DataSet.ReadXml%2A>用于填充<xref:System.Data.DataSet>.</xref:System.Data.DataSet>方法</xref:System.Data.DataSet.ReadXml%2A>之前调用通常调用 ReadXmlSchema 方法       <xref:System.Xml.XmlReader?displayProperty=fullName>类为抽象类。</xref:System.Xml.XmlReader?displayProperty=fullName> 继承自的类`XmlReader`是<xref:System.Xml.XmlTextReader?displayProperty=fullName>类。</xref:System.Xml.XmlTextReader?displayProperty=fullName>      1> [!NOTE]&1;> 如果的架构你<xref:System.Data.DataSet>包含元素的名称相同但类型不同，在相同的命名空间，当你尝试将架构读入引发异常<xref:System.Data.DataSet>与 ReadXmlSchema。</xref:System.Data.DataSet> </xref:System.Data.DataSet> 如果你使用的.NET Framework 1.0 版，则此异常不会发生。"
  example:
  - "The following example creates a new <xref:System.Data.DataSet> and <xref:System.IO.FileStream?displayProperty=fullName> object. The <xref:System.IO.FileStream> object, created with a file path and file name, is used to create an <xref:System.Xml.XmlTextReader?displayProperty=fullName> that is passed as an argument to the ReadXmlSchema method.  \n  \n [!code-vb[Classic WebData DataSet.ReadXmlSchema Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.re_4_1.vb)]\n [!code-cs[Classic WebData DataSet.ReadXmlSchema Example#1](~/add/codesnippet/csharp/m-system.data.dataset.re_4_1.cs)]"
  syntax:
    content: public void ReadXmlSchema (System.Xml.XmlReader reader);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "<xref:System.Xml.XmlReader>从中进行读取。</xref:System.Xml.XmlReader>"
  overload: System.Data.DataSet.ReadXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ReadXmlSerializable(System.Xml.XmlReader)
  id: ReadXmlSerializable(System.Xml.XmlReader)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXmlSerializable(XmlReader)
  nameWithType: DataSet.ReadXmlSerializable(XmlReader)
  fullName: System.Data.DataSet.ReadXmlSerializable(XmlReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "忽略特性，并返回一个空的数据集。"
  syntax:
    content: protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "指定的 XML 读取器。"
  overload: System.Data.DataSet.ReadXmlSerializable*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.RejectChanges
  id: RejectChanges
  parent: System.Data.DataSet
  langs:
  - csharp
  name: RejectChanges()
  nameWithType: DataSet.RejectChanges()
  fullName: System.Data.DataSet.RejectChanges()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "回滚到所做的所有更改<xref href=&quot;System.Data.DataSet&quot;></xref>创建，以来或自从上次&lt;xref:System.Data.DataSet.AcceptChanges%2A?displayProperty=fullName&gt;调用。"
  remarks: "调用 RejectChanges 调用<xref:System.Data.DataTable.RejectChanges%2A?displayProperty=fullName>上所有<xref:System.Data.DataTable>受支持<xref:System.Data.DataSet>。</xref:System.Data.DataSet>包含对象</xref:System.Data.DataTable>的方法</xref:System.Data.DataTable.RejectChanges%2A?displayProperty=fullName>       <xref:System.Data.DataRow>包含的对象<xref:System.Data.DataSet>可以每个设置置于编辑模式下通过调用<xref:System.Data.DataRow.BeginEdit%2A?displayProperty=fullName>方法。</xref:System.Data.DataRow.BeginEdit%2A?displayProperty=fullName> </xref:System.Data.DataSet></xref:System.Data.DataRow> 之后调用<xref:System.Data.DataRow.EndEdit%2A?displayProperty=fullName>方法，可以通过调用拒绝更改<xref:System.Data.DataTable.RejectChanges%2A?displayProperty=fullName>上<xref:System.Data.DataTable>到<xref:System.Data.DataRow>对象属于。</xref:System.Data.DataRow> </xref:System.Data.DataTable> </xref:System.Data.DataTable.RejectChanges%2A?displayProperty=fullName> </xref:System.Data.DataRow.EndEdit%2A?displayProperty=fullName>       当<xref:System.Data.DataTable.RejectChanges%2A?displayProperty=fullName>方法被调用时，仍处于编辑模式的任何行取消其编辑。</xref:System.Data.DataTable.RejectChanges%2A?displayProperty=fullName> 新行被移除。 修改和删除的行返回回其原始状态 (`DataRowState.Unchanged`)。       Acceptchange 和 Rejectchange 仅适用于<xref:System.Data.DataRow>相关更改 (即， `Add`， `Remove`， `Delete`，和`Modify`)。</xref:System.Data.DataRow> 它们不是适用于架构或结构上的更改。"
  example:
  - "The following example shows a class derived from the <xref:System.Data.DataSet> class. The RejectChanges event is invoked from within a function.  \n  \n [!code-cs[Classic WebData DataSet.RejectChanges Example#1](~/add/codesnippet/csharp/m-system.data.dataset.re_6_1.cs)]\n [!code-vb[Classic WebData DataSet.RejectChanges Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.re_6_1.vb)]"
  syntax:
    content: public virtual void RejectChanges ();
    parameters: []
  overload: System.Data.DataSet.RejectChanges*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Relations
  id: Relations
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Relations
  nameWithType: DataSet.Relations
  fullName: System.Data.DataSet.Relations
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "获取关系链接表，并允许导航从父表到子表的集合。"
  remarks: ''
  example:
  - "The following example prints the column name of all child tables through the Relations property.  \n  \n [!code-vb[Classic WebData DataSet.Relations Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.re_1.vb)]"
  syntax:
    content: public System.Data.DataRelationCollection Relations { get; }
    return:
      type: System.Data.DataRelationCollection
      description: "A <xref href=&quot;System.Data.DataRelationCollection&quot;> </xref> ，其中包含一套<xref href=&quot;System.Data.DataRelation&quot;></xref>对象。 如果没有，则返回一个空集合<xref href=&quot;System.Data.DataRelation&quot;></xref>对象存在。"
  overload: System.Data.DataSet.Relations*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.RemotingFormat
  id: RemotingFormat
  parent: System.Data.DataSet
  langs:
  - csharp
  name: RemotingFormat
  nameWithType: DataSet.RemotingFormat
  fullName: System.Data.DataSet.RemotingFormat
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "获取或设置<xref href=&quot;System.Data.SerializationFormat&quot;></xref>为<xref href=&quot;System.Data.DataSet&quot;></xref>远程处理期间使用。"
  syntax:
    content: public System.Data.SerializationFormat RemotingFormat { get; set; }
    return:
      type: System.Data.SerializationFormat
      description: "A <xref href=&quot;System.Data.SerializationFormat&quot;></xref> object."
  overload: System.Data.DataSet.RemotingFormat*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Reset
  id: Reset
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Reset()
  nameWithType: DataSet.Reset()
  fullName: System.Data.DataSet.Reset()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "清除所有表，并删除所有关系、 外约束和表从<xref href=&quot;System.Data.DataSet&quot;> </xref>。 子类应重写重置以还原<xref href=&quot;System.Data.DataSet&quot;></xref>到其原始状态。"
  syntax:
    content: public virtual void Reset ();
    parameters: []
  overload: System.Data.DataSet.Reset*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.SchemaSerializationMode
  id: SchemaSerializationMode
  parent: System.Data.DataSet
  langs:
  - csharp
  name: SchemaSerializationMode
  nameWithType: DataSet.SchemaSerializationMode
  fullName: System.Data.DataSet.SchemaSerializationMode
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Gets or sets a <xref href=&quot;System.Data.SchemaSerializationMode&quot;></xref> for a <xref href=&quot;System.Data.DataSet&quot;></xref>."
  remarks: "A<xref:System.Data.DataSet>将其架构和实例的数据序列化默认情况下，在 Web 服务和远程处理方案中。</xref:System.Data.DataSet> 设置类型化的 SchemaSerializationMode 属性`DataSet`到<xref:System.Data.SchemaSerializationMode>导致架构信息从序列化负载中排除。</xref:System.Data.SchemaSerializationMode>       <xref:System.Data.SchemaSerializationMode>支持的类型化`DataSet`。</xref:System.Data.SchemaSerializationMode> 为非类型化`DataSet`此属性只能设置为<xref:System.Data.SchemaSerializationMode>。</xref:System.Data.SchemaSerializationMode>       <xref:System.Data.SchemaSerializationMode>只应在其中的架构信息的基础类型化的情况下`DataTables`，`DataRelations`和`Constraints`尚未修改。</xref:System.Data.SchemaSerializationMode> 如果修改已发生的、 完整的架构信息应使用进行序列化<xref:System.Data.SchemaSerializationMode>.</xref:System.Data.SchemaSerializationMode>       <xref:System.Data.SchemaSerializationMode>在版本 2.0 的.NET framework 或更高版本受到支持。</xref:System.Data.SchemaSerializationMode>       当<xref:System.Data.SchemaSerializationMode>设置，仅顶级运行时属性上存在<xref:System.Data.DataSet>进行序列化。</xref:System.Data.DataSet> </xref:System.Data.SchemaSerializationMode> 此外，这些扩展会序列仅当它们碰巧不同于默认值。 没有任何`Tables`，`Relations`或`Constraints`进行序列化。 序列化的运行时属性包括<xref:System.Data.DataSet.DataSetName%2A>， <xref:System.Data.DataSet.Namespace%2A>， <xref:System.Data.DataSet.Prefix%2A>， <xref:System.Data.DataSet.Locale%2A>， <xref:System.Data.DataSet.EnforceConstraints%2A>，和<xref:System.Data.DataSet.CaseSensitive%2A>。</xref:System.Data.DataSet.CaseSensitive%2A> </xref:System.Data.DataSet.EnforceConstraints%2A> </xref:System.Data.DataSet.Locale%2A> </xref:System.Data.DataSet.Prefix%2A> </xref:System.Data.DataSet.Namespace%2A> </xref:System.Data.DataSet.DataSetName%2A> 若要确保会保留整体运行时数据完整性，序列化这些属性。"
  syntax:
    content: public virtual System.Data.SchemaSerializationMode SchemaSerializationMode { get; set; }
    return:
      type: System.Data.SchemaSerializationMode
      description: "Gets or sets a <xref href=&quot;System.Data.SchemaSerializationMode&quot;></xref> for a <xref href=&quot;System.Data.DataSet&quot;></xref>."
  overload: System.Data.DataSet.SchemaSerializationMode*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ShouldSerializeRelations
  id: ShouldSerializeRelations
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ShouldSerializeRelations()
  nameWithType: DataSet.ShouldSerializeRelations()
  fullName: System.Data.DataSet.ShouldSerializeRelations()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "获取一个值，该值指示是否<xref:System.Data.DataSet.Relations*>属性应对其进行持久化。</xref:System.Data.DataSet.Relations*>"
  remarks: "如果你创建的设计器通常使用此方法<xref:System.Data.DataSet>，或创建您自己的控件合并<xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataSet>"
  example:
  - "The following examples show a class derived from the <xref:System.Data.DataSet> class. The <xref:System.Data.DataSet.Reset%2A> and ShouldSerializeRelations methods are invoked from within functions in the derived class.  \n  \n [!code-cs[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/add/codesnippet/csharp/m-system.data.dataset.sh_3_1.cs)]\n [!code-vb[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.sh_3_1.vb)]"
  syntax:
    content: protected virtual bool ShouldSerializeRelations ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果属性值已更改，不再是默认值;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.DataSet.ShouldSerializeRelations*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ShouldSerializeTables
  id: ShouldSerializeTables
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ShouldSerializeTables()
  nameWithType: DataSet.ShouldSerializeTables()
  fullName: System.Data.DataSet.ShouldSerializeTables()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "获取一个值，该值指示是否<xref:System.Data.DataSet.Tables*>属性应对其进行持久化。</xref:System.Data.DataSet.Tables*>"
  remarks: "只有当你可以创建设计器中的为通常使用此方法<xref:System.Data.DataSet>，或创建您自己的控件合并<xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataSet>"
  example:
  - "The following example shows a class derived from the <xref:System.Data.DataSet> class. The ShouldSerializeTables method is called from within functions in the derived class.  \n  \n [!code-vb[Classic WebData DataSet.ShouldSerializeTables Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.sh_2_1.vb)]\n [!code-cs[Classic WebData DataSet.ShouldSerializeTables Example#1](~/add/codesnippet/csharp/m-system.data.dataset.sh_2_1.cs)]"
  syntax:
    content: protected virtual bool ShouldSerializeTables ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果属性值已更改，不再是默认值;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.DataSet.ShouldSerializeTables*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Site
  id: Site
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Site
  nameWithType: DataSet.Site
  fullName: System.Data.DataSet.Site
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "获取或设置<xref href=&quot;System.ComponentModel.ISite&quot;></xref>为<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  remarks: "站点绑定<xref:System.ComponentModel.Component>到<xref:System.ComponentModel.Container>和启用它们之间的通信，以及为要管理其组件的容器提供的方法。</xref:System.ComponentModel.Container> </xref:System.ComponentModel.Component>"
  syntax:
    content: public override System.ComponentModel.ISite Site { get; set; }
    return:
      type: System.ComponentModel.ISite
      description: "An <xref href=&quot;System.ComponentModel.ISite&quot;></xref> for the <xref href=&quot;System.Data.DataSet&quot;></xref>."
  overload: System.Data.DataSet.Site*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection
  id: System#ComponentModel#IListSource#ContainsListCollection
  isEii: true
  parent: System.Data.DataSet
  langs:
  - csharp
  name: System.ComponentModel.IListSource.ContainsListCollection
  nameWithType: DataSet.System.ComponentModel.IListSource.ContainsListCollection
  fullName: System.Data.DataSet.System.ComponentModel.IListSource.ContainsListCollection
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "有关此成员的说明，请参阅&lt;xref:System.ComponentModel.IListSource.ContainsListCollection%2A?displayProperty=fullName&gt;。"
  remarks: "此成员是显式接口成员的实现。 可以使用它时，才<xref:System.Data.DataSet>实例被强制转换为<xref:System.ComponentModel.IListSource>接口。</xref:System.ComponentModel.IListSource> </xref:System.Data.DataSet>"
  syntax:
    content: bool System.ComponentModel.IListSource.ContainsListCollection { get; }
    return:
      type: System.Boolean
      description: "有关此成员的说明，请参阅&lt;xref:System.ComponentModel.IListSource.ContainsListCollection%2A?displayProperty=fullName&gt;。"
  overload: System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.System#ComponentModel#IListSource#GetList
  id: System#ComponentModel#IListSource#GetList
  isEii: true
  parent: System.Data.DataSet
  langs:
  - csharp
  name: System.ComponentModel.IListSource.GetList()
  nameWithType: DataSet.System.ComponentModel.IListSource.GetList()
  fullName: System.Data.DataSet.System.ComponentModel.IListSource.GetList()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "有关此成员的说明，请参阅&lt;xref:System.ComponentModel.IListSource.GetList%2A?displayProperty=fullName&gt;。"
  remarks: "此成员是显式接口成员的实现。 可以使用它时，才<xref:System.Data.DataSet>实例被强制转换为<xref:System.ComponentModel.IListSource>接口。</xref:System.ComponentModel.IListSource> </xref:System.Data.DataSet>"
  syntax:
    content: System.Collections.IList IListSource.GetList ();
    parameters: []
    return:
      type: System.Collections.IList
      description: "有关此成员的说明，请参阅&lt;xref:System.ComponentModel.IListSource.GetList%2A?displayProperty=fullName&gt;。"
  overload: System.Data.DataSet.System#ComponentModel#IListSource#GetList*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema
  id: System#Xml#Serialization#IXmlSerializable#GetSchema
  isEii: true
  parent: System.Data.DataSet
  langs:
  - csharp
  name: System.Xml.Serialization.IXmlSerializable.GetSchema()
  nameWithType: DataSet.System.Xml.Serialization.IXmlSerializable.GetSchema()
  fullName: System.Data.DataSet.System.Xml.Serialization.IXmlSerializable.GetSchema()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "有关此成员的说明，请参阅&lt;xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A?displayProperty=fullName&gt;。"
  remarks: "此成员是显式接口成员的实现。 可以使用它时，才<xref:System.Data.DataSet>实例被强制转换为<xref:System.Xml.Serialization.IXmlSerializable>接口。</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Data.DataSet>"
  syntax:
    content: System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();
    parameters: []
    return:
      type: System.Xml.Schema.XmlSchema
      description: "有关此成员的说明，请参阅&lt;xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A?displayProperty=fullName&gt;。"
  overload: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
  id: System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
  isEii: true
  parent: System.Data.DataSet
  langs:
  - csharp
  name: System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
  nameWithType: DataSet.System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
  fullName: System.Data.DataSet.System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "有关此成员的说明，请参阅&lt;xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A?displayProperty=fullName&gt;。"
  remarks: "此成员是显式接口成员的实现。 可以使用它时，才<xref:System.Data.DataSet>实例被强制转换为<xref:System.Xml.Serialization.IXmlSerializable>接口。</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Data.DataSet>"
  syntax:
    content: void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "A <xref:System.Xml.XmlReader>.</xref:System.Xml.XmlReader>"
  overload: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
  id: System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
  isEii: true
  parent: System.Data.DataSet
  langs:
  - csharp
  name: System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
  nameWithType: DataSet.System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
  fullName: System.Data.DataSet.System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "有关此成员的说明，请参阅&lt;xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A?displayProperty=fullName&gt;。"
  remarks: "此成员是显式接口成员的实现。 可以使用它时，才<xref:System.Data.DataSet>实例被强制转换为<xref:System.Xml.Serialization.IXmlSerializable>接口。</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Data.DataSet>"
  syntax:
    content: void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "A <xref:System.Xml.XmlWriter>.</xref:System.Xml.XmlWriter>"
  overload: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Tables
  id: Tables
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Tables
  nameWithType: DataSet.Tables
  fullName: System.Data.DataSet.Tables
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "获取集合中包含的表<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  remarks: "若要将表添加到集合中，使用<xref:System.Data.DataTableCollection.Add%2A>的<xref:System.Data.DataTableCollection>。</xref:System.Data.DataTableCollection>方法</xref:System.Data.DataTableCollection.Add%2A> 若要删除表，使用<xref:System.Data.DataTableCollection.Remove%2A>方法。</xref:System.Data.DataTableCollection.Remove%2A>"
  example:
  - "The following example returns the <xref:System.Data.DataSet> object's <xref:System.Data.DataTableCollection>, and prints the columns and rows in each table.  \n  \n [!code-vb[Classic WebData DataSet.Tables Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.ta_1.vb)]\n [!code-cs[Classic WebData DataSet.Tables Example#1](~/add/codesnippet/csharp/p-system.data.dataset.ta_1.cs)]"
  syntax:
    content: public System.Data.DataTableCollection Tables { get; }
    return:
      type: System.Data.DataTableCollection
      description: "<xref href=&quot;System.Data.DataTableCollection&quot;> </xref>包含由此<xref href=&quot;System.Data.DataSet&quot;> </xref>。 如果没有，则返回一个空集合<xref href=&quot;System.Data.DataTable&quot;></xref>对象存在。"
  overload: System.Data.DataSet.Tables*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXml(System.IO.Stream)
  id: WriteXml(System.IO.Stream)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXml(Stream)
  nameWithType: DataSet.WriteXml(Stream)
  fullName: System.Data.DataSet.WriteXml(Stream)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "当前数据写入<xref href=&quot;System.Data.DataSet&quot;></xref>使用指定&lt;xref:System.IO.Stream?displayProperty=fullName&gt;。"
  remarks: "`WriteXml`方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataSet>插入 XML 文档，而<xref:System.Data.DataSet.WriteXmlSchema%2A>方法将写入仅的架构。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet> 若要编写数据和架构，使用包含的重载之一`mode`参数，并将其值设置为`WriteSchema`。       请注意，同样适用于<xref:System.Data.DataSet.ReadXml%2A>和<xref:System.Data.DataSet.ReadXmlSchema%2A>方法，分别。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet.ReadXml%2A> 读取 XML 数据或架构和数据读入`DataSet`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。      1> [!NOTE]&1;><xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  example:
  - "The following example creates a <xref:System.IO.FileStream?displayProperty=fullName> object. The object is then used with the WriteXml method to write an XML document.  \n  \n [!code-cs[Classic WebData DataSet.WriteXml Example#1](~/add/codesnippet/csharp/m-system.data.dataset.wr_2_1.cs)]\n [!code-vb[Classic WebData DataSet.WriteXml Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.wr_2_1.vb)]"
  syntax:
    content: public void WriteXml (System.IO.Stream stream);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "A<xref:System.IO.Stream>用于写入到的文件的对象。</xref:System.IO.Stream>"
  overload: System.Data.DataSet.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXml(System.IO.TextWriter)
  id: WriteXml(System.IO.TextWriter)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXml(TextWriter)
  nameWithType: DataSet.WriteXml(TextWriter)
  fullName: System.Data.DataSet.WriteXml(TextWriter)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "当前数据写入<xref href=&quot;System.Data.DataSet&quot;></xref>使用指定的<xref:System.IO.TextWriter>.</xref:System.IO.TextWriter>"
  remarks: "`WriteXml`方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataSet>插入 XML 文档，而<xref:System.Data.DataSet.WriteXmlSchema%2A>方法将写入仅的架构。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet> 若要编写数据和架构，使用包含的重载之一`mode`参数，并将其值设置为`WriteSchema`。       请注意，同样适用于<xref:System.Data.DataSet.ReadXml%2A>和<xref:System.Data.DataSet.ReadXmlSchema%2A>方法，分别。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet.ReadXml%2A> 读取 XML 数据或架构和数据读入`DataSet`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。      1> [!NOTE]&1;><xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (System.IO.TextWriter writer);
    parameters:
    - id: writer
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>与要写入的对象。</xref:System.IO.TextWriter>"
  overload: System.Data.DataSet.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXml(System.String)
  id: WriteXml(System.String)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXml(String)
  nameWithType: DataSet.WriteXml(String)
  fullName: System.Data.DataSet.WriteXml(String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "当前数据写入<xref href=&quot;System.Data.DataSet&quot;></xref>到指定的文件。"
  remarks: "`WriteXml`方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataSet>插入 XML 文档，而<xref:System.Data.DataSet.WriteXmlSchema%2A>方法将写入仅的架构。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet> 若要编写数据和架构，使用包含的重载之一`mode`参数，并将其值设置为`WriteSchema`。       请注意，同样适用于<xref:System.Data.DataSet.ReadXml%2A>和<xref:System.Data.DataSet.ReadXmlSchema%2A>方法，分别。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet.ReadXml%2A> 读取 XML 数据或架构和数据读入`DataSet`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。      1> [!NOTE]&1;><xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "文件名称 （包括路径），要向其写入。"
  overload: System.Data.DataSet.WriteXml*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<xref href=&quot;System.Security.Permissions.FileIOPermission&quot;></xref>未设置为<xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>。"
  platform:
  - net462
- uid: System.Data.DataSet.WriteXml(System.Xml.XmlWriter)
  id: WriteXml(System.Xml.XmlWriter)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXml(XmlWriter)
  nameWithType: DataSet.WriteXml(XmlWriter)
  fullName: System.Data.DataSet.WriteXml(XmlWriter)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "当前数据写入<xref href=&quot;System.Data.DataSet&quot;></xref>到指定<xref:System.Xml.XmlWriter>。</xref:System.Xml.XmlWriter>"
  remarks: "`WriteXml`方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataSet>插入 XML 文档，而<xref:System.Data.DataSet.WriteXmlSchema%2A>方法将写入仅的架构。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet> 若要编写数据和架构，使用包含的重载之一`mode`参数，并将其值设置为`WriteSchema`。       请注意，同样适用于<xref:System.Data.DataSet.ReadXml%2A>和<xref:System.Data.DataSet.ReadXmlSchema%2A>方法，分别。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet.ReadXml%2A> 读取 XML 数据或架构和数据读入`DataSet`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。      1> [!NOTE]&1;><xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (System.Xml.XmlWriter writer);
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "<xref:System.Xml.XmlWriter>用来编写。</xref:System.Xml.XmlWriter>"
  overload: System.Data.DataSet.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)
  id: WriteXml(System.IO.Stream,System.Data.XmlWriteMode)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXml(Stream,XmlWriteMode)
  nameWithType: DataSet.WriteXml(Stream,XmlWriteMode)
  fullName: System.Data.DataSet.WriteXml(Stream,XmlWriteMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "为编写的当前数据和 （可选） 架构， <xref href=&quot;System.Data.DataSet&quot;> </xref>使用指定&lt;xref:System.IO.Stream?displayProperty=fullName&gt;和<xref href=&quot;System.Data.XmlWriteMode&quot;> </xref>。 若要编写架构，请将的值设置<code> mode </code>参数<xref uid=&quot;langword_csharp_WriteSchema&quot; name=&quot;WriteSchema&quot; href=&quot;&quot;> </xref>。"
  remarks: "`WriteXml`方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataSet>插入 XML 文档，而<xref:System.Data.DataSet.WriteXmlSchema%2A>方法将写入仅的架构。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet> 若要编写数据和架构，设置`mode`参数`WriteSchema`。       请注意，同样适用于<xref:System.Data.DataSet.ReadXml%2A>和<xref:System.Data.DataSet.ReadXmlSchema%2A>方法，分别。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet.ReadXml%2A> 读取 XML 数据或架构和数据读入`DataSet`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。      1> [!NOTE]&1;><xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "A<xref:System.IO.Stream>用于写入到的文件的对象。</xref:System.IO.Stream>"
    - id: mode
      type: System.Data.XmlWriteMode
      description: "之一<xref href=&quot;System.Data.XmlWriteMode&quot;></xref>值。"
  overload: System.Data.DataSet.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)
  id: WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXml(TextWriter,XmlWriteMode)
  nameWithType: DataSet.WriteXml(TextWriter,XmlWriteMode)
  fullName: System.Data.DataSet.WriteXml(TextWriter,XmlWriteMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "为编写的当前数据和 （可选） 架构， <xref href=&quot;System.Data.DataSet&quot;> </xref>使用指定<xref:System.IO.TextWriter>和<xref href=&quot;System.Data.XmlWriteMode&quot;> </xref>。</xref:System.IO.TextWriter> 若要编写架构，请将的值设置<code> mode </code>参数<xref uid=&quot;langword_csharp_WriteSchema&quot; name=&quot;WriteSchema&quot; href=&quot;&quot;> </xref>。"
  remarks: "`WriteXml`方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataSet>插入 XML 文档，而<xref:System.Data.DataSet.WriteXmlSchema%2A>方法将写入仅的架构。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet> 若要编写数据和架构，设置`mode`参数`WriteSchema`。       请注意，同样适用于<xref:System.Data.DataSet.ReadXml%2A>和<xref:System.Data.DataSet.ReadXmlSchema%2A>方法，分别。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet.ReadXml%2A> 读取 XML 数据或架构和数据读入`DataSet`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。      1> [!NOTE]&1;><xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  example:
  - "The following example first creates a simple <xref:System.Data.DataSet> with one <xref:System.Data.DataTable>, two columns, and ten rows. The <xref:System.Data.DataSet> schema and data are written to disk by invoking the <xref:System.Data.DataSet.WriteXml%2A> method. A second <xref:System.Data.DataSet> is created and the <xref:System.Data.DataSet.ReadXml%2A> method is used to fill it with schema and data.  \n  \n [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.wr_7_1.vb)]\n [!code-cs[Classic WebData DataSet.ReadXml2 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.wr_7_1.cs)]"
  syntax:
    content: public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);
    parameters:
    - id: writer
      type: System.IO.TextWriter
      description: "A &lt;xref:System.IO.TextWriter?displayProperty=fullName&gt;用于进行写入的文档对象。"
    - id: mode
      type: System.Data.XmlWriteMode
      description: "之一<xref href=&quot;System.Data.XmlWriteMode&quot;></xref>值。"
  overload: System.Data.DataSet.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)
  id: WriteXml(System.String,System.Data.XmlWriteMode)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXml(String,XmlWriteMode)
  nameWithType: DataSet.WriteXml(String,XmlWriteMode)
  fullName: System.Data.DataSet.WriteXml(String,XmlWriteMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "为编写的当前数据和 （可选） 架构， <xref href=&quot;System.Data.DataSet&quot;> </xref>到指定的文件使用指定<xref href=&quot;System.Data.XmlWriteMode&quot;> </xref>。 若要编写架构，请将的值设置<code> mode </code>参数<xref uid=&quot;langword_csharp_WriteSchema&quot; name=&quot;WriteSchema&quot; href=&quot;&quot;> </xref>。"
  remarks: "`WriteXml`方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataSet>插入 XML 文档，而<xref:System.Data.DataSet.WriteXmlSchema%2A>方法将写入仅的架构。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet> 若要编写数据和架构，设置`mode`参数`WriteSchema`。       请注意，同样适用于<xref:System.Data.DataSet.ReadXml%2A>和<xref:System.Data.DataSet.ReadXmlSchema%2A>方法，分别。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet.ReadXml%2A> 读取 XML 数据或架构和数据读入`DataSet`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。      1> [!NOTE]&1;><xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  example:
  - "The following example uses the <xref:System.Data.DataSet.WriteXml%2A> method to write an XML document.  \n  \n [!code-cs[Classic WebData DataSet.WriteXml7 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.wr_3_1.cs)]\n [!code-vb[Classic WebData DataSet.WriteXml7 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.wr_3_1.vb)]"
  syntax:
    content: public void WriteXml (string fileName, System.Data.XmlWriteMode mode);
    parameters:
    - id: fileName
      type: System.String
      description: "文件名称 （包括路径），要向其写入。"
    - id: mode
      type: System.Data.XmlWriteMode
      description: "之一<xref href=&quot;System.Data.XmlWriteMode&quot;></xref>值。"
  overload: System.Data.DataSet.WriteXml*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<xref href=&quot;System.Security.Permissions.FileIOPermission&quot;></xref>未设置为<xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>。"
  platform:
  - net462
- uid: System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)
  id: WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXml(XmlWriter,XmlWriteMode)
  nameWithType: DataSet.WriteXml(XmlWriter,XmlWriteMode)
  fullName: System.Data.DataSet.WriteXml(XmlWriter,XmlWriteMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "为编写的当前数据和 （可选） 架构， <xref href=&quot;System.Data.DataSet&quot;> </xref>使用指定<xref:System.Xml.XmlWriter>和<xref href=&quot;System.Data.XmlWriteMode&quot;> </xref>。</xref:System.Xml.XmlWriter> 若要编写架构，请将的值设置<code> mode </code>参数<xref uid=&quot;langword_csharp_WriteSchema&quot; name=&quot;WriteSchema&quot; href=&quot;&quot;> </xref>。"
  remarks: "`WriteXml`方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataSet>插入 XML 文档，而<xref:System.Data.DataSet.WriteXmlSchema%2A>方法将写入仅的架构。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet> 若要编写数据和架构，设置`mode`参数`WriteSchema`。       请注意，同样适用于<xref:System.Data.DataSet.ReadXml%2A>和<xref:System.Data.DataSet.ReadXmlSchema%2A>方法，分别。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet.ReadXml%2A> 读取 XML 数据或架构和数据读入`DataSet`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。      1> [!NOTE]&1;><xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  example:
  - "The following example creates a <xref:System.IO.FileStream?displayProperty=fullName> object that is used to create a new <xref:System.Xml.XmlTextWriter?displayProperty=fullName>. The <xref:System.Xml.XmlTextWriter> object is used with the <xref:System.Data.DataSet.WriteXml%2A> method to write an XML document.  \n  \n [!code-cs[Classic WebData DataSet.WriteXml6 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.wr_1_1.cs)]\n [!code-vb[Classic WebData DataSet.WriteXml6 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.wr_1_1.vb)]"
  syntax:
    content: public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "<xref:System.Xml.XmlWriter>用来编写。</xref:System.Xml.XmlWriter>"
    - id: mode
      type: System.Data.XmlWriteMode
      description: "之一<xref href=&quot;System.Data.XmlWriteMode&quot;></xref>值。"
  overload: System.Data.DataSet.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXmlSchema(System.IO.Stream)
  id: WriteXmlSchema(System.IO.Stream)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXmlSchema(Stream)
  nameWithType: DataSet.WriteXmlSchema(Stream)
  fullName: System.Data.DataSet.WriteXmlSchema(Stream)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "写入<xref href=&quot;System.Data.DataSet&quot;></xref>作为一个 XML 架构写入指定的结构&lt;xref:System.IO.Stream?displayProperty=fullName&gt;对象。"
  remarks: "WriteXmlSchema 方法用于编写的架构<xref:System.Data.DataSet>到 XML 文档。</xref:System.Data.DataSet> 架构包含表、 关系和约束定义。 若要写入到 XML 文档的架构，使用 WriteXmlSchema 方法。       使用 XSD 标准编写 XML 架构。       若要将数据写入到 XML 文档，使用<xref:System.Data.DataSet.WriteXml%2A>方法。</xref:System.Data.DataSet.WriteXml%2A>       派生自的类<xref:System.IO.Stream>类包括<xref:System.IO.BufferedStream>， <xref:System.IO.FileStream>， <xref:System.IO.MemoryStream>，和<xref:System.Net.Sockets.NetworkStream>。</xref:System.Net.Sockets.NetworkStream> </xref:System.IO.MemoryStream> </xref:System.IO.FileStream> </xref:System.IO.BufferedStream> </xref:System.IO.Stream>"
  example:
  - "The following example creates a new <xref:System.IO.FileStream> object that is passed to the WriteXmlSchema method to write the schema to disk.  \n  \n [!code-vb[Classic WebData DataSet.WriteXmlSchema Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.wr_6_1.vb)]\n [!code-cs[Classic WebData DataSet.WriteXmlSchema Example#1](~/add/codesnippet/csharp/m-system.data.dataset.wr_6_1.cs)]"
  syntax:
    content: public void WriteXmlSchema (System.IO.Stream stream);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "A<xref:System.IO.Stream>用于写入到的文件的对象。</xref:System.IO.Stream>"
  overload: System.Data.DataSet.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)
  id: WriteXmlSchema(System.IO.TextWriter)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXmlSchema(TextWriter)
  nameWithType: DataSet.WriteXmlSchema(TextWriter)
  fullName: System.Data.DataSet.WriteXmlSchema(TextWriter)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "写入<xref href=&quot;System.Data.DataSet&quot;></xref>作为一个 XML 架构写入指定的结构<xref:System.IO.TextWriter>对象。</xref:System.IO.TextWriter>"
  remarks: "使用<xref:System.Data.DataSet.WriteXmlSchema%2A>方法写入的架构<xref:System.Data.DataSet>到 XML 文档。</xref:System.Data.DataSet> </xref:System.Data.DataSet.WriteXmlSchema%2A> 架构包含表、 关系和约束定义。 若要写入到 XML 文档的架构，使用<xref:System.Data.DataSet.WriteXmlSchema%2A>方法。</xref:System.Data.DataSet.WriteXmlSchema%2A>       使用 XSD 标准编写 XML 架构。       若要将数据写入到 XML 文档，使用<xref:System.Data.DataSet.WriteXml%2A>方法。</xref:System.Data.DataSet.WriteXml%2A>       类从派生<xref:System.IO.TextWriter?displayProperty=fullName>类包括<xref:System.Web.HttpWriter?displayProperty=fullName>， <xref:System.CodeDom.Compiler.IndentedTextWriter?displayProperty=fullName>， <xref:System.Web.UI.HtmlTextWriter?displayProperty=fullName>， <xref:System.IO.StreamWriter?displayProperty=fullName>，和<xref:System.IO.StringWriter?displayProperty=fullName>。</xref:System.IO.StringWriter?displayProperty=fullName> </xref:System.IO.StreamWriter?displayProperty=fullName> </xref:System.Web.UI.HtmlTextWriter?displayProperty=fullName> </xref:System.CodeDom.Compiler.IndentedTextWriter?displayProperty=fullName> </xref:System.Web.HttpWriter?displayProperty=fullName> </xref:System.IO.TextWriter?displayProperty=fullName>"
  example:
  - "The following example creates a <xref:System.Text.StringBuilder?displayProperty=fullName> object to that is used to create a new <xref:System.IO.StringWriter?displayProperty=fullName>. The <xref:System.IO.StringWriter> is passed to the <xref:System.Data.DataSet.WriteXmlSchema%2A> method, and the resulting string is printed to the console window.  \n  \n [!code-cs[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.wr_0_1.cs)]\n [!code-vb[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.wr_0_1.vb)]"
  syntax:
    content: public void WriteXmlSchema (System.IO.TextWriter writer);
    parameters:
    - id: writer
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>与要写入的对象。</xref:System.IO.TextWriter>"
  overload: System.Data.DataSet.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXmlSchema(System.String)
  id: WriteXmlSchema(System.String)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXmlSchema(String)
  nameWithType: DataSet.WriteXmlSchema(String)
  fullName: System.Data.DataSet.WriteXmlSchema(String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "写入<xref href=&quot;System.Data.DataSet&quot;></xref>作为一个 XML 架构写入文件的结构。"
  remarks: "使用<xref:System.Data.DataSet.WriteXmlSchema%2A>方法写入的架构<xref:System.Data.DataSet>到 XML 文档。</xref:System.Data.DataSet> </xref:System.Data.DataSet.WriteXmlSchema%2A> 架构包含表、 关系和约束定义。 若要写入到 XML 文档的架构，使用<xref:System.Data.DataSet.WriteXmlSchema%2A>方法。</xref:System.Data.DataSet.WriteXmlSchema%2A>       使用 XSD 标准编写 XML 架构。       若要将数据写入到 XML 文档，使用<xref:System.Data.DataSet.WriteXml%2A>方法。</xref:System.Data.DataSet.WriteXml%2A>"
  example:
  - >-
    [!code-cs[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.wr_4_1.cs)]
     [!code-vb[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.wr_4_1.vb)]
  syntax:
    content: public void WriteXmlSchema (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "文件名称 （包括路径），要向其写入。"
  overload: System.Data.DataSet.WriteXmlSchema*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<xref href=&quot;System.Security.Permissions.FileIOPermission&quot;></xref>未设置为<xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>。"
  platform:
  - net462
- uid: System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)
  id: WriteXmlSchema(System.Xml.XmlWriter)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXmlSchema(XmlWriter)
  nameWithType: DataSet.WriteXmlSchema(XmlWriter)
  fullName: System.Data.DataSet.WriteXmlSchema(XmlWriter)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "写入<xref href=&quot;System.Data.DataSet&quot;></xref>结构作为 XML 架构写入<xref:System.Xml.XmlWriter>对象。</xref:System.Xml.XmlWriter>"
  remarks: "使用<xref:System.Data.DataSet.WriteXmlSchema%2A>方法写入的架构<xref:System.Data.DataSet>到 XML 文档。</xref:System.Data.DataSet> </xref:System.Data.DataSet.WriteXmlSchema%2A> 架构包含表、 关系和约束定义。 若要写入到 XML 文档的架构，使用<xref:System.Data.DataSet.WriteXmlSchema%2A>方法。</xref:System.Data.DataSet.WriteXmlSchema%2A>       使用 XSD 标准编写 XML 架构。       若要将数据写入到 XML 文档，使用<xref:System.Data.DataSet.WriteXml%2A>方法。</xref:System.Data.DataSet.WriteXml%2A>       一个类继承自的<xref:System.Xml.XmlWriter?displayProperty=fullName>类是<xref:System.Xml.XmlTextWriter?displayProperty=fullName>类。</xref:System.Xml.XmlTextWriter?displayProperty=fullName> </xref:System.Xml.XmlWriter?displayProperty=fullName>"
  example:
  - "The following example creates a new <xref:System.IO.FileStream?displayProperty=fullName> object with the specified path. The <xref:System.IO.FileStream> object is used to create an <xref:System.Xml.XMLTextWriter?displayProperty=fullName> object. The <xref:System.Data.DataSet.WriteXmlSchema%2A> method is then invoked with the <xref:System.Xml.XmlTextWriter> object to write the schema to the disk.  \n  \n [!code-cs[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.wr_5_1.cs)]\n [!code-vb[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.wr_5_1.vb)]"
  syntax:
    content: public void WriteXmlSchema (System.Xml.XmlWriter writer);
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "<xref:System.Xml.XmlWriter>写入。</xref:System.Xml.XmlWriter>"
  overload: System.Data.DataSet.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})
  id: WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXmlSchema(Stream,Converter<Type,String>)
  nameWithType: DataSet.WriteXmlSchema(Stream,Converter<Type,String>)
  fullName: System.Data.DataSet.WriteXmlSchema(Stream,Converter<Type,String>)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "写入<xref href=&quot;System.Data.DataSet&quot;></xref>作为一个 XML 架构写入指定的结构&lt;xref:System.IO.Stream?displayProperty=fullName&gt;对象。"
  syntax:
    content: public void WriteXmlSchema (System.IO.Stream stream, Converter<Type,string> multipleTargetConverter);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "A &lt;xref:System.IO.Stream?displayProperty=fullName&gt;要写入到对象。"
    - id: multipleTargetConverter
      type: System.Converter{System.Type,System.String}
      description: "委托用于将转换<xref:System.Type>为字符串。</xref:System.Type>"
  overload: System.Data.DataSet.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})
  id: WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXmlSchema(TextWriter,Converter<Type,String>)
  nameWithType: DataSet.WriteXmlSchema(TextWriter,Converter<Type,String>)
  fullName: System.Data.DataSet.WriteXmlSchema(TextWriter,Converter<Type,String>)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "写入<xref href=&quot;System.Data.DataSet&quot;></xref>作为一个 XML 架构写入指定的<xref:System.IO.TextWriter>.</xref:System.IO.TextWriter>结构"
  syntax:
    content: public void WriteXmlSchema (System.IO.TextWriter writer, Converter<Type,string> multipleTargetConverter);
    parameters:
    - id: writer
      type: System.IO.TextWriter
      description: "A<xref:System.IO.TextWriter>要写入到对象。</xref:System.IO.TextWriter>"
    - id: multipleTargetConverter
      type: System.Converter{System.Type,System.String}
      description: "委托用于将转换<xref:System.Type>为字符串。</xref:System.Type>"
  overload: System.Data.DataSet.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXmlSchema(System.String,System.Converter{System.Type,System.String})
  id: WriteXmlSchema(System.String,System.Converter{System.Type,System.String})
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXmlSchema(String,Converter<Type,String>)
  nameWithType: DataSet.WriteXmlSchema(String,Converter<Type,String>)
  fullName: System.Data.DataSet.WriteXmlSchema(String,Converter<Type,String>)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "写入<xref href=&quot;System.Data.DataSet&quot;></xref>作为一个 XML 架构写入文件的结构。"
  syntax:
    content: public void WriteXmlSchema (string fileName, Converter<Type,string> multipleTargetConverter);
    parameters:
    - id: fileName
      type: System.String
      description: "要写入的文件的名称。"
    - id: multipleTargetConverter
      type: System.Converter{System.Type,System.String}
      description: "委托用于将转换<xref:System.Type>为字符串。</xref:System.Type>"
  overload: System.Data.DataSet.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})
  id: WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXmlSchema(XmlWriter,Converter<Type,String>)
  nameWithType: DataSet.WriteXmlSchema(XmlWriter,Converter<Type,String>)
  fullName: System.Data.DataSet.WriteXmlSchema(XmlWriter,Converter<Type,String>)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "写入<xref href=&quot;System.Data.DataSet&quot;></xref>作为一个 XML 架构写入指定的<xref:System.Xml.XmlWriter>.</xref:System.Xml.XmlWriter>结构"
  syntax:
    content: public void WriteXmlSchema (System.Xml.XmlWriter writer, Converter<Type,string> multipleTargetConverter);
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "A<xref:System.Xml.XmlWriter>要写入到对象。</xref:System.Xml.XmlWriter>"
    - id: multipleTargetConverter
      type: System.Converter{System.Type,System.String}
      description: "委托用于将转换<xref:System.Type>为字符串。</xref:System.Type>"
  overload: System.Data.DataSet.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
references:
- uid: System.ComponentModel.MarshalByValueComponent
  isExternal: false
  name: System.ComponentModel.MarshalByValueComponent
- uid: System.Data.ConstraintException
  parent: System.Data
  isExternal: false
  name: ConstraintException
  nameWithType: ConstraintException
  fullName: System.Data.ConstraintException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Data.DataSet.#ctor
  parent: System.Data.DataSet
  isExternal: false
  name: DataSet()
  nameWithType: DataSet.DataSet()
  fullName: System.Data.DataSet.DataSet()
- uid: System.Data.DataSet.#ctor(System.String)
  parent: System.Data.DataSet
  isExternal: false
  name: DataSet(String)
  nameWithType: DataSet.DataSet(String)
  fullName: System.Data.DataSet.DataSet(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataSet
  isExternal: false
  name: DataSet(SerializationInfo,StreamingContext)
  nameWithType: DataSet.DataSet(SerializationInfo,StreamingContext)
  fullName: System.Data.DataSet.DataSet(SerializationInfo,StreamingContext)
- uid: System.Runtime.Serialization.SerializationInfo
  parent: System.Runtime.Serialization
  isExternal: false
  name: SerializationInfo
  nameWithType: SerializationInfo
  fullName: System.Runtime.Serialization.SerializationInfo
- uid: System.Runtime.Serialization.StreamingContext
  parent: System.Runtime.Serialization
  isExternal: true
  name: StreamingContext
  nameWithType: StreamingContext
  fullName: System.Runtime.Serialization.StreamingContext
- uid: System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)
  parent: System.Data.DataSet
  isExternal: false
  name: DataSet(SerializationInfo,StreamingContext,Boolean)
  nameWithType: DataSet.DataSet(SerializationInfo,StreamingContext,Boolean)
  fullName: System.Data.DataSet.DataSet(SerializationInfo,StreamingContext,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Data.DataSet.AcceptChanges
  parent: System.Data.DataSet
  isExternal: false
  name: AcceptChanges()
  nameWithType: DataSet.AcceptChanges()
  fullName: System.Data.DataSet.AcceptChanges()
- uid: System.Data.DataSet.BeginInit
  parent: System.Data.DataSet
  isExternal: false
  name: BeginInit()
  nameWithType: DataSet.BeginInit()
  fullName: System.Data.DataSet.BeginInit()
- uid: System.Data.DataSet.CaseSensitive
  parent: System.Data.DataSet
  isExternal: false
  name: CaseSensitive
  nameWithType: DataSet.CaseSensitive
  fullName: System.Data.DataSet.CaseSensitive
- uid: System.Data.DataSet.Clear
  parent: System.Data.DataSet
  isExternal: false
  name: Clear()
  nameWithType: DataSet.Clear()
  fullName: System.Data.DataSet.Clear()
- uid: System.Data.DataSet.Clone
  parent: System.Data.DataSet
  isExternal: false
  name: Clone()
  nameWithType: DataSet.Clone()
  fullName: System.Data.DataSet.Clone()
- uid: System.Data.DataSet
  parent: System.Data
  isExternal: false
  name: DataSet
  nameWithType: DataSet
  fullName: System.Data.DataSet
- uid: System.Data.DataSet.Copy
  parent: System.Data.DataSet
  isExternal: false
  name: Copy()
  nameWithType: DataSet.Copy()
  fullName: System.Data.DataSet.Copy()
- uid: System.Data.DataSet.CreateDataReader
  parent: System.Data.DataSet
  isExternal: false
  name: CreateDataReader()
  nameWithType: DataSet.CreateDataReader()
  fullName: System.Data.DataSet.CreateDataReader()
- uid: System.Data.DataTableReader
  parent: System.Data
  isExternal: false
  name: DataTableReader
  nameWithType: DataTableReader
  fullName: System.Data.DataTableReader
- uid: System.Data.DataSet.CreateDataReader(System.Data.DataTable[])
  parent: System.Data.DataSet
  isExternal: false
  name: CreateDataReader(DataTable[])
  nameWithType: DataSet.CreateDataReader(DataTable[])
  fullName: System.Data.DataSet.CreateDataReader(DataTable[])
- uid: System.Data.DataTable[]
  parent: System.Data
  isExternal: false
  name: DataTable
  nameWithType: DataTable
  fullName: System.Data.DataTable[]
  spec.csharp:
  - uid: System.Data.DataTable
    name: DataTable
    nameWithType: DataTable
    fullName: DataTable[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Data.DataSet.DataSetName
  parent: System.Data.DataSet
  isExternal: false
  name: DataSetName
  nameWithType: DataSet.DataSetName
  fullName: System.Data.DataSet.DataSetName
- uid: System.Data.DataSet.DefaultViewManager
  parent: System.Data.DataSet
  isExternal: false
  name: DefaultViewManager
  nameWithType: DataSet.DefaultViewManager
  fullName: System.Data.DataSet.DefaultViewManager
- uid: System.Data.DataViewManager
  parent: System.Data
  isExternal: false
  name: DataViewManager
  nameWithType: DataViewManager
  fullName: System.Data.DataViewManager
- uid: System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)
  parent: System.Data.DataSet
  isExternal: false
  name: DetermineSchemaSerializationMode(XmlReader)
  nameWithType: DataSet.DetermineSchemaSerializationMode(XmlReader)
  fullName: System.Data.DataSet.DetermineSchemaSerializationMode(XmlReader)
- uid: System.Data.SchemaSerializationMode
  parent: System.Data
  isExternal: false
  name: SchemaSerializationMode
  nameWithType: SchemaSerializationMode
  fullName: System.Data.SchemaSerializationMode
- uid: System.Xml.XmlReader
  parent: System.Xml
  isExternal: true
  name: XmlReader
  nameWithType: XmlReader
  fullName: System.Xml.XmlReader
- uid: System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataSet
  isExternal: false
  name: DetermineSchemaSerializationMode(SerializationInfo,StreamingContext)
  nameWithType: DataSet.DetermineSchemaSerializationMode(SerializationInfo,StreamingContext)
  fullName: System.Data.DataSet.DetermineSchemaSerializationMode(SerializationInfo,StreamingContext)
- uid: System.Data.DataSet.EndInit
  parent: System.Data.DataSet
  isExternal: false
  name: EndInit()
  nameWithType: DataSet.EndInit()
  fullName: System.Data.DataSet.EndInit()
- uid: System.Data.DataSet.EnforceConstraints
  parent: System.Data.DataSet
  isExternal: false
  name: EnforceConstraints
  nameWithType: DataSet.EnforceConstraints
  fullName: System.Data.DataSet.EnforceConstraints
- uid: System.Data.DataSet.ExtendedProperties
  parent: System.Data.DataSet
  isExternal: false
  name: ExtendedProperties
  nameWithType: DataSet.ExtendedProperties
  fullName: System.Data.DataSet.ExtendedProperties
- uid: System.Data.PropertyCollection
  parent: System.Data
  isExternal: false
  name: PropertyCollection
  nameWithType: PropertyCollection
  fullName: System.Data.PropertyCollection
- uid: System.Data.DataSet.GetChanges
  parent: System.Data.DataSet
  isExternal: false
  name: GetChanges()
  nameWithType: DataSet.GetChanges()
  fullName: System.Data.DataSet.GetChanges()
- uid: System.Data.DataSet.GetChanges(System.Data.DataRowState)
  parent: System.Data.DataSet
  isExternal: false
  name: GetChanges(DataRowState)
  nameWithType: DataSet.GetChanges(DataRowState)
  fullName: System.Data.DataSet.GetChanges(DataRowState)
- uid: System.Data.DataRowState
  parent: System.Data
  isExternal: false
  name: DataRowState
  nameWithType: DataRowState
  fullName: System.Data.DataRowState
- uid: System.Data.DataSet.GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)
  parent: System.Data.DataSet
  isExternal: false
  name: GetDataSetSchema(XmlSchemaSet)
  nameWithType: DataSet.GetDataSetSchema(XmlSchemaSet)
  fullName: System.Data.DataSet.GetDataSetSchema(XmlSchemaSet)
- uid: System.Xml.Schema.XmlSchemaComplexType
  parent: System.Xml.Schema
  isExternal: false
  name: XmlSchemaComplexType
  nameWithType: XmlSchemaComplexType
  fullName: System.Xml.Schema.XmlSchemaComplexType
- uid: System.Xml.Schema.XmlSchemaSet
  parent: System.Xml.Schema
  isExternal: false
  name: XmlSchemaSet
  nameWithType: XmlSchemaSet
  fullName: System.Xml.Schema.XmlSchemaSet
- uid: System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataSet
  isExternal: false
  name: GetObjectData(SerializationInfo,StreamingContext)
  nameWithType: DataSet.GetObjectData(SerializationInfo,StreamingContext)
  fullName: System.Data.DataSet.GetObjectData(SerializationInfo,StreamingContext)
- uid: System.Data.DataSet.GetSchemaSerializable
  parent: System.Data.DataSet
  isExternal: false
  name: GetSchemaSerializable()
  nameWithType: DataSet.GetSchemaSerializable()
  fullName: System.Data.DataSet.GetSchemaSerializable()
- uid: System.Xml.Schema.XmlSchema
  parent: System.Xml.Schema
  isExternal: true
  name: XmlSchema
  nameWithType: XmlSchema
  fullName: System.Xml.Schema.XmlSchema
- uid: System.Data.DataSet.GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataSet
  isExternal: false
  name: GetSerializationData(SerializationInfo,StreamingContext)
  nameWithType: DataSet.GetSerializationData(SerializationInfo,StreamingContext)
  fullName: System.Data.DataSet.GetSerializationData(SerializationInfo,StreamingContext)
- uid: System.Data.DataSet.GetXml
  parent: System.Data.DataSet
  isExternal: false
  name: GetXml()
  nameWithType: DataSet.GetXml()
  fullName: System.Data.DataSet.GetXml()
- uid: System.Data.DataSet.GetXmlSchema
  parent: System.Data.DataSet
  isExternal: false
  name: GetXmlSchema()
  nameWithType: DataSet.GetXmlSchema()
  fullName: System.Data.DataSet.GetXmlSchema()
- uid: System.Data.DataSet.HasChanges
  parent: System.Data.DataSet
  isExternal: false
  name: HasChanges()
  nameWithType: DataSet.HasChanges()
  fullName: System.Data.DataSet.HasChanges()
- uid: System.Data.DataSet.HasChanges(System.Data.DataRowState)
  parent: System.Data.DataSet
  isExternal: false
  name: HasChanges(DataRowState)
  nameWithType: DataSet.HasChanges(DataRowState)
  fullName: System.Data.DataSet.HasChanges(DataRowState)
- uid: System.Data.DataSet.HasErrors
  parent: System.Data.DataSet
  isExternal: false
  name: HasErrors
  nameWithType: DataSet.HasErrors
  fullName: System.Data.DataSet.HasErrors
- uid: System.Data.DataSet.InferXmlSchema(System.IO.Stream,System.String[])
  parent: System.Data.DataSet
  isExternal: false
  name: InferXmlSchema(Stream,String[])
  nameWithType: DataSet.InferXmlSchema(Stream,String[])
  fullName: System.Data.DataSet.InferXmlSchema(Stream,String[])
- uid: System.IO.Stream
  parent: System.IO
  isExternal: true
  name: Stream
  nameWithType: Stream
  fullName: System.IO.Stream
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Data.DataSet.InferXmlSchema(System.IO.TextReader,System.String[])
  parent: System.Data.DataSet
  isExternal: false
  name: InferXmlSchema(TextReader,String[])
  nameWithType: DataSet.InferXmlSchema(TextReader,String[])
  fullName: System.Data.DataSet.InferXmlSchema(TextReader,String[])
- uid: System.IO.TextReader
  parent: System.IO
  isExternal: true
  name: TextReader
  nameWithType: TextReader
  fullName: System.IO.TextReader
- uid: System.Data.DataSet.InferXmlSchema(System.String,System.String[])
  parent: System.Data.DataSet
  isExternal: false
  name: InferXmlSchema(String,String[])
  nameWithType: DataSet.InferXmlSchema(String,String[])
  fullName: System.Data.DataSet.InferXmlSchema(String,String[])
- uid: System.Data.DataSet.InferXmlSchema(System.Xml.XmlReader,System.String[])
  parent: System.Data.DataSet
  isExternal: false
  name: InferXmlSchema(XmlReader,String[])
  nameWithType: DataSet.InferXmlSchema(XmlReader,String[])
  fullName: System.Data.DataSet.InferXmlSchema(XmlReader,String[])
- uid: System.Data.DataSet.Initialized
  parent: System.Data.DataSet
  isExternal: false
  name: Initialized
  nameWithType: DataSet.Initialized
  fullName: System.Data.DataSet.Initialized
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Data.DataSet.InitializeDerivedDataSet
  parent: System.Data.DataSet
  isExternal: false
  name: InitializeDerivedDataSet()
  nameWithType: DataSet.InitializeDerivedDataSet()
  fullName: System.Data.DataSet.InitializeDerivedDataSet()
- uid: System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataSet
  isExternal: false
  name: IsBinarySerialized(SerializationInfo,StreamingContext)
  nameWithType: DataSet.IsBinarySerialized(SerializationInfo,StreamingContext)
  fullName: System.Data.DataSet.IsBinarySerialized(SerializationInfo,StreamingContext)
- uid: System.Data.DataSet.IsInitialized
  parent: System.Data.DataSet
  isExternal: false
  name: IsInitialized
  nameWithType: DataSet.IsInitialized
  fullName: System.Data.DataSet.IsInitialized
- uid: System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])
  parent: System.Data.DataSet
  isExternal: false
  name: Load(IDataReader,LoadOption,DataTable[])
  nameWithType: DataSet.Load(IDataReader,LoadOption,DataTable[])
  fullName: System.Data.DataSet.Load(IDataReader,LoadOption,DataTable[])
- uid: System.Data.IDataReader
  parent: System.Data
  isExternal: false
  name: IDataReader
  nameWithType: IDataReader
  fullName: System.Data.IDataReader
- uid: System.Data.LoadOption
  parent: System.Data
  isExternal: false
  name: LoadOption
  nameWithType: LoadOption
  fullName: System.Data.LoadOption
- uid: System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])
  parent: System.Data.DataSet
  isExternal: false
  name: Load(IDataReader,LoadOption,String[])
  nameWithType: DataSet.Load(IDataReader,LoadOption,String[])
  fullName: System.Data.DataSet.Load(IDataReader,LoadOption,String[])
- uid: System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])
  parent: System.Data.DataSet
  isExternal: false
  name: Load(IDataReader,LoadOption,FillErrorEventHandler,DataTable[])
  nameWithType: DataSet.Load(IDataReader,LoadOption,FillErrorEventHandler,DataTable[])
  fullName: System.Data.DataSet.Load(IDataReader,LoadOption,FillErrorEventHandler,DataTable[])
- uid: System.Data.FillErrorEventHandler
  parent: System.Data
  isExternal: false
  name: FillErrorEventHandler
  nameWithType: FillErrorEventHandler
  fullName: System.Data.FillErrorEventHandler
- uid: System.Data.DataSet.Locale
  parent: System.Data.DataSet
  isExternal: false
  name: Locale
  nameWithType: DataSet.Locale
  fullName: System.Data.DataSet.Locale
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: true
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.Data.DataSet.Merge(System.Data.DataRow[])
  parent: System.Data.DataSet
  isExternal: false
  name: Merge(DataRow[])
  nameWithType: DataSet.Merge(DataRow[])
  fullName: System.Data.DataSet.Merge(DataRow[])
- uid: System.Data.DataRow[]
  parent: System.Data
  isExternal: false
  name: DataRow
  nameWithType: DataRow
  fullName: System.Data.DataRow[]
  spec.csharp:
  - uid: System.Data.DataRow
    name: DataRow
    nameWithType: DataRow
    fullName: DataRow[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Data.DataSet.Merge(System.Data.DataSet)
  parent: System.Data.DataSet
  isExternal: false
  name: Merge(DataSet)
  nameWithType: DataSet.Merge(DataSet)
  fullName: System.Data.DataSet.Merge(DataSet)
- uid: System.Data.DataSet.Merge(System.Data.DataTable)
  parent: System.Data.DataSet
  isExternal: false
  name: Merge(DataTable)
  nameWithType: DataSet.Merge(DataTable)
  fullName: System.Data.DataSet.Merge(DataTable)
- uid: System.Data.DataTable
  parent: System.Data
  isExternal: false
  name: DataTable
  nameWithType: DataTable
  fullName: System.Data.DataTable
- uid: System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)
  parent: System.Data.DataSet
  isExternal: false
  name: Merge(DataSet,Boolean)
  nameWithType: DataSet.Merge(DataSet,Boolean)
  fullName: System.Data.DataSet.Merge(DataSet,Boolean)
- uid: System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)
  parent: System.Data.DataSet
  isExternal: false
  name: Merge(DataRow[],Boolean,MissingSchemaAction)
  nameWithType: DataSet.Merge(DataRow[],Boolean,MissingSchemaAction)
  fullName: System.Data.DataSet.Merge(DataRow[],Boolean,MissingSchemaAction)
- uid: System.Data.MissingSchemaAction
  parent: System.Data
  isExternal: false
  name: MissingSchemaAction
  nameWithType: MissingSchemaAction
  fullName: System.Data.MissingSchemaAction
- uid: System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)
  parent: System.Data.DataSet
  isExternal: false
  name: Merge(DataSet,Boolean,MissingSchemaAction)
  nameWithType: DataSet.Merge(DataSet,Boolean,MissingSchemaAction)
  fullName: System.Data.DataSet.Merge(DataSet,Boolean,MissingSchemaAction)
- uid: System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)
  parent: System.Data.DataSet
  isExternal: false
  name: Merge(DataTable,Boolean,MissingSchemaAction)
  nameWithType: DataSet.Merge(DataTable,Boolean,MissingSchemaAction)
  fullName: System.Data.DataSet.Merge(DataTable,Boolean,MissingSchemaAction)
- uid: System.Data.DataSet.MergeFailed
  parent: System.Data.DataSet
  isExternal: false
  name: MergeFailed
  nameWithType: DataSet.MergeFailed
  fullName: System.Data.DataSet.MergeFailed
- uid: System.Data.MergeFailedEventHandler
  parent: System.Data
  isExternal: false
  name: MergeFailedEventHandler
  nameWithType: MergeFailedEventHandler
  fullName: System.Data.MergeFailedEventHandler
- uid: System.Data.DataSet.Namespace
  parent: System.Data.DataSet
  isExternal: false
  name: Namespace
  nameWithType: DataSet.Namespace
  fullName: System.Data.DataSet.Namespace
- uid: System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)
  parent: System.Data.DataSet
  isExternal: false
  name: OnPropertyChanging(PropertyChangedEventArgs)
  nameWithType: DataSet.OnPropertyChanging(PropertyChangedEventArgs)
  fullName: System.Data.DataSet.OnPropertyChanging(PropertyChangedEventArgs)
- uid: System.ComponentModel.PropertyChangedEventArgs
  parent: System.ComponentModel
  isExternal: true
  name: PropertyChangedEventArgs
  nameWithType: PropertyChangedEventArgs
  fullName: System.ComponentModel.PropertyChangedEventArgs
- uid: System.Data.DataSet.OnRemoveRelation(System.Data.DataRelation)
  parent: System.Data.DataSet
  isExternal: false
  name: OnRemoveRelation(DataRelation)
  nameWithType: DataSet.OnRemoveRelation(DataRelation)
  fullName: System.Data.DataSet.OnRemoveRelation(DataRelation)
- uid: System.Data.DataRelation
  parent: System.Data
  isExternal: false
  name: DataRelation
  nameWithType: DataRelation
  fullName: System.Data.DataRelation
- uid: System.Data.DataSet.OnRemoveTable(System.Data.DataTable)
  parent: System.Data.DataSet
  isExternal: false
  name: OnRemoveTable(DataTable)
  nameWithType: DataSet.OnRemoveTable(DataTable)
  fullName: System.Data.DataSet.OnRemoveTable(DataTable)
- uid: System.Data.DataSet.Prefix
  parent: System.Data.DataSet
  isExternal: false
  name: Prefix
  nameWithType: DataSet.Prefix
  fullName: System.Data.DataSet.Prefix
- uid: System.Data.DataSet.RaisePropertyChanging(System.String)
  parent: System.Data.DataSet
  isExternal: false
  name: RaisePropertyChanging(String)
  nameWithType: DataSet.RaisePropertyChanging(String)
  fullName: System.Data.DataSet.RaisePropertyChanging(String)
- uid: System.Data.DataSet.ReadXml(System.IO.Stream)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXml(Stream)
  nameWithType: DataSet.ReadXml(Stream)
  fullName: System.Data.DataSet.ReadXml(Stream)
- uid: System.Data.XmlReadMode
  parent: System.Data
  isExternal: false
  name: XmlReadMode
  nameWithType: XmlReadMode
  fullName: System.Data.XmlReadMode
- uid: System.Data.DataSet.ReadXml(System.IO.TextReader)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXml(TextReader)
  nameWithType: DataSet.ReadXml(TextReader)
  fullName: System.Data.DataSet.ReadXml(TextReader)
- uid: System.Data.DataSet.ReadXml(System.String)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXml(String)
  nameWithType: DataSet.ReadXml(String)
  fullName: System.Data.DataSet.ReadXml(String)
- uid: System.Data.DataSet.ReadXml(System.Xml.XmlReader)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXml(XmlReader)
  nameWithType: DataSet.ReadXml(XmlReader)
  fullName: System.Data.DataSet.ReadXml(XmlReader)
- uid: System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXml(Stream,XmlReadMode)
  nameWithType: DataSet.ReadXml(Stream,XmlReadMode)
  fullName: System.Data.DataSet.ReadXml(Stream,XmlReadMode)
- uid: System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXml(TextReader,XmlReadMode)
  nameWithType: DataSet.ReadXml(TextReader,XmlReadMode)
  fullName: System.Data.DataSet.ReadXml(TextReader,XmlReadMode)
- uid: System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXml(String,XmlReadMode)
  nameWithType: DataSet.ReadXml(String,XmlReadMode)
  fullName: System.Data.DataSet.ReadXml(String,XmlReadMode)
- uid: System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXml(XmlReader,XmlReadMode)
  nameWithType: DataSet.ReadXml(XmlReader,XmlReadMode)
  fullName: System.Data.DataSet.ReadXml(XmlReader,XmlReadMode)
- uid: System.Data.DataSet.ReadXmlSchema(System.IO.Stream)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXmlSchema(Stream)
  nameWithType: DataSet.ReadXmlSchema(Stream)
  fullName: System.Data.DataSet.ReadXmlSchema(Stream)
- uid: System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXmlSchema(TextReader)
  nameWithType: DataSet.ReadXmlSchema(TextReader)
  fullName: System.Data.DataSet.ReadXmlSchema(TextReader)
- uid: System.Data.DataSet.ReadXmlSchema(System.String)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXmlSchema(String)
  nameWithType: DataSet.ReadXmlSchema(String)
  fullName: System.Data.DataSet.ReadXmlSchema(String)
- uid: System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXmlSchema(XmlReader)
  nameWithType: DataSet.ReadXmlSchema(XmlReader)
  fullName: System.Data.DataSet.ReadXmlSchema(XmlReader)
- uid: System.Data.DataSet.ReadXmlSerializable(System.Xml.XmlReader)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXmlSerializable(XmlReader)
  nameWithType: DataSet.ReadXmlSerializable(XmlReader)
  fullName: System.Data.DataSet.ReadXmlSerializable(XmlReader)
- uid: System.Data.DataSet.RejectChanges
  parent: System.Data.DataSet
  isExternal: false
  name: RejectChanges()
  nameWithType: DataSet.RejectChanges()
  fullName: System.Data.DataSet.RejectChanges()
- uid: System.Data.DataSet.Relations
  parent: System.Data.DataSet
  isExternal: false
  name: Relations
  nameWithType: DataSet.Relations
  fullName: System.Data.DataSet.Relations
- uid: System.Data.DataRelationCollection
  parent: System.Data
  isExternal: false
  name: DataRelationCollection
  nameWithType: DataRelationCollection
  fullName: System.Data.DataRelationCollection
- uid: System.Data.DataSet.RemotingFormat
  parent: System.Data.DataSet
  isExternal: false
  name: RemotingFormat
  nameWithType: DataSet.RemotingFormat
  fullName: System.Data.DataSet.RemotingFormat
- uid: System.Data.SerializationFormat
  parent: System.Data
  isExternal: false
  name: SerializationFormat
  nameWithType: SerializationFormat
  fullName: System.Data.SerializationFormat
- uid: System.Data.DataSet.Reset
  parent: System.Data.DataSet
  isExternal: false
  name: Reset()
  nameWithType: DataSet.Reset()
  fullName: System.Data.DataSet.Reset()
- uid: System.Data.DataSet.SchemaSerializationMode
  parent: System.Data.DataSet
  isExternal: false
  name: SchemaSerializationMode
  nameWithType: DataSet.SchemaSerializationMode
  fullName: System.Data.DataSet.SchemaSerializationMode
- uid: System.Data.DataSet.ShouldSerializeRelations
  parent: System.Data.DataSet
  isExternal: false
  name: ShouldSerializeRelations()
  nameWithType: DataSet.ShouldSerializeRelations()
  fullName: System.Data.DataSet.ShouldSerializeRelations()
- uid: System.Data.DataSet.ShouldSerializeTables
  parent: System.Data.DataSet
  isExternal: false
  name: ShouldSerializeTables()
  nameWithType: DataSet.ShouldSerializeTables()
  fullName: System.Data.DataSet.ShouldSerializeTables()
- uid: System.Data.DataSet.Site
  parent: System.Data.DataSet
  isExternal: false
  name: Site
  nameWithType: DataSet.Site
  fullName: System.Data.DataSet.Site
- uid: System.ComponentModel.ISite
  parent: System.ComponentModel
  isExternal: false
  name: ISite
  nameWithType: ISite
  fullName: System.ComponentModel.ISite
- uid: System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection
  parent: System.Data.DataSet
  isExternal: false
  name: System.ComponentModel.IListSource.ContainsListCollection
  nameWithType: DataSet.System.ComponentModel.IListSource.ContainsListCollection
  fullName: System.Data.DataSet.System.ComponentModel.IListSource.ContainsListCollection
- uid: System.Data.DataSet.System#ComponentModel#IListSource#GetList
  parent: System.Data.DataSet
  isExternal: false
  name: System.ComponentModel.IListSource.GetList()
  nameWithType: DataSet.System.ComponentModel.IListSource.GetList()
  fullName: System.Data.DataSet.System.ComponentModel.IListSource.GetList()
- uid: System.Collections.IList
  parent: System.Collections
  isExternal: true
  name: IList
  nameWithType: IList
  fullName: System.Collections.IList
- uid: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema
  parent: System.Data.DataSet
  isExternal: false
  name: System.Xml.Serialization.IXmlSerializable.GetSchema()
  nameWithType: DataSet.System.Xml.Serialization.IXmlSerializable.GetSchema()
  fullName: System.Data.DataSet.System.Xml.Serialization.IXmlSerializable.GetSchema()
- uid: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
  parent: System.Data.DataSet
  isExternal: false
  name: System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
  nameWithType: DataSet.System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
  fullName: System.Data.DataSet.System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
- uid: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
  parent: System.Data.DataSet
  isExternal: false
  name: System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
  nameWithType: DataSet.System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
  fullName: System.Data.DataSet.System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
- uid: System.Xml.XmlWriter
  parent: System.Xml
  isExternal: true
  name: XmlWriter
  nameWithType: XmlWriter
  fullName: System.Xml.XmlWriter
- uid: System.Data.DataSet.Tables
  parent: System.Data.DataSet
  isExternal: false
  name: Tables
  nameWithType: DataSet.Tables
  fullName: System.Data.DataSet.Tables
- uid: System.Data.DataTableCollection
  parent: System.Data
  isExternal: false
  name: DataTableCollection
  nameWithType: DataTableCollection
  fullName: System.Data.DataTableCollection
- uid: System.Data.DataSet.WriteXml(System.IO.Stream)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXml(Stream)
  nameWithType: DataSet.WriteXml(Stream)
  fullName: System.Data.DataSet.WriteXml(Stream)
- uid: System.Data.DataSet.WriteXml(System.IO.TextWriter)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXml(TextWriter)
  nameWithType: DataSet.WriteXml(TextWriter)
  fullName: System.Data.DataSet.WriteXml(TextWriter)
- uid: System.IO.TextWriter
  parent: System.IO
  isExternal: true
  name: TextWriter
  nameWithType: TextWriter
  fullName: System.IO.TextWriter
- uid: System.Data.DataSet.WriteXml(System.String)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXml(String)
  nameWithType: DataSet.WriteXml(String)
  fullName: System.Data.DataSet.WriteXml(String)
- uid: System.Data.DataSet.WriteXml(System.Xml.XmlWriter)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXml(XmlWriter)
  nameWithType: DataSet.WriteXml(XmlWriter)
  fullName: System.Data.DataSet.WriteXml(XmlWriter)
- uid: System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXml(Stream,XmlWriteMode)
  nameWithType: DataSet.WriteXml(Stream,XmlWriteMode)
  fullName: System.Data.DataSet.WriteXml(Stream,XmlWriteMode)
- uid: System.Data.XmlWriteMode
  parent: System.Data
  isExternal: false
  name: XmlWriteMode
  nameWithType: XmlWriteMode
  fullName: System.Data.XmlWriteMode
- uid: System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXml(TextWriter,XmlWriteMode)
  nameWithType: DataSet.WriteXml(TextWriter,XmlWriteMode)
  fullName: System.Data.DataSet.WriteXml(TextWriter,XmlWriteMode)
- uid: System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXml(String,XmlWriteMode)
  nameWithType: DataSet.WriteXml(String,XmlWriteMode)
  fullName: System.Data.DataSet.WriteXml(String,XmlWriteMode)
- uid: System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXml(XmlWriter,XmlWriteMode)
  nameWithType: DataSet.WriteXml(XmlWriter,XmlWriteMode)
  fullName: System.Data.DataSet.WriteXml(XmlWriter,XmlWriteMode)
- uid: System.Data.DataSet.WriteXmlSchema(System.IO.Stream)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXmlSchema(Stream)
  nameWithType: DataSet.WriteXmlSchema(Stream)
  fullName: System.Data.DataSet.WriteXmlSchema(Stream)
- uid: System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXmlSchema(TextWriter)
  nameWithType: DataSet.WriteXmlSchema(TextWriter)
  fullName: System.Data.DataSet.WriteXmlSchema(TextWriter)
- uid: System.Data.DataSet.WriteXmlSchema(System.String)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXmlSchema(String)
  nameWithType: DataSet.WriteXmlSchema(String)
  fullName: System.Data.DataSet.WriteXmlSchema(String)
- uid: System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXmlSchema(XmlWriter)
  nameWithType: DataSet.WriteXmlSchema(XmlWriter)
  fullName: System.Data.DataSet.WriteXmlSchema(XmlWriter)
- uid: System.Data.DataSet.WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXmlSchema(Stream,Converter<Type,String>)
  nameWithType: DataSet.WriteXmlSchema(Stream,Converter<Type,String>)
  fullName: System.Data.DataSet.WriteXmlSchema(Stream,Converter<Type,String>)
- uid: System.Converter{System.Type,System.String}
  parent: System
  isExternal: false
  name: Converter<Type,String>
  nameWithType: Converter<Type,String>
  fullName: System.Converter<System.Type,System.String>
  spec.csharp:
  - uid: System.Converter`2
    name: Converter
    nameWithType: Converter
    fullName: Converter<System.Type,System.String>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Type
    name: Type
    nameWithType: Type
    fullName: Type
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXmlSchema(TextWriter,Converter<Type,String>)
  nameWithType: DataSet.WriteXmlSchema(TextWriter,Converter<Type,String>)
  fullName: System.Data.DataSet.WriteXmlSchema(TextWriter,Converter<Type,String>)
- uid: System.Data.DataSet.WriteXmlSchema(System.String,System.Converter{System.Type,System.String})
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXmlSchema(String,Converter<Type,String>)
  nameWithType: DataSet.WriteXmlSchema(String,Converter<Type,String>)
  fullName: System.Data.DataSet.WriteXmlSchema(String,Converter<Type,String>)
- uid: System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXmlSchema(XmlWriter,Converter<Type,String>)
  nameWithType: DataSet.WriteXmlSchema(XmlWriter,Converter<Type,String>)
  fullName: System.Data.DataSet.WriteXmlSchema(XmlWriter,Converter<Type,String>)
- uid: System.Data.DataSet.#ctor*
  parent: System.Data.DataSet
  isExternal: false
  name: DataSet
  nameWithType: DataSet.DataSet
- uid: System.Data.DataSet.AcceptChanges*
  parent: System.Data.DataSet
  isExternal: false
  name: AcceptChanges
  nameWithType: DataSet.AcceptChanges
- uid: System.Data.DataSet.BeginInit*
  parent: System.Data.DataSet
  isExternal: false
  name: BeginInit
  nameWithType: DataSet.BeginInit
- uid: System.Data.DataSet.CaseSensitive*
  parent: System.Data.DataSet
  isExternal: false
  name: CaseSensitive
  nameWithType: DataSet.CaseSensitive
- uid: System.Data.DataSet.Clear*
  parent: System.Data.DataSet
  isExternal: false
  name: Clear
  nameWithType: DataSet.Clear
- uid: System.Data.DataSet.Clone*
  parent: System.Data.DataSet
  isExternal: false
  name: Clone
  nameWithType: DataSet.Clone
- uid: System.Data.DataSet.Copy*
  parent: System.Data.DataSet
  isExternal: false
  name: Copy
  nameWithType: DataSet.Copy
- uid: System.Data.DataSet.CreateDataReader*
  parent: System.Data.DataSet
  isExternal: false
  name: CreateDataReader
  nameWithType: DataSet.CreateDataReader
- uid: System.Data.DataSet.DataSetName*
  parent: System.Data.DataSet
  isExternal: false
  name: DataSetName
  nameWithType: DataSet.DataSetName
- uid: System.Data.DataSet.DefaultViewManager*
  parent: System.Data.DataSet
  isExternal: false
  name: DefaultViewManager
  nameWithType: DataSet.DefaultViewManager
- uid: System.Data.DataSet.DetermineSchemaSerializationMode*
  parent: System.Data.DataSet
  isExternal: false
  name: DetermineSchemaSerializationMode
  nameWithType: DataSet.DetermineSchemaSerializationMode
- uid: System.Data.DataSet.EndInit*
  parent: System.Data.DataSet
  isExternal: false
  name: EndInit
  nameWithType: DataSet.EndInit
- uid: System.Data.DataSet.EnforceConstraints*
  parent: System.Data.DataSet
  isExternal: false
  name: EnforceConstraints
  nameWithType: DataSet.EnforceConstraints
- uid: System.Data.DataSet.ExtendedProperties*
  parent: System.Data.DataSet
  isExternal: false
  name: ExtendedProperties
  nameWithType: DataSet.ExtendedProperties
- uid: System.Data.DataSet.GetChanges*
  parent: System.Data.DataSet
  isExternal: false
  name: GetChanges
  nameWithType: DataSet.GetChanges
- uid: System.Data.DataSet.GetDataSetSchema*
  parent: System.Data.DataSet
  isExternal: false
  name: GetDataSetSchema
  nameWithType: DataSet.GetDataSetSchema
- uid: System.Data.DataSet.GetObjectData*
  parent: System.Data.DataSet
  isExternal: false
  name: GetObjectData
  nameWithType: DataSet.GetObjectData
- uid: System.Data.DataSet.GetSchemaSerializable*
  parent: System.Data.DataSet
  isExternal: false
  name: GetSchemaSerializable
  nameWithType: DataSet.GetSchemaSerializable
- uid: System.Data.DataSet.GetSerializationData*
  parent: System.Data.DataSet
  isExternal: false
  name: GetSerializationData
  nameWithType: DataSet.GetSerializationData
- uid: System.Data.DataSet.GetXml*
  parent: System.Data.DataSet
  isExternal: false
  name: GetXml
  nameWithType: DataSet.GetXml
- uid: System.Data.DataSet.GetXmlSchema*
  parent: System.Data.DataSet
  isExternal: false
  name: GetXmlSchema
  nameWithType: DataSet.GetXmlSchema
- uid: System.Data.DataSet.HasChanges*
  parent: System.Data.DataSet
  isExternal: false
  name: HasChanges
  nameWithType: DataSet.HasChanges
- uid: System.Data.DataSet.HasErrors*
  parent: System.Data.DataSet
  isExternal: false
  name: HasErrors
  nameWithType: DataSet.HasErrors
- uid: System.Data.DataSet.InferXmlSchema*
  parent: System.Data.DataSet
  isExternal: false
  name: InferXmlSchema
  nameWithType: DataSet.InferXmlSchema
- uid: System.Data.DataSet.InitializeDerivedDataSet*
  parent: System.Data.DataSet
  isExternal: false
  name: InitializeDerivedDataSet
  nameWithType: DataSet.InitializeDerivedDataSet
- uid: System.Data.DataSet.IsBinarySerialized*
  parent: System.Data.DataSet
  isExternal: false
  name: IsBinarySerialized
  nameWithType: DataSet.IsBinarySerialized
- uid: System.Data.DataSet.IsInitialized*
  parent: System.Data.DataSet
  isExternal: false
  name: IsInitialized
  nameWithType: DataSet.IsInitialized
- uid: System.Data.DataSet.Load*
  parent: System.Data.DataSet
  isExternal: false
  name: Load
  nameWithType: DataSet.Load
- uid: System.Data.DataSet.Locale*
  parent: System.Data.DataSet
  isExternal: false
  name: Locale
  nameWithType: DataSet.Locale
- uid: System.Data.DataSet.Merge*
  parent: System.Data.DataSet
  isExternal: false
  name: Merge
  nameWithType: DataSet.Merge
- uid: System.Data.DataSet.Namespace*
  parent: System.Data.DataSet
  isExternal: false
  name: Namespace
  nameWithType: DataSet.Namespace
- uid: System.Data.DataSet.OnPropertyChanging*
  parent: System.Data.DataSet
  isExternal: false
  name: OnPropertyChanging
  nameWithType: DataSet.OnPropertyChanging
- uid: System.Data.DataSet.OnRemoveRelation*
  parent: System.Data.DataSet
  isExternal: false
  name: OnRemoveRelation
  nameWithType: DataSet.OnRemoveRelation
- uid: System.Data.DataSet.OnRemoveTable*
  parent: System.Data.DataSet
  isExternal: false
  name: OnRemoveTable
  nameWithType: DataSet.OnRemoveTable
- uid: System.Data.DataSet.Prefix*
  parent: System.Data.DataSet
  isExternal: false
  name: Prefix
  nameWithType: DataSet.Prefix
- uid: System.Data.DataSet.RaisePropertyChanging*
  parent: System.Data.DataSet
  isExternal: false
  name: RaisePropertyChanging
  nameWithType: DataSet.RaisePropertyChanging
- uid: System.Data.DataSet.ReadXml*
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXml
  nameWithType: DataSet.ReadXml
- uid: System.Data.DataSet.ReadXmlSchema*
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXmlSchema
  nameWithType: DataSet.ReadXmlSchema
- uid: System.Data.DataSet.ReadXmlSerializable*
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXmlSerializable
  nameWithType: DataSet.ReadXmlSerializable
- uid: System.Data.DataSet.RejectChanges*
  parent: System.Data.DataSet
  isExternal: false
  name: RejectChanges
  nameWithType: DataSet.RejectChanges
- uid: System.Data.DataSet.Relations*
  parent: System.Data.DataSet
  isExternal: false
  name: Relations
  nameWithType: DataSet.Relations
- uid: System.Data.DataSet.RemotingFormat*
  parent: System.Data.DataSet
  isExternal: false
  name: RemotingFormat
  nameWithType: DataSet.RemotingFormat
- uid: System.Data.DataSet.Reset*
  parent: System.Data.DataSet
  isExternal: false
  name: Reset
  nameWithType: DataSet.Reset
- uid: System.Data.DataSet.SchemaSerializationMode*
  parent: System.Data.DataSet
  isExternal: false
  name: SchemaSerializationMode
  nameWithType: DataSet.SchemaSerializationMode
- uid: System.Data.DataSet.ShouldSerializeRelations*
  parent: System.Data.DataSet
  isExternal: false
  name: ShouldSerializeRelations
  nameWithType: DataSet.ShouldSerializeRelations
- uid: System.Data.DataSet.ShouldSerializeTables*
  parent: System.Data.DataSet
  isExternal: false
  name: ShouldSerializeTables
  nameWithType: DataSet.ShouldSerializeTables
- uid: System.Data.DataSet.Site*
  parent: System.Data.DataSet
  isExternal: false
  name: Site
  nameWithType: DataSet.Site
- uid: System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection*
  parent: System.Data.DataSet
  isExternal: false
  name: System.ComponentModel.IListSource.ContainsListCollection
  nameWithType: DataSet.System.ComponentModel.IListSource.ContainsListCollection
- uid: System.Data.DataSet.System#ComponentModel#IListSource#GetList*
  parent: System.Data.DataSet
  isExternal: false
  name: System.ComponentModel.IListSource.GetList
  nameWithType: DataSet.System.ComponentModel.IListSource.GetList
- uid: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema*
  parent: System.Data.DataSet
  isExternal: false
  name: System.Xml.Serialization.IXmlSerializable.GetSchema
  nameWithType: DataSet.System.Xml.Serialization.IXmlSerializable.GetSchema
- uid: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml*
  parent: System.Data.DataSet
  isExternal: false
  name: System.Xml.Serialization.IXmlSerializable.ReadXml
  nameWithType: DataSet.System.Xml.Serialization.IXmlSerializable.ReadXml
- uid: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml*
  parent: System.Data.DataSet
  isExternal: false
  name: System.Xml.Serialization.IXmlSerializable.WriteXml
  nameWithType: DataSet.System.Xml.Serialization.IXmlSerializable.WriteXml
- uid: System.Data.DataSet.Tables*
  parent: System.Data.DataSet
  isExternal: false
  name: Tables
  nameWithType: DataSet.Tables
- uid: System.Data.DataSet.WriteXml*
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXml
  nameWithType: DataSet.WriteXml
- uid: System.Data.DataSet.WriteXmlSchema*
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXmlSchema
  nameWithType: DataSet.WriteXmlSchema
