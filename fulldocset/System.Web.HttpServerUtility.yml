### YamlMime:ManagedReference
items:
- uid: System.Web.HttpServerUtility
  id: HttpServerUtility
  children:
  - System.Web.HttpServerUtility.ClearError
  - System.Web.HttpServerUtility.CreateObject(System.String)
  - System.Web.HttpServerUtility.CreateObject(System.Type)
  - System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)
  - System.Web.HttpServerUtility.Execute(System.String)
  - System.Web.HttpServerUtility.Execute(System.String,System.Boolean)
  - System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter)
  - System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter,System.Boolean)
  - System.Web.HttpServerUtility.Execute(System.Web.IHttpHandler,System.IO.TextWriter,System.Boolean)
  - System.Web.HttpServerUtility.GetLastError
  - System.Web.HttpServerUtility.HtmlDecode(System.String)
  - System.Web.HttpServerUtility.HtmlDecode(System.String,System.IO.TextWriter)
  - System.Web.HttpServerUtility.HtmlEncode(System.String)
  - System.Web.HttpServerUtility.HtmlEncode(System.String,System.IO.TextWriter)
  - System.Web.HttpServerUtility.MachineName
  - System.Web.HttpServerUtility.MapPath(System.String)
  - System.Web.HttpServerUtility.ScriptTimeout
  - System.Web.HttpServerUtility.Transfer(System.String)
  - System.Web.HttpServerUtility.Transfer(System.String,System.Boolean)
  - System.Web.HttpServerUtility.Transfer(System.Web.IHttpHandler,System.Boolean)
  - System.Web.HttpServerUtility.TransferRequest(System.String)
  - System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean)
  - System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection)
  - System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)
  - System.Web.HttpServerUtility.UrlDecode(System.String)
  - System.Web.HttpServerUtility.UrlDecode(System.String,System.IO.TextWriter)
  - System.Web.HttpServerUtility.UrlEncode(System.String)
  - System.Web.HttpServerUtility.UrlEncode(System.String,System.IO.TextWriter)
  - System.Web.HttpServerUtility.UrlPathEncode(System.String)
  - System.Web.HttpServerUtility.UrlTokenDecode(System.String)
  - System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])
  langs:
  - csharp
  name: HttpServerUtility
  nameWithType: HttpServerUtility
  fullName: System.Web.HttpServerUtility
  type: Class
  summary: "提供用于处理 Web 请求的 helper 方法。"
  remarks: "通过内部公开的方法和属性的 HttpServerUtility 类<xref:System.Web.HttpContext.Server%2A>由 ASP.NET 提供的对象。</xref:System.Web.HttpContext.Server%2A>"
  example:
  - "A Visual Studio Web site project with source code is available to accompany this topic: [Download](http://go.microsoft.com/fwlink/?LinkId=192870).  \n  \n The following example demonstrates how to use the <xref:System.Web.HttpServerUtility.HtmlEncode%2A> method and the <xref:System.Web.HttpServerUtility.UrlEncode%2A> method of the HttpServerUtility class. The <xref:System.Web.HttpServerUtility.HtmlEncode%2A> method helps ensure that any user-supplied string input will be rendered as static text in browsers instead of executable script or HTML elements. The <xref:System.Web.HttpServerUtility.UrlEncode%2A> method encodes URLs so that they are correctly transmitted in the HTTP stream.  \n  \n [!code-cs[System.Web.HttpServerUtility1#1](~/add/codesnippet/csharp/t-system.web.httpserveru_1.aspx)]\n [!code-vb[System.Web.HttpServerUtility1#1](~/add/codesnippet/visualbasic/t-system.web.httpserveru_1.aspx)]"
  syntax:
    content: public sealed class HttpServerUtility
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Web.HttpServerUtility.ClearError
  id: ClearError
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: ClearError()
  nameWithType: HttpServerUtility.ClearError()
  fullName: System.Web.HttpServerUtility.ClearError()
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "清除前一个异常。"
  remarks: ''
  example:
  - "The following example clears the last exception that was thrown.  \n  \n [!code-cs[Classic HttpServerUtility.ClearError Example#1](~/add/codesnippet/csharp/m-system.web.httpserveru_6_1.cs)]\n [!code-vb[Classic HttpServerUtility.ClearError Example#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_6_1.vb)]"
  syntax:
    content: public void ClearError ();
    parameters: []
  overload: System.Web.HttpServerUtility.ClearError*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpServerUtility.CreateObject(System.String)
  id: CreateObject(System.String)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: CreateObject(String)
  nameWithType: HttpServerUtility.CreateObject(String)
  fullName: System.Web.HttpServerUtility.CreateObject(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "创建 COM 对象由对象的编程标识符 (ProgID) 标识的服务器实例。"
  remarks: ''
  example:
  - "The following example creates an object by using the object's ProgID.  \n  \n [!code-vb[Classic HttpServerUtility.CreateObject Example#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_4_1.vb)]\n [!code-cs[Classic HttpServerUtility.CreateObject Example#1](~/add/codesnippet/csharp/m-system.web.httpserveru_4_1.cs)]"
  syntax:
    content: public object CreateObject (string progID);
    parameters:
    - id: progID
      type: System.String
      description: "类或要创建的实例的对象类型。"
    return:
      type: System.Object
      description: "新对象。"
  overload: System.Web.HttpServerUtility.CreateObject*
  exceptions:
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "无法创建对象的实例。"
  platform:
  - net462
- uid: System.Web.HttpServerUtility.CreateObject(System.Type)
  id: CreateObject(System.Type)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: CreateObject(Type)
  nameWithType: HttpServerUtility.CreateObject(Type)
  fullName: System.Web.HttpServerUtility.CreateObject(Type)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "创建 COM 对象由对象的类型标识的服务器实例。"
  syntax:
    content: public object CreateObject (Type type);
    parameters:
    - id: type
      type: System.Type
      description: "A<xref:System.Type>表示要创建的对象。</xref:System.Type>"
    return:
      type: System.Object
      description: "新对象。"
  overload: System.Web.HttpServerUtility.CreateObject*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)
  id: CreateObjectFromClsid(System.String)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: CreateObjectFromClsid(String)
  nameWithType: HttpServerUtility.CreateObjectFromClsid(String)
  fullName: System.Web.HttpServerUtility.CreateObjectFromClsid(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "创建 COM 对象由对象的类标识符 (CLSID) 标识的服务器实例。"
  remarks: ''
  example:
  - "The following example demonstrates how to use the CreateObjectFromClsid method to create a server instance of a COM object.  \n  \n [!code-cs[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/add/codesnippet/csharp/m-system.web.httpserveru_2_1.cs)]\n [!code-vb[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_2_1.vb)]"
  syntax:
    content: public object CreateObjectFromClsid (string clsid);
    parameters:
    - id: clsid
      type: System.String
      description: "要创建的实例的对象类标识符。"
    return:
      type: System.Object
      description: "新对象。"
  overload: System.Web.HttpServerUtility.CreateObjectFromClsid*
  exceptions:
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "无法创建对象的实例。"
  platform:
  - net462
- uid: System.Web.HttpServerUtility.Execute(System.String)
  id: Execute(System.String)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: Execute(String)
  nameWithType: HttpServerUtility.Execute(String)
  fullName: System.Web.HttpServerUtility.Execute(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "当前请求的上下文中执行指定虚拟路径的处理程序。"
  remarks: "完成执行新页后，在执行方法会继续执行原始页。 <xref:System.Web.HttpServerUtility.Transfer%2A>方法将执行无条件地转移到另一个处理程序。</xref:System.Web.HttpServerUtility.Transfer%2A>       ASP.NET 不会验证当前用户有权查看的 Execute 方法通过其传递的资源。 尽管 ASP.NET 授权和身份验证逻辑运行于调用原始资源处理程序之前，ASP.NET 将直接调用 Execute 方法指示的处理程序，并不重新运行新的资源的身份验证和授权逻辑。 如果你的应用程序的安全策略要求客户端具有适当的授权才能访问资源，应用程序应强制重新授权或提供自定义访问控制机制。       你可以通过使用强制重新授权<xref:System.Web.HttpResponse.Redirect%2A>方法而不是 Execute 方法。</xref:System.Web.HttpResponse.Redirect%2A> <xref:System.Web.HttpResponse.Redirect%2A>执行在其中浏览器请求新的资源的客户端的重定向。</xref:System.Web.HttpResponse.Redirect%2A> 此重定向时输入系统的新请求，因为它会对进行的 Internet 信息服务 (IIS) 和 ASP.NET 安全策略的所有身份验证和授权逻辑。       你可以验证该用户有权通过结合使用的自定义授权方法查看资源<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>方法之前应用程序调用 Execute 方法。</xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>"
  example:
  - "The following example displays the .aspx page \"Updateinfo.aspx\" in the current directory. Program execution returns to the starting page after the Updateinfo.aspx page is displayed.  \n  \n [!code-vb[Classic HttpServerUtility.Execute Example#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_15_1.vb)]\n [!code-cs[Classic HttpServerUtility.Execute Example#1](~/add/codesnippet/csharp/m-system.web.httpserveru_15_1.cs)]"
  syntax:
    content: public void Execute (string path);
    parameters:
    - id: path
      type: System.String
      description: "要执行的 URL 路径。"
  overload: System.Web.HttpServerUtility.Execute*
  exceptions:
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "The current <xref href=\"System.Web.HttpContext\"></xref> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n An error occurred while executing the handler specified by <code>path</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>path</code> is not a virtual path."
  platform:
  - net462
- uid: System.Web.HttpServerUtility.Execute(System.String,System.Boolean)
  id: Execute(System.String,System.Boolean)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: Execute(String,Boolean)
  nameWithType: HttpServerUtility.Execute(String,Boolean)
  fullName: System.Web.HttpServerUtility.Execute(String,Boolean)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "当前请求的上下文中执行指定虚拟路径的处理程序，并指定是否清除<> *1> 和<> *1> 集合。"
  remarks: ''
  example:
  - "The following example shows how to execute the .aspx page `Updateinfo.aspx` in the current request and preserve the <xref:System.Web.HttpRequest.QueryString%2A> and <xref:System.Web.HttpRequest.Form%2A> collections. Program execution returns to the starting page after `Updateinfo.aspx` is displayed.  \n  \n [!code-vb[HttpServerUtility.Execute#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_16_1.aspx)]\n [!code-cs[HttpServerUtility.Execute#1](~/add/codesnippet/csharp/m-system.web.httpserveru_16_1.aspx)]"
  syntax:
    content: public void Execute (string path, bool preserveForm);
    parameters:
    - id: path
      type: System.String
      description: "要执行的 URL 路径。"
    - id: preserveForm
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要保留<> *1> 和<> *1> 集合;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref> to clear the <>*> and <>*> collections."
  overload: System.Web.HttpServerUtility.Execute*
  exceptions:
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "The current <xref href=\"System.Web.HttpContext\"></xref> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n An error occurred while executing the handler specified by <code>path</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>path</code> is not a virtual path."
  platform:
  - net462
- uid: System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter)
  id: Execute(System.String,System.IO.TextWriter)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: Execute(String,TextWriter)
  nameWithType: HttpServerUtility.Execute(String,TextWriter)
  fullName: System.Web.HttpServerUtility.Execute(String,TextWriter)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "当前请求的上下文中执行指定虚拟路径的处理程序。 A<xref:System.IO.TextWriter>捕获从执行处理程序的输出。</xref:System.IO.TextWriter>"
  remarks: "指定的虚拟路径执行完成后，在执行方法将继续执行原始请求。 <xref:System.Web.HttpServerUtility.Transfer%2A>方法将执行无条件地转移到另一个处理程序。</xref:System.Web.HttpServerUtility.Transfer%2A>       ASP.NET 不会验证当前用户有权查看的 Execute 方法通过其传递的资源。 尽管 ASP.NET 授权和身份验证逻辑运行于调用原始资源处理程序之前，ASP.NET 将直接调用 Execute 方法指示的处理程序，并不重新运行新的资源的身份验证和授权逻辑。 如果你的应用程序的安全策略要求客户端具有适当的授权才能访问资源，应用程序应强制重新授权或提供自定义访问控制机制。       你可以通过使用强制重新授权<xref:System.Web.HttpResponse.Redirect%2A>方法而不是 Execute 方法。</xref:System.Web.HttpResponse.Redirect%2A> <xref:System.Web.HttpResponse.Redirect%2A>执行在其中浏览器请求新的资源的客户端的重定向。</xref:System.Web.HttpResponse.Redirect%2A> 此重定向时输入系统的新请求，因为它会对进行的 Internet 信息服务 (IIS) 和 ASP.NET 安全策略的所有身份验证和授权逻辑。       你可以验证该用户有权通过结合使用的自定义授权方法查看资源<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>方法之前应用程序调用 Execute 方法。</xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>"
  example:
  - "The following example executes the `Login.aspx` page on the server in the current directory and receives the output from the page through the <xref:System.IO.StringWriter> object `writer`. It writes the HTML stream received from `writer` to the HTTP output stream.  \n  \n [!code-cs[Classic HttpServerUtility.Execute1 Example#1](~/add/codesnippet/csharp/m-system.web.httpserveru_12_1.cs)]\n [!code-vb[Classic HttpServerUtility.Execute1 Example#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_12_1.vb)]"
  syntax:
    content: public void Execute (string path, System.IO.TextWriter writer);
    parameters:
    - id: path
      type: System.String
      description: "要执行的 URL 路径。"
    - id: writer
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>用于捕获输出。</xref:System.IO.TextWriter>"
  overload: System.Web.HttpServerUtility.Execute*
  exceptions:
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "The current <xref href=\"System.Web.HttpContext\"></xref> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n An error occurred while executing the handler specified by <code>path</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>path</code> is not a virtual path."
  platform:
  - net462
- uid: System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter,System.Boolean)
  id: Execute(System.String,System.IO.TextWriter,System.Boolean)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: Execute(String,TextWriter,Boolean)
  nameWithType: HttpServerUtility.Execute(String,TextWriter,Boolean)
  fullName: System.Web.HttpServerUtility.Execute(String,TextWriter,Boolean)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "当前请求的上下文中执行指定虚拟路径的处理程序。 A<xref:System.IO.TextWriter>捕获输出的页和一个布尔型参数指定是否清除<> *1> 和<> *1> 集合。</xref:System.IO.TextWriter>"
  remarks: "<xref:System.Web.HttpServerUtility.Execute%2A>方法在将指定的虚拟路径执行完成后继续执行原始请求。</xref:System.Web.HttpServerUtility.Execute%2A> <xref:System.Web.HttpServerUtility.Transfer%2A>方法将执行无条件地转移到另一个处理程序。</xref:System.Web.HttpServerUtility.Transfer%2A>       ASP.NET 不会验证当前用户有权查看的 Execute 方法通过其传递的资源。 尽管 ASP.NET 授权和身份验证逻辑运行于调用原始资源处理程序之前，ASP.NET 将直接调用 Execute 方法指示的处理程序，并不重新运行新的资源的身份验证和授权逻辑。 如果你的应用程序的安全策略要求客户端具有适当的授权才能访问资源，应用程序应强制重新授权或提供自定义访问控制机制。       你可以通过使用强制重新授权<xref:System.Web.HttpResponse.Redirect%2A>方法而不是 Execute 方法。</xref:System.Web.HttpResponse.Redirect%2A> <xref:System.Web.HttpResponse.Redirect%2A>执行在其中浏览器请求新的资源的客户端的重定向。</xref:System.Web.HttpResponse.Redirect%2A> 此重定向时输入系统的新请求，因为它会对进行的 Internet 信息服务 (IIS) 和 ASP.NET 安全策略的所有身份验证和授权逻辑。       你可以验证该用户有权通过结合使用的自定义授权方法查看资源<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>方法之前应用程序调用 Execute 方法。</xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>"
  example:
  - "The following example executes the `Login.aspx` page on the server in the current directory and receives the output from the page through the <xref:System.IO.StringWriter> object `writer`. It writes the HTML stream received from `writer` to the HTTP output stream. The contents of the <xref:System.Web.HttpRequest.Form%2A> and <xref:System.Web.HttpRequest.QueryString%2A> collections are preserved.  \n  \n [!code-cs[HttpServerUtility.Execute02#1](~/add/codesnippet/csharp/0d13d28c-0070-4c47-b943-_1.aspx)]\n [!code-vb[HttpServerUtility.Execute02#1](~/add/codesnippet/visualbasic/0d13d28c-0070-4c47-b943-_1.aspx)]"
  syntax:
    content: public void Execute (string path, System.IO.TextWriter writer, bool preserveForm);
    parameters:
    - id: path
      type: System.String
      description: "要执行的 URL 路径。"
    - id: writer
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>用于捕获输出。</xref:System.IO.TextWriter>"
    - id: preserveForm
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要保留<> *1> 和<> *1> 集合;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref> to clear the <>*> and <>*> collections."
  overload: System.Web.HttpServerUtility.Execute*
  exceptions:
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "The current <xref href=\"System.Web.HttpContext\"></xref> is a null reference (<xref uid=\"langword_csharp_Nothing\" name=\"Nothing\" href=\"\"></xref> in Visual Basic).  \n  \n \\- or -  \n  \n <code>path</code> ends with a period (.).  \n  \n \\- or -  \n  \n An error occurred while executing the handler specified by <code>path</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>不是虚拟路径。"
  platform:
  - net462
- uid: System.Web.HttpServerUtility.Execute(System.Web.IHttpHandler,System.IO.TextWriter,System.Boolean)
  id: Execute(System.Web.IHttpHandler,System.IO.TextWriter,System.Boolean)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: Execute(IHttpHandler,TextWriter,Boolean)
  nameWithType: HttpServerUtility.Execute(IHttpHandler,TextWriter,Boolean)
  fullName: System.Web.HttpServerUtility.Execute(IHttpHandler,TextWriter,Boolean)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "当前请求的上下文中执行指定虚拟路径的处理程序。 A<xref:System.IO.TextWriter>捕获的输出执行处理程序和一个布尔型参数指定是否清除<> *1> 和<> *1> 集合。</xref:System.IO.TextWriter>"
  remarks: "你可以编写自定义 HTTP 处理程序来处理特定的预定义类型的公共语言规范 (CLS) 符合任何语言中的 HTTP 请求。 这些特定的请求响应中而不是传统的 ASP (也称为经典 ASP) 页面或 ASP.NET 页的 HTTP 处理程序类定义的可执行代码。 HTTP 处理程序允许与的低级别的请求和响应服务正在运行 Internet 信息服务 (IIS) 的 Web 服务器进行交互并提供类似功能于 ISAPI 扩展，但有一个更简单的编程模型。       ASP.NET 不会验证当前用户有权查看的资源，则由 Execute 方法传送。 尽管 ASP.NET 授权和身份验证逻辑运行于调用原始资源处理程序之前，ASP.NET 将直接调用的处理程序通过 Execute 方法指示，并不重新运行新的资源的身份验证和授权逻辑。 如果你的应用程序的安全策略要求客户端具有适当的授权才能访问资源，应用程序应强制重新授权或提供自定义访问控制机制。       你可以通过使用强制重新授权<xref:System.Web.HttpResponse.Redirect%2A>方法而不是 Execute 方法。</xref:System.Web.HttpResponse.Redirect%2A> <xref:System.Web.HttpResponse.Redirect%2A>执行在其中浏览器请求新的资源的客户端的重定向。</xref:System.Web.HttpResponse.Redirect%2A> 此重定向时输入系统的新请求，因为它会对进行的 IIS 和 ASP.NET 安全策略的所有身份验证和授权逻辑。       你可以验证该用户有权通过结合使用的自定义授权方法查看资源<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>方法之前应用程序调用 Execute 方法。</xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>"
  syntax:
    content: public void Execute (System.Web.IHttpHandler handler, System.IO.TextWriter writer, bool preserveForm);
    parameters:
    - id: handler
      type: System.Web.IHttpHandler
      description: "实现的 HTTP 处理程序<xref href=&quot;System.Web.IHttpHandler&quot;></xref>若要向其传输当前请求。"
    - id: writer
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>用于捕获输出。</xref:System.IO.TextWriter>"
    - id: preserveForm
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要保留<> *1> 和<> *1> 集合;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref> to clear the <>*> and <>*> collections."
  overload: System.Web.HttpServerUtility.Execute*
  exceptions:
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "执行指定的处理程序时出错<code> handler </code>。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>handler</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Web.HttpServerUtility.GetLastError
  id: GetLastError
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: GetLastError()
  nameWithType: HttpServerUtility.GetLastError()
  fullName: System.Web.HttpServerUtility.GetLastError()
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "返回前一个异常。"
  remarks: ''
  example:
  - "The following example prints a description of the application's last error to the HTTP output stream. It prints \"No Errors\" if no errors have been encountered.  \n  \n [!code-vb[Classic HttpServerUtility.GetLastError Example#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_8_1.vb)]\n [!code-cs[Classic HttpServerUtility.GetLastError Example#1](~/add/codesnippet/csharp/m-system.web.httpserveru_8_1.cs)]"
  syntax:
    content: public Exception GetLastError ();
    parameters: []
    return:
      type: System.Exception
      description: "前一个异常引发。"
  overload: System.Web.HttpServerUtility.GetLastError*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpServerUtility.HtmlDecode(System.String)
  id: HtmlDecode(System.String)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: HtmlDecode(String)
  nameWithType: HttpServerUtility.HtmlDecode(String)
  fullName: System.Web.HttpServerUtility.HtmlDecode(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "对 HTML 编码的字符串进行解码并返回已解码的字符串。"
  remarks: "HTML encoding makes sure that text is displayed correctly in the browser and not interpreted by the browser as HTML. For example, if a text string contains a less than sign (\\<) or greater than sign (>), the browser would interpret these characters as the opening or closing bracket of an HTML tag. When the characters are HTML encoded, they are converted to the strings `<` and `>`, which causes the browser to display the less than sign and greater than sign correctly. HtmlDecode decodes text that has been transmitted to the server.  \n  \n This method is a convenient way to access the <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=fullName> method at run time from an ASP.NET application. Internally, this method uses <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=fullName> to decode strings.  \n  \n In the code-behind file for an ASP.NET web page, access an instance of the <xref:System.Web.HttpServerUtility> class through the `Server` property. In a class that is not in a code-behind file, use `HttpContext.Current.Server` to access an instance of the <xref:System.Web.HttpServerUtility> class.  \n  \n Outside of a web application, use the <xref:System.Net.WebUtility> class to encode or decode values."
  example:
  - "The following example contains the function `LoadDecodedFile`, which decodes the data from a file and copies it into one string.  \n  \n [!code-cs[Classic HttpServerUtility.HtmlDecode Example#1](~/add/codesnippet/csharp/m-system.web.httpserveru_14_1.aspx)]\n [!code-vb[Classic HttpServerUtility.HtmlDecode Example#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_14_1.aspx)]"
  syntax:
    content: public string HtmlDecode (string s);
    parameters:
    - id: s
      type: System.String
      description: "要解码的 HTML 字符串。"
    return:
      type: System.String
      description: "已解码的文本。"
  overload: System.Web.HttpServerUtility.HtmlDecode*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpServerUtility.HtmlDecode(System.String,System.IO.TextWriter)
  id: HtmlDecode(System.String,System.IO.TextWriter)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: HtmlDecode(String,TextWriter)
  nameWithType: HttpServerUtility.HtmlDecode(String,TextWriter)
  fullName: System.Web.HttpServerUtility.HtmlDecode(String,TextWriter)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "对 HTML 编码的字符串进行解码并将结果发送到输出<xref:System.IO.TextWriter>输出流。</xref:System.IO.TextWriter>"
  remarks: "HTML encoding makes sure that text is displayed correctly in the browser and not interpreted by the browser as HTML. For example, if a text string contains a less than sign (\\<) or greater than sign (>), the browser would interpret these characters as the opening or closing bracket of an HTML tag. When the characters are HTML encoded, they are converted to the strings `<` and `>`, which causes the browser to display the less than sign and greater than sign correctly.  \n  \n <xref:System.Web.HttpServerUtility.HtmlDecode%2A> decodes text that has been transmitted to the server.  \n  \n <xref:System.Web.HttpServerUtility.HtmlDecode%2A> is a convenient way to access the <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=fullName> method at run time from an ASP.NET application. Internally, <xref:System.Web.HttpServerUtility.HtmlDecode%2A> uses <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=fullName> to decode strings.  \n  \n To encode or decode values outside of a web application, use the <xref:System.Net.WebUtility> class."
  example:
  - "The following example decodes a string that has been HTML-encoded for transmission over HTTP. It decodes the supplied string named `EncodedString` which contains the text \"This is a &lt;Test String&gt;.\", and copies it into the string named `DecodedString` as \"This is a \\<Test String>.\".  \n  \n [!code-vb[Classic HttpServerUtility.HtmlDecode1 Example#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_1_1.vb)]\n [!code-cs[Classic HttpServerUtility.HtmlDecode1 Example#1](~/add/codesnippet/csharp/m-system.web.httpserveru_1_1.cs)]"
  syntax:
    content: public void HtmlDecode (string s, System.IO.TextWriter output);
    parameters:
    - id: s
      type: System.String
      description: "要解码的 HTML 字符串。"
    - id: output
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>包含已解码的字符串的输出流。</xref:System.IO.TextWriter>"
  overload: System.Web.HttpServerUtility.HtmlDecode*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpServerUtility.HtmlEncode(System.String)
  id: HtmlEncode(System.String)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: HtmlEncode(String)
  nameWithType: HttpServerUtility.HtmlEncode(String)
  fullName: System.Web.HttpServerUtility.HtmlEncode(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "对字符串进行 HTML 编码并返回已编码的字符串。"
  remarks: "HTML encoding makes sure that text is displayed correctly in the browser and not interpreted by the browser as HTML. For example, if a text string contains a less than sign (\\<) or greater than sign (>), the browser would interpret these characters as the opening or closing bracket of an HTML tag. When the characters are HTML encoded, they are converted to the strings `<` and `>`, which causes the browser to display the less than sign and greater than sign correctly.  \n  \n This method is a convenient way to access the <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=fullName> method at run time from an ASP.NET application. Internally, this method uses <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=fullName> to encode strings.  \n  \n In the code-behind file for an ASP.NET web page, access an instance of the <xref:System.Web.HttpServerUtility> class through the `Server` property. In a class that is not in a code-behind file, use `HttpContext.Current.Server` to access an instance of the <xref:System.Web.HttpServerUtility> class.  \n  \n Outside of a web application, use the <xref:System.Net.WebUtility> class to encode or decode values."
  example:
  - "The following example shows how to HTML-encode a value that potentially codes unsafe code. The code resides in the code-behind file for a web page. The value to encode is hard-coded in this example only to simplify the example and show the type of value you might HTML-encode. Typically, you would HTML-encode a value that you received from the user or the request. `Result` refers to a `Literal` control.  \n  \n [!code-cs[System.Web.HttpServerUtility.HtmlEncode#1](~/add/codesnippet/csharp/m-system.web.httpserveru_10_1.cs)]\n [!code-vb[System.Web.HttpServerUtility.HtmlEncode#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_10_1.vb)]  \n  \n The next example is similar to the previous example except it shows how to HTML-encode a value from within a class that is not in the code-behind file.  \n  \n [!code-cs[System.Web.HttpServerUtility.HtmlEncode#2](~/add/codesnippet/csharp/m-system.web.httpserveru_10_2.cs)]\n [!code-vb[System.Web.HttpServerUtility.HtmlEncode#2](~/add/codesnippet/visualbasic/m-system.web.httpserveru_10_2.vb)]"
  syntax:
    content: public string HtmlEncode (string s);
    parameters:
    - id: s
      type: System.String
      description: "要编码的文本字符串。"
    return:
      type: System.String
      description: "HTML 编码的文本。"
  overload: System.Web.HttpServerUtility.HtmlEncode*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpServerUtility.HtmlEncode(System.String,System.IO.TextWriter)
  id: HtmlEncode(System.String,System.IO.TextWriter)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: HtmlEncode(String,TextWriter)
  nameWithType: HttpServerUtility.HtmlEncode(String,TextWriter)
  fullName: System.Web.HttpServerUtility.HtmlEncode(String,TextWriter)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "一个字符串进行 HTML 编码的并得到的输出发送到发送<xref:System.IO.TextWriter>输出流。</xref:System.IO.TextWriter>"
  remarks: "HTML encoding ensures that text will be correctly displayed in the browser, not interpreted by the browser as HTML. For example, if a text string contains a less than sign (\\<) or greater than sign (>), the browser would interpret these characters as an opening or closing bracket of an HTML tag. The HTML encoding of these two characters is `<` and `>`, respectively, which causes the browser to display the less than sign and greater than sign correctly.  \n  \n <xref:System.Web.HttpServerUtility.HtmlEncode%2A> is a convenient way to access the <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=fullName> method at run time from an ASP.NET application. Internally, <xref:System.Web.HttpServerUtility.HtmlEncode%2A> uses <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=fullName> to encode strings.  \n  \n To encode or decode values outside of a web application, use the <xref:System.Net.WebUtility> class."
  example:
  - "The following example encodes a string for transmission by HTTP. It encodes the string named `TestString`, which contains the text \"This is a \\<Test String>.\", and copies it into the string named `EncodedString` as \"This is a &lt;Test String&gt;.\".  \n  \n [!code-vb[Classic HttpServerUtility.HtmlEncode1 Example#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_7_1.vb)]\n [!code-cs[Classic HttpServerUtility.HtmlEncode1 Example#1](~/add/codesnippet/csharp/m-system.web.httpserveru_7_1.cs)]"
  syntax:
    content: public void HtmlEncode (string s, System.IO.TextWriter output);
    parameters:
    - id: s
      type: System.String
      description: "要编码的字符串。"
    - id: output
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>包含已编码的字符串的输出流。</xref:System.IO.TextWriter>"
  overload: System.Web.HttpServerUtility.HtmlEncode*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpServerUtility.MachineName
  id: MachineName
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: MachineName
  nameWithType: HttpServerUtility.MachineName
  fullName: System.Web.HttpServerUtility.MachineName
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "获取服务器的计算机名称。"
  remarks: ''
  example:
  - "The following example stores the server's computer name as a string variable.  \n  \n [!code-vb[Classic HttpServerUtility.MachineName Example#1](~/add/codesnippet/visualbasic/p-system.web.httpserveru_0_1.vb)]\n [!code-cs[Classic HttpServerUtility.MachineName Example#1](~/add/codesnippet/csharp/p-system.web.httpserveru_0_1.cs)]"
  syntax:
    content: public string MachineName { get; }
    return:
      type: System.String
      description: "本地计算机的名称。"
  overload: System.Web.HttpServerUtility.MachineName*
  exceptions:
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "找不到的计算机名称。"
  platform:
  - net462
- uid: System.Web.HttpServerUtility.MapPath(System.String)
  id: MapPath(System.String)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: MapPath(String)
  nameWithType: HttpServerUtility.MapPath(String)
  fullName: System.Web.HttpServerUtility.MapPath(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "返回指定的虚拟路径相对应的物理文件路径。"
  remarks: "If `path` is `null`, the MapPath method returns the full physical path of the directory that contains the current request for the path. The relative path does not need to specify an existing file or folder for this method to return a value. However, you cannot specify a path outside of the Web application.  \n  \n> [!IMPORTANT]\n>  The MapPath method potentially contains sensitive information about the hosting environment. The return value should not be displayed to users.  \n  \n A Web application that resides at `C:\\ExampleSites\\TestMapPath` would return the following results:  \n  \n|Request from|`path`|Returned value|  \n|------------------|------------|--------------------|  \n|RootLevelPage.aspx|`null`|C:\\ExampleSites\\TestMapPath|  \n|RootLevelPage.aspx|\"/DownOneLevel/DownLevelPage.aspx\"|C:\\ExampleSites\\TestMapPath\\DownOneLevel\\DownLevelPage.aspx|  \n|RootLevelPage.aspx|\"/NotRealFolder\"|C:\\ExampleSites\\TestMapPath\\NotRealFolder|  \n|RootLevelPage.aspx|\"../OutsideApplication\"|<xref:System.Web.HttpException>|  \n|/DownOneLevel/DownLevelPage.aspx|`null`|C:\\ExampleSites\\TestMapPath\\DownOneLevel|  \n|/DownOneLevel/DownLevelPage.aspx|\"../RootLevelPage.aspx\"|C:\\ExampleSites\\TestMapPath\\RootLevelPage.aspx|"
  example:
  - "The following example shows how to retrieve the physical file of a relative virtual path. The code resides in the code-behind file for a web page and utilizes the default `Server` object.  \n  \n [!code-cs[System.Web.HttpServerUtility.MapPath#1](~/add/codesnippet/csharp/m-system.web.httpserveru_5_1.cs)]\n [!code-vb[System.Web.HttpServerUtility.MapPath#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_5_1.vb)]  \n  \n The next example is similar to the previous example except it shows how to retrieve a physical path from within a class that is not in the code-behind file.  \n  \n [!code-cs[System.Web.HttpServerUtility.MapPath#2](~/add/codesnippet/csharp/m-system.web.httpserveru_5_2.cs)]\n [!code-vb[System.Web.HttpServerUtility.MapPath#2](~/add/codesnippet/visualbasic/m-system.web.httpserveru_5_2.vb)]"
  syntax:
    content: public string MapPath (string path);
    parameters:
    - id: path
      type: System.String
      description: "Web 应用程序中的虚拟路径。"
    return:
      type: System.String
      description: "对应于在 Web 服务器上的物理文件路径<code> path </code>。"
  overload: System.Web.HttpServerUtility.MapPath*
  exceptions:
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "The current <xref href=&quot;System.Web.HttpContext&quot;></xref> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Web.HttpServerUtility.ScriptTimeout
  id: ScriptTimeout
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: ScriptTimeout
  nameWithType: HttpServerUtility.ScriptTimeout
  fullName: System.Web.HttpServerUtility.ScriptTimeout
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "获取和设置请求超时值以秒为单位。"
  remarks: "ScriptTimeout 属性可以设置 Web.config 文件中通过设置`executionTimeout`元素的特性。 如果超时值以编程方式与 ScriptTimeout 属性设置将优先于 Web.config 设置。      1> [!NOTE]&1;> 如果你设置`debug`到元素特性`true`在 Web.config 文件中，将忽略 ScriptTimeout 的值。"
  example:
  - "The following example sets the request time-out period to 60 seconds.  \n  \n [!code-vb[Classic HttpServerUtility.ScriptTimeout Example#1](~/add/codesnippet/visualbasic/p-system.web.httpserveru_1_1.vb)]\n [!code-cs[Classic HttpServerUtility.ScriptTimeout Example#1](~/add/codesnippet/csharp/p-system.web.httpserveru_1_1.cs)]"
  syntax:
    content: public int ScriptTimeout { get; set; }
    return:
      type: System.Int32
      description: "请求超时值设置。"
  overload: System.Web.HttpServerUtility.ScriptTimeout*
  exceptions:
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "The current <xref href=&quot;System.Web.HttpContext&quot;></xref> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "超时期限是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>或否则无法设置。"
  platform:
  - net462
- uid: System.Web.HttpServerUtility.Transfer(System.String)
  id: Transfer(System.String)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: Transfer(String)
  nameWithType: HttpServerUtility.Transfer(String)
  fullName: System.Web.HttpServerUtility.Transfer(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "对于当前的请求，终止执行当前页和开始执行新页通过使用指定页 URL 路径。"
  remarks: "传输到此页应是另一个.aspx 页。 例如，.asp 或.asmx 页传输不是有效的。 传输方法保留<xref:System.Web.HttpRequest.QueryString%2A>和<xref:System.Web.HttpRequest.Form%2A>集合。</xref:System.Web.HttpRequest.Form%2A> </xref:System.Web.HttpRequest.QueryString%2A>       传输调用<xref:System.Web.HttpResponse.End%2A>，该类会引发<xref:System.Threading.ThreadAbortException>完成后的异常。</xref:System.Threading.ThreadAbortException> </xref:System.Web.HttpResponse.End%2A>       ASP.NET 不会验证当前用户有权查看的传输方法通过其传递的资源。 尽管 ASP.NET 授权和身份验证逻辑运行于调用原始资源处理程序之前，ASP.NET 将直接调用由传输方法的处理程序，并不重新运行新的资源的身份验证和授权逻辑。 如果你的应用程序的安全策略要求客户端具有适当的授权才能访问资源，应用程序应强制重新授权或提供自定义访问控制机制。       你可以通过使用强制重新授权<xref:System.Web.HttpResponse.Redirect%2A>方法而非传输方法。</xref:System.Web.HttpResponse.Redirect%2A> <xref:System.Web.HttpResponse.Redirect%2A>方法执行在其中浏览器请求新的资源的客户端的重定向。</xref:System.Web.HttpResponse.Redirect%2A> 此重定向时输入系统的新请求，因为它会对进行的 Internet 信息服务 (IIS) 和 ASP.NET 安全策略的所有身份验证和授权逻辑。       你可以验证该用户有权通过结合使用的自定义授权方法查看资源<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>方法之前在应用程序调用的传输方法。</xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>"
  syntax:
    content: public void Transfer (string path);
    parameters:
    - id: path
      type: System.String
      description: "要执行的服务器上的新页 URL 路径。"
  overload: System.Web.HttpServerUtility.Transfer*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpServerUtility.Transfer(System.String,System.Boolean)
  id: Transfer(System.String,System.Boolean)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: Transfer(String,Boolean)
  nameWithType: HttpServerUtility.Transfer(String,Boolean)
  fullName: System.Web.HttpServerUtility.Transfer(String,Boolean)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "终止当前页的执行并使用指定页 URL 路径来开始执行新页。 指定是否清除<> *1> 和<> *1> 集合。"
  remarks: "传输到此页应是另一个.aspx 页。 例如，.asp 或.asmx 页传输不是有效的。       传输调用<xref:System.Web.HttpResponse.End%2A>，该类会引发<xref:System.Threading.ThreadAbortException>完成后的异常。</xref:System.Threading.ThreadAbortException> </xref:System.Web.HttpResponse.End%2A>       如果你设置`preserveForm`参数`true`，目标页将能够通过访问前一页的视图状态<xref:System.Web.UI.Page.PreviousPage%2A>属性。</xref:System.Web.UI.Page.PreviousPage%2A>       出于安全目的，你应该保留`enableViewStateMac`属性设置为`true`。 ASP.NET 不会验证当前用户有权查看的传输方法通过其传递的资源。 尽管 ASP.NET 授权和身份验证逻辑运行于调用原始资源处理程序之前，ASP.NET 将直接调用由传输方法的处理程序，并不重新运行新的资源的身份验证和授权逻辑。 如果你的应用程序的安全策略要求客户端具有适当的授权才能访问资源，应用程序应强制重新授权或提供自定义访问控制机制。       你可以通过使用强制重新授权<xref:System.Web.HttpResponse.Redirect%2A>方法而非传输方法。</xref:System.Web.HttpResponse.Redirect%2A> <xref:System.Web.HttpResponse.Redirect%2A>方法执行在其中浏览器请求新的资源的客户端的重定向。</xref:System.Web.HttpResponse.Redirect%2A> 此重定向时输入系统的新请求，因为它会对进行的 Internet 信息服务 (IIS) 和 ASP.NET 安全策略的所有身份验证和授权逻辑。       你可以验证该用户有权通过结合使用的自定义授权方法查看资源<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>方法之前在应用程序调用的传输方法。</xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>"
  example:
  - "The following example executes a new page in the same directory as the current page.  \n  \n [!code-cs[Classic HttpServerUtility.Transfer Example#1](~/add/codesnippet/csharp/m-system.web.httpserveru_3_1.cs)]\n [!code-vb[Classic HttpServerUtility.Transfer Example#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_3_1.vb)]"
  syntax:
    content: public void Transfer (string path, bool preserveForm);
    parameters:
    - id: path
      type: System.String
      description: "要执行的服务器上的新页 URL 路径。"
    - id: preserveForm
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要保留<> *1> 和<> *1> 集合;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref> to clear the <>*> and <>*> collections."
  overload: System.Web.HttpServerUtility.Transfer*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "在当前页面请求为回调。"
  platform:
  - net462
- uid: System.Web.HttpServerUtility.Transfer(System.Web.IHttpHandler,System.Boolean)
  id: Transfer(System.Web.IHttpHandler,System.Boolean)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: Transfer(IHttpHandler,Boolean)
  nameWithType: HttpServerUtility.Transfer(IHttpHandler,Boolean)
  fullName: System.Web.HttpServerUtility.Transfer(IHttpHandler,Boolean)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "终止当前页的执行并使用实现一个自定义 HTTP 处理程序来开始执行新请求<xref href=&quot;System.Web.IHttpHandler&quot;></xref>接口，并指定是否清除<> *1> 和<> *1> 集合。"
  remarks: "你可以编写自定义 HTTP 处理程序来处理特定的预定义类型的公共语言规范 (CLS) 符合任何语言中的 HTTP 请求。 这些特定的请求响应中而不是传统的 ASP (也称为经典 ASP) 页面或 ASP.NET 页的 HTTP 处理程序类定义的可执行代码。 HTTP 处理程序允许与的低级别的请求和响应服务正在运行 Internet 信息服务 (IIS) 的 Web 服务器进行交互并提供类似功能于 ISAPI 扩展，但有一个更简单的编程模型。       如果你设置`preserveForm`参数`true`，目标页将能够通过访问前一页的视图状态<xref:System.Web.UI.Page.PreviousPage%2A>属性。</xref:System.Web.UI.Page.PreviousPage%2A>       出于安全目的，你应该保留`enableViewStateMac`属性设置为`true`。 ASP.NET 不会验证当前用户有权查看的资源通过其传递<xref:System.Web.HttpServerUtility.Transfer%2A>方法。</xref:System.Web.HttpServerUtility.Transfer%2A> 尽管 ASP.NET 授权和身份验证逻辑运行于调用原始资源处理程序之前，ASP.NET 将直接调用由传输方法，指示的处理程序，并不重新运行新的资源的身份验证和授权逻辑。 如果你的应用程序的安全策略要求客户端具有适当的授权才能访问资源，应用程序应强制重新授权或提供一种自定义访问控制机制。       你可以通过使用强制重新授权<xref:System.Web.HttpResponse.Redirect%2A>方法而非传输方法。</xref:System.Web.HttpResponse.Redirect%2A> <xref:System.Web.HttpResponse.Redirect%2A>方法执行在其中浏览器请求新的资源的客户端的重定向。</xref:System.Web.HttpResponse.Redirect%2A> 此重定向时输入系统的新请求，因为它会对进行的 IIS 和 ASP.NET 安全策略的所有身份验证和授权逻辑。       你可以验证该用户有权通过结合使用的自定义授权方法查看资源<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>方法之前在应用程序调用的传输方法。</xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>"
  syntax:
    content: public void Transfer (System.Web.IHttpHandler handler, bool preserveForm);
    parameters:
    - id: handler
      type: System.Web.IHttpHandler
      description: "实现的 HTTP 处理程序<xref href=&quot;System.Web.IHttpHandler&quot;></xref>若要向其传输当前请求。"
    - id: preserveForm
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要保留<> *1> 和<> *1> 集合;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref> to clear the <>*> and <>*> collections."
  overload: System.Web.HttpServerUtility.Transfer*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "在当前页面请求为回调。"
  platform:
  - net462
- uid: System.Web.HttpServerUtility.TransferRequest(System.String)
  id: TransferRequest(System.String)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: TransferRequest(String)
  nameWithType: HttpServerUtility.TransferRequest(String)
  fullName: System.Web.HttpServerUtility.TransferRequest(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "异步执行指定的 url。"
  remarks: "此方法重载调用<xref:System.Web.HttpServerUtility.TransferRequest%2A>重载`preserveForm`参数设置为`false`、`method`参数设置为`null`、`headers`参数设置为`null`，和`preserveUser`参数设置为`true`。</xref:System.Web.HttpServerUtility.TransferRequest%2A> 有关详细信息，请参阅中的&quot;备注&quot;部分<xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>重载。</xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>"
  syntax:
    content: public void TransferRequest (string path);
    parameters:
    - id: path
      type: System.String
      description: "要执行的服务器上的新页 URL 路径。"
  overload: System.Web.HttpServerUtility.TransferRequest*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该请求需要的集成的管道模式[!INCLUDE[iisver](~/add/includes/ajax-current-ext-md.md)]。"
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "服务器不可用来处理该请求。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> path </code>参数无效。"
  platform:
  - net462
- uid: System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean)
  id: TransferRequest(System.String,System.Boolean)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: TransferRequest(String,Boolean)
  nameWithType: HttpServerUtility.TransferRequest(String,Boolean)
  fullName: System.Web.HttpServerUtility.TransferRequest(String,Boolean)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "异步执行指定的 url，并保留查询字符串参数。"
  remarks: "此重载调用<xref:System.Web.HttpServerUtility.TransferRequest%2A>重载`preserveForm`参数设置中，传递的值为`method`参数设置为`null`、`headers`参数设置为`null`，和`preserveUser`参数设置为`true`。</xref:System.Web.HttpServerUtility.TransferRequest%2A> 有关详细信息，请参阅&quot;备注&quot;部分中<xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>。</xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>       TransferRequest 是.NET Framework 3.5 版中引入的。  有关详细信息，请参阅[版本和依赖关系](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public void TransferRequest (string path, bool preserveForm);
    parameters:
    - id: path
      type: System.String
      description: "要执行的服务器上的新页 URL 路径。"
    - id: preserveForm
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要保留<> *1> 集合;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>清除<> *1> 集合。"
  overload: System.Web.HttpServerUtility.TransferRequest*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该请求需要的集成的管道模式[!INCLUDE[iisver](~/add/includes/ajax-current-ext-md.md)]。"
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "服务器不可用来处理该请求。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> path </code>参数无效。"
  platform:
  - net462
- uid: System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection)
  id: TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: TransferRequest(String,Boolean,String,NameValueCollection)
  nameWithType: HttpServerUtility.TransferRequest(String,Boolean,String,NameValueCollection)
  fullName: System.Web.HttpServerUtility.TransferRequest(String,Boolean,String,NameValueCollection)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "异步执行指定的 url，使用指定的 HTTP 方法和标头。"
  remarks: "中的集成的管道模式运行时，使用此方法[!INCLUDE[iisver](~/add/includes/ajax-current-ext-md.md)]允许请求处理，以从一个资源类型传输到另一个执行正确的请求上下文的目标请求时。 例如，TransferRequest 方法可用于将对一个 ASPX 页请求传输到一个 XML 页的请求。       TransferRequest 方法执行异步子执行指定的 url 与以下条件:-如果`path`参数指定的查询字符串，它将用作新的查询字符串。 如果包括任何查询字符串，不则请求的查询字符串将重复使用。      -如果`method`指定参数时，将使用它。 如果它是`null`，将使用原始请求的 HTTP 方法。      -如果`preserveForm`参数是`true`，当前的实体正文的请求将可供目标请求。 这使窗体发布，并将上载要传输。      -如果在原始请求当前设置的用户标识，标识将传输到新的请求。 这允许经过身份验证的请求重新使用新的请求的身份验证的结果。 如果您不希望要传输的用户，将用户设置为`null`在原始请求之前传输。      -如果`headers`指定参数，将执行新请求时指定的标头。 这可以用于修改的请求标头和 cookie 用于新请求，或添加特殊的标头，指定其中收到原始请求。           此方法调用<xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%2CSystem.Boolean%29>方法重载`preserveUser`参数设置为`true`。</xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%2CSystem.Boolean%29>"
  syntax:
    content: public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers);
    parameters:
    - id: path
      type: System.String
      description: "要执行的服务器上的新页 URL 路径。"
    - id: preserveForm
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要保留<> *1> 集合;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>清除<> *1> 集合。"
    - id: method
      type: System.String
      description: "要在执行新请求中使用的 HTTP 方法。"
    - id: headers
      type: System.Collections.Specialized.NameValueCollection
      description: "A <xref href=&quot;System.Collections.Specialized.NameValueCollection&quot;> </xref>的新请求的请求标头。"
  overload: System.Web.HttpServerUtility.TransferRequest*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该请求需要[!INCLUDE[iisver](~/add/includes/ajax-current-ext-md.md)]在集成模式下运行。"
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "服务器不可用来处理该请求。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> path </code>参数无效。"
  platform:
  - net462
- uid: System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)
  id: TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: TransferRequest(String,Boolean,String,NameValueCollection,Boolean)
  nameWithType: HttpServerUtility.TransferRequest(String,Boolean,String,NameValueCollection,Boolean)
  fullName: System.Web.HttpServerUtility.TransferRequest(String,Boolean,String,NameValueCollection,Boolean)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "用指定的 HTTP 方法、 标头和路径，指定的 URL 的异步执行和选择保留格式值和用户标识。"
  remarks: "有关详细信息，请参阅&quot;备注&quot;部分中<xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>。</xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>"
  syntax:
    content: public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers, bool preserveUser);
    parameters:
    - id: path
      type: System.String
      description: "路径。"
    - id: preserveForm
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要保留<> *1> 集合;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>清除<> *1> 集合。"
    - id: method
      type: System.String
      description: "要在新的请求中使用的 HTTP 方法。"
    - id: headers
      type: System.Collections.Specialized.NameValueCollection
      description: "A <xref href=&quot;System.Collections.Specialized.NameValueCollection&quot;> </xref>对象，其中包含用于新请求的请求标头。"
    - id: preserveUser
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要保留的用户标识;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 此方法的其他方法重载调用此参数设置为此重载<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。"
  overload: System.Web.HttpServerUtility.TransferRequest*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "该请求需要的集成的管道模式[!INCLUDE[iisver](~/add/includes/ajax-current-ext-md.md)]。"
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "服务器不可用来处理该请求。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> path </code>参数无效。"
  platform:
  - net462
- uid: System.Web.HttpServerUtility.UrlDecode(System.String)
  id: UrlDecode(System.String)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: UrlDecode(String)
  nameWithType: HttpServerUtility.UrlDecode(String)
  fullName: System.Web.HttpServerUtility.UrlDecode(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "对字符串进行 URL 解码并返回已解码的字符串。"
  remarks: "URL 编码，可确保所有浏览器将正确地传输 URL 字符串中的文本。 如问号 （？） 字符，& 符 （&） 斜杠标记 （/），并且可能会截断空格，或将其某些浏览器已损坏。 因此，这些字符必须经过编码中`<a>`标记或查询中的字符串可以在请求字符串中的浏览器中重新由字符串的位置。       此方法是一种简便方式访问<xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=fullName>方法在运行时从 ASP.NET 应用程序。</xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=fullName> 此方法在内部，使用<xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=fullName>来对字符串进行解码。</xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=fullName>       在代码隐藏文件中的 ASP.NET web 页，访问的实例<xref:System.Web.HttpServerUtility>类通过`Server`属性。</xref:System.Web.HttpServerUtility> 在不是代码隐藏文件中的类，使用`HttpContext.Current.Server`访问实例的<xref:System.Web.HttpServerUtility>类。</xref:System.Web.HttpServerUtility>       在 web 应用程序，外部使用<xref:System.Net.WebUtility>类进行编码或解码值。</xref:System.Net.WebUtility>"
  example:
  - "The following example shows how to URL-decode a value that is retrieved from the query string. The code resides in the code-behind file for a web page. `ReturnPage` refers to a `HyperLink` control.  \n  \n [!code-vb[System.Web.HttpServerUtility.UrlDecode#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_9_1.vb)]\n [!code-cs[System.Web.HttpServerUtility.UrlDecode#1](~/add/codesnippet/csharp/m-system.web.httpserveru_9_1.cs)]  \n  \n The next example is similar to the previous example except it shows how to URL-decode a value from within a class that is not in the code-behind file.  \n  \n [!code-cs[System.Web.HttpServerUtility.UrlDecode#2](~/add/codesnippet/csharp/m-system.web.httpserveru_9_2.cs)]\n [!code-vb[System.Web.HttpServerUtility.UrlDecode#2](~/add/codesnippet/visualbasic/m-system.web.httpserveru_9_2.vb)]"
  syntax:
    content: public string UrlDecode (string s);
    parameters:
    - id: s
      type: System.String
      description: "要解码的文本字符串。"
    return:
      type: System.String
      description: "已解码的文本。"
  overload: System.Web.HttpServerUtility.UrlDecode*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpServerUtility.UrlDecode(System.String,System.IO.TextWriter)
  id: UrlDecode(System.String,System.IO.TextWriter)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: UrlDecode(String,TextWriter)
  nameWithType: HttpServerUtility.UrlDecode(String,TextWriter)
  fullName: System.Web.HttpServerUtility.UrlDecode(String,TextWriter)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "对接收在 URL 中的 HTML 字符串进行解码并将结果发送到输出<xref:System.IO.TextWriter>输出流。</xref:System.IO.TextWriter>"
  remarks: "URL 编码，可确保所有浏览器将正确地传输 URL 字符串中的文本。 如问号 （？） 字符，& 符 （&） 斜杠标记 （/），并且可能会截断空格，或将其某些浏览器已损坏。 因此，这些字符必须经过编码中`<a>`标记或查询中的字符串可以在请求字符串中的浏览器中重新由字符串的位置。       <xref:System.Web.HttpServerUtility.UrlDecode%2A>是一种简便的方法来访问<xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=fullName>方法在运行时从 ASP.NET 应用程序。</xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=fullName></xref:System.Web.HttpServerUtility.UrlDecode%2A> 在内部，<xref:System.Web.HttpServerUtility.UrlDecode%2A>使用<xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=fullName>来对字符串进行解码。</xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=fullName> </xref:System.Web.HttpServerUtility.UrlDecode%2A>       若要进行编码或解码的 web 应用程序之外的值，使用<xref:System.Net.WebUtility>类。</xref:System.Net.WebUtility>"
  example:
  - "The following example decodes the string named `EncodedString` (received in a URL) into the string named `DecodedString`.  \n  \n [!code-vb[Classic HttpServerUtility.UrlDecode1 Example#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_11_1.vb)]\n [!code-cs[Classic HttpServerUtility.UrlDecode1 Example#1](~/add/codesnippet/csharp/m-system.web.httpserveru_11_1.cs)]"
  syntax:
    content: public void UrlDecode (string s, System.IO.TextWriter output);
    parameters:
    - id: s
      type: System.String
      description: "要解码的 HTML 字符串。"
    - id: output
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>包含已解码的字符串的输出流。</xref:System.IO.TextWriter>"
  overload: System.Web.HttpServerUtility.UrlDecode*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpServerUtility.UrlEncode(System.String)
  id: UrlEncode(System.String)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: UrlEncode(String)
  nameWithType: HttpServerUtility.UrlEncode(String)
  fullName: System.Web.HttpServerUtility.UrlEncode(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "对字符串进行 URL 编码，并返回已编码的字符串。"
  remarks: "URL 编码，可确保所有浏览器将正确地传输 URL 字符串中的文本。 如问号 （？） 字符，& 符 （&） 斜杠标记 （/），并且可能会截断空格，或将其某些浏览器已损坏。 因此，这些字符必须经过编码中`<a>`标记或查询中的字符串可以在请求字符串中的浏览器中重新由字符串的位置。       此方法是一种简便方式访问<xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=fullName>方法在运行时从 ASP.NET 应用程序。</xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=fullName> 此方法在内部，使用<xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=fullName>对字符串进行编码。</xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=fullName>       在代码隐藏文件中的 ASP.NET web 页，访问的实例<xref:System.Web.HttpServerUtility>类通过`Server`属性。</xref:System.Web.HttpServerUtility> 在不是代码隐藏文件中的类，使用`HttpContext.Current.Server`访问实例的<xref:System.Web.HttpServerUtility>类。</xref:System.Web.HttpServerUtility>       在 web 应用程序，外部使用<xref:System.Net.WebUtility>类进行编码或解码值。</xref:System.Net.WebUtility>"
  example:
  - "The following example shows how to URL-encode a value that is used as a query string value of a hyperlink. The code resides in the code-behind file for a web page. The value to encode is hard-coded in this example only to simplify the example and show the type of value you might URL-encode. Typically, you would URL-encode a value that you received from the user or the request. `NextPage` refers to a `HyperLink` control.  \n  \n [!code-cs[System.Web.HttpServerUtility.UrlEncode#1](~/add/codesnippet/csharp/m-system.web.httpserveru_0_1.cs)]\n [!code-vb[System.Web.HttpServerUtility.UrlEncode#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_0_1.vb)]  \n  \n The next example is similar to the previous example except it shows how to URL-encode a value from within a class that is not in the code-behind file.  \n  \n [!code-cs[System.Web.HttpServerUtility.UrlEncode#2](~/add/codesnippet/csharp/m-system.web.httpserveru_0_2.cs)]\n [!code-vb[System.Web.HttpServerUtility.UrlEncode#2](~/add/codesnippet/visualbasic/m-system.web.httpserveru_0_2.vb)]"
  syntax:
    content: public string UrlEncode (string s);
    parameters:
    - id: s
      type: System.String
      description: "进行 URL 编码的文本。"
    return:
      type: System.String
      description: "URL 编码的文本。"
  overload: System.Web.HttpServerUtility.UrlEncode*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpServerUtility.UrlEncode(System.String,System.IO.TextWriter)
  id: UrlEncode(System.String,System.IO.TextWriter)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: UrlEncode(String,TextWriter)
  nameWithType: HttpServerUtility.UrlEncode(String,TextWriter)
  fullName: System.Web.HttpServerUtility.UrlEncode(String,TextWriter)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "一个字符串进行 URL 编码的并得到的输出发送到发送<xref:System.IO.TextWriter>输出流。</xref:System.IO.TextWriter>"
  remarks: "URL 编码，可确保所有浏览器将正确地传输 URL 字符串中的文本。 如问号 （？） 字符，& 符 （&） 斜杠标记 （/），并且可能会截断空格，或将其某些浏览器已损坏。 因此，这些字符必须经过编码中`<a>`标记或查询中的字符串可以在请求字符串中的浏览器中重新由字符串的位置。       <xref:System.Web.HttpServerUtility.UrlEncode%2A>是一种简便的方法来访问<xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=fullName>方法在运行时从 ASP.NET 应用程序。</xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=fullName></xref:System.Web.HttpServerUtility.UrlEncode%2A> 在内部，<xref:System.Web.HttpServerUtility.UrlEncode%2A>使用<xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=fullName>对字符串进行编码。</xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=fullName> </xref:System.Web.HttpServerUtility.UrlEncode%2A>       若要进行编码或解码的 web 应用程序之外的值，使用<xref:System.Net.WebUtility>类。</xref:System.Net.WebUtility>"
  example:
  - "The following example encodes a string for transmission by HTTP. It encodes the string named `TestString`, which contains the text \"This is a \\<Test String>.\", and copies it into the string named `EncodedString` as \"This+is+a+%3cTest+String%3e.\".  \n  \n [!code-cs[Classic HttpServerUtility.UrlEncode1 Example#1](~/add/codesnippet/csharp/m-system.web.httpserveru_13_1.cs)]\n [!code-vb[Classic HttpServerUtility.UrlEncode1 Example#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_13_1.vb)]"
  syntax:
    content: public void UrlEncode (string s, System.IO.TextWriter output);
    parameters:
    - id: s
      type: System.String
      description: "要编码的文本字符串。"
    - id: output
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>包含已编码的字符串的输出流。</xref:System.IO.TextWriter>"
  overload: System.Web.HttpServerUtility.UrlEncode*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpServerUtility.UrlPathEncode(System.String)
  id: UrlPathEncode(System.String)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: UrlPathEncode(String)
  nameWithType: HttpServerUtility.UrlPathEncode(String)
  fullName: System.Web.HttpServerUtility.UrlPathEncode(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "不要使用;仅供浏览器兼容性。 使用<xref:System.Web.HttpServerUtility.UrlEncode*>.</xref:System.Web.HttpServerUtility.UrlEncode*>"
  syntax:
    content: public string UrlPathEncode (string s);
    parameters:
    - id: s
      type: System.String
      description: "进行 URL 编码的文本。"
    return:
      type: System.String
      description: "URL 已编码的文本。"
  overload: System.Web.HttpServerUtility.UrlPathEncode*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpServerUtility.UrlTokenDecode(System.String)
  id: UrlTokenDecode(System.String)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: UrlTokenDecode(String)
  nameWithType: HttpServerUtility.UrlTokenDecode(String)
  fullName: System.Web.HttpServerUtility.UrlTokenDecode(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "对 URL 字符串标记为使用 base 64 数字的等效字节数组进行解码。"
  remarks: "UrlTokenDecode 方法将 URL 字符串标记，它将二进制数据编码为 base 64 数字，转换为其等效的字节数组表示形式。 使用 UrlTokenDecode 方法解码，这些标记在 URL 中传输和编码使用<xref:System.Web.HttpServerUtility.UrlTokenEncode%2A>。</xref:System.Web.HttpServerUtility.UrlTokenEncode%2A>       UrlTokenDecode 方法将返回一个空字节数组，如果`input`参数具有的长度小于&1;。"
  syntax:
    content: public static byte[] UrlTokenDecode (string input);
    parameters:
    - id: input
      type: System.String
      description: "要解码的 URL 字符串标记。"
    return:
      type: System.Byte[]
      description: "包含已解码的 URL 字符串标记的字节数组。"
  overload: System.Web.HttpServerUtility.UrlTokenDecode*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "值<code> input </code>参数是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])
  id: UrlTokenEncode(System.Byte[])
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: UrlTokenEncode(Byte[])
  nameWithType: HttpServerUtility.UrlTokenEncode(Byte[])
  fullName: System.Web.HttpServerUtility.UrlTokenEncode(Byte[])
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "将字节数组编码为使用 base 64 数字，这可用于 URL 传输其等效的字符串表示形式。"
  remarks: "UrlTokenEncode 方法将转换为等效的字符串表示形式使用 base 64 数字编码的字节数组。 可以在 URL 中传输的生成的字符串标记。       UrlTokenEncode 将返回空字符串，如果`input`参数具有的长度小于&1;。"
  syntax:
    content: public static string UrlTokenEncode (byte[] input);
    parameters:
    - id: input
      type: System.Byte[]
      description: "要编码的字节数组。"
    return:
      type: System.String
      description: "包含令牌时的编码的字节数组的字符串*长度*大于&1; 否则为空字符串 (&quot;&quot;)。"
  overload: System.Web.HttpServerUtility.UrlTokenEncode*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "值<code> input </code>参数是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Web.HttpException
  parent: System.Web
  isExternal: false
  name: HttpException
  nameWithType: HttpException
  fullName: System.Web.HttpException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ApplicationException
  parent: System
  isExternal: false
  name: ApplicationException
  nameWithType: ApplicationException
  fullName: System.ApplicationException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.Web.HttpServerUtility.ClearError
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: ClearError()
  nameWithType: HttpServerUtility.ClearError()
  fullName: System.Web.HttpServerUtility.ClearError()
- uid: System.Web.HttpServerUtility.CreateObject(System.String)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: CreateObject(String)
  nameWithType: HttpServerUtility.CreateObject(String)
  fullName: System.Web.HttpServerUtility.CreateObject(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Web.HttpServerUtility.CreateObject(System.Type)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: CreateObject(Type)
  nameWithType: HttpServerUtility.CreateObject(Type)
  fullName: System.Web.HttpServerUtility.CreateObject(Type)
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: CreateObjectFromClsid(String)
  nameWithType: HttpServerUtility.CreateObjectFromClsid(String)
  fullName: System.Web.HttpServerUtility.CreateObjectFromClsid(String)
- uid: System.Web.HttpServerUtility.Execute(System.String)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: Execute(String)
  nameWithType: HttpServerUtility.Execute(String)
  fullName: System.Web.HttpServerUtility.Execute(String)
- uid: System.Web.HttpServerUtility.Execute(System.String,System.Boolean)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: Execute(String,Boolean)
  nameWithType: HttpServerUtility.Execute(String,Boolean)
  fullName: System.Web.HttpServerUtility.Execute(String,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: Execute(String,TextWriter)
  nameWithType: HttpServerUtility.Execute(String,TextWriter)
  fullName: System.Web.HttpServerUtility.Execute(String,TextWriter)
- uid: System.IO.TextWriter
  parent: System.IO
  isExternal: true
  name: TextWriter
  nameWithType: TextWriter
  fullName: System.IO.TextWriter
- uid: System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter,System.Boolean)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: Execute(String,TextWriter,Boolean)
  nameWithType: HttpServerUtility.Execute(String,TextWriter,Boolean)
  fullName: System.Web.HttpServerUtility.Execute(String,TextWriter,Boolean)
- uid: System.Web.HttpServerUtility.Execute(System.Web.IHttpHandler,System.IO.TextWriter,System.Boolean)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: Execute(IHttpHandler,TextWriter,Boolean)
  nameWithType: HttpServerUtility.Execute(IHttpHandler,TextWriter,Boolean)
  fullName: System.Web.HttpServerUtility.Execute(IHttpHandler,TextWriter,Boolean)
- uid: System.Web.IHttpHandler
  parent: System.Web
  isExternal: false
  name: IHttpHandler
  nameWithType: IHttpHandler
  fullName: System.Web.IHttpHandler
- uid: System.Web.HttpServerUtility.GetLastError
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: GetLastError()
  nameWithType: HttpServerUtility.GetLastError()
  fullName: System.Web.HttpServerUtility.GetLastError()
- uid: System.Exception
  parent: System
  isExternal: true
  name: Exception
  nameWithType: Exception
  fullName: System.Exception
- uid: System.Web.HttpServerUtility.HtmlDecode(System.String)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: HtmlDecode(String)
  nameWithType: HttpServerUtility.HtmlDecode(String)
  fullName: System.Web.HttpServerUtility.HtmlDecode(String)
- uid: System.Web.HttpServerUtility.HtmlDecode(System.String,System.IO.TextWriter)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: HtmlDecode(String,TextWriter)
  nameWithType: HttpServerUtility.HtmlDecode(String,TextWriter)
  fullName: System.Web.HttpServerUtility.HtmlDecode(String,TextWriter)
- uid: System.Web.HttpServerUtility.HtmlEncode(System.String)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: HtmlEncode(String)
  nameWithType: HttpServerUtility.HtmlEncode(String)
  fullName: System.Web.HttpServerUtility.HtmlEncode(String)
- uid: System.Web.HttpServerUtility.HtmlEncode(System.String,System.IO.TextWriter)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: HtmlEncode(String,TextWriter)
  nameWithType: HttpServerUtility.HtmlEncode(String,TextWriter)
  fullName: System.Web.HttpServerUtility.HtmlEncode(String,TextWriter)
- uid: System.Web.HttpServerUtility.MachineName
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: MachineName
  nameWithType: HttpServerUtility.MachineName
  fullName: System.Web.HttpServerUtility.MachineName
- uid: System.Web.HttpServerUtility.MapPath(System.String)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: MapPath(String)
  nameWithType: HttpServerUtility.MapPath(String)
  fullName: System.Web.HttpServerUtility.MapPath(String)
- uid: System.Web.HttpServerUtility.ScriptTimeout
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: ScriptTimeout
  nameWithType: HttpServerUtility.ScriptTimeout
  fullName: System.Web.HttpServerUtility.ScriptTimeout
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Web.HttpServerUtility.Transfer(System.String)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: Transfer(String)
  nameWithType: HttpServerUtility.Transfer(String)
  fullName: System.Web.HttpServerUtility.Transfer(String)
- uid: System.Web.HttpServerUtility.Transfer(System.String,System.Boolean)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: Transfer(String,Boolean)
  nameWithType: HttpServerUtility.Transfer(String,Boolean)
  fullName: System.Web.HttpServerUtility.Transfer(String,Boolean)
- uid: System.Web.HttpServerUtility.Transfer(System.Web.IHttpHandler,System.Boolean)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: Transfer(IHttpHandler,Boolean)
  nameWithType: HttpServerUtility.Transfer(IHttpHandler,Boolean)
  fullName: System.Web.HttpServerUtility.Transfer(IHttpHandler,Boolean)
- uid: System.Web.HttpServerUtility.TransferRequest(System.String)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: TransferRequest(String)
  nameWithType: HttpServerUtility.TransferRequest(String)
  fullName: System.Web.HttpServerUtility.TransferRequest(String)
- uid: System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: TransferRequest(String,Boolean)
  nameWithType: HttpServerUtility.TransferRequest(String,Boolean)
  fullName: System.Web.HttpServerUtility.TransferRequest(String,Boolean)
- uid: System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: TransferRequest(String,Boolean,String,NameValueCollection)
  nameWithType: HttpServerUtility.TransferRequest(String,Boolean,String,NameValueCollection)
  fullName: System.Web.HttpServerUtility.TransferRequest(String,Boolean,String,NameValueCollection)
- uid: System.Collections.Specialized.NameValueCollection
  parent: System.Collections.Specialized
  isExternal: false
  name: NameValueCollection
  nameWithType: NameValueCollection
  fullName: System.Collections.Specialized.NameValueCollection
- uid: System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: TransferRequest(String,Boolean,String,NameValueCollection,Boolean)
  nameWithType: HttpServerUtility.TransferRequest(String,Boolean,String,NameValueCollection,Boolean)
  fullName: System.Web.HttpServerUtility.TransferRequest(String,Boolean,String,NameValueCollection,Boolean)
- uid: System.Web.HttpServerUtility.UrlDecode(System.String)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: UrlDecode(String)
  nameWithType: HttpServerUtility.UrlDecode(String)
  fullName: System.Web.HttpServerUtility.UrlDecode(String)
- uid: System.Web.HttpServerUtility.UrlDecode(System.String,System.IO.TextWriter)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: UrlDecode(String,TextWriter)
  nameWithType: HttpServerUtility.UrlDecode(String,TextWriter)
  fullName: System.Web.HttpServerUtility.UrlDecode(String,TextWriter)
- uid: System.Web.HttpServerUtility.UrlEncode(System.String)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: UrlEncode(String)
  nameWithType: HttpServerUtility.UrlEncode(String)
  fullName: System.Web.HttpServerUtility.UrlEncode(String)
- uid: System.Web.HttpServerUtility.UrlEncode(System.String,System.IO.TextWriter)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: UrlEncode(String,TextWriter)
  nameWithType: HttpServerUtility.UrlEncode(String,TextWriter)
  fullName: System.Web.HttpServerUtility.UrlEncode(String,TextWriter)
- uid: System.Web.HttpServerUtility.UrlPathEncode(System.String)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: UrlPathEncode(String)
  nameWithType: HttpServerUtility.UrlPathEncode(String)
  fullName: System.Web.HttpServerUtility.UrlPathEncode(String)
- uid: System.Web.HttpServerUtility.UrlTokenDecode(System.String)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: UrlTokenDecode(String)
  nameWithType: HttpServerUtility.UrlTokenDecode(String)
  fullName: System.Web.HttpServerUtility.UrlTokenDecode(String)
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: UrlTokenEncode(Byte[])
  nameWithType: HttpServerUtility.UrlTokenEncode(Byte[])
  fullName: System.Web.HttpServerUtility.UrlTokenEncode(Byte[])
- uid: System.Web.HttpServerUtility.ClearError*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: ClearError
  nameWithType: HttpServerUtility.ClearError
- uid: System.Web.HttpServerUtility.CreateObject*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: CreateObject
  nameWithType: HttpServerUtility.CreateObject
- uid: System.Web.HttpServerUtility.CreateObjectFromClsid*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: CreateObjectFromClsid
  nameWithType: HttpServerUtility.CreateObjectFromClsid
- uid: System.Web.HttpServerUtility.Execute*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: Execute
  nameWithType: HttpServerUtility.Execute
- uid: System.Web.HttpServerUtility.GetLastError*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: GetLastError
  nameWithType: HttpServerUtility.GetLastError
- uid: System.Web.HttpServerUtility.HtmlDecode*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: HtmlDecode
  nameWithType: HttpServerUtility.HtmlDecode
- uid: System.Web.HttpServerUtility.HtmlEncode*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: HtmlEncode
  nameWithType: HttpServerUtility.HtmlEncode
- uid: System.Web.HttpServerUtility.MachineName*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: MachineName
  nameWithType: HttpServerUtility.MachineName
- uid: System.Web.HttpServerUtility.MapPath*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: MapPath
  nameWithType: HttpServerUtility.MapPath
- uid: System.Web.HttpServerUtility.ScriptTimeout*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: ScriptTimeout
  nameWithType: HttpServerUtility.ScriptTimeout
- uid: System.Web.HttpServerUtility.Transfer*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: Transfer
  nameWithType: HttpServerUtility.Transfer
- uid: System.Web.HttpServerUtility.TransferRequest*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: TransferRequest
  nameWithType: HttpServerUtility.TransferRequest
- uid: System.Web.HttpServerUtility.UrlDecode*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: UrlDecode
  nameWithType: HttpServerUtility.UrlDecode
- uid: System.Web.HttpServerUtility.UrlEncode*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: UrlEncode
  nameWithType: HttpServerUtility.UrlEncode
- uid: System.Web.HttpServerUtility.UrlPathEncode*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: UrlPathEncode
  nameWithType: HttpServerUtility.UrlPathEncode
- uid: System.Web.HttpServerUtility.UrlTokenDecode*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: UrlTokenDecode
  nameWithType: HttpServerUtility.UrlTokenDecode
- uid: System.Web.HttpServerUtility.UrlTokenEncode*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: UrlTokenEncode
  nameWithType: HttpServerUtility.UrlTokenEncode
