### YamlMime:ManagedReference
items:
- uid: System.Net.Sockets.NetworkStream
  id: NetworkStream
  children:
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)
  - System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.Net.Sockets.NetworkStream.CanRead
  - System.Net.Sockets.NetworkStream.CanSeek
  - System.Net.Sockets.NetworkStream.CanTimeout
  - System.Net.Sockets.NetworkStream.CanWrite
  - System.Net.Sockets.NetworkStream.Close(System.Int32)
  - System.Net.Sockets.NetworkStream.DataAvailable
  - System.Net.Sockets.NetworkStream.Dispose(System.Boolean)
  - System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)
  - System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)
  - System.Net.Sockets.NetworkStream.Finalize
  - System.Net.Sockets.NetworkStream.Flush
  - System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)
  - System.Net.Sockets.NetworkStream.Length
  - System.Net.Sockets.NetworkStream.Position
  - System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.Net.Sockets.NetworkStream.Readable
  - System.Net.Sockets.NetworkStream.ReadTimeout
  - System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.Net.Sockets.NetworkStream.SetLength(System.Int64)
  - System.Net.Sockets.NetworkStream.Socket
  - System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.Net.Sockets.NetworkStream.Writeable
  - System.Net.Sockets.NetworkStream.WriteTimeout
  langs:
  - csharp
  name: NetworkStream
  nameWithType: NetworkStream
  fullName: System.Net.Sockets.NetworkStream
  type: Class
  summary: "提供了网络访问数据的基础流。"
  remarks: "NetworkStream 类提供用于通过发送和接收数据方法<xref:System.Net.Sockets.SocketType>中阻止模式套接字。</xref:System.Net.Sockets.SocketType> 有关阻止与非阻止<xref:System.Net.Sockets.Socket>s，请参阅[使用异步客户端套接字](~/add/includes/ajax-current-ext-md.md)。</xref:System.Net.Sockets.Socket> NetworkStream 类可用于这两个同步和异步数据传输。 有关同步和异步通信的详细信息，请参阅[套接字](~/add/includes/ajax-current-ext-md.md)。       若要创建 NetworkStream，必须提供连接<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> 你还可以指定哪些<xref:System.IO.FileAccess>权限 NetworkStream 已通过提供<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.IO.FileAccess> 默认情况下，关闭 NetworkStream 不会关闭提供<xref:System.Net.Sockets.Socket>。</xref:System.Net.Sockets.Socket> 如果你想 NetworkStream 必须具有权限才能关闭提供<xref:System.Net.Sockets.Socket>，必须指定`true`的值的`ownsSocket`参数。</xref:System.Net.Sockets.Socket>       使用<xref:System.Net.Sockets.NetworkStream.Write%2A>和<xref:System.Net.Sockets.NetworkStream.Read%2A>方法用于简单的单线程同步阻止 I/O。</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream.Write%2A> 如果你想要处理你使用单独的线程的 I/O，请考虑使用<xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>和<xref:System.Net.Sockets.NetworkStream.EndWrite%2A>方法，或<xref:System.Net.Sockets.NetworkStream.BeginRead%2A>和<xref:System.Net.Sockets.NetworkStream.EndRead%2A>方法进行通信。</xref:System.Net.Sockets.NetworkStream.EndRead%2A> </xref:System.Net.Sockets.NetworkStream.BeginRead%2A> </xref:System.Net.Sockets.NetworkStream.EndWrite%2A> </xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>       NetworkStream 不支持随机访问网络数据流。 值<xref:System.Net.Sockets.NetworkStream.CanSeek%2A>属性，该值指示流是否支持查找，始终是`false`; 读取<xref:System.Net.Sockets.NetworkStream.Position%2A>属性，读取<xref:System.Net.Sockets.NetworkStream.Length%2A>属性，或调用<xref:System.Net.Sockets.NetworkStream.Seek%2A>方法将引发一种<xref:System.NotSupportedException>。</xref:System.NotSupportedException> </xref:System.Net.Sockets.NetworkStream.Seek%2A> </xref:System.Net.Sockets.NetworkStream.Length%2A> </xref:System.Net.Sockets.NetworkStream.Position%2A> </xref:System.Net.Sockets.NetworkStream.CanSeek%2A>       可以同时执行读取和写入操作，而无需同步 NetworkStream 类的实例上。 只要没有进行写入操作的一个唯一线程和进行读取操作的一个唯一线程，读取之间将出现存在交叉引用，以及是必需的写线程和不同步。"
  example:
  - "The following code example demonstrates how to create a NetworkStream from a connected <xref:System.Net.Sockets.SocketType><xref:System.Net.Sockets.Socket> and perform basic synchronous blocking I/O.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/visualbasic/t-system.net.sockets.net_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/cpp/t-system.net.sockets.net_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/csharp/t-system.net.sockets.net_1.cs)]"
  syntax:
    content: 'public class NetworkStream : System.IO.Stream'
  inheritance:
  - System.IO.Stream
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)
  id: '#ctor(System.Net.Sockets.Socket)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket)
  nameWithType: NetworkStream.NetworkStream(Socket)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "创建的新实例<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>指定<xref:System.Net.Sockets.Socket>。</xref:System.Net.Sockets.Socket>类"
  remarks: "<xref:System.Net.Sockets.NetworkStream>创建具有到指定<xref:System.Net.Sockets.Socket>。</xref:System.Net.Sockets.Socket>的读/写访问权限</xref:System.Net.Sockets.NetworkStream> <xref:System.Net.Sockets.NetworkStream>不拥有基础的<xref:System.Net.Sockets.Socket>因此调用的<xref:System.Net.Sockets.NetworkStream.Close%2A>方法不会关闭<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example illustrates how to create a <xref:System.Net.Sockets.NetworkStream> with a <xref:System.Net.Sockets.Socket>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/visualbasic/m-system.net.sockets.net_0_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/cpp/m-system.net.sockets.net_0_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/csharp/m-system.net.sockets.net_0_1.cs)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "<xref:System.Net.Sockets.Socket>， <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>将用于发送和接收数据。</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code> socket </code>未连接参数。       -或-<xref:System.Net.Sockets.Socket.SocketType*>属性<code> socket </code>参数不是&lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;。</xref:System.Net.Sockets.Socket.SocketType*>       -或- <code> socket </code>参数处于锁定状态。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)
  id: '#ctor(System.Net.Sockets.Socket,System.Boolean)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,Boolean)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "初始化的新实例<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>类指定<xref:System.Net.Sockets.Socket>具有指定<xref:System.Net.Sockets.Socket>所有权。</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.NetworkStream>创建具有到指定<xref:System.Net.Sockets.Socket>。</xref:System.Net.Sockets.Socket>的读/写访问权限</xref:System.Net.Sockets.NetworkStream> 如果值`ownsSocket`参数是`true`、<xref:System.Net.Sockets.NetworkStream>取得所有权的基础<xref:System.Net.Sockets.Socket>，并调用的<xref:System.Net.Sockets.NetworkStream.Close%2A>方法也会关闭基础<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.NetworkStream> with ownership of the <xref:System.Net.Sockets.Socket>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/visualbasic/59c93a1c-9c9b-46b2-a872-_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/cpp/59c93a1c-9c9b-46b2-a872-_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/csharp/59c93a1c-9c9b-46b2-a872-_1.cs)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket, bool ownsSocket);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "<xref:System.Net.Sockets.Socket>， <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>将用于发送和接收数据。</xref:System.Net.Sockets.Socket>"
    - id: ownsSocket
      type: System.Boolean
      description: "设置为<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> ，则指示<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>将获得的所有权<xref:System.Net.Sockets.Socket>; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code> socket </code>未连接参数。       -的值<xref:System.Net.Sockets.Socket.SocketType*>属性<code> socket </code>参数不是&lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;。</xref:System.Net.Sockets.Socket.SocketType*>       -或- <code> socket </code>参数处于锁定状态。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)
  id: '#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket,FileAccess)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "创建的新实例<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>类指定<xref:System.Net.Sockets.Socket>具有所指定的访问权限。</xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.NetworkStream>创建到指定<xref:System.Net.Sockets.Socket>。</xref:System.Net.Sockets.Socket>的指定访问权限</xref:System.Net.Sockets.NetworkStream> 使用此构造函数，<xref:System.Net.Sockets.NetworkStream>没有基础的<xref:System.Net.Sockets.Socket>因此调用的<xref:System.Net.Sockets.NetworkStream.Close%2A>方法不会关闭基础<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>       `access`参数设置<xref:System.Net.Sockets.NetworkStream.CanRead%2A>和<xref:System.Net.Sockets.NetworkStream.CanWrite%2A>属性的<xref:System.Net.Sockets.NetworkStream>。</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.CanWrite%2A> </xref:System.Net.Sockets.NetworkStream.CanRead%2A> 如果指定<xref:System.IO.FileAccess>，则<xref:System.Net.Sockets.NetworkStream>允许调用<xref:System.Net.Sockets.NetworkStream.Write%2A>方法。</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> 如果指定<xref:System.IO.FileAccess>，则<xref:System.Net.Sockets.NetworkStream>允许调用<xref:System.Net.Sockets.NetworkStream.Read%2A>方法。</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> 如果指定<xref:System.IO.FileAccess>，这两个方法调用都被允许。</xref:System.IO.FileAccess>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.NetworkStream> with the ability to read and write to the <xref:System.Net.Sockets.Socket>.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/visualbasic/586c6962-cd9c-4b70-aa3e-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/csharp/586c6962-cd9c-4b70-aa3e-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/cpp/586c6962-cd9c-4b70-aa3e-_1.cpp)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "<xref:System.Net.Sockets.Socket>， <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>将用于发送和接收数据。</xref:System.Net.Sockets.Socket>"
    - id: access
      type: System.IO.FileAccess
      description: "按位组合<xref href=&quot;System.IO.FileAccess&quot;></xref>指定的访问提供给类型的值<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>通过提供<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code> socket </code>未连接参数。       -或-<xref:System.Net.Sockets.Socket.SocketType*>属性<code> socket </code>参数不是&lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;。</xref:System.Net.Sockets.Socket.SocketType*>       -或- <code> socket </code>参数处于锁定状态。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)
  id: '#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket,FileAccess,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "创建的新实例<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>类指定<xref:System.Net.Sockets.Socket>使用指定的访问权限和指定<xref:System.Net.Sockets.Socket>所有权。</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.NetworkStream>创建具有到指定<xref:System.Net.Sockets.Socket>。</xref:System.Net.Sockets.Socket>的读/写访问权限</xref:System.Net.Sockets.NetworkStream> 如果值`ownsSocket`参数是`true`、<xref:System.Net.Sockets.NetworkStream>取得所有权的基础<xref:System.Net.Sockets.Socket>，并调用的<xref:System.Net.Sockets.NetworkStream.Close%2A>方法也会关闭基础<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>       `access`参数设置<xref:System.Net.Sockets.NetworkStream.CanRead%2A>和<xref:System.Net.Sockets.NetworkStream.CanWrite%2A>属性的<xref:System.Net.Sockets.NetworkStream>。</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.CanWrite%2A> </xref:System.Net.Sockets.NetworkStream.CanRead%2A> 如果指定<xref:System.IO.FileAccess>，则<xref:System.Net.Sockets.NetworkStream>允许调用<xref:System.Net.Sockets.NetworkStream.Write%2A>方法。</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> 如果指定<xref:System.IO.FileAccess>，则<xref:System.Net.Sockets.NetworkStream>允许调用<xref:System.Net.Sockets.NetworkStream.Read%2A>方法。</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> 如果指定<xref:System.IO.FileAccess>，这两个方法调用都被允许。</xref:System.IO.FileAccess>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.NetworkStream> with the ability to read and write to the <xref:System.Net.Sockets.Socket>. Ownership of the <xref:System.Net.Sockets.Socket> is given to this <xref:System.Net.Sockets.NetworkStream> by specifying `true` for the `ownsSocket` parameter.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/visualbasic/db34d484-28c0-47ef-b5ca-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/csharp/db34d484-28c0-47ef-b5ca-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/cpp/db34d484-28c0-47ef-b5ca-_1.cpp)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access, bool ownsSocket);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "<xref:System.Net.Sockets.Socket>， <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>将用于发送和接收数据。</xref:System.Net.Sockets.Socket>"
    - id: access
      type: System.IO.FileAccess
      description: "按位组合<xref href=&quot;System.IO.FileAccess&quot;></xref>指定到提供的访问的类型的值<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>通过提供<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
    - id: ownsSocket
      type: System.Boolean
      description: "设置为<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> ，则指示<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>将获得的所有权<xref:System.Net.Sockets.Socket>; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code> socket </code>未连接参数。       -或-<xref:System.Net.Sockets.Socket.SocketType*>属性<code> socket </code>参数不是&lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;。</xref:System.Net.Sockets.Socket.SocketType*>       -或- <code> socket </code>参数处于锁定状态。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "开始异步读从<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。"
  remarks: "BeginRead 方法会启动以异步方式从传入的网络缓冲区中读取数据。 调用 BeginRead 方法使你能够接收在单独的执行线程中的数据。       你必须创建实现一个回调方法<xref:System.AsyncCallback>委托并将其名称传递给 BeginRead 方法。</xref:System.AsyncCallback> 至少，你`state`参数必须包含<xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> 由于你将想要获取你的回调方法中接收到的数据，你应创建较小的类或结构，用于保存读取的缓冲区和任何其他有用信息。 通过 BeginRead 方法传递结构或类实例`state`参数。       你的回调方法应调用<xref:System.Net.Sockets.NetworkStream.EndRead%2A>方法。</xref:System.Net.Sockets.NetworkStream.EndRead%2A> 当你的应用程序调用 BeginRead 时，系统将等待接收数据或发生错误，然后系统将使用一个单独的线程执行指定的回调方法，并且阻止<xref:System.Net.Sockets.NetworkStream.EndRead%2A>直到提供<xref:System.Net.Sockets.NetworkStream>读取数据或引发异常。</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.EndRead%2A> 如果你想要阻止后调用 BeginRead 方法的原始线程，使用<xref:System.Threading.WaitHandle.WaitOne%2A>方法。</xref:System.Threading.WaitHandle.WaitOne%2A> 调用<xref:System.Threading.EventWaitHandle.Set%2A>当你想要继续执行原始线程时的回调方法中。</xref:System.Threading.EventWaitHandle.Set%2A> 有关编写回调方法的其他信息，请参阅[委托作为回调方法进行封送](~/add/includes/ajax-current-ext-md.md)。       BeginRead 方法读取原样可用，直到达到指定的字节数多的数据`size`参数。      1> [!NOTE]&1;> 如果你收到的<xref:System.IO.IOException>，请检查<xref:System.Exception.InnerException%2A>属性来确定如果它引起的一种<xref:System.Net.Sockets.SocketException>。</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> 如果是，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A>属性来获取特定错误代码，并请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。</xref:System.Net.Sockets.SocketException.ErrorCode%2A>       读取和写入的实例上可以同时执行操作<xref:System.Net.Sockets.NetworkStream>而无需同步的类。</xref:System.Net.Sockets.NetworkStream> 只要没有进行写入操作的一个唯一线程和进行读取操作的一个唯一线程，读取之间将出现存在交叉引用，以及是必需的写线程和不同步。"
  example:
  - "The following code example uses BeginRead to read data asynchronously from the network stream. The `myReadCallBack` method implements the <xref:System.AsyncCallback> delegate and is called by the system when BeginRead returns.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#3](~/add/codesnippet/visualbasic/b2716ae9-7520-4d87-8b97-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#3](~/add/codesnippet/csharp/b2716ae9-7520-4d87-8b97-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#3](~/add/codesnippet/cpp/b2716ae9-7520-4d87-8b97-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginRead (byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "类型的数组<xref:System.Byte>即内存中用于存储从读取的数据的位置<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "中的位置`buffer`开始存储数据。"
    - id: size
      type: System.Int32
      description: "要从其中进行读取的字节数<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。"
    - id: callback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>当 BeginRead 完成时执行的委托。</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "一个包含任何其他用户定义数据的对象。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，它表示异步调用。</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.NetworkStream.BeginRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> offset </code>参数小于 0。       -或- <code> offset </code>参数的长度大于<code> buffer </code>参数。       -或- <code> size </code>小于 0。       -或- <code> size </code>大于的长度<code> buffer </code>的值减去<code> offset </code>参数。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "基础<xref:System.Net.Sockets.Socket>已关闭。</xref:System.Net.Sockets.Socket>       -或者-从网络读取时失败。       -或者-访问套接字时出错。 请参阅备注部分以了解更多信息。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>已关闭。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "开始异步写到流。"
  remarks: "调用方法会启动到远程主机的异步发送操作。 调用调用方法使你能够发送单独的执行线程中的数据。       你必须创建实现一个回调方法<xref:System.AsyncCallback>委托并将其名称传递到调用方法。</xref:System.AsyncCallback> 至少，你`state`参数必须包含<xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> 如果你的回调需要详细信息，可以创建一个小型类或结构，用于保存<xref:System.Net.Sockets.NetworkStream>和其他必需的信息。</xref:System.Net.Sockets.NetworkStream> 通过调用方法传递结构或类实例`state`参数。       你的回调方法应实现<xref:System.Net.Sockets.NetworkStream.EndWrite%2A>方法。</xref:System.Net.Sockets.NetworkStream.EndWrite%2A> 当你的应用程序调用调用时，系统使用一个单独的线程来执行指定的回调方法，并阻止上<xref:System.Net.Sockets.NetworkStream.EndWrite%2A>直到<xref:System.Net.Sockets.NetworkStream>发送请求的字节数或引发异常。</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.EndWrite%2A> 如果你想要阻止后调用的调用方法的原始线程，使用<xref:System.Threading.WaitHandle.WaitOne%2A>方法。</xref:System.Threading.WaitHandle.WaitOne%2A> 调用<xref:System.Threading.EventWaitHandle.Set%2A>当你想要继续执行原始线程时的回调方法中。</xref:System.Threading.EventWaitHandle.Set%2A> 有关编写回调方法的其他信息，请参阅[委托作为回调方法进行封送](~/add/includes/ajax-current-ext-md.md)。      1> [!NOTE]&1;> 如果你收到的<xref:System.IO.IOException>，请检查<xref:System.Exception.InnerException%2A>属性来确定如果它引起的一种<xref:System.Net.Sockets.SocketException>。</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> 如果是，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A>属性来获取特定错误代码，并请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。</xref:System.Net.Sockets.SocketException.ErrorCode%2A>       读取和写入的实例上可以同时执行操作<xref:System.Net.Sockets.NetworkStream>而无需同步的类。</xref:System.Net.Sockets.NetworkStream> 只要没有进行写入操作的一个唯一线程和进行读取操作的一个唯一线程，读取之间将出现存在交叉引用，以及是必需的写线程和不同步。"
  example:
  - "The following code example uses BeginWrite to write data asynchronously to a network stream. The `myWriteCallBack` method implements the <xref:System.AsyncCallback> delegate and is called by the system when BeginWrite returns.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#2](~/add/codesnippet/visualbasic/d3b03755-0183-42fc-98c1-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#2](~/add/codesnippet/csharp/d3b03755-0183-42fc-98c1-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#2](~/add/codesnippet/cpp/d3b03755-0183-42fc-98c1-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginWrite (byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "类型的数组<xref:System.Byte>，其中包含要写入到的数据<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "中的位置`buffer`开始发送数据。"
    - id: size
      type: System.Int32
      description: "要写入的字节数<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。"
    - id: callback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>当调用完成时执行的委托。</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "一个包含任何其他用户定义数据的对象。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，它表示异步调用。</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.NetworkStream.BeginWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> offset </code>参数小于 0。       -或- <code> offset </code>参数的长度大于<code> buffer </code>。       -或- <code> size </code>参数小于 0。       -或- <code> size </code>参数的长度大于<code> buffer </code>的值减去<code> offset </code>参数。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "基础<xref:System.Net.Sockets.Socket>已关闭。</xref:System.Net.Sockets.Socket>       -或者-向网络写入时失败。       -或者-访问套接字时出错。 请参阅备注部分以了解更多信息。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>已关闭。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanRead
  id: CanRead
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanRead
  nameWithType: NetworkStream.CanRead
  fullName: System.Net.Sockets.NetworkStream.CanRead
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "获取一个值，该值指示是否<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>支持读取。"
  remarks: "如果 CanRead `true`，<xref:System.Net.Sockets.NetworkStream>允许调用<xref:System.Net.Sockets.NetworkStream.Read%2A>方法。</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> 提供相应的<xref:System.IO.FileAccess>枚举值，在构造函数中设置的可读性和可写性的<xref:System.Net.Sockets.NetworkStream>。</xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> CanRead 属性设置时<xref:System.Net.Sockets.NetworkStream>初始化。</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example checks CanRead to verify that the <xref:System.Net.Sockets.NetworkStream> is readable. It then performs a read operation on the <xref:System.Net.Sockets.NetworkStream>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/visualbasic/p-system.net.sockets.net_6_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/cpp/p-system.net.sockets.net_6_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/csharp/p-system.net.sockets.net_6_1.cs)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果可以从该流，则读取数据否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Sockets.NetworkStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanSeek
  id: CanSeek
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: NetworkStream.CanSeek
  fullName: System.Net.Sockets.NetworkStream.CanSeek
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "获取一个值，该值指示流是否支持查找。 目前不支持此属性。此属性始终返回<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>在所有情况下，则指示<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>无法查找流中的特定位置。"
  overload: System.Net.Sockets.NetworkStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanTimeout
  id: CanTimeout
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanTimeout
  nameWithType: NetworkStream.CanTimeout
  fullName: System.Net.Sockets.NetworkStream.CanTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "指示是否可用于超时属性<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。"
  remarks: "此属性为存在的因为它从<xref:System.IO.Stream>.</xref:System.IO.Stream>继承"
  syntax:
    content: public override bool CanTimeout { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>在所有情况下。"
  overload: System.Net.Sockets.NetworkStream.CanTimeout*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanWrite
  id: CanWrite
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: NetworkStream.CanWrite
  fullName: System.Net.Sockets.NetworkStream.CanWrite
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "获取一个值，该值指示是否<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>支持写入。"
  remarks: "如果 CanWrite `true`，<xref:System.Net.Sockets.NetworkStream>允许调用<xref:System.Net.Sockets.NetworkStream.Write%2A>方法。</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> 提供相应的<xref:System.IO.FileAccess>枚举值，在构造函数中设置的可读性和可写性的<xref:System.Net.Sockets.NetworkStream>。</xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> 时会设置第<xref:System.Net.Sockets.NetworkStream>初始化。</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example checks CanWrite to verify that the <xref:System.Net.Sockets.NetworkStream> is writable. It then performs a write operation on the <xref:System.Net.Sockets.NetworkStream>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/visualbasic/p-system.net.sockets.net_0_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/cpp/p-system.net.sockets.net_0_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/csharp/p-system.net.sockets.net_0_1.cs)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果数据可以写入到<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Sockets.NetworkStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Close(System.Int32)
  id: Close(System.Int32)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Close(Int32)
  nameWithType: NetworkStream.Close(Int32)
  fullName: System.Net.Sockets.NetworkStream.Close(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "关闭<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>后等待指定的时间，以允许要发送的数据。"
  remarks: "Close 方法释放<xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream>与关联的非托管及托管资源 如果<xref:System.Net.Sockets.NetworkStream>拥有基础<xref:System.Net.Sockets.Socket>，也会关闭。</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>       如果<xref:System.Net.Sockets.NetworkStream>关联的<xref:System.Net.Sockets.TcpClient>、 Close 方法将关闭 TCP 连接，而不是释放的关联<xref:System.Net.Sockets.TcpClient>。</xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.NetworkStream>"
  syntax:
    content: public void Close (int timeout);
    parameters:
    - id: timeout
      type: System.Int32
      description: "32 位带符号的整数，指定等待发送任何剩余的数据，在关闭之前的毫秒数。"
  overload: System.Net.Sockets.NetworkStream.Close*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> timeout </code>参数是小于-1。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.DataAvailable
  id: DataAvailable
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: DataAvailable
  nameWithType: NetworkStream.DataAvailable
  fullName: System.Net.Sockets.NetworkStream.DataAvailable
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "获取一个值，该值指示是否可在上找到数据<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>要读取。"
  remarks: "DataAvailable 属性用于确定是否已准备好读取数据。 如果 DataAvailable `true`，调用<xref:System.Net.Sockets.NetworkStream.Read%2A>立即返回。</xref:System.Net.Sockets.NetworkStream.Read%2A> 如果远程主机关闭，或关闭了连接，DataAvailable 可能会引发一种<xref:System.Net.Sockets.SocketException>。</xref:System.Net.Sockets.SocketException>"
  example:
  - "The following code example reads from the <xref:System.Net.Sockets.NetworkStream> as long as data is available.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/visualbasic/p-system.net.sockets.net_2_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/cpp/p-system.net.sockets.net_2_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/csharp/p-system.net.sockets.net_2_1.cs)]"
  syntax:
    content: public virtual bool DataAvailable { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果在要读取; 流上的数据是否可用否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Sockets.NetworkStream.DataAvailable*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>已关闭。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "基础<xref:System.Net.Sockets.Socket>已关闭。</xref:System.Net.Sockets.Socket>"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "使用&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;属性来获取特定错误代码，并请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: NetworkStream.Dispose(Boolean)
  fullName: System.Net.Sockets.NetworkStream.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "释放由非托管的资源<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> ，还可以释放托管的资源。"
  remarks: "此方法称为由公共`Dispose`方法和<xref:System.Object.Finalize%2A>方法。</xref:System.Object.Finalize%2A> `Dispose`调用受保护`Dispose(Boolean)`方法替换`disposing`参数设置为`true`。 <xref:System.Object.Finalize%2A>调用`Dispose`与`disposing`设置为`false`。</xref:System.Object.Finalize%2A>       当`disposing`参数是`true`，此方法释放由任何托管对象持有的全部资源此<xref:System.Net.Sockets.NetworkStream>引用。</xref:System.Net.Sockets.NetworkStream> 此方法调用`Dispose`每个引用对象的方法。"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要释放托管和非托管资源;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>若要仅释放非托管的资源。"
  overload: System.Net.Sockets.NetworkStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)
  id: EndRead(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: EndRead(IAsyncResult)
  nameWithType: NetworkStream.EndRead(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndRead(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "处理异步读取的末尾。"
  remarks: "EndRead 方法完成异步读取的操作以启动<xref:System.Net.Sockets.NetworkStream.BeginRead%2A>方法。</xref:System.Net.Sockets.NetworkStream.BeginRead%2A>       之前调用<xref:System.Net.Sockets.NetworkStream.BeginRead%2A>，你需要创建实现一个回调方法<xref:System.AsyncCallback>委派。</xref:System.AsyncCallback> </xref:System.Net.Sockets.NetworkStream.BeginRead%2A> 此回调方法在一个单独的线程中执行之后, 由系统调用<xref:System.Net.Sockets.NetworkStream.BeginRead%2A>返回。</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> 回调方法必须接受<xref:System.IAsyncResult>从返回<xref:System.Net.Sockets.NetworkStream.BeginRead%2A>作为参数的方法。</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> </xref:System.IAsyncResult>       在回调方法中，调用<xref:System.IAsyncResult.AsyncState%2A>属性<xref:System.IAsyncResult>以获取状态对象传递给<xref:System.Net.Sockets.NetworkStream.BeginRead%2A>方法。</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> </xref:System.IAsyncResult> </xref:System.IAsyncResult.AsyncState%2A> 提取接收<xref:System.Net.Sockets.NetworkStream>从此状态对象。</xref:System.Net.Sockets.NetworkStream> 获取之后<xref:System.Net.Sockets.NetworkStream>，调用 EndRead 方法，以成功完成读取的操作并返回读取的字节数。</xref:System.Net.Sockets.NetworkStream>       EndRead 方法受到阻止，直到数据可用。 EndRead 方法读取多的数据可用最中指定的字节数多`size`参数<xref:System.Net.Sockets.NetworkStream.BeginRead%2A>方法。</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> 如果远程主机关闭<xref:System.Net.Sockets.Socket>收到连接和所有可用的数据、 EndRead 方法立即完成并返回零字节。</xref:System.Net.Sockets.Socket>       若要获取已接收的数据，请调用<xref:System.IAsyncResult.AsyncState%2A>属性<xref:System.IAsyncResult>，然后提取生成的状态对象中包含的缓冲区。</xref:System.IAsyncResult> </xref:System.IAsyncResult.AsyncState%2A>      1> [!NOTE]&1;> 如果你收到的<xref:System.IO.IOException>，请检查<xref:System.Exception.InnerException%2A>属性来确定如果它引起的一种<xref:System.Net.Sockets.SocketException>。</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> 如果是，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A>属性来获取特定错误代码，并请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。</xref:System.Net.Sockets.SocketException.ErrorCode%2A>"
  example:
  - "In the following code example, `myReadCallback` is provided to <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> as the callback method. EndRead is implemented in `myReadCallback` to complete the asynchronous read call started by <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#5](~/add/codesnippet/visualbasic/m-system.net.sockets.net_2_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#5](~/add/codesnippet/csharp/m-system.net.sockets.net_2_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#5](~/add/codesnippet/cpp/m-system.net.sockets.net_2_1.cpp)]"
  syntax:
    content: public override int EndRead (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>表示的异步调用。</xref:System.IAsyncResult>"
    return:
      type: System.Int32
      description: "从读取的字节数<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。"
  overload: System.Net.Sockets.NetworkStream.EndRead*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>asyncResult</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "基础<xref:System.Net.Sockets.Socket>已关闭。</xref:System.Net.Sockets.Socket>       -或者-访问套接字时出错。 请参阅备注部分以了解更多信息。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>已关闭。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)
  id: EndWrite(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: EndWrite(IAsyncResult)
  nameWithType: NetworkStream.EndWrite(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndWrite(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "处理异步写入的结束。"
  remarks: "EndWrite 完成在<xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>中启动的异步发送操作       之前调用<xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>，你需要创建实现一个回调方法<xref:System.AsyncCallback>委派。</xref:System.AsyncCallback> </xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> 此回调方法在一个单独的线程中执行之后, 由系统调用<xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>返回。</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> 回调方法必须接受<xref:System.IAsyncResult>从返回<xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>作为参数的方法。</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> </xref:System.IAsyncResult>       在回调方法中，调用<xref:System.IAsyncResult.AsyncState%2A>属性`IAsyncResult`参数来获取<xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> </xref:System.IAsyncResult.AsyncState%2A> 获取之后<xref:System.Net.Sockets.NetworkStream>，你可以调用 EndWrite 方法，以成功完成发送操作并返回发送的字节数。</xref:System.Net.Sockets.NetworkStream>       EndWrite 方法受到阻止，直到发送请求的字节数。      1> [!NOTE]&1;> 如果你收到的<xref:System.IO.IOException>，请检查<xref:System.Exception.InnerException%2A>属性来确定如果它引起的一种<xref:System.Net.Sockets.SocketException>。</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> 如果是，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A>属性来获取特定错误代码，并请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。</xref:System.Net.Sockets.SocketException.ErrorCode%2A>"
  example:
  - "In the following code example, `myWriteCallback` is provided to <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> as the callback method. EndWrite is implemented in `myWriteCallback` to complete the asynchronous write call started by <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#4](~/add/codesnippet/visualbasic/m-system.net.sockets.net_3_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#4](~/add/codesnippet/csharp/m-system.net.sockets.net_3_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#4](~/add/codesnippet/cpp/m-system.net.sockets.net_3_1.cpp)]"
  syntax:
    content: public override void EndWrite (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，它表示异步调用。</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.NetworkStream.EndWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>asyncResult</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "基础<xref:System.Net.Sockets.Socket>已关闭。</xref:System.Net.Sockets.Socket>       -或者-在写入到网络时出错。       -或者-访问套接字时出错。 请参阅备注部分以了解更多信息。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>已关闭。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Finalize
  id: Finalize
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Finalize()
  nameWithType: NetworkStream.Finalize()
  fullName: System.Net.Sockets.NetworkStream.Finalize()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "释放使用的所有资源<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。"
  remarks: "此方法将替代<xref:System.Object.Finalize%2A?displayProperty=fullName>.</xref:System.Object.Finalize%2A?displayProperty=fullName> 应用程序代码不应调用此方法。对象的<xref:System.Object.Finalize%2A>方法期间垃圾回收，自动将进行调用，除非已通过调用禁用垃圾回收器的终止<xref:System.GC.SuppressFinalize%2A?displayProperty=fullName>方法。</xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> </xref:System.Object.Finalize%2A>       有关使用 Finalize 方法的详细信息，请参阅[Finalize 方法和析构函数](http://msdn.microsoft.com/en-us/fd376774-1643-499b-869e-9546a3aeea70)，[清洗向上非托管资源](~/add/includes/ajax-current-ext-md.md)，和[重写 Finalize 方法](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)。"
  syntax:
    content: ~NetworkStream ();
    parameters: []
  overload: System.Net.Sockets.NetworkStream.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Flush
  id: Flush
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Flush()
  nameWithType: NetworkStream.Flush()
  fullName: System.Net.Sockets.NetworkStream.Flush()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "刷新流中的数据。 此方法保留供将来使用。"
  remarks: "Flush 方法实现<xref:System.IO.Stream.Flush%2A?displayProperty=fullName>方法; 但是，因为<xref:System.Net.Sockets.NetworkStream>是未进行缓冲处理，它没有任何影响网络流。</xref:System.Net.Sockets.NetworkStream> </xref:System.IO.Stream.Flush%2A?displayProperty=fullName> 调用 Flush 方法不会引发异常。"
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.Net.Sockets.NetworkStream.Flush*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)
  id: FlushAsync(System.Threading.CancellationToken)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: FlushAsync(CancellationToken)
  nameWithType: NetworkStream.FlushAsync(CancellationToken)
  fullName: System.Net.Sockets.NetworkStream.FlushAsync(CancellationToken)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "刷新流中的数据作为异步操作。"
  remarks: "不会阻止此操作。 返回<xref:System.Threading.Tasks.Task>对象都完成后已从流中刷新数据<xref:System.Net.Sockets.NetworkStream>实例。</xref:System.Net.Sockets.NetworkStream> </xref:System.Threading.Tasks.Task>"
  syntax:
    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "取消标记，用于传播应取消此操作的通知。"
    return:
      type: System.Threading.Tasks.Task
      description: "返回<xref:System.Threading.Tasks.Task>.</xref:System.Threading.Tasks.Task>       表示异步操作的任务对象。"
  overload: System.Net.Sockets.NetworkStream.FlushAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Length
  id: Length
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Length
  nameWithType: NetworkStream.Length
  fullName: System.Net.Sockets.NetworkStream.Length
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "获取流上可用的数据的长度。 此属性当前不支持，并且总是引发一种<xref:System.NotSupportedException>。</xref:System.NotSupportedException>"
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "在流上的可用数据的长度。"
  overload: System.Net.Sockets.NetworkStream.Length*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "任何使用此属性。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Position
  id: Position
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Position
  nameWithType: NetworkStream.Position
  fullName: System.Net.Sockets.NetworkStream.Position
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "获取或设置流中的当前位置。 此属性当前不支持，并且总是引发一种<xref:System.NotSupportedException>。</xref:System.NotSupportedException>"
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "流中当前位置。"
  overload: System.Net.Sockets.NetworkStream.Position*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "任何使用此属性。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Read(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "读取数据从<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。"
  remarks: "此方法将数据读入`buffer`参数并返回成功读取的字节数。 如果没有数据可供读取，则 Read 方法将返回 0。 读取操作读取原样可用，直到达到指定的字节数多的数据`size`参数。 如果远程主机关闭了连接，并已接收所有可用的数据，该读取方法将立即完成，并返回零字节。      1> [!NOTE]&1;> 检查以查看<xref:System.Net.Sockets.NetworkStream>通过调用是可读<xref:System.Net.Sockets.NetworkStream.CanRead%2A>属性。</xref:System.Net.Sockets.NetworkStream.CanRead%2A> </xref:System.Net.Sockets.NetworkStream> 如果你尝试从一种<xref:System.Net.Sockets.NetworkStream>，是不可读，你将收到<xref:System.IO.IOException>.</xref:System.IO.IOException></xref:System.Net.Sockets.NetworkStream>读取      1> [!NOTE]&1;> 如果你收到的<xref:System.IO.IOException>，请检查<xref:System.Exception.InnerException%2A>属性来确定如果它引起的一种<xref:System.Net.Sockets.SocketException>。</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> 如果是，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A>属性来获取特定错误代码，并请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。</xref:System.Net.Sockets.SocketException.ErrorCode%2A>"
  example:
  - "The following code example uses <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> to determine if data is available to be read. If data is available, it reads from the <xref:System.Net.Sockets.NetworkStream>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/visualbasic/m-system.net.sockets.net_1_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/cpp/m-system.net.sockets.net_1_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/csharp/m-system.net.sockets.net_1_1.cs)]"
  syntax:
    content: public override int Read (byte[] buffer, int offset, int size);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "类型的数组<xref:System.Byte>即内存中用于存储从读取的数据的位置<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "中的位置`buffer`开始存储到的数据。"
    - id: size
      type: System.Int32
      description: "要从其中进行读取的字节数<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。"
    return:
      type: System.Int32
      description: "从读取的字节数<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。"
  overload: System.Net.Sockets.NetworkStream.Read*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> offset </code>参数小于 0。       -或- <code> offset </code>参数的长度大于<code> buffer </code>。       -或- <code> size </code>参数小于 0。       -或- <code> size </code>参数的长度大于<code> buffer </code>的值减去<code> offset </code>参数。       -或者-访问套接字时出错。 请参阅备注部分以了解更多信息。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "基础<xref:System.Net.Sockets.Socket>已关闭。</xref:System.Net.Sockets.Socket>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>已关闭。       -或者-从网络读取失败。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Readable
  id: Readable
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Readable
  nameWithType: NetworkStream.Readable
  fullName: System.Net.Sockets.NetworkStream.Readable
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "获取或设置一个值，该值指示是否<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>可以读取。"
  remarks: "你必须从中派生<xref:System.Net.Sockets.NetworkStream>类以使用可读属性。</xref:System.Net.Sockets.NetworkStream> 如果可读内容是`true`，<xref:System.Net.Sockets.NetworkStream>允许调用<xref:System.Net.Sockets.NetworkStream.Read%2A>方法。</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> 您还可以确定是否<xref:System.Net.Sockets.NetworkStream>是通过检查可公开访问的可读<xref:System.Net.Sockets.NetworkStream.CanRead%2A>属性。</xref:System.Net.Sockets.NetworkStream.CanRead%2A> </xref:System.Net.Sockets.NetworkStream>       可读属性设置时<xref:System.Net.Sockets.NetworkStream>初始化。</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "In the following code example, the `CanCommunicate` property checks the Readable property to determine if the <xref:System.Net.Sockets.NetworkStream> is readable.  \n  \n [!code-cpp[NetworkStream_Protected_Members#1](~/add/codesnippet/cpp/p-system.net.sockets.net_7_1.cpp)]\n [!code-cs[NetworkStream_Protected_Members#1](~/add/codesnippet/csharp/p-system.net.sockets.net_7_1.cs)]\n [!code-vb[NetworkStream_Protected_Members#1](~/add/codesnippet/visualbasic/p-system.net.sockets.net_7_1.vb)]"
  syntax:
    content: protected bool Readable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要指示<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>可读; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Sockets.NetworkStream.Readable*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.ReadTimeout
  id: ReadTimeout
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: ReadTimeout
  nameWithType: NetworkStream.ReadTimeout
  fullName: System.Net.Sockets.NetworkStream.ReadTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "获取或设置读取的操作阻止等待其数据的时间量。"
  remarks: "如果此属性指定的时间内未完成读取的操作，该读取的操作将引发<xref:System.IO.IOException>.</xref:System.IO.IOException>      1> [!NOTE]&1;> 此属性会影响所调用仅同步读取<xref:System.Net.Sockets.NetworkStream.Read%2A>方法。</xref:System.Net.Sockets.NetworkStream.Read%2A> 此属性不会影响通过调用执行的异步读取操作<xref:System.Net.Sockets.NetworkStream.BeginRead%2A>方法。</xref:System.Net.Sockets.NetworkStream.BeginRead%2A>"
  example:
  - "The following code example sets the read time-out for a network stream to 10 milliseconds.  \n  \n [!code-cs[NCLTcpClientSync#2](~/add/codesnippet/csharp/p-system.net.sockets.net_4_1.cs)]"
  syntax:
    content: public override int ReadTimeout { get; set; }
    return:
      type: System.Int32
      description: "A <xref:System.Int32>，它指定的时间，以毫秒为单位，读取的操作失败之前将等待。</xref:System.Int32> 默认值， <xref:System.Threading.Timeout.Infinite>，指定读取的操作不会超时。</xref:System.Threading.Timeout.Infinite>"
  overload: System.Net.Sockets.NetworkStream.ReadTimeout*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "指定的值是否小于或等于零且不是<xref:System.Threading.Timeout.Infinite>.</xref:System.Threading.Timeout.Infinite>"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: NetworkStream.Seek(Int64,SeekOrigin)
  fullName: System.Net.Sockets.NetworkStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "将流的当前位置设置为给定的值。 此方法当前不支持，并且总是引发一种<xref:System.NotSupportedException>。</xref:System.NotSupportedException>"
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "未使用此参数。"
    - id: origin
      type: System.IO.SeekOrigin
      description: "未使用此参数。"
    return:
      type: System.Int64
      description: "流中的位置。"
  overload: System.Net.Sockets.NetworkStream.Seek*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "任何使用此属性。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: NetworkStream.SetLength(Int64)
  fullName: System.Net.Sockets.NetworkStream.SetLength(Int64)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "设置流的长度。 此方法始终引发一种<xref:System.NotSupportedException>。</xref:System.NotSupportedException>"
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "未使用此参数。"
  overload: System.Net.Sockets.NetworkStream.SetLength*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "任何使用此属性。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Socket
  id: Socket
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Socket
  nameWithType: NetworkStream.Socket
  fullName: System.Net.Sockets.NetworkStream.Socket
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "获取基础<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.NetworkStream>可以使用此属性以获取基础<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket></xref:System.Net.Sockets.NetworkStream>从派生的类 使用基础<xref:System.Net.Sockets.Socket>从套接字属性返回，如果你要求在超出其<xref:System.Net.Sockets.NetworkStream>提供。</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.Socket>      1> [!NOTE]&1;> 此属性是只通过此类或派生的类可访问。"
  example:
  - "The following code example retrieves the underlying <xref:System.Net.Sockets.Socket> to verify an active connection.  \n  \n [!code-cpp[NetworkStream_Protected_Members#1](~/add/codesnippet/cpp/p-system.net.sockets.net_3_1.cpp)]\n [!code-cs[NetworkStream_Protected_Members#1](~/add/codesnippet/csharp/p-system.net.sockets.net_3_1.cs)]\n [!code-vb[NetworkStream_Protected_Members#1](~/add/codesnippet/visualbasic/p-system.net.sockets.net_3_1.vb)]"
  syntax:
    content: protected System.Net.Sockets.Socket Socket { get; }
    return:
      type: System.Net.Sockets.Socket
      description: "A<xref:System.Net.Sockets.Socket>表示的基础网络连接。</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.Socket*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Write(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "将数据写入到<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。"
  remarks: "Write 方法开始指定`offset`并发送`size`的内容的字节`buffer`到网络。 Write 方法阻止状态，直到发送请求的字节数或<xref:System.Net.Sockets.SocketException>引发。</xref:System.Net.Sockets.SocketException> 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>属性来获取特定错误代码，并请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException>      1> [!NOTE]&1;> 检查以查看<xref:System.Net.Sockets.NetworkStream>通过访问可写<xref:System.Net.Sockets.NetworkStream.CanWrite%2A>属性。</xref:System.Net.Sockets.NetworkStream.CanWrite%2A> </xref:System.Net.Sockets.NetworkStream> 如果你尝试写入到<xref:System.Net.Sockets.NetworkStream>这是不可写，你将收到<xref:System.IO.IOException>.</xref:System.IO.IOException> </xref:System.Net.Sockets.NetworkStream> 如果你收到的<xref:System.IO.IOException>，请检查<xref:System.Exception.InnerException%2A>属性来确定如果它引起的一种<xref:System.Net.Sockets.SocketException>。</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException>"
  example:
  - "The following code example checks to see whether the <xref:System.Net.Sockets.NetworkStream> is writable. If it is, then Write is used to write a small message.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/visualbasic/87c395a5-03ea-4324-8b05-_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/cpp/87c395a5-03ea-4324-8b05-_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/csharp/87c395a5-03ea-4324-8b05-_1.cs)]"
  syntax:
    content: public override void Write (byte[] buffer, int offset, int size);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "类型的数组<xref:System.Byte>，其中包含要写入到的数据<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "中的位置`buffer`从中开始写入数据。"
    - id: size
      type: System.Int32
      description: "要写入的字节数<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。"
  overload: System.Net.Sockets.NetworkStream.Write*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> offset </code>参数小于 0。       -或- <code> offset </code>参数的长度大于<code> buffer </code>。       -或- <code> size </code>参数小于 0。       -或- <code> size </code>参数的长度大于<code> buffer </code>的值减去<code> offset </code>参数。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "向网络写入时失败。       -或者-访问套接字时出错。 请参阅备注部分以了解更多信息。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>已关闭。       -或者-从网络读取失败。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Writeable
  id: Writeable
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Writeable
  nameWithType: NetworkStream.Writeable
  fullName: System.Net.Sockets.NetworkStream.Writeable
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "获取一个值，该值指示是否<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>是可写。"
  remarks: "你必须从中派生<xref:System.Net.Sockets.NetworkStream>类使用的可写属性。</xref:System.Net.Sockets.NetworkStream> 如果 Writeable `true`，<xref:System.Net.Sockets.NetworkStream>允许调用<xref:System.Net.Sockets.NetworkStream.Write%2A>方法。</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> 您还可以确定是否<xref:System.Net.Sockets.NetworkStream>通过检查可公开访问可写<xref:System.Net.Sockets.NetworkStream.CanWrite%2A>属性。</xref:System.Net.Sockets.NetworkStream.CanWrite%2A> </xref:System.Net.Sockets.NetworkStream>       时设置的可写属性<xref:System.Net.Sockets.NetworkStream>初始化。</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "In the following code example, the `CanCommunicate` property checks the Writeable property to determine if the <xref:System.Net.Sockets.NetworkStream> is writable.  \n  \n [!code-cpp[NetworkStream_Protected_Members#1](~/add/codesnippet/cpp/p-system.net.sockets.net_5_1.cpp)]\n [!code-cs[NetworkStream_Protected_Members#1](~/add/codesnippet/csharp/p-system.net.sockets.net_5_1.cs)]\n [!code-vb[NetworkStream_Protected_Members#1](~/add/codesnippet/visualbasic/p-system.net.sockets.net_5_1.vb)]"
  syntax:
    content: protected bool Writeable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果数据可以写入该流，则否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Sockets.NetworkStream.Writeable*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.WriteTimeout
  id: WriteTimeout
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: WriteTimeout
  nameWithType: NetworkStream.WriteTimeout
  fullName: System.Net.Sockets.NetworkStream.WriteTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "获取或设置等待数据写入操作块的时间量。"
  remarks: "如果此属性指定的时间内未完成写入操作，该写入操作将引发一种<xref:System.IO.IOException>。</xref:System.IO.IOException>      1> [!NOTE]&1;> 此属性会影响仅同步写入操作通过调用执行<xref:System.Net.Sockets.NetworkStream.Write%2A>方法。</xref:System.Net.Sockets.NetworkStream.Write%2A> 此属性不会影响通过调用执行的异步写入<xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>方法。</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>"
  example:
  - "The following code example sets the write time-out for a network stream to 10 milliseconds.  \n  \n [!code-cpp[NCLTcpServerSync#0](~/add/codesnippet/cpp/p-system.net.sockets.net_1_1.cpp)]\n [!code-cs[NCLTcpServerSync#0](~/add/codesnippet/csharp/p-system.net.sockets.net_1_1.cs)]"
  syntax:
    content: public override int WriteTimeout { get; set; }
    return:
      type: System.Int32
      description: "A <xref:System.Int32>，它指定的时间，以毫秒为单位，写入操作失败之前将等待。</xref:System.Int32> 默认值， <xref:System.Threading.Timeout.Infinite>，指定写入操作不会超时。</xref:System.Threading.Timeout.Infinite>"
  overload: System.Net.Sockets.NetworkStream.WriteTimeout*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "指定的值是否小于或等于零且不是<xref:System.Threading.Timeout.Infinite>.</xref:System.Threading.Timeout.Infinite>"
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.Net.Sockets.SocketException
  isExternal: true
  name: System.Net.Sockets.SocketException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket)
  nameWithType: NetworkStream.NetworkStream(Socket)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket)
- uid: System.Net.Sockets.Socket
  parent: System.Net.Sockets
  isExternal: true
  name: Socket
  nameWithType: Socket
  fullName: System.Net.Sockets.Socket
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket,FileAccess)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket,FileAccess,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
- uid: System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.Net.Sockets.NetworkStream.CanRead
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanRead
  nameWithType: NetworkStream.CanRead
  fullName: System.Net.Sockets.NetworkStream.CanRead
- uid: System.Net.Sockets.NetworkStream.CanSeek
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanSeek
  nameWithType: NetworkStream.CanSeek
  fullName: System.Net.Sockets.NetworkStream.CanSeek
- uid: System.Net.Sockets.NetworkStream.CanTimeout
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanTimeout
  nameWithType: NetworkStream.CanTimeout
  fullName: System.Net.Sockets.NetworkStream.CanTimeout
- uid: System.Net.Sockets.NetworkStream.CanWrite
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanWrite
  nameWithType: NetworkStream.CanWrite
  fullName: System.Net.Sockets.NetworkStream.CanWrite
- uid: System.Net.Sockets.NetworkStream.Close(System.Int32)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Close(Int32)
  nameWithType: NetworkStream.Close(Int32)
  fullName: System.Net.Sockets.NetworkStream.Close(Int32)
- uid: System.Net.Sockets.NetworkStream.DataAvailable
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: DataAvailable
  nameWithType: NetworkStream.DataAvailable
  fullName: System.Net.Sockets.NetworkStream.DataAvailable
- uid: System.Net.Sockets.NetworkStream.Dispose(System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: NetworkStream.Dispose(Boolean)
  fullName: System.Net.Sockets.NetworkStream.Dispose(Boolean)
- uid: System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndRead(IAsyncResult)
  nameWithType: NetworkStream.EndRead(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndRead(IAsyncResult)
- uid: System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndWrite(IAsyncResult)
  nameWithType: NetworkStream.EndWrite(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndWrite(IAsyncResult)
- uid: System.Net.Sockets.NetworkStream.Finalize
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Finalize()
  nameWithType: NetworkStream.Finalize()
  fullName: System.Net.Sockets.NetworkStream.Finalize()
- uid: System.Net.Sockets.NetworkStream.Flush
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Flush()
  nameWithType: NetworkStream.Flush()
  fullName: System.Net.Sockets.NetworkStream.Flush()
- uid: System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: FlushAsync(CancellationToken)
  nameWithType: NetworkStream.FlushAsync(CancellationToken)
  fullName: System.Net.Sockets.NetworkStream.FlushAsync(CancellationToken)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.Net.Sockets.NetworkStream.Length
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Length
  nameWithType: NetworkStream.Length
  fullName: System.Net.Sockets.NetworkStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Net.Sockets.NetworkStream.Position
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Position
  nameWithType: NetworkStream.Position
  fullName: System.Net.Sockets.NetworkStream.Position
- uid: System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Read(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Read(Byte[],Int32,Int32)
- uid: System.Net.Sockets.NetworkStream.Readable
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Readable
  nameWithType: NetworkStream.Readable
  fullName: System.Net.Sockets.NetworkStream.Readable
- uid: System.Net.Sockets.NetworkStream.ReadTimeout
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: ReadTimeout
  nameWithType: NetworkStream.ReadTimeout
  fullName: System.Net.Sockets.NetworkStream.ReadTimeout
- uid: System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: NetworkStream.Seek(Int64,SeekOrigin)
  fullName: System.Net.Sockets.NetworkStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.Net.Sockets.NetworkStream.SetLength(System.Int64)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: NetworkStream.SetLength(Int64)
  fullName: System.Net.Sockets.NetworkStream.SetLength(Int64)
- uid: System.Net.Sockets.NetworkStream.Socket
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Socket
  nameWithType: NetworkStream.Socket
  fullName: System.Net.Sockets.NetworkStream.Socket
- uid: System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Write(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Write(Byte[],Int32,Int32)
- uid: System.Net.Sockets.NetworkStream.Writeable
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Writeable
  nameWithType: NetworkStream.Writeable
  fullName: System.Net.Sockets.NetworkStream.Writeable
- uid: System.Net.Sockets.NetworkStream.WriteTimeout
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: WriteTimeout
  nameWithType: NetworkStream.WriteTimeout
  fullName: System.Net.Sockets.NetworkStream.WriteTimeout
- uid: System.Net.Sockets.NetworkStream.#ctor*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream
  nameWithType: NetworkStream.NetworkStream
- uid: System.Net.Sockets.NetworkStream.BeginRead*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginRead
  nameWithType: NetworkStream.BeginRead
- uid: System.Net.Sockets.NetworkStream.BeginWrite*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginWrite
  nameWithType: NetworkStream.BeginWrite
- uid: System.Net.Sockets.NetworkStream.CanRead*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanRead
  nameWithType: NetworkStream.CanRead
- uid: System.Net.Sockets.NetworkStream.CanSeek*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanSeek
  nameWithType: NetworkStream.CanSeek
- uid: System.Net.Sockets.NetworkStream.CanTimeout*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanTimeout
  nameWithType: NetworkStream.CanTimeout
- uid: System.Net.Sockets.NetworkStream.CanWrite*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanWrite
  nameWithType: NetworkStream.CanWrite
- uid: System.Net.Sockets.NetworkStream.Close*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Close
  nameWithType: NetworkStream.Close
- uid: System.Net.Sockets.NetworkStream.DataAvailable*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: DataAvailable
  nameWithType: NetworkStream.DataAvailable
- uid: System.Net.Sockets.NetworkStream.Dispose*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Dispose
  nameWithType: NetworkStream.Dispose
- uid: System.Net.Sockets.NetworkStream.EndRead*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndRead
  nameWithType: NetworkStream.EndRead
- uid: System.Net.Sockets.NetworkStream.EndWrite*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndWrite
  nameWithType: NetworkStream.EndWrite
- uid: System.Net.Sockets.NetworkStream.Finalize*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Finalize
  nameWithType: NetworkStream.Finalize
- uid: System.Net.Sockets.NetworkStream.Flush*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Flush
  nameWithType: NetworkStream.Flush
- uid: System.Net.Sockets.NetworkStream.FlushAsync*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: FlushAsync
  nameWithType: NetworkStream.FlushAsync
- uid: System.Net.Sockets.NetworkStream.Length*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Length
  nameWithType: NetworkStream.Length
- uid: System.Net.Sockets.NetworkStream.Position*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Position
  nameWithType: NetworkStream.Position
- uid: System.Net.Sockets.NetworkStream.Read*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Read
  nameWithType: NetworkStream.Read
- uid: System.Net.Sockets.NetworkStream.Readable*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Readable
  nameWithType: NetworkStream.Readable
- uid: System.Net.Sockets.NetworkStream.ReadTimeout*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: ReadTimeout
  nameWithType: NetworkStream.ReadTimeout
- uid: System.Net.Sockets.NetworkStream.Seek*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Seek
  nameWithType: NetworkStream.Seek
- uid: System.Net.Sockets.NetworkStream.SetLength*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: SetLength
  nameWithType: NetworkStream.SetLength
- uid: System.Net.Sockets.NetworkStream.Socket*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Socket
  nameWithType: NetworkStream.Socket
- uid: System.Net.Sockets.NetworkStream.Write*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Write
  nameWithType: NetworkStream.Write
- uid: System.Net.Sockets.NetworkStream.Writeable*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Writeable
  nameWithType: NetworkStream.Writeable
- uid: System.Net.Sockets.NetworkStream.WriteTimeout*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: WriteTimeout
  nameWithType: NetworkStream.WriteTimeout
