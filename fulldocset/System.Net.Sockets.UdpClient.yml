### YamlMime:ManagedReference
items:
- uid: System.Net.Sockets.UdpClient
  id: UdpClient
  children:
  - System.Net.Sockets.UdpClient.#ctor
  - System.Net.Sockets.UdpClient.#ctor(System.Int32)
  - System.Net.Sockets.UdpClient.#ctor(System.Net.IPEndPoint)
  - System.Net.Sockets.UdpClient.#ctor(System.Net.Sockets.AddressFamily)
  - System.Net.Sockets.UdpClient.#ctor(System.Int32,System.Net.Sockets.AddressFamily)
  - System.Net.Sockets.UdpClient.#ctor(System.String,System.Int32)
  - System.Net.Sockets.UdpClient.Active
  - System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)
  - System.Net.Sockets.UdpClient.Available
  - System.Net.Sockets.UdpClient.BeginReceive(System.AsyncCallback,System.Object)
  - System.Net.Sockets.UdpClient.BeginSend(System.Byte[],System.Int32,System.AsyncCallback,System.Object)
  - System.Net.Sockets.UdpClient.BeginSend(System.Byte[],System.Int32,System.Net.IPEndPoint,System.AsyncCallback,System.Object)
  - System.Net.Sockets.UdpClient.BeginSend(System.Byte[],System.Int32,System.String,System.Int32,System.AsyncCallback,System.Object)
  - System.Net.Sockets.UdpClient.Client
  - System.Net.Sockets.UdpClient.Close
  - System.Net.Sockets.UdpClient.Connect(System.Net.IPEndPoint)
  - System.Net.Sockets.UdpClient.Connect(System.Net.IPAddress,System.Int32)
  - System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)
  - System.Net.Sockets.UdpClient.Dispose
  - System.Net.Sockets.UdpClient.Dispose(System.Boolean)
  - System.Net.Sockets.UdpClient.DontFragment
  - System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress)
  - System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress,System.Int32)
  - System.Net.Sockets.UdpClient.EnableBroadcast
  - System.Net.Sockets.UdpClient.EndReceive(System.IAsyncResult,System.Net.IPEndPoint@)
  - System.Net.Sockets.UdpClient.EndSend(System.IAsyncResult)
  - System.Net.Sockets.UdpClient.ExclusiveAddressUse
  - System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress)
  - System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Int32,System.Net.IPAddress)
  - System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress,System.Int32)
  - System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress,System.Net.IPAddress)
  - System.Net.Sockets.UdpClient.MulticastLoopback
  - System.Net.Sockets.UdpClient.Receive(System.Net.IPEndPoint@)
  - System.Net.Sockets.UdpClient.ReceiveAsync
  - System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32)
  - System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)
  - System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.String,System.Int32)
  - System.Net.Sockets.UdpClient.SendAsync(System.Byte[],System.Int32)
  - System.Net.Sockets.UdpClient.SendAsync(System.Byte[],System.Int32,System.Net.IPEndPoint)
  - System.Net.Sockets.UdpClient.SendAsync(System.Byte[],System.Int32,System.String,System.Int32)
  - System.Net.Sockets.UdpClient.Ttl
  langs:
  - csharp
  name: UdpClient
  nameWithType: UdpClient
  fullName: System.Net.Sockets.UdpClient
  type: Class
  summary: "提供用户数据报协议 (UDP) 网络服务。"
  remarks: "The UdpClient class provides simple methods for sending and receiving connectionless UDP datagrams in blocking synchronous mode. Because UDP is a connectionless transport protocol, you do not need to establish a remote host connection prior to sending and receiving data. You do, however, have the option of establishing a default remote host in one of the following two ways:  \n  \n-   Create an instance of the UdpClient class using the remote host name and port number as parameters.  \n  \n-   Create an instance of the UdpClient class and then call the <xref:System.Net.Sockets.UdpClient.Connect%2A> method.  \n  \n You can use any of the send methods provided in the UdpClient to send data to a remote device. Use the <xref:System.Net.Sockets.UdpClient.Receive%2A> method to receive data from remote hosts.  \n  \n> [!NOTE]\n>  Do not call [Send(Byte\\[\\], Int32, IPEndPoint)](assetId:///M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)?qualifyHint=False&autoUpgrade=True) using a host name or <xref:System.Net.IPEndPoint> if you have already specified a default remote host. If you do, UdpClient will throw an exception.  \n  \n UdpClient methods also allow you to send and receive multicast datagrams. Use the <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> method to subscribe a UdpClient to a multicast group. Use the <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A> method to unsubscribe a UdpClient from a multicast group."
  example:
  - "The following example establishes a UdpClient connection using the host name www.contoso.com on port 11000. A small string message is sent to two separate remote host machines. The <xref:System.Net.Sockets.UdpClient.Receive%2A> method blocks execution until a message is received. Using the <xref:System.Net.IPEndPoint> passed to <xref:System.Net.Sockets.UdpClient.Receive%2A>, the identity of the responding host is revealed.  \n  \n [!code-vb[Classic UdpClientExample#1](~/add/codesnippet/visualbasic/t-system.net.sockets.udp_1.vb)]\n [!code-cpp[Classic UdpClientExample#1](~/add/codesnippet/cpp/t-system.net.sockets.udp_1.cpp)]\n [!code-cs[Classic UdpClientExample#1](~/add/codesnippet/csharp/t-system.net.sockets.udp_1.cs)]"
  syntax:
    content: 'public class UdpClient : IDisposable'
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.#ctor
  id: '#ctor'
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: UdpClient()
  nameWithType: UdpClient.UdpClient()
  fullName: System.Net.Sockets.UdpClient.UdpClient()
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "初始化的新实例<xref href=&quot;System.Net.Sockets.UdpClient&quot;></xref>类。"
  remarks: "此构造函数创建一个新<xref:System.Net.Sockets.UdpClient>和允许基础服务提供程序分配的最合适的本地 IPv4 地址和端口号。</xref:System.Net.Sockets.UdpClient> 如果使用此构造函数，则<xref:System.Net.Sockets.UdpClient>实例设置不能更改或覆盖具有 IPv6 目标的连接方法调用的 IPv4 地址族。</xref:System.Net.Sockets.UdpClient>      1> [!NOTE]&1;> 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>以获得特定错误代码。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException> 一旦你已获得此代码，你可以引用的 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。       此构造函数不是适用于加入多播的组，因为它不执行套接字绑定。 此外，它仅适用于 IPv4 地址类型。"
  example:
  - "The following example demonstrates how to use the default constructor to create an instance of the <xref:System.Net.Sockets.UdpClient> class.  \n  \n [!code-cs[Classic UdpClient.PublicMethodsAndPropertiesExample#4](~/add/codesnippet/csharp/m-system.net.sockets.udp_11_1.cs)]\n [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#4](~/add/codesnippet/cpp/m-system.net.sockets.udp_11_1.cpp)]\n [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#4](~/add/codesnippet/visualbasic/m-system.net.sockets.udp_11_1.vb)]"
  syntax:
    content: public UdpClient ();
    parameters: []
  overload: System.Net.Sockets.UdpClient.#ctor*
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "访问套接字时出错。 请参阅备注部分以了解更多信息。"
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: UdpClient(Int32)
  nameWithType: UdpClient.UdpClient(Int32)
  fullName: System.Net.Sockets.UdpClient.UdpClient(Int32)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "初始化的新实例<xref href=&quot;System.Net.Sockets.UdpClient&quot;></xref>类并将其绑定到提供的本地端口号。"
  remarks: "此构造函数创建基础<xref:System.Net.Sockets.Socket>并将其绑定到你想要进行通信的端口号。</xref:System.Net.Sockets.Socket> 如果你只是想设置的本地端口号，请使用此构造函数。 基础服务提供程序将指定本地 IP 地址。 如果将 0 传递给构造函数时，基础服务提供程序将分配一个端口号。 如果使用此构造函数，则<xref:System.Net.Sockets.UdpClient>实例设置不能更改或覆盖具有 IPv6 目标的连接方法调用的 IPv4 地址族。</xref:System.Net.Sockets.UdpClient>      1> [!NOTE]&1;> 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>以获得特定错误代码。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException> 一旦你已获得此代码，你可以引用的 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。       此构造函数仅适用于 IPv4 地址类型。"
  example:
  - "The following example demonstrates using a local port number to create an instance of the <xref:System.Net.Sockets.UdpClient> class.  \n  \n [!code-cs[Classic UdpClient.PublicMethodsAndPropertiesExample#1](~/add/codesnippet/csharp/m-system.net.sockets.udp_4_1.cs)]\n [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#1](~/add/codesnippet/cpp/m-system.net.sockets.udp_4_1.cpp)]\n [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#1](~/add/codesnippet/visualbasic/m-system.net.sockets.udp_4_1.vb)]"
  syntax:
    content: public UdpClient (int port);
    parameters:
    - id: port
      type: System.Int32
      description: "你想要进行通信的本地端口号。"
  overload: System.Net.Sockets.UdpClient.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> port </code>参数值大于<xref:System.Net.IPEndPoint.MaxPort>或小于<xref:System.Net.IPEndPoint.MinPort>.</xref:System.Net.IPEndPoint.MinPort> </xref:System.Net.IPEndPoint.MaxPort>"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "访问套接字时出错。 请参阅备注部分以了解更多信息。"
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.#ctor(System.Net.IPEndPoint)
  id: '#ctor(System.Net.IPEndPoint)'
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: UdpClient(IPEndPoint)
  nameWithType: UdpClient.UdpClient(IPEndPoint)
  fullName: System.Net.Sockets.UdpClient.UdpClient(IPEndPoint)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "初始化的新实例<xref href=&quot;System.Net.Sockets.UdpClient&quot;></xref>类并将其绑定到指定的本地终结点。"
  remarks: "此构造函数创建一个新<xref:System.Net.Sockets.UdpClient>和将其绑定到<xref:System.Net.IPEndPoint>指定的`localEP`参数。</xref:System.Net.IPEndPoint> </xref:System.Net.Sockets.UdpClient> 在调用此构造函数之前，必须创建<xref:System.Net.IPEndPoint>使用你想要发送和接收数据的 IP 地址和端口号。</xref:System.Net.IPEndPoint> 不需要指定用于发送和接收数据的本地 IP 地址和端口号。 如果不这样做，则基础服务提供程序将分配的最合适的本地 IP 地址和端口号。       如果使用此构造函数，则<xref:System.Net.Sockets.UdpClient>实例设置与指定的地址族`localEP`不能更改或覆盖具有不同的地址族的连接方法调用的参数。</xref:System.Net.Sockets.UdpClient>      1> [!NOTE]&1;> 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>以获得特定错误代码。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException> 一旦你已获得此代码，你可以引用的 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。"
  example:
  - "The following example demonstrates how to create an instance of the <xref:System.Net.Sockets.UdpClient> class using a local endpoint.  \n  \n [!code-cs[Classic UdpClient.PublicMethodsAndPropertiesExample#2](~/add/codesnippet/csharp/m-system.net.sockets.udp_9_1.cs)]\n [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#2](~/add/codesnippet/cpp/m-system.net.sockets.udp_9_1.cpp)]\n [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#2](~/add/codesnippet/visualbasic/m-system.net.sockets.udp_9_1.vb)]"
  syntax:
    content: public UdpClient (System.Net.IPEndPoint localEP);
    parameters:
    - id: localEP
      type: System.Net.IPEndPoint
      description: "<xref:System.Net.IPEndPoint>表示你要向其绑定 UDP 连接的本地终结点。</xref:System.Net.IPEndPoint>"
  overload: System.Net.Sockets.UdpClient.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>localEP</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "访问套接字时出错。 请参阅备注部分以了解更多信息。"
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.#ctor(System.Net.Sockets.AddressFamily)
  id: '#ctor(System.Net.Sockets.AddressFamily)'
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: UdpClient(AddressFamily)
  nameWithType: UdpClient.UdpClient(AddressFamily)
  fullName: System.Net.Sockets.UdpClient.UdpClient(AddressFamily)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "初始化的新实例<xref href=&quot;System.Net.Sockets.UdpClient&quot;></xref>类。"
  remarks: "`family`参数确定侦听器使用的 IP 版本 4 地址 (IPv4) 或 IP 版本 6 (IPv6) 地址。 若要使用的 IPv4 地址，将传递<xref:System.Net.Sockets.AddressFamily>值。</xref:System.Net.Sockets.AddressFamily> 若要使用 IPv6 地址，将传递<xref:System.Net.Sockets.AddressFamily>值。</xref:System.Net.Sockets.AddressFamily> 传递任何其他值会导致引发<xref:System.ArgumentException>.</xref:System.ArgumentException>方法       如果使用此构造函数，则<xref:System.Net.Sockets.UdpClient>实例设置与指定的地址族`family`不能更改或覆盖具有不同的地址族的连接方法调用的参数。</xref:System.Net.Sockets.UdpClient>      1> [!NOTE]&1;> 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>以获得特定错误代码。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException> 一旦你已获得此代码，你可以引用的 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。       UdpClient 不适用于加入多播的组，因为它不执行套接字绑定。"
  syntax:
    content: public UdpClient (System.Net.Sockets.AddressFamily family);
    parameters:
    - id: family
      type: System.Net.Sockets.AddressFamily
      description: "之一<xref:System.Net.Sockets.AddressFamily>指定套接字的寻址方案的值。</xref:System.Net.Sockets.AddressFamily>"
  overload: System.Net.Sockets.UdpClient.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>family</code>is not <xref:System.Net.Sockets.AddressFamily> or <xref:System.Net.Sockets.AddressFamily>."
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "访问套接字时出错。 请参阅备注部分以了解更多信息。"
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.#ctor(System.Int32,System.Net.Sockets.AddressFamily)
  id: '#ctor(System.Int32,System.Net.Sockets.AddressFamily)'
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: UdpClient(Int32,AddressFamily)
  nameWithType: UdpClient.UdpClient(Int32,AddressFamily)
  fullName: System.Net.Sockets.UdpClient.UdpClient(Int32,AddressFamily)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "初始化的新实例<xref href=&quot;System.Net.Sockets.UdpClient&quot;></xref>类并将其绑定到提供的本地端口号。"
  remarks: "此构造函数创建基础<xref:System.Net.Sockets.Socket>并将其绑定到你想要进行通信的端口号。</xref:System.Net.Sockets.Socket>       `family`参数确定侦听器使用的 IP 版本 4 地址 (IPv4) 或 IP 版本 6 (IPv6) 地址。 若要使用的 IPv4 地址，将传递<xref:System.Net.Sockets.AddressFamily>值。</xref:System.Net.Sockets.AddressFamily> 若要使用 IPv6 地址，将传递<xref:System.Net.Sockets.AddressFamily>值。</xref:System.Net.Sockets.AddressFamily> 传递任何其他值会导致引发<xref:System.ArgumentException>.</xref:System.ArgumentException>方法       如果使用此构造函数，则<xref:System.Net.Sockets.UdpClient>实例设置与指定的地址族`family`不能更改或覆盖具有不同的地址族的连接方法调用的参数。</xref:System.Net.Sockets.UdpClient>      1> [!NOTE]&1;> 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>以获得特定错误代码。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException> 一旦你已获得此代码，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。"
  example:
  - "The following code example shows how to create a UDP client to use in a multicast group.  \n  \n [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#3](~/add/codesnippet/cpp/c2c91fdb-fd73-47cc-8239-_1.cpp)]\n [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#3](~/add/codesnippet/visualbasic/c2c91fdb-fd73-47cc-8239-_1.vb)]\n [!code-cs[System.Net.Sockets.UdpClient.JoinMulticastGroup#3](~/add/codesnippet/csharp/c2c91fdb-fd73-47cc-8239-_1.cs)]"
  syntax:
    content: public UdpClient (int port, System.Net.Sockets.AddressFamily family);
    parameters:
    - id: port
      type: System.Int32
      description: "要传入的连接尝试的侦听端口。"
    - id: family
      type: System.Net.Sockets.AddressFamily
      description: "之一<xref:System.Net.Sockets.AddressFamily>指定套接字的寻址方案的值。</xref:System.Net.Sockets.AddressFamily>"
  overload: System.Net.Sockets.UdpClient.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>family</code>is not <xref:System.Net.Sockets.AddressFamily> or <xref:System.Net.Sockets.AddressFamily>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>port</code>大于<xref:System.Net.IPEndPoint.MaxPort>或小于<xref:System.Net.IPEndPoint.MinPort>。"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "访问套接字时出错。 请参阅备注部分以了解更多信息。"
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.#ctor(System.String,System.Int32)
  id: '#ctor(System.String,System.Int32)'
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: UdpClient(String,Int32)
  nameWithType: UdpClient.UdpClient(String,Int32)
  fullName: System.Net.Sockets.UdpClient.UdpClient(String,Int32)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "初始化的新实例<xref href=&quot;System.Net.Sockets.UdpClient&quot;></xref>类，并建立默认远程主机。"
  remarks: "此构造函数初始化新<xref:System.Net.Sockets.UdpClient>并建立远程主机使用`hostname`和`port`参数。</xref:System.Net.Sockets.UdpClient> 建立默认远程主机的操作是可选的。 如果你使用此构造函数，无需在每次调用中指定远程主机<xref:System.Net.Sockets.UdpClient.Send%2A>方法。</xref:System.Net.Sockets.UdpClient.Send%2A> 指定默认远程主机限制只能访问该主机。 可以通过调用在任何时候更改默认远程主机<xref:System.Net.Sockets.UdpClient.Connect%2A>方法。</xref:System.Net.Sockets.UdpClient.Connect%2A> 如果你想要调用中指定的远程主机<xref:System.Net.Sockets.UdpClient.Send%2A>方法，不使用此构造函数。</xref:System.Net.Sockets.UdpClient.Send%2A>      1> [!NOTE]&1;> 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>以获得特定错误代码。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException> 一旦你已获得此代码，你可以引用的 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。"
  example:
  - "The following example demonstrates how to create an instance of the <xref:System.Net.Sockets.UdpClient> class using a host name and port number.  \n  \n [!code-cs[Classic UdpClient.PublicMethodsAndPropertiesExample#3](~/add/codesnippet/csharp/m-system.net.sockets.udp_7_1.cs)]\n [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#3](~/add/codesnippet/cpp/m-system.net.sockets.udp_7_1.cpp)]\n [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#3](~/add/codesnippet/visualbasic/m-system.net.sockets.udp_7_1.vb)]"
  syntax:
    content: public UdpClient (string hostname, int port);
    parameters:
    - id: hostname
      type: System.String
      description: "你想要连接的远程 DNS 主机名称。"
    - id: port
      type: System.Int32
      description: "你想要连接到远程端口号。"
  overload: System.Net.Sockets.UdpClient.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>hostname</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>port</code>不介于<xref:System.Net.IPEndPoint.MinPort>和<xref:System.Net.IPEndPoint.MaxPort>。"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "访问套接字时出错。 请参阅备注部分以了解更多信息。"
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.Active
  id: Active
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: Active
  nameWithType: UdpClient.Active
  fullName: System.Net.Sockets.UdpClient.Active
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "获取或设置一个值，该值指示是否已建立默认远程主机。"
  remarks: "类派生自<xref:System.Net.Sockets.UdpClient>可以使用此属性以确定是否已建立默认远程主机。</xref:System.Net.Sockets.UdpClient> 你可以通过使用适当的构造函数或通过调用建立默认远程主机<xref:System.Net.Sockets.UdpClient.Connect%2A>方法。</xref:System.Net.Sockets.UdpClient.Connect%2A> 如果执行建立默认远程主机，则无法<xref:System.Net.Sockets.UdpClient.Send%2A>.</xref:System.Net.Sockets.UdpClient.Send%2A>调用中指定远程主机"
  syntax:
    content: protected bool Active { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果连接处于活动状态;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Sockets.UdpClient.Active*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)
  id: AllowNatTraversal(System.Boolean)
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: AllowNatTraversal(Boolean)
  nameWithType: UdpClient.AllowNatTraversal(Boolean)
  fullName: System.Net.Sockets.UdpClient.AllowNatTraversal(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "启用或禁用在网络地址转换 (NAT) 遍历<xref href=&quot;System.Net.Sockets.UdpClient&quot;></xref>实例。"
  remarks: "AllowNatTraversal 方法用于启用或禁用的 NAT 遍历<xref:System.Net.Sockets.UdpClient>实例。</xref:System.Net.Sockets.UdpClient> 可能使用 Teredo、 6to4 或 ISATAP 隧道提供 NAT 遍历。       当`allowed`参数为 false，<xref:System.Net.Sockets.SocketOptionName>关联的套接字上的选项设置为<xref:System.Net.Sockets.IPProtectionLevel>。</xref:System.Net.Sockets.IPProtectionLevel> </xref:System.Net.Sockets.SocketOptionName> 这将显式禁止 NAT 遍历<xref:System.Net.Sockets.UdpClient>实例。</xref:System.Net.Sockets.UdpClient>       当`allowed`参数为 true，<xref:System.Net.Sockets.SocketOptionName>关联的套接字上的选项设置为<xref:System.Net.Sockets.IPProtectionLevel>。</xref:System.Net.Sockets.IPProtectionLevel> </xref:System.Net.Sockets.SocketOptionName> 这可能使 NAT 遍历<xref:System.Net.Sockets.UdpClient>具体取决于系统上实施防火墙规则。</xref:System.Net.Sockets.UdpClient>       Teredo 地址是 IPv6 地址的前缀为 2001年:: / 32。 Teredo 地址可以返回通过正常的 DNS 名称解析或枚举为分配给了本地接口的 IPv6 地址。"
  syntax:
    content: public void AllowNatTraversal (bool allowed);
    parameters:
    - id: allowed
      type: System.Boolean
      description: "一个布尔值，指定是否启用或禁用 NAT 遍历。"
  overload: System.Net.Sockets.UdpClient.AllowNatTraversal*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.Available
  id: Available
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: Available
  nameWithType: UdpClient.Available
  fullName: System.Net.Sockets.UdpClient.Available
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "获取从可读取网络接收的数据量。"
  remarks: "可用的属性用于确定在读取的网络缓冲区中排队的数据量。 如果数据不可用，调用<xref:System.Net.Sockets.NetworkStream.Read%2A>获取数据。</xref:System.Net.Sockets.NetworkStream.Read%2A> 如果可用的任何数据不，可用的属性将返回 0。       如果远程主机关闭，或关闭了连接，可用的属性将引发一种<xref:System.Net.Sockets.SocketException>。</xref:System.Net.Sockets.SocketException>      1> [!NOTE] 1> 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>在 MSDN 库中的 Windows 套接字版本 2 API 错误代码文档为要获取特定的错误代码和参考[http://msdn.microsoft.com/library](http://msdn.microsoft.com/library)/ 有关错误的详细说明。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException>"
  example:
  - "The following code example shows the use of the Available property.  \n  \n [!code-cs[System.Net.Sockets.UdpClient#1](~/add/codesnippet/csharp/p-system.net.sockets.udp_1_1.cs)]\n [!code-cpp[System.Net.Sockets.UdpClient#1](~/add/codesnippet/cpp/p-system.net.sockets.udp_1_1.cpp)]"
  syntax:
    content: public int Available { get; }
    return:
      type: System.Int32
      description: "从网络接收的数据的字节数。"
  overload: System.Net.Sockets.UdpClient.Available*
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "尝试访问套接字时出错。 请参阅备注部分以了解更多信息。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref:System.Net.Sockets.Socket>已关闭。</xref:System.Net.Sockets.Socket>"
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.BeginReceive(System.AsyncCallback,System.Object)
  id: BeginReceive(System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: BeginReceive(AsyncCallback,Object)
  nameWithType: UdpClient.BeginReceive(AsyncCallback,Object)
  fullName: System.Net.Sockets.UdpClient.BeginReceive(AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "从远程主机异步接收数据报。"
  remarks: "必须通过调用完成异步 BeginReceive 操作<xref:System.Net.Sockets.UdpClient.EndReceive%2A>方法。</xref:System.Net.Sockets.UdpClient.EndReceive%2A> 通常情况下，通过调用该方法`requestCallback`委托。       此方法不会阻止，直到完成该操作。 若要阻止该操作完成之前，请使用<xref:System.Net.Sockets.UdpClient.Receive%2A>方法。</xref:System.Net.Sockets.UdpClient.Receive%2A>       有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example uses BeginReceive to asynchronously receive a server response.  \n  \n [!code-cpp[System.Net.Sockets.UdpClient1#1](~/add/codesnippet/cpp/m-system.net.sockets.udp_12_1.cpp)]\n [!code-cs[System.Net.Sockets.UdpClient1#1](~/add/codesnippet/csharp/m-system.net.sockets.udp_12_1.cs)]"
  syntax:
    content: public IAsyncResult BeginReceive (AsyncCallback requestCallback, object state);
    parameters:
    - id: requestCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>引用操作完成时要调用的方法的委托。</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "用户定义的对象，其中包含有关接收操作的信息。 此对象传递给`requestCallback`时，才完成操作的委托。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>引用异步接收的对象。</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.UdpClient.BeginReceive*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.BeginSend(System.Byte[],System.Int32,System.AsyncCallback,System.Object)
  id: BeginSend(System.Byte[],System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: BeginSend(Byte[],Int32,AsyncCallback,Object)
  nameWithType: UdpClient.BeginSend(Byte[],Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.UdpClient.BeginSend(Byte[],Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "以异步方式将数据报发送到远程主机。 通过调用<xref:System.Net.Sockets.UdpClient.Connect*>.</xref:System.Net.Sockets.UdpClient.Connect*>之前指定目标"
  remarks: "必须通过调用完成异步 BeginSend 操作<xref:System.Net.Sockets.UdpClient.EndSend%2A>方法。</xref:System.Net.Sockets.UdpClient.EndSend%2A> 通常情况下，通过调用该方法`requestCallback`委托。       此方法不会阻止该操作完成之前。 若要阻止该操作完成之前，请使用之一<xref:System.Net.Sockets.UdpClient.Send%2A>方法重载。</xref:System.Net.Sockets.UdpClient.Send%2A>       有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example uses BeginSend to asynchronously send a server request.  \n  \n [!code-cpp[System.Net.Sockets.UdpClient1#2](~/add/codesnippet/cpp/8a1303c1-e75f-4620-9cd1-_1.cpp)]\n [!code-cs[System.Net.Sockets.UdpClient1#2](~/add/codesnippet/csharp/8a1303c1-e75f-4620-9cd1-_1.cs)]  \n  \n [!code-cpp[System.Net.Sockets.UdpClient1#3](~/add/codesnippet/cpp/8a1303c1-e75f-4620-9cd1-_2.cpp)]\n [!code-cs[System.Net.Sockets.UdpClient1#3](~/add/codesnippet/csharp/8a1303c1-e75f-4620-9cd1-_2.cs)]"
  syntax:
    content: public IAsyncResult BeginSend (byte[] datagram, int bytes, AsyncCallback requestCallback, object state);
    parameters:
    - id: datagram
      type: System.Byte[]
      description: "A<xref:System.Byte>数组，其中包含要发送的数据。</xref:System.Byte>"
    - id: bytes
      type: System.Int32
      description: "要发送的字节数。"
    - id: requestCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>引用操作完成时要调用的方法的委托。</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "用户定义的对象，其中包含有关发送操作的信息。 此对象传递给`requestCallback`时，才完成操作的委托。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>对象，它引用异步发送。</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.UdpClient.BeginSend*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.BeginSend(System.Byte[],System.Int32,System.Net.IPEndPoint,System.AsyncCallback,System.Object)
  id: BeginSend(System.Byte[],System.Int32,System.Net.IPEndPoint,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: BeginSend(Byte[],Int32,IPEndPoint,AsyncCallback,Object)
  nameWithType: UdpClient.BeginSend(Byte[],Int32,IPEndPoint,AsyncCallback,Object)
  fullName: System.Net.Sockets.UdpClient.BeginSend(Byte[],Int32,IPEndPoint,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "以异步方式将数据报发送到目标。 目标被指定的一种<xref:System.Net.EndPoint>。</xref:System.Net.EndPoint>"
  remarks: "必须通过调用完成异步 BeginSend 操作<xref:System.Net.Sockets.UdpClient.EndSend%2A>方法。</xref:System.Net.Sockets.UdpClient.EndSend%2A> 通常情况下，通过调用该方法`requestCallback`委托。       此方法不会阻止，直到完成该操作。 若要阻止该操作完成之前，请使用之一<xref:System.Net.Sockets.UdpClient.Send%2A>方法重载。</xref:System.Net.Sockets.UdpClient.Send%2A>       有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example uses <xref:System.Net.Sockets.UdpClient.BeginSend%2A> to asynchronously send a server request.  \n  \n [!code-cpp[System.Net.Sockets.UdpClient1#2](~/add/codesnippet/cpp/baa8f51b-e44a-4d9b-997b-_1.cpp)]\n [!code-cs[System.Net.Sockets.UdpClient1#2](~/add/codesnippet/csharp/baa8f51b-e44a-4d9b-997b-_1.cs)]  \n  \n [!code-cpp[System.Net.Sockets.UdpClient1#4](~/add/codesnippet/cpp/baa8f51b-e44a-4d9b-997b-_2.cpp)]\n [!code-cs[System.Net.Sockets.UdpClient1#4](~/add/codesnippet/csharp/baa8f51b-e44a-4d9b-997b-_2.cs)]"
  syntax:
    content: public IAsyncResult BeginSend (byte[] datagram, int bytes, System.Net.IPEndPoint endPoint, AsyncCallback requestCallback, object state);
    parameters:
    - id: datagram
      type: System.Byte[]
      description: "A<xref:System.Byte>数组，其中包含要发送的数据。</xref:System.Byte>"
    - id: bytes
      type: System.Int32
      description: "要发送的字节数。"
    - id: endPoint
      type: System.Net.IPEndPoint
      description: "<xref:System.Net.EndPoint>表示数据的目标。</xref:System.Net.EndPoint>"
    - id: requestCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>引用操作完成时要调用的方法的委托。</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "用户定义的对象，其中包含有关发送操作的信息。 此对象传递给`requestCallback`时，才完成操作的委托。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>对象，它引用异步发送。</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.UdpClient.BeginSend*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.BeginSend(System.Byte[],System.Int32,System.String,System.Int32,System.AsyncCallback,System.Object)
  id: BeginSend(System.Byte[],System.Int32,System.String,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: BeginSend(Byte[],Int32,String,Int32,AsyncCallback,Object)
  nameWithType: UdpClient.BeginSend(Byte[],Int32,String,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.UdpClient.BeginSend(Byte[],Int32,String,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "以异步方式将数据报发送到目标。 目标指定按主机名和端口号。"
  remarks: "必须通过调用完成异步 BeginSend 操作<xref:System.Net.Sockets.UdpClient.EndSend%2A>方法。</xref:System.Net.Sockets.UdpClient.EndSend%2A> 通常情况下，通过调用该方法`requestCallback`委托。       此方法不会阻止，直到完成该操作。 若要阻止该操作完成之前，请使用之一<xref:System.Net.Sockets.UdpClient.Send%2A>方法重载。</xref:System.Net.Sockets.UdpClient.Send%2A>       有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example uses <xref:System.Net.Sockets.UdpClient.BeginSend%2A> to asynchronously send a server request.  \n  \n [!code-cpp[System.Net.Sockets.UdpClient1#2](~/add/codesnippet/cpp/b00a89c3-67f5-4a47-8f24-_1.cpp)]\n [!code-cs[System.Net.Sockets.UdpClient1#2](~/add/codesnippet/csharp/b00a89c3-67f5-4a47-8f24-_1.cs)]  \n  \n [!code-cpp[System.Net.Sockets.UdpClient1#5](~/add/codesnippet/cpp/b00a89c3-67f5-4a47-8f24-_2.cpp)]\n [!code-cs[System.Net.Sockets.UdpClient1#5](~/add/codesnippet/csharp/b00a89c3-67f5-4a47-8f24-_2.cs)]"
  syntax:
    content: public IAsyncResult BeginSend (byte[] datagram, int bytes, string hostname, int port, AsyncCallback requestCallback, object state);
    parameters:
    - id: datagram
      type: System.Byte[]
      description: "A<xref:System.Byte>数组，其中包含要发送的数据。</xref:System.Byte>"
    - id: bytes
      type: System.Int32
      description: "要发送的字节数。"
    - id: hostname
      type: System.String
      description: "目标主机中。"
    - id: port
      type: System.Int32
      description: "目标端口号。"
    - id: requestCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>引用操作完成时要调用的方法的委托。</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "用户定义的对象，其中包含有关发送操作的信息。 此对象传递给`requestCallback`时，才完成操作的委托。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>对象，它引用异步发送。</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.UdpClient.BeginSend*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.Client
  id: Client
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: Client
  nameWithType: UdpClient.Client
  fullName: System.Net.Sockets.UdpClient.Client
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "获取或设置基础网络<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.UdpClient>创建<xref:System.Net.Sockets.Socket>用于发送和接收数据通过网络。</xref:System.Net.Sockets.Socket></xref:System.Net.Sockets.UdpClient> <xref:System.Net.Sockets.UdpClient>可以使用此属性来获取或设置此<xref:System.Net.Sockets.Socket>。</xref:System.Net.Sockets.Socket></xref:System.Net.Sockets.UdpClient>从派生的类 使用基础<xref:System.Net.Sockets.Socket>返回从客户端，如果你要求在超出其<xref:System.Net.Sockets.UdpClient>提供。</xref:System.Net.Sockets.UdpClient> </xref:System.Net.Sockets.Socket> 你还可以使用客户端设置基础<xref:System.Net.Sockets.Socket>到现有的<xref:System.Net.Sockets.Socket>。</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket> 如果你想要利用使用<xref:System.Net.Sockets.UdpClient>预先存在的<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket></xref:System.Net.Sockets.UdpClient>的简单性这很有用"
  example:
  - "The following example demonstrates the use of the Client property. In this example, broadcasting is enabled for the underlying <xref:System.Net.Sockets.Socket>.  \n  \n [!code-cs[Classic UdpClient.ProtectedMethodsAndPropertiesExample#1](~/add/codesnippet/csharp/p-system.net.sockets.udp_0_1.cs)]\n [!code-cpp[Classic UdpClient.ProtectedMethodsAndPropertiesExample#1](~/add/codesnippet/cpp/p-system.net.sockets.udp_0_1.cpp)]\n [!code-vb[Classic UdpClient.ProtectedMethodsAndPropertiesExample#1](~/add/codesnippet/visualbasic/p-system.net.sockets.udp_0_1.vb)]"
  syntax:
    content: public System.Net.Sockets.Socket Client { get; set; }
    return:
      type: System.Net.Sockets.Socket
      description: "基础网络<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.UdpClient.Client*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.Close
  id: Close
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: Close()
  nameWithType: UdpClient.Close()
  fullName: System.Net.Sockets.UdpClient.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "关闭 UDP 连接。"
  remarks: "关闭禁用基础<xref:System.Net.Sockets.Socket>并释放与<xref:System.Net.Sockets.UdpClient>.</xref:System.Net.Sockets.UdpClient>关联的所有托管和非托管资源</xref:System.Net.Sockets.Socket>      1> [!NOTE]&1;> 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>以获得特定错误代码。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException> 一旦你已获得此代码，你可以引用的 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。"
  example:
  - "The following example demonstrates closing a <xref:System.Net.Sockets.UdpClient> by calling the Close method.  \n  \n [!code-cs[Classic UdpClient.PublicMethodsAndPropertiesExample#15](~/add/codesnippet/csharp/m-system.net.sockets.udp_10_1.cs)]\n [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#15](~/add/codesnippet/cpp/m-system.net.sockets.udp_10_1.cpp)]\n [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#15](~/add/codesnippet/visualbasic/m-system.net.sockets.udp_10_1.vb)]"
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Net.Sockets.UdpClient.Close*
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "访问套接字时出错。 请参阅备注部分以了解更多信息。"
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.Connect(System.Net.IPEndPoint)
  id: Connect(System.Net.IPEndPoint)
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: Connect(IPEndPoint)
  nameWithType: UdpClient.Connect(IPEndPoint)
  fullName: System.Net.Sockets.UdpClient.Connect(IPEndPoint)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "建立默认远程主机使用指定的网络终结点。"
  remarks: "<xref:System.Net.Sockets.UdpClient.Connect%2A>方法建立默认远程主机使用中指定的值`endPoint`参数。</xref:System.Net.Sockets.UdpClient.Connect%2A> 一旦建立，则不需要在每次调用中指定远程主机<xref:System.Net.Sockets.UdpClient.Send%2A>方法。</xref:System.Net.Sockets.UdpClient.Send%2A>       建立默认远程主机的操作是可选的。 指定默认远程主机限制只能访问该主机。 如果你想要将数据报发送到不同的远程主机，必须进行另一个调用<xref:System.Net.Sockets.UdpClient.Connect%2A>方法或创建另一个<xref:System.Net.Sockets.UdpClient>而无需默认远程主机。</xref:System.Net.Sockets.UdpClient> </xref:System.Net.Sockets.UdpClient.Connect%2A> 如果你已经建立默认远程主机和你还提供了一台远程主机的<xref:System.Net.Sockets.UdpClient.Send%2A>方法，则<xref:System.Net.Sockets.UdpClient.Send%2A>将引发一种<xref:System.Net.Sockets.SocketException>。</xref:System.Net.Sockets.SocketException></xref:System.Net.Sockets.UdpClient.Send%2A></xref:System.Net.Sockets.UdpClient.Send%2A>调用中 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>以获得特定错误代码。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException> 一旦你已获得此代码，你可以引用的 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。       如果调用<xref:System.Net.Sockets.Socket.Connect%2A>方法，而非将放弃指定的默认到达发件人地址的任何数据报。</xref:System.Net.Sockets.Socket.Connect%2A> 不能设置为使用此方法，除非从继承广播地址的默认远程主机<xref:System.Net.Sockets.UdpClient>，客户端方法用于获取基础<xref:System.Net.Sockets.Socket>，并将设置到<xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>。</xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>的套接字选项</xref:System.Net.Sockets.Socket></xref:System.Net.Sockets.UdpClient>       但是可以、 为默认值的广播的数据广播地址，255.255.255.255，如果你指定<xref:System.Net.IPAddress.Broadcast?displayProperty=fullName>调用中<xref:System.Net.Sockets.UdpClient.Send%2A>方法。</xref:System.Net.Sockets.UdpClient.Send%2A> </xref:System.Net.IPAddress.Broadcast?displayProperty=fullName> 如果你的应用程序需要更好地控制广播地址，你可以还原到使用<xref:System.Net.Sockets.Socket>类。</xref:System.Net.Sockets.Socket>      1> [!NOTE]&1;> 由于 UDP 协议是无，<xref:System.Net.Sockets.UdpClient.Connect%2A>方法不会阻止。</xref:System.Net.Sockets.UdpClient.Connect%2A> 不要调用<xref:System.Net.Sockets.UdpClient.Connect%2A>方法如果你想要接收多路广播数据报。</xref:System.Net.Sockets.UdpClient.Connect%2A>"
  example:
  - "The following example uses an <xref:System.Net.IPEndPoint> to establish a default remote host.  \n  \n [!code-cs[Classic UdpClient.PublicMethodsAndPropertiesExample#7](~/add/codesnippet/csharp/m-system.net.sockets.udp_1_1.cs)]\n [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#7](~/add/codesnippet/cpp/m-system.net.sockets.udp_1_1.cpp)]\n [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#7](~/add/codesnippet/visualbasic/m-system.net.sockets.udp_1_1.vb)]"
  syntax:
    content: public void Connect (System.Net.IPEndPoint endPoint);
    parameters:
    - id: endPoint
      type: System.Net.IPEndPoint
      description: "<xref:System.Net.IPEndPoint>，指定你想要将数据发送到的网络终结点。</xref:System.Net.IPEndPoint>"
  overload: System.Net.Sockets.UdpClient.Connect*
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "访问套接字时出错。 请参阅备注部分以了解更多信息。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>endPoint</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.UdpClient&quot;> </xref>已关闭。"
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.Connect(System.Net.IPAddress,System.Int32)
  id: Connect(System.Net.IPAddress,System.Int32)
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: Connect(IPAddress,Int32)
  nameWithType: UdpClient.Connect(IPAddress,Int32)
  fullName: System.Net.Sockets.UdpClient.Connect(IPAddress,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "建立默认远程主机使用指定的 IP 地址和端口号。"
  remarks: "<xref:System.Net.Sockets.UdpClient.Connect%2A>方法建立默认远程主机使用中指定的值`addr`和`port`参数。</xref:System.Net.Sockets.UdpClient.Connect%2A> 一旦建立，则不需要在每次调用中指定远程主机<xref:System.Net.Sockets.UdpClient.Send%2A>方法。</xref:System.Net.Sockets.UdpClient.Send%2A>       建立默认远程主机的操作是可选的。 指定默认远程主机限制只能访问该主机。 如果你想要将数据报发送到不同的远程主机，必须进行另一个调用<xref:System.Net.Sockets.UdpClient.Connect%2A>方法或创建另一个<xref:System.Net.Sockets.UdpClient>而无需默认远程主机。</xref:System.Net.Sockets.UdpClient> </xref:System.Net.Sockets.UdpClient.Connect%2A> 如果你已经建立默认远程主机和你还提供了一台远程主机的<xref:System.Net.Sockets.UdpClient.Send%2A>方法，则<xref:System.Net.Sockets.UdpClient.Send%2A>将引发一种<xref:System.Net.Sockets.SocketException>。</xref:System.Net.Sockets.SocketException></xref:System.Net.Sockets.UdpClient.Send%2A></xref:System.Net.Sockets.UdpClient.Send%2A>调用中 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>以获得特定错误代码。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException> 一旦你已获得此代码，你可以引用的 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。       如果调用<xref:System.Net.Sockets.Socket.Connect%2A>方法，而非将放弃指定的默认到达发件人地址的任何数据报。</xref:System.Net.Sockets.Socket.Connect%2A> 不能设置为使用此方法，除非从继承广播地址的默认远程主机<xref:System.Net.Sockets.UdpClient>，客户端方法用于获取基础<xref:System.Net.Sockets.Socket>，并将设置到<xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>。</xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>的套接字选项</xref:System.Net.Sockets.Socket></xref:System.Net.Sockets.UdpClient>       但是可以、 为默认值的广播的数据广播地址，255.255.255.255，如果你指定<xref:System.Net.IPAddress.Broadcast?displayProperty=fullName>调用中<xref:System.Net.Sockets.UdpClient.Send%2A>方法。</xref:System.Net.Sockets.UdpClient.Send%2A> </xref:System.Net.IPAddress.Broadcast?displayProperty=fullName> 如果你的应用程序需要更好地控制广播地址，你可以还原到使用<xref:System.Net.Sockets.Socket>类。</xref:System.Net.Sockets.Socket>      1> [!NOTE]&1;> 由于 UDP 协议是无，<xref:System.Net.Sockets.UdpClient.Connect%2A>方法不会阻止。</xref:System.Net.Sockets.UdpClient.Connect%2A> 不要调用<xref:System.Net.Sockets.UdpClient.Connect%2A>方法如果你想要接收多路广播数据报。</xref:System.Net.Sockets.UdpClient.Connect%2A>"
  example:
  - "The following example uses an IP address and port number to connect with a remote host.  \n  \n [!code-cs[Classic UdpClient.PublicMethodsAndPropertiesExample#6](~/add/codesnippet/csharp/m-system.net.sockets.udp_6_1.cs)]\n [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#6](~/add/codesnippet/cpp/m-system.net.sockets.udp_6_1.cpp)]\n [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#6](~/add/codesnippet/visualbasic/m-system.net.sockets.udp_6_1.vb)]"
  syntax:
    content: public void Connect (System.Net.IPAddress addr, int port);
    parameters:
    - id: addr
      type: System.Net.IPAddress
      description: "<xref:System.Net.IPAddress>你想要将数据发送到的远程主机。</xref:System.Net.IPAddress>"
    - id: port
      type: System.Int32
      description: "您想数据发送到端口号。"
  overload: System.Net.Sockets.UdpClient.Connect*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.UdpClient&quot;></xref>已关闭。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>addr</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>port</code>不介于<xref:System.Net.IPEndPoint.MinPort>和<xref:System.Net.IPEndPoint.MaxPort>。"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "访问套接字时出错。 请参阅备注部分以了解更多信息。"
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)
  id: Connect(System.String,System.Int32)
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: Connect(String,Int32)
  nameWithType: UdpClient.Connect(String,Int32)
  fullName: System.Net.Sockets.UdpClient.Connect(String,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "建立默认远程主机使用指定主机名和端口号。"
  remarks: "连接方法建立默认远程主机使用中指定的值`port`和`hostname`参数。 一旦建立，则不需要在每次调用中指定远程主机<xref:System.Net.Sockets.UdpClient.Send%2A>方法。</xref:System.Net.Sockets.UdpClient.Send%2A>       建立默认远程主机的操作是可选的。 指定默认远程主机限制只能访问该主机。 如果你想要将数据报发送到不同的远程主机，必须进行另一个连接方法调用或创建另一个<xref:System.Net.Sockets.UdpClient>而无需默认远程主机。</xref:System.Net.Sockets.UdpClient>       如果你已经建立默认远程主机和你还提供了一台远程主机的<xref:System.Net.Sockets.UdpClient.Send%2A>方法，则<xref:System.Net.Sockets.UdpClient.Send%2A>将引发一种<xref:System.Net.Sockets.SocketException>。</xref:System.Net.Sockets.SocketException></xref:System.Net.Sockets.UdpClient.Send%2A></xref:System.Net.Sockets.UdpClient.Send%2A>调用中 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>以获得特定错误代码。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException> 一旦你已获得此代码，你可以引用的 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。       如果调用<xref:System.Net.Sockets.Socket.Connect%2A>方法，而非将放弃指定的默认到达发件人地址的任何数据报。</xref:System.Net.Sockets.Socket.Connect%2A> 不能设置为使用此方法，除非从继承广播地址的默认远程主机<xref:System.Net.Sockets.UdpClient>，客户端方法用于获取基础<xref:System.Net.Sockets.Socket>，并将设置到<xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>。</xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>的套接字选项</xref:System.Net.Sockets.Socket></xref:System.Net.Sockets.UdpClient>       但是可以、 为默认值的广播的数据广播地址，255.255.255.255，如果你指定<xref:System.Net.IPAddress.Broadcast?displayProperty=fullName>调用中<xref:System.Net.Sockets.UdpClient.Send%2A>方法。</xref:System.Net.Sockets.UdpClient.Send%2A> </xref:System.Net.IPAddress.Broadcast?displayProperty=fullName> 如果你的应用程序需要更好地控制广播地址，你可以还原到使用<xref:System.Net.Sockets.Socket>类。</xref:System.Net.Sockets.Socket>      1> [!NOTE]&1;> 由于 UDP 协议是无连接、 连接方法不会阻止。 如果你想要接收多路广播数据报，请勿调用连接方法。"
  example:
  - "The following example uses the host name and port number to connect to a remote host.  \n  \n [!code-cs[Classic UdpClient.PublicMethodsAndPropertiesExample#5](~/add/codesnippet/csharp/m-system.net.sockets.udp_13_1.cs)]\n [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#5](~/add/codesnippet/cpp/m-system.net.sockets.udp_13_1.cpp)]\n [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#5](~/add/codesnippet/visualbasic/m-system.net.sockets.udp_13_1.vb)]"
  syntax:
    content: public void Connect (string hostname, int port);
    parameters:
    - id: hostname
      type: System.String
      description: "您想数据发送到远程主机的 DNS 名称。"
    - id: port
      type: System.Int32
      description: "你想要将数据发送到远程主机上的端口号。"
  overload: System.Net.Sockets.UdpClient.Connect*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.UdpClient&quot;> </xref>已关闭。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>port</code>不介于<xref:System.Net.IPEndPoint.MinPort>和<xref:System.Net.IPEndPoint.MaxPort>。"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "访问套接字时出错。 请参阅备注部分以了解更多信息。"
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.Dispose
  id: Dispose
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: Dispose()
  nameWithType: UdpClient.Dispose()
  fullName: System.Net.Sockets.UdpClient.Dispose()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "释放使用的托管和非托管资源<xref href=&quot;System.Net.Sockets.UdpClient&quot;> </xref>。"
  syntax:
    content: public void Dispose ();
    parameters: []
  overload: System.Net.Sockets.UdpClient.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: UdpClient.Dispose(Boolean)
  fullName: System.Net.Sockets.UdpClient.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "释放由非托管的资源<xref href=&quot;System.Net.Sockets.UdpClient&quot;> </xref> ，还可以释放托管的资源。"
  remarks: "此方法称为由公共`Dispose()`方法和<xref:System.Object.Finalize%2A>方法。</xref:System.Object.Finalize%2A> `Dispose()`调用受保护`Dispose(Boolean)`方法替换`disposing`参数设置为`true`。 <xref:System.Object.Finalize%2A>调用`Dispose`与`disposing`设置为`false`。</xref:System.Object.Finalize%2A>       当`disposing`参数为 true 时，此方法释放由任何托管对象持有的全部资源此<xref:System.Net.Sockets.UdpClient>引用。</xref:System.Net.Sockets.UdpClient> 此方法调用`Dispose()`每个引用对象的方法。"
  syntax:
    content: protected virtual void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要释放托管和非托管资源;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>若要仅释放非托管的资源。"
  overload: System.Net.Sockets.UdpClient.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.DontFragment
  id: DontFragment
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: DontFragment
  nameWithType: UdpClient.DontFragment
  fullName: System.Net.Sockets.UdpClient.DontFragment
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "获取或设置<xref:System.Boolean>值，该值指定是否<xref href=&quot;System.Net.Sockets.UdpClient&quot;></xref>允许 Internet 协议 (IP) 的数据报进行分段。</xref:System.Boolean>"
  remarks: "其大小超过最大传输单元 (MTU) 的传输介质时，数据报需要碎片。 数据报发送主机或中间路由器可以对消息分片。 如果必须碎片数据报，和<xref:System.Net.Sockets.Socket.DontFragment%2A>选项设置、 数据报将被丢弃，以及 Internet 控制消息协议 (ICMP) 错误消息发送回数据报的发件人。</xref:System.Net.Sockets.Socket.DontFragment%2A>"
  example:
  - "The following code example shows the use of the <xref:System.Net.Sockets.Socket.DontFragment%2A> property.  \n  \n [!code-cs[System.Net.Sockets.UdpClient#2](~/add/codesnippet/csharp/p-system.net.sockets.udp_5_1.cs)]\n [!code-cpp[System.Net.Sockets.UdpClient#2](~/add/codesnippet/cpp/p-system.net.sockets.udp_5_1.cpp)]"
  syntax:
    content: public bool DontFragment { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Net.Sockets.UdpClient&quot;></xref>允许数据报碎片; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Sockets.UdpClient.DontFragment*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "可以仅为使用的套接字设置此属性<xref:System.Net.Sockets.AddressFamily>标志或<xref:System.Net.Sockets.AddressFamily>标志。</xref:System.Net.Sockets.AddressFamily> </xref:System.Net.Sockets.AddressFamily>"
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress)
  id: DropMulticastGroup(System.Net.IPAddress)
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: DropMulticastGroup(IPAddress)
  nameWithType: UdpClient.DropMulticastGroup(IPAddress)
  fullName: System.Net.Sockets.UdpClient.DropMulticastGroup(IPAddress)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "离开多播的组。"
  remarks: "<xref:System.Net.Sockets.UdpClient>从的多播组标识指定<xref:System.Net.IPAddress>。</xref:System.Net.IPAddress></xref:System.Net.Sockets.UdpClient>中提取 DropMulticastGroup 方法 调用 DropMulticastGroup 方法后，基础<xref:System.Net.Sockets.Socket>将 Internet 组管理协议 (IGMP) 数据包发送到路由器上，从多播组中删除路由器。</xref:System.Net.Sockets.Socket> 后<xref:System.Net.Sockets.UdpClient>中提取从组中，将不再能够接收数据报发送到该组。</xref:System.Net.Sockets.UdpClient>      1> [!NOTE]&1;> 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>以获得特定错误代码。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException> 一旦你已获得此代码，你可以引用的 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。"
  example:
  - "The following example demonstrates how to drop a multicast group by providing a multicast address.  \n  \n [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/add/codesnippet/cpp/m-system.net.sockets.udp_3_1.cpp)]\n [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/add/codesnippet/visualbasic/m-system.net.sockets.udp_3_1.vb)]\n [!code-cs[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/add/codesnippet/csharp/m-system.net.sockets.udp_3_1.cs)]"
  syntax:
    content: public void DropMulticastGroup (System.Net.IPAddress multicastAddr);
    parameters:
    - id: multicastAddr
      type: System.Net.IPAddress
      description: "<xref:System.Net.IPAddress>要保留的多播组。</xref:System.Net.IPAddress>"
  overload: System.Net.Sockets.UdpClient.DropMulticastGroup*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "基础<xref:System.Net.Sockets.Socket>已关闭。</xref:System.Net.Sockets.Socket>"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "访问套接字时出错。 请参阅备注部分以了解更多信息。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "IP 地址不与兼容<xref:System.Net.Sockets.AddressFamily>值，该值定义套接字的寻址方案。</xref:System.Net.Sockets.AddressFamily>"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>multicastAddr</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress,System.Int32)
  id: DropMulticastGroup(System.Net.IPAddress,System.Int32)
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: DropMulticastGroup(IPAddress,Int32)
  nameWithType: UdpClient.DropMulticastGroup(IPAddress,Int32)
  fullName: System.Net.Sockets.UdpClient.DropMulticastGroup(IPAddress,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "离开多播的组。"
  remarks: "<xref:System.Net.Sockets.UdpClient>从的多播组标识指定<xref:System.Net.IPAddress>。</xref:System.Net.IPAddress></xref:System.Net.Sockets.UdpClient>中提取 DropMulticastGroup 方法 调用 DropMulticastGroup 方法后，基础<xref:System.Net.Sockets.Socket>将 Internet 组管理协议 (IGMP) 数据包发送到路由器上，从多播组中删除路由器。</xref:System.Net.Sockets.Socket> 后<xref:System.Net.Sockets.UdpClient>中提取从组中，将不再能够接收数据报发送到该组。</xref:System.Net.Sockets.UdpClient>      1> [!NOTE]&1;> 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>属性来获取特定的错误代码。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException> 获取此代码后，你可以参考 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。"
  example:
  - "The following code example demonstrates how to drop a multicast group by providing a multicast address.  \n  \n [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/add/codesnippet/cpp/d83f3217-6e3e-43a5-a5d8-_1.cpp)]\n [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/add/codesnippet/visualbasic/d83f3217-6e3e-43a5-a5d8-_1.vb)]\n [!code-cs[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/add/codesnippet/csharp/d83f3217-6e3e-43a5-a5d8-_1.cs)]"
  syntax:
    content: public void DropMulticastGroup (System.Net.IPAddress multicastAddr, int ifindex);
    parameters:
    - id: multicastAddr
      type: System.Net.IPAddress
      description: "<xref:System.Net.IPAddress>要保留的多播组。</xref:System.Net.IPAddress>"
    - id: ifindex
      type: System.Int32
      description: "要退出的多播组对本地地址。"
  overload: System.Net.Sockets.UdpClient.DropMulticastGroup*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "基础<xref:System.Net.Sockets.Socket>已关闭。</xref:System.Net.Sockets.Socket>"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "访问套接字时出错。 请参阅备注部分以了解更多信息。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "IP 地址不与兼容<xref:System.Net.Sockets.AddressFamily>值，该值定义套接字的寻址方案。</xref:System.Net.Sockets.AddressFamily>"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>multicastAddr</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.EnableBroadcast
  id: EnableBroadcast
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: EnableBroadcast
  nameWithType: UdpClient.EnableBroadcast
  fullName: System.Net.Sockets.UdpClient.EnableBroadcast
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "获取或设置<xref:System.Boolean>值，该值指定是否<xref href=&quot;System.Net.Sockets.UdpClient&quot;></xref>可能发送或接收广播的数据包。</xref:System.Boolean>"
  remarks: "广播仅限于特定子网。 您可以通过将数据包发送到 255.255.255.255; 广播到你的本地子网或者，你可以使用定向广播的地址，这是与设置的主机部分中的所有位的 Internet 协议 (IP) 地址的网络部分。 例如，如果你的 IP 地址是的 192.168.1.40 （C 类地址，使用的网络部分作为前三个八位字节和的主机部分是最后一个八位字节），则定向广播的地址是 192.168.1.255。"
  example:
  - "The following code example shows the use of the EnableBroadcast property.  \n  \n [!code-cs[System.Net.Sockets.UdpClient#3](~/add/codesnippet/csharp/p-system.net.sockets.udp_3_1.cs)]\n [!code-cpp[System.Net.Sockets.UdpClient#3](~/add/codesnippet/cpp/p-system.net.sockets.udp_3_1.cpp)]"
  syntax:
    content: public bool EnableBroadcast { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Net.Sockets.UdpClient&quot;></xref>允许广播的数据包数; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Sockets.UdpClient.EnableBroadcast*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.EndReceive(System.IAsyncResult,System.Net.IPEndPoint@)
  id: EndReceive(System.IAsyncResult,System.Net.IPEndPoint@)
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: EndReceive(IAsyncResult,IPEndPoint)
  nameWithType: UdpClient.EndReceive(IAsyncResult,IPEndPoint)
  fullName: System.Net.Sockets.UdpClient.EndReceive(IAsyncResult,IPEndPoint)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "结束挂起的异步接收。"
  remarks: "此方法受到阻止，直到操作完成。       若要以同步方式执行此操作，使用<xref:System.Net.Sockets.UdpClient.Receive%2A>方法。</xref:System.Net.Sockets.UdpClient.Receive%2A>"
  example:
  - "The following code example uses <xref:System.Net.Sockets.UdpClient.BeginSend%2A> to complete an asynchronous receive of a server response.  \n  \n [!code-cpp[System.Net.Sockets.UdpClient1#1](~/add/codesnippet/cpp/5ace0ab2-d0e9-4f1f-a415-_1.cpp)]\n [!code-cs[System.Net.Sockets.UdpClient1#1](~/add/codesnippet/csharp/5ace0ab2-d0e9-4f1f-a415-_1.cs)]"
  syntax:
    content: public byte[] EndReceive (IAsyncResult asyncResult, ref System.Net.IPEndPoint remoteEP);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>到<xref:System.Net.Sockets.UdpClient.BeginReceive*>。</xref:System.Net.Sockets.UdpClient.BeginReceive*>调用所返回对象</xref:System.IAsyncResult>"
    - id: remoteEP
      type: System.Net.IPEndPoint
      description: "指定的远程终结点。"
    return:
      type: System.Byte[]
      description: "如果成功，将收到的字节数。 如果不成功，则此方法将返回 0。"
  overload: System.Net.Sockets.UdpClient.EndReceive*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>asyncResult</code>通过调用未返回<xref:System.Net.Sockets.UdpClient.BeginReceive*>方法。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "EndReceive 之前被称为为异步读取。"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "在尝试访问的基础<xref:System.Net.Sockets.Socket>。</xref:System.Net.Sockets.Socket>时出错 请参阅备注部分以了解更多信息。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "基础<xref:System.Net.Sockets.Socket>已关闭。</xref:System.Net.Sockets.Socket>"
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.EndSend(System.IAsyncResult)
  id: EndSend(System.IAsyncResult)
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: EndSend(IAsyncResult)
  nameWithType: UdpClient.EndSend(IAsyncResult)
  fullName: System.Net.Sockets.UdpClient.EndSend(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "结束挂起的异步发送。"
  remarks: "此方法受到阻止，直到操作完成。       若要以同步方式执行此操作，使用<xref:System.Net.Sockets.UdpClient.Send%2A>方法。</xref:System.Net.Sockets.UdpClient.Send%2A>"
  example:
  - "The following code example uses <xref:System.Net.Sockets.UdpClient.BeginSend%2A> to complete an asynchronous send of a server request.  \n  \n [!code-cpp[System.Net.Sockets.UdpClient1#2](~/add/codesnippet/cpp/m-system.net.sockets.udp_0_1.cpp)]\n [!code-cs[System.Net.Sockets.UdpClient1#2](~/add/codesnippet/csharp/m-system.net.sockets.udp_0_1.cs)]"
  syntax:
    content: public int EndSend (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>到<xref:System.Net.Sockets.UdpClient.BeginSend*>。</xref:System.Net.Sockets.UdpClient.BeginSend*>调用所返回对象</xref:System.IAsyncResult>"
    return:
      type: System.Int32
      description: "如果成功，字节数发送到<xref href=&quot;System.Net.Sockets.UdpClient&quot;> </xref>。"
  overload: System.Net.Sockets.UdpClient.EndSend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>asyncResult</code>通过调用未返回<xref:System.Net.Sockets.Socket.BeginSend*>方法。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref:System.Net.Sockets.Socket.EndSend*>之前已调用以进行异步读取。</xref:System.Net.Sockets.Socket.EndSend*>"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "在尝试访问基础套接字时出错。 请参阅备注部分以了解更多信息。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "基础<xref:System.Net.Sockets.Socket>已关闭。</xref:System.Net.Sockets.Socket>"
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.ExclusiveAddressUse
  id: ExclusiveAddressUse
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: ExclusiveAddressUse
  nameWithType: UdpClient.ExclusiveAddressUse
  fullName: System.Net.Sockets.UdpClient.ExclusiveAddressUse
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "获取或设置<xref:System.Boolean>值，该值指定是否<xref href=&quot;System.Net.Sockets.UdpClient&quot;></xref>允许只有一个客户端使用端口</xref:System.Boolean>"
  remarks: "默认情况下，多个客户端可以使用特定端口，但是，只有一个客户端可以执行网络流量发送到端口的操作。 ExclusiveAddressUse 属性可用于防止多个客户端使用特定端口。       基础套接字绑定到客户端端口之前，必须设置此属性。 如果调用<xref:System.Net.Sockets.UdpClient.%23ctor%28System.Int32%29?displayProperty=fullName>， <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Int32%2CSystem.Net.Sockets.AddressFamily%29?displayProperty=fullName>， <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.IPEndPoint%29?displayProperty=fullName>，或<xref:System.Net.Sockets.UdpClient.%23ctor%28System.String%2CSystem.Int32%29?displayProperty=fullName>客户端端口绑定为构造函数中，会产生副作用，随后无法设置 ExclusiveAddressUse 属性</xref:System.Net.Sockets.UdpClient.%23ctor%28System.String%2CSystem.Int32%29?displayProperty=fullName></xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.IPEndPoint%29?displayProperty=fullName></xref:System.Net.Sockets.UdpClient.%23ctor%28System.Int32%2CSystem.Net.Sockets.AddressFamily%29?displayProperty=fullName></xref:System.Net.Sockets.UdpClient.%23ctor%28System.Int32%29?displayProperty=fullName>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.UdpClient>, and gets and sets the ExclusiveAddressUse property.  \n  \n [!code-cs[System.Net.Sockets.UdpClient#4](~/add/codesnippet/csharp/p-system.net.sockets.udp_4_1.cs)]\n [!code-cpp[System.Net.Sockets.UdpClient#4](~/add/codesnippet/cpp/p-system.net.sockets.udp_4_1.cpp)]"
  syntax:
    content: public bool ExclusiveAddressUse { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Net.Sockets.UdpClient&quot;></xref>允许只有一个客户端使用特定端口; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 默认值是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>为 Windows Server 2003 和 Windows XP Service Pack 2 及更高版本，和<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>对于所有其他版本。"
  overload: System.Net.Sockets.UdpClient.ExclusiveAddressUse*
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "在尝试访问基础套接字时出错。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "基础<xref:System.Net.Sockets.Socket>已关闭。</xref:System.Net.Sockets.Socket>"
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress)
  id: JoinMulticastGroup(System.Net.IPAddress)
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: JoinMulticastGroup(IPAddress)
  nameWithType: UdpClient.JoinMulticastGroup(IPAddress)
  fullName: System.Net.Sockets.UdpClient.JoinMulticastGroup(IPAddress)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "将添加<xref href=&quot;System.Net.Sockets.UdpClient&quot;></xref>到多播组。"
  remarks: "JoinMulticastGroup 方法订阅<xref:System.Net.Sockets.UdpClient>到多播组使用指定的<xref:System.Net.IPAddress>.</xref:System.Net.IPAddress> </xref:System.Net.Sockets.UdpClient> 调用 JoinMulticastGroup 方法后，基础<xref:System.Net.Sockets.Socket>将 Internet 组管理协议 (IGMP) 数据包发送到路由器请求到多播组的成员身份。</xref:System.Net.Sockets.Socket> 多播的地址范围是 224.0.0.0 到 239.255.255.255。 如果指定的地址在此范围之外，或对其进行请求的路由器不支持多路启用，<xref:System.Net.Sockets.UdpClient>将引发一种<xref:System.Net.Sockets.SocketException>。</xref:System.Net.Sockets.SocketException> </xref:System.Net.Sockets.UdpClient> 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>以获得特定错误代码。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException> 一旦你已获得此代码，你可以引用的 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。 一次<xref:System.Net.Sockets.UdpClient>列出使用多播组的成员作为路由器时，它将能够接收多路广播数据报发送到指定<xref:System.Net.IPAddress>。</xref:System.Net.IPAddress> </xref:System.Net.Sockets.UdpClient>      1> [!NOTE]&1;> 必须创建<xref:System.Net.Sockets.UdpClient>使用多址广播的端口号; 否则，你将不能接收多路广播数据报。</xref:System.Net.Sockets.UdpClient> 不要调用<xref:System.Net.Sockets.UdpClient.Connect%2A>方法，然后调用 JoinMulticastGroup 方法中，或<xref:System.Net.Sockets.UdpClient.Receive%2A>方法不适用。</xref:System.Net.Sockets.UdpClient.Receive%2A> </xref:System.Net.Sockets.UdpClient.Connect%2A> 不需要属于要将数据报发送到多播 IP 地址的多播组。       之前加入多播的组，请确保该套接字绑定到端口或终结点。 通过调用接受一个端口或终结点作为参数的构造函数之一来执行该操作。       若要停止接收多路广播数据报，调用<xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A>方法并提供<xref:System.Net.IPAddress>从中您是否要退出的组。</xref:System.Net.IPAddress> </xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A>      1> [!NOTE]&1;> 在 IPv6 情况下，有你可以从选择的多个多播的地址范围。 请请参阅 IETF RFC 2375。      1> [!NOTE]&1;> 不能调用<xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A>上<xref:System.Net.Sockets.UdpClient>构造没有的特定本地端口的情况下 (即，使用<xref:System.Net.Sockets.UdpClient.%23ctor>或<xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29>构造函数)。</xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29> </xref:System.Net.Sockets.UdpClient.%23ctor> </xref:System.Net.Sockets.UdpClient> </xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A>"
  example:
  - "The following code example demonstrates how to join a multicast group by providing a multicast address.  \n  \n [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#1](~/add/codesnippet/cpp/m-system.net.sockets.udp_8_1.cpp)]\n [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#1](~/add/codesnippet/visualbasic/m-system.net.sockets.udp_8_1.vb)]\n [!code-cs[System.Net.Sockets.UdpClient.JoinMulticastGroup#1](~/add/codesnippet/csharp/m-system.net.sockets.udp_8_1.cs)]"
  syntax:
    content: public void JoinMulticastGroup (System.Net.IPAddress multicastAddr);
    parameters:
    - id: multicastAddr
      type: System.Net.IPAddress
      description: "多路广播<xref:System.Net.IPAddress>您想要加入的组。</xref:System.Net.IPAddress>"
  overload: System.Net.Sockets.UdpClient.JoinMulticastGroup*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "基础<xref:System.Net.Sockets.Socket>已关闭。</xref:System.Net.Sockets.Socket>"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "访问套接字时出错。 请参阅备注部分以了解更多信息。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "IP 地址不与兼容<xref:System.Net.Sockets.AddressFamily>值，该值定义套接字的寻址方案。</xref:System.Net.Sockets.AddressFamily>"
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Int32,System.Net.IPAddress)
  id: JoinMulticastGroup(System.Int32,System.Net.IPAddress)
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: JoinMulticastGroup(Int32,IPAddress)
  nameWithType: UdpClient.JoinMulticastGroup(Int32,IPAddress)
  fullName: System.Net.Sockets.UdpClient.JoinMulticastGroup(Int32,IPAddress)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "将添加<xref href=&quot;System.Net.Sockets.UdpClient&quot;></xref>到多播组。"
  remarks: "之前加入多播的组，请确保该套接字绑定到端口或终结点。 你可以调用接受一个端口或终结点作为参数的构造函数之一来执行此操作。       `infindex`参数用于标识的相同链接上的硬件接口。      1> [!NOTE]&1;> 有多个多播的地址范围，可供选择。 请参阅 IETF RFC 2375。      1> [!NOTE]&1;> 不能调用<xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A>上<xref:System.Net.Sockets.UdpClient>构造没有的特定本地端口的情况下 (即，使用<xref:System.Net.Sockets.UdpClient.%23ctor?displayProperty=fullName>或<xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29?displayProperty=fullName>构造函数)。</xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29?displayProperty=fullName> </xref:System.Net.Sockets.UdpClient.%23ctor?displayProperty=fullName> </xref:System.Net.Sockets.UdpClient> </xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A>"
  example:
  - >-
    [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#5](~/add/codesnippet/cpp/f675abdc-8a60-48f5-a8c6-_1.cpp)]
     [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#5](~/add/codesnippet/visualbasic/f675abdc-8a60-48f5-a8c6-_1.vb)]
     [!code-cs[System.Net.Sockets.UdpClient.JoinMulticastGroup#5](~/add/codesnippet/csharp/f675abdc-8a60-48f5-a8c6-_1.cs)]
  syntax:
    content: public void JoinMulticastGroup (int ifindex, System.Net.IPAddress multicastAddr);
    parameters:
    - id: ifindex
      type: System.Int32
      description: "与对其进行加入多播的组本地 IP 地址关联的接口索引。"
    - id: multicastAddr
      type: System.Net.IPAddress
      description: "多路广播<xref:System.Net.IPAddress>您想要加入的组。</xref:System.Net.IPAddress>"
  overload: System.Net.Sockets.UdpClient.JoinMulticastGroup*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "基础<xref:System.Net.Sockets.Socket>已关闭。</xref:System.Net.Sockets.Socket>"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "访问套接字时出错。 请参阅备注部分以了解更多信息。"
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress,System.Int32)
  id: JoinMulticastGroup(System.Net.IPAddress,System.Int32)
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: JoinMulticastGroup(IPAddress,Int32)
  nameWithType: UdpClient.JoinMulticastGroup(IPAddress,Int32)
  fullName: System.Net.Sockets.UdpClient.JoinMulticastGroup(IPAddress,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "将添加<xref href=&quot;System.Net.Sockets.UdpClient&quot;></xref>到具有指定的时间 (TTL) 的多播组。"
  remarks: "<xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A><xref:System.Net.Sockets.UdpClient>到多播组使用指定的<xref:System.Net.IPAddress>.</xref:System.Net.IPAddress></xref:System.Net.Sockets.UdpClient>订阅方法</xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> 在调用<xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A>方法，基础<xref:System.Net.Sockets.Socket>将 Internet 组管理协议 (IGMP) 数据包发送到路由器请求到多播组的成员身份。</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> 多播的地址范围是 224.0.0.0 到 239.255.255.255。 如果指定的地址在此范围之外，或对其进行请求的路由器不支持多路启用，<xref:System.Net.Sockets.UdpClient>将引发一种<xref:System.Net.Sockets.SocketException>。</xref:System.Net.Sockets.SocketException> </xref:System.Net.Sockets.UdpClient> 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>以获得特定错误代码。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException> 一旦你已获得此代码，你可以引用的 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。 `timeToLive`参数指定路由器跃点数将被丢弃之前允许对多路广播数据报。 一次<xref:System.Net.Sockets.UdpClient>列出使用多播组的成员作为路由器时，它将能够接收多路广播数据报发送到指定<xref:System.Net.IPAddress>。</xref:System.Net.IPAddress> </xref:System.Net.Sockets.UdpClient>      1> [!NOTE]&1;> 必须创建<xref:System.Net.Sockets.UdpClient>使用多址广播的端口号否则你将无法接收多路广播数据报。</xref:System.Net.Sockets.UdpClient> 不要调用<xref:System.Net.Sockets.UdpClient.Connect%2A>方法之前调用<xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A>方法或 receive 方法不起作用。</xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> </xref:System.Net.Sockets.UdpClient.Connect%2A> 不需要属于要将数据报发送到多播 IP 地址的多播组。       加入多播的组之前请确保该套接字绑定到端口或终结点。 通过调用一个端口或终结点接受作为参数的构造函数之一来执行该操作。       若要停止接收多路广播数据报，调用<xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A>方法并提供<xref:System.Net.IPAddress>从中您是否要退出的组。</xref:System.Net.IPAddress> </xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A>      1> [!NOTE]&1;> 不能调用<xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A>上<xref:System.Net.Sockets.UdpClient>构造没有的特定本地端口的情况下 (即，使用<xref:System.Net.Sockets.UdpClient.%23ctor>或<xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29>构造函数)。</xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29> </xref:System.Net.Sockets.UdpClient.%23ctor> </xref:System.Net.Sockets.UdpClient> </xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A>"
  example:
  - "The following example demonstrates how to join a multicast group by providing two parameters, a multicast address, and a number that represents the TTL.  \n  \n [!code-cs[Classic UdpClient.PublicMethodsAndPropertiesExample#13](~/add/codesnippet/csharp/2ab5d1d5-1bd6-4398-ae63-_1.cs)]\n [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#13](~/add/codesnippet/cpp/2ab5d1d5-1bd6-4398-ae63-_1.cpp)]\n [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#13](~/add/codesnippet/visualbasic/2ab5d1d5-1bd6-4398-ae63-_1.vb)]"
  syntax:
    content: public void JoinMulticastGroup (System.Net.IPAddress multicastAddr, int timeToLive);
    parameters:
    - id: multicastAddr
      type: System.Net.IPAddress
      description: "<xref:System.Net.IPAddress>要联接的多播组。</xref:System.Net.IPAddress>"
    - id: timeToLive
      type: System.Int32
      description: "生存时间 (TTL)，以路由器跃点数为单位。"
  overload: System.Net.Sockets.UdpClient.JoinMulticastGroup*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "所提供的 TTL 不是介于 0 和 255 之间"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "基础<xref:System.Net.Sockets.Socket>已关闭。</xref:System.Net.Sockets.Socket>"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "访问套接字时出错。 请参阅备注部分以了解更多信息。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>multicastAddr</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "IP 地址不与兼容<xref:System.Net.Sockets.AddressFamily>值，该值定义套接字的寻址方案。</xref:System.Net.Sockets.AddressFamily>"
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress,System.Net.IPAddress)
  id: JoinMulticastGroup(System.Net.IPAddress,System.Net.IPAddress)
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: JoinMulticastGroup(IPAddress,IPAddress)
  nameWithType: UdpClient.JoinMulticastGroup(IPAddress,IPAddress)
  fullName: System.Net.Sockets.UdpClient.JoinMulticastGroup(IPAddress,IPAddress)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "将添加<xref href=&quot;System.Net.Sockets.UdpClient&quot;></xref>到多播组。"
  remarks: "加入多播的组之前，请确保该套接字已经绑定到端口或终结点。 你可以调用接受一个端口或终结点作为参数的构造函数之一来执行此操作。      1> [!NOTE]&1;> 有多个多播的地址范围，可供选择。 你可以在 IETF RFC 2375 找到它们。      1> [!NOTE]&1;> 不能调用<xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A>上<xref:System.Net.Sockets.UdpClient>构造没有的特定本地端口的情况下 (即，使用<xref:System.Net.Sockets.UdpClient.%23ctor>或<xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29>构造函数)。</xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29> </xref:System.Net.Sockets.UdpClient.%23ctor> </xref:System.Net.Sockets.UdpClient> </xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A>"
  example:
  - "The following code example shows the use of the JoinMulticastGroup method.  \n  \n [!code-cs[System.Net.Sockets.UdpClient#6](~/add/codesnippet/csharp/83ef7d63-bccd-4c55-a88d-_1.cs)]\n [!code-cpp[System.Net.Sockets.UdpClient#6](~/add/codesnippet/cpp/83ef7d63-bccd-4c55-a88d-_1.cpp)]"
  syntax:
    content: public void JoinMulticastGroup (System.Net.IPAddress multicastAddr, System.Net.IPAddress localAddress);
    parameters:
    - id: multicastAddr
      type: System.Net.IPAddress
      description: "多路广播<xref:System.Net.IPAddress>您想要加入的组。</xref:System.Net.IPAddress>"
    - id: localAddress
      type: System.Net.IPAddress
      description: "本地<xref:System.Net.IPAddress>.</xref:System.Net.IPAddress>"
  overload: System.Net.Sockets.UdpClient.JoinMulticastGroup*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "基础<xref:System.Net.Sockets.Socket>已关闭。</xref:System.Net.Sockets.Socket>"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "访问套接字时出错。 请参阅备注部分以了解更多信息。"
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.MulticastLoopback
  id: MulticastLoopback
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: MulticastLoopback
  nameWithType: UdpClient.MulticastLoopback
  fullName: System.Net.Sockets.UdpClient.MulticastLoopback
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "获取或设置<xref:System.Boolean>值，该值指定是否传出多播的数据包发送到发送应用程序。</xref:System.Boolean>"
  remarks: "多路广播是用于在 Internet 上的多对多通信的可扩展方法。 如果进程订阅到多播地址时，任何数据包发送到多播地址已订阅的每个其他进程，接收过程。"
  example:
  - "The following code example shows the use of the MulticastLoopback property.  \n  \n [!code-cs[System.Net.Sockets.UdpClient#7](~/add/codesnippet/csharp/p-system.net.sockets.udp_2_1.cs)]\n [!code-cpp[System.Net.Sockets.UdpClient#7](~/add/codesnippet/cpp/p-system.net.sockets.udp_2_1.cpp)]"
  syntax:
    content: public bool MulticastLoopback { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Net.Sockets.UdpClient&quot;></xref>接收传出多播的数据包数; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Sockets.UdpClient.MulticastLoopback*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.Receive(System.Net.IPEndPoint@)
  id: Receive(System.Net.IPEndPoint@)
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: Receive(IPEndPoint)
  nameWithType: UdpClient.Receive(IPEndPoint)
  fullName: System.Net.Sockets.UdpClient.Receive(IPEndPoint)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "返回一台远程主机由发送的 UDP 数据报。"
  remarks: "从远程主机的数据报到达之前，将阻止 Receive 方法。 当数据可用时，Receive 方法将读取第一个排队数据报和返回作为字节数组的数据部分。 此方法填充`remoteEP`参数<xref:System.Net.IPAddress>和发件人的端口号。</xref:System.Net.IPAddress>       如果指定中的默认远程主机<xref:System.Net.Sockets.UdpClient.Connect%2A>方法，Receive 方法将接受来自该主机仅数据报。</xref:System.Net.Sockets.UdpClient.Connect%2A> 所有其他数据报将被放弃。       如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>以获得特定错误代码。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException> 一旦你已获得此代码，你可以引用的 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。      1> [!NOTE]&1;> 如果你想要接收多路广播数据报，请勿调用<xref:System.Net.Sockets.UdpClient.Connect%2A>方法，然后调用 Receive 方法。</xref:System.Net.Sockets.UdpClient.Connect%2A> <xref:System.Net.Sockets.UdpClient>用于接收必须使用多址广播的端口号创建数据报。</xref:System.Net.Sockets.UdpClient>"
  example:
  - "The following example demonstrates the Receive method. The Receive method blocks execution until it receives a message. Using the <xref:System.Net.IPEndPoint> passed to Receive, the identity of the responding host is revealed.  \n  \n [!code-cs[Classic UdpClient.PublicMethodsAndPropertiesExample#11](~/add/codesnippet/csharp/m-system.net.sockets.udp_5_1.cs)]\n [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#11](~/add/codesnippet/cpp/m-system.net.sockets.udp_5_1.cpp)]\n [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#11](~/add/codesnippet/visualbasic/m-system.net.sockets.udp_5_1.vb)]"
  syntax:
    content: public byte[] Receive (ref System.Net.IPEndPoint remoteEP);
    parameters:
    - id: remoteEP
      type: System.Net.IPEndPoint
      description: "<xref:System.Net.IPEndPoint>表示远程主机已从其发送数据。</xref:System.Net.IPEndPoint>"
    return:
      type: System.Byte[]
      description: "类型的数组<xref:System.Byte>包含数据报数据。</xref:System.Byte>"
  overload: System.Net.Sockets.UdpClient.Receive*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "基础<xref:System.Net.Sockets.Socket>已关闭。</xref:System.Net.Sockets.Socket>"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "访问套接字时出错。 请参阅备注部分以了解更多信息。"
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.ReceiveAsync
  id: ReceiveAsync
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: ReceiveAsync()
  nameWithType: UdpClient.ReceiveAsync()
  fullName: System.Net.Sockets.UdpClient.ReceiveAsync()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "返回以异步方式，一台远程主机由发送的 UDP 数据报。"
  remarks: "不会阻止此操作。 返回<xref:System.Threading.Tasks.Task%601>1> 对象都完成后接收 UDP 数据包。</xref:System.Threading.Tasks.Task%601>       如果指定中的默认远程主机<xref:System.Net.Sockets.UdpClient.Connect%2A>方法，此方法将接受来自该主机仅数据报。</xref:System.Net.Sockets.UdpClient.Connect%2A> 所有其他数据报将被放弃。       如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>以获得特定错误代码。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException> 一旦你已获得此代码，你可以引用的 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。      1> [!WARNING]&1;> 如果你想要接收多路广播数据报，请勿调用<xref:System.Net.Sockets.UdpClient.Connect%2A>之前调用此方法的方法。</xref:System.Net.Sockets.UdpClient.Connect%2A> <xref:System.Net.Sockets.UdpClient>用于接收必须使用多址广播的端口号创建数据报。</xref:System.Net.Sockets.UdpClient>"
  syntax:
    content: public System.Threading.Tasks.Task<System.Net.Sockets.UdpReceiveResult> ReceiveAsync ();
    parameters: []
    return:
      type: System.Threading.Tasks.Task{System.Net.Sockets.UdpReceiveResult}
      description: "返回&lt;xref:System.Threading.Tasks.Task%601&gt;。       表示异步操作的任务对象。"
  overload: System.Net.Sockets.UdpClient.ReceiveAsync*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "基础<xref:System.Net.Sockets.Socket>已关闭。</xref:System.Net.Sockets.Socket>"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "访问套接字时出错。 请参阅备注部分以了解更多信息。"
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32)
  id: Send(System.Byte[],System.Int32)
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: Send(Byte[],Int32)
  nameWithType: UdpClient.Send(Byte[],Int32)
  fullName: System.Net.Sockets.UdpClient.Send(Byte[],Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "将 UDP 数据报发送到远程主机。"
  remarks: "此重载将数据报发送到中建立的远程主机<xref:System.Net.Sockets.UdpClient.Connect%2A>方法并返回已发送的字节数。</xref:System.Net.Sockets.UdpClient.Connect%2A> 如果你不调用<xref:System.Net.Sockets.UdpClient.Connect%2A>之前调用此重载，<xref:System.Net.Sockets.UdpClient.Send%2A>方法会引发一种<xref:System.Net.Sockets.SocketException>。</xref:System.Net.Sockets.SocketException> </xref:System.Net.Sockets.UdpClient.Send%2A> </xref:System.Net.Sockets.UdpClient.Connect%2A> 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>以获得特定错误代码。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException> 一旦你已获得此代码，你可以引用的 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。       如果你想要将数据报发送到不同的远程主机，则必须调用<xref:System.Net.Sockets.UdpClient.Connect%2A>方法并指定所需的远程主机。</xref:System.Net.Sockets.UdpClient.Connect%2A> 使用其他<xref:System.Net.Sockets.UdpClient.Send%2A>方法重载来为广播地址发送数据报。</xref:System.Net.Sockets.UdpClient.Send%2A>"
  example:
  - "The following example demonstrates the <xref:System.Net.Sockets.UdpClient.Send%2A> method. You must establish a default remote host prior to using this overload.  \n  \n [!code-cs[Classic UdpClient.PublicMethodsAndPropertiesExample#10](~/add/codesnippet/csharp/m-system.net.sockets.udp_2_1.cs)]\n [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#10](~/add/codesnippet/cpp/m-system.net.sockets.udp_2_1.cpp)]\n [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#10](~/add/codesnippet/visualbasic/m-system.net.sockets.udp_2_1.vb)]"
  syntax:
    content: public int Send (byte[] dgram, int bytes);
    parameters:
    - id: dgram
      type: System.Byte[]
      description: "类型的数组<xref:System.Byte>，它指定你打算发送的 UDP 数据报表示作为字节数组。</xref:System.Byte>"
    - id: bytes
      type: System.Int32
      description: "数据报中的字节数。"
    return:
      type: System.Int32
      description: "发送的字节数。"
  overload: System.Net.Sockets.UdpClient.Send*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>dgram</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Net.Sockets.UdpClient&quot;> </xref>已建立默认远程主机。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.UdpClient&quot;> </xref>已关闭。"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "访问套接字时出错。 请参阅备注部分以了解更多信息。"
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)
  id: Send(System.Byte[],System.Int32,System.Net.IPEndPoint)
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: Send(Byte[],Int32,IPEndPoint)
  nameWithType: UdpClient.Send(Byte[],Int32,IPEndPoint)
  fullName: System.Net.Sockets.UdpClient.Send(Byte[],Int32,IPEndPoint)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "将 UDP 数据报发送到位于指定远程终结点的主机。"
  remarks: "发送方法将数据报发送到指定的终结点，并返回成功发送的字节数。 之前调用此重载，你必须首先创建<xref:System.Net.IPEndPoint>使用将向其传递你的数据报的远程主机的 IP 地址和端口号。</xref:System.Net.IPEndPoint> 你可以通过<xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>为<xref:System.Net.IPAddress.Address%2A><xref:System.Net.IPEndPoint>.</xref:System.Net.IPEndPoint>属性</xref:System.Net.IPAddress.Address%2A></xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>指定数据报发送到默认广播地址，255.255.255.255， 创建此后<xref:System.Net.IPEndPoint>，将其传递给 Send 方法作为`endPoint`参数。</xref:System.Net.IPEndPoint>       如果你想要将数据报发送到任何其他广播地址，使用<xref:System.Net.Sockets.UdpClient.Client%2A>方法来获取基础<xref:System.Net.Sockets.Socket>，并将设置到<xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>。</xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>的套接字选项</xref:System.Net.Sockets.Socket></xref:System.Net.Sockets.UdpClient.Client%2A> 你还可以还原到使用<xref:System.Net.Sockets.Socket>类。</xref:System.Net.Sockets.Socket>      1> [!NOTE]&1;> 不提供`endPoint`此方法如果你已建立与远程主机参数<xref:System.Net.Sockets.UdpClient.Connect%2A>方法。</xref:System.Net.Sockets.UdpClient.Connect%2A> 如果这样做，Send 方法将引发一种<xref:System.Net.Sockets.SocketException>。</xref:System.Net.Sockets.SocketException> 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>以获得特定错误代码。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException> 一旦你已获得此代码，你可以引用的 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。"
  example:
  - "The following example demonstrates the Send method. This example uses an <xref:System.Net.IPEndPoint> to specify the target host.  \n  \n [!code-cs[Classic UdpClient.PublicMethodsAndPropertiesExample#8](~/add/codesnippet/csharp/2c594ef1-b462-42a1-adc5-_1.cs)]\n [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#8](~/add/codesnippet/cpp/2c594ef1-b462-42a1-adc5-_1.cpp)]\n [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#8](~/add/codesnippet/visualbasic/2c594ef1-b462-42a1-adc5-_1.vb)]"
  syntax:
    content: public int Send (byte[] dgram, int bytes, System.Net.IPEndPoint endPoint);
    parameters:
    - id: dgram
      type: System.Byte[]
      description: "类型的数组<xref:System.Byte>，指定你打算发送，并将表示为字节数组的 UDP 数据报。</xref:System.Byte>"
    - id: bytes
      type: System.Int32
      description: "数据报中的字节数。"
    - id: endPoint
      type: System.Net.IPEndPoint
      description: "<xref:System.Net.IPEndPoint>，表示主机和要将数据报发送到的端口。</xref:System.Net.IPEndPoint>"
    return:
      type: System.Int32
      description: "发送的字节数。"
  overload: System.Net.Sockets.UdpClient.Send*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>dgram</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Net.Sockets.UdpClient&quot;></xref>已建立默认远程主机。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.UdpClient&quot;></xref>已关闭。"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "访问套接字时出错。 请参阅备注部分以了解更多信息。"
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.String,System.Int32)
  id: Send(System.Byte[],System.Int32,System.String,System.Int32)
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: Send(Byte[],Int32,String,Int32)
  nameWithType: UdpClient.Send(Byte[],Int32,String,Int32)
  fullName: System.Net.Sockets.UdpClient.Send(Byte[],Int32,String,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "将 UDP 数据报发送到指定的远程主机上的指定端口。"
  remarks: "<xref:System.Net.Sockets.UdpClient.Send%2A>方法将数据报发送到指定的值`hostname`和`port`参数，并返回成功发送的字节数。</xref:System.Net.Sockets.UdpClient.Send%2A> 您可以向默认广播地址发送数据报，通过为指定&quot;255.255.255.255&quot;`hostname`参数值。       如果你想要将数据报发送到任何其他广播地址，使用<xref:System.Net.Sockets.UdpClient.Client%2A>方法来获取基础<xref:System.Net.Sockets.Socket>，并将设置到<xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>。</xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>的套接字选项</xref:System.Net.Sockets.Socket></xref:System.Net.Sockets.UdpClient.Client%2A> 你还可以还原到使用<xref:System.Net.Sockets.Socket>类。</xref:System.Net.Sockets.Socket>      1> [!NOTE]&1;> 不提供主机名或端口号对此方法，如果你已建立与远程主机<xref:System.Net.Sockets.UdpClient.Connect%2A>方法。</xref:System.Net.Sockets.UdpClient.Connect%2A> 如果这样做，<xref:System.Net.Sockets.UdpClient.Send%2A>方法会引发一种<xref:System.Net.Sockets.SocketException>。</xref:System.Net.Sockets.SocketException> </xref:System.Net.Sockets.UdpClient.Send%2A> 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>以获得特定错误代码。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException> 一旦你已获得此代码，你可以引用的 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。"
  example:
  - "The following example demonstrates the <xref:System.Net.Sockets.UdpClient.Send%2A> method. This example uses a host name and a port number to identify the target host.  \n  \n [!code-cs[Classic UdpClient.PublicMethodsAndPropertiesExample#9](~/add/codesnippet/csharp/5d28964f-8575-4595-a91e-_1.cs)]\n [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#9](~/add/codesnippet/cpp/5d28964f-8575-4595-a91e-_1.cpp)]\n [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#9](~/add/codesnippet/visualbasic/5d28964f-8575-4595-a91e-_1.vb)]"
  syntax:
    content: public int Send (byte[] dgram, int bytes, string hostname, int port);
    parameters:
    - id: dgram
      type: System.Byte[]
      description: "类型的数组<xref:System.Byte>，它指定你打算发送的 UDP 数据报表示作为字节数组。</xref:System.Byte>"
    - id: bytes
      type: System.Int32
      description: "数据报中的字节数。"
    - id: hostname
      type: System.String
      description: "你打算发送数据报的远程主机的名称。"
    - id: port
      type: System.Int32
      description: "你打算与之通信的远程端口号。"
    return:
      type: System.Int32
      description: "发送的字节数。"
  overload: System.Net.Sockets.UdpClient.Send*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>dgram</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Net.Sockets.UdpClient&quot;> </xref>已建立默认远程主机。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.UdpClient&quot;> </xref>已关闭。"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "访问套接字时出错。 请参阅备注部分以了解更多信息。"
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.SendAsync(System.Byte[],System.Int32)
  id: SendAsync(System.Byte[],System.Int32)
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: SendAsync(Byte[],Int32)
  nameWithType: UdpClient.SendAsync(Byte[],Int32)
  fullName: System.Net.Sockets.UdpClient.SendAsync(Byte[],Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "将 UDP 数据报异步发送到远程主机。"
  remarks: "此重载将数据报发送到中建立的远程主机<xref:System.Net.Sockets.UdpClient.Connect%2A>方法。</xref:System.Net.Sockets.UdpClient.Connect%2A> 如果不调用<xref:System.Net.Sockets.UdpClient.Connect%2A>之前调用此重载，该方法将引发一种<xref:System.Net.Sockets.SocketException>。</xref:System.Net.Sockets.SocketException> </xref:System.Net.Sockets.UdpClient.Connect%2A> 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>以获得特定错误代码。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException> 一旦你已获得此代码，你可以引用的 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。       如果你想要将数据报发送到不同的远程主机，则必须调用<xref:System.Net.Sockets.UdpClient.Connect%2A>方法并指定所需的远程主机。</xref:System.Net.Sockets.UdpClient.Connect%2A> 使用其他<xref:System.Net.Sockets.UdpClient.SendAsync%2A>方法重载来为广播地址发送数据报。</xref:System.Net.Sockets.UdpClient.SendAsync%2A>"
  syntax:
    content: public System.Threading.Tasks.Task<int> SendAsync (byte[] datagram, int bytes);
    parameters:
    - id: datagram
      type: System.Byte[]
      description: "类型的数组<xref:System.Byte>，它指定你打算发送的 UDP 数据报表示作为字节数组。</xref:System.Byte>"
    - id: bytes
      type: System.Int32
      description: "数据报中的字节数。"
    return:
      type: System.Threading.Tasks.Task{System.Int32}
      description: "返回&lt;xref:System.Threading.Tasks.Task%601&gt;。"
  overload: System.Net.Sockets.UdpClient.SendAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>dgram</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Net.Sockets.UdpClient&quot;> </xref>已建立默认远程主机。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.UdpClient&quot;> </xref>已关闭。"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "访问套接字时出错。 请参阅备注部分以了解更多信息。"
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.SendAsync(System.Byte[],System.Int32,System.Net.IPEndPoint)
  id: SendAsync(System.Byte[],System.Int32,System.Net.IPEndPoint)
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: SendAsync(Byte[],Int32,IPEndPoint)
  nameWithType: UdpClient.SendAsync(Byte[],Int32,IPEndPoint)
  fullName: System.Net.Sockets.UdpClient.SendAsync(Byte[],Int32,IPEndPoint)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "将 UDP 数据报异步发送到远程主机。"
  remarks: "此方法将数据报发送到指定的终结点。 之前调用此重载，你必须首先创建<xref:System.Net.IPEndPoint>使用将向其传递你的数据报的远程主机的 IP 地址和端口号。</xref:System.Net.IPEndPoint> 你可以通过<xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>为<xref:System.Net.IPAddress.Address%2A><xref:System.Net.IPEndPoint>.</xref:System.Net.IPEndPoint>属性</xref:System.Net.IPAddress.Address%2A></xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>指定数据报发送到默认广播地址，255.255.255.255， 创建此后<xref:System.Net.IPEndPoint>，将其传递给此方法作为`endPoint`参数。</xref:System.Net.IPEndPoint>       如果你想要将数据报发送到任何其他广播地址，使用<xref:System.Net.Sockets.UdpClient.Client%2A>方法来获取基础<xref:System.Net.Sockets.Socket>，并将设置到<xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>。</xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>的套接字选项</xref:System.Net.Sockets.Socket></xref:System.Net.Sockets.UdpClient.Client%2A> 你还可以还原到使用<xref:System.Net.Sockets.Socket>类。</xref:System.Net.Sockets.Socket>      1> [!WARNING]&1;> 不提供`endPoint`此方法如果你已建立与远程主机参数<xref:System.Net.Sockets.UdpClient.Connect%2A>方法。</xref:System.Net.Sockets.UdpClient.Connect%2A> 否则，此方法将引发一种<xref:System.Net.Sockets.SocketException>。</xref:System.Net.Sockets.SocketException> 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>以获得特定错误代码。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException> 一旦你已获得此代码，你可以引用的 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。"
  syntax:
    content: public System.Threading.Tasks.Task<int> SendAsync (byte[] datagram, int bytes, System.Net.IPEndPoint endPoint);
    parameters:
    - id: datagram
      type: System.Byte[]
      description: "类型的数组<xref:System.Byte>，它指定你打算发送的 UDP 数据报表示作为字节数组。</xref:System.Byte>"
    - id: bytes
      type: System.Int32
      description: "数据报中的字节数。"
    - id: endPoint
      type: System.Net.IPEndPoint
      description: "<xref:System.Net.IPEndPoint>，表示主机和要将数据报发送到的端口。</xref:System.Net.IPEndPoint>"
    return:
      type: System.Threading.Tasks.Task{System.Int32}
      description: "返回&lt;xref:System.Threading.Tasks.Task%601&gt;。"
  overload: System.Net.Sockets.UdpClient.SendAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>dgram</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Net.Sockets.UdpClient&quot;></xref>已建立默认远程主机。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.UdpClient&quot;></xref>已关闭。"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "访问套接字时出错。 请参阅备注部分以了解更多信息。"
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.SendAsync(System.Byte[],System.Int32,System.String,System.Int32)
  id: SendAsync(System.Byte[],System.Int32,System.String,System.Int32)
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: SendAsync(Byte[],Int32,String,Int32)
  nameWithType: UdpClient.SendAsync(Byte[],Int32,String,Int32)
  fullName: System.Net.Sockets.UdpClient.SendAsync(Byte[],Int32,String,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "将 UDP 数据报异步发送到远程主机。"
  remarks: "此方法将数据报发送到指定的值`hostname`和`port`参数。 您可以向默认广播地址发送数据报，通过为指定&quot;255.255.255.255&quot;`hostname`参数值。       如果你想要将数据报发送到任何其他广播地址，使用<xref:System.Net.Sockets.UdpClient.Client%2A>方法来获取基础<xref:System.Net.Sockets.Socket>，并将设置到<xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>。</xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>的套接字选项</xref:System.Net.Sockets.Socket></xref:System.Net.Sockets.UdpClient.Client%2A> 你还可以还原到使用<xref:System.Net.Sockets.Socket>类。</xref:System.Net.Sockets.Socket>      1> [!WARNING]&1;> 不提供主机名或端口号对此方法，如果你已建立与远程主机<xref:System.Net.Sockets.UdpClient.Connect%2A>方法。</xref:System.Net.Sockets.UdpClient.Connect%2A> 否则，此方法将引发一种<xref:System.Net.Sockets.SocketException>。</xref:System.Net.Sockets.SocketException> 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>以获得特定错误代码。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException> 一旦你已获得此代码，你可以引用的 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。"
  syntax:
    content: public System.Threading.Tasks.Task<int> SendAsync (byte[] datagram, int bytes, string hostname, int port);
    parameters:
    - id: datagram
      type: System.Byte[]
      description: "类型的数组<xref:System.Byte>，它指定你打算发送的 UDP 数据报表示作为字节数组。</xref:System.Byte>"
    - id: bytes
      type: System.Int32
      description: "数据报中的字节数。"
    - id: hostname
      type: System.String
      description: "你打算发送数据报的远程主机的名称。"
    - id: port
      type: System.Int32
      description: "你打算与之通信的远程端口号。"
    return:
      type: System.Threading.Tasks.Task{System.Int32}
      description: "返回&lt;xref:System.Threading.Tasks.Task%601&gt;。"
  overload: System.Net.Sockets.UdpClient.SendAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>dgram</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Net.Sockets.UdpClient&quot;> </xref>已建立默认远程主机。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.UdpClient&quot;> </xref>已关闭。"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "访问套接字时出错。 请参阅备注部分以了解更多信息。"
  platform:
  - net462
- uid: System.Net.Sockets.UdpClient.Ttl
  id: Ttl
  parent: System.Net.Sockets.UdpClient
  langs:
  - csharp
  name: Ttl
  nameWithType: UdpClient.Ttl
  fullName: System.Net.Sockets.UdpClient.Ttl
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "获取或设置一个值，指定的时间 (TTL) 值的 Internet 协议 (IP) 数据包发送<xref href=&quot;System.Net.Sockets.UdpClient&quot;> </xref>。"
  remarks: "TTL 值指示的路由器数据包可以遍历路由器放弃数据包和 Internet 控制消息协议 (ICMP)&quot;TTL 超出&quot;之前的最大数目的错误消息返回到发件人。"
  example:
  - "The following code example shows the use of the Ttl property.  \n  \n [!code-cs[System.Net.Sockets.UdpClient#5](~/add/codesnippet/csharp/p-system.net.sockets.udp_6_1.cs)]\n [!code-cpp[System.Net.Sockets.UdpClient#5](~/add/codesnippet/cpp/p-system.net.sockets.udp_6_1.cpp)]"
  syntax:
    content: public short Ttl { get; set; }
    return:
      type: System.Int16
      description: "TTL 值。"
  overload: System.Net.Sockets.UdpClient.Ttl*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Net.Sockets.SocketException
  isExternal: true
  name: System.Net.Sockets.SocketException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Net.Sockets.UdpClient.#ctor
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: UdpClient()
  nameWithType: UdpClient.UdpClient()
  fullName: System.Net.Sockets.UdpClient.UdpClient()
- uid: System.Net.Sockets.UdpClient.#ctor(System.Int32)
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: UdpClient(Int32)
  nameWithType: UdpClient.UdpClient(Int32)
  fullName: System.Net.Sockets.UdpClient.UdpClient(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Net.Sockets.UdpClient.#ctor(System.Net.IPEndPoint)
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: UdpClient(IPEndPoint)
  nameWithType: UdpClient.UdpClient(IPEndPoint)
  fullName: System.Net.Sockets.UdpClient.UdpClient(IPEndPoint)
- uid: System.Net.IPEndPoint
  parent: System.Net
  isExternal: true
  name: IPEndPoint
  nameWithType: IPEndPoint
  fullName: System.Net.IPEndPoint
- uid: System.Net.Sockets.UdpClient.#ctor(System.Net.Sockets.AddressFamily)
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: UdpClient(AddressFamily)
  nameWithType: UdpClient.UdpClient(AddressFamily)
  fullName: System.Net.Sockets.UdpClient.UdpClient(AddressFamily)
- uid: System.Net.Sockets.AddressFamily
  parent: System.Net.Sockets
  isExternal: true
  name: AddressFamily
  nameWithType: AddressFamily
  fullName: System.Net.Sockets.AddressFamily
- uid: System.Net.Sockets.UdpClient.#ctor(System.Int32,System.Net.Sockets.AddressFamily)
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: UdpClient(Int32,AddressFamily)
  nameWithType: UdpClient.UdpClient(Int32,AddressFamily)
  fullName: System.Net.Sockets.UdpClient.UdpClient(Int32,AddressFamily)
- uid: System.Net.Sockets.UdpClient.#ctor(System.String,System.Int32)
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: UdpClient(String,Int32)
  nameWithType: UdpClient.UdpClient(String,Int32)
  fullName: System.Net.Sockets.UdpClient.UdpClient(String,Int32)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Net.Sockets.UdpClient.Active
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: Active
  nameWithType: UdpClient.Active
  fullName: System.Net.Sockets.UdpClient.Active
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: AllowNatTraversal(Boolean)
  nameWithType: UdpClient.AllowNatTraversal(Boolean)
  fullName: System.Net.Sockets.UdpClient.AllowNatTraversal(Boolean)
- uid: System.Net.Sockets.UdpClient.Available
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: Available
  nameWithType: UdpClient.Available
  fullName: System.Net.Sockets.UdpClient.Available
- uid: System.Net.Sockets.UdpClient.BeginReceive(System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: BeginReceive(AsyncCallback,Object)
  nameWithType: UdpClient.BeginReceive(AsyncCallback,Object)
  fullName: System.Net.Sockets.UdpClient.BeginReceive(AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Net.Sockets.UdpClient.BeginSend(System.Byte[],System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: BeginSend(Byte[],Int32,AsyncCallback,Object)
  nameWithType: UdpClient.BeginSend(Byte[],Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.UdpClient.BeginSend(Byte[],Int32,AsyncCallback,Object)
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Net.Sockets.UdpClient.BeginSend(System.Byte[],System.Int32,System.Net.IPEndPoint,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: BeginSend(Byte[],Int32,IPEndPoint,AsyncCallback,Object)
  nameWithType: UdpClient.BeginSend(Byte[],Int32,IPEndPoint,AsyncCallback,Object)
  fullName: System.Net.Sockets.UdpClient.BeginSend(Byte[],Int32,IPEndPoint,AsyncCallback,Object)
- uid: System.Net.Sockets.UdpClient.BeginSend(System.Byte[],System.Int32,System.String,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: BeginSend(Byte[],Int32,String,Int32,AsyncCallback,Object)
  nameWithType: UdpClient.BeginSend(Byte[],Int32,String,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.UdpClient.BeginSend(Byte[],Int32,String,Int32,AsyncCallback,Object)
- uid: System.Net.Sockets.UdpClient.Client
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: Client
  nameWithType: UdpClient.Client
  fullName: System.Net.Sockets.UdpClient.Client
- uid: System.Net.Sockets.Socket
  parent: System.Net.Sockets
  isExternal: true
  name: Socket
  nameWithType: Socket
  fullName: System.Net.Sockets.Socket
- uid: System.Net.Sockets.UdpClient.Close
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: Close()
  nameWithType: UdpClient.Close()
  fullName: System.Net.Sockets.UdpClient.Close()
- uid: System.Net.Sockets.UdpClient.Connect(System.Net.IPEndPoint)
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: Connect(IPEndPoint)
  nameWithType: UdpClient.Connect(IPEndPoint)
  fullName: System.Net.Sockets.UdpClient.Connect(IPEndPoint)
- uid: System.Net.Sockets.UdpClient.Connect(System.Net.IPAddress,System.Int32)
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: Connect(IPAddress,Int32)
  nameWithType: UdpClient.Connect(IPAddress,Int32)
  fullName: System.Net.Sockets.UdpClient.Connect(IPAddress,Int32)
- uid: System.Net.IPAddress
  parent: System.Net
  isExternal: true
  name: IPAddress
  nameWithType: IPAddress
  fullName: System.Net.IPAddress
- uid: System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: Connect(String,Int32)
  nameWithType: UdpClient.Connect(String,Int32)
  fullName: System.Net.Sockets.UdpClient.Connect(String,Int32)
- uid: System.Net.Sockets.UdpClient.Dispose
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: Dispose()
  nameWithType: UdpClient.Dispose()
  fullName: System.Net.Sockets.UdpClient.Dispose()
- uid: System.Net.Sockets.UdpClient.Dispose(System.Boolean)
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: UdpClient.Dispose(Boolean)
  fullName: System.Net.Sockets.UdpClient.Dispose(Boolean)
- uid: System.Net.Sockets.UdpClient.DontFragment
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: DontFragment
  nameWithType: UdpClient.DontFragment
  fullName: System.Net.Sockets.UdpClient.DontFragment
- uid: System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress)
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: DropMulticastGroup(IPAddress)
  nameWithType: UdpClient.DropMulticastGroup(IPAddress)
  fullName: System.Net.Sockets.UdpClient.DropMulticastGroup(IPAddress)
- uid: System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress,System.Int32)
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: DropMulticastGroup(IPAddress,Int32)
  nameWithType: UdpClient.DropMulticastGroup(IPAddress,Int32)
  fullName: System.Net.Sockets.UdpClient.DropMulticastGroup(IPAddress,Int32)
- uid: System.Net.Sockets.UdpClient.EnableBroadcast
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: EnableBroadcast
  nameWithType: UdpClient.EnableBroadcast
  fullName: System.Net.Sockets.UdpClient.EnableBroadcast
- uid: System.Net.Sockets.UdpClient.EndReceive(System.IAsyncResult,System.Net.IPEndPoint@)
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: EndReceive(IAsyncResult,IPEndPoint)
  nameWithType: UdpClient.EndReceive(IAsyncResult,IPEndPoint)
  fullName: System.Net.Sockets.UdpClient.EndReceive(IAsyncResult,IPEndPoint)
- uid: System.Net.Sockets.UdpClient.EndSend(System.IAsyncResult)
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: EndSend(IAsyncResult)
  nameWithType: UdpClient.EndSend(IAsyncResult)
  fullName: System.Net.Sockets.UdpClient.EndSend(IAsyncResult)
- uid: System.Net.Sockets.UdpClient.ExclusiveAddressUse
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: ExclusiveAddressUse
  nameWithType: UdpClient.ExclusiveAddressUse
  fullName: System.Net.Sockets.UdpClient.ExclusiveAddressUse
- uid: System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress)
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: JoinMulticastGroup(IPAddress)
  nameWithType: UdpClient.JoinMulticastGroup(IPAddress)
  fullName: System.Net.Sockets.UdpClient.JoinMulticastGroup(IPAddress)
- uid: System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Int32,System.Net.IPAddress)
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: JoinMulticastGroup(Int32,IPAddress)
  nameWithType: UdpClient.JoinMulticastGroup(Int32,IPAddress)
  fullName: System.Net.Sockets.UdpClient.JoinMulticastGroup(Int32,IPAddress)
- uid: System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress,System.Int32)
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: JoinMulticastGroup(IPAddress,Int32)
  nameWithType: UdpClient.JoinMulticastGroup(IPAddress,Int32)
  fullName: System.Net.Sockets.UdpClient.JoinMulticastGroup(IPAddress,Int32)
- uid: System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress,System.Net.IPAddress)
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: JoinMulticastGroup(IPAddress,IPAddress)
  nameWithType: UdpClient.JoinMulticastGroup(IPAddress,IPAddress)
  fullName: System.Net.Sockets.UdpClient.JoinMulticastGroup(IPAddress,IPAddress)
- uid: System.Net.Sockets.UdpClient.MulticastLoopback
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: MulticastLoopback
  nameWithType: UdpClient.MulticastLoopback
  fullName: System.Net.Sockets.UdpClient.MulticastLoopback
- uid: System.Net.Sockets.UdpClient.Receive(System.Net.IPEndPoint@)
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: Receive(IPEndPoint)
  nameWithType: UdpClient.Receive(IPEndPoint)
  fullName: System.Net.Sockets.UdpClient.Receive(IPEndPoint)
- uid: System.Net.Sockets.UdpClient.ReceiveAsync
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: ReceiveAsync()
  nameWithType: UdpClient.ReceiveAsync()
  fullName: System.Net.Sockets.UdpClient.ReceiveAsync()
- uid: System.Threading.Tasks.Task{System.Net.Sockets.UdpReceiveResult}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<UdpReceiveResult>
  nameWithType: Task<UdpReceiveResult>
  fullName: System.Threading.Tasks.Task<System.Net.Sockets.UdpReceiveResult>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Net.Sockets.UdpReceiveResult>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Net.Sockets.UdpReceiveResult
    name: UdpReceiveResult
    nameWithType: UdpReceiveResult
    fullName: UdpReceiveResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32)
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: Send(Byte[],Int32)
  nameWithType: UdpClient.Send(Byte[],Int32)
  fullName: System.Net.Sockets.UdpClient.Send(Byte[],Int32)
- uid: System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: Send(Byte[],Int32,IPEndPoint)
  nameWithType: UdpClient.Send(Byte[],Int32,IPEndPoint)
  fullName: System.Net.Sockets.UdpClient.Send(Byte[],Int32,IPEndPoint)
- uid: System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.String,System.Int32)
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: Send(Byte[],Int32,String,Int32)
  nameWithType: UdpClient.Send(Byte[],Int32,String,Int32)
  fullName: System.Net.Sockets.UdpClient.Send(Byte[],Int32,String,Int32)
- uid: System.Net.Sockets.UdpClient.SendAsync(System.Byte[],System.Int32)
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: SendAsync(Byte[],Int32)
  nameWithType: UdpClient.SendAsync(Byte[],Int32)
  fullName: System.Net.Sockets.UdpClient.SendAsync(Byte[],Int32)
- uid: System.Threading.Tasks.Task{System.Int32}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<Int32>
  nameWithType: Task<Int32>
  fullName: System.Threading.Tasks.Task<System.Int32>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Int32>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Net.Sockets.UdpClient.SendAsync(System.Byte[],System.Int32,System.Net.IPEndPoint)
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: SendAsync(Byte[],Int32,IPEndPoint)
  nameWithType: UdpClient.SendAsync(Byte[],Int32,IPEndPoint)
  fullName: System.Net.Sockets.UdpClient.SendAsync(Byte[],Int32,IPEndPoint)
- uid: System.Net.Sockets.UdpClient.SendAsync(System.Byte[],System.Int32,System.String,System.Int32)
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: SendAsync(Byte[],Int32,String,Int32)
  nameWithType: UdpClient.SendAsync(Byte[],Int32,String,Int32)
  fullName: System.Net.Sockets.UdpClient.SendAsync(Byte[],Int32,String,Int32)
- uid: System.Net.Sockets.UdpClient.Ttl
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: Ttl
  nameWithType: UdpClient.Ttl
  fullName: System.Net.Sockets.UdpClient.Ttl
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: System.Net.Sockets.UdpClient.#ctor*
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: UdpClient
  nameWithType: UdpClient.UdpClient
- uid: System.Net.Sockets.UdpClient.Active*
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: Active
  nameWithType: UdpClient.Active
- uid: System.Net.Sockets.UdpClient.AllowNatTraversal*
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: AllowNatTraversal
  nameWithType: UdpClient.AllowNatTraversal
- uid: System.Net.Sockets.UdpClient.Available*
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: Available
  nameWithType: UdpClient.Available
- uid: System.Net.Sockets.UdpClient.BeginReceive*
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: BeginReceive
  nameWithType: UdpClient.BeginReceive
- uid: System.Net.Sockets.UdpClient.BeginSend*
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: BeginSend
  nameWithType: UdpClient.BeginSend
- uid: System.Net.Sockets.UdpClient.Client*
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: Client
  nameWithType: UdpClient.Client
- uid: System.Net.Sockets.UdpClient.Close*
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: Close
  nameWithType: UdpClient.Close
- uid: System.Net.Sockets.UdpClient.Connect*
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: Connect
  nameWithType: UdpClient.Connect
- uid: System.Net.Sockets.UdpClient.Dispose*
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: Dispose
  nameWithType: UdpClient.Dispose
- uid: System.Net.Sockets.UdpClient.DontFragment*
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: DontFragment
  nameWithType: UdpClient.DontFragment
- uid: System.Net.Sockets.UdpClient.DropMulticastGroup*
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: DropMulticastGroup
  nameWithType: UdpClient.DropMulticastGroup
- uid: System.Net.Sockets.UdpClient.EnableBroadcast*
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: EnableBroadcast
  nameWithType: UdpClient.EnableBroadcast
- uid: System.Net.Sockets.UdpClient.EndReceive*
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: EndReceive
  nameWithType: UdpClient.EndReceive
- uid: System.Net.Sockets.UdpClient.EndSend*
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: EndSend
  nameWithType: UdpClient.EndSend
- uid: System.Net.Sockets.UdpClient.ExclusiveAddressUse*
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: ExclusiveAddressUse
  nameWithType: UdpClient.ExclusiveAddressUse
- uid: System.Net.Sockets.UdpClient.JoinMulticastGroup*
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: JoinMulticastGroup
  nameWithType: UdpClient.JoinMulticastGroup
- uid: System.Net.Sockets.UdpClient.MulticastLoopback*
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: MulticastLoopback
  nameWithType: UdpClient.MulticastLoopback
- uid: System.Net.Sockets.UdpClient.Receive*
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: Receive
  nameWithType: UdpClient.Receive
- uid: System.Net.Sockets.UdpClient.ReceiveAsync*
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: ReceiveAsync
  nameWithType: UdpClient.ReceiveAsync
- uid: System.Net.Sockets.UdpClient.Send*
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: Send
  nameWithType: UdpClient.Send
- uid: System.Net.Sockets.UdpClient.SendAsync*
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: SendAsync
  nameWithType: UdpClient.SendAsync
- uid: System.Net.Sockets.UdpClient.Ttl*
  parent: System.Net.Sockets.UdpClient
  isExternal: false
  name: Ttl
  nameWithType: UdpClient.Ttl
