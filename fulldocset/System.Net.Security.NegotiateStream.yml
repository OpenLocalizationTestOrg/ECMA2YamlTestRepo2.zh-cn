### YamlMime:ManagedReference
items:
- uid: System.Net.Security.NegotiateStream
  id: NegotiateStream
  children:
  - System.Net.Security.NegotiateStream.#ctor(System.IO.Stream)
  - System.Net.Security.NegotiateStream.#ctor(System.IO.Stream,System.Boolean)
  - System.Net.Security.NegotiateStream.AuthenticateAsClient
  - System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.String)
  - System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)
  - System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  - System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  - System.Net.Security.NegotiateStream.AuthenticateAsClientAsync
  - System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String)
  - System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)
  - System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  - System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  - System.Net.Security.NegotiateStream.AuthenticateAsServer
  - System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)
  - System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  - System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  - System.Net.Security.NegotiateStream.AuthenticateAsServerAsync
  - System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)
  - System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  - System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  - System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.AsyncCallback,System.Object)
  - System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.AsyncCallback,System.Object)
  - System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.AsyncCallback,System.Object)
  - System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  - System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  - System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.AsyncCallback,System.Object)
  - System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.AsyncCallback,System.Object)
  - System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  - System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  - System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.Net.Security.NegotiateStream.CanRead
  - System.Net.Security.NegotiateStream.CanSeek
  - System.Net.Security.NegotiateStream.CanTimeout
  - System.Net.Security.NegotiateStream.CanWrite
  - System.Net.Security.NegotiateStream.Dispose(System.Boolean)
  - System.Net.Security.NegotiateStream.EndAuthenticateAsClient(System.IAsyncResult)
  - System.Net.Security.NegotiateStream.EndAuthenticateAsServer(System.IAsyncResult)
  - System.Net.Security.NegotiateStream.EndRead(System.IAsyncResult)
  - System.Net.Security.NegotiateStream.EndWrite(System.IAsyncResult)
  - System.Net.Security.NegotiateStream.Flush
  - System.Net.Security.NegotiateStream.ImpersonationLevel
  - System.Net.Security.NegotiateStream.IsAuthenticated
  - System.Net.Security.NegotiateStream.IsEncrypted
  - System.Net.Security.NegotiateStream.IsMutuallyAuthenticated
  - System.Net.Security.NegotiateStream.IsServer
  - System.Net.Security.NegotiateStream.IsSigned
  - System.Net.Security.NegotiateStream.Length
  - System.Net.Security.NegotiateStream.Position
  - System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.Net.Security.NegotiateStream.ReadTimeout
  - System.Net.Security.NegotiateStream.RemoteIdentity
  - System.Net.Security.NegotiateStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.Net.Security.NegotiateStream.SetLength(System.Int64)
  - System.Net.Security.NegotiateStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.Net.Security.NegotiateStream.WriteTimeout
  langs:
  - csharp
  name: NegotiateStream
  nameWithType: NegotiateStream
  fullName: System.Net.Security.NegotiateStream
  type: Class
  summary: "提供使用 Negotiate 安全协议进行身份验证客户端，和 （可选） 服务器上的，在客户端服务器通信的流。"
  remarks: "身份验证和协助保护客户端和服务器之间传输的信息，请使用 NegotiateStream 类。 使用 NegotiateStream，你可以执行以下操作。      -客户端的凭据向服务器发送的模拟或委托。      -请求服务器进行身份验证。      -加密和/或签名前将其传输的数据。       在将信息传输之前，必须执行身份验证。 客户端请求进行身份验证使用同步<xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>方法，身份验证完成之前阻止，或异步<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>方法，不会阻止等待身份验证完成时。</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> </xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> 服务器请求进行身份验证使用同步<xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>或异步<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>方法。</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> </xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> 客户端和服务器上，（可选） 进行身份验证使用 Negotiate 安全协议。 在 Windows 95/98 系统中，Windows NT LAN Manager (NTLM) 是用于身份验证的协议。 在 Kerberos 其他平台上使用协议进行身份验证客户端和服务器支持它; 如果否则使用 NTLM。 这些协议的详细说明，请参阅平台 SDK 文档 MSDN 上，在 msdn.microsoft.com/library/。 NegotiateStream 类执行使用安全支持提供程序接口 (SSPI) 身份验证。       当身份验证成功时，必须检查<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>和<xref:System.Net.Security.NegotiateStream.IsSigned%2A>属性来确定哪些安全服务将使用通过 NegotiateStream，来帮助保护你的数据在传输过程。</xref:System.Net.Security.NegotiateStream.IsSigned%2A> </xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> 检查<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>属性以确定是否发生了相互身份验证。</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> 你可以获取有关远程客户端或服务器使用信息<xref:System.Net.Security.NegotiateStream.RemoteIdentity%2A>属性。</xref:System.Net.Security.NegotiateStream.RemoteIdentity%2A>       如果身份验证失败，你将收到一个<xref:System.Security.Authentication.AuthenticationException>或一种<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> 在这种情况下，你可以重试使用不同的凭据进行身份验证。       你将使用同步的数据发送<xref:System.Net.Security.NegotiateStream.Write%2A>或异步<xref:System.Net.Security.NegotiateStream.BeginWrite%2A>方法。</xref:System.Net.Security.NegotiateStream.BeginWrite%2A> </xref:System.Net.Security.NegotiateStream.Write%2A> 接收数据的数据使用同步<xref:System.Net.Security.NegotiateStream.Read%2A>或异步<xref:System.Net.Security.NegotiateStream.BeginRead%2A>方法。</xref:System.Net.Security.NegotiateStream.BeginRead%2A> </xref:System.Net.Security.NegotiateStream.Read%2A> 如果安全服务 （如启用加密或签名），这些将自动应用于你的数据，通过 NegotiateStream。       NegotiateStream 将使用在创建 NegotiateStream 时提供的流的数据传输。 提供此基础流，必须指定是否关闭 NegotiateStream 也将关闭基础流的选项。"
  example:
  - "The following code example demonstrates the client side of a client-server connection that uses the NegotiateStream. The client authenticates and sends a message to the server asynchronously.  \n  \n [!code-cpp[NclNegoAsyncClient#0](~/add/codesnippet/cpp/t-system.net.security.ne_1.cpp)]\n [!code-cs[NclNegoAsyncClient#0](~/add/codesnippet/csharp/t-system.net.security.ne_1.cs)]  \n  \n The following code example demonstrates the server side of a client-server connection that uses the NegotiateStream to authenticate the client and read a message sent by the client.  \n  \n [!code-cs[NclNegoAsyncServer#0](~/add/codesnippet/csharp/t-system.net.security.ne_2.cs)]\n [!code-cpp[NclNegoAsyncServer#0](~/add/codesnippet/cpp/t-system.net.security.ne_2.cpp)]"
  syntax:
    content: 'public class NegotiateStream : System.Net.Security.AuthenticatedStream'
  inheritance:
  - System.IO.Stream
  - System.Net.Security.AuthenticatedStream
  implements: []
  inheritedMembers:
  - System.Net.Security.AuthenticatedStream.InnerStream
  - System.Net.Security.AuthenticatedStream.LeaveInnerStreamOpen
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.#ctor(System.IO.Stream)
  id: '#ctor(System.IO.Stream)'
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: NegotiateStream(Stream)
  nameWithType: NegotiateStream.NegotiateStream(Stream)
  fullName: System.Net.Security.NegotiateStream.NegotiateStream(Stream)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "初始化的新实例<xref href=&quot;System.Net.Security.NegotiateStream&quot;></xref>类使用的指定<xref:System.IO.Stream>。</xref:System.IO.Stream>"
  remarks: ''
  example:
  - "The following code example demonstrates calling this constructor.  \n  \n [!code-cs[NclNegoSyncClient#3](~/add/codesnippet/csharp/m-system.net.security.ne_1_1.cs)]\n [!code-cpp[NclNegoSyncClient#3](~/add/codesnippet/cpp/m-system.net.security.ne_1_1.cpp)]"
  syntax:
    content: public NegotiateStream (System.IO.Stream innerStream);
    parameters:
    - id: innerStream
      type: System.IO.Stream
      description: "A<xref:System.IO.Stream>使用对象<xref href=&quot;System.Net.Security.NegotiateStream&quot;></xref>用于发送和接收数据。</xref:System.IO.Stream>"
  overload: System.Net.Security.NegotiateStream.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.#ctor(System.IO.Stream,System.Boolean)
  id: '#ctor(System.IO.Stream,System.Boolean)'
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: NegotiateStream(Stream,Boolean)
  nameWithType: NegotiateStream.NegotiateStream(Stream,Boolean)
  fullName: System.Net.Security.NegotiateStream.NegotiateStream(Stream,Boolean)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "初始化的新实例<xref href=&quot;System.Net.Security.NegotiateStream&quot;></xref>类使用指定<xref:System.IO.Stream>和流封闭行为。</xref:System.IO.Stream>"
  remarks: "当指定`true`为`leaveStreamOpen`参数，关闭<xref:System.Net.Security.NegotiateStream>不起任何作用`innerStream`流式传输; 您必须显式关闭`innerStream`不再需要它。</xref:System.Net.Security.NegotiateStream>"
  example:
  - "The following code example demonstrates calling this constructor. This code example is part of a larger example provided for the <xref:System.Net.Security.NegotiateStream> class.  \n  \n [!code-cpp[NclNegoAsyncClient#1](~/add/codesnippet/cpp/m-system.net.security.ne_4_1.cpp)]\n [!code-cs[NclNegoAsyncClient#1](~/add/codesnippet/csharp/m-system.net.security.ne_4_1.cs)]"
  syntax:
    content: public NegotiateStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen);
    parameters:
    - id: innerStream
      type: System.IO.Stream
      description: "A<xref:System.IO.Stream>使用对象<xref href=&quot;System.Net.Security.NegotiateStream&quot;></xref>用于发送和接收数据。</xref:System.IO.Stream>"
    - id: leaveInnerStreamOpen
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要指示该关闭此<xref href=&quot;System.Net.Security.NegotiateStream&quot;></xref>不起任何作用`innerstream`;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>以指示该关闭此<xref href=&quot;System.Net.Security.NegotiateStream&quot;></xref>也会关闭`innerStream`。 请参阅备注部分以了解更多信息。"
  overload: System.Net.Security.NegotiateStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>innerStream</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>innerStream</code> is equal to <xref:System.IO.Stream.Null>."
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClient
  id: AuthenticateAsClient
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsClient()
  nameWithType: NegotiateStream.AuthenticateAsClient()
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClient()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "调用由客户端进行身份验证客户端，和 （可选） 中的客户端-服务器连接的服务器。"
  remarks: "身份验证使用客户端的<xref:System.Net.CredentialCache.DefaultCredentials%2A>.</xref:System.Net.CredentialCache.DefaultCredentials%2A> 为服务器不指定任何服务主体名称 (SPN)。 模拟级别是<xref:System.Security.Principal.TokenImpersonationLevel>，安全级别是<xref:System.Net.Security.ProtectionLevel>，并进行相互身份验证的请求。</xref:System.Net.Security.ProtectionLevel> </xref:System.Security.Principal.TokenImpersonationLevel> <xref:System.Net.Security.NegotiateStream>类将构造用于相互身份验证的 SPN。</xref:System.Net.Security.NegotiateStream>       身份验证成功后，你必须检查<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>和<xref:System.Net.Security.NegotiateStream.IsSigned%2A>属性，以确定由<xref:System.Net.Security.NegotiateStream>.</xref:System.Net.Security.NegotiateStream>使用哪些安全服务</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> 检查<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>属性以确定是否发生了相互身份验证。</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>       如果身份验证失败，你收到的<xref:System.Security.Authentication.AuthenticationException>或<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> 在这种情况下，你可以重试使用不同的凭据进行身份验证。"
  syntax:
    content: public virtual void AuthenticateAsClient ();
    parameters: []
  overload: System.Net.Security.NegotiateStream.AuthenticateAsClient*
  exceptions:
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此对象已关闭。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client."
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.String)
  id: AuthenticateAsClient(System.Net.NetworkCredential,System.String)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsClient(NetworkCredential,String)
  nameWithType: NegotiateStream.AuthenticateAsClient(NetworkCredential,String)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClient(NetworkCredential,String)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "调用由客户端进行身份验证客户端，和 （可选） 中的客户端-服务器连接的服务器。 身份验证过程使用指定的客户端凭据。"
  remarks: "模拟级别是<xref:System.Security.Principal.TokenImpersonationLevel>，安全级别是<xref:System.Net.Security.ProtectionLevel>，并进行相互身份验证的请求。</xref:System.Net.Security.ProtectionLevel> </xref:System.Security.Principal.TokenImpersonationLevel> <xref:System.Net.Security.NegotiateStream>类将构造用于相互身份验证的 SPN。</xref:System.Net.Security.NegotiateStream>       身份验证成功后，你必须检查<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>和<xref:System.Net.Security.NegotiateStream.IsSigned%2A>属性，以确定由<xref:System.Net.Security.NegotiateStream>.</xref:System.Net.Security.NegotiateStream>使用哪些安全服务</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> 检查<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>属性以确定是否发生了相互身份验证。</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>"
  syntax:
    content: public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, string targetName);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>，使用后者来建立客户端的标识。</xref:System.Net.NetworkCredential>"
    - id: targetName
      type: System.String
      description: "唯一标识服务器进行身份验证服务主体名称 (SPN)。"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsClient*
  exceptions:
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此对象已关闭。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>targetName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)
  id: AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsClient(NetworkCredential,ChannelBinding,String)
  nameWithType: NegotiateStream.AuthenticateAsClient(NetworkCredential,ChannelBinding,String)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClient(NetworkCredential,ChannelBinding,String)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "调用由客户端进行身份验证客户端，和 （可选） 中的客户端-服务器连接的服务器。 身份验证过程使用指定的客户端凭据和渠道绑定。"
  remarks: "模拟级别是<xref:System.Security.Principal.TokenImpersonationLevel>，安全级别是<xref:System.Net.Security.ProtectionLevel>，并进行相互身份验证的请求。</xref:System.Net.Security.ProtectionLevel> </xref:System.Security.Principal.TokenImpersonationLevel> <xref:System.Net.Security.NegotiateStream>类将构造用于相互身份验证的 SPN。</xref:System.Net.Security.NegotiateStream>       <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>用于传递给此方法的扩展保护`binding`参数将检索应用程序从<xref:System.Net.Security.SslStream.TransportContext%2A>属性的关联<xref:System.Net.Security.SslStream>。</xref:System.Net.Security.SslStream> </xref:System.Net.Security.SslStream.TransportContext%2A> </xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>       身份验证成功后，你必须检查<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>和<xref:System.Net.Security.NegotiateStream.IsSigned%2A>属性，以确定由<xref:System.Net.Security.NegotiateStream>.</xref:System.Net.Security.NegotiateStream>使用哪些安全服务</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> 检查<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>属性以确定是否发生了相互身份验证。</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>"
  syntax:
    content: public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>，使用后者来建立客户端的标识。</xref:System.Net.NetworkCredential>"
    - id: binding
      type: System.Security.Authentication.ExtendedProtection.ChannelBinding
      description: "<xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>用于扩展保护。</xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>"
    - id: targetName
      type: System.String
      description: "唯一标识服务器进行身份验证服务主体名称 (SPN)。"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsClient*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>targetName</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>credential</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此对象已关闭。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  id: AuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsClient(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsClient(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClient(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "调用由客户端进行身份验证客户端，和 （可选） 中的客户端-服务器连接的服务器。 身份验证过程使用指定的凭据和身份验证选项。"
  remarks: "使用`requiredProtectionLevel`对的请求安全服务的使用经过身份验证的流传输的数据的参数。 例如，若要让数据进行加密和签名，指定<xref:System.Net.Security.ProtectionLevel>值。</xref:System.Net.Security.ProtectionLevel> 成功通过身份验证并不保证，请求<xref:System.Net.Security.ProtectionLevel>已被授予。</xref:System.Net.Security.ProtectionLevel> 你必须检查<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>和<xref:System.Net.Security.NegotiateStream.IsSigned%2A>属性，以确定由<xref:System.Net.Security.NegotiateStream>.</xref:System.Net.Security.NegotiateStream>使用哪些安全服务</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>       如果身份验证失败，你收到的<xref:System.Security.Authentication.AuthenticationException>或<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> 在这种情况下，你可以重试使用不同的凭据进行身份验证。"
  syntax:
    content: public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>，使用后者来建立客户端的标识。</xref:System.Net.NetworkCredential>"
    - id: targetName
      type: System.String
      description: "唯一标识服务器进行身份验证服务主体名称 (SPN)。"
    - id: requiredProtectionLevel
      type: System.Net.Security.ProtectionLevel
      description: "之一<xref href=&quot;System.Net.Security.ProtectionLevel&quot;></xref>值，该值指示流的安全服务。"
    - id: allowedImpersonationLevel
      type: System.Security.Principal.TokenImpersonationLevel
      description: "之一<xref:System.Security.Principal.TokenImpersonationLevel>值，指示服务器如何使用客户端的凭据以访问资源。</xref:System.Security.Principal.TokenImpersonationLevel>"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsClient*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>allowedImpersonationLevel</code>不是有效的值。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>targetName</code>为 null。"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此对象已关闭。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client."
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  id: AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsClient(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsClient(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClient(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "调用由客户端进行身份验证客户端，和 （可选） 中的客户端-服务器连接的服务器。 身份验证过程使用指定的凭据、 身份验证选项和渠道绑定。"
  remarks: "使用`requiredProtectionLevel`对的请求安全服务的使用经过身份验证的流传输的数据的参数。 例如，若要让数据进行加密和签名，指定<xref:System.Net.Security.ProtectionLevel>值。</xref:System.Net.Security.ProtectionLevel> 成功通过身份验证并不保证，请求<xref:System.Net.Security.ProtectionLevel>已被授予。</xref:System.Net.Security.ProtectionLevel> 你必须检查<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>和<xref:System.Net.Security.NegotiateStream.IsSigned%2A>属性，以确定由<xref:System.Net.Security.NegotiateStream>.</xref:System.Net.Security.NegotiateStream>使用哪些安全服务</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>       <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>用于传递给此方法的扩展保护`binding`参数将检索应用程序从<xref:System.Net.Security.SslStream.TransportContext%2A>属性的关联<xref:System.Net.Security.SslStream>。</xref:System.Net.Security.SslStream> </xref:System.Net.Security.SslStream.TransportContext%2A> </xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>       如果身份验证失败，你收到的<xref:System.Security.Authentication.AuthenticationException>或<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> 在这种情况下，你可以重试使用不同的凭据进行身份验证。"
  syntax:
    content: public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>，使用后者来建立客户端的标识。</xref:System.Net.NetworkCredential>"
    - id: binding
      type: System.Security.Authentication.ExtendedProtection.ChannelBinding
      description: "<xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>用于扩展保护。</xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>"
    - id: targetName
      type: System.String
      description: "唯一标识服务器进行身份验证服务主体名称 (SPN)。"
    - id: requiredProtectionLevel
      type: System.Net.Security.ProtectionLevel
      description: "之一<xref href=&quot;System.Net.Security.ProtectionLevel&quot;></xref>值，该值指示流的安全服务。"
    - id: allowedImpersonationLevel
      type: System.Security.Principal.TokenImpersonationLevel
      description: "之一<xref:System.Security.Principal.TokenImpersonationLevel>值，指示服务器如何使用客户端的凭据以访问资源。</xref:System.Security.Principal.TokenImpersonationLevel>"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsClient*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>targetName</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>credential</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>allowedImpersonationLevel</code>不是有效的值。"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此对象已关闭。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync
  id: AuthenticateAsClientAsync
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsClientAsync()
  nameWithType: NegotiateStream.AuthenticateAsClientAsync()
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "调用由客户端进行身份验证客户端，和 （可选） 中作为异步操作的客户端-服务器连接的服务器。"
  remarks: "身份验证使用客户端的<xref:System.Net.CredentialCache.DefaultCredentials%2A>.</xref:System.Net.CredentialCache.DefaultCredentials%2A> 为服务器不指定任何服务主体名称 (SPN)。 模拟级别是<xref:System.Security.Principal.TokenImpersonationLevel>，安全级别是<xref:System.Net.Security.ProtectionLevel>，并进行相互身份验证的请求。</xref:System.Net.Security.ProtectionLevel> </xref:System.Security.Principal.TokenImpersonationLevel> <xref:System.Net.Security.NegotiateStream>类将构造用于相互身份验证的 SPN。</xref:System.Net.Security.NegotiateStream>       身份验证成功后，你必须检查<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>和<xref:System.Net.Security.NegotiateStream.IsSigned%2A>属性，以确定由<xref:System.Net.Security.NegotiateStream>.</xref:System.Net.Security.NegotiateStream>使用哪些安全服务</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> 检查<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>属性以确定是否发生了相互身份验证。</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>       如果身份验证失败，你收到的<xref:System.Security.Authentication.AuthenticationException>或<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> 在这种情况下，你可以重试使用不同的凭据进行身份验证。"
  syntax:
    content: public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync ();
    parameters: []
    return:
      type: System.Threading.Tasks.Task
      description: "返回<xref:System.Threading.Tasks.Task>表示异步操作的任务对象。</xref:System.Threading.Tasks.Task>"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync*
  exceptions:
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此对象已关闭。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client."
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String)
  id: AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsClientAsync(NetworkCredential,String)
  nameWithType: NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,String)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,String)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "调用由客户端进行身份验证客户端，和 （可选） 中作为异步操作的客户端-服务器连接的服务器。 身份验证过程使用指定的客户端凭据。"
  remarks: "模拟级别是<xref:System.Security.Principal.TokenImpersonationLevel>，安全级别是<xref:System.Net.Security.ProtectionLevel>，并进行相互身份验证的请求。</xref:System.Net.Security.ProtectionLevel> </xref:System.Security.Principal.TokenImpersonationLevel> <xref:System.Net.Security.NegotiateStream>类将构造用于相互身份验证的 SPN。</xref:System.Net.Security.NegotiateStream>       身份验证成功后，你必须检查<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>和<xref:System.Net.Security.NegotiateStream.IsSigned%2A>属性，以确定由<xref:System.Net.Security.NegotiateStream>.</xref:System.Net.Security.NegotiateStream>使用哪些安全服务</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> 检查<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>属性以确定是否发生了相互身份验证。</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>"
  syntax:
    content: public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, string targetName);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>，使用后者来建立客户端的标识。</xref:System.Net.NetworkCredential>"
    - id: targetName
      type: System.String
      description: "唯一标识服务器进行身份验证服务主体名称 (SPN)。"
    return:
      type: System.Threading.Tasks.Task
      description: "返回<xref:System.Threading.Tasks.Task>表示异步操作的任务对象。</xref:System.Threading.Tasks.Task>"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync*
  exceptions:
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此对象已关闭。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>targetName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)
  id: AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsClientAsync(NetworkCredential,ChannelBinding,String)
  nameWithType: NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,ChannelBinding,String)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,ChannelBinding,String)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "调用由客户端进行身份验证客户端，和 （可选） 中作为异步操作的客户端-服务器连接的服务器。 身份验证过程使用指定的客户端凭据和渠道绑定。"
  remarks: "模拟级别是<xref:System.Security.Principal.TokenImpersonationLevel>，安全级别是<xref:System.Net.Security.ProtectionLevel>，并进行相互身份验证的请求。</xref:System.Net.Security.ProtectionLevel> </xref:System.Security.Principal.TokenImpersonationLevel> <xref:System.Net.Security.NegotiateStream>类将构造用于相互身份验证的 SPN。</xref:System.Net.Security.NegotiateStream>       <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>用于传递给此方法的扩展保护`binding`参数将检索应用程序从<xref:System.Net.Security.SslStream.TransportContext%2A>属性的关联<xref:System.Net.Security.SslStream>。</xref:System.Net.Security.SslStream> </xref:System.Net.Security.SslStream.TransportContext%2A> </xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>       身份验证成功后，你必须检查<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>和<xref:System.Net.Security.NegotiateStream.IsSigned%2A>属性，以确定由<xref:System.Net.Security.NegotiateStream>.</xref:System.Net.Security.NegotiateStream>使用哪些安全服务</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> 检查<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>属性以确定是否发生了相互身份验证。</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>"
  syntax:
    content: public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>，使用后者来建立客户端的标识。</xref:System.Net.NetworkCredential>"
    - id: binding
      type: System.Security.Authentication.ExtendedProtection.ChannelBinding
      description: "<xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>用于扩展保护。</xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>"
    - id: targetName
      type: System.String
      description: "唯一标识服务器进行身份验证服务主体名称 (SPN)。"
    return:
      type: System.Threading.Tasks.Task
      description: "返回<xref:System.Threading.Tasks.Task>表示异步操作的任务对象。</xref:System.Threading.Tasks.Task>"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>targetName</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>credential</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此对象已关闭。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  id: AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsClientAsync(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "调用由客户端进行身份验证客户端，和 （可选） 中作为异步操作的客户端-服务器连接的服务器。 身份验证过程使用指定的凭据和身份验证选项。"
  remarks: "使用`requiredProtectionLevel`对的请求安全服务的使用经过身份验证的流传输的数据的参数。 例如，若要让数据进行加密和签名，指定<xref:System.Net.Security.ProtectionLevel>值。</xref:System.Net.Security.ProtectionLevel> 成功通过身份验证并不保证，请求<xref:System.Net.Security.ProtectionLevel>已被授予。</xref:System.Net.Security.ProtectionLevel> 你必须检查<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>和<xref:System.Net.Security.NegotiateStream.IsSigned%2A>属性，以确定由<xref:System.Net.Security.NegotiateStream>.</xref:System.Net.Security.NegotiateStream>使用哪些安全服务</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>       如果身份验证失败，你收到的<xref:System.Security.Authentication.AuthenticationException>或<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> 在这种情况下，你可以重试使用不同的凭据进行身份验证。"
  syntax:
    content: public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>，使用后者来建立客户端的标识。</xref:System.Net.NetworkCredential>"
    - id: targetName
      type: System.String
      description: "唯一标识服务器进行身份验证服务主体名称 (SPN)。"
    - id: requiredProtectionLevel
      type: System.Net.Security.ProtectionLevel
      description: "之一<xref href=&quot;System.Net.Security.ProtectionLevel&quot;></xref>值，该值指示流的安全服务。"
    - id: allowedImpersonationLevel
      type: System.Security.Principal.TokenImpersonationLevel
      description: "之一<xref:System.Security.Principal.TokenImpersonationLevel>值，指示服务器如何使用客户端的凭据以访问资源。</xref:System.Security.Principal.TokenImpersonationLevel>"
    return:
      type: System.Threading.Tasks.Task
      description: "返回<xref:System.Threading.Tasks.Task>表示异步操作的任务对象。</xref:System.Threading.Tasks.Task>"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>allowedImpersonationLevel</code>不是有效的值。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>targetName</code>为 null。"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此对象已关闭。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client."
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  id: AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsClientAsync(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "调用由客户端进行身份验证客户端，和 （可选） 中作为异步操作的客户端-服务器连接的服务器。 身份验证过程使用指定的凭据、 身份验证选项和渠道绑定。"
  remarks: "使用`requiredProtectionLevel`对的请求安全服务的使用经过身份验证的流传输的数据的参数。 例如，若要让数据进行加密和签名，指定<xref:System.Net.Security.ProtectionLevel>值。</xref:System.Net.Security.ProtectionLevel> 成功通过身份验证并不保证，请求<xref:System.Net.Security.ProtectionLevel>已被授予。</xref:System.Net.Security.ProtectionLevel> 你必须检查<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>和<xref:System.Net.Security.NegotiateStream.IsSigned%2A>属性，以确定由<xref:System.Net.Security.NegotiateStream>.</xref:System.Net.Security.NegotiateStream>使用哪些安全服务</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>       <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>用于传递给此方法的扩展保护`binding`参数将检索应用程序从<xref:System.Net.Security.SslStream.TransportContext%2A>属性的关联<xref:System.Net.Security.SslStream>。</xref:System.Net.Security.SslStream> </xref:System.Net.Security.SslStream.TransportContext%2A> </xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>       如果身份验证失败，你收到的<xref:System.Security.Authentication.AuthenticationException>或<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> 在这种情况下，你可以重试使用不同的凭据进行身份验证。"
  syntax:
    content: public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>，使用后者来建立客户端的标识。</xref:System.Net.NetworkCredential>"
    - id: binding
      type: System.Security.Authentication.ExtendedProtection.ChannelBinding
      description: "<xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>用于扩展保护。</xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>"
    - id: targetName
      type: System.String
      description: "唯一标识服务器进行身份验证服务主体名称 (SPN)。"
    - id: requiredProtectionLevel
      type: System.Net.Security.ProtectionLevel
      description: "之一<xref href=&quot;System.Net.Security.ProtectionLevel&quot;></xref>值，该值指示流的安全服务。"
    - id: allowedImpersonationLevel
      type: System.Security.Principal.TokenImpersonationLevel
      description: "之一<xref:System.Security.Principal.TokenImpersonationLevel>值，指示服务器如何使用客户端的凭据以访问资源。</xref:System.Security.Principal.TokenImpersonationLevel>"
    return:
      type: System.Threading.Tasks.Task
      description: "返回<xref:System.Threading.Tasks.Task>表示异步操作的任务对象。</xref:System.Threading.Tasks.Task>"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>targetName</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>credential</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>allowedImpersonationLevel</code>不是有效的值。"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此对象已关闭。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServer
  id: AuthenticateAsServer
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsServer()
  nameWithType: NegotiateStream.AuthenticateAsServer()
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServer()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "由服务器验证客户端，以及 （可选） 中的客户端-服务器连接的服务器。"
  remarks: "身份验证使用的服务器的<xref:System.Net.CredentialCache.DefaultCredentials%2A>.</xref:System.Net.CredentialCache.DefaultCredentials%2A> 为服务器不指定任何服务主体名称 (SPN)。 模拟级别是<xref:System.Security.Principal.TokenImpersonationLevel>，和的安全级别为<xref:System.Net.Security.ProtectionLevel>。</xref:System.Net.Security.ProtectionLevel> </xref:System.Security.Principal.TokenImpersonationLevel>       身份验证成功后，你必须检查<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>和<xref:System.Net.Security.NegotiateStream.IsSigned%2A>属性，以确定由<xref:System.Net.Security.NegotiateStream>.</xref:System.Net.Security.NegotiateStream>使用哪些安全服务</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> 检查<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>属性以确定是否发生了相互身份验证。</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>       此方法阻止，直至该操作完成。 若要防止在操作完成之前一直阻止，使用之一<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>方法重载。</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>       如果身份验证失败，你收到的<xref:System.Security.Authentication.AuthenticationException>或<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> 在这种情况下，你可以重试使用不同的凭据进行身份验证。"
  syntax:
    content: public virtual void AuthenticateAsServer ();
    parameters: []
  overload: System.Net.Security.NegotiateStream.AuthenticateAsServer*
  exceptions:
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此对象已关闭。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "不支持 windows 95 和 Windows 98。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)
  id: AuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsServer(ExtendedProtectionPolicy)
  nameWithType: NegotiateStream.AuthenticateAsServer(ExtendedProtectionPolicy)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServer(ExtendedProtectionPolicy)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "由服务器验证客户端，以及 （可选） 中的客户端-服务器连接的服务器。 身份验证过程中使用指定的扩展的保护策略。"
  remarks: "身份验证使用的服务器的<xref:System.Net.CredentialCache.DefaultCredentials%2A>.</xref:System.Net.CredentialCache.DefaultCredentials%2A> 为服务器不指定任何服务主体名称 (SPN)。 模拟级别是<xref:System.Security.Principal.TokenImpersonationLevel>，和的安全级别为<xref:System.Net.Security.ProtectionLevel>。</xref:System.Net.Security.ProtectionLevel> </xref:System.Security.Principal.TokenImpersonationLevel>       如果`policy`参数是`null`，然后使用扩展的保护策略已<xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A>设置为<xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement>。</xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement> </xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A>       身份验证成功后，你必须检查<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>和<xref:System.Net.Security.NegotiateStream.IsSigned%2A>属性，以确定由<xref:System.Net.Security.NegotiateStream>.</xref:System.Net.Security.NegotiateStream>使用哪些安全服务</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> 检查<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>属性以确定是否发生了相互身份验证。</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>       此方法阻止，直至该操作完成。 若要防止在操作完成之前一直阻止，使用之一<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>方法重载。</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>       如果身份验证失败，你收到的<xref:System.Security.Authentication.AuthenticationException>或<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> 在这种情况下，你可以重试使用不同的凭据进行身份验证。"
  syntax:
    content: public virtual void AuthenticateAsServer (System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy);
    parameters:
    - id: policy
      type: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
      description: "<xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;> </xref>用于扩展保护。"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsServer*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<> </> *1> 和<> *1> 传入的扩展的保护策略<code> policy </code>参数都是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "不支持 windows 95 和 Windows 98。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此对象已关闭。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<code> policy </code>参数设置为<xref href=&quot;System.Security.Authentication.ExtendedProtection.PolicyEnforcement&quot;></xref>不支持扩展的保护的平台上。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  id: AuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsServer(NetworkCredential,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsServer(NetworkCredential,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServer(NetworkCredential,ProtectionLevel,TokenImpersonationLevel)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "由服务器验证客户端，以及 （可选） 中的客户端-服务器连接的服务器。 身份验证过程使用指定的服务器凭据和身份验证选项。"
  remarks: "身份验证成功后，你必须检查<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>和<xref:System.Net.Security.NegotiateStream.IsSigned%2A>属性，以确定由<xref:System.Net.Security.NegotiateStream>.</xref:System.Net.Security.NegotiateStream>使用哪些安全服务</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> 检查<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>属性以确定是否发生了相互身份验证。</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>       此方法阻止，直至该操作完成。 若要防止在操作完成之前一直阻止，使用之一<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>方法重载。</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>       如果身份验证失败，你收到的<xref:System.Security.Authentication.AuthenticationException>或<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> 在这种情况下，你可以重试使用不同的凭据进行身份验证。"
  syntax:
    content: public virtual void AuthenticateAsServer (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>用于建立服务器标识。</xref:System.Net.NetworkCredential>"
    - id: requiredProtectionLevel
      type: System.Net.Security.ProtectionLevel
      description: "之一<xref href=&quot;System.Net.Security.ProtectionLevel&quot;></xref>值，该值指示流的安全服务。"
    - id: requiredImpersonationLevel
      type: System.Security.Principal.TokenImpersonationLevel
      description: "之一<xref:System.Security.Principal.TokenImpersonationLevel>值，指示服务器如何使用客户端的凭据以访问资源。</xref:System.Security.Principal.TokenImpersonationLevel>"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsServer*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>credential </code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>requiredImpersonationLevel</code>must be <xref:System.Security.Principal.TokenImpersonationLevel>, <xref:System.Security.Principal.TokenImpersonationLevel>, or <xref:System.Security.Principal.TokenImpersonationLevel>,"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "身份验证失败。 可以使用此对象来尝试 r 进行身份验证。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此对象已关闭。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the client. You cannot use the stream to retry authentication as the server."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "不支持 windows 95 和 Windows 98。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  id: AuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsServer(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsServer(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServer(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "由服务器验证客户端，以及 （可选） 中的客户端-服务器连接的服务器。 身份验证过程使用指定的服务器凭据、 身份验证选项并扩展保护策略。"
  remarks: "如果`policy`参数是`null`，然后使用扩展的保护策略已<xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A>设置为<xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement>。</xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement> </xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A>       身份验证成功后，你必须检查<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>和<xref:System.Net.Security.NegotiateStream.IsSigned%2A>属性，以确定由<xref:System.Net.Security.NegotiateStream>.</xref:System.Net.Security.NegotiateStream>使用哪些安全服务</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> 检查<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>属性以确定是否发生了相互身份验证。</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>       此方法阻止，直至该操作完成。 若要防止在操作完成之前一直阻止，使用之一<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>方法重载。</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>       如果身份验证失败，你收到的<xref:System.Security.Authentication.AuthenticationException>或<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> 在这种情况下，你可以重试使用不同的凭据进行身份验证。"
  syntax:
    content: public virtual void AuthenticateAsServer (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>，使用后者来建立客户端的标识。</xref:System.Net.NetworkCredential>"
    - id: policy
      type: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
      description: "<xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;> </xref>用于扩展保护。"
    - id: requiredProtectionLevel
      type: System.Net.Security.ProtectionLevel
      description: "之一<xref href=&quot;System.Net.Security.ProtectionLevel&quot;></xref>值，该值指示流的安全服务。"
    - id: requiredImpersonationLevel
      type: System.Security.Principal.TokenImpersonationLevel
      description: "之一<xref:System.Security.Principal.TokenImpersonationLevel>值，指示服务器如何使用客户端的凭据以访问资源。</xref:System.Security.Principal.TokenImpersonationLevel>"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsServer*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<> </> *1> 和<> *1> 传入的扩展的保护策略<code> policy </code>参数都是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>credential </code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>requiredImpersonationLevel</code>must be <xref:System.Security.Principal.TokenImpersonationLevel>, <xref:System.Security.Principal.TokenImpersonationLevel>, or <xref:System.Security.Principal.TokenImpersonationLevel>,"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "身份验证失败。 可以使用此对象来尝试 r 进行身份验证。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the client. You cannot use the stream to retry authentication as the server."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "不支持 windows 95 和 Windows 98。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此对象已关闭。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<code> policy </code>参数设置为<xref href=&quot;System.Security.Authentication.ExtendedProtection.PolicyEnforcement&quot;></xref>不支持扩展的保护的平台上。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync
  id: AuthenticateAsServerAsync
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsServerAsync()
  nameWithType: NegotiateStream.AuthenticateAsServerAsync()
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "由服务器验证客户端，以及 （可选） 中作为异步操作的客户端-服务器连接的服务器。"
  remarks: "身份验证使用的服务器的<xref:System.Net.CredentialCache.DefaultCredentials%2A>.</xref:System.Net.CredentialCache.DefaultCredentials%2A> 为服务器不指定任何服务主体名称 (SPN)。 模拟级别是<xref:System.Security.Principal.TokenImpersonationLevel>，和的安全级别为<xref:System.Net.Security.ProtectionLevel>。</xref:System.Net.Security.ProtectionLevel> </xref:System.Security.Principal.TokenImpersonationLevel>       身份验证成功后，你必须检查<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>和<xref:System.Net.Security.NegotiateStream.IsSigned%2A>属性，以确定由<xref:System.Net.Security.NegotiateStream>.</xref:System.Net.Security.NegotiateStream>使用哪些安全服务</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> 检查<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>属性以确定是否发生了相互身份验证。</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>       如果身份验证失败，你收到的<xref:System.Security.Authentication.AuthenticationException>或<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> 在这种情况下，你可以重试使用不同的凭据进行身份验证。"
  syntax:
    content: public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync ();
    parameters: []
    return:
      type: System.Threading.Tasks.Task
      description: "返回<xref:System.Threading.Tasks.Task>表示异步操作的任务对象。</xref:System.Threading.Tasks.Task>"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync*
  exceptions:
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此对象已关闭。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "不支持 windows 95 和 Windows 98。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)
  id: AuthenticateAsServerAsync(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsServerAsync(ExtendedProtectionPolicy)
  nameWithType: NegotiateStream.AuthenticateAsServerAsync(ExtendedProtectionPolicy)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(ExtendedProtectionPolicy)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "由服务器验证客户端，以及 （可选） 中作为异步操作的客户端-服务器连接的服务器。 身份验证过程中使用指定的扩展的保护策略。"
  remarks: "身份验证使用的服务器的<xref:System.Net.CredentialCache.DefaultCredentials%2A>.</xref:System.Net.CredentialCache.DefaultCredentials%2A> 为服务器不指定任何服务主体名称 (SPN)。 模拟级别是<xref:System.Security.Principal.TokenImpersonationLevel>，和的安全级别为<xref:System.Net.Security.ProtectionLevel>。</xref:System.Net.Security.ProtectionLevel> </xref:System.Security.Principal.TokenImpersonationLevel>       如果`policy`参数是`null`，然后使用扩展的保护策略已<xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A>设置为<xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement>。</xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement> </xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A>       身份验证成功后，你必须检查<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>和<xref:System.Net.Security.NegotiateStream.IsSigned%2A>属性，以确定由<xref:System.Net.Security.NegotiateStream>.</xref:System.Net.Security.NegotiateStream>使用哪些安全服务</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> 检查<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>属性以确定是否发生了相互身份验证。</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>       如果身份验证失败，你收到的<xref:System.Security.Authentication.AuthenticationException>或<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> 在这种情况下，你可以重试使用不同的凭据进行身份验证。"
  syntax:
    content: public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy);
    parameters:
    - id: policy
      type: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
      description: "<xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;> </xref>用于扩展保护。"
    return:
      type: System.Threading.Tasks.Task
      description: "返回<xref:System.Threading.Tasks.Task>表示异步操作的任务对象。</xref:System.Threading.Tasks.Task>"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<> </> *1> 和<> *1> 传入的扩展的保护策略<code> policy </code>参数都是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "不支持 windows 95 和 Windows 98。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此对象已关闭。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<code> policy </code>参数设置为<xref href=&quot;System.Security.Authentication.ExtendedProtection.PolicyEnforcement&quot;></xref>不支持扩展的保护的平台上。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  id: AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsServerAsync(NetworkCredential,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsServerAsync(NetworkCredential,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(NetworkCredential,ProtectionLevel,TokenImpersonationLevel)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "由服务器验证客户端，以及 （可选） 中作为异步操作的客户端-服务器连接的服务器。 身份验证过程使用指定的服务器凭据和身份验证选项。"
  remarks: "身份验证成功后，你必须检查<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>和<xref:System.Net.Security.NegotiateStream.IsSigned%2A>属性，以确定由<xref:System.Net.Security.NegotiateStream>.</xref:System.Net.Security.NegotiateStream>使用哪些安全服务</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> 检查<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>属性以确定是否发生了相互身份验证。</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>       如果身份验证失败，你收到的<xref:System.Security.Authentication.AuthenticationException>或<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> 在这种情况下，你可以重试使用不同的凭据进行身份验证。"
  syntax:
    content: public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>用于建立服务器标识。</xref:System.Net.NetworkCredential>"
    - id: requiredProtectionLevel
      type: System.Net.Security.ProtectionLevel
      description: "之一<xref href=&quot;System.Net.Security.ProtectionLevel&quot;></xref>值，该值指示流的安全服务。"
    - id: requiredImpersonationLevel
      type: System.Security.Principal.TokenImpersonationLevel
      description: "之一<xref:System.Security.Principal.TokenImpersonationLevel>值，指示服务器如何使用客户端的凭据以访问资源。</xref:System.Security.Principal.TokenImpersonationLevel>"
    return:
      type: System.Threading.Tasks.Task
      description: "返回<xref:System.Threading.Tasks.Task>表示异步操作的任务对象。</xref:System.Threading.Tasks.Task>"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>credential </code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>requiredImpersonationLevel</code>must be <xref:System.Security.Principal.TokenImpersonationLevel>, <xref:System.Security.Principal.TokenImpersonationLevel>, or <xref:System.Security.Principal.TokenImpersonationLevel>,"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "身份验证失败。 可以使用此对象来尝试 r 进行身份验证。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此对象已关闭。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the client. You cannot use the stream to retry authentication as the server."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "不支持 windows 95 和 Windows 98。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  id: AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsServerAsync(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsServerAsync(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "由服务器验证客户端，以及 （可选） 中作为异步操作的客户端-服务器连接的服务器。 身份验证过程使用指定的服务器凭据、 身份验证选项并扩展保护策略。"
  remarks: "如果`policy`参数是`null`，然后使用扩展的保护策略已<xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A>设置为<xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement>。</xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement> </xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A>       身份验证成功后，你必须检查<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>和<xref:System.Net.Security.NegotiateStream.IsSigned%2A>属性，以确定由<xref:System.Net.Security.NegotiateStream>.</xref:System.Net.Security.NegotiateStream>使用哪些安全服务</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> 检查<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>属性以确定是否发生了相互身份验证。</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>       如果身份验证失败，你收到的<xref:System.Security.Authentication.AuthenticationException>或<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> 在这种情况下，你可以重试使用不同的凭据进行身份验证。"
  syntax:
    content: public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>，使用后者来建立客户端的标识。</xref:System.Net.NetworkCredential>"
    - id: policy
      type: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
      description: "<xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;> </xref>用于扩展保护。"
    - id: requiredProtectionLevel
      type: System.Net.Security.ProtectionLevel
      description: "之一<xref href=&quot;System.Net.Security.ProtectionLevel&quot;></xref>值，该值指示流的安全服务。"
    - id: requiredImpersonationLevel
      type: System.Security.Principal.TokenImpersonationLevel
      description: "之一<xref:System.Security.Principal.TokenImpersonationLevel>值，指示服务器如何使用客户端的凭据以访问资源。</xref:System.Security.Principal.TokenImpersonationLevel>"
    return:
      type: System.Threading.Tasks.Task
      description: "返回<xref:System.Threading.Tasks.Task>表示异步操作的任务对象。</xref:System.Threading.Tasks.Task>"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<> </> *1> 和<> *1> 传入的扩展的保护策略<code> policy </code>参数都是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>credential </code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>requiredImpersonationLevel</code>must be <xref:System.Security.Principal.TokenImpersonationLevel>, <xref:System.Security.Principal.TokenImpersonationLevel>, or <xref:System.Security.Principal.TokenImpersonationLevel>,"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "身份验证失败。 可以使用此对象来尝试 r 进行身份验证。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the client. You cannot use the stream to retry authentication as the server."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "不支持 windows 95 和 Windows 98。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此对象已关闭。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<code> policy </code>参数设置为<xref href=&quot;System.Security.Authentication.ExtendedProtection.PolicyEnforcement&quot;></xref>不支持扩展的保护的平台上。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.AsyncCallback,System.Object)
  id: BeginAuthenticateAsClient(System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: BeginAuthenticateAsClient(AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsClient(AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "由客户端开始一个异步操作以进行身份验证客户端，以及 （可选） 中的客户端-服务器连接的服务器调用。 此方法不会阻止。"
  remarks: "身份验证使用客户端的<xref:System.Net.CredentialCache.DefaultCredentials%2A>.</xref:System.Net.CredentialCache.DefaultCredentials%2A> 为服务器不指定任何服务主体名称 (SPN)。 模拟级别是<xref:System.Security.Principal.TokenImpersonationLevel>，和的安全级别为<xref:System.Net.Security.ProtectionLevel>。</xref:System.Net.Security.ProtectionLevel> </xref:System.Security.Principal.TokenImpersonationLevel> <xref:System.Net.Security.NegotiateStream>类将构造用于相互身份验证的 SPN。</xref:System.Net.Security.NegotiateStream>       此方法是异步的不会阻止在操作完成时。 若要阻止该操作完成之前，请使用之一<xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>方法重载。</xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>       必须通过调用完成异步身份验证操作<xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A>方法。</xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> 通常情况下，通过调用该方法`asyncCallback`委托。 有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/add/includes/ajax-current-ext-md.md)身份验证失败，如果你收到的<xref:System.Security.Authentication.AuthenticationException>或<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> 在这种情况下，你可以重试使用不同的凭据进行身份验证。"
  example:
  - "The following code example demonstrates calling this method to begin an asynchronous authentication for the client.  \n  \n [!code-cpp[NclNegoAsyncClient#2](~/add/codesnippet/cpp/66fdfed9-ce77-41e0-af55-_1.cpp)]\n [!code-cs[NclNegoAsyncClient#2](~/add/codesnippet/csharp/66fdfed9-ce77-41e0-af55-_1.cs)]"
  syntax:
    content: public virtual IAsyncResult BeginAuthenticateAsClient (AsyncCallback asyncCallback, object asyncState);
    parameters:
    - id: asyncCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>引用身份验证完成时要调用的方法的委托。</xref:System.AsyncCallback>"
    - id: asyncState
      type: System.Object
      description: "一个用户定义的对象，包含有关操作的信息。 此对象传递给`asyncCallback`委托操作完成时。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>对象，该值指示异步操作的状态。</xref:System.IAsyncResult>"
  overload: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient*
  exceptions:
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此对象已关闭。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client."
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.AsyncCallback,System.Object)
  id: BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: BeginAuthenticateAsClient(NetworkCredential,String,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,String,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,String,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "由客户端开始一个异步操作以进行身份验证客户端，以及 （可选） 中的客户端-服务器连接的服务器调用。 身份验证过程使用指定的凭据。 此方法不会阻止。"
  remarks: "此方法是异步的不会阻止在操作完成时。 若要阻止该操作完成之前，请使用之一<xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>方法重载。</xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>       必须通过调用完成异步身份验证操作<xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A>方法。</xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> 通常情况下，通过调用该方法`asyncCallback`委托。 有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/add/includes/ajax-current-ext-md.md)身份验证失败，如果你收到的<xref:System.Security.Authentication.AuthenticationException>或<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> 在这种情况下，你可以重试使用不同的凭据进行身份验证。"
  syntax:
    content: public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, AsyncCallback asyncCallback, object asyncState);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>，使用后者来建立客户端的标识。</xref:System.Net.NetworkCredential>"
    - id: targetName
      type: System.String
      description: "唯一标识服务器进行身份验证服务主体名称 (SPN)。"
    - id: asyncCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>引用身份验证完成时要调用的方法的委托。</xref:System.AsyncCallback>"
    - id: asyncState
      type: System.Object
      description: "一个用户定义的对象，包含有关写入操作的信息。 此对象传递给`asyncCallback`委托操作完成时。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>对象，该值指示异步操作的状态。</xref:System.IAsyncResult>"
  overload: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>credential</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>targetName</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此对象已关闭。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client."
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.AsyncCallback,System.Object)
  id: BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: BeginAuthenticateAsClient(NetworkCredential,ChannelBinding,String,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,ChannelBinding,String,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,ChannelBinding,String,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "由客户端开始一个异步操作以进行身份验证客户端，以及 （可选） 中的客户端-服务器连接的服务器调用。 身份验证过程使用指定的凭据和渠道绑定。 此方法不会阻止。"
  remarks: "此方法是异步的不会阻止在操作完成时。 若要阻止该操作完成之前，请使用之一<xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>方法重载。</xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>       必须通过调用完成异步身份验证操作<xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A>方法。</xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> 通常情况下，通过调用该方法`asyncCallback`委托。 有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/add/includes/ajax-current-ext-md.md)身份验证失败，如果你收到的<xref:System.Security.Authentication.AuthenticationException>或<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> 在这种情况下，你可以重试使用不同的凭据进行身份验证。"
  syntax:
    content: public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, AsyncCallback asyncCallback, object asyncState);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>，使用后者来建立客户端的标识。</xref:System.Net.NetworkCredential>"
    - id: binding
      type: System.Security.Authentication.ExtendedProtection.ChannelBinding
      description: "<xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>用于扩展保护。</xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>"
    - id: targetName
      type: System.String
      description: "唯一标识服务器进行身份验证服务主体名称 (SPN)。"
    - id: asyncCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>引用身份验证完成时要调用的方法的委托。</xref:System.AsyncCallback>"
    - id: asyncState
      type: System.Object
      description: "一个用户定义的对象，包含有关写入操作的信息。 此对象传递给`asyncCallback`委托操作完成时。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>对象，该值指示异步操作的状态。</xref:System.IAsyncResult>"
  overload: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>credential</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>targetName</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此对象已关闭。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  id: BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: BeginAuthenticateAsClient(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "由客户端开始一个异步操作以进行身份验证客户端，以及 （可选） 中的客户端-服务器连接的服务器调用。 身份验证过程使用指定的凭据和身份验证选项。 此方法不会阻止。"
  remarks: "使用`requiredProtectionLevel`对的请求安全服务的使用经过身份验证的流传输的数据的参数。 例如，若要让数据进行加密和签名，指定<xref:System.Net.Security.ProtectionLevel>值。</xref:System.Net.Security.ProtectionLevel> 成功通过身份验证并不保证，请求<xref:System.Net.Security.ProtectionLevel>已被授予。</xref:System.Net.Security.ProtectionLevel> 你必须检查<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>和<xref:System.Net.Security.NegotiateStream.IsSigned%2A>属性，以确定由<xref:System.Net.Security.NegotiateStream>.</xref:System.Net.Security.NegotiateStream>使用哪些安全服务</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>       此方法是异步的不会阻止在操作完成时。 若要阻止该操作完成之前，请使用之一<xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>方法重载。</xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>       必须通过调用完成异步身份验证操作<xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A>方法。</xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> 通常情况下，通过调用该方法`asyncCallback`委托。 有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/add/includes/ajax-current-ext-md.md)身份验证失败，如果你收到的<xref:System.Security.Authentication.AuthenticationException>或<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> 在这种情况下，你可以重试使用不同的凭据进行身份验证。"
  syntax:
    content: public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>，使用后者来建立客户端的标识。</xref:System.Net.NetworkCredential>"
    - id: targetName
      type: System.String
      description: "唯一标识服务器进行身份验证服务主体名称 (SPN)。"
    - id: requiredProtectionLevel
      type: System.Net.Security.ProtectionLevel
      description: "之一<xref href=&quot;System.Net.Security.ProtectionLevel&quot;></xref>值，该值指示流的安全服务。"
    - id: allowedImpersonationLevel
      type: System.Security.Principal.TokenImpersonationLevel
      description: "之一<xref:System.Security.Principal.TokenImpersonationLevel>值，指示服务器如何使用客户端的凭据以访问资源。</xref:System.Security.Principal.TokenImpersonationLevel>"
    - id: asyncCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>引用身份验证完成时要调用的方法的委托。</xref:System.AsyncCallback>"
    - id: asyncState
      type: System.Object
      description: "一个用户定义的对象，包含有关写入操作的信息。 此对象传递给`asyncCallback`委托操作完成时。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>对象，该值指示异步操作的状态。</xref:System.IAsyncResult>"
  overload: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>credential</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>targetName</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此对象已关闭。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client."
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  id: BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: BeginAuthenticateAsClient(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "由客户端开始一个异步操作以进行身份验证客户端，以及 （可选） 中的客户端-服务器连接的服务器调用。 身份验证过程使用指定的凭据、 身份验证选项和渠道绑定。 此方法不会阻止。"
  remarks: "使用`requiredProtectionLevel`对的请求安全服务的使用经过身份验证的流传输的数据的参数。 例如，若要让数据进行加密和签名，指定<xref:System.Net.Security.ProtectionLevel>值。</xref:System.Net.Security.ProtectionLevel> 成功通过身份验证并不保证，请求<xref:System.Net.Security.ProtectionLevel>已被授予。</xref:System.Net.Security.ProtectionLevel> 你必须检查<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>和<xref:System.Net.Security.NegotiateStream.IsSigned%2A>属性，以确定由<xref:System.Net.Security.NegotiateStream>.</xref:System.Net.Security.NegotiateStream>使用哪些安全服务</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>       此方法是异步的不会阻止在操作完成时。 若要阻止该操作完成之前，请使用之一<xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>方法重载。</xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>       必须通过调用完成异步身份验证操作<xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A>方法。</xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> 通常情况下，通过调用该方法`asyncCallback`委托。 有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/add/includes/ajax-current-ext-md.md)身份验证失败，如果你收到的<xref:System.Security.Authentication.AuthenticationException>或<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> 在这种情况下，你可以重试使用不同的凭据进行身份验证。"
  syntax:
    content: public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>，使用后者来建立客户端的标识。</xref:System.Net.NetworkCredential>"
    - id: binding
      type: System.Security.Authentication.ExtendedProtection.ChannelBinding
      description: "<xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>用于扩展保护。</xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>"
    - id: targetName
      type: System.String
      description: "唯一标识服务器进行身份验证服务主体名称 (SPN)。"
    - id: requiredProtectionLevel
      type: System.Net.Security.ProtectionLevel
      description: "之一<xref href=&quot;System.Net.Security.ProtectionLevel&quot;></xref>值，该值指示流的安全服务。"
    - id: allowedImpersonationLevel
      type: System.Security.Principal.TokenImpersonationLevel
      description: "之一<xref:System.Security.Principal.TokenImpersonationLevel>值，指示服务器如何使用客户端的凭据以访问资源。</xref:System.Security.Principal.TokenImpersonationLevel>"
    - id: asyncCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>引用身份验证完成时要调用的方法的委托。</xref:System.AsyncCallback>"
    - id: asyncState
      type: System.Object
      description: "一个用户定义的对象，包含有关写入操作的信息。 此对象传递给`asyncCallback`委托操作完成时。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>对象，该值指示异步操作的状态。</xref:System.IAsyncResult>"
  overload: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>credential</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>targetName</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此对象已关闭。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.AsyncCallback,System.Object)
  id: BeginAuthenticateAsServer(System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: BeginAuthenticateAsServer(AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsServer(AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "由服务器开始一个异步操作以验证客户端，以及 （可选） 中的客户端-服务器连接的服务器。 此方法不会阻止。"
  remarks: "身份验证使用的服务器的<xref:System.Net.CredentialCache.DefaultCredentials%2A>.</xref:System.Net.CredentialCache.DefaultCredentials%2A> 为服务器不指定任何服务主体名称 (SPN)。 模拟级别为<xref:System.Security.Principal.TokenImpersonationLevel>，安全级别为<xref:System.Net.Security.ProtectionLevel>.</xref:System.Net.Security.ProtectionLevel> </xref:System.Security.Principal.TokenImpersonationLevel>       身份验证成功后，你必须检查<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>和<xref:System.Net.Security.NegotiateStream.IsSigned%2A>属性，以确定由<xref:System.Net.Security.NegotiateStream>.</xref:System.Net.Security.NegotiateStream>使用哪些安全服务</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> 检查<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>属性以确定是否发生了相互身份验证。</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>       若要阻止该操作完成之前，请使用之一<xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>方法重载。</xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>       如果身份验证失败，你收到的<xref:System.Security.Authentication.AuthenticationException>或<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> 在这种情况下，你可以重试使用不同的凭据进行身份验证。"
  syntax:
    content: public virtual IAsyncResult BeginAuthenticateAsServer (AsyncCallback asyncCallback, object asyncState);
    parameters:
    - id: asyncCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>引用身份验证完成时要调用的方法的委托。</xref:System.AsyncCallback>"
    - id: asyncState
      type: System.Object
      description: "一个用户定义的对象，包含有关操作的信息。 此对象传递给`asyncCallback`委托操作完成时。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>对象，该值指示异步操作的状态。</xref:System.IAsyncResult>"
  overload: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer*
  exceptions:
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此对象已关闭。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "不支持 windows 95 和 Windows 98。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.AsyncCallback,System.Object)
  id: BeginAuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: BeginAuthenticateAsServer(ExtendedProtectionPolicy,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsServer(ExtendedProtectionPolicy,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(ExtendedProtectionPolicy,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "由服务器开始一个异步操作以验证客户端，以及 （可选） 中的客户端-服务器连接的服务器。 身份验证过程中使用指定的扩展的保护策略。 此方法不会阻止。"
  remarks: "身份验证使用的服务器的<xref:System.Net.CredentialCache.DefaultCredentials%2A>.</xref:System.Net.CredentialCache.DefaultCredentials%2A> 为服务器不指定任何服务主体名称 (SPN)。 模拟级别为<xref:System.Security.Principal.TokenImpersonationLevel>，安全级别为<xref:System.Net.Security.ProtectionLevel>.</xref:System.Net.Security.ProtectionLevel> </xref:System.Security.Principal.TokenImpersonationLevel>       如果`policy`参数是`null`，然后使用扩展的保护策略已<xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A>设置为<xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement>。</xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement> </xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A>       身份验证成功后，你必须检查<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>和<xref:System.Net.Security.NegotiateStream.IsSigned%2A>属性，以确定由<xref:System.Net.Security.NegotiateStream>.</xref:System.Net.Security.NegotiateStream>使用哪些安全服务</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> 检查<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>属性以确定是否发生了相互身份验证。</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>       若要阻止该操作完成之前，请使用之一<xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>方法重载。</xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>       如果身份验证失败，你收到的<xref:System.Security.Authentication.AuthenticationException>或<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> 在这种情况下，你可以重试使用不同的凭据进行身份验证。"
  syntax:
    content: public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, AsyncCallback asyncCallback, object asyncState);
    parameters:
    - id: policy
      type: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
      description: "<xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;> </xref>用于扩展保护。"
    - id: asyncCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>引用身份验证完成时要调用的方法的委托。</xref:System.AsyncCallback>"
    - id: asyncState
      type: System.Object
      description: "一个用户定义的对象，包含有关写入操作的信息。 此对象传递给`asyncCallback`委托操作完成时。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>对象，该值指示异步操作的状态。</xref:System.IAsyncResult>"
  overload: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<> </> *1> 和<> *1> 传入的扩展的保护策略<code> policy </code>参数都是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "不支持 windows 95 和 Windows 98。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此对象已关闭。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<code> policy </code>参数设置为<xref href=&quot;System.Security.Authentication.ExtendedProtection.PolicyEnforcement&quot;></xref>不支持扩展的保护的平台上。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  id: BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: BeginAuthenticateAsServer(NetworkCredential,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsServer(NetworkCredential,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(NetworkCredential,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "由服务器开始一个异步操作以验证客户端，以及 （可选） 中的客户端-服务器连接的服务器。 身份验证过程使用指定的服务器凭据和身份验证选项。 此方法不会阻止。"
  remarks: "使用`requiredProtectionLevel`对的请求安全服务的使用经过身份验证的流传输的数据的参数。 例如，若要让数据进行加密和签名，指定<xref:System.Net.Security.ProtectionLevel>值。</xref:System.Net.Security.ProtectionLevel> 成功通过身份验证并不保证，请求<xref:System.Net.Security.ProtectionLevel>已被授予。</xref:System.Net.Security.ProtectionLevel> 你必须检查<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>和<xref:System.Net.Security.NegotiateStream.IsSigned%2A>属性，以确定由<xref:System.Net.Security.NegotiateStream>.</xref:System.Net.Security.NegotiateStream>使用哪些安全服务</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>       此方法是异步的不会阻止在操作完成时。 若要阻止该操作完成之前，请使用之一<xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>方法重载。</xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>       必须通过调用完成异步身份验证操作<xref:System.Net.Security.NegotiateStream.EndAuthenticateAsServer%2A>方法。</xref:System.Net.Security.NegotiateStream.EndAuthenticateAsServer%2A> 通常情况下，通过调用该方法`asyncCallback`委托。 有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/add/includes/ajax-current-ext-md.md)身份验证失败，如果你收到的<xref:System.Security.Authentication.AuthenticationException>或<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> 在这种情况下，你可以重试使用不同的凭据进行身份验证。"
  syntax:
    content: public virtual IAsyncResult BeginAuthenticateAsServer (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>，使用后者来建立客户端的标识。</xref:System.Net.NetworkCredential>"
    - id: requiredProtectionLevel
      type: System.Net.Security.ProtectionLevel
      description: "之一<xref href=&quot;System.Net.Security.ProtectionLevel&quot;></xref>值，该值指示流的安全服务。"
    - id: requiredImpersonationLevel
      type: System.Security.Principal.TokenImpersonationLevel
      description: "之一<xref:System.Security.Principal.TokenImpersonationLevel>值，指示服务器如何使用客户端的凭据以访问资源。</xref:System.Security.Principal.TokenImpersonationLevel>"
    - id: asyncCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>引用身份验证完成时要调用的方法的委托。</xref:System.AsyncCallback>"
    - id: asyncState
      type: System.Object
      description: "一个用户定义的对象，包含有关操作的信息。 此对象传递给`asyncCallback`委托操作完成时。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>对象，该值指示异步操作的状态。</xref:System.IAsyncResult>"
  overload: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>credential</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>requiredImpersonationLevel</code>must be <xref:System.Security.Principal.TokenImpersonationLevel>, <xref:System.Security.Principal.TokenImpersonationLevel>, or <xref:System.Security.Principal.TokenImpersonationLevel>,"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此对象已关闭。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the client. You cannot use the stream to retry authentication as the server."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "不支持 windows 95 和 Windows 98。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  id: BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: BeginAuthenticateAsServer(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsServer(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "由服务器开始一个异步操作以验证客户端，以及 （可选） 中的客户端-服务器连接的服务器。 身份验证过程使用指定的服务器凭据、 身份验证选项并扩展保护策略。 此方法不会阻止。"
  remarks: "使用`requiredProtectionLevel`对的请求安全服务的使用经过身份验证的流传输的数据的参数。 例如，若要让数据进行加密和签名，指定<xref:System.Net.Security.ProtectionLevel>值。</xref:System.Net.Security.ProtectionLevel> 成功通过身份验证并不保证，请求<xref:System.Net.Security.ProtectionLevel>已被授予。</xref:System.Net.Security.ProtectionLevel> 你必须检查<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>和<xref:System.Net.Security.NegotiateStream.IsSigned%2A>属性，以确定由<xref:System.Net.Security.NegotiateStream>.</xref:System.Net.Security.NegotiateStream>使用哪些安全服务</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>       如果`policy`参数是`null`，然后使用扩展的保护策略已<xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A>设置为<xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement>。</xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement> </xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A>       此方法是异步的不会阻止在操作完成时。 若要阻止该操作完成之前，请使用之一<xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>方法重载。</xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>       必须通过调用完成异步身份验证操作<xref:System.Net.Security.NegotiateStream.EndAuthenticateAsServer%2A>方法。</xref:System.Net.Security.NegotiateStream.EndAuthenticateAsServer%2A> 通常情况下，通过调用该方法`asyncCallback`委托。 有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/add/includes/ajax-current-ext-md.md)身份验证失败，如果你收到的<xref:System.Security.Authentication.AuthenticationException>或<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> 在这种情况下，你可以重试使用不同的凭据进行身份验证。"
  syntax:
    content: public virtual IAsyncResult BeginAuthenticateAsServer (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>，使用后者来建立客户端的标识。</xref:System.Net.NetworkCredential>"
    - id: policy
      type: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
      description: "<xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;> </xref>用于扩展保护。"
    - id: requiredProtectionLevel
      type: System.Net.Security.ProtectionLevel
      description: "之一<xref href=&quot;System.Net.Security.ProtectionLevel&quot;></xref>值，该值指示流的安全服务。"
    - id: requiredImpersonationLevel
      type: System.Security.Principal.TokenImpersonationLevel
      description: "之一<xref:System.Security.Principal.TokenImpersonationLevel>值，指示服务器如何使用客户端的凭据以访问资源。</xref:System.Security.Principal.TokenImpersonationLevel>"
    - id: asyncCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>引用身份验证完成时要调用的方法的委托。</xref:System.AsyncCallback>"
    - id: asyncState
      type: System.Object
      description: "一个用户定义的对象，包含有关写入操作的信息。 此对象传递给`asyncCallback`委托操作完成时。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>对象，该值指示异步操作的状态。</xref:System.IAsyncResult>"
  overload: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<> </> *1> 和<> *1> 传入的扩展的保护策略<code> policy </code>参数都是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>credential</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>requiredImpersonationLevel</code>must be <xref:System.Security.Principal.TokenImpersonationLevel>, <xref:System.Security.Principal.TokenImpersonationLevel>, or <xref:System.Security.Principal.TokenImpersonationLevel>,"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the client. You cannot use the stream to retry authentication as the server."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "不支持 windows 95 和 Windows 98。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此对象已关闭。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<code> policy </code>参数设置为<xref href=&quot;System.Security.Authentication.ExtendedProtection.PolicyEnforcement&quot;></xref>不支持扩展的保护的平台上。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "开始异步读的操作从流中读取数据并将它存储在指定的数组。"
  remarks: "如果启用了加密、 签名或加密和签名，读取的操作将从基础流中读取数据、 检查的数据的完整性和对其进行解密。 如果任何安全不服务 （如数据加密或签名） 中使用，此方法会启动对基础流的异步读取的操作。       此方法是异步的不会阻止在操作完成时。 若要阻止该操作完成之前，请使用<xref:System.Net.Security.NegotiateStream.Read%2A>方法。</xref:System.Net.Security.NegotiateStream.Read%2A>       异步读的操作必须由调用完成<xref:System.Net.Security.NegotiateStream.EndRead%2A>方法。</xref:System.Net.Security.NegotiateStream.EndRead%2A> 通常情况下，通过调用该方法`asyncCallback`委托。 有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/add/includes/ajax-current-ext-md.md)<xref:System.Net.Security.NegotiateStream>类不支持多个同时进行的读取操作。</xref:System.Net.Security.NegotiateStream> 如果你尝试开始读取的操作，而另一个读取操作已经在执行对同一个流，<xref:System.NotSupportedException>将引发异常。</xref:System.NotSupportedException>       你已成功通过身份验证之前，不能调用此方法。 若要进行身份验证，调用之一<xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>， <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>， <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>，或<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>方法。</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> </xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> </xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> </xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>"
  example:
  - "The following code example demonstrates starting an asynchronous read operation. This code example is part of a larger example provided for the <xref:System.Net.Security.NegotiateStream> class.  \n  \n [!code-cs[NclNegoAsyncServer#1](~/add/codesnippet/csharp/45085c2d-bb14-48e7-a75f-_1.cs)]\n [!code-cpp[NclNegoAsyncServer#1](~/add/codesnippet/cpp/45085c2d-bb14-48e7-a75f-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "A<xref:System.Byte>数组，用于接收字节从流中读取。</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "中的从零开始的位置`buffer`从此处开始存储读取的数据从该流。"
    - id: count
      type: System.Int32
      description: "最大要从流中读取的字节数。"
    - id: asyncCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>引用要在读取的操作已完成时调用的方法的委托。</xref:System.AsyncCallback>"
    - id: asyncState
      type: System.Object
      description: "一个用户定义的对象，包含有关读取操作的信息。 此对象传递给`asyncCallback`委托操作完成时。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>对象，该值指示异步操作的状态。</xref:System.IAsyncResult>"
  overload: System.Net.Security.NegotiateStream.BeginRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>offset</code> is less than 0.  \n  \n \\- or -  \n  \n <code>offset</code> is greater than the length of <code>buffer</code>.  \n  \n \\- or -  \n  \n <code>offset</code> plus <code>count</code> is greater than the length of <code>buffer</code>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "The read operation failed.  \n  \n \\- or -  \n  \n Encryption is in use, but the data could not be decrypted."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "已存在正在进行的读取的操作。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此对象已关闭。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "不发生身份验证。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "开始异步写操作写入<xref:System.Byte>从指定的缓冲区到流的 s。</xref:System.Byte>"
  remarks: "如果启用了加密、 签名或加密和签名，此方法从缓冲区中读取数据、 加密，符号，或对进行加密和签名，以及传输使用基础流。 如果任何安全不服务 （如数据加密或签名） 中使用，此方法会启动对基础流的异步写入操作。       此方法是异步的不会阻止在操作完成时。 若要阻止该操作完成之前，请使用<xref:System.Net.Security.NegotiateStream.Read%2A>方法。</xref:System.Net.Security.NegotiateStream.Read%2A>       异步读的操作必须由调用完成<xref:System.Net.Security.NegotiateStream.EndWrite%2A>方法。</xref:System.Net.Security.NegotiateStream.EndWrite%2A> 通常情况下，通过调用该方法`asyncCallback`委托。 有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/add/includes/ajax-current-ext-md.md)<xref:System.Net.Security.NegotiateStream>类不支持多个同时进行的写入操作。</xref:System.Net.Security.NegotiateStream> 如果你尝试开始写入操作，而另一个写入操作已经在执行对同一个流，<xref:System.NotSupportedException>将引发异常。</xref:System.NotSupportedException>       你已成功通过身份验证之前，不能调用此方法。 若要进行身份验证，调用之一<xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>， <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>， <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>，或<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>方法。</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> </xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> </xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> </xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>"
  example:
  - "The following code example demonstrates beginning an asynchronous write operation.  \n  \n [!code-cpp[NclNegoAsyncClient#3](~/add/codesnippet/cpp/5748c807-4e74-4d4c-a4e4-_1.cpp)]\n [!code-cs[NclNegoAsyncClient#3](~/add/codesnippet/csharp/5748c807-4e74-4d4c-a4e4-_1.cs)]  \n  \n The following method is called when the operation completes.  \n  \n [!code-cpp[NclNegoAsyncClient#4](~/add/codesnippet/cpp/5748c807-4e74-4d4c-a4e4-_2.cpp)]\n [!code-cs[NclNegoAsyncClient#4](~/add/codesnippet/csharp/5748c807-4e74-4d4c-a4e4-_2.cs)]"
  syntax:
    content: public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "A<xref:System.Byte>提供要写入到流的字节的数组。</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "中的从零开始的位置`buffer`从此处开始读取要写入到流的字节。"
    - id: count
      type: System.Int32
      description: "<xref:System.Int32>值，该值指定要从其中进行读取的字节数`buffer`。</xref:System.Int32>"
    - id: asyncCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>引用写入操作完成时要调用的方法的委托。</xref:System.AsyncCallback>"
    - id: asyncState
      type: System.Object
      description: "一个用户定义的对象，包含有关写入操作的信息。 此对象传递给`asyncCallback`委托操作完成时。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>对象，该值指示异步操作的状态。</xref:System.IAsyncResult>"
  overload: System.Net.Security.NegotiateStream.BeginWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>offset is less than 0</code>.  \n  \n \\- or -  \n  \n <code>offset</code> is greater than the length of <code>buffer</code>.  \n  \n \\- or -  \n  \n <code>offset</code> plus count is greater than the length of <code>buffer</code>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "The write operation failed.  \n  \n \\- or -  \n  \n Encryption is in use, but the data could not be encrypted."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "已存在正在进行的写入操作。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此对象已关闭。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "不发生身份验证。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.CanRead
  id: CanRead
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: CanRead
  nameWithType: NegotiateStream.CanRead
  fullName: System.Net.Security.NegotiateStream.CanRead
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "获取<xref:System.Boolean>值，该值指示是否可读基础流。</xref:System.Boolean>"
  remarks: "如果发生了成功的身份验证，此属性返回通过调用返回的值<xref:System.IO.Stream.CanRead%2A>对基础流的属性。</xref:System.IO.Stream.CanRead%2A> 基础流是在创建<xref:System.Net.Security.NegotiateStream>类</xref:System.Net.Security.NegotiateStream>的实例时指定"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cs[NclNegoSyncClient#2](~/add/codesnippet/csharp/p-system.net.security.ne_4_1.cs)]\n [!code-cpp[NclNegoSyncClient#2](~/add/codesnippet/cpp/p-system.net.security.ne_4_1.cpp)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果已进行身份验证且基础流可读，则为否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Security.NegotiateStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.CanSeek
  id: CanSeek
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: NegotiateStream.CanSeek
  fullName: System.Net.Security.NegotiateStream.CanSeek
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "获取<xref:System.Boolean>值，该值指示是否可查找的基础流。</xref:System.Boolean>"
  remarks: "不应尝试设置的位置<xref:System.Net.Security.NegotiateStream>对象或其基础流。</xref:System.Net.Security.NegotiateStream> 基础流是在创建<xref:System.Net.Security.NegotiateStream>类</xref:System.Net.Security.NegotiateStream>的实例时指定"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cs[NclNegoSyncClient#2](~/add/codesnippet/csharp/p-system.net.security.ne_3_1.cs)]\n [!code-cpp[NclNegoSyncClient#2](~/add/codesnippet/cpp/p-system.net.security.ne_3_1.cpp)]"
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "此属性始终返回<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Security.NegotiateStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.CanTimeout
  id: CanTimeout
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: CanTimeout
  nameWithType: NegotiateStream.CanTimeout
  fullName: System.Net.Security.NegotiateStream.CanTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "获取<xref:System.Boolean>值，该值指示基础流是否支持超时。</xref:System.Boolean>"
  remarks: "此属性返回通过调用返回的值<xref:System.IO.Stream.CanTimeout%2A>对基础流的属性。</xref:System.IO.Stream.CanTimeout%2A> 基础流是在创建<xref:System.Net.Security.NegotiateStream>类</xref:System.Net.Security.NegotiateStream>的实例时指定"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cs[NclNegoSyncClient#2](~/add/codesnippet/csharp/p-system.net.security.ne_2_1.cs)]\n [!code-cpp[NclNegoSyncClient#2](~/add/codesnippet/cpp/p-system.net.security.ne_2_1.cpp)]"
  syntax:
    content: public override bool CanTimeout { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果基础流支持超时，则否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Security.NegotiateStream.CanTimeout*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.CanWrite
  id: CanWrite
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: NegotiateStream.CanWrite
  fullName: System.Net.Security.NegotiateStream.CanWrite
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "获取<xref:System.Boolean>值，该值指示是否可写基础流。</xref:System.Boolean>"
  remarks: "如果发生了成功的身份验证，此属性返回通过调用返回的值<xref:System.IO.Stream.CanWrite%2A>对基础流的属性。</xref:System.IO.Stream.CanWrite%2A> 基础流是在创建<xref:System.Net.Security.NegotiateStream>类</xref:System.Net.Security.NegotiateStream>的实例时指定"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cs[NclNegoSyncClient#2](~/add/codesnippet/csharp/p-system.net.security.ne_6_1.cs)]\n [!code-cpp[NclNegoSyncClient#2](~/add/codesnippet/cpp/p-system.net.security.ne_6_1.cpp)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果已进行身份验证，而且基础流可写;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Security.NegotiateStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: NegotiateStream.Dispose(Boolean)
  fullName: System.Net.Security.NegotiateStream.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "释放由非托管的资源<xref href=&quot;System.Net.Security.NegotiateStream&quot;> </xref> ，还可以释放托管的资源。"
  remarks: "此方法称为由公共`Dispose()`方法和<xref:System.Object.Finalize%2A>方法。</xref:System.Object.Finalize%2A> `Dispose()`调用受保护`Dispose(Boolean)`方法替换`disposing`参数设置为`true`。 <xref:System.Object.Finalize%2A>调用`Dispose`与`disposing`设置为`false`。</xref:System.Object.Finalize%2A>       当`disposing`参数为 true 时，此方法释放由任何托管对象持有的全部资源此<xref:System.Net.Security.NegotiateStream>引用。</xref:System.Net.Security.NegotiateStream> 此方法调用`Dispose()`每个引用对象的方法。"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要释放托管和非托管资源;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>若要仅释放非托管的资源。"
  overload: System.Net.Security.NegotiateStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.EndAuthenticateAsClient(System.IAsyncResult)
  id: EndAuthenticateAsClient(System.IAsyncResult)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: EndAuthenticateAsClient(IAsyncResult)
  nameWithType: NegotiateStream.EndAuthenticateAsClient(IAsyncResult)
  fullName: System.Net.Security.NegotiateStream.EndAuthenticateAsClient(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "结束到<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient*>。</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient*>调用已启动挂起的异步客户端身份验证操作"
  remarks: "如果该操作未完成，此方法阻止，直至它执行。 当身份验证成功时，您必须检查<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>和<xref:System.Net.Security.NegotiateStream.IsSigned%2A>属性，以确定由<xref:System.Net.Security.NegotiateStream>.</xref:System.Net.Security.NegotiateStream>使用哪些安全服务</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> 检查<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>属性以确定是否发生了相互身份验证。</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>       如果身份验证失败，你收到的<xref:System.Security.Authentication.AuthenticationException>或<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> 在这种情况下，你可以重试使用不同的凭据进行身份验证。       若要以同步方式执行此操作，请使用之一<xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>方法。</xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>"
  syntax:
    content: public virtual void EndAuthenticateAsClient (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>通过<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient*>.</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient*>调用返回的实例</xref:System.IAsyncResult>"
  overload: System.Net.Security.NegotiateStream.EndAuthenticateAsClient*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>asyncResult</code>未创建通过调用<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient*>。"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "没有挂起的客户端身份验证才能完成。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.EndAuthenticateAsServer(System.IAsyncResult)
  id: EndAuthenticateAsServer(System.IAsyncResult)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: EndAuthenticateAsServer(IAsyncResult)
  nameWithType: NegotiateStream.EndAuthenticateAsServer(IAsyncResult)
  fullName: System.Net.Security.NegotiateStream.EndAuthenticateAsServer(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "结束到<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer*>。</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer*>调用已启动挂起的异步客户端身份验证操作"
  remarks: "如果该操作未完成，此方法阻止，直至它执行。       身份验证成功后，你必须检查<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>和<xref:System.Net.Security.NegotiateStream.IsSigned%2A>属性，以确定由<xref:System.Net.Security.NegotiateStream>.</xref:System.Net.Security.NegotiateStream>使用哪些安全服务</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> 检查<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>属性以确定是否发生了相互身份验证。</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>       如果身份验证失败，你收到的<xref:System.Security.Authentication.AuthenticationException>或<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> 在这种情况下，你可以重试使用不同的凭据进行身份验证。       若要以同步方式执行此操作，使用<xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>方法。</xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>"
  syntax:
    content: public virtual void EndAuthenticateAsServer (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>通过<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer*>.</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer*>调用返回的实例</xref:System.IAsyncResult>"
  overload: System.Net.Security.NegotiateStream.EndAuthenticateAsServer*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>asyncResult</code>未创建通过调用<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer*>。"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "身份验证失败。 此对象可用于重新进行身份验证。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "没有任何挂起的身份验证才能完成。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.EndRead(System.IAsyncResult)
  id: EndRead(System.IAsyncResult)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: EndRead(IAsyncResult)
  nameWithType: NegotiateStream.EndRead(IAsyncResult)
  fullName: System.Net.Security.NegotiateStream.EndRead(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "结束异步读取的操作开始<xref:System.Net.Security.NegotiateStream.BeginRead*>.</xref:System.Net.Security.NegotiateStream.BeginRead*>调用"
  remarks: "如果该操作未完成，此方法阻止，直至它执行。       若要以同步方式执行此操作，使用<xref:System.Net.Security.NegotiateStream.Read%2A>方法。</xref:System.Net.Security.NegotiateStream.Read%2A>       你已成功通过身份验证之前，不能调用此方法。 若要进行身份验证，调用之一<xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>， <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>， <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>，或<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>方法。</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> </xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> </xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> </xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>"
  example:
  - "The following code example demonstrates ending an asynchronous read operation. For an example that demonstrates starting the operation, see <xref:System.Net.Security.NegotiateStream.BeginRead%2A>.  \n  \n [!code-cs[NclNegoAsyncServer#3](~/add/codesnippet/csharp/m-system.net.security.ne_2_1.cs)]\n [!code-cpp[NclNegoAsyncServer#3](~/add/codesnippet/cpp/m-system.net.security.ne_2_1.cpp)]"
  syntax:
    content: public override int EndRead (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>返回通过调用实例<xref:System.Net.Security.NegotiateStream.BeginRead*></xref:System.Net.Security.NegotiateStream.BeginRead*></xref:System.IAsyncResult>"
    return:
      type: System.Int32
      description: "A<xref:System.Int32>从基础流中读取指定的字节数的值。</xref:System.Int32>"
  overload: System.Net.Security.NegotiateStream.EndRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "通过调用<xref:System.Net.Security.NegotiateStream.BeginRead*>.</xref:System.Net.Security.NegotiateStream.BeginRead*>未创建 asyncResult"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "不发生身份验证。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "读取的操作失败。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.EndWrite(System.IAsyncResult)
  id: EndWrite(System.IAsyncResult)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: EndWrite(IAsyncResult)
  nameWithType: NegotiateStream.EndWrite(IAsyncResult)
  fullName: System.Net.Security.NegotiateStream.EndWrite(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "结束异步写操作，到<xref:System.Net.Security.NegotiateStream.BeginWrite*>。</xref:System.Net.Security.NegotiateStream.BeginWrite*>调用已启动"
  remarks: "如果该操作未完成，此方法阻止，直至它执行。       你已成功通过身份验证之前，不能调用此方法。 若要进行身份验证，调用之一<xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>， <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>， <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>，或<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>方法。</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> </xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> </xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> </xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>       若要以同步方式执行此操作，使用<xref:System.Net.Security.NegotiateStream.Write%2A>方法。</xref:System.Net.Security.NegotiateStream.Write%2A>"
  example:
  - "The following code example demonstrates a method that is called to complete the asynchronous write operation. For an example that demonstrates starting the operation, see <xref:System.Net.Security.NegotiateStream.BeginWrite%2A>.  \n  \n [!code-cpp[NclNegoAsyncClient#4](~/add/codesnippet/cpp/m-system.net.security.ne_0_1.cpp)]\n [!code-cs[NclNegoAsyncClient#4](~/add/codesnippet/csharp/m-system.net.security.ne_0_1.cs)]"
  syntax:
    content: public override void EndWrite (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>返回通过调用实例<xref:System.Net.Security.NegotiateStream.BeginWrite*></xref:System.Net.Security.NegotiateStream.BeginWrite*></xref:System.IAsyncResult>"
  overload: System.Net.Security.NegotiateStream.EndWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "通过调用<xref:System.Net.Security.NegotiateStream.BeginWrite*>.</xref:System.Net.Security.NegotiateStream.BeginWrite*>未创建 asyncResult"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "不发生身份验证。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "写入操作失败。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.Flush
  id: Flush
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: Flush()
  nameWithType: NegotiateStream.Flush()
  fullName: System.Net.Security.NegotiateStream.Flush()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "使所有缓冲的数据都写入基础设备。"
  remarks: "此方法调用<xref:System.IO.Stream.Flush%2A>对基础流。</xref:System.IO.Stream.Flush%2A>"
  example:
  - "The following code example demonstrates flushing the stream.  \n  \n [!code-cs[NclNegoSyncClient#4](~/add/codesnippet/csharp/m-system.net.security.ne_3_1.cs)]\n [!code-cpp[NclNegoSyncClient#4](~/add/codesnippet/cpp/m-system.net.security.ne_3_1.cpp)]"
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.Net.Security.NegotiateStream.Flush*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.ImpersonationLevel
  id: ImpersonationLevel
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: ImpersonationLevel
  nameWithType: NegotiateStream.ImpersonationLevel
  fullName: System.Net.Security.NegotiateStream.ImpersonationLevel
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "获取一个值，该值指示服务器可以如何使用客户端的凭据。"
  remarks: "你必须调用此方法之前已成功验证。 通过调用其中一个请求身份验证时，客户端指定的模拟级别<xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>或<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>方法。</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> </xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> 如果进行身份验证而无需指定<xref:System.Security.Principal.TokenImpersonationLevel>，<xref:System.Security.Principal.TokenImpersonationLevel>使用。</xref:System.Security.Principal.TokenImpersonationLevel> </xref:System.Security.Principal.TokenImpersonationLevel>"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cs[NclNegoSyncClient#1](~/add/codesnippet/csharp/p-system.net.security.ne_5_1.cs)]\n [!code-cpp[NclNegoSyncClient#1](~/add/codesnippet/cpp/p-system.net.security.ne_5_1.cpp)]"
  syntax:
    content: public virtual System.Security.Principal.TokenImpersonationLevel ImpersonationLevel { get; }
    return:
      type: System.Security.Principal.TokenImpersonationLevel
      description: "之一<xref:System.Security.Principal.TokenImpersonationLevel>值。</xref:System.Security.Principal.TokenImpersonationLevel>"
  overload: System.Net.Security.NegotiateStream.ImpersonationLevel*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "身份验证失败或后未发生。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.IsAuthenticated
  id: IsAuthenticated
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: IsAuthenticated
  nameWithType: NegotiateStream.IsAuthenticated
  fullName: System.Net.Security.NegotiateStream.IsAuthenticated
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "获取<xref:System.Boolean>值，该值指示身份验证是否成功。</xref:System.Boolean>"
  remarks: "客户端进行身份验证通过调用<xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>或<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>方法。</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> </xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> 服务器进行身份验证通过调用<xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>或<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>方法。</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> </xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cs[NclNegoSyncClient#1](~/add/codesnippet/csharp/p-system.net.security.ne_10_1.cs)]\n [!code-cpp[NclNegoSyncClient#1](~/add/codesnippet/cpp/p-system.net.security.ne_10_1.cpp)]"
  syntax:
    content: public override bool IsAuthenticated { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果发生了成功的身份验证;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Security.NegotiateStream.IsAuthenticated*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.IsEncrypted
  id: IsEncrypted
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: IsEncrypted
  nameWithType: NegotiateStream.IsEncrypted
  fullName: System.Net.Security.NegotiateStream.IsEncrypted
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "获取<xref:System.Boolean>值，该值指示是否这<xref href=&quot;System.Net.Security.NegotiateStream&quot;></xref>使用数据加密。</xref:System.Boolean>"
  remarks: "加密有助于保护的数据; 的隐私也就是说，它可帮助确保，在传输过程中的数据时它不能破译由第三方。"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cs[NclNegoSyncClient#1](~/add/codesnippet/csharp/p-system.net.security.ne_8_1.cs)]\n [!code-cpp[NclNegoSyncClient#1](~/add/codesnippet/cpp/p-system.net.security.ne_8_1.cpp)]"
  syntax:
    content: public override bool IsEncrypted { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果正在通过网络传输之前加密和解密数据在它到达远程终结点;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Security.NegotiateStream.IsEncrypted*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.IsMutuallyAuthenticated
  id: IsMutuallyAuthenticated
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: IsMutuallyAuthenticated
  nameWithType: NegotiateStream.IsMutuallyAuthenticated
  fullName: System.Net.Security.NegotiateStream.IsMutuallyAuthenticated
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "获取<xref:System.Boolean>值，该值指示是否在服务器和客户端已经过身份验证。</xref:System.Boolean>"
  remarks: "当客户端想要提供身份验证的凭据的服务器，客户端指定相互身份验证。 默认情况下，客户端请求相互身份验证。       协商协议选择 NTLM 或 Kerberos，具体取决于支持的客户端和服务器的安全协议。 NTLM 不支持相互身份验证。"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cs[NclNegoSyncClient#1](~/add/codesnippet/csharp/p-system.net.security.ne_7_1.cs)]\n [!code-cpp[NclNegoSyncClient#1](~/add/codesnippet/cpp/p-system.net.security.ne_7_1.cpp)]"
  syntax:
    content: public override bool IsMutuallyAuthenticated { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果服务器已经过身份验证;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Security.NegotiateStream.IsMutuallyAuthenticated*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.IsServer
  id: IsServer
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: IsServer
  nameWithType: NegotiateStream.IsServer
  fullName: System.Net.Security.NegotiateStream.IsServer
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "获取<xref:System.Boolean>值，该值指示由此是否使用连接的本地端<xref href=&quot;System.Net.Security.NegotiateStream&quot;></xref>与服务器进行身份验证。</xref:System.Boolean>"
  remarks: "如果身份验证失败，或者没有出现，则此属性返回`false`。       若要与服务器进行身份验证，调用<xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>或<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>方法。</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> </xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cs[NclNegoSyncClient#1](~/add/codesnippet/csharp/p-system.net.security.ne_0_1.cs)]\n [!code-cpp[NclNegoSyncClient#1](~/add/codesnippet/cpp/p-system.net.security.ne_0_1.cpp)]"
  syntax:
    content: public override bool IsServer { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果成功，本地终结点进行身份验证作为经过身份验证的连接; 的服务器端否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Security.NegotiateStream.IsServer*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.IsSigned
  id: IsSigned
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: IsSigned
  nameWithType: NegotiateStream.IsSigned
  fullName: System.Net.Security.NegotiateStream.IsSigned
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "获取<xref:System.Boolean>值，该值指示是否使用此流发送的数据进行签名。</xref:System.Boolean>"
  remarks: "数据签名有助于保护的数据中; 完整性也就是说，它可帮助收件人确定是否数据已被篡改在传输过程中。"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cs[NclNegoSyncClient#1](~/add/codesnippet/csharp/p-system.net.security.ne_13_1.cs)]\n [!code-cpp[NclNegoSyncClient#1](~/add/codesnippet/cpp/p-system.net.security.ne_13_1.cpp)]"
  syntax:
    content: public override bool IsSigned { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果数据在传输; 前已签名否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Security.NegotiateStream.IsSigned*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.Length
  id: Length
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: Length
  nameWithType: NegotiateStream.Length
  fullName: System.Net.Security.NegotiateStream.Length
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "获取基础流的长度。"
  remarks: "此属性返回通过调用返回的值<xref:System.IO.Stream.Length%2A>对基础流的属性。</xref:System.IO.Stream.Length%2A> 如果基础流是不可查找的此属性通常将引发异常。 基础流的运行时类型确定引发的异常的运行时类型。"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cs[NclNegoSyncClient#2](~/add/codesnippet/csharp/p-system.net.security.ne_9_1.cs)]\n [!code-cpp[NclNegoSyncClient#2](~/add/codesnippet/cpp/p-system.net.security.ne_9_1.cpp)]"
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "A <xref:System.Int64>，它指定基础流的长度。</xref:System.Int64>"
  overload: System.Net.Security.NegotiateStream.Length*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "获取此属性的值时，不支持的基础流是<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.Position
  id: Position
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: Position
  nameWithType: NegotiateStream.Position
  fullName: System.Net.Security.NegotiateStream.Position
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "获取或设置基础流中的当前位置。"
  remarks: "此属性返回通过调用返回的值<xref:System.IO.Stream.Position%2A>对基础流的属性。</xref:System.IO.Stream.Position%2A> 如果基础流是不可查找的此属性通常将引发异常。 基础流的运行时类型确定引发的异常的运行时类型。"
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "A <xref:System.Int64>，它指定基础流中的当前位置。</xref:System.Int64>"
  overload: System.Net.Security.NegotiateStream.Position*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Setting this property is not supported.  \n  \n \\- or -  \n  \n Getting the value of this property is not supported when the underlying stream is a <xref href=\"System.Net.Sockets.NetworkStream\"></xref>."
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: NegotiateStream.Read(Byte[],Int32,Int32)
  fullName: System.Net.Security.NegotiateStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "从该流中读取数据并将其存储在指定的数组。"
  remarks: "该方法读取的最多`count`字节从当前流，并且将它们存储在`buffer`开始`offset`。       你已成功通过身份验证之前，不能调用此方法。 若要进行身份验证，调用之一<xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>， <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>， <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>，或<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>方法。</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> </xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> </xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> </xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>       若要以异步方式执行此操作，使用<xref:System.Net.Security.NegotiateStream.BeginRead%2A>方法。</xref:System.Net.Security.NegotiateStream.BeginRead%2A>"
  example:
  - "The following code example demonstrates reading from a <xref:System.Net.Security.NegotiateStream>.  \n  \n [!code-cs[NclNegoSyncServer#1](~/add/codesnippet/csharp/e81792fe-7974-494d-8076-_1.cs)]\n [!code-cpp[NclNegoSyncServer#1](~/add/codesnippet/cpp/e81792fe-7974-494d-8076-_1.cpp)]"
  syntax:
    content: public override int Read (byte[] buffer, int offset, int count);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "A<xref:System.Byte>数组，用于接收字节从流中读取。</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "A<xref:System.Int32>包含中的从零开始的位置`buffer`从此处开始存储读取的数据从该流。</xref:System.Int32>"
    - id: count
      type: System.Int32
      description: "A<xref:System.Int32>包含字节从流中读取的最大数目。</xref:System.Int32>"
    return:
      type: System.Int32
      description: "A<xref:System.Int32>从基础流中读取指定的字节数的值。</xref:System.Int32> 如果没有要读取没有更多数据，则返回 0。"
  overload: System.Net.Security.NegotiateStream.Read*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "读取的操作失败。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "不发生身份验证。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "读取操作正在进行。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.ReadTimeout
  id: ReadTimeout
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: ReadTimeout
  nameWithType: NegotiateStream.ReadTimeout
  fullName: System.Net.Security.NegotiateStream.ReadTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "获取或设置读取的操作等待数据的时间量。"
  remarks: "此属性返回通过调用返回的值<xref:System.IO.Stream.ReadTimeout%2A>对基础流的属性。</xref:System.IO.Stream.ReadTimeout%2A> 当设置此属性，<xref:System.IO.Stream.ReadTimeout%2A>对基础流的值设置为指定的值。</xref:System.IO.Stream.ReadTimeout%2A>       如果基础流已<xref:System.Net.Sockets.NetworkStream>，ReadTimeout 以毫秒为单位，并且设置为<xref:System.Threading.Timeout.Infinite>默认情况下，这样一来，读取操作不会超时。</xref:System.Threading.Timeout.Infinite> </xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cs[NclNegoSyncClient#2](~/add/codesnippet/csharp/p-system.net.security.ne_12_1.cs)]\n [!code-cpp[NclNegoSyncClient#2](~/add/codesnippet/cpp/p-system.net.security.ne_12_1.cpp)]"
  syntax:
    content: public override int ReadTimeout { get; set; }
    return:
      type: System.Int32
      description: "A <xref:System.Int32>，它指定的读取的操作失败之前将等待的时间量。</xref:System.Int32>"
  overload: System.Net.Security.NegotiateStream.ReadTimeout*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.RemoteIdentity
  id: RemoteIdentity
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: RemoteIdentity
  nameWithType: NegotiateStream.RemoteIdentity
  fullName: System.Net.Security.NegotiateStream.RemoteIdentity
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "获取有关标识的远程方共享此经过身份验证的流的信息。"
  remarks: "如果客户端访问，该属性返回<xref:System.Security.Principal.GenericIdentity>包含服务的服务器和使用的身份验证协议主体名称 (SPN)。</xref:System.Security.Principal.GenericIdentity> 如果服务器可以访问，该属性返回<xref:System.Security.Principal.WindowsIdentity>描述客户端。</xref:System.Security.Principal.WindowsIdentity> 如果<xref:System.Security.Principal.WindowsIdentity>是不可用，客户端信息返回到一种<xref:System.Security.Principal.GenericIdentity>。</xref:System.Security.Principal.GenericIdentity>中的服务器</xref:System.Security.Principal.WindowsIdentity>"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cs[NclNegoAsyncServer#2](~/add/codesnippet/csharp/p-system.net.security.ne_1_1.cs)]\n [!code-cpp[NclNegoAsyncServer#2](~/add/codesnippet/cpp/p-system.net.security.ne_1_1.cpp)]"
  syntax:
    content: public virtual System.Security.Principal.IIdentity RemoteIdentity { get; }
    return:
      type: System.Security.Principal.IIdentity
      description: "<xref:System.Security.Principal.IIdentity>对象，描述远程终结点的标识。</xref:System.Security.Principal.IIdentity>"
  overload: System.Net.Security.NegotiateStream.RemoteIdentity*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "身份验证失败或后未发生。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: NegotiateStream.Seek(Int64,SeekOrigin)
  fullName: System.Net.Security.NegotiateStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "引发<xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  remarks: "请勿调用此方法。 它继承的但不是受<xref:System.Net.Security.NegotiateStream>.</xref:System.Net.Security.NegotiateStream>"
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "将忽略此值。"
    - id: origin
      type: System.IO.SeekOrigin
      description: "将忽略此值。"
    return:
      type: System.Int64
      description: "总是引发一种<xref:System.NotSupportedException>。</xref:System.NotSupportedException>"
  overload: System.Net.Security.NegotiateStream.Seek*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "不支持查找<xref href=&quot;System.Net.Security.NegotiateStream&quot;> </xref>。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: NegotiateStream.SetLength(Int64)
  fullName: System.Net.Security.NegotiateStream.SetLength(Int64)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "设置基础流的长度。"
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "<xref:System.Int64>值，该值指定流的长度。</xref:System.Int64>"
  overload: System.Net.Security.NegotiateStream.SetLength*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: NegotiateStream.Write(Byte[],Int32,Int32)
  fullName: System.Net.Security.NegotiateStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "写入指定的数<xref:System.Byte>对基础流使用指定的缓冲区和偏移量的 s。</xref:System.Byte>"
  remarks: "如果启用了加密、 签名或加密和签名，此方法从缓冲区中读取数据、 加密，符号，或对进行加密和签名，以及传输使用基础流。 如果任何安全不服务 （如数据加密或签名） 中使用，此方法将调用<xref:System.IO.Stream.Write%2A>对基础流。</xref:System.IO.Stream.Write%2A>       当在写入操作完成时，将阻止此方法。 若要防止阻塞操作完成时，使用 Write 方法。       你已成功通过身份验证之前，不能调用此方法。 若要进行身份验证，调用之一<xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>， <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>， <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>，或<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>方法。</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> </xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> </xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> </xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>       <xref:System.Net.Security.NegotiateStream>类不支持多个同时进行的写入操作。</xref:System.Net.Security.NegotiateStream> 如果你尝试开始写入操作，而另一个写入操作已经在执行对同一个流，<xref:System.NotSupportedException>将引发异常。</xref:System.NotSupportedException>"
  example:
  - "The following code example demonstrates writing to a <xref:System.Net.Security.NegotiateStream>.  \n  \n [!code-cs[NclNegoSyncClient#4](~/add/codesnippet/csharp/1536316b-fecf-4b4a-b33a-_1.cs)]\n [!code-cpp[NclNegoSyncClient#4](~/add/codesnippet/cpp/1536316b-fecf-4b4a-b33a-_1.cpp)]"
  syntax:
    content: public override void Write (byte[] buffer, int offset, int count);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "A<xref:System.Byte>提供写入流中的字节的数组。</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "<xref:System.Int32>包含中的从零开始的位置`buffer`从此处开始读取要写入到流的字节。</xref:System.Int32>"
    - id: count
      type: System.Int32
      description: "A<xref:System.Int32>包含要读取的字节数`buffer`。</xref:System.Int32>"
  overload: System.Net.Security.NegotiateStream.Write*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>offset is less than 0</code>.  \n  \n \\- or -  \n  \n <code>offset</code> is greater than the length of <code>buffer</code>.  \n  \n \\- or -  \n  \n <code>offset</code> plus count is greater than the length of <code>buffer</code>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "The write operation failed.  \n  \n \\- or -  \n  \n Encryption is in use, but the data could not be encrypted."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "已存在正在进行的写入操作。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此对象已关闭。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "不发生身份验证。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.WriteTimeout
  id: WriteTimeout
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: WriteTimeout
  nameWithType: NegotiateStream.WriteTimeout
  fullName: System.Net.Security.NegotiateStream.WriteTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "获取或设置等待数据写入操作的时间量。"
  remarks: "此属性返回通过调用返回的值<xref:System.IO.Stream.WriteTimeout%2A>对基础流的属性。</xref:System.IO.Stream.WriteTimeout%2A> 对于集合运算指定的值设置<xref:System.IO.Stream.WriteTimeout%2A>对基础流的值。</xref:System.IO.Stream.WriteTimeout%2A>       如果基础流已<xref:System.Net.Sockets.NetworkStream>，WriteTimeout 以毫秒为单位，并且设置为<xref:System.Threading.Timeout.Infinite>默认情况下，因此写操作就不会超时。</xref:System.Threading.Timeout.Infinite> </xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cs[NclNegoSyncClient#2](~/add/codesnippet/csharp/p-system.net.security.ne_11_1.cs)]\n [!code-cpp[NclNegoSyncClient#2](~/add/codesnippet/cpp/p-system.net.security.ne_11_1.cpp)]"
  syntax:
    content: public override int WriteTimeout { get; set; }
    return:
      type: System.Int32
      description: "A <xref:System.Int32>，它指定的写入操作失败之前将等待的时间量。</xref:System.Int32>"
  overload: System.Net.Security.NegotiateStream.WriteTimeout*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Net.Security.AuthenticatedStream
  isExternal: false
  name: System.Net.Security.AuthenticatedStream
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.Security.Authentication.AuthenticationException
  parent: System.Security.Authentication
  isExternal: false
  name: AuthenticationException
  nameWithType: AuthenticationException
  fullName: System.Security.Authentication.AuthenticationException
- uid: System.Security.Authentication.InvalidCredentialException
  parent: System.Security.Authentication
  isExternal: false
  name: InvalidCredentialException
  nameWithType: InvalidCredentialException
  fullName: System.Security.Authentication.InvalidCredentialException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.Net.Security.NegotiateStream.#ctor(System.IO.Stream)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: NegotiateStream(Stream)
  nameWithType: NegotiateStream.NegotiateStream(Stream)
  fullName: System.Net.Security.NegotiateStream.NegotiateStream(Stream)
- uid: System.IO.Stream
  parent: System.IO
  isExternal: true
  name: Stream
  nameWithType: Stream
  fullName: System.IO.Stream
- uid: System.Net.Security.NegotiateStream.#ctor(System.IO.Stream,System.Boolean)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: NegotiateStream(Stream,Boolean)
  nameWithType: NegotiateStream.NegotiateStream(Stream,Boolean)
  fullName: System.Net.Security.NegotiateStream.NegotiateStream(Stream,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClient
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsClient()
  nameWithType: NegotiateStream.AuthenticateAsClient()
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClient()
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.String)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsClient(NetworkCredential,String)
  nameWithType: NegotiateStream.AuthenticateAsClient(NetworkCredential,String)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClient(NetworkCredential,String)
- uid: System.Net.NetworkCredential
  parent: System.Net
  isExternal: true
  name: NetworkCredential
  nameWithType: NetworkCredential
  fullName: System.Net.NetworkCredential
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsClient(NetworkCredential,ChannelBinding,String)
  nameWithType: NegotiateStream.AuthenticateAsClient(NetworkCredential,ChannelBinding,String)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClient(NetworkCredential,ChannelBinding,String)
- uid: System.Security.Authentication.ExtendedProtection.ChannelBinding
  parent: System.Security.Authentication.ExtendedProtection
  isExternal: true
  name: ChannelBinding
  nameWithType: ChannelBinding
  fullName: System.Security.Authentication.ExtendedProtection.ChannelBinding
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsClient(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsClient(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClient(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel)
- uid: System.Net.Security.ProtectionLevel
  parent: System.Net.Security
  isExternal: false
  name: ProtectionLevel
  nameWithType: ProtectionLevel
  fullName: System.Net.Security.ProtectionLevel
- uid: System.Security.Principal.TokenImpersonationLevel
  parent: System.Security.Principal
  isExternal: true
  name: TokenImpersonationLevel
  nameWithType: TokenImpersonationLevel
  fullName: System.Security.Principal.TokenImpersonationLevel
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsClient(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsClient(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClient(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel)
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsClientAsync()
  nameWithType: NegotiateStream.AuthenticateAsClientAsync()
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync()
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsClientAsync(NetworkCredential,String)
  nameWithType: NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,String)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,String)
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsClientAsync(NetworkCredential,ChannelBinding,String)
  nameWithType: NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,ChannelBinding,String)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,ChannelBinding,String)
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsClientAsync(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel)
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsClientAsync(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel)
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServer
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsServer()
  nameWithType: NegotiateStream.AuthenticateAsServer()
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServer()
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsServer(ExtendedProtectionPolicy)
  nameWithType: NegotiateStream.AuthenticateAsServer(ExtendedProtectionPolicy)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServer(ExtendedProtectionPolicy)
- uid: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
  parent: System.Security.Authentication.ExtendedProtection
  isExternal: false
  name: ExtendedProtectionPolicy
  nameWithType: ExtendedProtectionPolicy
  fullName: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsServer(NetworkCredential,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsServer(NetworkCredential,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServer(NetworkCredential,ProtectionLevel,TokenImpersonationLevel)
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsServer(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsServer(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServer(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel)
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsServerAsync()
  nameWithType: NegotiateStream.AuthenticateAsServerAsync()
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync()
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsServerAsync(ExtendedProtectionPolicy)
  nameWithType: NegotiateStream.AuthenticateAsServerAsync(ExtendedProtectionPolicy)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(ExtendedProtectionPolicy)
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsServerAsync(NetworkCredential,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsServerAsync(NetworkCredential,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(NetworkCredential,ProtectionLevel,TokenImpersonationLevel)
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsServerAsync(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsServerAsync(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel)
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: BeginAuthenticateAsClient(AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsClient(AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: BeginAuthenticateAsClient(NetworkCredential,String,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,String,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,String,AsyncCallback,Object)
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: BeginAuthenticateAsClient(NetworkCredential,ChannelBinding,String,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,ChannelBinding,String,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,ChannelBinding,String,AsyncCallback,Object)
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: BeginAuthenticateAsClient(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: BeginAuthenticateAsClient(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: BeginAuthenticateAsServer(AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsServer(AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(AsyncCallback,Object)
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: BeginAuthenticateAsServer(ExtendedProtectionPolicy,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsServer(ExtendedProtectionPolicy,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(ExtendedProtectionPolicy,AsyncCallback,Object)
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: BeginAuthenticateAsServer(NetworkCredential,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsServer(NetworkCredential,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(NetworkCredential,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: BeginAuthenticateAsServer(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsServer(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
- uid: System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.Net.Security.NegotiateStream.CanRead
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: CanRead
  nameWithType: NegotiateStream.CanRead
  fullName: System.Net.Security.NegotiateStream.CanRead
- uid: System.Net.Security.NegotiateStream.CanSeek
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: CanSeek
  nameWithType: NegotiateStream.CanSeek
  fullName: System.Net.Security.NegotiateStream.CanSeek
- uid: System.Net.Security.NegotiateStream.CanTimeout
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: CanTimeout
  nameWithType: NegotiateStream.CanTimeout
  fullName: System.Net.Security.NegotiateStream.CanTimeout
- uid: System.Net.Security.NegotiateStream.CanWrite
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: CanWrite
  nameWithType: NegotiateStream.CanWrite
  fullName: System.Net.Security.NegotiateStream.CanWrite
- uid: System.Net.Security.NegotiateStream.Dispose(System.Boolean)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: NegotiateStream.Dispose(Boolean)
  fullName: System.Net.Security.NegotiateStream.Dispose(Boolean)
- uid: System.Net.Security.NegotiateStream.EndAuthenticateAsClient(System.IAsyncResult)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: EndAuthenticateAsClient(IAsyncResult)
  nameWithType: NegotiateStream.EndAuthenticateAsClient(IAsyncResult)
  fullName: System.Net.Security.NegotiateStream.EndAuthenticateAsClient(IAsyncResult)
- uid: System.Net.Security.NegotiateStream.EndAuthenticateAsServer(System.IAsyncResult)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: EndAuthenticateAsServer(IAsyncResult)
  nameWithType: NegotiateStream.EndAuthenticateAsServer(IAsyncResult)
  fullName: System.Net.Security.NegotiateStream.EndAuthenticateAsServer(IAsyncResult)
- uid: System.Net.Security.NegotiateStream.EndRead(System.IAsyncResult)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: EndRead(IAsyncResult)
  nameWithType: NegotiateStream.EndRead(IAsyncResult)
  fullName: System.Net.Security.NegotiateStream.EndRead(IAsyncResult)
- uid: System.Net.Security.NegotiateStream.EndWrite(System.IAsyncResult)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: EndWrite(IAsyncResult)
  nameWithType: NegotiateStream.EndWrite(IAsyncResult)
  fullName: System.Net.Security.NegotiateStream.EndWrite(IAsyncResult)
- uid: System.Net.Security.NegotiateStream.Flush
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: Flush()
  nameWithType: NegotiateStream.Flush()
  fullName: System.Net.Security.NegotiateStream.Flush()
- uid: System.Net.Security.NegotiateStream.ImpersonationLevel
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: ImpersonationLevel
  nameWithType: NegotiateStream.ImpersonationLevel
  fullName: System.Net.Security.NegotiateStream.ImpersonationLevel
- uid: System.Net.Security.NegotiateStream.IsAuthenticated
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: IsAuthenticated
  nameWithType: NegotiateStream.IsAuthenticated
  fullName: System.Net.Security.NegotiateStream.IsAuthenticated
- uid: System.Net.Security.NegotiateStream.IsEncrypted
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: IsEncrypted
  nameWithType: NegotiateStream.IsEncrypted
  fullName: System.Net.Security.NegotiateStream.IsEncrypted
- uid: System.Net.Security.NegotiateStream.IsMutuallyAuthenticated
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: IsMutuallyAuthenticated
  nameWithType: NegotiateStream.IsMutuallyAuthenticated
  fullName: System.Net.Security.NegotiateStream.IsMutuallyAuthenticated
- uid: System.Net.Security.NegotiateStream.IsServer
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: IsServer
  nameWithType: NegotiateStream.IsServer
  fullName: System.Net.Security.NegotiateStream.IsServer
- uid: System.Net.Security.NegotiateStream.IsSigned
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: IsSigned
  nameWithType: NegotiateStream.IsSigned
  fullName: System.Net.Security.NegotiateStream.IsSigned
- uid: System.Net.Security.NegotiateStream.Length
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: Length
  nameWithType: NegotiateStream.Length
  fullName: System.Net.Security.NegotiateStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Net.Security.NegotiateStream.Position
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: Position
  nameWithType: NegotiateStream.Position
  fullName: System.Net.Security.NegotiateStream.Position
- uid: System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: NegotiateStream.Read(Byte[],Int32,Int32)
  fullName: System.Net.Security.NegotiateStream.Read(Byte[],Int32,Int32)
- uid: System.Net.Security.NegotiateStream.ReadTimeout
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: ReadTimeout
  nameWithType: NegotiateStream.ReadTimeout
  fullName: System.Net.Security.NegotiateStream.ReadTimeout
- uid: System.Net.Security.NegotiateStream.RemoteIdentity
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: RemoteIdentity
  nameWithType: NegotiateStream.RemoteIdentity
  fullName: System.Net.Security.NegotiateStream.RemoteIdentity
- uid: System.Security.Principal.IIdentity
  parent: System.Security.Principal
  isExternal: true
  name: IIdentity
  nameWithType: IIdentity
  fullName: System.Security.Principal.IIdentity
- uid: System.Net.Security.NegotiateStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: NegotiateStream.Seek(Int64,SeekOrigin)
  fullName: System.Net.Security.NegotiateStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.Net.Security.NegotiateStream.SetLength(System.Int64)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: NegotiateStream.SetLength(Int64)
  fullName: System.Net.Security.NegotiateStream.SetLength(Int64)
- uid: System.Net.Security.NegotiateStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: NegotiateStream.Write(Byte[],Int32,Int32)
  fullName: System.Net.Security.NegotiateStream.Write(Byte[],Int32,Int32)
- uid: System.Net.Security.NegotiateStream.WriteTimeout
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: WriteTimeout
  nameWithType: NegotiateStream.WriteTimeout
  fullName: System.Net.Security.NegotiateStream.WriteTimeout
- uid: System.Net.Security.NegotiateStream.#ctor*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: NegotiateStream
  nameWithType: NegotiateStream.NegotiateStream
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClient*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsClient
  nameWithType: NegotiateStream.AuthenticateAsClient
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsClientAsync
  nameWithType: NegotiateStream.AuthenticateAsClientAsync
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServer*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsServer
  nameWithType: NegotiateStream.AuthenticateAsServer
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsServerAsync
  nameWithType: NegotiateStream.AuthenticateAsServerAsync
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: BeginAuthenticateAsClient
  nameWithType: NegotiateStream.BeginAuthenticateAsClient
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: BeginAuthenticateAsServer
  nameWithType: NegotiateStream.BeginAuthenticateAsServer
- uid: System.Net.Security.NegotiateStream.BeginRead*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: BeginRead
  nameWithType: NegotiateStream.BeginRead
- uid: System.Net.Security.NegotiateStream.BeginWrite*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: BeginWrite
  nameWithType: NegotiateStream.BeginWrite
- uid: System.Net.Security.NegotiateStream.CanRead*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: CanRead
  nameWithType: NegotiateStream.CanRead
- uid: System.Net.Security.NegotiateStream.CanSeek*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: CanSeek
  nameWithType: NegotiateStream.CanSeek
- uid: System.Net.Security.NegotiateStream.CanTimeout*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: CanTimeout
  nameWithType: NegotiateStream.CanTimeout
- uid: System.Net.Security.NegotiateStream.CanWrite*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: CanWrite
  nameWithType: NegotiateStream.CanWrite
- uid: System.Net.Security.NegotiateStream.Dispose*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: Dispose
  nameWithType: NegotiateStream.Dispose
- uid: System.Net.Security.NegotiateStream.EndAuthenticateAsClient*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: EndAuthenticateAsClient
  nameWithType: NegotiateStream.EndAuthenticateAsClient
- uid: System.Net.Security.NegotiateStream.EndAuthenticateAsServer*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: EndAuthenticateAsServer
  nameWithType: NegotiateStream.EndAuthenticateAsServer
- uid: System.Net.Security.NegotiateStream.EndRead*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: EndRead
  nameWithType: NegotiateStream.EndRead
- uid: System.Net.Security.NegotiateStream.EndWrite*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: EndWrite
  nameWithType: NegotiateStream.EndWrite
- uid: System.Net.Security.NegotiateStream.Flush*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: Flush
  nameWithType: NegotiateStream.Flush
- uid: System.Net.Security.NegotiateStream.ImpersonationLevel*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: ImpersonationLevel
  nameWithType: NegotiateStream.ImpersonationLevel
- uid: System.Net.Security.NegotiateStream.IsAuthenticated*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: IsAuthenticated
  nameWithType: NegotiateStream.IsAuthenticated
- uid: System.Net.Security.NegotiateStream.IsEncrypted*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: IsEncrypted
  nameWithType: NegotiateStream.IsEncrypted
- uid: System.Net.Security.NegotiateStream.IsMutuallyAuthenticated*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: IsMutuallyAuthenticated
  nameWithType: NegotiateStream.IsMutuallyAuthenticated
- uid: System.Net.Security.NegotiateStream.IsServer*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: IsServer
  nameWithType: NegotiateStream.IsServer
- uid: System.Net.Security.NegotiateStream.IsSigned*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: IsSigned
  nameWithType: NegotiateStream.IsSigned
- uid: System.Net.Security.NegotiateStream.Length*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: Length
  nameWithType: NegotiateStream.Length
- uid: System.Net.Security.NegotiateStream.Position*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: Position
  nameWithType: NegotiateStream.Position
- uid: System.Net.Security.NegotiateStream.Read*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: Read
  nameWithType: NegotiateStream.Read
- uid: System.Net.Security.NegotiateStream.ReadTimeout*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: ReadTimeout
  nameWithType: NegotiateStream.ReadTimeout
- uid: System.Net.Security.NegotiateStream.RemoteIdentity*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: RemoteIdentity
  nameWithType: NegotiateStream.RemoteIdentity
- uid: System.Net.Security.NegotiateStream.Seek*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: Seek
  nameWithType: NegotiateStream.Seek
- uid: System.Net.Security.NegotiateStream.SetLength*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: SetLength
  nameWithType: NegotiateStream.SetLength
- uid: System.Net.Security.NegotiateStream.Write*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: Write
  nameWithType: NegotiateStream.Write
- uid: System.Net.Security.NegotiateStream.WriteTimeout*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: WriteTimeout
  nameWithType: NegotiateStream.WriteTimeout
