### YamlMime:ManagedReference
items:
- uid: System.Threading.ThreadPool
  id: ThreadPool
  children:
  - System.Threading.ThreadPool.BindHandle(System.IntPtr)
  - System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)
  - System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)
  - System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)
  - System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)
  - System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)
  - System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  - System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)
  - System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)
  - System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  - System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  langs:
  - csharp
  name: ThreadPool
  nameWithType: ThreadPool
  fullName: System.Threading.ThreadPool
  type: Class
  summary: "提供一个用于执行任务、 发送工作项、 处理异步 I/O、 代表其他线程等待和处理计时器的线程池。"
  remarks: "许多应用程序创建花费大量时间处于睡眠状态，等待事件发生的线程。 其他线程可能会进入休眠状态，只是为了被唤醒，定期轮询更改或更新状态信息。 线程池，可通过提供一个受系统管理的辅助线程池上的应用程序更有效地使用线程。 使用线程池线程的操作示例包括以下:-当你创建<xref:System.Threading.Tasks.Task>或<xref:System.Threading.Tasks.Task%601>对象来执行某些任务以异步方式，默认情况下，计划任务在线程池线程上运行。</xref:System.Threading.Tasks.Task%601> </xref:System.Threading.Tasks.Task>      -异步计时器使用线程池。 线程池线程执行回调从<xref:System.Threading.Timer?displayProperty=fullName>从<xref:System.Timers.Timer?displayProperty=fullName>类</xref:System.Timers.Timer?displayProperty=fullName>的类和引发事件</xref:System.Threading.Timer?displayProperty=fullName>      -当你使用已注册的等待句柄，某个系统线程监视等待句柄的状态。 等待操作完成后，从线程池工作线程将执行对应的回调函数。      -当你调用<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法进行排队以在线程池线程上执行的方法。</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> 通过传递给该方法执行此操作<xref:System.Threading.WaitCallback>委派。</xref:System.Threading.WaitCallback>   委托具有签名<CodeContentPlaceHolder>0</CodeContentPlaceHolder><CodeContentPlaceHolder>1</CodeContentPlaceHolder>其中`state`是一个对象，包含由委托使用的数据。    实际的数据可以通过调用传递给委托<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>方法。</xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>      1> [!NOTE]&1;> 在托管的线程池线程是后台线程。 即，其<xref:System.Threading.Thread.IsBackground%2A>属性`true`。</xref:System.Threading.Thread.IsBackground%2A> 这意味着线程池线程不会对所有前台线程均都退出之后运行的应用程序。      1> [!IMPORTANT]&1;> 时线程池重用某个线程，它不会清除在线程本地存储或使用标记的字段中的数据<xref:System.ThreadStaticAttribute>属性。</xref:System.ThreadStaticAttribute> 因此，检查线程本地存储区或的字段的方法标记有<xref:System.ThreadStaticAttribute>属性，它找到的值可能会留下线程池线程更早版本使用过程中。</xref:System.ThreadStaticAttribute>       你可以排队到线程池等待操作不相关的工作项。 若要请求的工作项来处理线程池中线程，调用<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法。</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> 此方法将对该方法或将由所选线程池中的线程调用的委托的引用作为参数。 没有方法来取消工作项之后它已在排队等候。       计时器队列中的计时器和已注册的等待操作也使用线程池。 它们的回调函数要排队发送至线程池。       没有每个进程的一个线程池。 开头[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]，线程池的进程的默认大小取决于若干因素，例如虚拟地址空间的大小。 进程可以调用<xref:System.Threading.ThreadPool.GetMaxThreads%2A>方法，以确定线程数。</xref:System.Threading.ThreadPool.GetMaxThreads%2A> 可以使用更改线程池中的线程数<xref:System.Threading.ThreadPool.SetMaxThreads%2A>方法。</xref:System.Threading.ThreadPool.SetMaxThreads%2A> 每个线程使用的默认堆栈大小，并运行默认优先级。      1> [!NOTE]&1;> 承载.NET Framework 的非托管的代码可以更改通过使用线程池的大小`CorSetMaxThreads`mscoree.h 文件中定义的函数。       线程池按需提供新的辅助线程或 I/O 完成线程直到它达到每个类别的最低要求。 当达到最小值时，线程池可以在该类别中创建其他线程或等待，直到一些任务完成。 开头[!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]，线程池创建和销毁工作线程以优化吞吐量，吞吐量被定义为每个单位时间完成的任务数。 线程过少不可能实现可用资源的最优利用，而线程过多则可能增加资源争用。      1> [!NOTE]&1;> 时需求较低，线程池线程的实际数量可以低于最小值。       你可以使用<xref:System.Threading.ThreadPool.GetMinThreads%2A>方法来获取这些最小值。</xref:System.Threading.ThreadPool.GetMinThreads%2A>      1> [!CAUTION]&1;> 可以使用<xref:System.Threading.ThreadPool.SetMinThreads%2A>方法来增加最小线程数。</xref:System.Threading.ThreadPool.SetMinThreads%2A> 但是，不必要地增加这些值可能导致性能问题。 如果在同一时间开始太多的任务，所有这些可能会很慢。 在大多数情况下线程池将使用其自己的分配线程算法更好地执行。"
  example:
  - "In the following example, the main application thread  queues a method named `ThreadProc` to execute on a thread pool thread, sleeps for one second, and then exits. The `ThreadProc` method simply displays a message.  \n  \n [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/cpp/t-system.threading.threa_5_1.cpp)]\n [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/visualbasic/t-system.threading.threa_5_1.vb)]\n [!code-cs[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/csharp/t-system.threading.threa_5_1.cs)]  \n  \n If you comment out the call to the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method, the main thread exits before         method runs on the thread pool thread.  The thread pool uses background         threads, which do not keep the application running if all foreground threads have terminated.  (This         is a simple example of a race condition.)"
  syntax:
    content: public static class ThreadPool
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.BindHandle(System.IntPtr)
  id: BindHandle(System.IntPtr)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: BindHandle(IntPtr)
  nameWithType: ThreadPool.BindHandle(IntPtr)
  fullName: System.Threading.ThreadPool.BindHandle(IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "将绑定到的操作系统句柄<xref href=&quot;System.Threading.ThreadPool&quot;> </xref>。"
  syntax:
    content: public static bool BindHandle (IntPtr osHandle);
    parameters:
    - id: osHandle
      type: System.IntPtr
      description: "<xref:System.IntPtr>持有句柄。</xref:System.IntPtr> 必须已为非托管端重叠 I/O 打开了句柄。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果句柄绑定;，否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Threading.ThreadPool.BindHandle*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  platform:
  - net462
- uid: System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)
  id: BindHandle(System.Runtime.InteropServices.SafeHandle)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: BindHandle(SafeHandle)
  nameWithType: ThreadPool.BindHandle(SafeHandle)
  fullName: System.Threading.ThreadPool.BindHandle(SafeHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "将绑定到的操作系统句柄<xref href=&quot;System.Threading.ThreadPool&quot;> </xref>。"
  remarks: "`osHandle`参数应该是的<xref:Microsoft.Win32.SafeHandles.SafeFileHandle>，其派生自抽象<xref:System.Runtime.InteropServices.SafeHandle>类。</xref:System.Runtime.InteropServices.SafeHandle> </xref:Microsoft.Win32.SafeHandles.SafeFileHandle>"
  syntax:
    content: public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);
    parameters:
    - id: osHandle
      type: System.Runtime.InteropServices.SafeHandle
      description: "A<xref:System.Runtime.InteropServices.SafeHandle>保存操作系统句柄。</xref:System.Runtime.InteropServices.SafeHandle> 必须已为非托管端重叠 I/O 打开了句柄。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果句柄绑定;，否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Threading.ThreadPool.BindHandle*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>osHandle</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)
  id: GetAvailableThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: GetAvailableThreads(Int32,Int32)
  nameWithType: ThreadPool.GetAvailableThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetAvailableThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "检索的最大返回的线程池线程数之间的差异<xref:System.Threading.ThreadPool.GetMaxThreads*>方法，并且当前处于活动状态的数量。</xref:System.Threading.ThreadPool.GetMaxThreads*>"
  remarks: "当 GetAvailableThreads 返回时，指定的变量`workerThreads`包含可以启动的其他工作线程和指定的变量的数量`completionPortThreads`包含可以启动的其他异步 I/O 线程数。       如果没有可用的线程，其他线程池请求保持排队状态，直到线程池线程变为可用。"
  example:
  - "The following example displays the number of worker threads and I/O threads available when a simple app is started.  \n  \n [!code-cs[System.Threading.ThreadPool.GetAvailableThreads#2](~/add/codesnippet/csharp/m-system.threading.threa_23_1.cs)]\n [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/add/codesnippet/visualbasic/m-system.threading.threa_23_1.vb)]"
  syntax:
    content: public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "可用的工作线程数。"
    - id: completionPortThreads
      type: System.Int32
      description: "可用异步 I/O 线程数。"
  overload: System.Threading.ThreadPool.GetAvailableThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)
  id: GetMaxThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: GetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMaxThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "检索可以同时处于活动状态的线程池的请求数。 大于此数目的所有请求将都保持排队，直到线程池线程变为可用。"
  remarks: "当 GetMaxThreads 返回时，指定的变量`workerThreads`包含在线程池中允许的工作线程和指定的变量的最大数目`completionPortThreads`包含在线程池中允许的异步 I/O 线程的最大数目。       你可以使用<xref:System.Threading.ThreadPool.GetAvailableThreads%2A>方法来确定在任何给定时间在线程池中的线程的实际数量。</xref:System.Threading.ThreadPool.GetAvailableThreads%2A>       你可以使用<xref:System.Threading.ThreadPool.SetMaxThreads%2A>在线程池中设置的最大工作线程和异步 I/O 线程数。</xref:System.Threading.ThreadPool.SetMaxThreads%2A>       你可以排队尽可能的系统内存允许线程池请求。 如果有更多的请求数多于线程池线程数，则其他请求保持排队状态，直到线程池线程变为可用。"
  example:
  - "The following code example shows how to retrieve a count of the maximum and available number of threads in the thread pool. A work item is queued that uses `FileStream` to asynchronously write to two files. The callback methods are timed to overlap. A worker thread handles the work item and, depending on the speed and number of processors on the computer, one or two completion port threads handle the write operations.  \n  \n [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/add/codesnippet/cpp/m-system.threading.threa_14_1.cpp)]\n [!code-cs[System.Threading.ThreadPool.GetAvailableThreads#1](~/add/codesnippet/csharp/m-system.threading.threa_14_1.cs)]\n [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/add/codesnippet/visualbasic/m-system.threading.threa_14_1.vb)]"
  syntax:
    content: public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "最大线程池中辅助线程数。"
    - id: completionPortThreads
      type: System.Int32
      description: "最大线程池中异步 I/O 线程数。"
  overload: System.Threading.ThreadPool.GetMaxThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)
  id: GetMinThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: GetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMinThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "进行新的请求时，在切换到管理线程创建和销毁的算法之前检索的最小线程池根据需要，创建的线程数。"
  remarks: "线程池按需提供新的辅助线程或 I/O 完成线程直到它达到每个类别的最低要求。 默认情况下，最小线程数设置为在系统上的处理器数。 当达到最小值时，线程池可以在该类别中创建其他线程或等待，直到一些任务完成。 开头[!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]，线程池创建和销毁线程以优化吞吐量，吞吐量被定义为每个单位时间完成的任务数。 线程过少不可能实现可用资源的最优利用，而线程过多则可能增加资源争用。      1> [!NOTE]&1;> 时需求较低，线程池线程的实际数量可以低于最小值。"
  example:
  - "The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.  \n  \n [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/visualbasic/m-system.threading.threa_20_1.vb)]\n [!code-cs[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/csharp/m-system.threading.threa_20_1.cs)]\n [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/cpp/m-system.threading.threa_20_1.cpp)]"
  syntax:
    content: public static void GetMinThreads (out int workerThreads, out int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "此方法返回时，包含的最小线程池根据需要创建的工作线程数。"
    - id: completionPortThreads
      type: System.Int32
      description: "此方法返回时，包含的最小线程池根据需要创建的异步 I/O 线程数。"
  overload: System.Threading.ThreadPool.GetMinThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)
  id: QueueUserWorkItem(System.Threading.WaitCallback)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: QueueUserWorkItem(WaitCallback)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "方法排入队列以便执行。 方法在线程池线程变得可用时执行。"
  remarks: "您可以将数据排队方法的类定义方法，或可以使用的实例字段中所需的放置<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>重载接受一个包含所需数据的对象。</xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>      1> [!NOTE]&1;> Visual Basic 用户可以省略<xref:System.Threading.WaitCallback>构造函数，并且只需使用`AddressOf`运算符时将回调方法传递给<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> </xref:System.Threading.WaitCallback> Visual Basic 会自动调用正确的委托构造函数。      ## 版本信息在.NET Framework 2.0 版中，<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>属性值将传播到辅助线程排队使用<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法。</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> 在早期版本，不会传播的主体的信息。"
  example:
  - "The following example uses the QueueUserWorkItem method overload to queue a task, which is represented by the `ThreadProc` method, to execute when a thread becomes available. No task information is supplied with this overload. Therefore, the information that is available to the `ThreadProc` method is limited to the object the method belongs to.  \n  \n [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/cpp/m-system.threading.threa_22_1.cpp)]\n [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/visualbasic/m-system.threading.threa_22_1.vb)]\n [!code-cs[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/csharp/m-system.threading.threa_22_1.cs)]"
  syntax:
    content: public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);
    parameters:
    - id: callBack
      type: System.Threading.WaitCallback
      description: "A <xref href=&quot;System.Threading.WaitCallback&quot;> </xref> ，表示要执行的方法。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果此方法成功排队;<xref:System.NotSupportedException>无法排队的工作项时引发。</xref:System.NotSupportedException>"
  overload: System.Threading.ThreadPool.QueueUserWorkItem*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "承载公共语言运行时 (CLR)，和主机不支持此操作。"
  platform:
  - net462
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  id: QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: QueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "方法排入队列的执行，并指定包含要方法要使用的数据的对象。 方法在线程池线程变得可用时执行。"
  remarks: "如果回调方法需要复杂的数据，你可以定义一个类来包含的数据。      1> [!NOTE]&1;> Visual Basic 用户可以省略<xref:System.Threading.WaitCallback>构造函数，并且只需使用`AddressOf`运算符时将回调方法传递到 QueueUserWorkItem。</xref:System.Threading.WaitCallback> Visual Basic 会自动调用正确的委托构造函数。      ## 版本信息在.NET Framework 2.0 版中，<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>属性值将传播到辅助线程排队使用<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法。</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> 在早期版本，不会传播的主体的信息。"
  example:
  - "The following example shows how to create an object that contains task information. It also demonstrates how to pass that object to a task that is queued for execution by the thread pool.  \n  \n [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/add/codesnippet/cpp/9389ae71-aa49-4ceb-9b0a-_1.cpp)]\n [!code-cs[System.Threading.ThreadPool QueueUserWorkItem1#1](~/add/codesnippet/csharp/9389ae71-aa49-4ceb-9b0a-_1.cs)]\n [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/add/codesnippet/visualbasic/9389ae71-aa49-4ceb-9b0a-_1.vb)]"
  syntax:
    content: public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);
    parameters:
    - id: callBack
      type: System.Threading.WaitCallback
      description: "A <xref href=&quot;System.Threading.WaitCallback&quot;> </xref>表示要执行的方法。"
    - id: state
      type: System.Object
      description: "一个包含数据的方法要使用的对象。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果此方法成功排队;<xref:System.NotSupportedException>无法排队的工作项时引发。</xref:System.NotSupportedException>"
  overload: System.Threading.ThreadPool.QueueUserWorkItem*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "承载公共语言运行时 (CLR)，和主机不支持此操作。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "注册委托以等待<xref:System.Threading.WaitHandle>，以毫秒为单位指定超时 32 位有符号的整数。</xref:System.Threading.WaitHandle>"
  remarks: "完成之后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法来释放对等待句柄的引用。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> 我们建议你始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，即使你指定`true`为`executeOnlyOnce`。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> 垃圾回收的工作的详细信息有效地如果调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法而不是具体取决于已注册的等待句柄的终结器。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       RegisterWaitForSingleObject 方法指定的委托排队到线程池。 在下列情况之一发生时，工作线程将执行委托:-指定的对象处于终止状态。      -超时间隔已过期。       RegisterWaitForSingleObject 方法检查指定对象的<xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle>的当前状态 如果对象的状态为非终止状态，该方法将注册一个等待操作。 等待操作由线程池中的线程执行。 对象的状态将被发送信号或超时间隔结束时，将通过工作线程执行委托。 如果`timeOutInterval`参数不是 0 （零） 和`executeOnlyOnce`参数是`false`，每次该事件处于有信号状态或达到超时间隔重置计时器。      1> [!IMPORTANT]&1;> 使用<xref:System.Threading.Mutex>为`waitObject`不提供的回调的互相排斥，因为基础的 Win32 API 使用默认值`WT_EXECUTEDEFAULT`标志，以便在一个单独的线程池线程上调度每个回调。</xref:System.Threading.Mutex> 而不是<xref:System.Threading.Mutex>，使用<xref:System.Threading.Semaphore>与的最大计数为 1。</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       若要取消等待操作，请调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       等待线程使用 Win32`WaitForMultipleObjects`函数来监视已注册的等待操作。 因此，如果多个调用 RegisterWaitForSingleObject，必须使用相同的本机操作系统句柄，你必须在使用 Win32 句柄`DuplicateHandle`函数。 请注意，不应传递到 RegisterWaitForSingleObject，因为等待线程可能检测不到该事件已终止之前将重置。       再返回，该函数修改修改某些类型的同步对象的状态。 修改仅发生在其终止的状态导致等待条件得到满足的对象。 例如，信号量的计数减少&1;。      ## 版本信息与.NET Framework 2.0 版中，正在启动<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>属性值将传播到辅助线程排队使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法。</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> 在早期版本，不会传播的主体的信息。"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>注册。</xref:System.Threading.WaitHandle> 使用<xref:System.Threading.WaitHandle>以外<xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "<xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref>时调用的委托`waitObject`参数发出信号。"
    - id: state
      type: System.Object
      description: "传递给委托的对象。"
    - id: millisecondsTimeOutInterval
      type: System.Int32
      description: "以毫秒为单位的超时。 如果`millisecondsTimeOutInterval`参数为 0 （零），函数将测试对象的状态并立即返回。 如果`millisecondsTimeOutInterval`为-1，函数的超时间隔永远不过期。"
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要指示该线程将不再等待`waitObject`参数后已调用的委托;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>以指示每次等待操作完成取消注册在等待之前都重置计时器。"
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref>封装本机句柄。"
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> millisecondsTimeOutInterval </code>参数是小于-1。"
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "注册委托以等待<xref:System.Threading.WaitHandle>，以毫秒为单位指定超时 64 位有符号的整数。</xref:System.Threading.WaitHandle>"
  remarks: "完成之后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法来释放对等待句柄的引用。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> 我们建议你始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，即使你指定`true`为`executeOnlyOnce`。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> 垃圾回收的工作的详细信息有效地如果调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法而不是具体取决于已注册的等待句柄的终结器。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       RegisterWaitForSingleObject 方法指定的委托排队到线程池。 在下列情况之一发生时，工作线程将执行委托:-指定的对象处于终止状态。      -超时间隔已过期。       RegisterWaitForSingleObject 方法检查指定对象的<xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle>的当前状态 如果对象的状态为非终止状态，该方法将注册一个等待操作。 等待操作由线程池中的线程执行。 对象的状态将被发送信号或超时间隔结束时，将通过工作线程执行委托。 如果`timeOutInterval`参数不是 0 （零） 和`executeOnlyOnce`参数是`false`，每次该事件处于有信号状态或达到超时间隔重置计时器。      1> [!IMPORTANT]&1;> 使用<xref:System.Threading.Mutex>为`waitObject`不提供的回调的互相排斥，因为基础的 Win32 API 使用默认值`WT_EXECUTEDEFAULT`标志，以便在一个单独的线程池线程上调度每个回调。</xref:System.Threading.Mutex> 而不是<xref:System.Threading.Mutex>，使用<xref:System.Threading.Semaphore>与的最大计数为 1。</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       若要取消等待操作，请调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       等待线程使用 Win32`WaitForMultipleObjects`函数来监视已注册的等待操作。 因此，如果多个调用 RegisterWaitForSingleObject，必须使用相同的本机操作系统句柄，你必须在使用 Win32 句柄`DuplicateHandle`函数。 请注意，不应传递到 RegisterWaitForSingleObject，因为等待线程可能检测不到该事件已终止之前将重置。       再返回，该函数修改修改某些类型的同步对象的状态。 修改仅发生在其终止的状态导致等待条件得到满足的对象。 例如，信号量的计数减少&1;。      ## 版本信息与.NET Framework 2.0 版中，正在启动<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>属性值将传播到辅助线程排队使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法。</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> 在早期版本，不会传播的主体的信息。"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>注册。</xref:System.Threading.WaitHandle> 使用<xref:System.Threading.WaitHandle>以外<xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "<xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref>时调用的委托`waitObject`参数发出信号。"
    - id: state
      type: System.Object
      description: "将对象传递给委托。"
    - id: millisecondsTimeOutInterval
      type: System.Int64
      description: "以毫秒为单位的超时。 如果`millisecondsTimeOutInterval`参数为 0 （零），函数将测试对象的状态并立即返回。 如果`millisecondsTimeOutInterval`为-1，函数的超时间隔永远不过期。"
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要指示该线程将不再等待`waitObject`参数后已调用的委托;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>以指示每次等待操作完成取消注册在等待之前都重置计时器。"
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref>封装本机句柄。"
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> millisecondsTimeOutInterval </code>参数是小于-1。"
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "注册委托以等待<xref:System.Threading.WaitHandle>，并指定<xref:System.TimeSpan>超时值。</xref:System.TimeSpan> </xref:System.Threading.WaitHandle>"
  remarks: "完成之后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法来释放对等待句柄的引用。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> 我们建议你始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，即使你指定`true`为`executeOnlyOnce`。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> 垃圾回收的工作的详细信息有效地如果调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法而不是具体取决于已注册的等待句柄的终结器。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       RegisterWaitForSingleObject 方法指定的委托排队到线程池。 在下列情况之一发生时，工作线程将执行委托:-指定的对象处于终止状态。      -超时间隔已过期。       RegisterWaitForSingleObject 方法检查指定对象的<xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle>的当前状态 如果对象的状态为非终止状态，该方法将注册一个等待操作。 等待操作由线程池中的线程执行。 对象的状态将被发送信号或超时间隔结束时，将通过工作线程执行委托。 如果`timeOutInterval`参数不是 0 （零） 和`executeOnlyOnce`参数是`false`，每次该事件处于有信号状态或达到超时间隔重置计时器。      1> [!IMPORTANT]&1;> 使用<xref:System.Threading.Mutex>为`waitObject`不提供的回调的互相排斥，因为基础的 Win32 API 使用默认值`WT_EXECUTEDEFAULT`标志，以便在一个单独的线程池线程上调度每个回调。</xref:System.Threading.Mutex> 而不是<xref:System.Threading.Mutex>，使用<xref:System.Threading.Semaphore>与的最大计数为 1。</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       若要取消等待操作，请调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       等待线程使用 Win32`WaitForMultipleObjects`函数来监视已注册的等待操作。 因此，如果多个调用 RegisterWaitForSingleObject，必须使用相同的本机操作系统句柄，你必须在使用 Win32 句柄`DuplicateHandle`函数。 请注意，不应传递到 RegisterWaitForSingleObject，因为等待线程可能检测不到该事件已终止之前将重置。       再返回，该函数修改修改某些类型的同步对象的状态。 修改仅发生在其终止的状态导致等待条件得到满足的对象。 例如，信号量的计数减少&1;。      ## 版本信息与.NET Framework 2.0 版中，正在启动<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>属性值将传播到辅助线程排队使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法。</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> 在早期版本，不会传播的主体的信息。"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>注册。</xref:System.Threading.WaitHandle> 使用<xref:System.Threading.WaitHandle>以外<xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "<xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref>时调用的委托`waitObject`参数发出信号。"
    - id: state
      type: System.Object
      description: "将对象传递给委托。"
    - id: timeout
      type: System.TimeSpan
      description: "一种<xref:System.TimeSpan>。</xref:System.TimeSpan>所表示的超时时间 如果`timeout`为 0 （零），函数将测试对象的状态并立即返回。 如果`timeout`为-1，函数的超时间隔永远不过期。"
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要指示该线程将不再等待`waitObject`参数后已调用的委托;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>以指示每次等待操作完成取消注册在等待之前都重置计时器。"
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref>封装本机句柄。"
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> timeout </code>参数是小于-1。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code> timeout </code>参数大于&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;。"
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "注册委托以等待<xref:System.Threading.WaitHandle>，以毫秒为单位指定超时的 32 位无符号的整数。</xref:System.Threading.WaitHandle>"
  remarks: "完成之后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法来释放对等待句柄的引用。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> 我们建议你始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，即使你指定`true`为`executeOnlyOnce`。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> 垃圾回收的工作的详细信息有效地如果调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法而不是具体取决于已注册的等待句柄的终结器。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法指定的委托排队到线程池。</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 在下列情况之一发生时，工作线程将执行委托:-指定的对象处于终止状态。      -超时间隔已过期。       <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法检查指定对象的<xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle>的当前状态</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 如果对象的状态为非终止状态，该方法将注册一个等待操作。 等待操作由线程池中的线程执行。 对象的状态将被发送信号或超时间隔结束时，将通过工作线程执行委托。 如果`timeOutInterval`参数不是 0 （零） 和`executeOnlyOnce`参数是`false`，每次该事件处于有信号状态或达到超时间隔重置计时器。      1> [!IMPORTANT]&1;> 使用<xref:System.Threading.Mutex>为`waitObject`不提供的回调的互相排斥，因为基础的 Win32 API 使用默认值`WT_EXECUTEDEFAULT`标志，以便在一个单独的线程池线程上调度每个回调。</xref:System.Threading.Mutex> 而不是<xref:System.Threading.Mutex>，使用<xref:System.Threading.Semaphore>与的最大计数为 1。</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       若要取消等待操作，请调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       等待线程使用 Win32`WaitForMultipleObjects`函数来监视已注册的等待操作。 因此，如果必须使用相同的本机操作系统句柄中多次调用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，你必须使用 Win32 句柄复制`DuplicateHandle`函数。</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 请注意，不应传递到<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，因为等待线程可能检测不到该事件已终止之前将重置。</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>       再返回，该函数修改修改某些类型的同步对象的状态。 修改仅发生在其终止的状态导致等待条件得到满足的对象。 例如，信号量的计数减少&1;。      ## 版本信息与.NET Framework 2.0 版中，正在启动<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>属性值将传播到辅助线程排队使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法。</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> 在早期版本，不会传播的主体的信息。"
  example:
  - "The following example shows how to use the RegisterWaitForSingleObject method to execute a specified callback method when a specified wait handle is signaled. In this example, the callback method is `WaitProc`, and the wait handle is an <xref:System.Threading.AutoResetEvent>.  \n  \n The example defines a `TaskInfo` class to hold the information that is passed to the callback when it executes. The example creates a `TaskInfo` object and assigns it some string data. The <xref:System.Threading.RegisteredWaitHandle> that is returned by the RegisterWaitForSingleObject method is assigned to the `Handle` field of the `TaskInfo` object so that the callback method has access to the <xref:System.Threading.RegisteredWaitHandle>.  \n  \n In addition to specifying `TaskInfo` as the object to pass to the callback method, the call to the RegisterWaitForSingleObject method specifies the <xref:System.Threading.AutoResetEvent> that the task will wait for, a <xref:System.Threading.WaitOrTimerCallback> delegate that represents the `WaitProc` callback method, a one second time-out interval, and multiple callbacks.  \n  \n When the main thread signals the <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, the <xref:System.Threading.WaitOrTimerCallback> delegate is invoked. The `WaitProc` method tests <xref:System.Threading.RegisteredWaitHandle> to determine whether a time-out occurred. If the callback was invoked because the wait handle was signaled, the `WaitProc` method unregisters the <xref:System.Threading.RegisteredWaitHandle>, stopping additional callbacks. In the case of a time-out, the task continues to wait. The `WaitProc` method ends by printing a message to the console.  \n  \n [!code-cs[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/add/codesnippet/csharp/2f901dc9-3ce0-4cdc-bf06-_1.cs)]\n [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/add/codesnippet/cpp/2f901dc9-3ce0-4cdc-bf06-_1.cpp)]\n [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/add/codesnippet/visualbasic/2f901dc9-3ce0-4cdc-bf06-_1.vb)]"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>注册。</xref:System.Threading.WaitHandle> 使用<xref:System.Threading.WaitHandle>以外<xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "<xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref>时调用的委托`waitObject`参数发出信号。"
    - id: state
      type: System.Object
      description: "将对象传递给委托。"
    - id: millisecondsTimeOutInterval
      type: System.UInt32
      description: "以毫秒为单位的超时。 如果`millisecondsTimeOutInterval`参数为 0 （零），函数将测试对象的状态并立即返回。 如果`millisecondsTimeOutInterval`为-1，函数的超时间隔永远不过期。"
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要指示该线程将不再等待`waitObject`参数后已调用的委托;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>以指示每次等待操作完成取消注册在等待之前都重置计时器。"
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref>可以用于取消已注册的等待操作。"
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> millisecondsTimeOutInterval </code>参数是小于-1。"
  platform:
  - net462
- uid: System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)
  id: SetMaxThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: SetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMaxThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "设置可以同时处于活动状态的线程池的请求数。 大于此数目的所有请求将都保持排队，直到线程池线程变为可用。"
  remarks: "不能设置工作线程或 I/O 完成线程的最大数为一个数字小于的计算机上的处理器数。 若要确定存在多少处理器，检索的值<xref:System.Environment.ProcessorCount%2A?displayProperty=fullName>属性。</xref:System.Environment.ProcessorCount%2A?displayProperty=fullName> 此外，你不能设置辅助线程或为一个小于最小相应工作线程数的数字的 I/O 完成线程或 I/O 完成线程的最大数目。 若要确定最小线程池大小，请调用<xref:System.Threading.ThreadPool.GetMinThreads%2A>方法。</xref:System.Threading.ThreadPool.GetMinThreads%2A>       如果承载公共语言运行时，例如通过 Internet 信息服务 (IIS) 或 SQL Server，主机可以限制或阻止更改到线程池大小。       更改的最大线程池中的线程数时要格外小心。 虽然你的代码中获益，所做的更改可能产生负面影响上使用的代码库。       设置线程池大小太大，则会导致性能问题。 如果在同一时间执行过多的线程，任务切换开销就成为一个重要的因素。"
  syntax:
    content: public static bool SetMaxThreads (int workerThreads, int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "最大线程池中辅助线程数。"
    - id: completionPortThreads
      type: System.Int32
      description: "最大线程池中异步 I/O 线程数。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果更改成功，则否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Threading.ThreadPool.SetMaxThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)
  id: SetMinThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: SetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMinThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "进行新的请求时，在切换到管理线程创建和销毁的算法之前设置的最小线程池根据需要，创建的线程数。"
  remarks: "线程池按需提供新的辅助线程或 I/O 完成线程直到它达到每个类别的最低要求。 当达到最小值时，线程池可以在该类别中创建其他线程或等待，直到一些任务完成。 开头[!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]，线程池创建和销毁线程以优化吞吐量，吞吐量被定义为每个单位时间完成的任务数。 线程过少不可能实现可用资源的最优利用，而线程过多则可能增加资源争用。       需求较低时，线程池线程的实际数量可以低于最小值。       如果你指定为负数或大于最大活动线程池线程数的数字 (使用获取<xref:System.Threading.ThreadPool.GetMaxThreads%2A>)，SetMinThreads 返回`false`并不会更改两个最小值。</xref:System.Threading.ThreadPool.GetMaxThreads%2A>      1> [!CAUTION]&1;> 默认情况下，最小线程数设置为在系统上的处理器数。 SetMinThreads 方法可用于增加最小的数字 ofthreads。 但是，不必要地增加这些值可能导致性能问题。 如果在同一时间开始太多的任务，所有这些可能会很慢。 在大多数情况下，线程池将使用其自己的分配线程算法更好地执行。 减少到小于处理器数也会影响性能的最小值。"
  example:
  - "The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.  \n  \n [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/visualbasic/m-system.threading.threa_10_1.vb)]\n [!code-cs[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/csharp/m-system.threading.threa_10_1.cs)]\n [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/cpp/m-system.threading.threa_10_1.cpp)]"
  syntax:
    content: public static bool SetMinThreads (int workerThreads, int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "最小线程池根据需要创建的工作线程数。"
    - id: completionPortThreads
      type: System.Int32
      description: "最小线程池根据需要创建的异步 I/O 线程数。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果更改成功，则否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Threading.ThreadPool.SetMinThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  id: UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeQueueNativeOverlapped(NativeOverlapped*)
  nameWithType: ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
  fullName: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "执行的队列重叠的 I/O 操作。"
  remarks: "有关使用本机 Win32 信息重叠的 I/O，请参阅<xref:System.Threading.Overlapped>类，<xref:System.Threading.NativeOverlapped>结构，与`OVERLAPPED`Win32 平台 SDK 中的结构。</xref:System.Threading.NativeOverlapped> </xref:System.Threading.Overlapped>      1> [!CAUTION]&1;> 使用 UnsafeQueueNativeOverlapped 方法可能会无意中打开安全漏洞。 代码访问安全性将基于堆栈的所有调用方的权限其权限检查。 如果工作的线程池线程使用 UnsafeQueueNativeOverlapped 上排队，则该线程池线程的堆栈没有实际调用方的上下文。 恶意代码可能会利用这一点避开权限检查。"
  syntax:
    content: public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);
    parameters:
    - id: overlapped
      type: System.Threading.NativeOverlapped*
      description: "<xref href=&quot;System.Threading.NativeOverlapped&quot;> </xref>到队列的结构。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果该操作已成功排队到 I/O 完成端口;否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  id: UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeQueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "指定的委托排队到线程池，但不会传播到辅助线程的调用堆栈。"
  remarks: "与不同<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法，UnsafeQueueUserWorkItem 不传播到辅助线程的调用堆栈。</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> 这使得代码丢失所做的调用堆栈，从而提升其安全特权。      1> [!CAUTION]&1;> 使用 UnsafeQueueUserWorkItem 可能无意中打开安全漏洞。 代码访问安全性将基于堆栈的所有调用方的权限其权限检查。 如果工作的线程池线程使用 UnsafeQueueUserWorkItem 上排队，线程池线程的堆栈不会实际调用方的上下文。 恶意代码可能会利用这一点避开权限检查。"
  syntax:
    content: public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);
    parameters:
    - id: callBack
      type: System.Threading.WaitCallback
      description: "A <xref href=&quot;System.Threading.WaitCallback&quot;> </xref> ，表示在线程池中的线程选择工作项时要调用的委托。"
    - id: state
      type: System.Object
      description: "从线程池传递给委托服务时的对象。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果该方法成功;<xref:System.OutOfMemoryException>无法排队的工作项时引发。</xref:System.OutOfMemoryException>"
  overload: System.Threading.ThreadPool.UnsafeQueueUserWorkItem*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "遇到内存不足情况。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "无法将工作项排队。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "注册委托以等待<xref:System.Threading.WaitHandle>，使用 32 位有符号的整数来表示超时值以毫秒为单位。</xref:System.Threading.WaitHandle> 此方法不传播到辅助线程的调用堆栈。"
  remarks: "与不同<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法，UnsafeRegisterWaitForSingleObject 不传播到辅助线程的调用堆栈。</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 这使得代码丢失所做的调用堆栈，从而提升其安全特权。      1> [!CAUTION]&1;> 使用 UnsafeRegisterWaitForSingleObject 可能无意中打开安全漏洞。 代码访问安全性将基于堆栈的所有调用方的权限其权限检查。 如果工作的线程池线程使用 UnsafeRegisterWaitForSingleObject 上排队，线程池线程的堆栈不会实际调用方的上下文。 恶意代码可能会利用这一点避开权限检查。       使用<xref:System.Threading.Mutex>为`waitObject`不提供的回调的互相排斥，因为基础的 Win32 API 使用默认值`WT_EXECUTEDEFAULT`标志，以便在一个单独的线程池线程上调度每个回调。</xref:System.Threading.Mutex>       完成之后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法来释放对等待句柄的引用。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> 我们建议你始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，即使你指定`true`为`executeOnlyOnce`。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> 垃圾回收的工作的详细信息有效地如果调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法而不是具体取决于已注册的等待句柄的终结器。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>注册。</xref:System.Threading.WaitHandle> 使用<xref:System.Threading.WaitHandle>以外<xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "要时调用的委托`waitObject`参数发出信号。"
    - id: state
      type: System.Object
      description: "传递给委托的对象。"
    - id: millisecondsTimeOutInterval
      type: System.Int32
      description: "以毫秒为单位的超时。 如果`millisecondsTimeOutInterval`参数为 0 （零），函数将测试对象的状态并立即返回。 如果`millisecondsTimeOutInterval`为-1，函数的超时间隔永远不过期。"
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要指示该线程将不再等待`waitObject`参数后已调用的委托;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>以指示每次等待操作完成取消注册在等待之前都重置计时器。"
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref>可以用于取消已注册的等待操作的对象。"
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> millisecondsTimeOutInterval </code>参数是小于-1。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "注册委托以等待<xref:System.Threading.WaitHandle>，以毫秒为单位指定超时 64 位有符号的整数。</xref:System.Threading.WaitHandle> 此方法不传播到辅助线程的调用堆栈。"
  remarks: "与不同<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法，UnsafeRegisterWaitForSingleObject 不传播到辅助线程的调用堆栈。</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 这使得代码丢失所做的调用堆栈，从而提升其安全特权。      1> [!CAUTION]&1;> 使用 UnsafeRegisterWaitForSingleObject 可能无意中打开安全漏洞。 代码访问安全性将基于堆栈的所有调用方的权限其权限检查。 如果工作的线程池线程使用 UnsafeRegisterWaitForSingleObject 上排队，线程池线程的堆栈不会实际调用方的上下文。 恶意代码可能会利用这一点避开权限检查。       使用<xref:System.Threading.Mutex>为`waitObject`不提供的回调的互相排斥，因为基础的 Win32 API 使用默认值`WT_EXECUTEDEFAULT`标志，以便在一个单独的线程池线程上调度每个回调。</xref:System.Threading.Mutex>       完成之后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法来释放对等待句柄的引用。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> 我们建议你始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，即使你指定`true`为`executeOnlyOnce`。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> 垃圾回收的工作的详细信息有效地如果调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法而不是具体取决于已注册的等待句柄的终结器。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>注册。</xref:System.Threading.WaitHandle> 使用<xref:System.Threading.WaitHandle>以外<xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "要时调用的委托`waitObject`参数发出信号。"
    - id: state
      type: System.Object
      description: "传递给委托的对象。"
    - id: millisecondsTimeOutInterval
      type: System.Int64
      description: "以毫秒为单位的超时。 如果`millisecondsTimeOutInterval`参数为 0 （零），函数将测试对象的状态并立即返回。 如果`millisecondsTimeOutInterval`为-1，函数的超时间隔永远不过期。"
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要指示该线程将不再等待`waitObject`参数后已调用的委托;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>以指示每次等待操作完成取消注册在等待之前都重置计时器。"
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref>可以用于取消已注册的等待操作的对象。"
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> millisecondsTimeOutInterval </code>参数是小于-1。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "注册委托以等待<xref:System.Threading.WaitHandle>，并指定<xref:System.TimeSpan>超时值。</xref:System.TimeSpan> </xref:System.Threading.WaitHandle> 此方法不传播到辅助线程的调用堆栈。"
  remarks: "与不同<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法，UnsafeRegisterWaitForSingleObject 不传播到辅助线程的调用堆栈。</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 这使得代码丢失所做的调用堆栈，从而提升其安全特权。      1> [!CAUTION]&1;> 使用 UnsafeRegisterWaitForSingleObject 可能无意中打开安全漏洞。 代码访问安全性将基于堆栈的所有调用方的权限其权限检查。 如果工作的线程池线程使用 UnsafeRegisterWaitForSingleObject 上排队，线程池线程的堆栈不会实际调用方的上下文。 恶意代码可能会利用这一点避开权限检查。       使用<xref:System.Threading.Mutex>为`waitObject`不提供的回调的互相排斥，因为基础的 Win32 API 使用默认值`WT_EXECUTEDEFAULT`标志，以便在一个单独的线程池线程上调度每个回调。</xref:System.Threading.Mutex>       完成之后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法来释放对等待句柄的引用。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> 我们建议你始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，即使你指定`true`为`executeOnlyOnce`。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> 垃圾回收的工作的详细信息有效地如果调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法而不是具体取决于已注册的等待句柄的终结器。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>注册。</xref:System.Threading.WaitHandle> 使用<xref:System.Threading.WaitHandle>以外<xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "要时调用的委托`waitObject`参数发出信号。"
    - id: state
      type: System.Object
      description: "传递给委托的对象。"
    - id: timeout
      type: System.TimeSpan
      description: "一种<xref:System.TimeSpan>。</xref:System.TimeSpan>所表示的超时时间 如果`timeout`为 0 （零），函数将测试对象的状态并立即返回。 如果`timeout`为-1，函数的超时间隔永远不过期。"
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要指示该线程将不再等待`waitObject`参数后已调用的委托;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>以指示每次等待操作完成取消注册在等待之前都重置计时器。"
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref>可以用于取消已注册的等待操作的对象。"
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> timeout </code>参数是小于-1。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code> timeout </code>参数大于&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "注册委托以等待<xref:System.Threading.WaitHandle>，以毫秒为单位指定超时的 32 位无符号的整数。</xref:System.Threading.WaitHandle> 此方法不传播到辅助线程的调用堆栈。"
  remarks: "与不同<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法，UnsafeRegisterWaitForSingleObject 不传播到辅助线程的调用堆栈。</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 这使得代码丢失所做的调用堆栈，从而提升其安全特权。      1> [!CAUTION]&1;> 使用 UnsafeRegisterWaitForSingleObject 可能无意中打开安全漏洞。 代码访问安全性将基于堆栈的所有调用方的权限其权限检查。 如果工作的线程池线程使用 UnsafeRegisterWaitForSingleObject 上排队，线程池线程的堆栈不会实际调用方的上下文。 恶意代码可能会利用这一点避开权限检查。       使用<xref:System.Threading.Mutex>为`waitObject`不提供的回调的互相排斥，因为基础的 Win32 API 使用默认值`WT_EXECUTEDEFAULT`标志，以便在一个单独的线程池线程上调度每个回调。</xref:System.Threading.Mutex>       完成之后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法来释放对等待句柄的引用。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> 我们建议你始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，即使你指定`true`为`executeOnlyOnce`。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> 垃圾回收的工作的详细信息有效地如果调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法而不是具体取决于已注册的等待句柄的终结器。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>注册。</xref:System.Threading.WaitHandle> 使用<xref:System.Threading.WaitHandle>以外<xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "要时调用的委托`waitObject`参数发出信号。"
    - id: state
      type: System.Object
      description: "传递给委托的对象。"
    - id: millisecondsTimeOutInterval
      type: System.UInt32
      description: "以毫秒为单位的超时。 如果`millisecondsTimeOutInterval`参数为 0 （零），函数将测试对象的状态并立即返回。 如果`millisecondsTimeOutInterval`为-1，函数的超时间隔永远不过期。"
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要指示该线程将不再等待`waitObject`参数后已调用的委托;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>以指示每次等待操作完成取消注册在等待之前都重置计时器。"
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref>可以用于取消已注册的等待操作的对象。"
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ApplicationException
  parent: System
  isExternal: false
  name: ApplicationException
  nameWithType: ApplicationException
  fullName: System.ApplicationException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.Threading.ThreadPool.BindHandle(System.IntPtr)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: BindHandle(IntPtr)
  nameWithType: ThreadPool.BindHandle(IntPtr)
  fullName: System.Threading.ThreadPool.BindHandle(IntPtr)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: BindHandle(SafeHandle)
  nameWithType: ThreadPool.BindHandle(SafeHandle)
  fullName: System.Threading.ThreadPool.BindHandle(SafeHandle)
- uid: System.Runtime.InteropServices.SafeHandle
  parent: System.Runtime.InteropServices
  isExternal: true
  name: SafeHandle
  nameWithType: SafeHandle
  fullName: System.Runtime.InteropServices.SafeHandle
- uid: System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetAvailableThreads(Int32,Int32)
  nameWithType: ThreadPool.GetAvailableThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetAvailableThreads(Int32,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMaxThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMinThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: QueueUserWorkItem(WaitCallback)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback)
- uid: System.Threading.WaitCallback
  parent: System.Threading
  isExternal: false
  name: WaitCallback
  nameWithType: WaitCallback
  fullName: System.Threading.WaitCallback
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: QueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback,Object)
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
- uid: System.Threading.RegisteredWaitHandle
  parent: System.Threading
  isExternal: false
  name: RegisteredWaitHandle
  nameWithType: RegisteredWaitHandle
  fullName: System.Threading.RegisteredWaitHandle
- uid: System.Threading.WaitHandle
  parent: System.Threading
  isExternal: true
  name: WaitHandle
  nameWithType: WaitHandle
  fullName: System.Threading.WaitHandle
- uid: System.Threading.WaitOrTimerCallback
  parent: System.Threading
  isExternal: false
  name: WaitOrTimerCallback
  nameWithType: WaitOrTimerCallback
  fullName: System.Threading.WaitOrTimerCallback
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
- uid: System.UInt32
  parent: System
  isExternal: true
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMaxThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMinThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueNativeOverlapped(NativeOverlapped*)
  nameWithType: ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
  fullName: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
- uid: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
- uid: System.Threading.ThreadPool.BindHandle*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: BindHandle
  nameWithType: ThreadPool.BindHandle
- uid: System.Threading.ThreadPool.GetAvailableThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetAvailableThreads
  nameWithType: ThreadPool.GetAvailableThreads
- uid: System.Threading.ThreadPool.GetMaxThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMaxThreads
  nameWithType: ThreadPool.GetMaxThreads
- uid: System.Threading.ThreadPool.GetMinThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMinThreads
  nameWithType: ThreadPool.GetMinThreads
- uid: System.Threading.ThreadPool.QueueUserWorkItem*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: QueueUserWorkItem
  nameWithType: ThreadPool.QueueUserWorkItem
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject
  nameWithType: ThreadPool.RegisterWaitForSingleObject
- uid: System.Threading.ThreadPool.SetMaxThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMaxThreads
  nameWithType: ThreadPool.SetMaxThreads
- uid: System.Threading.ThreadPool.SetMinThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMinThreads
  nameWithType: ThreadPool.SetMinThreads
- uid: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueNativeOverlapped
  nameWithType: ThreadPool.UnsafeQueueNativeOverlapped
- uid: System.Threading.ThreadPool.UnsafeQueueUserWorkItem*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueUserWorkItem
  nameWithType: ThreadPool.UnsafeQueueUserWorkItem
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject
