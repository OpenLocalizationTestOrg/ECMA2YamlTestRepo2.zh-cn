### YamlMime:ManagedReference
items:
- uid: System.IO.Directory
  id: Directory
  children:
  - System.IO.Directory.CreateDirectory(System.String)
  - System.IO.Directory.CreateDirectory(System.String,System.Security.AccessControl.DirectorySecurity)
  - System.IO.Directory.Delete(System.String)
  - System.IO.Directory.Delete(System.String,System.Boolean)
  - System.IO.Directory.EnumerateDirectories(System.String)
  - System.IO.Directory.EnumerateDirectories(System.String,System.String)
  - System.IO.Directory.EnumerateDirectories(System.String,System.String,System.IO.SearchOption)
  - System.IO.Directory.EnumerateFiles(System.String)
  - System.IO.Directory.EnumerateFiles(System.String,System.String)
  - System.IO.Directory.EnumerateFiles(System.String,System.String,System.IO.SearchOption)
  - System.IO.Directory.EnumerateFileSystemEntries(System.String)
  - System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String)
  - System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String,System.IO.SearchOption)
  - System.IO.Directory.Exists(System.String)
  - System.IO.Directory.GetAccessControl(System.String)
  - System.IO.Directory.GetAccessControl(System.String,System.Security.AccessControl.AccessControlSections)
  - System.IO.Directory.GetCreationTime(System.String)
  - System.IO.Directory.GetCreationTimeUtc(System.String)
  - System.IO.Directory.GetCurrentDirectory
  - System.IO.Directory.GetDirectories(System.String)
  - System.IO.Directory.GetDirectories(System.String,System.String)
  - System.IO.Directory.GetDirectories(System.String,System.String,System.IO.SearchOption)
  - System.IO.Directory.GetDirectoryRoot(System.String)
  - System.IO.Directory.GetFiles(System.String)
  - System.IO.Directory.GetFiles(System.String,System.String)
  - System.IO.Directory.GetFiles(System.String,System.String,System.IO.SearchOption)
  - System.IO.Directory.GetFileSystemEntries(System.String)
  - System.IO.Directory.GetFileSystemEntries(System.String,System.String)
  - System.IO.Directory.GetFileSystemEntries(System.String,System.String,System.IO.SearchOption)
  - System.IO.Directory.GetLastAccessTime(System.String)
  - System.IO.Directory.GetLastAccessTimeUtc(System.String)
  - System.IO.Directory.GetLastWriteTime(System.String)
  - System.IO.Directory.GetLastWriteTimeUtc(System.String)
  - System.IO.Directory.GetLogicalDrives
  - System.IO.Directory.GetParent(System.String)
  - System.IO.Directory.Move(System.String,System.String)
  - System.IO.Directory.SetAccessControl(System.String,System.Security.AccessControl.DirectorySecurity)
  - System.IO.Directory.SetCreationTime(System.String,System.DateTime)
  - System.IO.Directory.SetCreationTimeUtc(System.String,System.DateTime)
  - System.IO.Directory.SetCurrentDirectory(System.String)
  - System.IO.Directory.SetLastAccessTime(System.String,System.DateTime)
  - System.IO.Directory.SetLastAccessTimeUtc(System.String,System.DateTime)
  - System.IO.Directory.SetLastWriteTime(System.String,System.DateTime)
  - System.IO.Directory.SetLastWriteTimeUtc(System.String,System.DateTime)
  langs:
  - csharp
  name: Directory
  nameWithType: Directory
  fullName: System.IO.Directory
  type: Class
  summary: "公开用于创建、 移动和枚举目录和子目录的静态方法。 此类不能被继承。       若要浏览此类型的.NET Framework 源代码，请参阅[引用源](http://referencesource.microsoft.com/#mscorlib/system/io/directory.cs#b3ad5f0ba800bb28)。"
  remarks: "> [!NOTE]\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/io/directory.cs#b3ad5f0ba800bb28). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \n  \n Use the Directory class for typical operations such as copying, moving, renaming, creating, and deleting directories.  \n  \n-   To create a directory, use one of the <xref:System.IO.Directory.CreateDirectory%2A> methods.  \n  \n-   To delete a directory, use one of the <xref:System.IO.Directory.Delete%2A> methods.  \n  \n-   To get or set the current directory for an app, use the <xref:System.IO.Directory.GetCurrentDirectory%2A> or <xref:System.IO.Directory.SetCurrentDirectory%2A> method.  \n  \n-   To manipulate <xref:System.DateTime> information related to the creation, access, and writing of a directory, use methods such as <xref:System.IO.Directory.SetLastAccessTime%2A> and <xref:System.IO.Directory.SetCreationTime%2A>.  \n  \n The static methods of the Directory class perform security checks on all methods. If you are going to reuse an object several times, consider using the corresponding instance method of <xref:System.IO.DirectoryInfo> instead, because the security check will not always be necessary.  \n  \n If you are performing only one directory-related action, it might be more efficient to use a static Directory method rather than a corresponding <xref:System.IO.DirectoryInfo> instance method. Most Directory methods require the path to the directory that you are manipulating.  \n  \n> [!NOTE]\n>  In members that accept a string `path` parameter, that path must be well-formed or an exception is raised. For example, if a path is fully qualified but begins with a space (\" c:\\temp\"), the path string isn't trimmed, so the path is considered malformed and an exception is raised. In addition, a path or a combination of paths cannot be fully qualified twice. For example, \"c:\\temp c:\\windows\" also raises an exception. Ensure that your paths are well-formed when using methods that accept a path string. For more information see <xref:System.IO.Path>.  \n  \n In members that accept a path, the path can refer to a file or a directory. You can use a full path, a relative path, or a Universal Naming Convention (UNC) path for a server and share name. For example, all the following are acceptable paths:  \n  \n-   \"c:\\\\\\MyDir\" in C#, or \"c:\\MyDir\" in Visual Basic.  \n  \n-   \"MyDir\\\\\\MySubdir\" in C#, or \"MyDir\\MySubDir\" in Visual Basic.  \n  \n-   \"\\\\\\\\\\\\\\MyServer\\\\\\MyShare\" in C#, or \"\\\\\\MyServer\\MyShare\" in Visual Basic.  \n  \n By default, full read/write access to new directories is granted to all users. However, the app must have the correct security to access existing directories.  \n  \n To demand permissions for a directory and all its subdirectories, end the path string with the directory separator character. (For example, \"C:\\Temp\\\\\" grants access to C:\\Temp\\ and all its subdirectories.) To demand permissions only for a specific directory, end the path string with a period. (For example, \"C:\\Temp\\\\.\" grants access only to C:\\Temp\\\\, not to its subdirectories.)  \n  \n In members that accept a `searchPattern` parameter, the search string can be any combination of literal characters and two wildcard characters; * and ?. This parameter does not recognize regular expressions. For more information, see the <xref:System.IO.Directory.EnumerateDirectories%28System.String%2CSystem.String%29> method or any other method that uses the `searchPattern` parameter.  \n  \n For a list of common I/O tasks, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md).  \n  \n Directory and <xref:System.IO.DirectoryInfo> are not supported for use in [!INCLUDE[win8_appstore_long](~/add/includes/win8-appstore-long-md.md)] apps. For information about how to access files and folders in [!INCLUDE[win8_appstore_long](~/add/includes/win8-appstore-long-md.md)] apps, see [Accessing data and files (Windows Store apps)](http://msdn.microsoft.com/library/windows/apps/hh758319.aspx)."
  example:
  - "The following example shows how to retrieve all the text files from a directory and move them to a new directory. After the files are moved, they no longer exist in the original directory.  \n  \n [!code-cs[System.IO.Directory#10](~/add/codesnippet/csharp/t-system.io.directory_1.cs)]\n [!code-vb[System.IO.Directory#10](~/add/codesnippet/visualbasic/t-system.io.directory_1.vb)]  \n  \n The following example demonstrates how to use the <xref:System.IO.Directory.EnumerateFiles%2A> method to retrieve a collection of text files from a directory, and then use that collection in a query to find all the lines that contain \"Example\".  \n  \n [!code-cs[System.IO.Directory#11](~/add/codesnippet/csharp/t-system.io.directory_2.cs)]\n [!code-vb[System.IO.Directory#11](~/add/codesnippet/visualbasic/t-system.io.directory_2.vb)]  \n  \n The following example demonstrates how to move a directory and all its files to a new directory. The original directory no longer exists after it has been moved.  \n  \n [!code-vb[System.IO.Directory#14](~/add/codesnippet/visualbasic/t-system.io.directory_3.vb)]\n [!code-cs[System.IO.Directory#14](~/add/codesnippet/csharp/t-system.io.directory_3.cs)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public static class Directory
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.Directory.CreateDirectory(System.String)
  id: CreateDirectory(System.String)
  parent: System.IO.Directory
  langs:
  - csharp
  name: CreateDirectory(String)
  nameWithType: Directory.CreateDirectory(String)
  fullName: System.IO.Directory.CreateDirectory(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "除非它们已经存在创建在指定路径中的所有目录和子目录。"
  remarks: "Any and all directories specified in `path` are created, unless they already exist or unless some part of `path` is invalid. If the directory already exists, this method does not create a new directory, but it returns a <xref:System.IO.DirectoryInfo> object for the existing directory.  \n  \n The `path` parameter specifies a directory path, not a file path.  \n  \n Trailing spaces are removed from the end of the `path` parameter before creating the directory.  \n  \n You can create a directory on a remote computer, on a share that you have write access to. UNC paths are supported; for example, you can specify the following for `path`: `\\\\2009\\Archives\\December` in Visual Basic, and `\\\\\\\\2009\\\\Archives\\\\December` in C#.  \n  \n Creating a directory with only the colon character (:) is not supported, and will cause a `NotSupportedException` to be thrown."
  example:
  - "The following example creates and deletes the specified directory.  \n  \n [!code-cs[Dir_CreateDir#1](~/add/codesnippet/csharp/m-system.io.directory.cr_1.cs)]\n [!code-vb[Dir_CreateDir#1](~/add/codesnippet/visualbasic/m-system.io.directory.cr_1.vb)]\n [!code-cpp[Dir_CreateDir#1](~/add/codesnippet/cpp/m-system.io.directory.cr_1.cpp)]  \n  \n To create the directory C:\\Users\\User1\\Public\\Html when the current directory is C:\\Users\\User1, use any of the following calls to ensure that the backslash is interpreted properly.  \n  \n In Visual Basic:  \n  \n```  \nDirectory.CreateDirectory(\"Public\\Html\")   \n    Directory.CreateDirectory(\"\\Users\\User1\\Public\\Html\")   \n    Directory.CreateDirectory(\"c:\\Users\\User1\\Public\\Html\")  \n```  \n  \n In C#:  \n  \n```  \nDirectory.CreateDirectory(\"Public\\\\Html\");  \n    Directory.CreateDirectory(\"\\\\Users\\\\User1\\\\Public\\\\Html\");  \n    Directory.CreateDirectory(\"c:\\\\Users\\\\User1\\\\Public\\\\Html\");  \n```  \n  \n In C++:  \n  \n```  \nDirectory::CreateDirectory(\"Public\\\\Html\");  \n    Directory::CreateDirectory(\"\\\\Users\\\\User1\\\\Public\\\\Html\");  \n    Directory::CreateDirectory(\"c:\\\\Users\\\\User1\\\\Public\\\\Html\");  \n```"
  syntax:
    content: public static System.IO.DirectoryInfo CreateDirectory (string path);
    parameters:
    - id: path
      type: System.String
      description: "要创建的目录。"
    return:
      type: System.IO.DirectoryInfo
      description: "一个对象，表示在指定路径的目录。 无论是否在指定路径的目录已存在，都将返回此对象。"
  overload: System.IO.Directory.CreateDirectory*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "指定的目录<code> path </code>是文件。       -或者-网络名称未知。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>是零长度字符串，仅包含空格，或包含一个或多个无效字符。 你可以通过使用查询无效字符<xref:System.IO.Path.GetInvalidPathChars*>方法。       -或-<code>path</code>带有前缀，或包含仅的冒号字符 （:）。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路径无效 （例如，它位于未映射的驱动器上）。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>包含不是驱动器标签的一部分的冒号字符 （:） (&quot;c:\\&quot;)。"
  platform:
  - net462
- uid: System.IO.Directory.CreateDirectory(System.String,System.Security.AccessControl.DirectorySecurity)
  id: CreateDirectory(System.String,System.Security.AccessControl.DirectorySecurity)
  parent: System.IO.Directory
  langs:
  - csharp
  name: CreateDirectory(String,DirectorySecurity)
  nameWithType: Directory.CreateDirectory(String,DirectorySecurity)
  fullName: System.IO.Directory.CreateDirectory(String,DirectorySecurity)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "在指定的路径中，创建所有目录，除非已存在，并应用指定的 Windows 安全性。"
  remarks: "Use this method overload to create a directory with access control, so there is no chance the directory can be accessed before security is applied.  \n  \n Any and all directories specified in the `path` parameter are created, unless they already exist or unless some part of `path` is invalid. The `path` parameter specifies a directory path, not a file path. If the directory already exists, this method does not create a new directory, but it returns a <xref:System.IO.DirectoryInfo> object for the existing directory.  \n  \n Trailing spaces are removed from the end of the `path` parameter before creating the directory.  \n  \n You can create a directory on a remote computer, on a share that you have write access to. UNC paths are supported; for example, you can specify the following for `path`: `\\\\2009\\Archives\\December` in Visual Basic, and `\\\\\\\\2009\\\\Archives\\\\December` in C#.  \n  \n Creating a directory with only the colon character (:) is not supported and causes a `NotSupportedException` to be thrown."
  example:
  - "The following example creates a new directory with access rules for two user accounts.  \n  \n [!code-cs[System.IO.Directory#15](~/add/codesnippet/csharp/52b6d5ea-0f1d-4395-a346-_1.cs)]\n [!code-vb[System.IO.Directory#15](~/add/codesnippet/visualbasic/52b6d5ea-0f1d-4395-a346-_1.vb)]"
  syntax:
    content: public static System.IO.DirectoryInfo CreateDirectory (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);
    parameters:
    - id: path
      type: System.String
      description: "要创建的目录。"
    - id: directorySecurity
      type: System.Security.AccessControl.DirectorySecurity
      description: "要应用于此目录的访问控制。"
    return:
      type: System.IO.DirectoryInfo
      description: "一个对象，表示在指定路径的目录。 无论是否在指定路径的目录已存在，都将返回此对象。"
  overload: System.IO.Directory.CreateDirectory*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "指定的目录<code> path </code>是文件。       -或者-网络名称未知。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>是零长度字符串，仅包含空格，或包含一个或多个无效字符。 你可以通过使用查询无效字符<xref:System.IO.Path.GetInvalidPathChars*>方法。       -或-<code>path</code>带有前缀，或包含仅的冒号字符 （:）。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路径无效 （例如，它位于未映射的驱动器上）。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>包含不是驱动器标签的一部分的冒号字符 （:） (&quot;c:\\&quot;)。"
  platform:
  - net462
- uid: System.IO.Directory.Delete(System.String)
  id: Delete(System.String)
  parent: System.IO.Directory
  langs:
  - csharp
  name: Delete(String)
  nameWithType: Directory.Delete(String)
  fullName: System.IO.Directory.Delete(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "从指定路径删除空目录。"
  remarks: "此方法的行为相同与<xref:System.IO.Directory.Delete%28System.String%2CSystem.Boolean%29>与`false`为第二个参数指定。</xref:System.IO.Directory.Delete%28System.String%2CSystem.Boolean%29>       `path`参数可以指定相对或绝对路径信息。 相对路径信息被解释为相对于当前工作目录。 若要获取当前工作目录，请参阅<xref:System.IO.Directory.GetCurrentDirectory%2A>。</xref:System.IO.Directory.GetCurrentDirectory%2A>       从的末尾删除尾随空格`path`之前删除目录的参数。       此方法将引发<xref:System.IO.IOException>如果中指定的目录`path`参数包含文件或子目录。</xref:System.IO.IOException>       `path`参数不区分大小写。       在某些情况下，如果必须在文件资源管理器中打开的指定的目录 Delete 方法可能不能将其删除。"
  example:
  - "The following example shows how to create a new directory and subdirectory, and then delete only the subdirectory.  \n  \n [!code-vb[System.IO.Directory.Delete#1](~/add/codesnippet/visualbasic/m-system.io.directory.de_0_1.vb)]\n [!code-cs[System.IO.Directory.Delete#1](~/add/codesnippet/csharp/m-system.io.directory.de_0_1.cs)]"
  syntax:
    content: public static void Delete (string path);
    parameters:
    - id: path
      type: System.String
      description: "要移除的空目录的名称。 此目录必须可写且为空。"
  overload: System.IO.Directory.Delete*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "具有相同名称和指定的位置的文件<code> path </code>存在。       -或者-目录是应用程序的当前工作目录。       -指定的目录<code> path </code>不为空。       -或者-该目录是只读的或包含一个只读文件。       -或者-目录正由另一个进程。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>是零长度字符串，仅包含空格，或包含一个或多个无效字符。 你可以通过使用查询无效字符<xref:System.IO.Path.GetInvalidPathChars*>方法。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "<code>path</code>不存在或找不到。       -或-指定的路径无效 （例如，它位于未映射的驱动器上）。"
  platform:
  - net462
- uid: System.IO.Directory.Delete(System.String,System.Boolean)
  id: Delete(System.String,System.Boolean)
  parent: System.IO.Directory
  langs:
  - csharp
  name: Delete(String,Boolean)
  nameWithType: Directory.Delete(String,Boolean)
  fullName: System.IO.Directory.Delete(String,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "删除指定的目录，如果已指明，所有子目录和文件的目录中。"
  remarks: "`path`参数可以指定相对或绝对路径信息。 相对路径信息被解释为相对于当前工作目录。 若要获取当前工作目录，请参阅<xref:System.IO.Directory.GetCurrentDirectory%2A>。</xref:System.IO.Directory.GetCurrentDirectory%2A>       从的末尾删除尾随空格`path`之前删除目录的参数。       `path`参数不区分大小写。       如果`recursive`参数是`true`，用户必须具有对当前目录及其所有子目录的写入权限。       删除包含重新分析点，如符号链接或装入点的目录时，此方法的行为略有不同。 如果重新分析点是一个目录，如装入点，它将卸载和删除该装入点。 此方法不通过重新分析点进行递归。 如果重新分析点文件的符号链接，则删除重新分析点和不符号链接的目标。       在某些情况下，如果必须在文件资源管理器中打开的指定的目录 Delete 方法可能不能将其删除。"
  example:
  - "The following example shows how to create a new directory, subdirectory, and file in the subdirectory, and then recursively delete all the new items.  \n  \n [!code-cs[System.IO.Directory.Delete#2](~/add/codesnippet/csharp/m-system.io.directory.de_1_1.cs)]\n [!code-vb[System.IO.Directory.Delete#2](~/add/codesnippet/visualbasic/m-system.io.directory.de_1_1.vb)]"
  syntax:
    content: public static void Delete (string path, bool recursive);
    parameters:
    - id: path
      type: System.String
      description: "要删除的目录的名称。"
    - id: recursive
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要删除目录、 子目录和文件中的`path`; 否则为<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.Directory.Delete*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "具有相同名称和指定的位置的文件<code> path </code>存在。       -指定的目录<code> path </code>是只读的或<code> recursive </code>是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>和<code> path </code>不是空的目录。       -或者-目录是应用程序的当前工作目录。       -或者-该目录包含只读文件。       -或者-目录正由另一个进程。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>是零长度字符串，仅包含空格，或包含一个或多个无效字符。 你可以通过使用查询无效字符<xref:System.IO.Path.GetInvalidPathChars*>方法。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "<code>path</code>不存在或找不到。       -或-指定的路径无效 （例如，它位于未映射的驱动器上）。"
  platform:
  - net462
- uid: System.IO.Directory.EnumerateDirectories(System.String)
  id: EnumerateDirectories(System.String)
  parent: System.IO.Directory
  langs:
  - csharp
  name: EnumerateDirectories(String)
  nameWithType: Directory.EnumerateDirectories(String)
  fullName: System.IO.Directory.EnumerateDirectories(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "返回指定路径中的目录名的可枚举集合。"
  remarks: "你可以指定中的相对或绝对路径信息`path`参数。 相对路径的信息解释为相对于当前工作目录，你可以通过使用来确定<xref:System.IO.Directory.GetCurrentDirectory%2A>方法。</xref:System.IO.Directory.GetCurrentDirectory%2A> 返回的目录名称的前缀中提供的值为`path`参数。 例如，如果你提供的相对路径`path`参数，返回的目录名称将包含相对路径。       <xref:System.IO.Directory.EnumerateDirectories%2A>和<xref:System.IO.Directory.GetDirectories%2A>方法的行为有所不同，如下所示︰ 当你使用<xref:System.IO.Directory.EnumerateDirectories%2A>，你可以启动之前，则返回整个集合枚举名称的集合; 当你使用<xref:System.IO.Directory.GetDirectories%2A>，你必须等待的名称之前才能访问该数组返回整个数组。</xref:System.IO.Directory.GetDirectories%2A> </xref:System.IO.Directory.EnumerateDirectories%2A> </xref:System.IO.Directory.GetDirectories%2A> </xref:System.IO.Directory.EnumerateDirectories%2A> 因此，当你正在使用许多文件和目录，<xref:System.IO.Directory.EnumerateDirectories%2A>可能更有效。</xref:System.IO.Directory.EnumerateDirectories%2A>       不缓存返回的集合;每次调用<xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>在集合上将启动一个新的枚举。</xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>"
  example:
  - "The following example enumerates the top-level directories in a specified path.  \n  \n [!code-vb[System.IO.EnumDirs1#1](~/add/codesnippet/visualbasic/m-system.io.directory.en_2_1.vb)]\n [!code-cs[System.IO.EnumDirs1#1](~/add/codesnippet/csharp/m-system.io.directory.en_2_1.cs)]"
  syntax:
    content: public static System.Collections.Generic.IEnumerable<string> EnumerateDirectories (string path);
    parameters:
    - id: path
      type: System.String
      description: "要搜索的目录相对或绝对路径。 此字符串不区分大小写。"
    return:
      type: System.Collections.Generic.IEnumerable{System.String}
      description: "目录中指定的目录的文件的完整名称 （包括路径） 的可枚举集合<code> path </code>。"
  overload: System.IO.Directory.EnumerateDirectories*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path </code>是零长度字符串，仅包含空格，或包含无效字符。 你可以通过使用查询无效字符<xref:System.IO.Path.GetInvalidPathChars*>方法。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "<code>path</code>无效，如引用未映射的驱动器。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>path</code>是一个文件名。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径，或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  platform:
  - net462
- uid: System.IO.Directory.EnumerateDirectories(System.String,System.String)
  id: EnumerateDirectories(System.String,System.String)
  parent: System.IO.Directory
  langs:
  - csharp
  name: EnumerateDirectories(String,String)
  nameWithType: Directory.EnumerateDirectories(String,String)
  fullName: System.IO.Directory.EnumerateDirectories(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "返回与指定路径中的搜索模式匹配的目录名的可枚举集合。"
  remarks: "`searchPattern` can be a combination of literal and wildcard characters, but doesn't support regular expressions. The following wildcard specifiers are permitted in `searchPattern`.  \n  \n|Wildcard specifier|Matches|  \n|------------------------|-------------|  \n|* (asterisk)|Zero or more characters in that position.|  \n|? (question mark)|Zero or one character in that position.|  \n  \n Characters other than the wildcard are literal characters. For example, the `searchPattern` string \"*t\" searches for all names in `path` ending with the letter \"t\". The `searchPattern` string \"s\\*\" searches for all names in `path` beginning with the letter \"s\".  \n  \n `searchPattern` cannot end in two periods (\"..\") or contain two periods (\"..\") followed by <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>, nor can it contain any invalid characters. You can query for invalid characters by using the <xref:System.IO.Path.GetInvalidPathChars%2A> method.  \n  \n You can specify relative or absolute path information in the `path` parameter. Relative path information is interpreted as relative to the current working directory, which you can determine by using the <xref:System.IO.Directory.GetCurrentDirectory%2A> method. The returned directory names are prefixed with the value you provided in the `path` parameter. For example, if you provide a relative path in the `path` parameter, the returned directory names will contain a relative path.  \n  \n The <xref:System.IO.Directory.EnumerateDirectories%2A> and <xref:System.IO.Directory.GetDirectories%2A> methods differ as follows: When you use <xref:System.IO.Directory.EnumerateDirectories%2A>, you can start enumerating the collection of names before the whole collection is returned; when you use <xref:System.IO.Directory.GetDirectories%2A>, you must wait for the whole array of names to be returned before you can access the array. Therefore, when you are working with many files and directories, <xref:System.IO.Directory.EnumerateDirectories%2A> can be more efficient.  \n  \n The returned collection is not cached; each call to the <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> on the collection will start a new enumeration."
  example:
  - "The following example enumerates the top-level directories in a specified path that match a specified search pattern.  \n  \n [!code-cs[System.IO.EnumDirs2#1](~/add/codesnippet/csharp/m-system.io.directory.en_0_1.cs)]\n [!code-vb[System.IO.EnumDirs2#1](~/add/codesnippet/visualbasic/m-system.io.directory.en_0_1.vb)]"
  syntax:
    content: public static System.Collections.Generic.IEnumerable<string> EnumerateDirectories (string path, string searchPattern);
    parameters:
    - id: path
      type: System.String
      description: "要搜索的目录相对或绝对路径。 此字符串不区分大小写。"
    - id: searchPattern
      type: System.String
      description: "要与中的目录名称匹配的搜索字符串`path`。  此参数可以包含有效文本路径和通配符的组合 (* 和？) 字符 （请参阅备注），但不支持正则表达式。"
    return:
      type: System.Collections.Generic.IEnumerable{System.String}
      description: "目录中指定的目录的文件的完整名称 （包括路径） 的可枚举集合<code> path </code>且与指定的搜索模式匹配。"
  overload: System.IO.Directory.EnumerateDirectories*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path </code>is a zero-length string, contains only white space, or contains invalid characters. You can query for invalid characters with the  <xref:System.IO.Path.GetInvalidPathChars*> method.  \n  \n \\- or -  \n  \n <code>searchPattern</code> does not contain a valid pattern."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>searchPattern</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "<code>path</code>无效，如引用未映射的驱动器。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>path</code>是一个文件名。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径，或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  platform:
  - net462
- uid: System.IO.Directory.EnumerateDirectories(System.String,System.String,System.IO.SearchOption)
  id: EnumerateDirectories(System.String,System.String,System.IO.SearchOption)
  parent: System.IO.Directory
  langs:
  - csharp
  name: EnumerateDirectories(String,String,SearchOption)
  nameWithType: Directory.EnumerateDirectories(String,String,SearchOption)
  fullName: System.IO.Directory.EnumerateDirectories(String,String,SearchOption)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "返回与指定路径中的搜索模式匹配的目录名的可枚举集合，并还可以搜索子目录。"
  remarks: "`searchPattern` can be a combination of literal and wildcard characters, but doesn't support regular expressions. The following wildcard specifiers are permitted in `searchPattern`.  \n  \n|Wildcard specifier|Matches|  \n|------------------------|-------------|  \n|* (asterisk)|Zero or more characters in that position.|  \n|? (question mark)|Exactly one character in that position.|  \n  \n Characters other than the wildcard are literal characters. For example, the `searchPattern` string \"*t\" searches for all names in `path` ending with the letter \"t\". The `searchPattern` string \"s\\*\" searches for all names in `path` beginning with the letter \"s\".  \n  \n `searchPattern` cannot end in two periods (\"..\") or contain two periods (\"..\") followed by <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>, nor can it contain any invalid characters. You can query for invalid characters by using the <xref:System.IO.Path.GetInvalidPathChars%2A> method.  \n  \n You can specify relative or absolute path information in the `path` parameter. Relative path information is interpreted as relative to the current working directory, which you can determine by using the <xref:System.IO.Directory.GetCurrentDirectory%2A> method. The returned directory names are prefixed with the value you provided in the `path` parameter. For example, if you provide a relative path in the `path` parameter, the returned directory names will contain a relative path.  \n  \n The <xref:System.IO.Directory.EnumerateDirectories%2A> and <xref:System.IO.Directory.GetDirectories%2A> methods differ as follows: When you use <xref:System.IO.Directory.EnumerateDirectories%2A>, you can start enumerating the collection of names before the whole collection is returned; when you use <xref:System.IO.Directory.GetDirectories%2A>, you must wait for the whole array of names to be returned before you can access the array. Therefore, when you are working with many files and directories, <xref:System.IO.Directory.EnumerateDirectories%2A> can be more efficient.  \n  \n The returned collection is not cached; each call to the <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> on the collection will start a new enumeration."
  example:
  - "The following example enumerates directories in a specified path that match a specified search pattern. It uses the `searchOption` parameter to specify that all subdirectories should be included in the search.  \n  \n [!code-cs[System.IO.EnumDirs3#1](~/add/codesnippet/csharp/d54eb053-19f8-45e5-b70d-_1.cs)]\n [!code-vb[System.IO.EnumDirs3#1](~/add/codesnippet/visualbasic/d54eb053-19f8-45e5-b70d-_1.vb)]"
  syntax:
    content: public static System.Collections.Generic.IEnumerable<string> EnumerateDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);
    parameters:
    - id: path
      type: System.String
      description: "要搜索的目录相对或绝对路径。 此字符串不区分大小写。"
    - id: searchPattern
      type: System.String
      description: "要与中的目录名称匹配的搜索字符串`path`。  此参数可以包含有效文本路径和通配符的组合 (* 和？) 字符 （请参阅备注），但不支持正则表达式。"
    - id: searchOption
      type: System.IO.SearchOption
      description: "指定搜索操作是应仅包含当前目录还是应包含所有子目录的枚举值之一。       默认值是<xref href=&quot;System.IO.SearchOption&quot;> </xref>。"
    return:
      type: System.Collections.Generic.IEnumerable{System.String}
      description: "目录中指定的目录的文件的完整名称 （包括路径） 的可枚举集合<code> path </code>与指定的搜索模式和选项匹配。"
  overload: System.IO.Directory.EnumerateDirectories*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path </code>is a zero-length string, contains only white space, or contains invalid characters. You can query for invalid characters by using the  <xref:System.IO.Path.GetInvalidPathChars*> method.  \n  \n \\- or -  \n  \n <code>searchPattern</code> does not contain a valid pattern."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>searchPattern</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>searchOption</code>不是有效<xref href=&quot;System.IO.SearchOption&quot;></xref>值。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "<code>path</code>无效，如引用未映射的驱动器。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>path</code>是一个文件名。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径，或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  platform:
  - net462
- uid: System.IO.Directory.EnumerateFiles(System.String)
  id: EnumerateFiles(System.String)
  parent: System.IO.Directory
  langs:
  - csharp
  name: EnumerateFiles(String)
  nameWithType: Directory.EnumerateFiles(String)
  fullName: System.IO.Directory.EnumerateFiles(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "返回指定路径中的文件名称的可枚举集合。"
  remarks: "你可以指定使用的相对路径信息`path`参数。 相对路径的信息解释为相对于当前工作目录，你可以通过使用来确定<xref:System.IO.Directory.GetCurrentDirectory%2A>方法。</xref:System.IO.Directory.GetCurrentDirectory%2A>       <xref:System.IO.Directory.EnumerateFiles%2A>和<xref:System.IO.Directory.GetFiles%2A>方法的行为有所不同，如下所示︰ 当你使用<xref:System.IO.Directory.EnumerateFiles%2A>，你可以启动之前，则返回整个集合枚举名称的集合; 当你使用<xref:System.IO.Directory.GetFiles%2A>，你必须等待的名称之前才能访问该数组返回整个数组。</xref:System.IO.Directory.GetFiles%2A> </xref:System.IO.Directory.EnumerateFiles%2A> </xref:System.IO.Directory.GetFiles%2A> </xref:System.IO.Directory.EnumerateFiles%2A> 因此，当你正在使用许多文件和目录，<xref:System.IO.Directory.EnumerateFiles%2A>可能更有效。</xref:System.IO.Directory.EnumerateFiles%2A>       不缓存返回的集合;每次调用<xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>在集合上将启动一个新的枚举。</xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>"
  example:
  - "The following example shows how to retrieve all the files in a directory and move them to a new directory. After the files are moved, they no longer exist in the original directory.  \n  \n [!code-cs[System.IO.Directory#12](~/add/codesnippet/csharp/m-system.io.directory.en_3_1.cs)]\n [!code-vb[System.IO.Directory#12](~/add/codesnippet/visualbasic/m-system.io.directory.en_3_1.vb)]  \n  \n The following example enumerates the files in the specified directory, reads each line of the file, and displays the line if it contains the string \"Europe\".  \n  \n [!code-cs[System.IO.Directory.EnumFiles#1](~/add/codesnippet/csharp/m-system.io.directory.en_3_2.cs)]\n [!code-vb[System.IO.Directory.EnumFiles#1](~/add/codesnippet/visualbasic/m-system.io.directory.en_3_2.vb)]"
  syntax:
    content: public static System.Collections.Generic.IEnumerable<string> EnumerateFiles (string path);
    parameters:
    - id: path
      type: System.String
      description: "要搜索的目录相对或绝对路径。 此字符串不区分大小写。"
    return:
      type: System.Collections.Generic.IEnumerable{System.String}
      description: "指定的目录中的文件的完整名称 （包括路径） 的可枚举集合<code> path </code>。"
  overload: System.IO.Directory.EnumerateFiles*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path </code>是零长度字符串，仅包含空格，或包含无效字符。 你可以通过使用查询无效字符<xref:System.IO.Path.GetInvalidPathChars*>方法。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "<code>path</code>无效，如引用未映射的驱动器。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>path</code>是一个文件名。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径，或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  platform:
  - net462
- uid: System.IO.Directory.EnumerateFiles(System.String,System.String)
  id: EnumerateFiles(System.String,System.String)
  parent: System.IO.Directory
  langs:
  - csharp
  name: EnumerateFiles(String,String)
  nameWithType: Directory.EnumerateFiles(String,String)
  fullName: System.IO.Directory.EnumerateFiles(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "返回与指定路径中的搜索模式匹配的文件名的可枚举集合。"
  remarks: "`searchPattern` can be a combination of literal and wildcard characters, but doesn't support regular expressions. The following wildcard specifiers are permitted in `searchPattern`.  \n  \n|Wildcard specifier|Matches|  \n|------------------------|-------------|  \n|* (asterisk)|Zero or more characters in that position.|  \n|? (question mark)|Zero or one character in that position.|  \n  \n Characters other than the wildcard are literal characters. For example, the `searchPattern` string \"*t\" searches for all names in `path` ending with the letter \"t\". The `searchPattern` string \"s\\*\" searches for all names in `path` beginning with the letter \"s\".  \n  \n> [!NOTE]\n>  When you use the asterisk wildcard character in a `searchPattern` such as \"*.txt\", the number of characters in the specified extension affects the search as follows:  \n>   \n>  -   If the specified extension is exactly three characters long, the method returns files with extensions that begin with the specified extension. For example, \"*.xls\" returns both \"book.xls\" and \"book.xlsx\".  \n> -   In all other cases, the method returns files that exactly match the specified extension. For example, \"*.ai\" returns \"file.ai\" but not \"file.aif\".  \n>   \n>  When you use the question mark wildcard character, this method returns only files that match the specified file extension. For example, given two files, \"file1.txt\" and \"file1.txtother\", in a directory, a search pattern of \"file?.txt\" returns just the first file, whereas a search pattern of \"file*.txt\" returns both files.  \n  \n `searchPattern` cannot end in two periods (\"..\") or contain two periods (\"..\") followed by <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>, nor can it contain any invalid characters. You can query for invalid characters by using the <xref:System.IO.Path.GetInvalidPathChars%2A> method.  \n  \n You can specify relative path information with the `path` parameter. Relative path information is interpreted as relative to the current working directory, which you can determine by using the <xref:System.IO.Directory.GetCurrentDirectory%2A> method.  \n  \n The <xref:System.IO.Directory.EnumerateFiles%2A> and <xref:System.IO.Directory.GetFiles%2A> methods differ as follows: When you use <xref:System.IO.Directory.EnumerateFiles%2A>, you can start enumerating the collection of names before the whole collection is returned; when you use <xref:System.IO.Directory.GetFiles%2A>, you must wait for the whole array of names to be returned before you can access the array. Therefore, when you are working with many files and directories, <xref:System.IO.Directory.EnumerateFiles%2A> can be more efficient.  \n  \n The returned collection is not cached; each call to the <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> on the collection will start a new enumeration."
  example:
  - "The following example shows how to retrieve all the text files in a directory and move them to a new directory. After the files are moved, they no longer exist in the original directory.  \n  \n [!code-cs[System.IO.Directory#10](~/add/codesnippet/csharp/m-system.io.directory.en_1_1.cs)]\n [!code-vb[System.IO.Directory#10](~/add/codesnippet/visualbasic/m-system.io.directory.en_1_1.vb)]  \n  \n The following example enumerates the files in the specified directory that have a .txt extension, reads each line of the file, and displays the line if it contains the string \"Europe\".  \n  \n [!code-cs[System.IO.Directory.EnumFiles2#1](~/add/codesnippet/csharp/m-system.io.directory.en_1_2.cs)]\n [!code-vb[System.IO.Directory.EnumFiles2#1](~/add/codesnippet/visualbasic/m-system.io.directory.en_1_2.vb)]"
  syntax:
    content: public static System.Collections.Generic.IEnumerable<string> EnumerateFiles (string path, string searchPattern);
    parameters:
    - id: path
      type: System.String
      description: "要搜索的目录相对或绝对路径。 此字符串不区分大小写。"
    - id: searchPattern
      type: System.String
      description: "要与中的文件的名称匹配的搜索字符串`path`。  此参数可以包含有效文本路径和通配符的组合 (* 和？) 字符 （请参阅备注），但不支持正则表达式。"
    return:
      type: System.Collections.Generic.IEnumerable{System.String}
      description: "指定的目录中的文件的完整名称 （包括路径） 的可枚举集合<code> path </code>且与指定的搜索模式匹配。"
  overload: System.IO.Directory.EnumerateFiles*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path </code>is a zero-length string, contains only white space, or contains invalid characters. You can query for invalid characters by using the <xref:System.IO.Path.GetInvalidPathChars*> method.  \n  \n \\- or -  \n  \n <code>searchPattern</code> does not contain a valid pattern."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>searchPattern</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "<code>path</code>无效，如引用未映射的驱动器。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>path</code>是一个文件名。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径，或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  platform:
  - net462
- uid: System.IO.Directory.EnumerateFiles(System.String,System.String,System.IO.SearchOption)
  id: EnumerateFiles(System.String,System.String,System.IO.SearchOption)
  parent: System.IO.Directory
  langs:
  - csharp
  name: EnumerateFiles(String,String,SearchOption)
  nameWithType: Directory.EnumerateFiles(String,String,SearchOption)
  fullName: System.IO.Directory.EnumerateFiles(String,String,SearchOption)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "返回与指定路径中的搜索模式匹配的文件名的可枚举集合，并还可以搜索子目录。"
  remarks: "`searchPattern` can be a combination of literal and wildcard characters, but doesn't support regular expressions. The following wildcard specifiers are permitted in `searchPattern`.  \n  \n|Wildcard specifier|Matches|  \n|------------------------|-------------|  \n|* (asterisk)|Zero or more characters in that position.|  \n|? (question mark)|Zero or one character in that position.|  \n  \n Characters other than the wildcard are literal characters. For example, the `searchPattern` string \"*t\" searches for all names in `path` ending with the letter \"t\". The `searchPattern` string \"s\\*\" searches for all names in `path` beginning with the letter \"s\".  \n  \n> [!NOTE]\n>  When you use the asterisk wildcard character in a `searchPattern` such as \"*.txt\", the number of characters in the specified extension affects the search as follows:  \n>   \n>  -   If the specified extension is exactly three characters long, the method returns files with extensions that begin with the specified extension. For example, \"*.xls\" returns both \"book.xls\" and \"book.xlsx\".  \n> -   In all other cases, the method returns files that exactly match the specified extension. For example, \"*.ai\" returns \"file.ai\" but not \"file.aif\".  \n>   \n>  When you use the question mark wildcard character, this method returns only files that match the specified file extension. For example, given two files, \"file1.txt\" and \"file1.txtother\", in a directory, a search pattern of \"file?.txt\" returns just the first file, whereas a search pattern of \"file*.txt\" returns both files.  \n  \n `searchPattern` cannot end in two periods (\"..\") or contain two periods (\"..\") followed by <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>, nor can it contain any invalid characters. You can query for invalid characters by using the <xref:System.IO.Path.GetInvalidPathChars%2A> method.  \n  \n You can specify relative path information with the `path` parameter. Relative path information is interpreted as relative to the current working directory, which you can determine by using the <xref:System.IO.Directory.GetCurrentDirectory%2A> method.  \n  \n The <xref:System.IO.Directory.EnumerateFiles%2A> and <xref:System.IO.Directory.GetFiles%2A> methods differ as follows: When you use <xref:System.IO.Directory.EnumerateFiles%2A>, you can start enumerating the collection of names before the whole collection is returned; when you use <xref:System.IO.Directory.GetFiles%2A>, you must wait for the whole array of names to be returned before you can access the array. Therefore, when you are working with many files and directories, <xref:System.IO.Directory.EnumerateFiles%2A> can be more efficient.  \n  \n The returned collection is not cached; each call to the <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> on the collection will start a new enumeration."
  example:
  - "The following example shows how to retrieve all the text files in a directory and its subdirectories, and move them to a new directory. After the files are moved, they no longer exist in the original directories.  \n  \n [!code-cs[System.IO.Directory#13](~/add/codesnippet/csharp/5542867a-6e9d-46bd-b2ed-_1.cs)]\n [!code-vb[System.IO.Directory#13](~/add/codesnippet/visualbasic/5542867a-6e9d-46bd-b2ed-_1.vb)]  \n  \n The following example recursively enumerates all files that have a .txt extension, reads each line of the file, and displays the line if it contains the string \"Microsoft\".  \n  \n [!code-cs[System.IO.Directory.EnumerateFiles#1](~/add/codesnippet/csharp/5542867a-6e9d-46bd-b2ed-_2.cs)]\n [!code-vb[System.IO.Directory.EnumerateFiles#1](~/add/codesnippet/visualbasic/5542867a-6e9d-46bd-b2ed-_2.vb)]"
  syntax:
    content: public static System.Collections.Generic.IEnumerable<string> EnumerateFiles (string path, string searchPattern, System.IO.SearchOption searchOption);
    parameters:
    - id: path
      type: System.String
      description: "要搜索的目录相对或绝对路径。 此字符串不区分大小写。"
    - id: searchPattern
      type: System.String
      description: "要与中的文件的名称匹配的搜索字符串`path`。  此参数可以包含有效文本路径和通配符的组合 (* 和？) 字符 （请参阅备注），但不支持正则表达式。"
    - id: searchOption
      type: System.IO.SearchOption
      description: "指定搜索操作是应仅包含当前目录还是应包含所有子目录的枚举值之一。       默认值是<xref href=&quot;System.IO.SearchOption&quot;> </xref>。"
    return:
      type: System.Collections.Generic.IEnumerable{System.String}
      description: "指定的目录中的文件的完整名称 （包括路径） 的可枚举集合<code> path </code>与指定的搜索模式和选项匹配。"
  overload: System.IO.Directory.EnumerateFiles*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path </code>is a zero-length string, contains only white space, or contains invalid characters. You can query for invalid characters by using the <xref:System.IO.Path.GetInvalidPathChars*> method.  \n  \n \\- or -  \n  \n <code>searchPattern</code> does not contain a valid pattern."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>searchPattern</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>searchOption</code>不是有效<xref href=&quot;System.IO.SearchOption&quot;></xref>值。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "<code>path</code>无效，如引用未映射的驱动器。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>path</code>是一个文件名。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径，或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  platform:
  - net462
- uid: System.IO.Directory.EnumerateFileSystemEntries(System.String)
  id: EnumerateFileSystemEntries(System.String)
  parent: System.IO.Directory
  langs:
  - csharp
  name: EnumerateFileSystemEntries(String)
  nameWithType: Directory.EnumerateFileSystemEntries(String)
  fullName: System.IO.Directory.EnumerateFileSystemEntries(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "返回指定路径中的文件名和目录名的可枚举集合。"
  remarks: "你可以指定使用的相对路径信息`path`参数。 相对路径的信息解释为相对于当前工作目录，你可以通过使用来确定<xref:System.IO.Directory.GetCurrentDirectory%2A>方法。</xref:System.IO.Directory.GetCurrentDirectory%2A>       <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>和<xref:System.IO.Directory.GetFileSystemEntries%2A>方法的行为有所不同，如下所示︰ 当你使用<xref:System.IO.Directory.EnumerateFileSystemEntries%2A>，你可以启动之前，则返回整个集合枚举的项的集合; 当你使用<xref:System.IO.Directory.GetFileSystemEntries%2A>，你必须等待的项，然后才能访问该数组返回整个数组。</xref:System.IO.Directory.GetFileSystemEntries%2A> </xref:System.IO.Directory.EnumerateFileSystemEntries%2A> </xref:System.IO.Directory.GetFileSystemEntries%2A> </xref:System.IO.Directory.EnumerateFileSystemEntries%2A> 因此，当你正在使用许多文件和目录，<xref:System.IO.Directory.EnumerateFiles%2A>可能更有效。</xref:System.IO.Directory.EnumerateFiles%2A>       不缓存返回的集合;每次调用<xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>在集合上将启动一个新的枚举。</xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>"
  syntax:
    content: public static System.Collections.Generic.IEnumerable<string> EnumerateFileSystemEntries (string path);
    parameters:
    - id: path
      type: System.String
      description: "要搜索的目录相对或绝对路径。 此字符串不区分大小写。"
    return:
      type: System.Collections.Generic.IEnumerable{System.String}
      description: "指定的目录中的文件系统条目的可枚举集合<code> path </code>。"
  overload: System.IO.Directory.EnumerateFileSystemEntries*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path </code>是零长度字符串，仅包含空格，或包含无效字符。 你可以通过使用查询无效字符<xref:System.IO.Path.GetInvalidPathChars*>方法。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "<code>path</code>无效，如引用未映射的驱动器。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>path</code>是一个文件名。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径，或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  platform:
  - net462
- uid: System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String)
  id: EnumerateFileSystemEntries(System.String,System.String)
  parent: System.IO.Directory
  langs:
  - csharp
  name: EnumerateFileSystemEntries(String,String)
  nameWithType: Directory.EnumerateFileSystemEntries(String,String)
  fullName: System.IO.Directory.EnumerateFileSystemEntries(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "返回文件名和与指定路径中的搜索模式匹配的目录名的可枚举的集合。"
  remarks: "`searchPattern` can be a combination of literal and wildcard characters, but doesn't support regular expressions. The following wildcard specifiers are permitted in `searchPattern`..  \n  \n|Wildcard specifier|Matches|  \n|------------------------|-------------|  \n|* (asterisk)|Zero or more characters in that position.|  \n|? (question mark)|Zero or one character in that position.|  \n  \n Characters other than the wildcard are literal characters. For example, the `searchPattern` string \"*t\" searches for all names in `path` ending with the letter \"t\". The `searchPattern` string \"s\\*\" searches for all names in `path` beginning with the letter \"s\".  \n  \n> [!NOTE]\n>  When you use the asterisk wildcard character in a `searchPattern` such as \"*.txt\", the number of characters in the specified extension affects the search as follows:  \n>   \n>  -   If the specified extension is exactly three characters long, the method returns files with extensions that begin with the specified extension. For example, \"*.xls\" returns both \"book.xls\" and \"book.xlsx\".  \n> -   In all other cases, the method returns files that exactly match the specified extension. For example, \"*.ai\" returns \"file.ai\" but not \"file.aif\".  \n>   \n>  When you use the question mark wildcard character, this method returns only files that match the specified file extension. For example, given two files, \"file1.txt\" and \"file1.txtother\", in a directory, a search pattern of \"file?.txt\" returns just the first file, whereas a search pattern of \"file*.txt\" returns both files.  \n  \n `searchPattern` cannot end in two periods (\"..\") or contain two periods (\"..\") followed by <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>, nor can it contain any invalid characters. You can query for invalid characters by using the <xref:System.IO.Path.GetInvalidPathChars%2A> method.  \n  \n You can specify relative path information with the `path` parameter. Relative path information is interpreted as relative to the current working directory, which you can determine by using the <xref:System.IO.Directory.GetCurrentDirectory%2A> method.  \n  \n The <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> and <xref:System.IO.Directory.GetFileSystemEntries%2A> methods differ as follows: When you use <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, you can start enumerating the collection of entries before the whole collection is returned; when you use <xref:System.IO.Directory.GetFileSystemEntries%2A>, you must wait for the whole array of entries to be returned before you can access the array. Therefore, when you are working with many files and directories, <xref:System.IO.Directory.EnumerateFiles%2A> can be more efficient.  \n  \n The returned collection is not cached; each call to the <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> on the collection will start a new enumeration."
  syntax:
    content: public static System.Collections.Generic.IEnumerable<string> EnumerateFileSystemEntries (string path, string searchPattern);
    parameters:
    - id: path
      type: System.String
      description: "要搜索的目录相对或绝对路径。 此字符串不区分大小写。"
    - id: searchPattern
      type: System.String
      description: "要与中的文件系统条目的名称匹配的搜索字符串`path`。  此参数可以包含有效文本路径和通配符的组合 (* 和？) 字符 （请参阅备注），但不支持正则表达式。"
    return:
      type: System.Collections.Generic.IEnumerable{System.String}
      description: "指定的目录中的文件系统条目的可枚举集合<code> path </code>且与指定的搜索模式匹配。"
  overload: System.IO.Directory.EnumerateFileSystemEntries*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path </code>is a zero-length string, contains only white space, or contains invalid characters. You can query for invalid characters by using the <xref:System.IO.Path.GetInvalidPathChars*> method.  \n  \n \\- or -  \n  \n <code>searchPattern</code> does not contain a valid pattern."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>searchPattern</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "<code>path</code>无效，如引用未映射的驱动器。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>path</code>是一个文件名。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径，或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  platform:
  - net462
- uid: System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String,System.IO.SearchOption)
  id: EnumerateFileSystemEntries(System.String,System.String,System.IO.SearchOption)
  parent: System.IO.Directory
  langs:
  - csharp
  name: EnumerateFileSystemEntries(String,String,SearchOption)
  nameWithType: Directory.EnumerateFileSystemEntries(String,String,SearchOption)
  fullName: System.IO.Directory.EnumerateFileSystemEntries(String,String,SearchOption)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "返回的文件名和与指定路径中的搜索模式匹配的目录名的可枚举集合，并还可以搜索子目录。"
  remarks: "`searchPattern` can be a combination of literal and wildcard characters, but doesn't support regular expressions. The following wildcard specifiers are permitted in `searchPattern`.  \n  \n|Wildcard specifier|Matches|  \n|------------------------|-------------|  \n|* (asterisk)|Zero or more characters in that position.|  \n|? (question mark)|Zero or one character in that position.|  \n  \n Characters other than the wildcard are literal characters. For example, the `searchPattern` string \"*t\" searches for all names in `path` ending with the letter \"t\". The `searchPattern` string \"s\\*\" searches for all names in `path` beginning with the letter \"s\".  \n  \n> [!NOTE]\n>  When you use the asterisk wildcard character in a `searchPattern` such as \"*.txt\", the number of characters in the specified extension affects the search as follows:  \n>   \n>  -   If the specified extension is exactly three characters long, the method returns files with extensions that begin with the specified extension. For example, \"*.xls\" returns both \"book.xls\" and \"book.xlsx\".  \n> -   In all other cases, the method returns files that exactly match the specified extension. For example, \"*.ai\" returns \"file.ai\" but not \"file.aif\".  \n>   \n>  When you use the question mark wildcard character, this method returns only files that match the specified file extension. For example, given two files, \"file1.txt\" and \"file1.txtother\", in a directory, a search pattern of \"file?.txt\" returns just the first file, whereas a search pattern of \"file*.txt\" returns both files.  \n  \n `searchPattern` cannot end in two periods (\"..\") or contain two periods (\"..\") followed by <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>, nor can it contain any invalid characters. You can query for invalid characters by using the <xref:System.IO.Path.GetInvalidPathChars%2A> method.  \n  \n You can specify relative path information with the `path` parameter. Relative path information is interpreted as relative to the current working directory, which you can determine by using the <xref:System.IO.Directory.GetCurrentDirectory%2A> method.  \n  \n The <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> and <xref:System.IO.Directory.GetFileSystemEntries%2A> methods differ as follows: When you use <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, you can start enumerating the collection of entries before the whole collection is returned; when you use <xref:System.IO.Directory.GetFileSystemEntries%2A>, you must wait for the whole array of entries to be returned before you can access the array. Therefore, when you are working with many files and directories, <xref:System.IO.Directory.EnumerateFiles%2A> can be more efficient.  \n  \n The returned collection is not cached; each call to the <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> on the collection will start a new enumeration."
  syntax:
    content: public static System.Collections.Generic.IEnumerable<string> EnumerateFileSystemEntries (string path, string searchPattern, System.IO.SearchOption searchOption);
    parameters:
    - id: path
      type: System.String
      description: "要搜索的目录相对或绝对路径。 此字符串不区分大小写。"
    - id: searchPattern
      type: System.String
      description: "要与中的文件系统项匹配的搜索字符串`path`。  此参数可以包含有效文本路径和通配符的组合 (* 和？) 字符 （请参阅备注），但不支持正则表达式。"
    - id: searchOption
      type: System.IO.SearchOption
      description: "指定搜索操作是应仅包含当前目录还是应包含所有子目录的枚举值之一。       默认值是<xref href=&quot;System.IO.SearchOption&quot;> </xref>。"
    return:
      type: System.Collections.Generic.IEnumerable{System.String}
      description: "指定的目录中的文件系统条目的可枚举集合<code> path </code>与指定的搜索模式和选项匹配。"
  overload: System.IO.Directory.EnumerateFileSystemEntries*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path </code>is a zero-length string, contains only white space, or contains invalid characters. You can query for invalid characters by using the <xref:System.IO.Path.GetInvalidPathChars*> method.  \n  \n \\- or -  \n  \n <code>searchPattern</code> does not contain a valid pattern."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>searchPattern</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>searchOption</code>不是有效<xref href=&quot;System.IO.SearchOption&quot;></xref>值。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "<code>path</code>无效，如引用未映射的驱动器。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>path</code>是一个文件名。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径，或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  platform:
  - net462
- uid: System.IO.Directory.Exists(System.String)
  id: Exists(System.String)
  parent: System.IO.Directory
  langs:
  - csharp
  name: Exists(String)
  nameWithType: Directory.Exists(String)
  fullName: System.IO.Directory.Exists(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "确定给定的路径是否引用磁盘上现有的目录。"
  remarks: "`path`参数允许指定相对或绝对路径信息。 相对路径信息被解释为相对于当前工作目录。       从的末尾删除尾随空格`path`再进行检查目录是否存在的参数。       `path`参数不区分大小写。       如果你没有在目录最小的只读权限，则 Exists 方法将返回`false`。       Exists 方法返回`false`如果在尝试确定指定的文件是否存在任何错误时发生。 在引发异常，例如传递具有无效的字符或太多字符，磁盘失效或缺失的文件名的情况下可能发生这或如果调用方没有权限读取此文件。"
  example:
  - "The following example takes an array of file or directory names on the command line, determines what kind of name it is, and processes it appropriately.  \n  \n [!code-cpp[Recursive file finder#2](~/add/codesnippet/cpp/m-system.io.directory.ex_1.cpp)]\n [!code-cs[Recursive file finder#2](~/add/codesnippet/csharp/m-system.io.directory.ex_1.cs)]\n [!code-vb[Recursive file finder#2](~/add/codesnippet/visualbasic/m-system.io.directory.ex_1.vb)]"
  syntax:
    content: public static bool Exists (string path);
    parameters:
    - id: path
      type: System.String
      description: "要测试的路径。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<code> path </code>引用的现有目录;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>如果目录不存在，或尝试确定指定的目录是否存在时出错。"
  overload: System.IO.Directory.Exists*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Directory.GetAccessControl(System.String)
  id: GetAccessControl(System.String)
  parent: System.IO.Directory
  langs:
  - csharp
  name: GetAccessControl(String)
  nameWithType: Directory.GetAccessControl(String)
  fullName: System.IO.Directory.GetAccessControl(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "获取<xref href=&quot;System.Security.AccessControl.DirectorySecurity&quot;></xref>对象，它封装指定目录的访问控制列表 (ACL) 项。"
  remarks: "GetAccessControl 方法用于检索目录的访问控制列表 (ACL) 项。       ACL 描述个人和/或组具有或没有执行到给定的文件或目录上的特定操作的权限。 有关详细信息，请参阅[如何︰ 添加或移除访问控制列表项](~/add/includes/ajax-current-ext-md.md)。       在 NTFS 环境中，<xref:System.Security.AccessControl.FileSystemRights>和<xref:System.Security.AccessControl.FileSystemRights>如果用户具有向用户授予<xref:System.Security.AccessControl.FileSystemRights>上的父文件夹的权限。</xref:System.Security.AccessControl.FileSystemRights> </xref:System.Security.AccessControl.FileSystemRights> </xref:System.Security.AccessControl.FileSystemRights> 若要拒绝<xref:System.Security.AccessControl.FileSystemRights>和<xref:System.Security.AccessControl.FileSystemRights>，拒绝<xref:System.Security.AccessControl.FileSystemRights>上的父目录。</xref:System.Security.AccessControl.FileSystemRights> </xref:System.Security.AccessControl.FileSystemRights> </xref:System.Security.AccessControl.FileSystemRights>"
  example:
  - "The following example uses the GetAccessControl and the <xref:System.IO.Directory.SetAccessControl%2A> methods to add an access control list (ACL) entry and then remove an ACL entry from a directory.  You must supply a valid user or group account to run this example.  \n  \n [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/add/codesnippet/cpp/m-system.io.directory.ge_7_1.cpp)]\n [!code-cs[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/add/codesnippet/csharp/m-system.io.directory.ge_7_1.cs)]\n [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/add/codesnippet/visualbasic/m-system.io.directory.ge_7_1.vb)]"
  syntax:
    content: public static System.Security.AccessControl.DirectorySecurity GetAccessControl (string path);
    parameters:
    - id: path
      type: System.String
      description: "目录包含的路径<xref href=&quot;System.Security.AccessControl.DirectorySecurity&quot;></xref>描述文件的访问控制列表 (ACL) 信息的对象。"
    return:
      type: System.Security.AccessControl.DirectorySecurity
      description: "一个对象，封装的访问控制规则所描述的文件<code> path </code>参数。"
  overload: System.IO.Directory.GetAccessControl*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "打开目录时发生 I/O 错误。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "当前操作系统不是 Windows 2000 或更高版本。"
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "将出现系统级别错误，如找不到目录。 特定异常可能是的一个子类<xref href=&quot;System.SystemException&quot;> </xref>。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> path </code>参数指定的目录中是只读的。       -或者-当前平台上不支持此操作。       -或者-调用方没有所要求的权限。"
  platform:
  - net462
- uid: System.IO.Directory.GetAccessControl(System.String,System.Security.AccessControl.AccessControlSections)
  id: GetAccessControl(System.String,System.Security.AccessControl.AccessControlSections)
  parent: System.IO.Directory
  langs:
  - csharp
  name: GetAccessControl(String,AccessControlSections)
  nameWithType: Directory.GetAccessControl(String,AccessControlSections)
  fullName: System.IO.Directory.GetAccessControl(String,AccessControlSections)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "获取<xref href=&quot;System.Security.AccessControl.DirectorySecurity&quot;></xref>封装指定目录的访问控制列表 (ACL) 项的指定的类型的对象。"
  remarks: "GetAccessControl 方法用于检索目录的访问控制列表 (ACL) 项。       ACL 描述个人和/或组具有或没有执行到给定的文件或目录上的特定操作的权限。 有关详细信息，请参阅[如何︰ 添加或移除访问控制列表项](~/add/includes/ajax-current-ext-md.md)。       在 NTFS 环境中，<xref:System.Security.AccessControl.FileSystemRights>和<xref:System.Security.AccessControl.FileSystemRights>如果用户具有向用户授予<xref:System.Security.AccessControl.FileSystemRights>上的父文件夹的权限。</xref:System.Security.AccessControl.FileSystemRights> </xref:System.Security.AccessControl.FileSystemRights> </xref:System.Security.AccessControl.FileSystemRights> 若要拒绝<xref:System.Security.AccessControl.FileSystemRights>和<xref:System.Security.AccessControl.FileSystemRights>，拒绝<xref:System.Security.AccessControl.FileSystemRights>上的父目录。</xref:System.Security.AccessControl.FileSystemRights> </xref:System.Security.AccessControl.FileSystemRights> </xref:System.Security.AccessControl.FileSystemRights>"
  syntax:
    content: public static System.Security.AccessControl.DirectorySecurity GetAccessControl (string path, System.Security.AccessControl.AccessControlSections includeSections);
    parameters:
    - id: path
      type: System.String
      description: "目录包含的路径<xref href=&quot;System.Security.AccessControl.DirectorySecurity&quot;></xref>描述文件的访问控制列表 (ACL) 信息的对象。"
    - id: includeSections
      type: System.Security.AccessControl.AccessControlSections
      description: "之一<xref href=&quot;System.Security.AccessControl.AccessControlSections&quot;></xref>值，指定的类型的访问控制列表 (ACL) 信息来接收。"
    return:
      type: System.Security.AccessControl.DirectorySecurity
      description: "一个对象，封装的访问控制规则所描述的文件<code> path </code>参数。"
  overload: System.IO.Directory.GetAccessControl*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "打开目录时发生 I/O 错误。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "当前操作系统不是 Windows 2000 或更高版本。"
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "将出现系统级别错误，如找不到目录。 特定异常可能是的一个子类<xref href=&quot;System.SystemException&quot;> </xref>。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> path </code>参数指定的目录中是只读的。       -或者-当前平台上不支持此操作。       -或者-调用方没有所要求的权限。"
  platform:
  - net462
- uid: System.IO.Directory.GetCreationTime(System.String)
  id: GetCreationTime(System.String)
  parent: System.IO.Directory
  langs:
  - csharp
  name: GetCreationTime(String)
  nameWithType: Directory.GetCreationTime(String)
  fullName: System.IO.Directory.GetCreationTime(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "获取的创建日期和时间的目录。"
  remarks: "> [!NOTE]1> 此方法可能返回不准确的值，因为它使用其值可能不会持续更新由操作系统的本机函数。       此方法相当于<xref:System.IO.File.GetCreationTime%2A?displayProperty=fullName>.</xref:System.IO.File.GetCreationTime%2A?displayProperty=fullName>       如果目录中所述`path`参数不存在，此方法将返回第午夜 12:00 到公元 1601 年 1 月 1 日 (C.E.)为本地时间调整协调世界时 (UTC)。       `path`参数允许指定相对或绝对路径信息。 相对路径信息被解释为相对于当前工作目录。 若要获取当前工作目录，请参阅<xref:System.IO.Directory.GetCurrentDirectory%2A>。</xref:System.IO.Directory.GetCurrentDirectory%2A>       `path`参数不区分大小写。       通用 I/O 任务的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example gets the creation time of the specified directory.  \n  \n [!code-cpp[Dir_GetCreation#1](~/add/codesnippet/cpp/m-system.io.directory.ge_1_1.cpp)]\n [!code-cs[Dir_GetCreation#1](~/add/codesnippet/csharp/m-system.io.directory.ge_1_1.cs)]\n [!code-vb[Dir_GetCreation#1](~/add/codesnippet/visualbasic/m-system.io.directory.ge_1_1.vb)]"
  syntax:
    content: public static DateTime GetCreationTime (string path);
    parameters:
    - id: path
      type: System.String
      description: "目录的路径。"
    return:
      type: System.DateTime
      description: "设置为的创建日期和时间的指定目录结构。 该值用本地时间表示。"
  overload: System.IO.Directory.GetCreationTime*
  exceptions:
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>是零长度字符串，仅包含空格，或包含一个或多个无效字符。 你可以通过使用查询无效字符<xref:System.IO.Path.GetInvalidPathChars*>方法。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  platform:
  - net462
- uid: System.IO.Directory.GetCreationTimeUtc(System.String)
  id: GetCreationTimeUtc(System.String)
  parent: System.IO.Directory
  langs:
  - csharp
  name: GetCreationTimeUtc(String)
  nameWithType: Directory.GetCreationTimeUtc(String)
  fullName: System.IO.Directory.GetCreationTimeUtc(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "获取的创建日期和时间，采用协调世界时 (UTC) 格式，一个目录。"
  remarks: "> [!NOTE]1> 此方法可能返回不准确的值，因为它使用其值可能不会持续更新由操作系统的本机函数。       如果目录中所述`path`参数不存在，此方法将返回第午夜 12:00 到公元 1601 年 1 月 1 日 (C.E.)协调世界时 (UTC)。       此方法用于获取基于协调世界时 (UTC) 的目录的创建时间。"
  example:
  - "The following example illustrates the differences in output when using Coordinated Universal Time (UTC) output.  \n  \n [!code-cs[System.IO.UTCExample#1](~/add/codesnippet/csharp/m-system.io.directory.ge_11_1.cs)]\n [!code-cpp[System.IO.UTCExample#1](~/add/codesnippet/cpp/m-system.io.directory.ge_11_1.cpp)]\n [!code-vb[System.IO.UTCExample#1](~/add/codesnippet/visualbasic/m-system.io.directory.ge_11_1.vb)]"
  syntax:
    content: public static DateTime GetCreationTimeUtc (string path);
    parameters:
    - id: path
      type: System.String
      description: "目录的路径。"
    return:
      type: System.DateTime
      description: "设置为的创建日期和时间的指定目录结构。 该值用 UTC 时间表示。"
  overload: System.IO.Directory.GetCreationTimeUtc*
  exceptions:
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>是零长度字符串，仅包含空格，或包含一个或多个无效字符。 你可以通过使用查询无效字符<xref:System.IO.Path.GetInvalidPathChars*>方法。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  platform:
  - net462
- uid: System.IO.Directory.GetCurrentDirectory
  id: GetCurrentDirectory
  parent: System.IO.Directory
  langs:
  - csharp
  name: GetCurrentDirectory()
  nameWithType: Directory.GetCurrentDirectory()
  fullName: System.IO.Directory.GetCurrentDirectory()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "获取当前工作目录的应用程序。"
  remarks: "当前目录是不同于原始的目录，它是从其启动该进程的一个。       通用 I/O 任务的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example demonstrates how to use the `GetCurrentDirectory` method.  \n  \n [!code-cs[Dir_GetCurDir#1](~/add/codesnippet/csharp/m-system.io.directory.ge_16_1.cs)]\n [!code-vb[Dir_GetCurDir#1](~/add/codesnippet/visualbasic/m-system.io.directory.ge_16_1.vb)]\n [!code-cpp[Dir_GetCurDir#1](~/add/codesnippet/cpp/m-system.io.directory.ge_16_1.cpp)]"
  syntax:
    content: public static string GetCurrentDirectory ();
    parameters: []
    return:
      type: System.String
      description: "包含当前工作目录的路径且不以反斜杠结尾的字符串 (\\\\)。"
  overload: System.IO.Directory.GetCurrentDirectory*
  exceptions:
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "操作系统为 Windows CE，不具有当前目录功能。       此方法可在.NET Compact Framework 中，但当前不支持。"
  platform:
  - net462
- uid: System.IO.Directory.GetDirectories(System.String)
  id: GetDirectories(System.String)
  parent: System.IO.Directory
  langs:
  - csharp
  name: GetDirectories(String)
  nameWithType: Directory.GetDirectories(String)
  fullName: System.IO.Directory.GetDirectories(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "返回指定目录中的子目录 （包括其路径） 的名称。"
  remarks: "此方法等同于<xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%29>将星号 （*） 指定为搜索模式，因此它将返回所有子目录。如果想要搜索子目录，使用<xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29>方法，使你可以指定具有的子目录的搜索`searchOption`参数。</xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29> </xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%29>       <xref:System.IO.Directory.EnumerateDirectories%2A>和<xref:System.IO.Directory.GetDirectories%2A>方法的行为有所不同，如下所示︰ 当你使用<xref:System.IO.Directory.EnumerateDirectories%2A>，你可以启动之前，则返回整个集合枚举名称的集合; 当你使用<xref:System.IO.Directory.GetDirectories%2A>，你必须等待的名称之前才能访问该数组返回整个数组。</xref:System.IO.Directory.GetDirectories%2A> </xref:System.IO.Directory.EnumerateDirectories%2A> </xref:System.IO.Directory.GetDirectories%2A> </xref:System.IO.Directory.EnumerateDirectories%2A> 因此，当你正在使用许多文件和目录，<xref:System.IO.Directory.EnumerateDirectories%2A>可能更有效。</xref:System.IO.Directory.EnumerateDirectories%2A>       `path`参数可以指定相对或绝对路径信息。 相对路径信息被解释为相对于当前工作目录。 若要获取当前工作目录，请参阅<xref:System.IO.Directory.GetCurrentDirectory%2A>。</xref:System.IO.Directory.GetCurrentDirectory%2A>       此方法返回的名称前加上中提供的目录信息`path`。       `path`参数不区分大小写。       通用 I/O 任务的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example takes an array of file or directory names on the command line, determines what kind of name it is, and processes it appropriately.  \n  \n [!code-cpp[Recursive file finder#1](~/add/codesnippet/cpp/m-system.io.directory.ge_13_1.cpp)]\n [!code-cs[Recursive file finder#1](~/add/codesnippet/csharp/m-system.io.directory.ge_13_1.cs)]\n [!code-vb[Recursive file finder#1](~/add/codesnippet/visualbasic/m-system.io.directory.ge_13_1.vb)]"
  syntax:
    content: public static string[] GetDirectories (string path);
    parameters:
    - id: path
      type: System.String
      description: "要搜索的目录相对或绝对路径。 此字符串不区分大小写。"
    return:
      type: System.String[]
      description: "指定的路径或如果未不找到任何目录的空数组中的子目录的完整名称 （包括路径） 的数组。"
  overload: System.IO.Directory.GetDirectories*
  exceptions:
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>是零长度字符串，仅包含空格，或包含一个或多个无效字符。 你可以通过使用查询无效字符<xref:System.IO.Path.GetInvalidPathChars*>方法。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>path</code>是一个文件名。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路径无效 （例如，它位于未映射的驱动器上）。"
  platform:
  - net462
- uid: System.IO.Directory.GetDirectories(System.String,System.String)
  id: GetDirectories(System.String,System.String)
  parent: System.IO.Directory
  langs:
  - csharp
  name: GetDirectories(String,String)
  nameWithType: Directory.GetDirectories(String,String)
  fullName: System.IO.Directory.GetDirectories(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "返回指定目录中指定的搜索模式匹配的子目录 （包括其路径） 的名称。"
  remarks: "This method returns all subdirectories directly under the specified directory that match the specified search pattern. If the specified directory has no subdirectories, or no subdirectories match the `searchPattern` parameter, this method returns an empty array. Only the top directory is searched. If you want to search the subdirectories as well, use the <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29> method and specify <xref:System.IO.SearchOption> in the `searchOption` parameter.  \n  \n `searchPattern` can be a combination of literal and wildcard characters, but doesn't support regular expressions. The following wildcard specifiers are permitted in `searchPattern`.  \n  \n|Wildcard specifier|Matches|  \n|------------------------|-------------|  \n|* (asterisk)|Zero or more characters in that position.|  \n|? (question mark)|Zero or one character in that position.|  \n  \n Characters other than the wildcard are literal characters. For example, the `searchPattern` string \"*t\" searches for all names in `path` ending with the letter \"t\". The `searchPattern` string \"s\\*\" searches for all names in `path` beginning with the letter \"s\".  \n  \n `searchPattern` cannot end in two periods (\"..\") or contain two periods (\"..\") followed by <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>, nor can it contain any invalid characters. You can query for invalid characters by using the <xref:System.IO.Path.GetInvalidPathChars%2A> method.  \n  \n The `path` parameter can specify relative or absolute path information, and is not case-sensitive.  Relative path information is interpreted as relative to the current working directory. To obtain the current working directory, see <xref:System.IO.Directory.GetCurrentDirectory%2A>.  \n  \n The <xref:System.IO.Directory.EnumerateDirectories%2A> and <xref:System.IO.Directory.GetDirectories%2A> methods differ as follows: When you use <xref:System.IO.Directory.EnumerateDirectories%2A>, you can start enumerating the collection of names before the whole collection is returned; when you use <xref:System.IO.Directory.GetDirectories%2A>, you must wait for the whole array of names to be returned before you can access the array. Therefore, when you are working with many files and directories, <xref:System.IO.Directory.EnumerateDirectories%2A> can be more efficient.  \n  \n For a list of common I/O tasks, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example counts the number of directories in a path that begin with the specified letter.  \n  \n [!code-cpp[Dir_GetDirs2#1](~/add/codesnippet/cpp/m-system.io.directory.ge_12_1.cpp)]\n [!code-cs[Dir_GetDirs2#1](~/add/codesnippet/csharp/m-system.io.directory.ge_12_1.cs)]\n [!code-vb[Dir_GetDirs2#1](~/add/codesnippet/visualbasic/m-system.io.directory.ge_12_1.vb)]"
  syntax:
    content: public static string[] GetDirectories (string path, string searchPattern);
    parameters:
    - id: path
      type: System.String
      description: "要搜索的目录相对或绝对路径。 此字符串不区分大小写。"
    - id: searchPattern
      type: System.String
      description: "要与中的子目录的名称匹配的搜索字符串`path`。 此参数可以包含有效文本和通配符字符组合 （请参阅备注），但不支持正则表达式。"
    return:
      type: System.String[]
      description: "在指定的目录中，搜索模式匹配的子目录的完整名称 （包括路径） 的数组或如果未不找到任何目录的空数组。"
  overload: System.IO.Directory.GetDirectories*
  exceptions:
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>是零长度字符串，仅包含空格，或包含一个或多个无效字符。 你可以通过使用查询无效字符<xref:System.IO.Path.GetInvalidPathChars*>。       -或-<code>searchPattern</code>不包含有效的模式。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>or <code>searchPattern</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>path</code>是一个文件名。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路径无效 （例如，它位于未映射的驱动器上）。"
  platform:
  - net462
- uid: System.IO.Directory.GetDirectories(System.String,System.String,System.IO.SearchOption)
  id: GetDirectories(System.String,System.String,System.IO.SearchOption)
  parent: System.IO.Directory
  langs:
  - csharp
  name: GetDirectories(String,String,SearchOption)
  nameWithType: Directory.GetDirectories(String,String,SearchOption)
  fullName: System.IO.Directory.GetDirectories(String,String,SearchOption)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "返回在指定的目录中，指定的搜索模式匹配的子目录 （包括其路径） 的名称，还可以搜索子目录。"
  remarks: "The `path` parameter can specify relative or absolute path information, and is not case-sensitive. Relative path information is interpreted as relative to the current working directory. To obtain the current working directory, see <xref:System.IO.Directory.GetCurrentDirectory%2A>.  \n  \n `searchPattern` can be a combination of literal and wildcard characters, but doesn't support regular expressions. The following wildcard specifiers are permitted in `searchPattern`.  \n  \n|Wildcard specifier|Matches|  \n|------------------------|-------------|  \n|* (asterisk)|Zero or more characters in that position.|  \n|? (question mark)|Zero or one character in that position.|  \n  \n Characters other than the wildcard are literal characters. For example, the `searchPattern` string \"*t\" searches for all names in `path` ending with the letter \"t\". The `searchPattern` string \"s\\*\" searches for all names in `path` beginning with the letter \"s\".  \n  \n `searchPattern` cannot end in two periods (\"..\") or contain two periods (\"..\") followed by <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>, nor can it contain any invalid characters. You can query for invalid characters by using the <xref:System.IO.Path.GetInvalidPathChars%2A> method.  \n  \n The <xref:System.IO.Directory.EnumerateDirectories%2A> and <xref:System.IO.Directory.GetDirectories%2A> methods differ as follows: When you use <xref:System.IO.Directory.EnumerateDirectories%2A>, you can start enumerating the collection of names before the whole collection is returned; when you use <xref:System.IO.Directory.GetDirectories%2A>, you must wait for the whole array of names to be returned before you can access the array. Therefore, when you are working with many files and directories, <xref:System.IO.Directory.EnumerateDirectories%2A> can be more efficient.  \n  \n For a list of common I/O tasks, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example counts the number of directories that begin with the specified letter in a path. Only the top-level directory is searched.  \n  \n [!code-vb[Dir_GetDirs2#2](~/add/codesnippet/visualbasic/15c0f479-3a12-4c2f-95ac-_1.vb)]\n [!code-cs[Dir_GetDirs2#2](~/add/codesnippet/csharp/15c0f479-3a12-4c2f-95ac-_1.cs)]"
  syntax:
    content: public static string[] GetDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);
    parameters:
    - id: path
      type: System.String
      description: "要搜索的目录相对或绝对路径。 此字符串不区分大小写。"
    - id: searchPattern
      type: System.String
      description: "要与中的子目录的名称匹配的搜索字符串`path`。 此参数可以包含有效文本和通配符字符组合 （请参阅备注），但不支持正则表达式。"
    - id: searchOption
      type: System.IO.SearchOption
      description: "指定搜索操作是否应包含所有子目录还是仅当前目录的枚举值之一。"
    return:
      type: System.String[]
      description: "与指定的条件，匹配的子目录的完整名称 （包括路径） 的数组或如果未不找到任何目录的空数组。"
  overload: System.IO.Directory.GetDirectories*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>是零长度字符串，仅包含空格，或包含一个或多个无效字符。 你可以通过使用查询无效字符<xref:System.IO.Path.GetInvalidPathChars*>方法。       -或-<code>searchPattern</code>不包含有效模式。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>or <code>searchPattern</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>searchOption</code>不是有效<xref href=&quot;System.IO.SearchOption&quot;></xref>值。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>path</code>是一个文件名。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路径无效 （例如，它位于未映射的驱动器上）。"
  platform:
  - net462
- uid: System.IO.Directory.GetDirectoryRoot(System.String)
  id: GetDirectoryRoot(System.String)
  parent: System.IO.Directory
  langs:
  - csharp
  name: GetDirectoryRoot(String)
  nameWithType: Directory.GetDirectoryRoot(String)
  fullName: System.IO.Directory.GetDirectoryRoot(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "返回的卷信息、 根信息或两者同时指定的路径。"
  remarks: "此方法获取的完全限定的路径名称`path`，如由<xref:System.IO.Path.GetFullPath%2A>，并返回根目录信息。</xref:System.IO.Path.GetFullPath%2A> 指定的路径不需要存在。       `path`参数允许指定相对或绝对路径信息。 相对路径信息被解释为相对于当前工作目录。 若要获取当前工作目录，请参阅<xref:System.IO.Directory.GetCurrentDirectory%2A>。</xref:System.IO.Directory.GetCurrentDirectory%2A>       `path`参数不区分大小写。       通用 I/O 任务的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example illustrates how to set the current directory and display the directory root.  \n  \n [!code-cpp[System.IO.DirectoryRoot#1](~/add/codesnippet/cpp/m-system.io.directory.ge_10_1.cpp)]\n [!code-cs[System.IO.DirectoryRoot#1](~/add/codesnippet/csharp/m-system.io.directory.ge_10_1.cs)]\n [!code-vb[System.IO.DirectoryRoot#1](~/add/codesnippet/visualbasic/m-system.io.directory.ge_10_1.vb)]"
  syntax:
    content: public static string GetDirectoryRoot (string path);
    parameters:
    - id: path
      type: System.String
      description: "文件或目录的路径。"
    return:
      type: System.String
      description: "包含的卷信息、 根信息或两者同时指定的路径的字符串。"
  overload: System.IO.Directory.GetDirectoryRoot*
  exceptions:
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>是零长度字符串，仅包含空格，或包含一个或多个无效字符。 你可以查询无效字符替换<xref:System.IO.Path.GetInvalidPathChars*>。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  platform:
  - net462
- uid: System.IO.Directory.GetFiles(System.String)
  id: GetFiles(System.String)
  parent: System.IO.Directory
  langs:
  - csharp
  name: GetFiles(String)
  nameWithType: Directory.GetFiles(String)
  fullName: System.IO.Directory.GetFiles(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "返回指定目录中的文件 （包括其路径） 的名称。"
  remarks: "<xref:System.IO.Directory.EnumerateFiles%2A>和<xref:System.IO.Directory.GetFiles%2A>方法的行为有所不同，如下所示︰ 当你使用<xref:System.IO.Directory.EnumerateFiles%2A>，你可以启动之前，则返回整个集合枚举名称的集合; 当你使用<xref:System.IO.Directory.GetFiles%2A>，你必须等待的名称之前才能访问该数组返回整个数组。</xref:System.IO.Directory.GetFiles%2A> </xref:System.IO.Directory.EnumerateFiles%2A> </xref:System.IO.Directory.GetFiles%2A> </xref:System.IO.Directory.EnumerateFiles%2A> 因此，当你正在使用许多文件和目录，<xref:System.IO.Directory.EnumerateFiles%2A>可能更有效。</xref:System.IO.Directory.EnumerateFiles%2A>       返回的文件名追加为所提供`path`参数。       此方法等同于<xref:System.IO.Directory.GetFiles%28System.String%2CSystem.String%29>有星号 （*） 指定为搜索模式。</xref:System.IO.Directory.GetFiles%28System.String%2CSystem.String%29>       `path`参数可以指定相对或绝对路径信息。 相对路径信息被解释为相对于当前工作目录。 若要获取当前工作目录，请参阅<xref:System.IO.Directory.GetCurrentDirectory%2A>。</xref:System.IO.Directory.GetCurrentDirectory%2A>       返回的文件的名称的顺序不能保证;使用<xref:System.Array.Sort%2A>方法是否需要特定的排序顺序。</xref:System.Array.Sort%2A>       `path`参数不区分大小写。       通用 I/O 任务的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example demonstrates how to use the GetFiles method to return file names from a user-specified location. The example is configured to catch all errors common to this method.  \n  \n [!code-cpp[Recursive file finder#1](~/add/codesnippet/cpp/m-system.io.directory.ge_0_1.cpp)]\n [!code-cs[Recursive file finder#1](~/add/codesnippet/csharp/m-system.io.directory.ge_0_1.cs)]\n [!code-vb[Recursive file finder#1](~/add/codesnippet/visualbasic/m-system.io.directory.ge_0_1.vb)]"
  syntax:
    content: public static string[] GetFiles (string path);
    parameters:
    - id: path
      type: System.String
      description: "要搜索的目录相对或绝对路径。 此字符串不区分大小写。"
    return:
      type: System.String[]
      description: "指定的目录中的文件的完整名称 （包括路径） 的数组或如果未不找到任何文件的空数组。"
  overload: System.IO.Directory.GetFiles*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>path</code>是一个文件名。       -或者-发生了网络错误。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>是零长度字符串，仅包含空格，或包含一个或多个无效字符。 你可以通过使用查询无效字符<xref:System.IO.Path.GetInvalidPathChars*>方法。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路径未找到或无效 （例如，它位于未映射的驱动器上）。"
  platform:
  - net462
- uid: System.IO.Directory.GetFiles(System.String,System.String)
  id: GetFiles(System.String,System.String)
  parent: System.IO.Directory
  langs:
  - csharp
  name: GetFiles(String,String)
  nameWithType: Directory.GetFiles(String,String)
  fullName: System.IO.Directory.GetFiles(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "返回指定目录中指定的搜索模式匹配的文件 （包括其路径） 的名称。"
  remarks: "The returned file names are appended to the supplied `path` parameter and the order of the returned file names is not guaranteed; use the <xref:System.Array.Sort%2A> method if a specific sort order is required.  \n  \n `searchPattern` can be a combination of literal and wildcard characters, but doesn't support regular expressions. The following wildcard specifiers are permitted in `searchPattern`.  \n  \n|Wildcard specifier|Matches|  \n|------------------------|-------------|  \n|* (asterisk)|Zero or more characters in that position.|  \n|? (question mark)|Zero or one character in that position.|  \n  \n Characters other than the wildcard are literal characters. For example, the `searchPattern` string \"*t\" searches for all names in `path` ending with the letter \"t\". The `searchPattern` string \"s\\*\" searches for all names in `path` beginning with the letter \"s\".  \n  \n `searchPattern` cannot end in two periods (\"..\") or contain two periods (\"..\") followed by <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>, nor can it contain any invalid characters. You can query for invalid characters by using the <xref:System.IO.Path.GetInvalidPathChars%2A> method.  \n  \n> [!NOTE]\n>  When you use the asterisk wildcard character in a `searchPattern` such as \"*.txt\", the number of characters in the specified extension affects the search as follows:  \n>   \n>  -   If the specified extension is exactly three characters long, the method returns files with extensions that begin with the specified extension. For example, \"*.xls\" returns both \"book.xls\" and \"book.xlsx\".  \n> -   In all other cases, the method returns files that exactly match the specified extension. For example, \"*.ai\" returns \"file.ai\" but not \"file.aif\".  \n>   \n>  When you use the question mark wildcard character, this method returns only files that match the specified file extension. For example, given two files, \"file1.txt\" and \"file1.txtother\", in a directory, a search pattern of \"file?.txt\" returns just the first file, whereas a search pattern of \"file*.txt\" returns both files.  \n  \n> [!NOTE]\n>  Because this method checks against file names with both the 8.3 file name format and the long file name format, a search pattern similar to \"*1\\*.txt\" may return unexpected file names. For example, using a search pattern of \"\\*1\\*.txt\" returns \"longfilename.txt\" because the equivalent 8.3 file name format is \"LONGFI~1.TXT\".  \n  \n The <xref:System.IO.Directory.EnumerateFiles%2A> and <xref:System.IO.Directory.GetFiles%2A> methods differ as follows: When you use <xref:System.IO.Directory.EnumerateFiles%2A>, you can start enumerating the collection of names before the whole collection is returned; when you use <xref:System.IO.Directory.GetFiles%2A>, you must wait for the whole array of names to be returned before you can access the array. Therefore, when you are working with many files and directories, <xref:System.IO.Directory.EnumerateFiles%2A> can be more efficient.  \n  \n The `path` parameter can specify relative or absolute path information. Relative path information is interpreted as relative to the current working directory. To obtain the current working directory, see <xref:System.IO.Directory.GetCurrentDirectory%2A>.  \n  \n The `path` parameter is not case-sensitive.  \n  \n For a list of common I/O tasks, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example counts the number of files that begin with the specified letter.  \n  \n [!code-vb[Dir_GetFiles2#1](~/add/codesnippet/visualbasic/m-system.io.directory.ge_15_1.vb)]\n [!code-cs[Dir_GetFiles2#1](~/add/codesnippet/csharp/m-system.io.directory.ge_15_1.cs)]\n [!code-cpp[Dir_GetFiles2#1](~/add/codesnippet/cpp/m-system.io.directory.ge_15_1.cpp)]"
  syntax:
    content: public static string[] GetFiles (string path, string searchPattern);
    parameters:
    - id: path
      type: System.String
      description: "要搜索的目录相对或绝对路径。 此字符串不区分大小写。"
    - id: searchPattern
      type: System.String
      description: "要与中的文件的名称匹配的搜索字符串`path`。  此参数可以包含有效文本路径和通配符的组合 (* 和？) 字符 （请参阅备注），但不支持正则表达式。"
    return:
      type: System.String[]
      description: "数组中指定的目录的文件的完整名称 （包括路径） 的匹配指定的搜索模式中，则为空数组如果未不找到任何文件。"
  overload: System.IO.Directory.GetFiles*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>path</code>是一个文件名。       -或者-发生了网络错误。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>是零长度字符串，仅包含空格，或包含一个或多个无效字符。 你可以通过使用查询无效字符<xref:System.IO.Path.GetInvalidPathChars*>。       -或-<code>searchPattern</code>不包含有效的模式。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>or <code>searchPattern</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路径未找到或无效 （例如，它位于未映射的驱动器上）。"
  platform:
  - net462
- uid: System.IO.Directory.GetFiles(System.String,System.String,System.IO.SearchOption)
  id: GetFiles(System.String,System.String,System.IO.SearchOption)
  parent: System.IO.Directory
  langs:
  - csharp
  name: GetFiles(String,String,SearchOption)
  nameWithType: Directory.GetFiles(String,String,SearchOption)
  fullName: System.IO.Directory.GetFiles(String,String,SearchOption)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "返回与指定的目录，使用某个值确定是否搜索子目录中指定的搜索模式匹配的文件 （包括其路径） 的名称。"
  remarks: "The returned file names are appended to the supplied  parameter `path` and the order of the returned file names is not guaranteed; use the <xref:System.Array.Sort%2A> method if a specific sort order is required.  \n  \n `searchPattern` can be a combination of literal and wildcard characters, but doesn't support regular expressions. The following wildcard specifiers are permitted in `searchPattern`.  \n  \n|Wildcard specifier|Matches|  \n|------------------------|-------------|  \n|* (asterisk)|Zero or more characters in that position.|  \n|? (question mark)|Zero or one character in that position.|  \n  \n Characters other than the wildcard are literal characters. For example, the `searchPattern` string \"*t\" searches for all names in `path` ending with the letter \"t\". The `searchPattern` string \"s\\*\" searches for all names in `path` beginning with the letter \"s\".  \n  \n `searchPattern` cannot end in two periods (\"..\") or contain two periods (\"..\") followed by <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>, nor can it contain any invalid characters. You can query for invalid characters by using the <xref:System.IO.Path.GetInvalidPathChars%2A> method.  \n  \n> [!NOTE]\n>  When you use the asterisk wildcard character in a `searchPattern` such as \"*.txt\", the number of characters in the specified extension affects the search as follows:  \n>   \n>  -   If the specified extension is exactly three characters long, the method returns files with extensions that begin with the specified extension. For example, \"*.xls\" returns both \"book.xls\" and \"book.xlsx\".  \n> -   In all other cases, the method returns files that exactly match the specified extension. For example, \"*.ai\" returns \"file.ai\" but not \"file.aif\".  \n>   \n>  When you use the question mark wildcard character, this method returns only files that match the specified file extension. For example, given two files, \"file1.txt\" and \"file1.txtother\", in a directory, a search pattern of \"file?.txt\" returns just the first file, whereas a search pattern of \"file*.txt\" returns both files.  \n  \n> [!NOTE]\n>  Because this method checks against file names with both the 8.3 file name format and the long file name format, a search pattern similar to \"*1\\*.txt\" may return unexpected file names. For example, using a search pattern of \"\\*1\\*.txt\" returns \"longfilename.txt\" because the equivalent 8.3 file name format is \"LONGFI~1.TXT\".  \n  \n The <xref:System.IO.Directory.EnumerateFiles%2A> and <xref:System.IO.Directory.GetFiles%2A> methods differ as follows: When you use <xref:System.IO.Directory.EnumerateFiles%2A>, you can start enumerating the collection of names before the whole collection is returned; when you use <xref:System.IO.Directory.GetFiles%2A>, you must wait for the whole array of names to be returned before you can access the array. Therefore, when you are working with many files and directories, <xref:System.IO.Directory.EnumerateFiles%2A> can be more efficient.  \n  \n The file names include the full path.  \n  \n The `path` parameter can specify relative or absolute path information. Relative path information is interpreted as relative to the current working directory. To obtain the current working directory, see <xref:System.IO.Directory.GetCurrentDirectory%2A>.  \n  \n The `path` parameter is not case-sensitive.  \n  \n For a list of common I/O tasks, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static string[] GetFiles (string path, string searchPattern, System.IO.SearchOption searchOption);
    parameters:
    - id: path
      type: System.String
      description: "要搜索的目录相对或绝对路径。 此字符串不区分大小写。"
    - id: searchPattern
      type: System.String
      description: "要与中的文件的名称匹配的搜索字符串`path`。  此参数可以包含有效文本路径和通配符的组合 (* 和？) 字符 （请参阅备注），但不支持正则表达式。"
    - id: searchOption
      type: System.IO.SearchOption
      description: "指定搜索操作是否应包含所有子目录还是仅当前目录的枚举值之一。"
    return:
      type: System.String[]
      description: "未找到指定的目录中与指定的搜索模式和选项，匹配的文件的完整名称 （包括路径） 的数组则如果任何文件的空数组。"
  overload: System.IO.Directory.GetFiles*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>是零长度字符串，仅包含空格，或包含一个或多个无效字符。 你可以查询无效字符替换<xref:System.IO.Path.GetInvalidPathChars*>方法。       -或-<code>searchPattern</code>不包含有效模式。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>or <code>searchpattern</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>searchOption</code>不是有效<xref href=&quot;System.IO.SearchOption&quot;></xref>值。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路径未找到或无效 （例如，它位于未映射的驱动器上）。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>path</code>是一个文件名。       -或者-发生了网络错误。"
  platform:
  - net462
- uid: System.IO.Directory.GetFileSystemEntries(System.String)
  id: GetFileSystemEntries(System.String)
  parent: System.IO.Directory
  langs:
  - csharp
  name: GetFileSystemEntries(String)
  nameWithType: Directory.GetFileSystemEntries(String)
  fullName: System.IO.Directory.GetFileSystemEntries(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "返回指定路径中的所有文件和子目录的名称。"
  remarks: "返回的文件和目录名称的顺序不能保证;使用<xref:System.Array.Sort%2A>方法是否需要特定的排序顺序。</xref:System.Array.Sort%2A>       <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>和<xref:System.IO.Directory.GetFileSystemEntries%2A>方法的行为有所不同，如下所示︰ 当你使用<xref:System.IO.Directory.EnumerateFileSystemEntries%2A>，你可以启动之前，则返回整个集合枚举的项的集合; 当你使用<xref:System.IO.Directory.GetFileSystemEntries%2A>，你必须等待的项，然后才能访问该数组返回整个数组。</xref:System.IO.Directory.GetFileSystemEntries%2A> </xref:System.IO.Directory.EnumerateFileSystemEntries%2A> </xref:System.IO.Directory.GetFileSystemEntries%2A> </xref:System.IO.Directory.EnumerateFileSystemEntries%2A> 因此，当你正在使用许多文件和目录，<xref:System.IO.Directory.EnumerateFiles%2A>可能更有效。</xref:System.IO.Directory.EnumerateFiles%2A>       此方法等同于<xref:System.IO.Directory.GetFileSystemEntries%2A>有星号 （*） 指定为搜索模式。</xref:System.IO.Directory.GetFileSystemEntries%2A>       `path`参数允许指定相对或绝对路径信息。 相对路径信息被解释为相对于当前工作目录。 若要获取当前工作目录，请参阅<xref:System.IO.Directory.GetCurrentDirectory%2A>。</xref:System.IO.Directory.GetCurrentDirectory%2A>       `path`参数不区分大小写。       通用 I/O 任务的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example uses the GetFileSystemEntries method to fill an array of strings with the names of all files and subdirectories in a user-specified location and prints each string in the array to the console. The example is configured to catch all errors common to this method.  \n  \n [!code-cs[System.IO.Directory#1](~/add/codesnippet/csharp/m-system.io.directory.ge_4_1.cs)]\n [!code-vb[System.IO.Directory#1](~/add/codesnippet/visualbasic/m-system.io.directory.ge_4_1.vb)]\n [!code-cpp[System.IO.Directory#1](~/add/codesnippet/cpp/m-system.io.directory.ge_4_1.cpp)]"
  syntax:
    content: public static string[] GetFileSystemEntries (string path);
    parameters:
    - id: path
      type: System.String
      description: "要搜索的目录相对或绝对路径。 此字符串不区分大小写。"
    return:
      type: System.String[]
      description: "数组中指定的目录的文件和子目录的名称或为空数组，如果不找到任何文件或子目录。"
  overload: System.IO.Directory.GetFileSystemEntries*
  exceptions:
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>是零长度字符串，仅包含空格，或包含一个或多个无效字符。 你可以查询无效字符替换<xref:System.IO.Path.GetInvalidPathChars*>。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>path</code>是一个文件名。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路径无效 （例如，它位于未映射的驱动器上）。"
  platform:
  - net462
- uid: System.IO.Directory.GetFileSystemEntries(System.String,System.String)
  id: GetFileSystemEntries(System.String,System.String)
  parent: System.IO.Directory
  langs:
  - csharp
  name: GetFileSystemEntries(String,String)
  nameWithType: Directory.GetFileSystemEntries(String,String)
  fullName: System.IO.Directory.GetFileSystemEntries(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "返回指定路径中的数组的文件名和目录名的相匹配的搜索模式。"
  remarks: "The order of the returned file and directory names is not guaranteed; use the <xref:System.Array.Sort%2A> method if a specific sort order is required.  \n  \n `searchPattern` can be a combination of literal and wildcard characters, but doesn't support regular expressions. The following wildcard specifiers are permitted in `searchPattern`.  \n  \n|Wildcard specifier|Matches|  \n|------------------------|-------------|  \n|* (asterisk)|Zero or more characters in that position.|  \n|? (question mark)|Zero or one character in that position.|  \n  \n Characters other than the wildcard are literal characters. For example, the `searchPattern` string \"*t\" searches for all names in `path` ending with the letter \"t\". The `searchPattern` string \"s\\*\" searches for all names in `path` beginning with the letter \"s\".  \n  \n `searchPattern` cannot end in two periods (\"..\") or contain two periods (\"..\") followed by <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>, nor can it contain any invalid characters. You can query for invalid characters by using the <xref:System.IO.Path.GetInvalidPathChars%2A> method.  \n  \n> [!NOTE]\n>  When you use the asterisk wildcard character in a `searchPattern` such as \"*.txt\", the number of characters in the specified extension affects the search as follows:  \n>   \n>  -   If the specified extension is exactly three characters long, the method returns files with extensions that begin with the specified extension. For example, \"*.xls\" returns both \"book.xls\" and \"book.xlsx\".  \n> -   In all other cases, the method returns files that exactly match the specified extension. For example, \"*.ai\" returns \"file.ai\" but not \"file.aif\".  \n>   \n>  When you use the question mark wildcard character, this method returns only files that match the specified file extension. For example, given two files, \"file1.txt\" and \"file1.txtother\", in a directory, a search pattern of \"file?.txt\" returns just the first file, whereas a search pattern of \"file*.txt\" returns both files.  \n  \n The `path` parameter is permitted to specify relative or absolute path information. Relative path information is interpreted as relative to the current working directory. To obtain the current working directory, see <xref:System.IO.Directory.GetCurrentDirectory%2A>.  \n  \n The `path` parameter is not case-sensitive.  \n  \n For a list of common I/O tasks, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example uses the GetFileSystemEntries method to fill an array of strings with the names of all files matching a user-specified filter in a specific location and prints each string in the array to the console. The example is configured to catch all errors common to this method.  \n  \n [!code-cs[System.IO.Directory#2](~/add/codesnippet/csharp/m-system.io.directory.ge_8_1.cs)]\n [!code-vb[System.IO.Directory#2](~/add/codesnippet/visualbasic/m-system.io.directory.ge_8_1.vb)]\n [!code-cpp[System.IO.Directory#2](~/add/codesnippet/cpp/m-system.io.directory.ge_8_1.cpp)]"
  syntax:
    content: public static string[] GetFileSystemEntries (string path, string searchPattern);
    parameters:
    - id: path
      type: System.String
      description: "要搜索的目录相对或绝对路径。 此字符串不区分大小写。"
    - id: searchPattern
      type: System.String
      description: "要与中的文件和目录的名称匹配的搜索字符串`path`。  此参数可以包含有效文本路径和通配符的组合 (* 和？) 字符 （请参阅备注），但不支持正则表达式。"
    return:
      type: System.String[]
      description: "文件名称和与指定的搜索条件匹配的目录名的数组或如果不找到任何文件或目录的空数组。"
  overload: System.IO.Directory.GetFileSystemEntries*
  exceptions:
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>是零长度字符串，仅包含空格，或包含一个或多个无效字符。 你可以查询无效字符替换<xref:System.IO.Path.GetInvalidPathChars*>方法。       -或-<code>searchPattern</code>不包含有效模式。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>or <code>searchPattern</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>path</code>是一个文件名。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路径无效 （例如，它位于未映射的驱动器上）。"
  platform:
  - net462
- uid: System.IO.Directory.GetFileSystemEntries(System.String,System.String,System.IO.SearchOption)
  id: GetFileSystemEntries(System.String,System.String,System.IO.SearchOption)
  parent: System.IO.Directory
  langs:
  - csharp
  name: GetFileSystemEntries(String,String,SearchOption)
  nameWithType: Directory.GetFileSystemEntries(String,String,SearchOption)
  fullName: System.IO.Directory.GetFileSystemEntries(String,String,SearchOption)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "返回所有文件的名称和与指定路径中的搜索模式匹配的目录名的数组，还可以搜索子目录。"
  remarks: "The order of the returned file and directory names is not guaranteed; use the <xref:System.Array.Sort%2A> method if a specific sort order is required.  \n  \n `searchPattern` can be a combination of literal and wildcard characters, but doesn't support regular expressions. The following wildcard specifiers are permitted in `searchPattern`.  \n  \n|Wildcard specifier|Matches|  \n|------------------------|-------------|  \n|* (asterisk)|Zero or more characters in that position.|  \n|? (question mark)|Zero or one character in that position.|  \n  \n Characters other than the wildcard are literal characters. For example, the `searchPattern` string \"*t\" searches for all names in `path` ending with the letter \"t\". The `searchPattern` string \"s\\*\" searches for all names in `path` beginning with the letter \"s\".  \n  \n `searchPattern` cannot end in two periods (\"..\") or contain two periods (\"..\") followed by <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>, nor can it contain any invalid characters. You can query for invalid characters by using the <xref:System.IO.Path.GetInvalidPathChars%2A> method.  \n  \n> [!NOTE]\n>  When you use the asterisk wildcard character in a `searchPattern` such as \"*.txt\", the number of characters in the specified extension affects the search as follows:  \n>   \n>  -   If the specified extension is exactly three characters long, the method returns files with extensions that begin with the specified extension. For example, \"*.xls\" returns both \"book.xls\" and \"book.xlsx\".  \n> -   In all other cases, the method returns files that exactly match the specified extension. For example, \"*.ai\" returns \"file.ai\" but not \"file.aif\".  \n>   \n>  When you use the question mark wildcard character, this method returns only files that match the specified file extension. For example, given two files, \"file1.txt\" and \"file1.txtother\", in a directory, a search pattern of \"file?.txt\" returns just the first file, whereas a search pattern of \"file*.txt\" returns both files.  \n  \n The <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> and <xref:System.IO.Directory.GetFileSystemEntries%2A> methods differ as follows: When you use <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, you can start enumerating the collection of entries before the whole collection is returned; when you use <xref:System.IO.Directory.GetFileSystemEntries%2A>, you must wait for the whole array of entries to be returned before you can access the array. Therefore, when you are working with many files and directories, <xref:System.IO.Directory.EnumerateFiles%2A> can be more efficient.  \n  \n You can specify relative path information with the `path` parameter. Relative path information is interpreted as relative to the current working directory, which you can determine by using the <xref:System.IO.Directory.GetCurrentDirectory%2A> method."
  syntax:
    content: public static string[] GetFileSystemEntries (string path, string searchPattern, System.IO.SearchOption searchOption);
    parameters:
    - id: path
      type: System.String
      description: "要搜索的目录相对或绝对路径。 此字符串不区分大小写。"
    - id: searchPattern
      type: System.String
      description: "要与中的文件和目录的名称匹配的搜索字符串`path`。  此参数可以包含有效文本路径和通配符的组合 (* 和？) 字符 （请参阅备注），但不支持正则表达式。"
    - id: searchOption
      type: System.IO.SearchOption
      description: "指定搜索操作是应仅包含当前目录还是应包含所有子目录的枚举值之一。       默认值是<xref href=&quot;System.IO.SearchOption&quot;> </xref>。"
    return:
      type: System.String[]
      description: "找到的文件名和目录名的匹配指定的搜索条件，则为空数组，如果任何文件或目录的文件的数组。"
  overload: System.IO.Directory.GetFileSystemEntries*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path </code>is a zero-length string, contains only white space, or contains invalid characters. You can query for invalid characters by using the <xref:System.IO.Path.GetInvalidPathChars*> method.  \n  \n \\- or -  \n  \n <code>searchPattern</code> does not contain a valid pattern."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>searchPattern</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>searchOption</code>不是有效<xref href=&quot;System.IO.SearchOption&quot;></xref>值。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "<code>path</code>无效，如引用未映射的驱动器。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>path</code>是一个文件名。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径，或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  platform:
  - net462
- uid: System.IO.Directory.GetLastAccessTime(System.String)
  id: GetLastAccessTime(System.String)
  parent: System.IO.Directory
  langs:
  - csharp
  name: GetLastAccessTime(String)
  nameWithType: Directory.GetLastAccessTime(String)
  fullName: System.IO.Directory.GetLastAccessTime(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "返回的日期和时间指定上次访问文件或目录。"
  remarks: "> [!NOTE]1> 此方法可能返回不准确的值，因为它使用其值可能不会持续更新由操作系统的本机函数。       此方法等同于<xref:System.IO.File.GetLastAccessTime%2A?displayProperty=fullName>.</xref:System.IO.File.GetLastAccessTime%2A?displayProperty=fullName>       如果目录中所述`path`参数不存在，此方法将返回第午夜 12:00 到公元 1601 年 1 月 1 日 (C.E.)为本地时间调整协调世界时 (UTC)。       `path`参数允许指定相对或绝对路径信息。 相对路径信息被解释为相对于当前工作目录。 若要获取当前工作目录，请参阅<xref:System.IO.Directory.GetCurrentDirectory%2A>。</xref:System.IO.Directory.GetCurrentDirectory%2A>       `path`参数不区分大小写。       通用 I/O 任务的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example demonstrates how to use `GetLastAccessTime`.  \n  \n [!code-cpp[Dir_GetLastAccess#1](~/add/codesnippet/cpp/m-system.io.directory.ge_6_1.cpp)]\n [!code-vb[Dir_GetLastAccess#1](~/add/codesnippet/visualbasic/m-system.io.directory.ge_6_1.vb)]\n [!code-cs[Dir_GetLastAccess#1](~/add/codesnippet/csharp/m-system.io.directory.ge_6_1.cs)]"
  syntax:
    content: public static DateTime GetLastAccessTime (string path);
    parameters:
    - id: path
      type: System.String
      description: "文件或为要获取其访问日期和时间信息的目录中。"
    return:
      type: System.DateTime
      description: "上次访问一个结构，它设置为日期和时间的指定的文件或目录。 该值用本地时间表示。"
  overload: System.IO.Directory.GetLastAccessTime*
  exceptions:
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>是零长度字符串，仅包含空格，或包含一个或多个无效字符。 你可以查询无效字符替换<xref:System.IO.Path.GetInvalidPathChars*>方法。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code> path </code>参数是格式无效。"
  platform:
  - net462
- uid: System.IO.Directory.GetLastAccessTimeUtc(System.String)
  id: GetLastAccessTimeUtc(System.String)
  parent: System.IO.Directory
  langs:
  - csharp
  name: GetLastAccessTimeUtc(String)
  nameWithType: Directory.GetLastAccessTimeUtc(String)
  fullName: System.IO.Directory.GetLastAccessTimeUtc(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "返回上次访问指定的文件或目录的日期和时间，其格式为协调世界时 (UTC)。"
  remarks: "> [!NOTE]1> 此方法可能返回不准确的值，因为它使用其值可能不会持续更新由操作系统的本机函数。       如果目录中所述`path`参数不存在，此方法将返回第午夜 12:00 到公元 1601 年 1 月 1 日 (C.E.)协调世界时 (UTC)。       通用 I/O 任务的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example illustrates the differences in output when using Coordinated Universal Time (UTC) output.  \n  \n [!code-cs[System.IO.UTCExample#1](~/add/codesnippet/csharp/m-system.io.directory.ge_9_1.cs)]\n [!code-cpp[System.IO.UTCExample#1](~/add/codesnippet/cpp/m-system.io.directory.ge_9_1.cpp)]\n [!code-vb[System.IO.UTCExample#1](~/add/codesnippet/visualbasic/m-system.io.directory.ge_9_1.vb)]"
  syntax:
    content: public static DateTime GetLastAccessTimeUtc (string path);
    parameters:
    - id: path
      type: System.String
      description: "文件或为要获取其访问日期和时间信息的目录中。"
    return:
      type: System.DateTime
      description: "上次访问一个结构，它设置为日期和时间的指定的文件或目录。 该值用 UTC 时间表示。"
  overload: System.IO.Directory.GetLastAccessTimeUtc*
  exceptions:
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>是零长度字符串，仅包含空格，或包含一个或多个无效字符。 你可以查询无效字符替换<xref:System.IO.Path.GetInvalidPathChars*>方法。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code> path </code>参数是格式无效。"
  platform:
  - net462
- uid: System.IO.Directory.GetLastWriteTime(System.String)
  id: GetLastWriteTime(System.String)
  parent: System.IO.Directory
  langs:
  - csharp
  name: GetLastWriteTime(String)
  nameWithType: Directory.GetLastWriteTime(String)
  fullName: System.IO.Directory.GetLastWriteTime(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "返回的日期和时间指定上次写入文件或目录。"
  remarks: "> [!NOTE]1> 此方法可能返回不准确的值，因为它使用其值可能不会持续更新由操作系统的本机函数。       如果目录中所述`path`参数不存在，此方法将返回第午夜 12:00 到公元 1601 年 1 月 1 日 (C.E.)为本地时间调整协调世界时 (UTC)。       `path`参数允许指定相对或绝对路径信息。 相对路径信息被解释为相对于当前工作目录。 若要获取当前工作目录，请参阅<xref:System.IO.Directory.GetCurrentDirectory%2A>。</xref:System.IO.Directory.GetCurrentDirectory%2A>       `path`参数不区分大小写。       通用 I/O 任务的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example demonstrates how to use `GetLastWriteTime`.  \n  \n [!code-cs[Dir_GetLastWrite#1](~/add/codesnippet/csharp/m-system.io.directory.ge_14_1.cs)]\n [!code-cpp[Dir_GetLastWrite#1](~/add/codesnippet/cpp/m-system.io.directory.ge_14_1.cpp)]\n [!code-vb[Dir_GetLastWrite#1](~/add/codesnippet/visualbasic/m-system.io.directory.ge_14_1.vb)]"
  syntax:
    content: public static DateTime GetLastWriteTime (string path);
    parameters:
    - id: path
      type: System.String
      description: "文件或为要获取其修改日期和时间信息的目录中。"
    return:
      type: System.DateTime
      description: "上次写入一个结构，它设置为日期和时间的指定的文件或目录。 该值用本地时间表示。"
  overload: System.IO.Directory.GetLastWriteTime*
  exceptions:
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>是零长度字符串，仅包含空格，或包含一个或多个无效字符。 你可以查询无效字符替换<xref:System.IO.Path.GetInvalidPathChars*>方法。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  platform:
  - net462
- uid: System.IO.Directory.GetLastWriteTimeUtc(System.String)
  id: GetLastWriteTimeUtc(System.String)
  parent: System.IO.Directory
  langs:
  - csharp
  name: GetLastWriteTimeUtc(String)
  nameWithType: Directory.GetLastWriteTimeUtc(String)
  fullName: System.IO.Directory.GetLastWriteTimeUtc(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "返回的日期和时间，格式为协调世界时 (UTC)，上次写入指定的文件或目录。"
  remarks: "> [!NOTE]1> 此方法可能返回不准确的值，因为它使用其值可能不会持续更新由操作系统的本机函数。       如果目录中所述`path`参数不存在，此方法将返回第午夜 12:00 到公元 1601 年 1 月 1 日 (C.E.)协调世界时 (UTC)。       通用 I/O 任务的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example illustrates the differences in output when using Coordinated Universal Time (UTC) output.  \n  \n [!code-cs[System.IO.UTCExample#1](~/add/codesnippet/csharp/m-system.io.directory.ge_2_1.cs)]\n [!code-cpp[System.IO.UTCExample#1](~/add/codesnippet/cpp/m-system.io.directory.ge_2_1.cpp)]\n [!code-vb[System.IO.UTCExample#1](~/add/codesnippet/visualbasic/m-system.io.directory.ge_2_1.vb)]"
  syntax:
    content: public static DateTime GetLastWriteTimeUtc (string path);
    parameters:
    - id: path
      type: System.String
      description: "文件或为要获取其修改日期和时间信息的目录中。"
    return:
      type: System.DateTime
      description: "上次写入一个结构，它设置为日期和时间的指定的文件或目录。 该值用 UTC 时间表示。"
  overload: System.IO.Directory.GetLastWriteTimeUtc*
  exceptions:
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>是零长度字符串，仅包含空格，或包含一个或多个无效字符。 你可以查询无效字符替换<xref:System.IO.Path.GetInvalidPathChars*>方法。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  platform:
  - net462
- uid: System.IO.Directory.GetLogicalDrives
  id: GetLogicalDrives
  parent: System.IO.Directory
  langs:
  - csharp
  name: GetLogicalDrives()
  nameWithType: Directory.GetLogicalDrives()
  fullName: System.IO.Directory.GetLogicalDrives()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "检索的窗体中的此计算机上的逻辑驱动器的名称&quot;&lt;驱动器号&gt;:\\&quot;。"
  remarks: "GetLogicalDrives 将返回所有可访问驱动器在特定计算机上，包括软盘驱动器和任何光学。       通用 I/O 任务的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example uses the GetLogicalDrives method to assign the name of each drive on the calling computer to an array of strings. Each member of this string array is then printed to the console. The example is configured to catch all errors common to this method.  \n  \n [!code-cs[System.IO.Directory#3](~/add/codesnippet/csharp/m-system.io.directory.ge_3_1.cs)]\n [!code-vb[System.IO.Directory#3](~/add/codesnippet/visualbasic/m-system.io.directory.ge_3_1.vb)]\n [!code-cpp[System.IO.Directory#3](~/add/codesnippet/cpp/m-system.io.directory.ge_3_1.cpp)]"
  syntax:
    content: public static string[] GetLogicalDrives ();
    parameters: []
    return:
      type: System.String[]
      description: "此计算机上的逻辑驱动器。"
  overload: System.IO.Directory.GetLogicalDrives*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "（例如磁盘错误），发生了 I/O 错误。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  platform:
  - net462
- uid: System.IO.Directory.GetParent(System.String)
  id: GetParent(System.String)
  parent: System.IO.Directory
  langs:
  - csharp
  name: GetParent(String)
  nameWithType: Directory.GetParent(String)
  fullName: System.IO.Directory.GetParent(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "检索指定的路径，包括绝对和相对路径的父目录。"
  remarks: "The `path` parameter is permitted to specify relative or absolute path information. Relative path information is interpreted as relative to the current working directory. To obtain the current working directory, see <xref:System.IO.Directory.GetCurrentDirectory%2A>.  \n  \n Trailing spaces are removed from the end of the `path` parameter before getting the directory.  \n  \n The string returned by this method consists of all characters in the path up to, but not including, the last <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>. For example, passing the path \"C:\\Directory\\SubDirectory\\test.txt\" to GetParent returns \"C:\\Directory\\SubDirectory\". Passing \"C:\\Directory\\SubDirectory\" returns \"C:\\Directory\". However, passing \"C:\\Directory\\SubDirectory\\\\\" returns \"C:\\Directory\\SubDirectory\", because the ending directory separator is after \"SubDirectory\".  \n  \n The `path` parameter is not case-sensitive.  \n  \n For a list of common I/O tasks, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example demonstrates how to use the GetParent method to retrieve the parent directory of a user-specified location, \"path\". The value returned by the GetParent method is then printed to the console. The example is configured to catch all errors common to this method.  \n  \n [!code-cs[System.IO.Directory#4](~/add/codesnippet/csharp/m-system.io.directory.ge_5_1.cs)]\n [!code-vb[System.IO.Directory#4](~/add/codesnippet/visualbasic/m-system.io.directory.ge_5_1.vb)]\n [!code-cpp[System.IO.Directory#4](~/add/codesnippet/cpp/m-system.io.directory.ge_5_1.cpp)]"
  syntax:
    content: public static System.IO.DirectoryInfo GetParent (string path);
    parameters:
    - id: path
      type: System.String
      description: "为其检索父目录的路径。"
    return:
      type: System.IO.DirectoryInfo
      description: "父目录，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果<code> path </code>是根目录，包括 UNC 服务器或共享名的根。"
  overload: System.IO.Directory.GetParent*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "指定的目录<code> path </code>是只读的。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>是零长度字符串，仅包含空格，或包含一个或多个无效字符。 你可以查询无效字符替换<xref:System.IO.Path.GetInvalidPathChars*>方法。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "找不到指定的路径。"
  platform:
  - net462
- uid: System.IO.Directory.Move(System.String,System.String)
  id: Move(System.String,System.String)
  parent: System.IO.Directory
  langs:
  - csharp
  name: Move(String,String)
  nameWithType: Directory.Move(String,String)
  fullName: System.IO.Directory.Move(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "将文件或目录并将其内容移动到新位置。"
  remarks: "This method creates a new directory with the name specified by `destDirName` and moves the contents of `sourceDirName` to the newly created destination directory. If you try to move a directory to a directory that already exists, an <xref:System.IO.IOException> will occur. For example, an exception will occur if you try to move c:\\mydir to c:\\public, and c:\\public already exists. Alternatively, you could specify \"c:\\\\\\public\\\\\\mydir\" as the `destDirName` parameter, provided that \"mydir\" does not exist under \"c:\\\\\\public\", or specify a new directory name such as \"c:\\\\\\newdir\".  \n  \n The `sourceDirName` and `destDirName` arguments are permitted to specify relative or absolute path information. Relative path information is interpreted as relative to the current working directory. To obtain the current working directory, see <xref:System.IO.Directory.GetCurrentDirectory%2A>.  \n  \n Trailing spaces are removed from the end of the path parameters before moving the directory.  \n  \n For a list of common I/O tasks, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example demonstrates how to move a directory and all its files to a new directory. The original directory no longer exists after it has been moved.  \n  \n [!code-vb[System.IO.Directory#14](~/add/codesnippet/visualbasic/m-system.io.directory.mo_1.vb)]\n [!code-cs[System.IO.Directory#14](~/add/codesnippet/csharp/m-system.io.directory.mo_1.cs)]"
  syntax:
    content: public static void Move (string sourceDirName, string destDirName);
    parameters:
    - id: sourceDirName
      type: System.String
      description: "文件或要移动目录的路径。"
    - id: destDirName
      type: System.String
      description: "新位置的路径`sourceDirName`。 如果`sourceDirName`是文件，然后`destDirName`还必须是一个文件名。"
  overload: System.IO.Directory.Move*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "尝试将目录移动到不同的卷。       - <code> destDirName </code>已存在。       -或- <code> sourceDirName </code>和<code> destDirName </code>参数引用同一个文件或目录。       -或者-另一个进程正在使用的目录或其中一个文件。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sourceDirName</code>或<code>destDirName</code>是零长度字符串，仅包含空格，或包含一个或多个无效字符。 你可以查询无效字符替换<xref:System.IO.Path.GetInvalidPathChars*>方法。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>sourceDirName</code>or <code>destDirName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路径<code> sourceDirName </code>无效 （例如，它位于未映射的驱动器上）。"
  platform:
  - net462
- uid: System.IO.Directory.SetAccessControl(System.String,System.Security.AccessControl.DirectorySecurity)
  id: SetAccessControl(System.String,System.Security.AccessControl.DirectorySecurity)
  parent: System.IO.Directory
  langs:
  - csharp
  name: SetAccessControl(String,DirectorySecurity)
  nameWithType: Directory.SetAccessControl(String,DirectorySecurity)
  fullName: System.IO.Directory.SetAccessControl(String,DirectorySecurity)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "将访问控制列表 (ACL) 项所描述应用<xref href=&quot;System.Security.AccessControl.DirectorySecurity&quot;></xref>到指定的目录对象。"
  remarks: "SetAccessControl 方法适用于表示非继承的 ACL 列表的文件的访问控制列表 (ACL) 项。      1> [!CAUTION]&1;> 为 ACL 指定`directorySecurity`参数替换现有的目录 ACL。 若要添加的新用户的权限，请使用<xref:System.IO.Directory.GetAccessControl%2A>方法来获取现有的 ACL 并修改它。</xref:System.IO.Directory.GetAccessControl%2A>       ACL 描述个人和/或组具有或没有执行到给定的文件或目录上的特定操作的权限。 有关详细信息，请参阅[如何︰ 添加或移除访问控制列表项](~/add/includes/ajax-current-ext-md.md)。       SetAccessControl 方法仍然仅存在<xref:System.Security.AccessControl.DirectorySecurity>对象创建后已修改的对象。</xref:System.Security.AccessControl.DirectorySecurity>  如果<xref:System.Security.AccessControl.DirectorySecurity>尚未修改对象，它不会保留到文件。</xref:System.Security.AccessControl.DirectorySecurity>  因此，不能检索<xref:System.Security.AccessControl.DirectorySecurity>对象从一个文件，并重新对同一对象应用到另一个文件。</xref:System.Security.AccessControl.DirectorySecurity>       若要将 ACL 信息从一个文件复制到另一个︰ 1。  使用<xref:System.IO.Directory.GetAccessControl%2A>方法来检索<xref:System.Security.AccessControl.DirectorySecurity>源文件中的对象。</xref:System.Security.AccessControl.DirectorySecurity> </xref:System.IO.Directory.GetAccessControl%2A>      2.  创建一个新<xref:System.Security.AccessControl.DirectorySecurity>目标文件的对象。</xref:System.Security.AccessControl.DirectorySecurity>      3.  使用<xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A>或<xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A>方法的源<xref:System.Security.AccessControl.DirectorySecurity>要检索 ACL 信息对象。</xref:System.Security.AccessControl.DirectorySecurity> </xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> </xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A>      4.  使用<xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A>或<xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A>方法的信息复制到目标的步骤 3 中检索<xref:System.Security.AccessControl.DirectorySecurity>对象。</xref:System.Security.AccessControl.DirectorySecurity> </xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> </xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A>      5.  设置目标<xref:System.Security.AccessControl.DirectorySecurity>目标文件使用 SetAccessControl 方法的对象。</xref:System.Security.AccessControl.DirectorySecurity>       在 NTFS 环境中，<xref:System.Security.AccessControl.FileSystemRights>和<xref:System.Security.AccessControl.FileSystemRights>如果用户具有向用户授予<xref:System.Security.AccessControl.FileSystemRights>上的父文件夹的权限。</xref:System.Security.AccessControl.FileSystemRights> </xref:System.Security.AccessControl.FileSystemRights> </xref:System.Security.AccessControl.FileSystemRights> 若要拒绝<xref:System.Security.AccessControl.FileSystemRights>和<xref:System.Security.AccessControl.FileSystemRights>，拒绝<xref:System.Security.AccessControl.FileSystemRights>上的父目录。</xref:System.Security.AccessControl.FileSystemRights> </xref:System.Security.AccessControl.FileSystemRights> </xref:System.Security.AccessControl.FileSystemRights>"
  example:
  - "The following example uses the <xref:System.IO.Directory.GetAccessControl%2A> and the SetAccessControl methods to add an access control list (ACL) entry and then remove an ACL entry from a directory.  You must supply a valid user or group account to run this example.  \n  \n [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/add/codesnippet/cpp/57b88d80-60eb-4344-b644-_1.cpp)]\n [!code-cs[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/add/codesnippet/csharp/57b88d80-60eb-4344-b644-_1.cs)]\n [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/add/codesnippet/visualbasic/57b88d80-60eb-4344-b644-_1.vb)]"
  syntax:
    content: public static void SetAccessControl (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);
    parameters:
    - id: path
      type: System.String
      description: "若要添加或移除访问控制列表 (ACL) 项从一个目录。"
    - id: directorySecurity
      type: System.Security.AccessControl.DirectorySecurity
      description: "A <xref href=&quot;System.Security.AccessControl.DirectorySecurity&quot;> </xref>对象，描述要应用于所描述的目录的 ACL 项`path`参数。"
  overload: System.IO.Directory.SetAccessControl*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>directorySecurity</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "找不到目录。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> path </code>无效。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "当前进程不具有对指定的目录的访问<code> path </code>。       -或者-当前进程不具有足够的特权来设置的 ACL 项。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "当前操作系统不是 Windows 2000 或更高版本。"
  platform:
  - net462
- uid: System.IO.Directory.SetCreationTime(System.String,System.DateTime)
  id: SetCreationTime(System.String,System.DateTime)
  parent: System.IO.Directory
  langs:
  - csharp
  name: SetCreationTime(String,DateTime)
  nameWithType: Directory.SetCreationTime(String,DateTime)
  fullName: System.IO.Directory.SetCreationTime(String,DateTime)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "设置的创建日期和时间的指定的文件或目录。"
  remarks: "`path`参数允许指定相对或绝对路径信息。 相对路径信息被解释为相对于当前工作目录。 若要获取当前工作目录，请参阅<xref:System.IO.Directory.GetCurrentDirectory%2A>。</xref:System.IO.Directory.GetCurrentDirectory%2A>       `path`参数不区分大小写。"
  example:
  - "The following example illustrates the differences in output when using Coordinated Universal Time (UTC) output.  \n  \n [!code-cs[System.IO.UTCExample#1](~/add/codesnippet/csharp/m-system.io.directory.se_4_1.cs)]\n [!code-cpp[System.IO.UTCExample#1](~/add/codesnippet/cpp/m-system.io.directory.se_4_1.cpp)]\n [!code-vb[System.IO.UTCExample#1](~/add/codesnippet/visualbasic/m-system.io.directory.se_4_1.vb)]"
  syntax:
    content: public static void SetCreationTime (string path, DateTime creationTime);
    parameters:
    - id: path
      type: System.String
      description: "文件或为其设置的创建日期和时间信息的目录中。"
    - id: creationTime
      type: System.DateTime
      description: "日期和时间的文件或上次写入目录。 该值用本地时间表示。"
  overload: System.IO.Directory.SetCreationTime*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到指定的路径。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>是零长度字符串，仅包含空格，或包含一个或多个无效字符。 你可以查询无效字符替换<xref:System.IO.Path.GetInvalidPathChars*>方法。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>creationTime</code>指定的值超出了允许此操作的日期或时间范围。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "当前操作系统不是 Windows NT 或更高版本。"
  platform:
  - net462
- uid: System.IO.Directory.SetCreationTimeUtc(System.String,System.DateTime)
  id: SetCreationTimeUtc(System.String,System.DateTime)
  parent: System.IO.Directory
  langs:
  - csharp
  name: SetCreationTimeUtc(String,DateTime)
  nameWithType: Directory.SetCreationTimeUtc(String,DateTime)
  fullName: System.IO.Directory.SetCreationTimeUtc(String,DateTime)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "设置的创建日期和时间，格式为协调世界时 (UTC)，为指定的文件或目录。"
  remarks: "`path`参数允许指定相对或绝对路径信息。 相对路径信息被解释为相对于当前工作目录。 若要获取当前工作目录，请参阅<xref:System.IO.Directory.GetCurrentDirectory%2A>。</xref:System.IO.Directory.GetCurrentDirectory%2A>       `path`参数不区分大小写。       通用 I/O 任务的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public static void SetCreationTimeUtc (string path, DateTime creationTimeUtc);
    parameters:
    - id: path
      type: System.String
      description: "文件或为其设置的创建日期和时间信息的目录中。"
    - id: creationTimeUtc
      type: System.DateTime
      description: "日期和时间目录或文件的创建。 该值用本地时间表示。"
  overload: System.IO.Directory.SetCreationTimeUtc*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到指定的路径。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>是零长度字符串，仅包含空格，或包含一个或多个无效字符。 你可以查询无效字符替换<xref:System.IO.Path.GetInvalidPathChars*>方法。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>creationTime</code>指定的值超出了允许此操作的日期或时间范围。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "当前操作系统不是 Windows NT 或更高版本。"
  platform:
  - net462
- uid: System.IO.Directory.SetCurrentDirectory(System.String)
  id: SetCurrentDirectory(System.String)
  parent: System.IO.Directory
  langs:
  - csharp
  name: SetCurrentDirectory(String)
  nameWithType: Directory.SetCurrentDirectory(String)
  fullName: System.IO.Directory.SetCurrentDirectory(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "将应用程序的当前工作目录设置为指定的目录。"
  remarks: "当应用程序终止时，工作目录还原到其原始位置 （启动该进程的目录）。       `path`参数允许指定相对或绝对路径信息。 相对路径信息被解释为相对于当前工作目录。 若要获取当前工作目录，请参阅<xref:System.IO.Directory.GetCurrentDirectory%2A>。</xref:System.IO.Directory.GetCurrentDirectory%2A>       从的末尾删除尾随空格`path`之前设置目录的参数。       `path`参数不区分大小写。       如果要将目录设置为使用可移动媒体驱动器转换例如，为 (A︰ 的软盘驱动器) 或&quot;e:&quot;为 CD-ROM 驱动器，则可以确定驱动器是否已准备就绪使用<xref:System.IO.DriveInfo.IsReady%2A>属性。</xref:System.IO.DriveInfo.IsReady%2A>"
  example:
  - "The following example illustrates how to set the current directory and display the directory root.  \n  \n [!code-cpp[System.IO.DirectoryRoot#1](~/add/codesnippet/cpp/m-system.io.directory.se_2_1.cpp)]\n [!code-cs[System.IO.DirectoryRoot#1](~/add/codesnippet/csharp/m-system.io.directory.se_2_1.cs)]\n [!code-vb[System.IO.DirectoryRoot#1](~/add/codesnippet/visualbasic/m-system.io.directory.se_2_1.vb)]"
  syntax:
    content: public static void SetCurrentDirectory (string path);
    parameters:
    - id: path
      type: System.String
      description: "当前工作目录设置为其中的路径。"
  overload: System.IO.Directory.SetCurrentDirectory*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "发生 I/O 错误。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>是零长度字符串，仅包含空格，或包含一个或多个无效字符。 你可以查询无效字符替换<xref:System.IO.Path.GetInvalidPathChars*>方法。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限访问非托管的代码。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到指定的路径。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "找不到指定的目录。"
  platform:
  - net462
- uid: System.IO.Directory.SetLastAccessTime(System.String,System.DateTime)
  id: SetLastAccessTime(System.String,System.DateTime)
  parent: System.IO.Directory
  langs:
  - csharp
  name: SetLastAccessTime(String,DateTime)
  nameWithType: Directory.SetLastAccessTime(String,DateTime)
  fullName: System.IO.Directory.SetLastAccessTime(String,DateTime)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "设置日期和时间指定上次访问文件或目录。"
  remarks: "`path`参数允许指定相对或绝对路径信息。 相对路径信息被解释为相对于当前工作目录。 若要获取当前工作目录，请参阅<xref:System.IO.Directory.GetCurrentDirectory%2A>。</xref:System.IO.Directory.GetCurrentDirectory%2A>       `path`参数不区分大小写。       通用 I/O 任务的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example demonstrates how to use `SetLastAccessTime`.  \n  \n [!code-cs[Dir_SetLastAccess#1](~/add/codesnippet/csharp/m-system.io.directory.se_1_1.cs)]\n [!code-cpp[Dir_SetLastAccess#1](~/add/codesnippet/cpp/m-system.io.directory.se_1_1.cpp)]\n [!code-vb[Dir_SetLastAccess#1](~/add/codesnippet/visualbasic/m-system.io.directory.se_1_1.vb)]"
  syntax:
    content: public static void SetLastAccessTime (string path, DateTime lastAccessTime);
    parameters:
    - id: path
      type: System.String
      description: "文件或为其设置其访问日期和时间信息的目录中。"
    - id: lastAccessTime
      type: System.DateTime
      description: "包含要为的访问日期和时间设置的值的对象`path`。 该值用本地时间表示。"
  overload: System.IO.Directory.SetLastAccessTime*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到指定的路径。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>是零长度字符串，仅包含空格，或包含一个或多个无效字符。 你可以查询无效字符替换<xref:System.IO.Path.GetInvalidPathChars*>方法。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "当前操作系统不是 Windows NT 或更高版本。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>lastAccessTime</code>指定的值超出了允许此操作的日期或时间范围。"
  platform:
  - net462
- uid: System.IO.Directory.SetLastAccessTimeUtc(System.String,System.DateTime)
  id: SetLastAccessTimeUtc(System.String,System.DateTime)
  parent: System.IO.Directory
  langs:
  - csharp
  name: SetLastAccessTimeUtc(String,DateTime)
  nameWithType: Directory.SetLastAccessTimeUtc(String,DateTime)
  fullName: System.IO.Directory.SetLastAccessTimeUtc(String,DateTime)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "设置上次访问指定的文件或目录的日期和时间，其格式为协调世界时 (UTC)。"
  remarks: "`path`参数允许指定相对或绝对路径信息。 相对路径信息被解释为相对于当前工作目录。 若要获取当前工作目录，请参阅<xref:System.IO.Directory.GetCurrentDirectory%2A>。</xref:System.IO.Directory.GetCurrentDirectory%2A>       `path`参数不区分大小写。       通用 I/O 任务的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example illustrates the differences in output when using Coordinated Universal Time (UTC) output.  \n  \n [!code-cs[System.IO.UTCExample#1](~/add/codesnippet/csharp/m-system.io.directory.se_0_1.cs)]\n [!code-cpp[System.IO.UTCExample#1](~/add/codesnippet/cpp/m-system.io.directory.se_0_1.cpp)]\n [!code-vb[System.IO.UTCExample#1](~/add/codesnippet/visualbasic/m-system.io.directory.se_0_1.vb)]"
  syntax:
    content: public static void SetLastAccessTimeUtc (string path, DateTime lastAccessTimeUtc);
    parameters:
    - id: path
      type: System.String
      description: "文件或为其设置其访问日期和时间信息的目录中。"
    - id: lastAccessTimeUtc
      type: System.DateTime
      description: "包含要为的访问日期和时间设置的值的对象`path`。 该值用 UTC 时间表示。"
  overload: System.IO.Directory.SetLastAccessTimeUtc*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到指定的路径。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>是零长度字符串，仅包含空格，或包含一个或多个无效字符。 你可以查询无效字符替换<xref:System.IO.Path.GetInvalidPathChars*>方法。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "当前操作系统不是 Windows NT 或更高版本。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>lastAccessTimeUtc</code>指定的值超出了允许此操作的日期或时间范围。"
  platform:
  - net462
- uid: System.IO.Directory.SetLastWriteTime(System.String,System.DateTime)
  id: SetLastWriteTime(System.String,System.DateTime)
  parent: System.IO.Directory
  langs:
  - csharp
  name: SetLastWriteTime(String,DateTime)
  nameWithType: Directory.SetLastWriteTime(String,DateTime)
  fullName: System.IO.Directory.SetLastWriteTime(String,DateTime)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "设置日期和上次写入某个目录的时间。"
  remarks: "`path`参数允许指定相对或绝对路径信息。 相对路径信息被解释为相对于当前工作目录。 若要获取当前工作目录，请参阅<xref:System.IO.Directory.GetCurrentDirectory%2A>。</xref:System.IO.Directory.GetCurrentDirectory%2A>       `path`参数不区分大小写。       通用 I/O 任务的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example demonstrates how to use `SetLastWriteTime`.  \n  \n [!code-cpp[Dir_SetLastWrite#1](~/add/codesnippet/cpp/m-system.io.directory.se_3_1.cpp)]\n [!code-cs[Dir_SetLastWrite#1](~/add/codesnippet/csharp/m-system.io.directory.se_3_1.cs)]\n [!code-vb[Dir_SetLastWrite#1](~/add/codesnippet/visualbasic/m-system.io.directory.se_3_1.vb)]"
  syntax:
    content: public static void SetLastWriteTime (string path, DateTime lastWriteTime);
    parameters:
    - id: path
      type: System.String
      description: "目录的路径。"
    - id: lastWriteTime
      type: System.DateTime
      description: "上次写入目录的日期和时间。 该值用本地时间表示。"
  overload: System.IO.Directory.SetLastWriteTime*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到指定的路径。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>是零长度字符串，仅包含空格，或包含一个或多个无效字符。 你可以查询无效字符替换<xref:System.IO.Path.GetInvalidPathChars*>方法。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "当前操作系统不是 Windows NT 或更高版本。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>lastWriteTime</code>指定的值超出了允许此操作的日期或时间范围。"
  platform:
  - net462
- uid: System.IO.Directory.SetLastWriteTimeUtc(System.String,System.DateTime)
  id: SetLastWriteTimeUtc(System.String,System.DateTime)
  parent: System.IO.Directory
  langs:
  - csharp
  name: SetLastWriteTimeUtc(String,DateTime)
  nameWithType: Directory.SetLastWriteTimeUtc(String,DateTime)
  fullName: System.IO.Directory.SetLastWriteTimeUtc(String,DateTime)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "设置的日期和时间，格式为协调世界时 (UTC)，上次写入目录。"
  remarks: "`path`参数允许指定相对或绝对路径信息。 相对路径信息被解释为相对于当前工作目录。 若要获取当前工作目录，请参阅<xref:System.IO.Directory.GetCurrentDirectory%2A>。</xref:System.IO.Directory.GetCurrentDirectory%2A>       `path`参数不区分大小写。       通用 I/O 任务的列表，请参阅[通用 I/O 任务](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example illustrates the differences in output when using Coordinated Universal Time (UTC) output.  \n  \n [!code-cs[System.IO.UTCExample#1](~/add/codesnippet/csharp/m-system.io.directory.se_5_1.cs)]\n [!code-cpp[System.IO.UTCExample#1](~/add/codesnippet/cpp/m-system.io.directory.se_5_1.cpp)]\n [!code-vb[System.IO.UTCExample#1](~/add/codesnippet/visualbasic/m-system.io.directory.se_5_1.vb)]"
  syntax:
    content: public static void SetLastWriteTimeUtc (string path, DateTime lastWriteTimeUtc);
    parameters:
    - id: path
      type: System.String
      description: "目录的路径。"
    - id: lastWriteTimeUtc
      type: System.DateTime
      description: "上次写入目录的日期和时间。 该值用 UTC 时间表示。"
  overload: System.IO.Directory.SetLastWriteTimeUtc*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到指定的路径。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>是零长度字符串，仅包含空格，或包含一个或多个无效字符。 你可以查询无效字符替换<xref:System.IO.Path.GetInvalidPathChars*>方法。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "当前操作系统不是 Windows NT 或更高版本。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>lastWriteTimeUtc</code>指定的值超出了允许此操作的日期或时间范围。"
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.IO.PathTooLongException
  isExternal: true
  name: System.IO.PathTooLongException
- uid: System.IO.DirectoryNotFoundException
  isExternal: true
  name: System.IO.DirectoryNotFoundException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.Directory.CreateDirectory(System.String)
  parent: System.IO.Directory
  isExternal: false
  name: CreateDirectory(String)
  nameWithType: Directory.CreateDirectory(String)
  fullName: System.IO.Directory.CreateDirectory(String)
- uid: System.IO.DirectoryInfo
  parent: System.IO
  isExternal: false
  name: DirectoryInfo
  nameWithType: DirectoryInfo
  fullName: System.IO.DirectoryInfo
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.Directory.CreateDirectory(System.String,System.Security.AccessControl.DirectorySecurity)
  parent: System.IO.Directory
  isExternal: false
  name: CreateDirectory(String,DirectorySecurity)
  nameWithType: Directory.CreateDirectory(String,DirectorySecurity)
  fullName: System.IO.Directory.CreateDirectory(String,DirectorySecurity)
- uid: System.Security.AccessControl.DirectorySecurity
  parent: System.Security.AccessControl
  isExternal: false
  name: DirectorySecurity
  nameWithType: DirectorySecurity
  fullName: System.Security.AccessControl.DirectorySecurity
- uid: System.IO.Directory.Delete(System.String)
  parent: System.IO.Directory
  isExternal: false
  name: Delete(String)
  nameWithType: Directory.Delete(String)
  fullName: System.IO.Directory.Delete(String)
- uid: System.IO.Directory.Delete(System.String,System.Boolean)
  parent: System.IO.Directory
  isExternal: false
  name: Delete(String,Boolean)
  nameWithType: Directory.Delete(String,Boolean)
  fullName: System.IO.Directory.Delete(String,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.Directory.EnumerateDirectories(System.String)
  parent: System.IO.Directory
  isExternal: false
  name: EnumerateDirectories(String)
  nameWithType: Directory.EnumerateDirectories(String)
  fullName: System.IO.Directory.EnumerateDirectories(String)
- uid: System.Collections.Generic.IEnumerable{System.String}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<String>
  nameWithType: IEnumerable<String>
  fullName: System.Collections.Generic.IEnumerable<System.String>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.String>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Directory.EnumerateDirectories(System.String,System.String)
  parent: System.IO.Directory
  isExternal: false
  name: EnumerateDirectories(String,String)
  nameWithType: Directory.EnumerateDirectories(String,String)
  fullName: System.IO.Directory.EnumerateDirectories(String,String)
- uid: System.IO.Directory.EnumerateDirectories(System.String,System.String,System.IO.SearchOption)
  parent: System.IO.Directory
  isExternal: false
  name: EnumerateDirectories(String,String,SearchOption)
  nameWithType: Directory.EnumerateDirectories(String,String,SearchOption)
  fullName: System.IO.Directory.EnumerateDirectories(String,String,SearchOption)
- uid: System.IO.SearchOption
  parent: System.IO
  isExternal: false
  name: SearchOption
  nameWithType: SearchOption
  fullName: System.IO.SearchOption
- uid: System.IO.Directory.EnumerateFiles(System.String)
  parent: System.IO.Directory
  isExternal: false
  name: EnumerateFiles(String)
  nameWithType: Directory.EnumerateFiles(String)
  fullName: System.IO.Directory.EnumerateFiles(String)
- uid: System.IO.Directory.EnumerateFiles(System.String,System.String)
  parent: System.IO.Directory
  isExternal: false
  name: EnumerateFiles(String,String)
  nameWithType: Directory.EnumerateFiles(String,String)
  fullName: System.IO.Directory.EnumerateFiles(String,String)
- uid: System.IO.Directory.EnumerateFiles(System.String,System.String,System.IO.SearchOption)
  parent: System.IO.Directory
  isExternal: false
  name: EnumerateFiles(String,String,SearchOption)
  nameWithType: Directory.EnumerateFiles(String,String,SearchOption)
  fullName: System.IO.Directory.EnumerateFiles(String,String,SearchOption)
- uid: System.IO.Directory.EnumerateFileSystemEntries(System.String)
  parent: System.IO.Directory
  isExternal: false
  name: EnumerateFileSystemEntries(String)
  nameWithType: Directory.EnumerateFileSystemEntries(String)
  fullName: System.IO.Directory.EnumerateFileSystemEntries(String)
- uid: System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String)
  parent: System.IO.Directory
  isExternal: false
  name: EnumerateFileSystemEntries(String,String)
  nameWithType: Directory.EnumerateFileSystemEntries(String,String)
  fullName: System.IO.Directory.EnumerateFileSystemEntries(String,String)
- uid: System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String,System.IO.SearchOption)
  parent: System.IO.Directory
  isExternal: false
  name: EnumerateFileSystemEntries(String,String,SearchOption)
  nameWithType: Directory.EnumerateFileSystemEntries(String,String,SearchOption)
  fullName: System.IO.Directory.EnumerateFileSystemEntries(String,String,SearchOption)
- uid: System.IO.Directory.Exists(System.String)
  parent: System.IO.Directory
  isExternal: false
  name: Exists(String)
  nameWithType: Directory.Exists(String)
  fullName: System.IO.Directory.Exists(String)
- uid: System.IO.Directory.GetAccessControl(System.String)
  parent: System.IO.Directory
  isExternal: false
  name: GetAccessControl(String)
  nameWithType: Directory.GetAccessControl(String)
  fullName: System.IO.Directory.GetAccessControl(String)
- uid: System.IO.Directory.GetAccessControl(System.String,System.Security.AccessControl.AccessControlSections)
  parent: System.IO.Directory
  isExternal: false
  name: GetAccessControl(String,AccessControlSections)
  nameWithType: Directory.GetAccessControl(String,AccessControlSections)
  fullName: System.IO.Directory.GetAccessControl(String,AccessControlSections)
- uid: System.Security.AccessControl.AccessControlSections
  parent: System.Security.AccessControl
  isExternal: false
  name: AccessControlSections
  nameWithType: AccessControlSections
  fullName: System.Security.AccessControl.AccessControlSections
- uid: System.IO.Directory.GetCreationTime(System.String)
  parent: System.IO.Directory
  isExternal: false
  name: GetCreationTime(String)
  nameWithType: Directory.GetCreationTime(String)
  fullName: System.IO.Directory.GetCreationTime(String)
- uid: System.DateTime
  parent: System
  isExternal: true
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: System.IO.Directory.GetCreationTimeUtc(System.String)
  parent: System.IO.Directory
  isExternal: false
  name: GetCreationTimeUtc(String)
  nameWithType: Directory.GetCreationTimeUtc(String)
  fullName: System.IO.Directory.GetCreationTimeUtc(String)
- uid: System.IO.Directory.GetCurrentDirectory
  parent: System.IO.Directory
  isExternal: false
  name: GetCurrentDirectory()
  nameWithType: Directory.GetCurrentDirectory()
  fullName: System.IO.Directory.GetCurrentDirectory()
- uid: System.IO.Directory.GetDirectories(System.String)
  parent: System.IO.Directory
  isExternal: false
  name: GetDirectories(String)
  nameWithType: Directory.GetDirectories(String)
  fullName: System.IO.Directory.GetDirectories(String)
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.IO.Directory.GetDirectories(System.String,System.String)
  parent: System.IO.Directory
  isExternal: false
  name: GetDirectories(String,String)
  nameWithType: Directory.GetDirectories(String,String)
  fullName: System.IO.Directory.GetDirectories(String,String)
- uid: System.IO.Directory.GetDirectories(System.String,System.String,System.IO.SearchOption)
  parent: System.IO.Directory
  isExternal: false
  name: GetDirectories(String,String,SearchOption)
  nameWithType: Directory.GetDirectories(String,String,SearchOption)
  fullName: System.IO.Directory.GetDirectories(String,String,SearchOption)
- uid: System.IO.Directory.GetDirectoryRoot(System.String)
  parent: System.IO.Directory
  isExternal: false
  name: GetDirectoryRoot(String)
  nameWithType: Directory.GetDirectoryRoot(String)
  fullName: System.IO.Directory.GetDirectoryRoot(String)
- uid: System.IO.Directory.GetFiles(System.String)
  parent: System.IO.Directory
  isExternal: false
  name: GetFiles(String)
  nameWithType: Directory.GetFiles(String)
  fullName: System.IO.Directory.GetFiles(String)
- uid: System.IO.Directory.GetFiles(System.String,System.String)
  parent: System.IO.Directory
  isExternal: false
  name: GetFiles(String,String)
  nameWithType: Directory.GetFiles(String,String)
  fullName: System.IO.Directory.GetFiles(String,String)
- uid: System.IO.Directory.GetFiles(System.String,System.String,System.IO.SearchOption)
  parent: System.IO.Directory
  isExternal: false
  name: GetFiles(String,String,SearchOption)
  nameWithType: Directory.GetFiles(String,String,SearchOption)
  fullName: System.IO.Directory.GetFiles(String,String,SearchOption)
- uid: System.IO.Directory.GetFileSystemEntries(System.String)
  parent: System.IO.Directory
  isExternal: false
  name: GetFileSystemEntries(String)
  nameWithType: Directory.GetFileSystemEntries(String)
  fullName: System.IO.Directory.GetFileSystemEntries(String)
- uid: System.IO.Directory.GetFileSystemEntries(System.String,System.String)
  parent: System.IO.Directory
  isExternal: false
  name: GetFileSystemEntries(String,String)
  nameWithType: Directory.GetFileSystemEntries(String,String)
  fullName: System.IO.Directory.GetFileSystemEntries(String,String)
- uid: System.IO.Directory.GetFileSystemEntries(System.String,System.String,System.IO.SearchOption)
  parent: System.IO.Directory
  isExternal: false
  name: GetFileSystemEntries(String,String,SearchOption)
  nameWithType: Directory.GetFileSystemEntries(String,String,SearchOption)
  fullName: System.IO.Directory.GetFileSystemEntries(String,String,SearchOption)
- uid: System.IO.Directory.GetLastAccessTime(System.String)
  parent: System.IO.Directory
  isExternal: false
  name: GetLastAccessTime(String)
  nameWithType: Directory.GetLastAccessTime(String)
  fullName: System.IO.Directory.GetLastAccessTime(String)
- uid: System.IO.Directory.GetLastAccessTimeUtc(System.String)
  parent: System.IO.Directory
  isExternal: false
  name: GetLastAccessTimeUtc(String)
  nameWithType: Directory.GetLastAccessTimeUtc(String)
  fullName: System.IO.Directory.GetLastAccessTimeUtc(String)
- uid: System.IO.Directory.GetLastWriteTime(System.String)
  parent: System.IO.Directory
  isExternal: false
  name: GetLastWriteTime(String)
  nameWithType: Directory.GetLastWriteTime(String)
  fullName: System.IO.Directory.GetLastWriteTime(String)
- uid: System.IO.Directory.GetLastWriteTimeUtc(System.String)
  parent: System.IO.Directory
  isExternal: false
  name: GetLastWriteTimeUtc(String)
  nameWithType: Directory.GetLastWriteTimeUtc(String)
  fullName: System.IO.Directory.GetLastWriteTimeUtc(String)
- uid: System.IO.Directory.GetLogicalDrives
  parent: System.IO.Directory
  isExternal: false
  name: GetLogicalDrives()
  nameWithType: Directory.GetLogicalDrives()
  fullName: System.IO.Directory.GetLogicalDrives()
- uid: System.IO.Directory.GetParent(System.String)
  parent: System.IO.Directory
  isExternal: false
  name: GetParent(String)
  nameWithType: Directory.GetParent(String)
  fullName: System.IO.Directory.GetParent(String)
- uid: System.IO.Directory.Move(System.String,System.String)
  parent: System.IO.Directory
  isExternal: false
  name: Move(String,String)
  nameWithType: Directory.Move(String,String)
  fullName: System.IO.Directory.Move(String,String)
- uid: System.IO.Directory.SetAccessControl(System.String,System.Security.AccessControl.DirectorySecurity)
  parent: System.IO.Directory
  isExternal: false
  name: SetAccessControl(String,DirectorySecurity)
  nameWithType: Directory.SetAccessControl(String,DirectorySecurity)
  fullName: System.IO.Directory.SetAccessControl(String,DirectorySecurity)
- uid: System.IO.Directory.SetCreationTime(System.String,System.DateTime)
  parent: System.IO.Directory
  isExternal: false
  name: SetCreationTime(String,DateTime)
  nameWithType: Directory.SetCreationTime(String,DateTime)
  fullName: System.IO.Directory.SetCreationTime(String,DateTime)
- uid: System.IO.Directory.SetCreationTimeUtc(System.String,System.DateTime)
  parent: System.IO.Directory
  isExternal: false
  name: SetCreationTimeUtc(String,DateTime)
  nameWithType: Directory.SetCreationTimeUtc(String,DateTime)
  fullName: System.IO.Directory.SetCreationTimeUtc(String,DateTime)
- uid: System.IO.Directory.SetCurrentDirectory(System.String)
  parent: System.IO.Directory
  isExternal: false
  name: SetCurrentDirectory(String)
  nameWithType: Directory.SetCurrentDirectory(String)
  fullName: System.IO.Directory.SetCurrentDirectory(String)
- uid: System.IO.Directory.SetLastAccessTime(System.String,System.DateTime)
  parent: System.IO.Directory
  isExternal: false
  name: SetLastAccessTime(String,DateTime)
  nameWithType: Directory.SetLastAccessTime(String,DateTime)
  fullName: System.IO.Directory.SetLastAccessTime(String,DateTime)
- uid: System.IO.Directory.SetLastAccessTimeUtc(System.String,System.DateTime)
  parent: System.IO.Directory
  isExternal: false
  name: SetLastAccessTimeUtc(String,DateTime)
  nameWithType: Directory.SetLastAccessTimeUtc(String,DateTime)
  fullName: System.IO.Directory.SetLastAccessTimeUtc(String,DateTime)
- uid: System.IO.Directory.SetLastWriteTime(System.String,System.DateTime)
  parent: System.IO.Directory
  isExternal: false
  name: SetLastWriteTime(String,DateTime)
  nameWithType: Directory.SetLastWriteTime(String,DateTime)
  fullName: System.IO.Directory.SetLastWriteTime(String,DateTime)
- uid: System.IO.Directory.SetLastWriteTimeUtc(System.String,System.DateTime)
  parent: System.IO.Directory
  isExternal: false
  name: SetLastWriteTimeUtc(String,DateTime)
  nameWithType: Directory.SetLastWriteTimeUtc(String,DateTime)
  fullName: System.IO.Directory.SetLastWriteTimeUtc(String,DateTime)
- uid: System.IO.Directory.CreateDirectory*
  parent: System.IO.Directory
  isExternal: false
  name: CreateDirectory
  nameWithType: Directory.CreateDirectory
- uid: System.IO.Directory.Delete*
  parent: System.IO.Directory
  isExternal: false
  name: Delete
  nameWithType: Directory.Delete
- uid: System.IO.Directory.EnumerateDirectories*
  parent: System.IO.Directory
  isExternal: false
  name: EnumerateDirectories
  nameWithType: Directory.EnumerateDirectories
- uid: System.IO.Directory.EnumerateFiles*
  parent: System.IO.Directory
  isExternal: false
  name: EnumerateFiles
  nameWithType: Directory.EnumerateFiles
- uid: System.IO.Directory.EnumerateFileSystemEntries*
  parent: System.IO.Directory
  isExternal: false
  name: EnumerateFileSystemEntries
  nameWithType: Directory.EnumerateFileSystemEntries
- uid: System.IO.Directory.Exists*
  parent: System.IO.Directory
  isExternal: false
  name: Exists
  nameWithType: Directory.Exists
- uid: System.IO.Directory.GetAccessControl*
  parent: System.IO.Directory
  isExternal: false
  name: GetAccessControl
  nameWithType: Directory.GetAccessControl
- uid: System.IO.Directory.GetCreationTime*
  parent: System.IO.Directory
  isExternal: false
  name: GetCreationTime
  nameWithType: Directory.GetCreationTime
- uid: System.IO.Directory.GetCreationTimeUtc*
  parent: System.IO.Directory
  isExternal: false
  name: GetCreationTimeUtc
  nameWithType: Directory.GetCreationTimeUtc
- uid: System.IO.Directory.GetCurrentDirectory*
  parent: System.IO.Directory
  isExternal: false
  name: GetCurrentDirectory
  nameWithType: Directory.GetCurrentDirectory
- uid: System.IO.Directory.GetDirectories*
  parent: System.IO.Directory
  isExternal: false
  name: GetDirectories
  nameWithType: Directory.GetDirectories
- uid: System.IO.Directory.GetDirectoryRoot*
  parent: System.IO.Directory
  isExternal: false
  name: GetDirectoryRoot
  nameWithType: Directory.GetDirectoryRoot
- uid: System.IO.Directory.GetFiles*
  parent: System.IO.Directory
  isExternal: false
  name: GetFiles
  nameWithType: Directory.GetFiles
- uid: System.IO.Directory.GetFileSystemEntries*
  parent: System.IO.Directory
  isExternal: false
  name: GetFileSystemEntries
  nameWithType: Directory.GetFileSystemEntries
- uid: System.IO.Directory.GetLastAccessTime*
  parent: System.IO.Directory
  isExternal: false
  name: GetLastAccessTime
  nameWithType: Directory.GetLastAccessTime
- uid: System.IO.Directory.GetLastAccessTimeUtc*
  parent: System.IO.Directory
  isExternal: false
  name: GetLastAccessTimeUtc
  nameWithType: Directory.GetLastAccessTimeUtc
- uid: System.IO.Directory.GetLastWriteTime*
  parent: System.IO.Directory
  isExternal: false
  name: GetLastWriteTime
  nameWithType: Directory.GetLastWriteTime
- uid: System.IO.Directory.GetLastWriteTimeUtc*
  parent: System.IO.Directory
  isExternal: false
  name: GetLastWriteTimeUtc
  nameWithType: Directory.GetLastWriteTimeUtc
- uid: System.IO.Directory.GetLogicalDrives*
  parent: System.IO.Directory
  isExternal: false
  name: GetLogicalDrives
  nameWithType: Directory.GetLogicalDrives
- uid: System.IO.Directory.GetParent*
  parent: System.IO.Directory
  isExternal: false
  name: GetParent
  nameWithType: Directory.GetParent
- uid: System.IO.Directory.Move*
  parent: System.IO.Directory
  isExternal: false
  name: Move
  nameWithType: Directory.Move
- uid: System.IO.Directory.SetAccessControl*
  parent: System.IO.Directory
  isExternal: false
  name: SetAccessControl
  nameWithType: Directory.SetAccessControl
- uid: System.IO.Directory.SetCreationTime*
  parent: System.IO.Directory
  isExternal: false
  name: SetCreationTime
  nameWithType: Directory.SetCreationTime
- uid: System.IO.Directory.SetCreationTimeUtc*
  parent: System.IO.Directory
  isExternal: false
  name: SetCreationTimeUtc
  nameWithType: Directory.SetCreationTimeUtc
- uid: System.IO.Directory.SetCurrentDirectory*
  parent: System.IO.Directory
  isExternal: false
  name: SetCurrentDirectory
  nameWithType: Directory.SetCurrentDirectory
- uid: System.IO.Directory.SetLastAccessTime*
  parent: System.IO.Directory
  isExternal: false
  name: SetLastAccessTime
  nameWithType: Directory.SetLastAccessTime
- uid: System.IO.Directory.SetLastAccessTimeUtc*
  parent: System.IO.Directory
  isExternal: false
  name: SetLastAccessTimeUtc
  nameWithType: Directory.SetLastAccessTimeUtc
- uid: System.IO.Directory.SetLastWriteTime*
  parent: System.IO.Directory
  isExternal: false
  name: SetLastWriteTime
  nameWithType: Directory.SetLastWriteTime
- uid: System.IO.Directory.SetLastWriteTimeUtc*
  parent: System.IO.Directory
  isExternal: false
  name: SetLastWriteTimeUtc
  nameWithType: Directory.SetLastWriteTimeUtc
