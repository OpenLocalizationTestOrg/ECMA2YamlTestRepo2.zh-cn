### YamlMime:ManagedReference
items:
- uid: System.EnterpriseServices.Internal.Publish
  id: Publish
  children:
  - System.EnterpriseServices.Internal.Publish.#ctor
  - System.EnterpriseServices.Internal.Publish.CreateMailBox(System.String,System.String,System.String@,System.String@,System.String@,System.String@)
  - System.EnterpriseServices.Internal.Publish.CreateVirtualRoot(System.String,System.String,System.String@,System.String@,System.String@,System.String@)
  - System.EnterpriseServices.Internal.Publish.DeleteMailBox(System.String,System.String,System.String@)
  - System.EnterpriseServices.Internal.Publish.DeleteVirtualRoot(System.String,System.String,System.String@)
  - System.EnterpriseServices.Internal.Publish.GacInstall(System.String)
  - System.EnterpriseServices.Internal.Publish.GacRemove(System.String)
  - System.EnterpriseServices.Internal.Publish.GetAssemblyNameForCache(System.String,System.String@)
  - System.EnterpriseServices.Internal.Publish.GetClientPhysicalPath(System.Boolean)
  - System.EnterpriseServices.Internal.Publish.GetTypeNameFromProgId(System.String,System.String)
  - System.EnterpriseServices.Internal.Publish.ParseUrl(System.String,System.String@,System.String@)
  - System.EnterpriseServices.Internal.Publish.ProcessClientTlb(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)
  - System.EnterpriseServices.Internal.Publish.ProcessServerTlb(System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)
  - System.EnterpriseServices.Internal.Publish.RegisterAssembly(System.String)
  - System.EnterpriseServices.Internal.Publish.UnRegisterAssembly(System.String)
  langs:
  - csharp
  name: Publish
  nameWithType: Publish
  fullName: System.EnterpriseServices.Internal.Publish
  type: Class
  summary: "发布 SOAP 启用 COM + 应用程序的 COM 接口。"
  remarks: "发布由.NET Framework 内部使用。 不需要在代码中直接使用它。"
  syntax:
    content: >-
      [System.Runtime.InteropServices.Guid("d8013eef-730b-45e2-ba24-874b7242c425")]

      public class Publish : System.EnterpriseServices.Internal.IComSoapPublisher
  inheritance:
  - System.Object
  implements:
  - System.EnterpriseServices.Internal.IComSoapPublisher
  inheritedMembers: []
  platform:
  - net462
- uid: System.EnterpriseServices.Internal.Publish.#ctor
  id: '#ctor'
  parent: System.EnterpriseServices.Internal.Publish
  langs:
  - csharp
  name: Publish()
  nameWithType: Publish.Publish()
  fullName: System.EnterpriseServices.Internal.Publish.Publish()
  type: Constructor
  assemblies:
  - System.EnterpriseServices
  namespace: System.EnterpriseServices.Internal
  summary: "初始化的新实例<xref href=&quot;System.EnterpriseServices.Internal.Publish&quot;></xref>类。"
  syntax:
    content: public Publish ();
    parameters: []
  overload: System.EnterpriseServices.Internal.Publish.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.EnterpriseServices.Internal.Publish.CreateMailBox(System.String,System.String,System.String@,System.String@,System.String@,System.String@)
  id: CreateMailBox(System.String,System.String,System.String@,System.String@,System.String@,System.String@)
  parent: System.EnterpriseServices.Internal.Publish
  langs:
  - csharp
  name: CreateMailBox(String,String,String,String,String,String)
  nameWithType: Publish.CreateMailBox(String,String,String,String,String,String)
  fullName: System.EnterpriseServices.Internal.Publish.CreateMailBox(String,String,String,String,String,String)
  type: Method
  assemblies:
  - System.EnterpriseServices
  namespace: System.EnterpriseServices.Internal
  summary: "在指定的 URL 创建 SOAP 启用 COM + 应用程序邮箱。 未完全实现。"
  remarks: "未完全实现;不会创建邮箱。 返回的错误消息&quot;COM + SOAP 服务不支持 SMTP 发布。&quot;"
  syntax:
    content: public void CreateMailBox (string RootMailServer, string MailBox, out string SmtpName, out string Domain, out string PhysicalPath, out string Error);
    parameters:
    - id: RootMailServer
      type: System.String
      description: "根邮件服务器的 URL。"
    - id: MailBox
      type: System.String
      description: "要创建的邮箱。"
    - id: SmtpName
      type: System.String
      description: "此方法返回时，此参数将包含包含邮箱的简单邮件传输协议 (SMTP) 服务器的名称。"
    - id: Domain
      type: System.String
      description: "此方法返回时，此参数将包含 SMTP 服务器的域。"
    - id: PhysicalPath
      type: System.String
      description: "此方法返回时，此参数将包含邮箱的文件系统路径。"
    - id: Error
      type: System.String
      description: "此方法返回时，此参数将包含一条错误消息，如果遇到了问题。"
  overload: System.EnterpriseServices.Internal.Publish.CreateMailBox*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "中的调用链的调用方没有访问非托管的代码的权限。"
  platform:
  - net462
- uid: System.EnterpriseServices.Internal.Publish.CreateVirtualRoot(System.String,System.String,System.String@,System.String@,System.String@,System.String@)
  id: CreateVirtualRoot(System.String,System.String,System.String@,System.String@,System.String@,System.String@)
  parent: System.EnterpriseServices.Internal.Publish
  langs:
  - csharp
  name: CreateVirtualRoot(String,String,String,String,String,String)
  nameWithType: Publish.CreateVirtualRoot(String,String,String,String,String,String)
  fullName: System.EnterpriseServices.Internal.Publish.CreateVirtualRoot(String,String,String,String,String,String)
  type: Method
  assemblies:
  - System.EnterpriseServices
  namespace: System.EnterpriseServices.Internal
  summary: "创建一个 SOAP 启用 COM + 应用程序虚拟根目录。"
  remarks: "建议<xref:System.EnterpriseServices.Internal.SoapServerVRoot.CreateVirtualRootEx%2A>代替 CreateVirtualRoot。</xref:System.EnterpriseServices.Internal.SoapServerVRoot.CreateVirtualRootEx%2A>"
  syntax:
    content: public void CreateVirtualRoot (string Operation, string FullUrl, out string BaseUrl, out string VirtualRoot, out string PhysicalPath, out string Error);
    parameters:
    - id: Operation
      type: System.String
      description: "要执行的操作。"
    - id: FullUrl
      type: System.String
      description: "为虚拟根目录完整 URL 地址。"
    - id: BaseUrl
      type: System.String
      description: "此方法返回时，此参数将包含基 URL 地址。"
    - id: VirtualRoot
      type: System.String
      description: "此方法返回时，此参数将包含虚拟根目录的名称。"
    - id: PhysicalPath
      type: System.String
      description: "此方法返回时，此参数将包含的虚拟根目录的文件路径。"
    - id: Error
      type: System.String
      description: "此方法返回时，此参数将包含一条错误消息，如果遇到了问题。"
  overload: System.EnterpriseServices.Internal.Publish.CreateVirtualRoot*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "中的调用链的调用方没有访问非托管的代码的权限。       -或者-调用方有权访问的 DNS 信息。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>FullUrl</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "在本地主机名解析时遇到错误。"
  - type: System.UriFormatException
    commentId: T:System.UriFormatException
    description: "<code>FullUrl</code>为空。       -中指定的方案<code>FullUrl</code>无效。       -或-<code>FullUrl</code>包含两个以上连续的斜杠。       -中指定的密码<code>FullUrl</code>无效。       -或-中指定的主机名<code>FullUrl</code>无效。       -或-中指定的文件名称<code>FullUrl</code>无效。"
  platform:
  - net462
- uid: System.EnterpriseServices.Internal.Publish.DeleteMailBox(System.String,System.String,System.String@)
  id: DeleteMailBox(System.String,System.String,System.String@)
  parent: System.EnterpriseServices.Internal.Publish
  langs:
  - csharp
  name: DeleteMailBox(String,String,String)
  nameWithType: Publish.DeleteMailBox(String,String,String)
  fullName: System.EnterpriseServices.Internal.Publish.DeleteMailBox(String,String,String)
  type: Method
  assemblies:
  - System.EnterpriseServices
  namespace: System.EnterpriseServices.Internal
  summary: "删除 SOAP 启用 COM + 应用程序邮箱在指定的 URL。 未完全实现。"
  remarks: "未完全实现，不会删除邮箱。 返回的错误消息&quot;COM + SOAP 服务不支持 SMTP 发布。&quot;"
  syntax:
    content: public void DeleteMailBox (string RootMailServer, string MailBox, out string Error);
    parameters:
    - id: RootMailServer
      type: System.String
      description: "根邮件服务器的 URL。"
    - id: MailBox
      type: System.String
      description: "要删除的邮箱。"
    - id: Error
      type: System.String
      description: "此方法返回时，此参数将包含一条错误消息，如果遇到了问题。"
  overload: System.EnterpriseServices.Internal.Publish.DeleteMailBox*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "中的调用链的调用方没有访问非托管的代码的权限。"
  platform:
  - net462
- uid: System.EnterpriseServices.Internal.Publish.DeleteVirtualRoot(System.String,System.String,System.String@)
  id: DeleteVirtualRoot(System.String,System.String,System.String@)
  parent: System.EnterpriseServices.Internal.Publish
  langs:
  - csharp
  name: DeleteVirtualRoot(String,String,String)
  nameWithType: Publish.DeleteVirtualRoot(String,String,String)
  fullName: System.EnterpriseServices.Internal.Publish.DeleteVirtualRoot(String,String,String)
  type: Method
  assemblies:
  - System.EnterpriseServices
  namespace: System.EnterpriseServices.Internal
  summary: "删除 SOAP 启用 COM + 应用程序虚拟根目录。 未完全实现。"
  remarks: "DeleteVirtualRoot 的功能尚不可用。      1> [!CAUTION]&1;> 方法当前返回且未发生错误，但不是会删除的虚拟根目录。       如果功能变为可用，建议的方法将<xref:System.EnterpriseServices.Internal.SoapServerVRoot.DeleteVirtualRootEx%2A>.</xref:System.EnterpriseServices.Internal.SoapServerVRoot.DeleteVirtualRootEx%2A>"
  syntax:
    content: public void DeleteVirtualRoot (string RootWebServer, string FullUrl, out string Error);
    parameters:
    - id: RootWebServer
      type: System.String
      description: "根 Web 服务器。"
    - id: FullUrl
      type: System.String
      description: "为虚拟根目录完整 URL 地址。"
    - id: Error
      type: System.String
      description: "此方法返回时，此参数将包含一条错误消息，如果遇到了问题。"
  overload: System.EnterpriseServices.Internal.Publish.DeleteVirtualRoot*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "中的调用链的调用方没有访问非托管的代码的权限。"
  platform:
  - net462
- uid: System.EnterpriseServices.Internal.Publish.GacInstall(System.String)
  id: GacInstall(System.String)
  parent: System.EnterpriseServices.Internal.Publish
  langs:
  - csharp
  name: GacInstall(String)
  nameWithType: Publish.GacInstall(String)
  fullName: System.EnterpriseServices.Internal.Publish.GacInstall(String)
  type: Method
  assemblies:
  - System.EnterpriseServices
  namespace: System.EnterpriseServices.Internal
  summary: "将程序集安装在全局程序集缓存中。"
  syntax:
    content: public void GacInstall (string AssemblyPath);
    parameters:
    - id: AssemblyPath
      type: System.String
      description: "程序集文件系统路径。"
  overload: System.EnterpriseServices.Internal.Publish.GacInstall*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "中的调用链的调用方没有访问非托管的代码的权限。"
  platform:
  - net462
- uid: System.EnterpriseServices.Internal.Publish.GacRemove(System.String)
  id: GacRemove(System.String)
  parent: System.EnterpriseServices.Internal.Publish
  langs:
  - csharp
  name: GacRemove(String)
  nameWithType: Publish.GacRemove(String)
  fullName: System.EnterpriseServices.Internal.Publish.GacRemove(String)
  type: Method
  assemblies:
  - System.EnterpriseServices
  namespace: System.EnterpriseServices.Internal
  summary: "从全局程序集缓存中移除程序集。"
  syntax:
    content: public void GacRemove (string AssemblyPath);
    parameters:
    - id: AssemblyPath
      type: System.String
      description: "程序集文件系统路径。"
  overload: System.EnterpriseServices.Internal.Publish.GacRemove*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "中的调用链的调用方没有访问非托管的代码的权限。       -或者-调用方没有路径发现权限。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>AssemblyPath</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>AssemblyPath</code>为空。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>AssemblyPath</code>未找到。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>AssemblyPath</code>不是有效的程序集。"
  platform:
  - net462
- uid: System.EnterpriseServices.Internal.Publish.GetAssemblyNameForCache(System.String,System.String@)
  id: GetAssemblyNameForCache(System.String,System.String@)
  parent: System.EnterpriseServices.Internal.Publish
  langs:
  - csharp
  name: GetAssemblyNameForCache(String,String)
  nameWithType: Publish.GetAssemblyNameForCache(String,String)
  fullName: System.EnterpriseServices.Internal.Publish.GetAssemblyNameForCache(String,String)
  type: Method
  assemblies:
  - System.EnterpriseServices
  namespace: System.EnterpriseServices.Internal
  summary: "返回具有强名称签名生成的程序集 SoapCache 目录中的完整路径。"
  remarks: "对于非托管 COM + 组件以通过 SOAP 终结点的.NET 远程处理发布，代理需要生成可向.NET Framework 提供的非托管的组件。 这可通过以编程方式执行与类型库导入程序 (Tlbimp.exe) 相同的步骤[!INCLUDE[winsdklong](~/add/includes/winsdklong-md.md)]工具，用于将非托管的 COM + 类型库转换为代理元数据程序集。 但是，对于通过 SOAP 成功的客户端激活，客户端和服务器计算机必须共享相同的强名称签名的元数据代理服务器。 因此，托管的代理程序集生成的非托管的 COM + 组件时强名称密钥还生成和用于对代理程序集进行签名。"
  syntax:
    content: public void GetAssemblyNameForCache (string TypeLibPath, out string CachePath);
    parameters:
    - id: TypeLibPath
      type: System.String
      description: "包含类型库文件的路径。"
    - id: CachePath
      type: System.String
      description: "此方法返回时，此参数将包含 SoapCache 目录的名称。"
  overload: System.EnterpriseServices.Internal.Publish.GetAssemblyNameForCache*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>TypeLibPath</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有所要求的权限。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "文件名称为空，仅包含空格，或包含无效字符。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "访问<code> TypeLibPath </code>被拒绝。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路径和 / 或文件名超过了系统定义的最大长度。 例如，在基于 Windows 的平台上，路径必须少于 248 个字符，文件名必须少于 260 个字符。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>TypeLibPath</code>包含在字符串中间一个冒号 （:）。"
  platform:
  - net462
- uid: System.EnterpriseServices.Internal.Publish.GetClientPhysicalPath(System.Boolean)
  id: GetClientPhysicalPath(System.Boolean)
  parent: System.EnterpriseServices.Internal.Publish
  langs:
  - csharp
  name: GetClientPhysicalPath(Boolean)
  nameWithType: Publish.GetClientPhysicalPath(Boolean)
  fullName: System.EnterpriseServices.Internal.Publish.GetClientPhysicalPath(Boolean)
  type: Method
  assemblies:
  - System.EnterpriseServices
  namespace: System.EnterpriseServices.Internal
  summary: "返回用于存储客户端配置文件的目录的路径。"
  remarks: "创建目录&quot;\\com\\SOAPAssembly\\&quot;系统目录下。"
  syntax:
    content: public static string GetClientPhysicalPath (bool CreateDir);
    parameters:
    - id: CreateDir
      type: System.Boolean
      description: "设置为<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>创建目录，或<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>若要返回的路径，但不是创建目录。"
    return:
      type: System.String
      description: "要包含的配置文件的目录路径。"
  overload: System.EnterpriseServices.Internal.Publish.GetClientPhysicalPath*
  exceptions:
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "调用方没有所要求的权限。"
  platform:
  - net462
- uid: System.EnterpriseServices.Internal.Publish.GetTypeNameFromProgId(System.String,System.String)
  id: GetTypeNameFromProgId(System.String,System.String)
  parent: System.EnterpriseServices.Internal.Publish
  langs:
  - csharp
  name: GetTypeNameFromProgId(String,String)
  nameWithType: Publish.GetTypeNameFromProgId(String,String)
  fullName: System.EnterpriseServices.Internal.Publish.GetTypeNameFromProgId(String,String)
  type: Method
  assemblies:
  - System.EnterpriseServices
  namespace: System.EnterpriseServices.Internal
  summary: "反映程序集，并返回与匹配 ProgID 的类型名称。"
  syntax:
    content: public string GetTypeNameFromProgId (string AssemblyPath, string ProgId);
    parameters:
    - id: AssemblyPath
      type: System.String
      description: "程序集文件系统路径。"
    - id: ProgId
      type: System.String
      description: "类的编程标识符。"
    return:
      type: System.String
      description: "与匹配 ProgID 的类型名称。"
  overload: System.EnterpriseServices.Internal.Publish.GetTypeNameFromProgId*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "中的调用链的调用方没有访问非托管的代码的权限。"
  platform:
  - net462
- uid: System.EnterpriseServices.Internal.Publish.ParseUrl(System.String,System.String@,System.String@)
  id: ParseUrl(System.String,System.String@,System.String@)
  parent: System.EnterpriseServices.Internal.Publish
  langs:
  - csharp
  name: ParseUrl(String,String,String)
  nameWithType: Publish.ParseUrl(String,String,String)
  fullName: System.EnterpriseServices.Internal.Publish.ParseUrl(String,String,String)
  type: Method
  assemblies:
  - System.EnterpriseServices
  namespace: System.EnterpriseServices.Internal
  summary: "分析 URL 并返回基 URL 和虚拟根部分。"
  syntax:
    content: public static void ParseUrl (string FullUrl, out string BaseUrl, out string VirtualRoot);
    parameters:
    - id: FullUrl
      type: System.String
      description: "为虚拟根目录完整 URL 地址。"
    - id: BaseUrl
      type: System.String
      description: "此方法返回时，此参数将包含基 URL 地址。"
    - id: VirtualRoot
      type: System.String
      description: "此方法返回时，此参数将包含虚拟根目录的名称。"
  overload: System.EnterpriseServices.Internal.Publish.ParseUrl*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>FullUrl</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "在本地主机名解析时遇到错误。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "调用方没有权限访问 DNS 信息。"
  - type: System.UriFormatException
    commentId: T:System.UriFormatException
    description: "<code>FullUrl</code>为空。       -中指定的方案<code>FullUrl</code>无效。       -或-<code>FullUrl</code>包含过多斜杠。       -中指定的密码<code>FullUrl</code>无效。       -或-中指定的主机名<code>FullUrl</code>无效。       -或-中指定的文件名称<code>FullUrl</code>无效。"
  platform:
  - net462
- uid: System.EnterpriseServices.Internal.Publish.ProcessClientTlb(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)
  id: ProcessClientTlb(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)
  parent: System.EnterpriseServices.Internal.Publish
  langs:
  - csharp
  name: ProcessClientTlb(String,String,String,String,String,String,String,String,String,String)
  nameWithType: Publish.ProcessClientTlb(String,String,String,String,String,String,String,String,String,String)
  fullName: System.EnterpriseServices.Internal.Publish.ProcessClientTlb(String,String,String,String,String,String,String,String,String,String)
  type: Method
  assemblies:
  - System.EnterpriseServices
  namespace: System.EnterpriseServices.Internal
  summary: "处理客户端类型库，创建客户端上的配置文件。"
  remarks: "此方法在客户端代理导入用于生成远程处理配置文件。       如果`Mode`参数为&quot;wellknownobject&quot;或空字符串 (&quot;&quot;)，则假定的已知对象;否则，将假定客户端激活。       建议<xref:System.EnterpriseServices.Internal.SoapClientImport.ProcessClientTlbEx%2A>代替 ProcessClientTlb。</xref:System.EnterpriseServices.Internal.SoapClientImport.ProcessClientTlbEx%2A>"
  syntax:
    content: public void ProcessClientTlb (string ProgId, string SrcTlbPath, string PhysicalPath, string VRoot, string BaseUrl, string Mode, string Transport, out string AssemblyName, out string TypeName, out string Error);
    parameters:
    - id: ProgId
      type: System.String
      description: "类的编程标识符。"
    - id: SrcTlbPath
      type: System.String
      description: "包含类型库文件的路径。"
    - id: PhysicalPath
      type: System.String
      description: "Web 应用程序目录。"
    - id: VRoot
      type: System.String
      description: "虚拟根目录的名称。"
    - id: BaseUrl
      type: System.String
      description: "包含的虚拟根目录的基 URL。"
    - id: Mode
      type: System.String
      description: "激活模式中。"
    - id: Transport
      type: System.String
      description: "未使用。 指定<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>为此参数。"
    - id: AssemblyName
      type: System.String
      description: "此方法返回时，此参数将包含程序集的显示名称。"
    - id: TypeName
      type: System.String
      description: "此方法返回时，此参数将包含程序集的完全限定的类型名称。"
    - id: Error
      type: System.String
      description: "此方法返回时，此参数将包含一条错误消息，如果遇到了问题。"
  overload: System.EnterpriseServices.Internal.Publish.ProcessClientTlb*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "中的调用链的调用方没有访问非托管的代码的权限。"
  platform:
  - net462
- uid: System.EnterpriseServices.Internal.Publish.ProcessServerTlb(System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)
  id: ProcessServerTlb(System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)
  parent: System.EnterpriseServices.Internal.Publish
  langs:
  - csharp
  name: ProcessServerTlb(String,String,String,String,String,String,String)
  nameWithType: Publish.ProcessServerTlb(String,String,String,String,String,String,String)
  fullName: System.EnterpriseServices.Internal.Publish.ProcessServerTlb(String,String,String,String,String,String,String)
  type: Method
  assemblies:
  - System.EnterpriseServices
  namespace: System.EnterpriseServices.Internal
  summary: "处理服务器类型库，添加或删除组件的 Web.config 和 Default.disco 文件条目。 如有必要，则生成代理。"
  remarks: "ProcessServerTlb 将条目添加到发现文件和 web.config 文件中的组件类型库，并生成或将代理复制到非托管组件的 bin 目录。 如果`Operation`等于&quot;删除&quot;，然后从 Web.config 和 Default.disco 文件中删除组件条目。       建议<xref:System.EnterpriseServices.Internal.SoapServerTlb.AddServerTlb%2A>和<xref:System.EnterpriseServices.Internal.SoapServerTlb.DeleteServerTlb%2A>代替 ProcessServerTlb。</xref:System.EnterpriseServices.Internal.SoapServerTlb.DeleteServerTlb%2A> </xref:System.EnterpriseServices.Internal.SoapServerTlb.AddServerTlb%2A>"
  syntax:
    content: public void ProcessServerTlb (string ProgId, string SrcTlbPath, string PhysicalPath, string Operation, out string strAssemblyName, out string TypeName, out string Error);
    parameters:
    - id: ProgId
      type: System.String
      description: "类的编程标识符。"
    - id: SrcTlbPath
      type: System.String
      description: "包含类型库文件的路径。"
    - id: PhysicalPath
      type: System.String
      description: "Web 应用程序目录。"
    - id: Operation
      type: System.String
      description: "要执行的操作。"
    - id: strAssemblyName
      type: System.String
      description: "此方法返回时，此参数将包含程序集的显示名称。"
    - id: TypeName
      type: System.String
      description: "此方法返回时，此参数将包含程序集的完全限定的类型名称。"
    - id: Error
      type: System.String
      description: "此方法返回时，此参数将包含一条错误消息，如果遇到了问题。"
  overload: System.EnterpriseServices.Internal.Publish.ProcessServerTlb*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "中的调用链的调用方没有访问非托管的代码的权限。"
  - type: System.EnterpriseServices.ServicedComponentException
    commentId: T:System.EnterpriseServices.ServicedComponentException
    description: "<code> SrcTlbPath </code>参数引用 scrobj.dll; 因此，不支持 SOAP 发布的脚本组件。"
  platform:
  - net462
- uid: System.EnterpriseServices.Internal.Publish.RegisterAssembly(System.String)
  id: RegisterAssembly(System.String)
  parent: System.EnterpriseServices.Internal.Publish
  langs:
  - csharp
  name: RegisterAssembly(String)
  nameWithType: Publish.RegisterAssembly(String)
  fullName: System.EnterpriseServices.Internal.Publish.RegisterAssembly(String)
  type: Method
  assemblies:
  - System.EnterpriseServices
  namespace: System.EnterpriseServices.Internal
  summary: "注册为 COM 互操作程序集。"
  remarks: "RegisterAssembly 使用程序集注册工具 (Regasm.exe) 来注册程序集中的可创建类。 有关详细信息，请参阅[Regasm.exe （程序集注册工具）](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public void RegisterAssembly (string AssemblyPath);
    parameters:
    - id: AssemblyPath
      type: System.String
      description: "程序集文件系统路径。"
  overload: System.EnterpriseServices.Internal.Publish.RegisterAssembly*
  exceptions:
  - type: System.EnterpriseServices.RegistrationException
    commentId: T:System.EnterpriseServices.RegistrationException
    description: "输入程序集没有强名称。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "中的调用链的调用方没有访问非托管的代码的权限。       -或-指定了不以&quot;file://&quot;开头的基本代码且没有所需<xref href=&quot;System.Net.WebPermission&quot;> </xref>。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>AssemblyPath</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>AssemblyPath</code>未找到，或未指定文件扩展名。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>AssemblyPath</code>不是有效的程序集。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块或程序集名称的长度超过 MAX_PATH 个字符。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "方法标记为<xref href=&quot;System.Runtime.InteropServices.ComUnregisterFunctionAttribute&quot;></xref>不<xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref>。       -或-没有标有多个方法<xref href=&quot;System.Runtime.InteropServices.ComUnregisterFunctionAttribute&quot;></xref>在给定级别的层次结构。       -或-方法的签名标有<xref href=&quot;System.Runtime.InteropServices.ComUnregisterFunctionAttribute&quot;></xref>无效。"
  platform:
  - net462
- uid: System.EnterpriseServices.Internal.Publish.UnRegisterAssembly(System.String)
  id: UnRegisterAssembly(System.String)
  parent: System.EnterpriseServices.Internal.Publish
  langs:
  - csharp
  name: UnRegisterAssembly(String)
  nameWithType: Publish.UnRegisterAssembly(String)
  fullName: System.EnterpriseServices.Internal.Publish.UnRegisterAssembly(String)
  type: Method
  assemblies:
  - System.EnterpriseServices
  namespace: System.EnterpriseServices.Internal
  summary: "注销 COM 互操作程序集。"
  remarks: "UnRegisterAssembly 使用 Regasm.exe 来注销程序集中的可创建类。 有关详细信息，请参阅[Regasm.exe （程序集注册工具）](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public void UnRegisterAssembly (string AssemblyPath);
    parameters:
    - id: AssemblyPath
      type: System.String
      description: "程序集文件系统路径。"
  overload: System.EnterpriseServices.Internal.Publish.UnRegisterAssembly*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "中的调用链的调用方没有访问非托管的代码的权限。       -或-指定了不以&quot;file://&quot;开头的基本代码且没有所需<xref href=&quot;System.Net.WebPermission&quot;> </xref>。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>AssemblyPath</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>AssemblyPath</code>未找到，或未指定文件扩展名。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>AssemblyPath</code>不是有效的程序集。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "两次用两个不同的证据加载了一个程序集或模块或程序集名称的长度超过 MAX_PATH 个字符。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "方法标记为<xref href=&quot;System.Runtime.InteropServices.ComUnregisterFunctionAttribute&quot;></xref>不<xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref>。       -或-没有标有多个方法<xref href=&quot;System.Runtime.InteropServices.ComUnregisterFunctionAttribute&quot;></xref>在给定级别的层次结构。       -或-方法的签名标有<xref href=&quot;System.Runtime.InteropServices.ComUnregisterFunctionAttribute&quot;></xref>无效。"
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.Net.Sockets.SocketException
  isExternal: true
  name: System.Net.Sockets.SocketException
- uid: System.UriFormatException
  isExternal: true
  name: System.UriFormatException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.FileLoadException
  isExternal: true
  name: System.IO.FileLoadException
- uid: System.BadImageFormatException
  isExternal: true
  name: System.BadImageFormatException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.IO.PathTooLongException
  isExternal: true
  name: System.IO.PathTooLongException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.EnterpriseServices.ServicedComponentException
  parent: System.EnterpriseServices
  isExternal: false
  name: ServicedComponentException
  nameWithType: ServicedComponentException
  fullName: System.EnterpriseServices.ServicedComponentException
- uid: System.EnterpriseServices.RegistrationException
  parent: System.EnterpriseServices
  isExternal: false
  name: RegistrationException
  nameWithType: RegistrationException
  fullName: System.EnterpriseServices.RegistrationException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.EnterpriseServices.Internal.Publish.#ctor
  parent: System.EnterpriseServices.Internal.Publish
  isExternal: false
  name: Publish()
  nameWithType: Publish.Publish()
  fullName: System.EnterpriseServices.Internal.Publish.Publish()
- uid: System.EnterpriseServices.Internal.Publish.CreateMailBox(System.String,System.String,System.String@,System.String@,System.String@,System.String@)
  parent: System.EnterpriseServices.Internal.Publish
  isExternal: false
  name: CreateMailBox(String,String,String,String,String,String)
  nameWithType: Publish.CreateMailBox(String,String,String,String,String,String)
  fullName: System.EnterpriseServices.Internal.Publish.CreateMailBox(String,String,String,String,String,String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.EnterpriseServices.Internal.Publish.CreateVirtualRoot(System.String,System.String,System.String@,System.String@,System.String@,System.String@)
  parent: System.EnterpriseServices.Internal.Publish
  isExternal: false
  name: CreateVirtualRoot(String,String,String,String,String,String)
  nameWithType: Publish.CreateVirtualRoot(String,String,String,String,String,String)
  fullName: System.EnterpriseServices.Internal.Publish.CreateVirtualRoot(String,String,String,String,String,String)
- uid: System.EnterpriseServices.Internal.Publish.DeleteMailBox(System.String,System.String,System.String@)
  parent: System.EnterpriseServices.Internal.Publish
  isExternal: false
  name: DeleteMailBox(String,String,String)
  nameWithType: Publish.DeleteMailBox(String,String,String)
  fullName: System.EnterpriseServices.Internal.Publish.DeleteMailBox(String,String,String)
- uid: System.EnterpriseServices.Internal.Publish.DeleteVirtualRoot(System.String,System.String,System.String@)
  parent: System.EnterpriseServices.Internal.Publish
  isExternal: false
  name: DeleteVirtualRoot(String,String,String)
  nameWithType: Publish.DeleteVirtualRoot(String,String,String)
  fullName: System.EnterpriseServices.Internal.Publish.DeleteVirtualRoot(String,String,String)
- uid: System.EnterpriseServices.Internal.Publish.GacInstall(System.String)
  parent: System.EnterpriseServices.Internal.Publish
  isExternal: false
  name: GacInstall(String)
  nameWithType: Publish.GacInstall(String)
  fullName: System.EnterpriseServices.Internal.Publish.GacInstall(String)
- uid: System.EnterpriseServices.Internal.Publish.GacRemove(System.String)
  parent: System.EnterpriseServices.Internal.Publish
  isExternal: false
  name: GacRemove(String)
  nameWithType: Publish.GacRemove(String)
  fullName: System.EnterpriseServices.Internal.Publish.GacRemove(String)
- uid: System.EnterpriseServices.Internal.Publish.GetAssemblyNameForCache(System.String,System.String@)
  parent: System.EnterpriseServices.Internal.Publish
  isExternal: false
  name: GetAssemblyNameForCache(String,String)
  nameWithType: Publish.GetAssemblyNameForCache(String,String)
  fullName: System.EnterpriseServices.Internal.Publish.GetAssemblyNameForCache(String,String)
- uid: System.EnterpriseServices.Internal.Publish.GetClientPhysicalPath(System.Boolean)
  parent: System.EnterpriseServices.Internal.Publish
  isExternal: false
  name: GetClientPhysicalPath(Boolean)
  nameWithType: Publish.GetClientPhysicalPath(Boolean)
  fullName: System.EnterpriseServices.Internal.Publish.GetClientPhysicalPath(Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.EnterpriseServices.Internal.Publish.GetTypeNameFromProgId(System.String,System.String)
  parent: System.EnterpriseServices.Internal.Publish
  isExternal: false
  name: GetTypeNameFromProgId(String,String)
  nameWithType: Publish.GetTypeNameFromProgId(String,String)
  fullName: System.EnterpriseServices.Internal.Publish.GetTypeNameFromProgId(String,String)
- uid: System.EnterpriseServices.Internal.Publish.ParseUrl(System.String,System.String@,System.String@)
  parent: System.EnterpriseServices.Internal.Publish
  isExternal: false
  name: ParseUrl(String,String,String)
  nameWithType: Publish.ParseUrl(String,String,String)
  fullName: System.EnterpriseServices.Internal.Publish.ParseUrl(String,String,String)
- uid: System.EnterpriseServices.Internal.Publish.ProcessClientTlb(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)
  parent: System.EnterpriseServices.Internal.Publish
  isExternal: false
  name: ProcessClientTlb(String,String,String,String,String,String,String,String,String,String)
  nameWithType: Publish.ProcessClientTlb(String,String,String,String,String,String,String,String,String,String)
  fullName: System.EnterpriseServices.Internal.Publish.ProcessClientTlb(String,String,String,String,String,String,String,String,String,String)
- uid: System.EnterpriseServices.Internal.Publish.ProcessServerTlb(System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)
  parent: System.EnterpriseServices.Internal.Publish
  isExternal: false
  name: ProcessServerTlb(String,String,String,String,String,String,String)
  nameWithType: Publish.ProcessServerTlb(String,String,String,String,String,String,String)
  fullName: System.EnterpriseServices.Internal.Publish.ProcessServerTlb(String,String,String,String,String,String,String)
- uid: System.EnterpriseServices.Internal.Publish.RegisterAssembly(System.String)
  parent: System.EnterpriseServices.Internal.Publish
  isExternal: false
  name: RegisterAssembly(String)
  nameWithType: Publish.RegisterAssembly(String)
  fullName: System.EnterpriseServices.Internal.Publish.RegisterAssembly(String)
- uid: System.EnterpriseServices.Internal.Publish.UnRegisterAssembly(System.String)
  parent: System.EnterpriseServices.Internal.Publish
  isExternal: false
  name: UnRegisterAssembly(String)
  nameWithType: Publish.UnRegisterAssembly(String)
  fullName: System.EnterpriseServices.Internal.Publish.UnRegisterAssembly(String)
- uid: System.EnterpriseServices.Internal.Publish.#ctor*
  parent: System.EnterpriseServices.Internal.Publish
  isExternal: false
  name: Publish
  nameWithType: Publish.Publish
- uid: System.EnterpriseServices.Internal.Publish.CreateMailBox*
  parent: System.EnterpriseServices.Internal.Publish
  isExternal: false
  name: CreateMailBox
  nameWithType: Publish.CreateMailBox
- uid: System.EnterpriseServices.Internal.Publish.CreateVirtualRoot*
  parent: System.EnterpriseServices.Internal.Publish
  isExternal: false
  name: CreateVirtualRoot
  nameWithType: Publish.CreateVirtualRoot
- uid: System.EnterpriseServices.Internal.Publish.DeleteMailBox*
  parent: System.EnterpriseServices.Internal.Publish
  isExternal: false
  name: DeleteMailBox
  nameWithType: Publish.DeleteMailBox
- uid: System.EnterpriseServices.Internal.Publish.DeleteVirtualRoot*
  parent: System.EnterpriseServices.Internal.Publish
  isExternal: false
  name: DeleteVirtualRoot
  nameWithType: Publish.DeleteVirtualRoot
- uid: System.EnterpriseServices.Internal.Publish.GacInstall*
  parent: System.EnterpriseServices.Internal.Publish
  isExternal: false
  name: GacInstall
  nameWithType: Publish.GacInstall
- uid: System.EnterpriseServices.Internal.Publish.GacRemove*
  parent: System.EnterpriseServices.Internal.Publish
  isExternal: false
  name: GacRemove
  nameWithType: Publish.GacRemove
- uid: System.EnterpriseServices.Internal.Publish.GetAssemblyNameForCache*
  parent: System.EnterpriseServices.Internal.Publish
  isExternal: false
  name: GetAssemblyNameForCache
  nameWithType: Publish.GetAssemblyNameForCache
- uid: System.EnterpriseServices.Internal.Publish.GetClientPhysicalPath*
  parent: System.EnterpriseServices.Internal.Publish
  isExternal: false
  name: GetClientPhysicalPath
  nameWithType: Publish.GetClientPhysicalPath
- uid: System.EnterpriseServices.Internal.Publish.GetTypeNameFromProgId*
  parent: System.EnterpriseServices.Internal.Publish
  isExternal: false
  name: GetTypeNameFromProgId
  nameWithType: Publish.GetTypeNameFromProgId
- uid: System.EnterpriseServices.Internal.Publish.ParseUrl*
  parent: System.EnterpriseServices.Internal.Publish
  isExternal: false
  name: ParseUrl
  nameWithType: Publish.ParseUrl
- uid: System.EnterpriseServices.Internal.Publish.ProcessClientTlb*
  parent: System.EnterpriseServices.Internal.Publish
  isExternal: false
  name: ProcessClientTlb
  nameWithType: Publish.ProcessClientTlb
- uid: System.EnterpriseServices.Internal.Publish.ProcessServerTlb*
  parent: System.EnterpriseServices.Internal.Publish
  isExternal: false
  name: ProcessServerTlb
  nameWithType: Publish.ProcessServerTlb
- uid: System.EnterpriseServices.Internal.Publish.RegisterAssembly*
  parent: System.EnterpriseServices.Internal.Publish
  isExternal: false
  name: RegisterAssembly
  nameWithType: Publish.RegisterAssembly
- uid: System.EnterpriseServices.Internal.Publish.UnRegisterAssembly*
  parent: System.EnterpriseServices.Internal.Publish
  isExternal: false
  name: UnRegisterAssembly
  nameWithType: Publish.UnRegisterAssembly
